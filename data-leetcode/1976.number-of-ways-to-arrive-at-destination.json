[
    {
        "title": "Most Common Word",
        "question_content": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\n&nbsp;\nExample 1:\n\nInput: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.\n\nExample 2:\n\nInput: paragraph = \"a.\", banned = []\nOutput: \"a\"\n\n&nbsp;\nConstraints:\n\n\t1 <= paragraph.length <= 1000\n\tparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n\t0 <= banned.length <= 100\n\t1 <= banned[i].length <= 10\n\tbanned[i] consists of only lowercase English letters.",
        "solutions": [
            {
                "id": 123854,
                "title": "c-java-python-easy-solution-with-explanation",
                "content": "The description doesn\\'t clearify the case like \"word,word,word\".\\nAnd it doesn\\'t have this kind of corner cases at first.\\nThe test cases and OJ may not be perfect on this problem.\\n\\nAnyway I didn\\'t bother thinking this issue.\\nIn my opinion, the problem demands to extract words with only letters.\\nAll I did is just extract words with only letters.\\n\\n4 steps:\\n1. remove all punctuations\\n2. change to lowercase\\n3. words count for each word not in banned set\\n4. return the most common word\\n\\n**C++:**\\n```\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        unordered_map<string, int> count;\\n        for (auto & c: p) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(p);\\n        string w;\\n        pair<string, int> res (\"\", 0);\\n        while (iss >> w)\\n            if (ban.find(w) == ban.end() && ++count[w] > res.second)\\n                res = make_pair(w, count[w]);\\n        return res.first;\\n    }\\n```\\n**Java:**\\n```\\n    public String mostCommonWord(String p, String[] banned) {\\n        Set<String> ban = new HashSet<>(Arrays.asList(banned));\\n        Map<String, Integer> count = new HashMap<>();\\n        String[] words = p.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for (String w : words) if (!ban.contains(w)) count.put(w, count.getOrDefault(w, 0) + 1);\\n        return Collections.max(count.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n```\\n\\n**Python:**\\nThanks to @sirxudi I change one line from\\n`words = re.sub(r\\'[^a-zA-Z]\\', \\' \\', p).lower().split()`\\nto \\n`words = re.findall(r\\'\\\\w+\\', p.lower())\\n`\\n```\\n    def mostCommonWord(self, p, banned):\\n        ban = set(banned)\\n        words = re.findall(r\\'\\\\w+\\', p.lower())\\n        return collections.Counter(w for w in words if w not in ban).most_common(1)[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        unordered_map<string, int> count;\\n        for (auto & c: p) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(p);\\n        string w;\\n        pair<string, int> res (\"\", 0);\\n        while (iss >> w)\\n            if (ban.find(w) == ban.end() && ++count[w] > res.second)\\n                res = make_pair(w, count[w]);\\n        return res.first;\\n    }\\n```\n```\\n    public String mostCommonWord(String p, String[] banned) {\\n        Set<String> ban = new HashSet<>(Arrays.asList(banned));\\n        Map<String, Integer> count = new HashMap<>();\\n        String[] words = p.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for (String w : words) if (!ban.contains(w)) count.put(w, count.getOrDefault(w, 0) + 1);\\n        return Collections.max(count.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n```\n```\\n    def mostCommonWord(self, p, banned):\\n        ban = set(banned)\\n        words = re.findall(r\\'\\\\w+\\', p.lower())\\n        return collections.Counter(w for w in words if w not in ban).most_common(1)[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 124286,
                "title": "clean-6ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        for(int i = 0; i < paragraph.size();){\\n            string s = \"\";\\n            while(i < paragraph.size() && isalpha(paragraph[i])) s.push_back(tolower(paragraph[i++]));\\n            while(i < paragraph.size() && !isalpha(paragraph[i])) i++;\\n            m[s]++;\\n        }\\n        for(auto x: banned) m[x] = 0;\\n        string res = \"\";\\n        int count = 0;\\n        for(auto x: m)\\n            if(x.second > count) res = x.first, count = x.second;\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        for(int i = 0; i < paragraph.size();){\\n            string s = \"\";\\n            while(i < paragraph.size() && isalpha(paragraph[i])) s.push_back(tolower(paragraph[i++]));\\n            while(i < paragraph.size() && !isalpha(paragraph[i])) i++;\\n            m[s]++;\\n        }\\n        for(auto x: banned) m[x] = 0;\\n        string res = \"\";\\n        int count = 0;\\n        for(auto x: m)\\n            if(x.second > count) res = x.first, count = x.second;\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123973,
                "title": "simple-java-solution",
                "content": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph.toLowerCase().split(\"[ !?\\',;.]+\");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n        for(String word : banned) if(map.containsKey(word)) map.remove(word);\\n        String res = null;\\n        for(String word : map.keySet())\\n            if(res == null || map.get(word) > map.get(res))\\n                res = word;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph.toLowerCase().split(\"[ !?\\',;.]+\");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n        for(String word : banned) if(map.containsKey(word)) map.remove(word);\\n        String res = null;\\n        for(String word : map.keySet())\\n            if(res == null || map.get(word) > map.get(res))\\n                res = word;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168958,
                "title": "store-words-in-trie-6ms-beats-99-java",
                "content": "Instead of using Map, storing words in **Trie** (or called **Prefix Tree**) requires less memory space.\\n\\nEach node has 26 sub-nodes, \\n```\\nprivate class Trie {\\n    private Trie[] next = new Trie[26];    // sub nodes\\n    private int count;                     // word freqence\\n    private boolean ban;                   // banned?\\n}\\n```\\nThe path from root to a specific node represents a word. The following diagram contains 3 words: `[cat, do, dog]`.  The integer `count` note the frequence of that word. A third boolean field is used to distinct a normal word from banned one.\\n```bash\\n              root\\n             /     \\\\\\n          c | 0    d | 0\\n          /           \\\\\\n       a | 0          o | 1 [do]\\n        /                \\\\   \\n[cat]t | 1               g | 1 [dog]\\n```\\n\\nHere is my solution. 6ms, beats 99%.\\nTime Complexity: **O (N + M)**\\nSpace Complexity: **O (N + M)**\\nwhere, `N` is the number of characters in banned list, while `M` is thoes in paragraph.\\n\\n\\n```java\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Trie root = new Trie();\\n        Trie curr = root;\\n        // insert banned words into Trie\\n        for (String ban : banned) {\\n            for (int i = 0; i < ban.length(); i++) {\\n                int idx = ban.charAt(i) - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            curr.ban = true;\\n            curr = root;\\n        }\\n        int maxCount = 0;\\n        String mostFreqWord = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        char[] pArray = paragraph.toCharArray();\\n        // insert words in paragraph into Trie\\n        for (int start = 0, end = 0; start < pArray.length; start = end + 1) {\\n            // skip non-letter characters\\n            while (start < pArray.length && (pArray[start] < \\'a\\' || pArray[start] > \\'z\\')) { start++; }\\n            // insert consecutive letters(words) into Trie\\n            for (end = start; end < pArray.length && (pArray[end] >= \\'a\\' && pArray[end] <= \\'z\\'); end++) {\\n                int idx = pArray[end] - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            // update statistics\\n            if (curr != root && !curr.ban) {\\n                curr.count++;\\n                if (curr.count > maxCount) {\\n                    mostFreqWord = paragraph.substring(start, end);\\n                    maxCount = curr.count;\\n                }\\n            }\\n            curr = root;\\n        }\\n        return mostFreqWord;\\n    }\\n    // simplest Trie data structure\\n    private class Trie {\\n        private Trie[] next = new Trie[26];    // sub nodes\\n        private int count;                     // word freqence\\n        private boolean ban;                   // banned?\\n    }\\n}\\n```\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/helloshen/image_1536687882.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nprivate class Trie {\\n    private Trie[] next = new Trie[26];    // sub nodes\\n    private int count;                     // word freqence\\n    private boolean ban;                   // banned?\\n}\\n```\n```bash\\n              root\\n             /     \\\\\\n          c | 0    d | 0\\n          /           \\\\\\n       a | 0          o | 1 [do]\\n        /                \\\\   \\n[cat]t | 1               g | 1 [dog]\\n```\n```java\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Trie root = new Trie();\\n        Trie curr = root;\\n        // insert banned words into Trie\\n        for (String ban : banned) {\\n            for (int i = 0; i < ban.length(); i++) {\\n                int idx = ban.charAt(i) - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            curr.ban = true;\\n            curr = root;\\n        }\\n        int maxCount = 0;\\n        String mostFreqWord = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        char[] pArray = paragraph.toCharArray();\\n        // insert words in paragraph into Trie\\n        for (int start = 0, end = 0; start < pArray.length; start = end + 1) {\\n            // skip non-letter characters\\n            while (start < pArray.length && (pArray[start] < \\'a\\' || pArray[start] > \\'z\\')) { start++; }\\n            // insert consecutive letters(words) into Trie\\n            for (end = start; end < pArray.length && (pArray[end] >= \\'a\\' && pArray[end] <= \\'z\\'); end++) {\\n                int idx = pArray[end] - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            // update statistics\\n            if (curr != root && !curr.ban) {\\n                curr.count++;\\n                if (curr.count > maxCount) {\\n                    mostFreqWord = paragraph.substring(start, end);\\n                    maxCount = curr.count;\\n                }\\n            }\\n            curr = root;\\n        }\\n        return mostFreqWord;\\n    }\\n    // simplest Trie data structure\\n    private class Trie {\\n        private Trie[] next = new Trie[26];    // sub nodes\\n        private int count;                     // word freqence\\n        private boolean ban;                   // banned?\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216788,
                "title": "easy-python-solution",
                "content": "# \\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        for c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        d, res, count = {},\"\",0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue;\\n            elif word in d:\\n                d[word] += 1\\n            else:\\n                d[word] = 1\\n            if d[word] > count:\\n                count = d[word]\\n                res = word\\n        return res",
                "solutionTags": [],
                "code": "# \\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        for c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        d, res, count = {},\"\",0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue;\\n            elif word in d:\\n                d[word] += 1\\n            else:\\n                d[word] = 1\\n            if d[word] > count:\\n                count = d[word]\\n                res = word\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 411380,
                "title": "java-summary-of-usages-of-split-and-replace-vs-replaceall",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/most-common-word/)\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n## Problem\\n\\n> Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  **It is guaranteed there is at least one word that isn\\'t banned, and that the answer is unique.**\\n\\n> Words in the list of banned words are **given in lowercase**, and free of punctuation.  Words in the paragraph are not case sensitive. The answer is in **lowercase**.\\n\\n**Note:** \\n\\n- 1 <= `paragraph.length` <= 1000.\\n- 0 <= `banned.length` <= 100.\\n- 1 <= `banned[i].length` <= 10.\\n- The answer is unique, and written in lowercase (even if its occurrences in `paragraph` may have uppercase symbols, and even if it is a proper noun.)\\n- Paragraph only consists of `letters`, `spaces`, or the punctuation symbols `!?\\',;.`.\\n- There are no hyphens or hyphenated words.\\n- Words only consist of letters, never apostrophes or other punctuation symbols.\\n\\n**Example:** \\n\\n```java\\nInput: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\nbanned: [\"hit\"]\\nOutput:  \"ball\"\\n\\nInput: \"a, a, a, a, b,b,b,c, c\"\\nbanned: [\"a\"]\\nOutput: \"b\"\\n```\\n\\n\\n## Analysis\\n\\n### Hash Set + Hash Map\\n\\n**Note:** `str.split(\"\\\\\\\\s+\")` is equivalent to `str.split(\"\\\\\\\\s+\", 0)`. It means split the string for as many times as possible, and remove empty result `\"\"`. So `trim()` is not necessary here.\\n\\nOriginal code:\\n\\n```java\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n  String str = preprocess(paragraph);\\n  String[] words = str.split(\"\\\\\\\\s+\"); // split by one or more spaces\\n  // ban set\\n  Set<String> banSet = new HashSet<>();\\n  for (String s : banned) banSet.add(s);\\n  // count map\\n  Map<String, Integer> countMap = new HashMap<>();\\n  int maxCount = 0;\\n  for (String s : words) {\\n    if (banSet.contains(s)) continue;\\n    int count = countMap.getOrDefault(s, 0) + 1;\\n    maxCount = Math.max(maxCount, count);\\n    countMap.put(s, count);\\n  }\\n  // find the string with maxCount\\n  for (String s : countMap.keySet()) {\\n    if (countMap.get(s) == maxCount) {\\n      return s;\\n    }\\n  }\\n  return null;\\n}\\n```\\n\\nHere is the `preprocess` function:\\n\\n```java\\n// \"a, a, a, a, b,b,b,c, c\"\\n// [\"a\"]\\n// Output: \"b\"\\nprivate String preprocess(String s) {\\n  s = s.replace(\"!\", \" \"); // for \"a,a,a,,a\", we should replace by \" \" instead of \"\"\\n  s = s.replace(\"?\", \" \");\\n  s = s.replace(\"\\'\", \" \");\\n  s = s.replace(\",\", \" \");\\n  s = s.replace(\";\", \" \");\\n  s = s.replace(\".\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\\n\\nOr:\\n\\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\!|\\\\\\\\?|\\\\\\\\\\'|\\\\\\\\,|\\\\\\\\;|\\\\\\\\.\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\\n\\n**`replace()` vs. `replaceAll()`:**\\n\\n- `replace(char oldChar, char newChar)`\\n- `replace(CharSequence target, CharSequence replacement)`\\n- `replaceAll(String regex, String replacement)`\\n\\nNotice that they all replace all occurrences. `All` in the name of `replaceAll` doesn\\'t mean only it can replace all occurrences.\\n\\n\\nA succinct version:\\n\\n- `\\\\\\\\w+` matches all `alphanumeric` characters and `_`.\\n- `\\\\\\\\W+` matches all characters except `alphanumeric` characters and `_`.\\n- They are opposite.\\n\\n\\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\W+\", \" \");\\n  s = s.trim().toLowerCase();\\n}\\n```\\n\\nA more succinct version:\\n\\n```java\\nString[] words = s.toLowerCase().split(\"\\\\\\\\W+\"); // \"\\\\\\\\W+\" includes spaces\\n```\\n\\nRules about `split()`: [271. Encode and Decode Strings](http://junhaow.com/lc/problems/string/271_encode-and-decode-strings.html)\\n\\n\\n```java\\n\"..\".split(\"\\\\\\\\W+\", -1); // [\"\", \"\"]\\n\"..\".split(\"\\\\\\\\W+\", 0);  // []\\n\"..\".split(\"\\\\\\\\W+\", 1);  // [\"..\"]\\n\"..\".split(\"\\\\\\\\W+\", 2);  // [\"\", \"\"]\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nInput: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\nbanned: [\"hit\"]\\nOutput:  \"ball\"\\n\\nInput: \"a, a, a, a, b,b,b,c, c\"\\nbanned: [\"a\"]\\nOutput: \"b\"\\n```\n```java\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n  String str = preprocess(paragraph);\\n  String[] words = str.split(\"\\\\\\\\s+\"); // split by one or more spaces\\n  // ban set\\n  Set<String> banSet = new HashSet<>();\\n  for (String s : banned) banSet.add(s);\\n  // count map\\n  Map<String, Integer> countMap = new HashMap<>();\\n  int maxCount = 0;\\n  for (String s : words) {\\n    if (banSet.contains(s)) continue;\\n    int count = countMap.getOrDefault(s, 0) + 1;\\n    maxCount = Math.max(maxCount, count);\\n    countMap.put(s, count);\\n  }\\n  // find the string with maxCount\\n  for (String s : countMap.keySet()) {\\n    if (countMap.get(s) == maxCount) {\\n      return s;\\n    }\\n  }\\n  return null;\\n}\\n```\n```java\\n// \"a, a, a, a, b,b,b,c, c\"\\n// [\"a\"]\\n// Output: \"b\"\\nprivate String preprocess(String s) {\\n  s = s.replace(\"!\", \" \"); // for \"a,a,a,,a\", we should replace by \" \" instead of \"\"\\n  s = s.replace(\"?\", \" \");\\n  s = s.replace(\"\\'\", \" \");\\n  s = s.replace(\",\", \" \");\\n  s = s.replace(\";\", \" \");\\n  s = s.replace(\".\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\!|\\\\\\\\?|\\\\\\\\\\'|\\\\\\\\,|\\\\\\\\;|\\\\\\\\.\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\W+\", \" \");\\n  s = s.trim().toLowerCase();\\n}\\n```\n```java\\nString[] words = s.toLowerCase().split(\"\\\\\\\\W+\"); // \"\\\\\\\\W+\" includes spaces\\n```\n```java\\n\"..\".split(\"\\\\\\\\W+\", -1); // [\"\", \"\"]\\n\"..\".split(\"\\\\\\\\W+\", 0);  // []\\n\"..\".split(\"\\\\\\\\W+\", 1);  // [\"..\"]\\n\"..\".split(\"\\\\\\\\W+\", 2);  // [\"\", \"\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500772,
                "title": "python-3-three-lines-easy-and-explained",
                "content": "Runtime: 36 ms, faster than 40.27% of Python3 online submissions for Most Common Word.\\nMemory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Most Common Word.\\n\\n```Python 3\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\n\\t\\t# convert to lower case and split string into words by spaces and punctuation\\n        a = re.split(r\\'\\\\W+\\', paragraph.lower())\\n\\t\\t\\n\\t\\t# make new list consisitng of words not in banned list (remove banned words)\\n        b = [w for w in a if w not in banned]\\n\\t\\t\\n\\t\\t# return value that counted max times in the new list\\n        return max(b, key = b.count)\\n```\\n\\nPlease, upvote if you like it so that others can see and learn from it. Thanks!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python 3\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\n\\t\\t# convert to lower case and split string into words by spaces and punctuation\\n        a = re.split(r\\'\\\\W+\\', paragraph.lower())\\n\\t\\t\\n\\t\\t# make new list consisitng of words not in banned list (remove banned words)\\n        b = [w for w in a if w not in banned]\\n\\t\\t\\n\\t\\t# return value that counted max times in the new list\\n        return max(b, key = b.count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184971,
                "title": "c-4ms-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string res;\\n        unordered_map<string, int> count;\\n        \\n        // Step 1: remove punctuations and change to lower case;\\n        for(auto &c : paragraph)\\n            c =  isalpha(c)? tolower(c) : \\' \\'; \\n        \\n        // Step 2: count the frequency of every word\\n        istringstream iss(paragraph);\\n        string lower_word;\\n        while(iss >> lower_word)\\n            ++count[lower_word];  \\n    \\n        // Step 3: set the frequency of banned word to zero\\n        for(auto b : banned) count[b] = 0; \\n        \\n        // Step 4: get the word with highest frequency\\n        int max_count = 0;\\n        for(auto c : count){\\n            if(c.second > max_count){\\n                max_count = c.second;\\n                res = c.first;   \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string res;\\n        unordered_map<string, int> count;\\n        \\n        // Step 1: remove punctuations and change to lower case;\\n        for(auto &c : paragraph)\\n            c =  isalpha(c)? tolower(c) : \\' \\'; \\n        \\n        // Step 2: count the frequency of every word\\n        istringstream iss(paragraph);\\n        string lower_word;\\n        while(iss >> lower_word)\\n            ++count[lower_word];  \\n    \\n        // Step 3: set the frequency of banned word to zero\\n        for(auto b : banned) count[b] = 0; \\n        \\n        // Step 4: get the word with highest frequency\\n        int max_count = 0;\\n        for(auto c : count){\\n            if(c.second > max_count){\\n                max_count = c.second;\\n                res = c.first;   \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810141,
                "title": "c-super-short",
                "content": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\tfor(auto&c : paragraph)\\n\\t\\tc = ispunct(c) ? \\' \\' : tolower(c);\\n\\n\\tstring str, res;\\n\\tunordered_map<string, int> freq;\\n\\tunordered_set<string> b(banned.begin(), banned.end());\\n\\tstringstream ss(paragraph);\\n\\n\\twhile(ss>>str)\\n\\t\\tif(b.count(str)==0 && freq[res]<++freq[str]) \\n\\t\\t\\tres = str;\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\tfor(auto&c : paragraph)\\n\\t\\tc = ispunct(c) ? \\' \\' : tolower(c);\\n\\n\\tstring str, res;\\n\\tunordered_map<string, int> freq;\\n\\tunordered_set<string> b(banned.begin(), banned.end());\\n\\tstringstream ss(paragraph);\\n\\n\\twhile(ss>>str)\\n\\t\\tif(b.count(str)==0 && freq[res]<++freq[str]) \\n\\t\\t\\tres = str;\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335407,
                "title": "python-solution-using-max-and-key-function-16-ms",
                "content": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        dict = {}\\n        banned = set(banned)\\n        for c in \"!?\\',;.\":\\n            paragraph = paragraph.replace(c, \" \")\\n        paragraph = paragraph.lower().split()\\n\\n        for word in paragraph:            \\n            if word not in banned:\\n                if word in dict:\\n                    dict[word]+=1\\n                else:\\n                    dict[word]=1\\n\\t\\t#Don\\'t need a counter if you use key function to choose the key with max. count!\\n        return max(dict, key=dict.get)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        dict = {}\\n        banned = set(banned)\\n        for c in \"!?\\',;.\":\\n            paragraph = paragraph.replace(c, \" \")\\n        paragraph = paragraph.lower().split()\\n\\n        for word in paragraph:            \\n            if word not in banned:\\n                if word in dict:\\n                    dict[word]+=1\\n                else:\\n                    dict[word]=1\\n\\t\\t#Don\\'t need a counter if you use key function to choose the key with max. count!\\n        return max(dict, key=dict.get)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420553,
                "title": "clean-javascript-solution",
                "content": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n  const bannedSet = new Set(banned);\\n  const words = paragraph.toLowerCase().split(/\\\\W+/);\\n  const map = {};\\n  for (const w of words) {\\n    if (!bannedSet.has(w)) {\\n      if (map[w] == null) map[w] = 0;\\n      map[w]++;\\n    }\\n  }\\n\\n  let res = \\'\\';\\n  let max = -Infinity;\\n  for (const w in map) {\\n    const count = map[w];\\n    if (count > max) {\\n      res = w;\\n      max = count;\\n    }\\n  }\\n  return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n  const bannedSet = new Set(banned);\\n  const words = paragraph.toLowerCase().split(/\\\\W+/);\\n  const map = {};\\n  for (const w of words) {\\n    if (!bannedSet.has(w)) {\\n      if (map[w] == null) map[w] = 0;\\n      map[w]++;\\n    }\\n  }\\n\\n  let res = \\'\\';\\n  let max = -Infinity;\\n  for (const w in map) {\\n    const count = map[w];\\n    if (count > max) {\\n      res = w;\\n      max = count;\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1056547,
                "title": "java-map-set-solution-w-detailed-comments",
                "content": "\\tclass Solution {\\n\\n\\t\\t/*\\n\\t\\t\\tInput: \\n\\t\\t\\tparagraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\n\\t\\t\\tbanned = [\"hit\"]\\n\\n\\t\\t\\t-> \"Bob hit a ball the hit BALL flew far after it was hit\"\\n\\t\\t\\t-> \"bob hit a ball the hit ball flew far after it was hit\"\\n\\t\\t\\t-> [\"bob\", \"hit\", \"a\", \"ball\", \"the\", \"ball\", \"flew\", \"far\", \"after\", \"it\", \"was\", \"hit\"]\\n\\n\\t\\t\\t-> {\"hit\"}\\n\\n\\t\\t\\t-> {\\n\\t\\t\\t\\t\\tball:   2\\n\\t\\t\\t\\t\\tbob:    1\\n\\t\\t\\t\\t\\ta:      1\\n\\t\\t\\t\\t\\tthe:    1\\n\\t\\t\\t\\t\\tflew:   1\\n\\t\\t\\t\\t\\tfar:    1\\n\\t\\t\\t\\t\\tafter:  1\\n\\t\\t\\t\\t\\tit:     1\\n\\t\\t\\t\\t\\twas:    1\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tResult: \"ball\"\\n\\n\\t\\t\\tALGORITHM\\n\\t\\t\\t\\tSTEP 1: ensure the passed string is not null or blank\\n\\t\\t\\t\\tSTEP 2: create a set to contain the banned words\\n\\t\\t\\t\\tSTEP 3: create a map to store word and count\\n\\t\\t\\t\\tSTEP 4: remove all other characters from the paragraph except A-Z or a-z\\n\\t\\t\\t\\tSTEP 5: tranform paragraph to have all lowercase letters\\n\\t\\t\\t\\tSTEP 6: create a string array containing the words of pargraph spilt by space\\n\\t\\t\\t\\tSTEP 7: populate the set with the banned words\\n\\t\\t\\t\\tSTEP 8: loop through all the words\\n\\t\\t\\t\\t\\tSTEP 9: if the word is not in the banned list\\n\\t\\t\\t\\t\\t\\t\\t-> add the word to the map with an updated count\\n\\t\\t\\t\\tSTEP 810: return the most common word from map \\n\\n\\n\\t\\t*/\\n\\t\\tpublic String mostCommonWord(String paragraph, String[] banned) {\\n\\n\\t\\t\\tif(paragraph == null || paragraph.length() == 0) {\\n\\t\\t\\t\\treturn \"\";\\n\\t\\t\\t}\\n\\n\\t\\t\\tSet<String> bannedWords = new HashSet<>();\\n\\t\\t\\tMap<String, Integer> wordCount = new HashMap<>();\\n            String[] words = paragraph.replaceAll(\"[^A-Za-z]\",\" \").toLowerCase().split(\" \");\\n\\n\\t\\t\\tfor(String word: banned) {\\n\\t\\t\\t\\tbannedWords.add(word);\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\tfor(String word: words) {\\n\\t\\t\\t\\tif(!bannedWords.contains(word)) {\\n\\t\\t\\t\\t\\twordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\tString mostCommonWord = \"\";\\n\\t\\t\\tfor(String word: wordCount.keySet()) {\\n\\t\\t\\t\\tif(mostCommonWord.equals(\"\")) {\\n\\t\\t\\t\\t\\tmostCommonWord = word;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmostCommonWord = wordCount.get(mostCommonWord) > wordCount.get(word) ? mostCommonWord : word; \\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn mostCommonWord;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\n\\t\\t/*\\n\\t\\t\\tInput: \\n\\t\\t\\tparagraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\n\\t\\t\\tbanned = [\"hit\"]\\n\\n\\t\\t\\t-> \"Bob hit a ball the hit BALL flew far after it was hit\"\\n\\t\\t\\t-> \"bob hit a ball the hit ball flew far after it was hit\"\\n\\t\\t\\t-> [\"bob\", \"hit\", \"a\", \"ball\", \"the\", \"ball\", \"flew\", \"far\", \"after\", \"it\", \"was\", \"hit\"]\\n\\n\\t\\t\\t-> {\"hit\"}",
                "codeTag": "Java"
            },
            {
                "id": 196675,
                "title": "3ms-java-solution-beat-99-94",
                "content": "https://en.wikipedia.org/wiki/Trie\\nWe\\'ll use a Trie to solve this problem.\\nEvery TrieNode has 26 links, representing 26 lower-case letters.\\nThe root represents empty string, and each link points to the first character of a string.\\nWe use word to save the string that the node represents, and use cnt to count on number of times we meet the string.\\n\\nDuring \"mostCommonWord\", we could use StringBuilder to append the valid characters(and turn them to all lowercase),\\nwhile we meet any non-letter character, insert the string to the Trie.\\n\\nThe main part of TrieNode functions are describes below:\\n1. insert: \\nTake a char from string letter by letter, and go through the links.\\nIf curr.links[index] == null, that means we haven\\'t had a path pass by,\\nnew the TrieNode and set the \"word\".\\nAt the last of the TrieNode, we need to increase the cnt.\\n2. ban:\\nBan out the string means that we could set the cnt of string to zero.\\nNotice that if we meet null links, just return since the string is not exist in the paragraph.\\n3. findMax:\\nGo through all TrieNode and find the largest cnt and its word.\\n\\nThe following is for \\u4E2D\\u6587\\u4F7F\\u7528\\u8005\\u3002\\n\\u9019\\u500B\\u89E3\\u6CD5\\u662F\\u4F7F\\u7528\\u5B57\\u5178\\u6A39\\u4F86\\u89E3\\uFF0C\\u6A39\\u6839\\u4EE3\\u8868\\u7A7A\\u5B57\\u4E32\\uFF0C\\u6BCF\\u500B\\u5B57\\u4E32\\u90FD\\u6703\\u670926\\u500Blink\\uFF0C\\u4EE3\\u886826\\u500B\\u5C0F\\u5BEB\\u5B57\\u6BCD\\u3002\\n\\u6211\\u5011\\u5728\\u6BCF\\u500BTrieNode\\u4E2D\\u5B58\\u653Eword(\\u8D70\\u5230\\u9019\\u5BE6\\u969B\\u7684\\u5B57\\u4E32)\\u548Ccnt(\\u8A18\\u9304\\u9019\\u500B\\u5B57\\u4E32\\u6709\\u5E7E\\u500B)\\u3002\\n\\u5728mostCommonWord\\u4E2D\\uFF0C\\u4F7F\\u7528StringBuilder\\u6BCF\\u6B21\\u5C07\\u5408\\u6CD5\\u7684\\u5B57\\u5143(\\u5927\\u5C0F\\u5BEB\\u5B57\\u6BCD)\\u52A0\\u5165(\\u4E26\\u8F49\\u6210\\u5C0F\\u5BEB)\\uFF0C\\n\\u5728\\u9047\\u5230\\u975E\\u5B57\\u6BCD\\u7684\\u5B57\\u5143\\u7684\\u6642\\u5019\\uFF0C\\u5C31\\u628A\\u76EE\\u524D\\u7684\\u9019\\u500B\\u5B57\\u4E32\\u585E\\u9032\\u5B57\\u5178\\u6A39\\u88E1\\u3002\\n\\nTrieNode\\u9019\\u908A\\u6709\\u4E09\\u500Bfunctions:\\n1. insert:\\n\\u900F\\u904E\\u6BCF\\u500B\\u5B57\\u6BCD\\u6CBFlinks\\u7684\\u8DEF\\u5F91\\u8D70\\uFF0C\\u5982\\u679Ccurr.links[index] == null\\u5247\\u8868\\u793A\\u524D\\u9762\\u9084\\u6C92\\u8D70\\u904E\\uFF0C\\n\\u8981\\u81EA\\u884Cnew\\u51FA\\u4F86\\uFF0C\\u4E26\\u8A2D\\u5B9A\\u5176word\\u8B8A\\u6578\\u3002\\n\\u5728\\u8D70\\u5230\\u5E95\\u7684\\u6642\\u5019\\u6211\\u5011\\u8981\\u5C07cnt\\u6578\\u52A01\\u3002\\n2. ban:\\n\\u53EA\\u8981\\u5C07\\u8A72string\\u7684cnt\\u8A2D\\u6210\\u96F6\\u5373\\u53EF\\u3002\\n\\u5982\\u679C\\u5728\\u8D70\\u7684\\u8DEF\\u5F91\\u9014\\u4E2D\\u9047\\u5230null\\uFF0C\\u8868\\u793A\\u6BB5\\u843D\\u88E1\\u4E0D\\u5B58\\u5728\\u9019\\u500Bstring\\uFF0C\\u76F4\\u63A5return\\u5373\\u53EF\\u3002\\n3. findMax:\\n\\u904D\\u6B77\\u6240\\u6709TrieNode\\u4E26\\u627E\\u5230\\u6700\\u5927\\u7684cnt\\u53CA\\u5C0D\\u61C9\\u7684word\\u3002\\n\\n```\\nclass Solution {\\n    public String res;\\n    public int maxcnt;\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        TrieNode root = new TrieNode();\\n        StringBuilder st = new StringBuilder();\\n        res = \"\";\\n        maxcnt = 0;\\n        boolean isString = false;\\n        for (char ch : paragraph.toCharArray()) {\\n            if (ch >= \\'a\\' && ch <= \\'z\\') {\\n                st.append(ch);\\n                isString = true;\\n            } else if (ch >= \\'A\\' && ch <= \\'Z\\') {\\n                st.append((char)(ch + \\'a\\' - \\'A\\'));\\n                isString = true;\\n            } else {\\n                if (isString) {\\n                    root.insert(st.toString());\\n                    st = new StringBuilder();\\n                    isString = false;\\n                } \\n            }\\n        }\\n        if (isString) root.insert(st.toString());        \\n        for (String s : banned) root.ban(s);\\n        root.findMax(root);\\n        return res;\\n    }\\n    class TrieNode {\\n        String word = \"\";\\n        int cnt = 0;\\n        TrieNode[] links = new TrieNode[26];\\n        \\n        void insert(String s) {\\n            TrieNode curr = this;\\n            char[] chs = s.toCharArray();\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) {\\n                    curr.links[index] = new TrieNode();\\n                    curr.links[index].word = curr.word + chs[i];\\n                }\\n                curr = curr.links[index];\\n            }\\n            curr.cnt += 1;\\n        }\\n        void ban(String s) {\\n            char[] chs = s.toCharArray();\\n            TrieNode curr = this;\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) return;\\n                curr = curr.links[index];\\n            }\\n            curr.cnt = 0;\\n        }\\n        void findMax(TrieNode curr) {\\n            if (curr == null) return;\\n            if (curr.cnt > maxcnt) {\\n                res = curr.word;\\n                maxcnt = curr.cnt;\\n            }\\n            for (int i = 0; i < curr.links.length; ++i) {\\n                findMax(curr.links[i]);\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String res;\\n    public int maxcnt;\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        TrieNode root = new TrieNode();\\n        StringBuilder st = new StringBuilder();\\n        res = \"\";\\n        maxcnt = 0;\\n        boolean isString = false;\\n        for (char ch : paragraph.toCharArray()) {\\n            if (ch >= \\'a\\' && ch <= \\'z\\') {\\n                st.append(ch);\\n                isString = true;\\n            } else if (ch >= \\'A\\' && ch <= \\'Z\\') {\\n                st.append((char)(ch + \\'a\\' - \\'A\\'));\\n                isString = true;\\n            } else {\\n                if (isString) {\\n                    root.insert(st.toString());\\n                    st = new StringBuilder();\\n                    isString = false;\\n                } \\n            }\\n        }\\n        if (isString) root.insert(st.toString());        \\n        for (String s : banned) root.ban(s);\\n        root.findMax(root);\\n        return res;\\n    }\\n    class TrieNode {\\n        String word = \"\";\\n        int cnt = 0;\\n        TrieNode[] links = new TrieNode[26];\\n        \\n        void insert(String s) {\\n            TrieNode curr = this;\\n            char[] chs = s.toCharArray();\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) {\\n                    curr.links[index] = new TrieNode();\\n                    curr.links[index].word = curr.word + chs[i];\\n                }\\n                curr = curr.links[index];\\n            }\\n            curr.cnt += 1;\\n        }\\n        void ban(String s) {\\n            char[] chs = s.toCharArray();\\n            TrieNode curr = this;\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) return;\\n                curr = curr.links[index];\\n            }\\n            curr.cnt = 0;\\n        }\\n        void findMax(TrieNode curr) {\\n            if (curr == null) return;\\n            if (curr.cnt > maxcnt) {\\n                res = curr.word;\\n                maxcnt = curr.cnt;\\n            }\\n            for (int i = 0; i < curr.links.length; ++i) {\\n                findMax(curr.links[i]);\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753471,
                "title": "c-8-ms-solution-easy-to-understand",
                "content": "***Runtime: 8 ms, faster than 93.85% of C++ online submissions for Most Common Word.\\nMemory Usage: 7.7 MB, less than 92.55% of C++ online submissions for Most Common Word.***\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string result;\\n        int count = 0;\\n        unordered_map<string, int> umap;\\n        int i = 0;\\n        while(i < p.size()){\\n            string result = \"\";\\n            while(i < p.size() && isalpha(p[i])){\\n                result += tolower(p[i]);\\n                i++;\\n            }\\n            if(result != \"\")\\n                umap[result]++;\\n            i++;\\n        }\\n        for(auto& s: b){\\n            umap.erase(s);\\n        }\\n        for(auto& [key,value] : umap){\\n            if(count < value){\\n                result = key;\\n                count = value;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string result;\\n        int count = 0;\\n        unordered_map<string, int> umap;\\n        int i = 0;\\n        while(i < p.size()){\\n            string result = \"\";\\n            while(i < p.size() && isalpha(p[i])){\\n                result += tolower(p[i]);\\n                i++;\\n            }\\n            if(result != \"\")\\n                umap[result]++;\\n            i++;\\n        }\\n        for(auto& s: b){\\n            umap.erase(s);\\n        }\\n        for(auto& [key,value] : umap){\\n            if(count < value){\\n                result = key;\\n                count = value;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328271,
                "title": "c-linq",
                "content": "```\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n            char[] chars = new char[] { \\'!\\', \\'?\\', \\',\\', \\'.\\', \\';\\', \\' \\', \\'\\\\\\'\\' };\\n            return paragraph.Split(chars).Where(x => !string.IsNullOrWhiteSpace(x)).\\n                Select(x => x.ToLower()).Where(x => !banned.Contains(x)).\\n                GroupBy(x => x).Select(x => new { Word = x.Key, Count = x.Count() }).\\n                OrderBy(x => x.Count).Last().Word;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n            char[] chars = new char[] { \\'!\\', \\'?\\', \\',\\', \\'.\\', \\';\\', \\' \\', \\'\\\\\\'\\' };\\n            return paragraph.Split(chars).Where(x => !string.IsNullOrWhiteSpace(x)).\\n                Select(x => x.ToLower()).Where(x => !banned.Contains(x)).\\n                GroupBy(x => x).Select(x => new { Word = x.Key, Count = x.Count() }).\\n                OrderBy(x => x.Count).Last().Word;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125883,
                "title": "a-clean-o-n-javascript-es6-solution",
                "content": "Here is a shortened ES6 solution with explanation; It\\'s in `O(N)` *where `N` is the number of words in the `paragraph`*; \\n\\n```\\nvar mostCommonWord = function(paragraph, banned) {\\n    //Split the paragraph into an array of words in lowercase\\n    const words = paragraph.toLowerCase().split(/\\\\W/);\\n    //Create a map to act as histogram of words\\n    const mp = Object.create(null);\\n    //Filter out empty strings and make the histogram\\n    words.filter(x => x).map(x => mp[x] = x in mp ? mp[x] + 1 : 1);\\n    //Rather than deleting banned words, just set its value to a negative number\\n    banned.map(x => mp[x] = -1)\\n    //Return the word with the highest count in the histogram\\n    return Object.keys(mp).reduce((a, b) => mp[a] > mp[b] ? a : b);\\n};\\n```\\n\\n**Noteworthy here:** \\n- It doesn\\'t ever `delete` anything, cause it hurts performance in some JavaScript Engines, notably in v8 engine \\n- Note the oneliner trick of finding maximum element using a predicate, with the `[...].reduce()` trick. Similar to how I would have done it in C++ `std::max_element(...[](){})`;\\n\\n",
                "solutionTags": [],
                "code": "```\\nvar mostCommonWord = function(paragraph, banned) {\\n    //Split the paragraph into an array of words in lowercase\\n    const words = paragraph.toLowerCase().split(/\\\\W/);\\n    //Create a map to act as histogram of words\\n    const mp = Object.create(null);\\n    //Filter out empty strings and make the histogram\\n    words.filter(x => x).map(x => mp[x] = x in mp ? mp[x] + 1 : 1);\\n    //Rather than deleting banned words, just set its value to a negative number\\n    banned.map(x => mp[x] = -1)\\n    //Return the word with the highest count in the histogram\\n    return Object.keys(mp).reduce((a, b) => mp[a] > mp[b] ? a : b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125686,
                "title": "java-simple-solution-using-hashmaps-along-with-asserts-to-test",
                "content": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        String[] splitArr = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<String> bannedList = Arrays.asList(banned);\\n        for(String str: splitArr) {\\n            if(!bannedList.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n\\n        int currentMax = 0;\\n        String res = \"\";\\n        for(String key: map.keySet()) {\\n            res = map.get(key) >  currentMax ? key : res;\\n            currentMax = map.get(key);\\n        }\\n        return res;\\n    }\\n```\\n\\nCan be tested by following two asserts:\\n```\\npublic static void main(String[] args) {\\n    Assert.assertEquals(\"ball\", mostCommonWord(\"Bob hit a ball, the hit BALL flew far after it was hit.\", new String[]{\"hit\"}));\\n    Assert.assertEquals(\"z\", mostCommonWord(\"L, P! X! C; u! P? w! P. G, S? l? X? D. w? m? f? v, x? i. z; x\\' m! U\\' M! j? V; l. S! j? r, K. O? k? p? p, H! t! z\\' X! v. u; F, h; s? X? K. y, Y! L; q! y? j, o? D\\' y? F\\' Z; E? W; W\\' W! n! p\\' U. N; w? V\\' y! Q; J, o! T? g? o! N\\' M? X? w! V. w? o\\' k. W. y, k; o\\' m! r; i, n. k, w; U? S? t; O\\' g\\' z. V. N? z, W? j! m? W! h; t! V\\' T! Z? R\\' w, w? y? y; O\\' w; r? q. G, V. x? n, Y; Q. s? S. G. f, s! U? l. o! i. L; Z\\' X! u. y, Q. q; Q, D; V. m. q. s? Y, U; p? u! q? h? O. W\\' y? Z! x! r. E, R, r\\' X\\' V, b. z, x! Q; y, g\\' j; j. q; W; v\\' X! J\\' H? i\\' o? n, Y. X! x? h? u; T? l! o? z. K\\' z\\' s; L? p? V\\' r. L? Y; V! V\\' S. t? Z\\' T\\' Y. s? i? Y! G? r; Y; T! h! K; M. k. U; A! V? R? C\\' x! X. M; z\\' V! w. N. T? Y\\' w? n, Z, Z? Y\\' R; V\\' f; V\\' I; t? X? Z; l? R, Q! Z. R. R, O. S! w; p\\' T. u? U! n, V, M. p? Q, O? q\\' t. B, k. u. H\\' T; T? S; Y! S! i? q! K\\' z\\' S! v; L. x; q; W? m? y, Z! x. y. j? N\\' R\\' I? r? V! Z; s, O? s; V, I, e? U\\' w! T? T! u; U! e? w? z; t! C! z? U, p\\' p! r. x; U! Z; u! j; T! X! N\\' F? n! P\\' t, X. s; q\\'\", new String[]{\"m\",\"i\",\"s\",\"w\",\"y\",\"d\",\"q\",\"l\",\"a\",\"p\",\"n\",\"t\",\"u\",\"b\",\"o\",\"e\",\"f\",\"g\",\"c\",\"x\"}));\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        String[] splitArr = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<String> bannedList = Arrays.asList(banned);\\n        for(String str: splitArr) {\\n            if(!bannedList.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n\\n        int currentMax = 0;\\n        String res = \"\";\\n        for(String key: map.keySet()) {\\n            res = map.get(key) >  currentMax ? key : res;\\n            currentMax = map.get(key);\\n        }\\n        return res;\\n    }\\n```\n```\\npublic static void main(String[] args) {\\n    Assert.assertEquals(\"ball\", mostCommonWord(\"Bob hit a ball, the hit BALL flew far after it was hit.\", new String[]{\"hit\"}));\\n    Assert.assertEquals(\"z\", mostCommonWord(\"L, P! X! C; u! P? w! P. G, S? l? X? D. w? m? f? v, x? i. z; x\\' m! U\\' M! j? V; l. S! j? r, K. O? k? p? p, H! t! z\\' X! v. u; F, h; s? X? K. y, Y! L; q! y? j, o? D\\' y? F\\' Z; E? W; W\\' W! n! p\\' U. N; w? V\\' y! Q; J, o! T? g? o! N\\' M? X? w! V. w? o\\' k. W. y, k; o\\' m! r; i, n. k, w; U? S? t; O\\' g\\' z. V. N? z, W? j! m? W! h; t! V\\' T! Z? R\\' w, w? y? y; O\\' w; r? q. G, V. x? n, Y; Q. s? S. G. f, s! U? l. o! i. L; Z\\' X! u. y, Q. q; Q, D; V. m. q. s? Y, U; p? u! q? h? O. W\\' y? Z! x! r. E, R, r\\' X\\' V, b. z, x! Q; y, g\\' j; j. q; W; v\\' X! J\\' H? i\\' o? n, Y. X! x? h? u; T? l! o? z. K\\' z\\' s; L? p? V\\' r. L? Y; V! V\\' S. t? Z\\' T\\' Y. s? i? Y! G? r; Y; T! h! K; M. k. U; A! V? R? C\\' x! X. M; z\\' V! w. N. T? Y\\' w? n, Z, Z? Y\\' R; V\\' f; V\\' I; t? X? Z; l? R, Q! Z. R. R, O. S! w; p\\' T. u? U! n, V, M. p? Q, O? q\\' t. B, k. u. H\\' T; T? S; Y! S! i? q! K\\' z\\' S! v; L. x; q; W? m? y, Z! x. y. j? N\\' R\\' I? r? V! Z; s, O? s; V, I, e? U\\' w! T? T! u; U! e? w? z; t! C! z? U, p\\' p! r. x; U! Z; u! j; T! X! N\\' F? n! P\\' t, X. s; q\\'\", new String[]{\"m\",\"i\",\"s\",\"w\",\"y\",\"d\",\"q\",\"l\",\"a\",\"p\",\"n\",\"t\",\"u\",\"b\",\"o\",\"e\",\"f\",\"g\",\"c\",\"x\"}));\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484164,
                "title": "python-faster-than-92-97",
                "content": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        \\n        #replacing each symbols, so they are not included with words\\n        symbols = \"!?\\',;.\" \\n        for s in symbols:\\n            paragraph = paragraph.replace(s,\" \")\\n    \\n        paraList = split(lower(paragraph))\\n        wordCounter = {}\\n        for w in paraList:\\n            if w not in banned:\\n                if w not in wordCounter.keys():\\n                    wordCounter[w] = 1 \\n                else:\\n                    wordCounter[w] += 1\\n        \\n        maxVal = max(wordCounter.values())\\n        for k,v in wordCounter.items():\\n            if v == maxVal:\\n                return k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        \\n        #replacing each symbols, so they are not included with words\\n        symbols = \"!?\\',;.\" \\n        for s in symbols:\\n            paragraph = paragraph.replace(s,\" \")\\n    \\n        paraList = split(lower(paragraph))\\n        wordCounter = {}\\n        for w in paraList:\\n            if w not in banned:\\n                if w not in wordCounter.keys():\\n                    wordCounter[w] = 1 \\n                else:\\n                    wordCounter[w] += 1\\n        \\n        maxVal = max(wordCounter.values())\\n        for k,v in wordCounter.items():\\n            if v == maxVal:\\n                return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370291,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var mostCommonWord = function(paragraph, banned) {\\n        let arr = paragraph.toLowerCase().split(/\\\\W+/g)\\n        let map = {}\\n    \\n        for(let word of arr) {\\n            if(!map[word]) {\\n                map[word] = 1        \\n            } else {\\n                map[word]++\\n            }\\n        }\\n    \\n       return Object.keys(map).sort((a,b) => {\\n            return map[b] - map[a]\\n        }).filter(word => !banned.includes(word))[0]\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var mostCommonWord = function(paragraph, banned) {\\n        let arr = paragraph.toLowerCase().split(/\\\\W+/g)\\n        let map = {}\\n    \\n        for(let word of arr) {\\n            if(!map[word]) {\\n                map[word] = 1        \\n            } else {\\n                map[word]++\\n            }\\n        }\\n    \\n       return Object.keys(map).sort((a,b) => {\\n            return map[b] - map[a]\\n        }).filter(word => !banned.includes(word))[0]\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 123958,
                "title": "3-lines-python-solution-using-regex",
                "content": "```python\\n    def mostCommonWord(self, paragraph, banned):\\n        tokens = [token for token in re.findall(r\"([a-zA-Z]+)\",  paragraph.lower()) if token not in banned]\\n        mostComm = collections.Counter(tokens).most_common(1)\\n        return mostComm[0][0]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def mostCommonWord(self, paragraph, banned):\\n        tokens = [token for token in re.findall(r\"([a-zA-Z]+)\",  paragraph.lower()) if token not in banned]\\n        mostComm = collections.Counter(tokens).most_common(1)\\n        return mostComm[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2049770,
                "title": "python-brute-force-method-with-explanation",
                "content": "**Explanation**\\n1. make paragraph lowercase (case insensitive)\\n2. remove symbols from paragraph\\n3. split the paragraph into list of words\\n4. remove duplicate words\\n5. iterate through new paragraph\\n\\t6. if the current word isn\\'t in `banned` and it occurs more times in the old paragraph: update count and update the most common word\\n\\t7. return most common word\\n\\n```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        count = 0\\n        y=\"\"\\n        s=\"!?\\',;.\"\\n        for i in s:\\n            paragraph = paragraph.replace(i,\\' \\')\\n            \\n            \\n        allwords = paragraph.split()\\n        words = list(set(allwords))\\n        for j in words:\\n            if j not in banned:\\n                if allwords.count(j) > count:\\n                    count = allwords.count(j)\\n                    y = j\\n        return y\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        count = 0\\n        y=\"\"\\n        s=\"!?\\',;.\"\\n        for i in s:\\n            paragraph = paragraph.replace(i,\\' \\')\\n            \\n            \\n        allwords = paragraph.split()\\n        words = list(set(allwords))\\n        for j in words:\\n            if j not in banned:\\n                if allwords.count(j) > count:\\n                    count = allwords.count(j)\\n                    y = j\\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429450,
                "title": "java-runtime-o-n-4ms-99-memory-o-n-36mb-96",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }\\n            String currWord = paragraph.substring(left,right).toLowerCase();\\n            if(!banSet.contains(currWord)){\\n                int newCount = strCount.getOrDefault(currWord,0)+1;\\n                strCount.put(currWord,newCount);\\n                if(newCount>max){\\n                    max=newCount;\\n                    maxWord=currWord;\\n                }\\n            }\\n            while(right < n && !Character.isLetter(charParagraph[right])) right++;\\n            left=right;\\n        }\\n        return maxWord;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }\\n            String currWord = paragraph.substring(left,right).toLowerCase();\\n            if(!banSet.contains(currWord)){\\n                int newCount = strCount.getOrDefault(currWord,0)+1;\\n                strCount.put(currWord,newCount);\\n                if(newCount>max){\\n                    max=newCount;\\n                    maxWord=currWord;\\n                }\\n            }\\n            while(right < n && !Character.isLetter(charParagraph[right])) right++;\\n            left=right;\\n        }\\n        return maxWord;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982633,
                "title": "python-dictionaries-clean-code",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!.\\',;:?\": \\n            paragraph = paragraph.replace(i, \\' \\')\\n        dic, ans, ansCount = defaultdict(int), \\'\\', 0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue\\n            dic[word] += 1\\n            if dic[word] > ansCount:\\n                ansCount = dic[word]\\n                res = word\\n        return res    \\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!.\\',;:?\": \\n            paragraph = paragraph.replace(i, \\' \\')\\n        dic, ans, ansCount = defaultdict(int), \\'\\', 0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue\\n            dic[word] += 1\\n            if dic[word] > ansCount:\\n                ansCount = dic[word]\\n                res = word\\n        return res    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 828958,
                "title": "swift-16ms",
                "content": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        var map: [String: Int] = [String: Int]()\\n    \\n        let fixedParagraph = paragraph.lowercased().split{ !$0.isLetter }\\n    \\n        fixedParagraph.forEach { (word) in\\n            map[String(word)] = (map[String(word)] ?? 0) + 1\\n        }\\n\\n        return map.sorted {$0.value > $1.value }.filter{ !banned.contains($0.key)}.first?.key ?? \"\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        var map: [String: Int] = [String: Int]()\\n    \\n        let fixedParagraph = paragraph.lowercased().split{ !$0.isLetter }\\n    \\n        fixedParagraph.forEach { (word) in\\n            map[String(word)] = (map[String(word)] ?? 0) + 1\\n        }\\n\\n        return map.sorted {$0.value > $1.value }.filter{ !banned.contains($0.key)}.first?.key ?? \"\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823208,
                "title": "python-simple-and-clean-explained-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        my_dict = defaultdict(int)\\n        # split string into list ignoring cases and punctuation\\n        par = re.split(\"[\" + string.punctuation + \" \"+ \"]+\", paragraph.lower())\\n        # keep counts of words in dict and keep track of most frequent\\n        max_count = 0\\n        max_word = \"\"\\n        for word in par:\\n            if word not in banned:\\n                my_dict[word]+=1\\n                if my_dict[word] > max_count:\\n                    max_count = my_dict[word]\\n                    max_word = word\\n        return max_word\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        my_dict = defaultdict(int)\\n        # split string into list ignoring cases and punctuation\\n        par = re.split(\"[\" + string.punctuation + \" \"+ \"]+\", paragraph.lower())\\n        # keep counts of words in dict and keep track of most frequent\\n        max_count = 0\\n        max_word = \"\"\\n        for word in par:\\n            if word not in banned:\\n                my_dict[word]+=1\\n                if my_dict[word] > max_count:\\n                    max_count = my_dict[word]\\n                    max_word = word\\n        return max_word\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 466877,
                "title": "python-counter-regex-solution-faster-than-98-5",
                "content": "```\\nfrom collections import Counter\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.split(\\'[!?\\\\\\',;. ]\\', paragraph.lower()))\\n        for (word, count) in c.most_common():\\n            if word not in banned and word != \\'\\':\\n                return word\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.split(\\'[!?\\\\\\',;. ]\\', paragraph.lower()))\\n        for (word, count) in c.most_common():\\n            if word not in banned and word != \\'\\':\\n                return word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348148,
                "title": "javascript-beats-99-hashmap",
                "content": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n    const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n    const map = new Map();\\n    const set = new Set(banned);\\n    words.forEach(word => map.set(word, map.has(word) ? map.get(word) + 1 : 1));\\n    set.forEach(banned => {\\n        if(map.has(banned)) map.delete(banned);\\n    });\\n    \\n    let res = \\'\\', max = Number.MIN_SAFE_INTEGER;\\n    for(let [word, count] of map.entries()) {\\n        if(word) {\\n            res = count > max ? word : res;\\n            max = count > max ? count : max;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n    const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n    const map = new Map();\\n    const set = new Set(banned);\\n    words.forEach(word => map.set(word, map.has(word) ? map.get(word) + 1 : 1));\\n    set.forEach(banned => {\\n        if(map.has(banned)) map.delete(banned);\\n    });\\n    \\n    let res = \\'\\', max = Number.MIN_SAFE_INTEGER;\\n    for(let [word, count] of map.entries()) {\\n        if(word) {\\n            res = count > max ? word : res;\\n            max = count > max ? count : max;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274538,
                "title": "java-short-8-line-code-beats-95-45",
                "content": "# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] ban) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(ban));\\n\\n        for(String i : paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\")){\\n            if(!set.contains(i))map.put(i, map.getOrDefault(i,0)+1);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        String res = \"\";\\n        for(String i : map.keySet()){\\n            if(map.get(i) > max){\\n                max = map.get(i);\\n                res = i;\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] ban) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(ban));\\n\\n        for(String i : paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\")){\\n            if(!set.contains(i))map.put(i, map.getOrDefault(i,0)+1);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        String res = \"\";\\n        for(String i : map.keySet()){\\n            if(map.get(i) > max){\\n                max = map.get(i);\\n                res = i;\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613988,
                "title": "c-4ms-clean-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int>m;\\n        int frequency = 0;\\n        string s = \"\";\\n        for(int i=0;i<p.size();i++){\\n            if((p[i]>=\\'a\\' and p[i]<=\\'z\\') or (p[i]>=\\'A\\' and p[i]<=\\'Z\\')){\\n                s+=tolower(p[i]);\\n            }\\n            else{\\n                if(s.length()>0){\\n                    m[s]++,s=\"\";\\n                }\\n            }\\n        }\\n        m[s]++;\\n        for(auto i:banned)  m[i]=0;\\n        for(auto i:m){\\n            if(frequency<=i.second){\\n                s=i.first,frequency = i.second;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/84db0c16-77b3-495b-b83c-0122c8ffa289_1638759978.574484.jpeg)\\n\\n\\n\\n**If you have any questions, feel free to comment below.\\nPlease help to UPVOTE if this post is useful for you.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int>m;\\n        int frequency = 0;\\n        string s = \"\";\\n        for(int i=0;i<p.size();i++){\\n            if((p[i]>=\\'a\\' and p[i]<=\\'z\\') or (p[i]>=\\'A\\' and p[i]<=\\'Z\\')){\\n                s+=tolower(p[i]);\\n            }\\n            else{\\n                if(s.length()>0){\\n                    m[s]++,s=\"\";\\n                }\\n            }\\n        }\\n        m[s]++;\\n        for(auto i:banned)  m[i]=0;\\n        for(auto i:m){\\n            if(frequency<=i.second){\\n                s=i.first,frequency = i.second;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820773,
                "title": "python-solution-97-faster",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        counter = defaultdict(int)\\n        # remove special chars and make lower\\n        paragraph = re.findall(r\\'\\\\w+\\', paragraph.lower()) \\n        for word in paragraph:\\n            if word not in banned:\\n                counter[word] += 1\\n\\n        return  max(counter, key= lambda x: counter[x]) \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        counter = defaultdict(int)\\n        # remove special chars and make lower\\n        paragraph = re.findall(r\\'\\\\w+\\', paragraph.lower()) \\n        for word in paragraph:\\n            if word not in banned:\\n                counter[word] += 1\\n\\n        return  max(counter, key= lambda x: counter[x]) \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 692486,
                "title": "java-10ms-but-clear-code-many-comments",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n      \\n      /*\\n      Runtime: 10 ms, faster than 70.48% of Java online submissions for Most Common Word.\\n      Memory Usage: 39.4 MB, less than 78.59% of Java online submissions for Most Common Word.\\n      */\\n      \\n      // store banned words in a HashSet for fast lookup later\\n      Set<String> bannedWords = new HashSet<String>(Arrays.asList(banned));\\n      \\n      // convert to lowercase\\n      paragraph = paragraph.toLowerCase();\\n      \\n      // remove punctuation\\n      String punctuation = \"!?\\',;.\";\\n      for (char c : punctuation.toCharArray()) {\\n        paragraph = paragraph.replace(c, \\' \\'); // OK to increase the number of spaces, because our tokenizing will ignore sequences of whitespace\\n      }\\n      \\n      // tokenize and load non-banned words into HashMap\\n      String[] tokens = paragraph.split(\"\\\\\\\\s+\"); // split on any amount of whitespace\\n      Map<String, Integer> frequencyTable = new HashMap<>();      \\n      for (String s : tokens) {\\n        if (!bannedWords.contains(s)) {\\n          frequencyTable.merge(s, 1, Integer::sum); // handy merge() method!\\n        }\\n      }\\n      \\n      // traverse HashMap and determine highest-frequency word\\n      int maxFrequency = 0;\\n      String maxWord = \"\";\\n      \\n      for (Map.Entry<String, Integer> e : frequencyTable.entrySet()) {\\n        if (e.getValue() > maxFrequency) {\\n          maxFrequency = e.getValue();\\n          maxWord = e.getKey();\\n        }\\n      }\\n      \\n      return maxWord;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n      \\n      /*\\n      Runtime: 10 ms, faster than 70.48% of Java online submissions for Most Common Word.\\n      Memory Usage: 39.4 MB, less than 78.59% of Java online submissions for Most Common Word.\\n      */\\n      \\n      // store banned words in a HashSet for fast lookup later\\n      Set<String> bannedWords = new HashSet<String>(Arrays.asList(banned));\\n      \\n      // convert to lowercase\\n      paragraph = paragraph.toLowerCase();\\n      \\n      // remove punctuation\\n      String punctuation = \"!?\\',;.\";\\n      for (char c : punctuation.toCharArray()) {\\n        paragraph = paragraph.replace(c, \\' \\'); // OK to increase the number of spaces, because our tokenizing will ignore sequences of whitespace\\n      }\\n      \\n      // tokenize and load non-banned words into HashMap\\n      String[] tokens = paragraph.split(\"\\\\\\\\s+\"); // split on any amount of whitespace\\n      Map<String, Integer> frequencyTable = new HashMap<>();      \\n      for (String s : tokens) {\\n        if (!bannedWords.contains(s)) {\\n          frequencyTable.merge(s, 1, Integer::sum); // handy merge() method!\\n        }\\n      }\\n      \\n      // traverse HashMap and determine highest-frequency word\\n      int maxFrequency = 0;\\n      String maxWord = \"\";\\n      \\n      for (Map.Entry<String, Integer> e : frequencyTable.entrySet()) {\\n        if (e.getValue() > maxFrequency) {\\n          maxFrequency = e.getValue();\\n          maxWord = e.getKey();\\n        }\\n      }\\n      \\n      return maxWord;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686043,
                "title": "functional-solution-in-java",
                "content": "Probably not the best solution to choose in a coding interview but a fun way to solve this problem in Java.\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph\\n            .toLowerCase()\\n            .split(\"[\\\\\\\\p{Punct}\\\\\\\\s]+\");\\n\\n        Set<String> bannedWords = Set.of(banned);\\n        \\n        return Arrays\\n            .asList(words)\\n            .stream()\\n            .filter(word -> !bannedWords.contains(word))\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .entrySet()\\n            .stream()\\n            .max(Comparator.comparing(Map.Entry<String, Long>::getValue))\\n            .get()\\n            .getKey();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph\\n            .toLowerCase()\\n            .split(\"[\\\\\\\\p{Punct}\\\\\\\\s]+\");\\n\\n        Set<String> bannedWords = Set.of(banned);\\n        \\n        return Arrays\\n            .asList(words)\\n            .stream()\\n            .filter(word -> !bannedWords.contains(word))\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .entrySet()\\n            .stream()\\n            .max(Comparator.comparing(Map.Entry<String, Long>::getValue))\\n            .get()\\n            .getKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575644,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned) {\\n            HashSet<string> set = new HashSet<string>(banned);\\n\\n            foreach (var str in paragraph.Replace(\"!\", \" \")\\n                                         .Replace(\"?\", \" \")\\n                                         .Replace(\"\\'\", \" \")\\n                                         .Replace(\",\", \" \")\\n                                         .Replace(\";\", \" \")\\n                                         .Replace(\".\", \" \")\\n                                         .ToLower()\\n                                         .Split(new char[] { \\' \\' }, StringSplitOptions.RemoveEmptyEntries)\\n                                         .GroupBy(x => x)\\n                                         .OrderByDescending(x => x.Count())\\n                                         .Select(x => x.Key))\\n                if (!set.Contains(str))\\n                    return str;\\n\\n            return string.Empty;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned) {\\n            HashSet<string> set = new HashSet<string>(banned);\\n\\n            foreach (var str in paragraph.Replace(\"!\", \" \")\\n                                         .Replace(\"?\", \" \")\\n                                         .Replace(\"\\'\", \" \")\\n                                         .Replace(\",\", \" \")\\n                                         .Replace(\";\", \" \")\\n                                         .Replace(\".\", \" \")\\n                                         .ToLower()\\n                                         .Split(new char[] { \\' \\' }",
                "codeTag": "Java"
            },
            {
                "id": 500791,
                "title": "python-3-another-solution-explained",
                "content": "Runtime: 32 ms, faster than 69.45% of Python3 online submissions for Most Common Word.\\nMemory Usage: 12.6 MB, less than 100.00% of Python3 online submissions for Most Common Word.\\n\\n```Python 3\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        translator = str.maketrans(string.punctuation, \\' \\'*32)\\n        a = paragraph.lower().translate(translator).split()\\n        b = [w for w in a if w not in banned]\\n        return max(b, key = b.count)\\n```\\n\\n**Explanation:**\\n\\n1. First, we create translation map using [str.maketrans](https://docs.python.org/3/library/stdtypes.html#str.maketrans) (<- link to the official doc) to remove all punctuation from the paragraph. If you print `print(string.punctuation)` you will get: `!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~`. The length of this string is 32 symbols. Since first two maketrans arguments must have equal length, we make second argument equal to 32 symbols by using \\' \\'*32 or 32 spaces. That\\'s how we tell to translate all punctuation symbols into spaces.\\n2. Then we convert our `paragraph` to lower case, translate all punctuation into spaces using translator from step one and then split paragraph into words by spaces.\\n3. Then we create new list by saving only those words from paragraph that are **not** in the banned list.\\n4. Finally, we return value that counted max times in our new list.\\n\\nPleaase, upvote if you like this solution so that others can see and learn from it. Thanks!\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python 3\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        translator = str.maketrans(string.punctuation, \\' \\'*32)\\n        a = paragraph.lower().translate(translator).split()\\n        b = [w for w in a if w not in banned]\\n        return max(b, key = b.count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415594,
                "title": "simple-c-99-20-lines-o-n",
                "content": "Pretty straight forward, the two edge cases are \\n- making sure you count end-of-string as hitting a delimiter and working with whatever word is in the buffer at that time\\n- making sure you don\\'t count an empty string word in your wordCount structure\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> bannedWords(banned.begin(), banned.end());\\n        unordered_map<string,int> wordCountMap;\\n        string word, winnerWord = \"\";\\n        int winnerCount = 0;\\n        \\n        for (int i = 0; i <= paragraph.size(); ++i) {\\n            bool delimHit = i == paragraph.size() || !isalpha(paragraph[i]);\\n            if (delimHit) {\\n                if (!word.size())\\n                    continue;\\n                if (bannedWords.find(word) == bannedWords.end() && ++wordCountMap[word] > winnerCount) {\\n                    winnerCount = wordCountMap[word];\\n                    winnerWord = word;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        return winnerWord;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> bannedWords(banned.begin(), banned.end());\\n        unordered_map<string,int> wordCountMap;\\n        string word, winnerWord = \"\";\\n        int winnerCount = 0;\\n        \\n        for (int i = 0; i <= paragraph.size(); ++i) {\\n            bool delimHit = i == paragraph.size() || !isalpha(paragraph[i]);\\n            if (delimHit) {\\n                if (!word.size())\\n                    continue;\\n                if (bannedWords.find(word) == bannedWords.end() && ++wordCountMap[word] > winnerCount) {\\n                    winnerCount = wordCountMap[word];\\n                    winnerWord = word;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        return winnerWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408056,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = dict()\\n        for c in paragraph:\\n            if(c == \\'!\\' or c == \\',\\' or c == \\'.\\' or c == \\'?\\' or c == \\';\\' or c == \"\\'\"):\\n                paragraph = paragraph.replace(c, \\' \\')\\n\\n        paragraph = paragraph.split()\\n        for word in paragraph:\\n            word = word.lower()\\n            if(word not in banned):\\n                if(word not in d):\\n                    d[word] = 1\\n                    \\n                else:\\n                    d[word] += 1\\n                    \\n\\n        return max(d, key = d.get)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = dict()\\n        for c in paragraph:\\n            if(c == \\'!\\' or c == \\',\\' or c == \\'.\\' or c == \\'?\\' or c == \\';\\' or c == \"\\'\"):\\n                paragraph = paragraph.replace(c, \\' \\')\\n\\n        paragraph = paragraph.split()\\n        for word in paragraph:\\n            word = word.lower()\\n            if(word not in banned):\\n                if(word not in d):\\n                    d[word] = 1\\n                    \\n                else:\\n                    d[word] += 1\\n                    \\n\\n        return max(d, key = d.get)",
                "codeTag": "Java"
            },
            {
                "id": 374139,
                "title": "straightforward-c-solution",
                "content": "Firstly I am doing error checking to see if the given paragraph is empty or not. There are some important points in this code:\\n\\n1) I am transferring the values in the banned vector to a set, to later on search over those words efficiently. Also since set will have unique values, we are eliminating the possibility of wating our time with the same banned words if there are any.\\n2) In the for loop, I am cleaning the paragraph. Since our search will be case insensitive we will have to convert all characters in the paragraph to lower case since all of the banned words are in lower case. Doing this, we will have a common ground to search over. I am also replacing any non-alphabetic character with a space. Do not forget to iterate over the characters in the paragraph by reference since we want to modify them.\\n3) I am utilizing input string stream to parse words from the paragraph. Note that we could also have used a simple string stream but input string stream makes our intention clearer.\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        if(p.empty()) return {};\\n        \\n        std::string res;\\n        std::unordered_set<string> banned_words(banned.begin(), banned.end());\\n        std::unordered_map<string, int> count_map;\\n        \\n        for (auto& ch : p) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        \\n        istringstream iss(p);\\n        std::string word; \\n        \\n        int max = INT_MIN;\\n        \\n        \\n        while(iss >> word) {\\n            if(banned_words.find(word) == banned_words.end()) {\\n                ++count_map[word];\\n                if(count_map[word] > max) {\\n                    max = count_map[word];\\n                    res = word;\\n                }\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        if(p.empty()) return {};\\n        \\n        std::string res;\\n        std::unordered_set<string> banned_words(banned.begin(), banned.end());\\n        std::unordered_map<string, int> count_map;\\n        \\n        for (auto& ch : p) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        \\n        istringstream iss(p);\\n        std::string word; \\n        \\n        int max = INT_MIN;\\n        \\n        \\n        while(iss >> word) {\\n            if(banned_words.find(word) == banned_words.end()) {\\n                ++count_map[word];\\n                if(count_map[word] > max) {\\n                    max = count_map[word];\\n                    res = word;\\n                }\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345695,
                "title": "c-very-easy-solution-o-n-8ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_set<string> bannedWords;\\n        for(string & s : banned)\\n            bannedWords.insert(s); // for a fast lookup\\n        bannedWords.insert(\"\"); // to tackle an edge case\\n        map<string, int> topWords;\\n        unordered_set<string> punctuations; // for convenience sake\\n        punctuations.insert(\"!\");\\n        punctuations.insert(\"\\'\");\\n        punctuations.insert(\"?\");\\n        punctuations.insert(\",\");\\n        punctuations.insert(\";\");\\n        punctuations.insert(\".\");\\n        string current = \"\";\\n        for(char & c : paragraph)\\n        {\\n            if(c == \\' \\' || punctuations.count(string(1, c)))\\n            {\\n                if(!bannedWords.count(current))\\n                {\\n                    cout << current << \"!\";\\n                    ++topWords[current];\\n                }\\n                current = \"\";\\n            }\\n            else current += char(tolower(c));\\n        }\\n        if(!bannedWords.count(current))\\n            ++topWords[current];\\n        pair<int, string> result(0, \"\");\\n        for(auto & it : topWords)\\n        {\\n            if(it.second > result.first)\\n                result = {it.second, it.first};\\n        }\\n        return result.second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_set<string> bannedWords;\\n        for(string & s : banned)\\n            bannedWords.insert(s); // for a fast lookup\\n        bannedWords.insert(\"\"); // to tackle an edge case\\n        map<string, int> topWords;\\n        unordered_set<string> punctuations; // for convenience sake\\n        punctuations.insert(\"!\");\\n        punctuations.insert(\"\\'\");\\n        punctuations.insert(\"?\");\\n        punctuations.insert(\",\");\\n        punctuations.insert(\";\");\\n        punctuations.insert(\".\");\\n        string current = \"\";\\n        for(char & c : paragraph)\\n        {\\n            if(c == \\' \\' || punctuations.count(string(1, c)))\\n            {\\n                if(!bannedWords.count(current))\\n                {\\n                    cout << current << \"!\";\\n                    ++topWords[current];\\n                }\\n                current = \"\";\\n            }\\n            else current += char(tolower(c));\\n        }\\n        if(!bannedWords.count(current))\\n            ++topWords[current];\\n        pair<int, string> result(0, \"\");\\n        for(auto & it : topWords)\\n        {\\n            if(it.second > result.first)\\n                result = {it.second, it.first};\\n        }\\n        return result.second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 332220,
                "title": "weird-bug-of-using-range-based-loop-for-unordered-map-c",
                "content": "This is my Accepted submission, I post it here for a full view of my code before describing the bug below.\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        paragraph += \\' \\';\\n        string word = \"\";\\n        unordered_map<string, int> map;\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        ban.insert(\"\");\\n        for (auto c: paragraph) {\\n            if (!isalpha(c)) {\\n                if (!ban.count(word)) {\\n                    if (map.count(word) == 0) map[word] = 0;\\n                    map[word]++;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(c);\\n            }\\n        }\\n        int prev = map[word];\\n        for (auto &kv: map) {\\n            if (kv.second > prev) {\\n                word = kv.first;\\n                prev = kv.second;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\\n\\nIn a previous submission, I did the last loop as follows\\n\\n```\\n        for (auto &kv: map) {\\n            if (kv.second > map[word]) {\\n                word = kv.first;\\n            }\\n        }\\n```\\n\\nFor some unknown reasons, the loop doesn\\'t visit all key-value pairs in the map. For example, in the test `a, a, a, a, b,b,b,c, c`, the code will only check key `c` and skip key `b`. The part ` map[word]` seems to be problematic, I took it out and the problem went away. I am clueless about why it behaves as such, let me know if you have any idea.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        paragraph += \\' \\';\\n        string word = \"\";\\n        unordered_map<string, int> map;\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        ban.insert(\"\");\\n        for (auto c: paragraph) {\\n            if (!isalpha(c)) {\\n                if (!ban.count(word)) {\\n                    if (map.count(word) == 0) map[word] = 0;\\n                    map[word]++;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(c);\\n            }\\n        }\\n        int prev = map[word];\\n        for (auto &kv: map) {\\n            if (kv.second > prev) {\\n                word = kv.first;\\n                prev = kv.second;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\n```\\n        for (auto &kv: map) {\\n            if (kv.second > map[word]) {\\n                word = kv.first;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305493,
                "title": "python3-solution-faster-than-99-74-submissions-using-dict",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        import re\\n        d={}\\n        paragraph = re.sub(r\\'[^\\\\w\\\\s]\\',\\' \\',paragraph)\\n        paragraph=paragraph.split()\\n        for i in paragraph:\\n            i=i.lower()\\n            if i not in banned:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    d[i]=1\\n        key,value= max(d.items(),key= lambda k:k[1])\\n        return (\"\".join(str(key)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        import re\\n        d={}\\n        paragraph = re.sub(r\\'[^\\\\w\\\\s]\\',\\' \\',paragraph)\\n        paragraph=paragraph.split()\\n        for i in paragraph:\\n            i=i.lower()\\n            if i not in banned:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    d[i]=1\\n        key,value= max(d.items(),key= lambda k:k[1])\\n        return (\"\".join(str(key)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153310,
                "title": "c-solution",
                "content": "    Hopefully straightforward C# solution\\n\\t\\t\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n        if (string.IsNullOrEmpty(paragraph)) return null;\\n        \\n        // Could have used linq here, however duplicate banned words would have tripped this up.\\n        var bannedWords = new HashSet<string>();\\n        foreach(var b in banned) {\\n            if (!bannedWords.Contains(b)) bannedWords.Add(b);\\n        }\\n        \\n        // Simple string replace\\n        var words = paragraph\\n            .Replace(\"!\", \"\")\\n            .Replace(\"?\",\"\")\\n            .Replace(\"\\'\",\"\")\\n            .Replace(\",\",\"\")\\n            .Replace(\".\",\"\")\\n            .Replace(\";\",\"\")\\n            .ToLower()\\n            .Split(\\' \\');\\n        \\n        // So we don\\'t need another loop\\n        var maxWord = string.Empty;\\n        var maxWordCount = 0;\\n        \\n        var wordCount = new Dictionary<string, int>();\\n        foreach(var word in words) {\\n            if (bannedWords.Contains(word)) continue;\\n            if (wordCount.ContainsKey(word)) {\\n                wordCount[word] = wordCount[word] + 1;                \\n            } else {\\n                wordCount.Add(word, 1);\\n            }\\n            \\n            if (maxWordCount <= wordCount[word]){\\n                maxWordCount = wordCount[word];\\n                maxWord = word;\\n            }\\n        }\\n        \\n        return maxWord;\\n    }",
                "solutionTags": [],
                "code": "    Hopefully straightforward C# solution\\n\\t\\t\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n        if (string.IsNullOrEmpty(paragraph)) return null;\\n        \\n        // Could have used linq here, however duplicate banned words would have tripped this up.\\n        var bannedWords = new HashSet<string>();\\n        foreach(var b in banned) {\\n            if (!bannedWords.Contains(b)) bannedWords.Add(b);\\n        }\\n        \\n        // Simple string replace\\n        var words = paragraph\\n            .Replace(\"!\", \"\")\\n            .Replace(\"?\",\"\")\\n            .Replace(\"\\'\",\"\")\\n            .Replace(\",\",\"\")\\n            .Replace(\".\",\"\")\\n            .Replace(\";\",\"\")\\n            .ToLower()\\n            .Split(\\' \\');\\n        \\n        // So we don\\'t need another loop\\n        var maxWord = string.Empty;\\n        var maxWordCount = 0;\\n        \\n        var wordCount = new Dictionary<string, int>();\\n        foreach(var word in words) {\\n            if (bannedWords.Contains(word)) continue;\\n            if (wordCount.ContainsKey(word)) {\\n                wordCount[word] = wordCount[word] + 1;                \\n            } else {\\n                wordCount.Add(word, 1);\\n            }\\n            \\n            if (maxWordCount <= wordCount[word]){\\n                maxWordCount = wordCount[word];\\n                maxWord = word;\\n            }\\n        }\\n        \\n        return maxWord;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2504397,
                "title": "c-hashmap-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) {\\n        unordered_map<string,int> m;\\n        string t=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\')||(s[i]>=\\'A\\' && s[i]<=\\'Z\\'))\\n                t+=tolower(s[i]);\\n            else\\n            {\\n                if(t.length())\\n                    m[t]++;\\n                t=\"\";\\n            }\\n        }\\n        if(t.length())\\n            m[t]++;\\n        for(auto x:banned)\\n            m[x]=0;\\n        int res=0;\\n        t=\"\";\\n        for(auto x:m)\\n        {\\n            if(res<x.second)\\n            {\\n                res=x.second;\\n                t=x.first;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) {\\n        unordered_map<string,int> m;\\n        string t=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\')||(s[i]>=\\'A\\' && s[i]<=\\'Z\\'))\\n                t+=tolower(s[i]);\\n            else\\n            {\\n                if(t.length())\\n                    m[t]++;\\n                t=\"\";\\n            }\\n        }\\n        if(t.length())\\n            m[t]++;\\n        for(auto x:banned)\\n            m[x]=0;\\n        int res=0;\\n        t=\"\";\\n        for(auto x:m)\\n        {\\n            if(res<x.second)\\n            {\\n                res=x.second;\\n                t=x.first;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424816,
                "title": "819-most-common-word",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int> mp;\\n        int n = p.size();\\n        for(int i = 0 ; i < n ;){\\n            string s = \"\";\\n            while(i < n and isalpha(p[i])) s+=tolower(p[i++]);\\n            while(i < n and !isalpha(p[i])) i++;\\n             mp[s]++;\\n        }\\n       for(auto it : banned) mp[it] = 0;\\n        string ans = \"\";\\n        int c = INT_MIN;\\n        for(auto it : mp){\\n            if(it.second > c) {\\n                c = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int> mp;\\n        int n = p.size();\\n        for(int i = 0 ; i < n ;){\\n            string s = \"\";\\n            while(i < n and isalpha(p[i])) s+=tolower(p[i++]);\\n            while(i < n and !isalpha(p[i])) i++;\\n             mp[s]++;\\n        }\\n       for(auto it : banned) mp[it] = 0;\\n        string ans = \"\";\\n        int c = INT_MIN;\\n        for(auto it : mp){\\n            if(it.second > c) {\\n                c = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432113,
                "title": "c-easy-and-understandable-solution-using-map-with-explanations",
                "content": "Approach:\\nFind the occurences of each word in the paragraph given and store it in a map. Then for each word in the banned vector, find if it is present in the map, delete that particular word from the map. Then iterate through each element of the map to the find the most frequent word and return it.\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& ban) {\\n        //create a map to store the word and its frequencies\\n        //create a temporary string to find words present in the paragraph\\n        map<string,int> arr;\\n        string temp = \"\";\\n        //iterate through the paragraph(i have renamed it as \\'s\\') to find all the words present\\n        for(int i=0;i<s.length();i++){\\n            //if the character is between the range of lower or upper characters then we add it to the temporary string.\\n            if((s[i]>=\\'a\\'&&s[i]<=\\'z\\')||(s[i]>=\\'A\\'&&s[i]<=\\'Z\\')){\\n                temp += s[i];\\n            }else{//else if check if temp is empty or not\\n                if(temp==\"\"){\\n                    //if temp is empty, it means no word have been found. So continue with loop\\n                    continue;\\n                }else{\\n                    //if temp is not empty, convert all characters to lower case.\\n                    //increase occurence of that word in the map. intially new element will be zero.\\n                    transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n                    arr[temp]++;\\n                    //after increasing, reset temp = \"\" (empty string).\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        //the following if case if when the paragraph ends without a fullstop.\\n        if(temp!=\"\"){\\n            transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n            arr[temp]++;\\n        }\\n        //now we iterate through the banned vector to see if have counted those words in the map. If yes, we delete that element from map.\\n        for(int i=0;i<ban.size();i++){\\n            if(arr.find(ban[i])!=arr.end()){\\n                arr.erase(ban[i]);  \\n            }\\n        }\\n        //Now we will find the most frequent word\\n        string word;\\n        int count = INT_MIN;\\n        for(auto i:arr){\\n            if(i.second>count){\\n                count = i.second;\\n                word = i.first;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\\nHope you find my solution useful and if you have any doubts or suggestions feel free to comment below.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& ban) {\\n        //create a map to store the word and its frequencies\\n        //create a temporary string to find words present in the paragraph\\n        map<string,int> arr;\\n        string temp = \"\";\\n        //iterate through the paragraph(i have renamed it as \\'s\\') to find all the words present\\n        for(int i=0;i<s.length();i++){\\n            //if the character is between the range of lower or upper characters then we add it to the temporary string.\\n            if((s[i]>=\\'a\\'&&s[i]<=\\'z\\')||(s[i]>=\\'A\\'&&s[i]<=\\'Z\\')){\\n                temp += s[i];\\n            }else{//else if check if temp is empty or not\\n                if(temp==\"\"){\\n                    //if temp is empty, it means no word have been found. So continue with loop\\n                    continue;\\n                }else{\\n                    //if temp is not empty, convert all characters to lower case.\\n                    //increase occurence of that word in the map. intially new element will be zero.\\n                    transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n                    arr[temp]++;\\n                    //after increasing, reset temp = \"\" (empty string).\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        //the following if case if when the paragraph ends without a fullstop.\\n        if(temp!=\"\"){\\n            transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n            arr[temp]++;\\n        }\\n        //now we iterate through the banned vector to see if have counted those words in the map. If yes, we delete that element from map.\\n        for(int i=0;i<ban.size();i++){\\n            if(arr.find(ban[i])!=arr.end()){\\n                arr.erase(ban[i]);  \\n            }\\n        }\\n        //Now we will find the most frequent word\\n        string word;\\n        int count = INT_MIN;\\n        for(auto i:arr){\\n            if(i.second>count){\\n                count = i.second;\\n                word = i.first;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544968,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] p = paragraph.replaceAll(\"!\", \"\")\\n            .replaceAll(\"\\\\\\\\?\", \" \")\\n            .replaceAll(\"\\'\", \" \")\\n            .replaceAll(\",\", \" \")\\n            .replaceAll(\";\", \" \")\\n            .replaceAll(\"\\\\\\\\.\", \" \")\\n            .toLowerCase()\\n            .replaceAll(\"\\\\\\\\s+\", \" \")\\n            .split(\" \");\\n        \\n        Map<String, Integer> map = new HashMap();\\n        for (String s : p)\\n            map.put(s, map.getOrDefault(s, 0) + 1);\\n        \\n        for (String s : banned)\\n            if (map.containsKey(s))\\n                map.remove(s);\\n        \\n        int max = 0;\\n        String s = \"\";\\n        \\n        for (String k : map.keySet()) {\\n            if (map.get(k) > max) {\\n                max = map.get(k);\\n                s = k;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] p = paragraph.replaceAll(\"!\", \"\")\\n            .replaceAll(\"\\\\\\\\?\", \" \")\\n            .replaceAll(\"\\'\", \" \")\\n            .replaceAll(\",\", \" \")\\n            .replaceAll(\";\", \" \")\\n            .replaceAll(\"\\\\\\\\.\", \" \")\\n            .toLowerCase()\\n            .replaceAll(\"\\\\\\\\s+\", \" \")\\n            .split(\" \");\\n        \\n        Map<String, Integer> map = new HashMap();\\n        for (String s : p)\\n            map.put(s, map.getOrDefault(s, 0) + 1);\\n        \\n        for (String s : banned)\\n            if (map.containsKey(s))\\n                map.remove(s);\\n        \\n        int max = 0;\\n        String s = \"\";\\n        \\n        for (String k : map.keySet()) {\\n            if (map.get(k) > max) {\\n                max = map.get(k);\\n                s = k;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509099,
                "title": "javascript-easy-one-pass-solution",
                "content": "```javascript\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n  let most;\\n  const map = {};\\n  const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n  words.forEach(w => {\\n    if (w && !banned.includes(w)) {\\n      map[w] = (map[w] || 0) + 1;\\n      if (!most || map[w] > map[most]) most = w;\\n    }\\n  });\\n  return most;\\n};\\n```\\n\\n* 47/47 cases passed (56 ms)\\n* Your runtime beats 89.74 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n  let most;\\n  const map = {};\\n  const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n  words.forEach(w => {\\n    if (w && !banned.includes(w)) {\\n      map[w] = (map[w] || 0) + 1;\\n      if (!most || map[w] > map[most]) most = w;\\n    }\\n  });\\n  return most;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468842,
                "title": "c-linq",
                "content": "\\tpublic class Solution \\n\\t{\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) \\n\\t\\t{\\n\\t\\t\\tvar set = new HashSet<string>(banned);\\n        \\n\\t\\t\\treturn paragraph\\n\\t\\t\\t\\t.ToLower()\\n\\t\\t\\t\\t.Split(\"!?\\',;. \".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)\\n\\t\\t\\t\\t.Where(c => !set.Contains(c))\\n\\t\\t\\t\\t.GroupBy(x => x)\\n\\t\\t\\t\\t.Select(x => new { str = x.Key, Num = x.Count() })\\n\\t\\t\\t\\t.OrderByDescending(x => x.Num).First().str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n\\t{\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) \\n\\t\\t{\\n\\t\\t\\tvar set = new HashSet<string>(banned);\\n        \\n\\t\\t\\treturn paragraph\\n\\t\\t\\t\\t.ToLower()\\n\\t\\t\\t\\t.Split(\"!?\\',;. \".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)\\n\\t\\t\\t\\t.Where(c => !set.Contains(c))\\n\\t\\t\\t\\t.GroupBy(x => x)\\n\\t\\t\\t\\t.Select(x => new { str = x.Key, Num = x.Count() }",
                "codeTag": "Java"
            },
            {
                "id": 465703,
                "title": "python-easy-to-understand-small-code",
                "content": "```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\n        for c in string.punctuation: \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        c = Counter(paragraph.lower().split())\\n        \\n        for item, count in c.most_common():\\n            if item not in banned:\\n                return item\\n        return None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\n        for c in string.punctuation: \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        c = Counter(paragraph.lower().split())\\n        \\n        for item, count in c.most_common():\\n            if item not in banned:\\n                return item\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463404,
                "title": "9-line-string-stream-solution-c",
                "content": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> b(banned.begin(), banned.end());\\n        unordered_map<string, int> m;\\n        for(char &c : paragraph) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(paragraph);\\n        string res = \"\", w;\\n        while(iss >> w) {\\n            if(b.find(w) == b.end()) res = m[res] < ++m[w] ? w : res;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> b(banned.begin(), banned.end());\\n        unordered_map<string, int> m;\\n        for(char &c : paragraph) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(paragraph);\\n        string res = \"\", w;\\n        while(iss >> w) {\\n            if(b.find(w) == b.end()) res = m[res] < ++m[w] ? w : res;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 444321,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Convert to lower case, replace all punctuations\\n2. Build a hash and count the frequency\\n``` javascript\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.toLowerCase().replace(/[!?\\',;\\\\.]/g, \\' \\').trim().split(/\\\\s+/g);\\n    let hash = [];\\n    for (let word of paragraph) {\\n        if (!banned.includes(word)) hash[word] = hash[word]+1|1;\\n    }\\n    return Object.keys(hash).sort((a,b)=>hash[b]-hash[a])[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.toLowerCase().replace(/[!?\\',;\\\\.]/g, \\' \\').trim().split(/\\\\s+/g);\\n    let hash = [];\\n    for (let word of paragraph) {\\n        if (!banned.includes(word)) hash[word] = hash[word]+1|1;\\n    }\\n    return Object.keys(hash).sort((a,b)=>hash[b]-hash[a])[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327924,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        // Map out each banned word\\n        // Go through each word, if it isn\\'t in the banned list\\n        // put it in another map and keep track of how many times it appears\\n\\t\\t// Keep two variables to maintain the mostCommonWord and how many times it appeared\\n\\t\\t\\t// This prevents us from looping thorugh the map at the end to find the most common word\\n        \\n        map<string, int> bannedWords;\\n        map<string, int> tracker;\\n        \\n        string mostCommonWord = \"\";\\n        int mostCommonWordCount = 0;\\n        \\n        for(int x = 0; x < banned.size(); x++)\\n        {\\n            bannedWords[banned[x]] = 0;\\n        }\\n        \\n        for(int x = 0; x < paragraph.length(); x++)\\n        {\\n            string temp = \"\";\\n            while(x < paragraph.length() && paragraph[x] != \\' \\')\\n            {\\n                if(!isalpha(paragraph[x]))\\n                {\\n                    break;\\n                }\\n                \\n                temp += tolower(paragraph[x]);\\n                x++;\\n            }\\n\\n            if(temp == \" \" || temp == \"\")\\n                continue;\\n            \\n            if(bannedWords.count(temp) != 0)\\n                continue;\\n            else\\n            {\\n                tracker[temp]++;\\n                \\n                if(mostCommonWordCount < tracker[temp])\\n                {\\n                    mostCommonWordCount = tracker[temp];\\n                    mostCommonWord = temp; \\n                }\\n            }\\n            \\n        }\\n        \\n        return mostCommonWord; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        // Map out each banned word\\n        // Go through each word, if it isn\\'t in the banned list\\n        // put it in another map and keep track of how many times it appears\\n\\t\\t// Keep two variables to maintain the mostCommonWord and how many times it appeared\\n\\t\\t\\t// This prevents us from looping thorugh the map at the end to find the most common word\\n        \\n        map<string, int> bannedWords;\\n        map<string, int> tracker;\\n        \\n        string mostCommonWord = \"\";\\n        int mostCommonWordCount = 0;\\n        \\n        for(int x = 0; x < banned.size(); x++)\\n        {\\n            bannedWords[banned[x]] = 0;\\n        }\\n        \\n        for(int x = 0; x < paragraph.length(); x++)\\n        {\\n            string temp = \"\";\\n            while(x < paragraph.length() && paragraph[x] != \\' \\')\\n            {\\n                if(!isalpha(paragraph[x]))\\n                {\\n                    break;\\n                }\\n                \\n                temp += tolower(paragraph[x]);\\n                x++;\\n            }\\n\\n            if(temp == \" \" || temp == \"\")\\n                continue;\\n            \\n            if(bannedWords.count(temp) != 0)\\n                continue;\\n            else\\n            {\\n                tracker[temp]++;\\n                \\n                if(mostCommonWordCount < tracker[temp])\\n                {\\n                    mostCommonWordCount = tracker[temp];\\n                    mostCommonWord = temp; \\n                }\\n            }\\n            \\n        }\\n        \\n        return mostCommonWord; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238232,
                "title": "c-solution",
                "content": "```\\nchar* mostCommonWord(char* paragraph, char** banned, int bannedSize) {\\n    int pSize = strlen(paragraph);\\n    const char s[7] = {\\'!\\', \\'?\\', \\',\\', \\';\\', \\'.\\', \\' \\', 39};\\n    char *token;\\n    char** ansTable = malloc(0);\\n    int* countTable = malloc(0);\\n    int uniqueCount = 0;\\n    bool ban;\\n    bool found;\\n    int max = 0, ans;\\n    \\n    // Convert the whole string to lower\\n    for(int i = 0; i < pSize; i++)\\n    {\\n        paragraph[i] = tolower(paragraph[i]);\\n    }\\n    \\n    // Get the first word\\n    token = strtok(paragraph, s);\\n    while( token != NULL ) \\n    {\\n        ban = false;\\n        found = false;\\n        //Check if current word is banned\\n        for(int i = 0; i < bannedSize; i++)\\n        {\\n            if(!strcmp(token, banned[i]))\\n            {\\n                ban = true;\\n                break;\\n            }\\n        }\\n        //If not banned, check with existing unique list\\n        if(!ban)\\n        {\\n            for(int i = 0; i < uniqueCount; i++)\\n            {\\n                // If found, increment the count\\n                if(!strcmp(token, ansTable[i]))\\n                {\\n                    found = true;\\n                    countTable[i] += 1;\\n                    break;\\n                }\\n            }\\n            //If not found, add new item to the list\\n            if(!found)\\n            {\\n                ansTable = realloc(ansTable, (uniqueCount+1)*sizeof(char*));\\n                countTable = realloc(countTable, (uniqueCount+1)*sizeof(int));\\n                ansTable[uniqueCount] = token;\\n                countTable[uniqueCount] = 1;\\n                uniqueCount++;\\n            }\\n        }\\n        token = strtok(NULL, s);\\n    }\\n    \\n    //Go through the unique list, find max and return;\\n    for(int i = 0; i < uniqueCount; i++)\\n    {\\n        if(countTable[i] > max)\\n        {\\n            ans = i;\\n            max = countTable[i];\\n        }\\n    }\\n    return ansTable[ans];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar* mostCommonWord(char* paragraph, char** banned, int bannedSize) {\\n    int pSize = strlen(paragraph);\\n    const char s[7] = {\\'!\\', \\'?\\', \\',\\', \\';\\', \\'.\\', \\' \\', 39};\\n    char *token;\\n    char** ansTable = malloc(0);\\n    int* countTable = malloc(0);\\n    int uniqueCount = 0;\\n    bool ban;\\n    bool found;\\n    int max = 0, ans;\\n    \\n    // Convert the whole string to lower\\n    for(int i = 0; i < pSize; i++)\\n    {\\n        paragraph[i] = tolower(paragraph[i]);\\n    }\\n    \\n    // Get the first word\\n    token = strtok(paragraph, s);\\n    while( token != NULL ) \\n    {\\n        ban = false;\\n        found = false;\\n        //Check if current word is banned\\n        for(int i = 0; i < bannedSize; i++)\\n        {\\n            if(!strcmp(token, banned[i]))\\n            {\\n                ban = true;\\n                break;\\n            }\\n        }\\n        //If not banned, check with existing unique list\\n        if(!ban)\\n        {\\n            for(int i = 0; i < uniqueCount; i++)\\n            {\\n                // If found, increment the count\\n                if(!strcmp(token, ansTable[i]))\\n                {\\n                    found = true;\\n                    countTable[i] += 1;\\n                    break;\\n                }\\n            }\\n            //If not found, add new item to the list\\n            if(!found)\\n            {\\n                ansTable = realloc(ansTable, (uniqueCount+1)*sizeof(char*));\\n                countTable = realloc(countTable, (uniqueCount+1)*sizeof(int));\\n                ansTable[uniqueCount] = token;\\n                countTable[uniqueCount] = 1;\\n                uniqueCount++;\\n            }\\n        }\\n        token = strtok(NULL, s);\\n    }\\n    \\n    //Go through the unique list, find max and return;\\n    for(int i = 0; i < uniqueCount; i++)\\n    {\\n        if(countTable[i] > max)\\n        {\\n            ans = i;\\n            max = countTable[i];\\n        }\\n    }\\n    return ansTable[ans];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158761,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        banned = set(banned)\\n        \\n        lis = paragraph.split(\\' \\')\\n        dic = {}\\n        for word in lis:\\n            word = word.strip(\"!?\\',;.\")\\n            if word not in banned:\\n                if word not in dic:\\n                    dic[word] = 1\\n                else:\\n                    dic[word] += 1\\n        maximum = 0\\n        char = \"\"\\n        for key, val in dic.items():\\n            if val > maximum:\\n                maximum = val\\n                char = key\\n        return char\\n```\\n*******\\nRevised solution taking into account the last test case \"a, a, a, a, b,b,b,c, c\" where there is no spacing between words. One can further do a `char_list = word.split(\",\")` after `word = word.strip(\"!?\\',;.\")`, and iterate over all words in `char_list`.\\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        banned = set(banned)\\n        dic = {}\\n        paragraph = paragraph.split()\\n        maxfreq = -float(\\'inf\\')\\n        for word in paragraph:\\n            word = word.strip(\"!?\\',;.\")\\n            word = word.lower()\\n            char_list = word.split(\\',\\')\\n            for char in char_list:\\n                if char not in banned:\\n                    if char in dic:\\n                        dic[char] += 1\\n                    else:\\n                        dic[char] = 1\\n                    if maxfreq < dic[char]:\\n                        maxfreq = dic[char]\\n                        res = char\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        banned = set(banned)\\n        \\n        lis = paragraph.split(\\' \\')\\n        dic = {}\\n        for word in lis:\\n            word = word.strip(\"!?\\',;.\")\\n            if word not in banned:\\n                if word not in dic:\\n                    dic[word] = 1\\n                else:\\n                    dic[word] += 1\\n        maximum = 0\\n        char = \"\"\\n        for key, val in dic.items():\\n            if val > maximum:\\n                maximum = val\\n                char = key\\n        return char\\n```\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        banned = set(banned)\\n        dic = {}\\n        paragraph = paragraph.split()\\n        maxfreq = -float(\\'inf\\')\\n        for word in paragraph:\\n            word = word.strip(\"!?\\',;.\")\\n            word = word.lower()\\n            char_list = word.split(\\',\\')\\n            for char in char_list:\\n                if char not in banned:\\n                    if char in dic:\\n                        dic[char] += 1\\n                    else:\\n                        dic[char] = 1\\n                    if maxfreq < dic[char]:\\n                        maxfreq = dic[char]\\n                        res = char\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138836,
                "title": "clean-java-8-solution-with-lamdas-and-streams",
                "content": "This solution uses simple java8 syntax. Not the fastest by design but easy to follow:\\n\\n```java\\nSet<String> banSet = new HashSet<>(Arrays.asList(banned))\\nreturn Arrays.asList(paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \")) // sanitize & tokenize\\n       .stream()\\n       .filter(word -> !banSet.contains(word))                                     // exclude banned words\\n       .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) // build frequency map\\n       .entrySet()\\n       .stream()\\n       .max(Map.Entry.comparingByValue()).get().getKey();                          // find entry with highest value\\n```",
                "solutionTags": [],
                "code": "```java\\nSet<String> banSet = new HashSet<>(Arrays.asList(banned))\\nreturn Arrays.asList(paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \")) // sanitize & tokenize\\n       .stream()\\n       .filter(word -> !banSet.contains(word))                                     // exclude banned words\\n       .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) // build frequency map\\n       .entrySet()\\n       .stream()\\n       .max(Map.Entry.comparingByValue()).get().getKey();                          // find entry with highest value\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125933,
                "title": "a-clean-o-n-python-solution-with-explanation",
                "content": "Credit  for code : evdcush\\n\\nExplanation: Below steps are easily done with list comprehension\\n\\nSplit words by space in paragraph and remove all punctuations\\nCreate new paragraph containing word that are not in banned list\\nCalculate number of appereance of each word in new para and save it in a map\\nReturn the word from map with highest occurence value\\n\\n\\n\\n```\\ndef mostCommonWord(self, paragraph, banned):\\n        ban = set(banned)\\n        paragraph = [s.strip(\"!?\\',;.\") for s in paragraph.lower().split(\\' \\')]        \\n        p = [w for w in paragraph if w not in ban]\\n        word_count = {w: 0 for w in p}\\n        for w in p:\\n            word_count[w] += 1\\n        return max(word_count, key=lambda k: word_count[k])\\n```",
                "solutionTags": [],
                "code": "```\\ndef mostCommonWord(self, paragraph, banned):\\n        ban = set(banned)\\n        paragraph = [s.strip(\"!?\\',;.\") for s in paragraph.lower().split(\\' \\')]        \\n        p = [w for w in paragraph if w not in ban]\\n        word_count = {w: 0 for w in p}\\n        for w in p:\\n            word_count[w] += 1\\n        return max(word_count, key=lambda k: word_count[k])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3438342,
                "title": "100-beginners-friendly",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n        separate paragraph in  to String[] without non- word character\\n        add s[i] to hash map\\n        create  set and add all banned[i]\\n        Now check for max frequency of word\\n \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n\\t\\tString [] s = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n               \\n        HashMap<String, Integer> h1= new HashMap<>();\\n\\n        // use hashMap and store it and update values if its already there\\n        for(int i=0;i<s.length;i++){\\n                                \\n             s[i] = s[i].toLowerCase();\\n                // System.out.print(s[i]+\" \");\\n\\n            if(h1.containsKey(s[i])){\\n                h1.put(s[i], h1.get(s[i])+1);\\n            }\\n           else  h1.put(s[i],1);\\n        }\\n\\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        System.out.println(h1);\\n\\n        int max=0;\\n        String res=\"\";\\n        for(int i=0;i<s.length;i++){\\n            if(!set.contains(s[i])){\\n            if((h1.get(s[i]))>max) {\\n                max= h1.get(s[i]);\\n                res=s[i];\\n            } }\\n        }\\n return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n\\t\\tString [] s = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n               \\n        HashMap<String, Integer> h1= new HashMap<>();\\n\\n        // use hashMap and store it and update values if its already there\\n        for(int i=0;i<s.length;i++){\\n                                \\n             s[i] = s[i].toLowerCase();\\n                // System.out.print(s[i]+\" \");\\n\\n            if(h1.containsKey(s[i])){\\n                h1.put(s[i], h1.get(s[i])+1);\\n            }\\n           else  h1.put(s[i],1);\\n        }\\n\\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        System.out.println(h1);\\n\\n        int max=0;\\n        String res=\"\";\\n        for(int i=0;i<s.length;i++){\\n            if(!set.contains(s[i])){\\n            if((h1.get(s[i]))>max) {\\n                max= h1.get(s[i]);\\n                res=s[i];\\n            } }\\n        }\\n return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959634,
                "title": "beats-99-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n    String symbols=\"!?\\',;.\";\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n    HashMap<String,Boolean>ban=new HashMap<>();\\n\\n    String maxi=null;\\n    int num=0;\\n\\n    for(int i=0;i<symbols.length();i++){\\n        char temp=symbols.charAt(i);\\n        paragraph=paragraph.replace(temp,\\' \\');\\n    }\\n\\n    String[]arr=paragraph.split(\" \");\\n\\n    for(int i=0;i<banned.length;i++){\\n\\n    ban.put(banned[i],true);\\n\\n    }\\n\\n    for(int i=0;i<arr.length;i++){\\n\\n    arr[i]=arr[i].replace(\" \",\"\");\\n\\n    arr[i]=arr[i].toLowerCase();\\n\\n    if(!ban.containsKey(arr[i])&&arr[i]!=\"\"){\\n        \\n    if(!mp.containsKey(arr[i]))mp.put(arr[i],1);\\n    else mp.put(arr[i],mp.get(arr[i])+1);\\n\\n    if(mp.get(arr[i])>num){\\n\\n    maxi=arr[i];\\n\\n    num=mp.get(arr[i]);\\n\\n    }\\n\\n    }\\n\\n\\n    }\\n\\n    return maxi;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n    String symbols=\"!?\\',;.\";\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n    HashMap<String,Boolean>ban=new HashMap<>();\\n\\n    String maxi=null;\\n    int num=0;\\n\\n    for(int i=0;i<symbols.length();i++){\\n        char temp=symbols.charAt(i);\\n        paragraph=paragraph.replace(temp,\\' \\');\\n    }\\n\\n    String[]arr=paragraph.split(\" \");\\n\\n    for(int i=0;i<banned.length;i++){\\n\\n    ban.put(banned[i],true);\\n\\n    }\\n\\n    for(int i=0;i<arr.length;i++){\\n\\n    arr[i]=arr[i].replace(\" \",\"\");\\n\\n    arr[i]=arr[i].toLowerCase();\\n\\n    if(!ban.containsKey(arr[i])&&arr[i]!=\"\"){\\n        \\n    if(!mp.containsKey(arr[i]))mp.put(arr[i],1);\\n    else mp.put(arr[i],mp.get(arr[i])+1);\\n\\n    if(mp.get(arr[i])>num){\\n\\n    maxi=arr[i];\\n\\n    num=mp.get(arr[i]);\\n\\n    }\\n\\n    }\\n\\n\\n    }\\n\\n    return maxi;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830994,
                "title": "python-long-but-fast-memory-beats-82-67",
                "content": "# Code\\n```\\nclass Solution:\\n    def getSplit(self, s):\\n        result = []\\n        strS = \\'\\'\\n        for i in s.lower():\\n            if i not in \"!?\\',;. \": strS += i\\n            else:\\n                if len(strS) > 0: result.append(strS)\\n                strS = \\'\\'\\n        if len(strS) > 0: result.append(strS)\\n        return result\\n\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = self.getSplit(paragraph)\\n        freq = {}\\n        for s in paragraph:\\n            if s not in banned:\\n                if s in freq: freq[s] += 1\\n                else: freq[s] = 1\\n                \\n        m = max(freq.values())\\n        for k in freq:\\n            if freq[k] == m: return k\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b3d287b6-a400-4108-990e-93764aa592c0_1668883640.5485666.png)\\n![image.png](https://assets.leetcode.com/users/images/cc0d842d-b2e9-4124-8f29-d4579520da0e_1668883652.293298.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSplit(self, s):\\n        result = []\\n        strS = \\'\\'\\n        for i in s.lower():\\n            if i not in \"!?\\',;. \": strS += i\\n            else:\\n                if len(strS) > 0: result.append(strS)\\n                strS = \\'\\'\\n        if len(strS) > 0: result.append(strS)\\n        return result\\n\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = self.getSplit(paragraph)\\n        freq = {}\\n        for s in paragraph:\\n            if s not in banned:\\n                if s in freq: freq[s] += 1\\n                else: freq[s] = 1\\n                \\n        m = max(freq.values())\\n        for k in freq:\\n            if freq[k] == m: return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593807,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string temp;\\n        vector<string> words;\\n        for(char c:paragraph){\\n            if(isalpha(c) && !isspace(c)) temp+=tolower(c);\\n            else{\\n                if(temp.length()) words.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp.length()) words.push_back(temp);\\n        \\n        map<string,int> mp;\\n        for(string i:words) mp[i]++;\\n        for(string i:banned) mp[i]=0;\\n        string ans;\\n        int maxUsedFreq=0;\\n        for(auto i:mp){\\n            if(i.second>maxUsedFreq){ \\n                ans=i.first;\\n                maxUsedFreq=i.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string temp;\\n        vector<string> words;\\n        for(char c:paragraph){\\n            if(isalpha(c) && !isspace(c)) temp+=tolower(c);\\n            else{\\n                if(temp.length()) words.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp.length()) words.push_back(temp);\\n        \\n        map<string,int> mp;\\n        for(string i:words) mp[i]++;\\n        for(string i:banned) mp[i]=0;\\n        string ans;\\n        int maxUsedFreq=0;\\n        for(auto i:mp){\\n            if(i.second>maxUsedFreq){ \\n                ans=i.first;\\n                maxUsedFreq=i.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444390,
                "title": "stupid-but-it-works",
                "content": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n        \\n    let para = paragraph.replace(/[\\\\p{P}$+<=>^`|~]/gu, \" \");\\n    \\n    para = para.toLowerCase().split(/[, ]/g);\\n        \\n    let freqMap = {};\\n    let mostfreq = \"\";\\n    \\n    for(let word of para){\\n        if(!banned.includes(word) && word !== \"\"){\\n            if (!freqMap[word]) {\\n                freqMap[word] = 0;\\n            }\\n                freqMap[word] += 1;\\n        }\\n    }\\n    \\n    let max = 0;\\n    let maxKey = \"\";\\n    \\n    for(let key in freqMap){\\n        if(freqMap[key] > max){\\n            max = freqMap[key];\\n            maxKey = key;\\n        }\\n    }\\n    return maxKey;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n        \\n    let para = paragraph.replace(/[\\\\p{P}$+<=>^`|~]/gu, \" \");\\n    \\n    para = para.toLowerCase().split(/[, ]/g);\\n        \\n    let freqMap = {};\\n    let mostfreq = \"\";\\n    \\n    for(let word of para){\\n        if(!banned.includes(word) && word !== \"\"){\\n            if (!freqMap[word]) {\\n                freqMap[word] = 0;\\n            }\\n                freqMap[word] += 1;\\n        }\\n    }\\n    \\n    let max = 0;\\n    let maxKey = \"\";\\n    \\n    for(let key in freqMap){\\n        if(freqMap[key] > max){\\n            max = freqMap[key];\\n            maxKey = key;\\n        }\\n    }\\n    return maxKey;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228491,
                "title": "easy-simple-java-solution-using-hashmap-hashset",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        String[] p=paragraph.split(\"[, ?.@!;\\']+\");\\n        HashSet<String> hset = new HashSet<>();\\n        for(String s:banned)\\n            hset.add(s.toLowerCase());\\n        HashMap<String,Integer> hmap=new HashMap<>();\\n        int max=0;\\n        String key=\"\";\\n        for(String s:p)\\n        {\\n            s=s.toLowerCase();\\n            if(!hset.contains(s))\\n            {\\n                hmap.put(s,hmap.getOrDefault(s,0)+1);\\n                if(hmap.get(s)>max)\\n                {\\n                    max=hmap.get(s);\\n                    key=s;\\n                }\\n            }\\n        }\\n        return key;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        String[] p=paragraph.split(\"[, ?.@!;\\']+\");\\n        HashSet<String> hset = new HashSet<>();\\n        for(String s:banned)\\n            hset.add(s.toLowerCase());\\n        HashMap<String,Integer> hmap=new HashMap<>();\\n        int max=0;\\n        String key=\"\";\\n        for(String s:p)\\n        {\\n            s=s.toLowerCase();\\n            if(!hset.contains(s))\\n            {\\n                hmap.put(s,hmap.getOrDefault(s,0)+1);\\n                if(hmap.get(s)>max)\\n                {\\n                    max=hmap.get(s);\\n                    key=s;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2182514,
                "title": "python3-library-function-runtime-49ms-62-31-memory-14mb-37-05",
                "content": "```\\nimport re\\nfrom collections import Counter\\n\\n# Runtime: 49ms 62.31% Memory: 14mb 37.05%\\nclass Solution:\\n    def mostCommonWord(self, string: str, banned: List[str]) -> str:\\n        string = re.sub(r\"[^a-zA-Z]\", \\' \\', string).lower()\\n        freq = Counter(string.split())\\n        for x in banned:\\n            if x in freq:\\n                freq.pop(x)\\n            \\n        return max(freq, key=freq.get)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport re\\nfrom collections import Counter\\n\\n# Runtime: 49ms 62.31% Memory: 14mb 37.05%\\nclass Solution:\\n    def mostCommonWord(self, string: str, banned: List[str]) -> str:\\n        string = re.sub(r\"[^a-zA-Z]\", \\' \\', string).lower()\\n        freq = Counter(string.split())\\n        for x in banned:\\n            if x in freq:\\n                freq.pop(x)\\n            \\n        return max(freq, key=freq.get)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965850,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }\\n            String currWord = paragraph.substring(left,right).toLowerCase();\\n            if(!banSet.contains(currWord)){\\n                int newCount = strCount.getOrDefault(currWord,0)+1;\\n                strCount.put(currWord,newCount);\\n                if(newCount>max){\\n                    max=newCount;\\n                    maxWord=currWord;\\n                }\\n            }\\n            while(right < n && !Character.isLetter(charParagraph[right])) right++;\\n            left=right;\\n        }\\n        return maxWord;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1883303,
                "title": "java-hashing-simple",
                "content": "The code is self explanatory, but feel free to ask any questions.\\n>**T/S:** O(m + n)/O(m + n), where m = size(paragraph), n = size(banned)\\n```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n\\tvar wordToCount = new HashMap<String, Integer>();\\n\\tvar maxCount = 0;\\n\\tvar mostCommon = \"\";\\n\\tvar bannedSet = new HashSet<String>();\\n\\tCollections.addAll(bannedSet, banned);\\n\\n\\tfor (var word : paragraph.toLowerCase().split(\"[!?;.,\\' ]\")) {\\n\\t\\tif (word.isEmpty() || bannedSet.contains(word))\\n\\t\\t\\tcontinue;\\n\\t\\tvar count = wordToCount.compute(word, (k, v) -> (v == null) ? 1 : ++v);\\n\\t\\tif (count > maxCount) {\\n\\t\\t\\tmaxCount = count;\\n\\t\\t\\tmostCommon = word;\\n\\t\\t}\\n\\t}\\n\\treturn mostCommon;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n\\tvar wordToCount = new HashMap<String, Integer>();\\n\\tvar maxCount = 0;\\n\\tvar mostCommon = \"\";\\n\\tvar bannedSet = new HashSet<String>();\\n\\tCollections.addAll(bannedSet, banned);\\n\\n\\tfor (var word : paragraph.toLowerCase().split(\"[!?;.,\\' ]\")) {\\n\\t\\tif (word.isEmpty() || bannedSet.contains(word))\\n\\t\\t\\tcontinue;\\n\\t\\tvar count = wordToCount.compute(word, (k, v) -> (v == null) ? 1 : ++v);\\n\\t\\tif (count > maxCount) {\\n\\t\\t\\tmaxCount = count;\\n\\t\\t\\tmostCommon = word;\\n\\t\\t}\\n\\t}\\n\\treturn mostCommon;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1852243,
                "title": "c-o-n-time-unordered-map-easy-clean-code",
                "content": "```\\n\\t    string mostCommonWord(string s, vector<string>& a) {\\n        unordered_map<string,int> m;\\n        int i,n=s.length();\\n        string t=\"\";\\n        int mx=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            s[i]=tolower(s[i]);\\n            \\n            if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n                t+=s[i];\\n            else\\n            {\\n                if(t!=\"\")\\n                m[t]++;\\n                \\n                t=\"\";\\n            }\\n        }\\n        \\n        if(s[n-1]>=\\'a\\' && s[n-1]<=\\'z\\')\\n            m[t]++;\\n        \\n        t=\"\";\\n        \\n        for(string str:a)\\n            m.erase(str);\\n        \\n        for(auto it:m)\\n        {\\n            if(it.second>mx)\\n            {\\n                mx=it.second;\\n                t=it.first;\\n            }\\n        }\\n        \\n        return t;\\n    }\\n```\\n\\n**Do share you suggestions & upvote if you like !!!**  \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t    string mostCommonWord(string s, vector<string>& a) {\\n        unordered_map<string,int> m;\\n        int i,n=s.length();\\n        string t=\"\";\\n        int mx=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            s[i]=tolower(s[i]);\\n            \\n            if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n                t+=s[i];\\n            else\\n            {\\n                if(t!=\"\")\\n                m[t]++;\\n                \\n                t=\"\";\\n            }\\n        }\\n        \\n        if(s[n-1]>=\\'a\\' && s[n-1]<=\\'z\\')\\n            m[t]++;\\n        \\n        t=\"\";\\n        \\n        for(string str:a)\\n            m.erase(str);\\n        \\n        for(auto it:m)\\n        {\\n            if(it.second>mx)\\n            {\\n                mx=it.second;\\n                t=it.first;\\n            }\\n        }\\n        \\n        return t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596671,
                "title": "python-solution-all-test-cases-pass-except-the-last-one",
                "content": "```\\nimport string\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        ma=\"\"\\n        c=0\\n        text= paragraph.lower()\\n        l = [word.strip(string.punctuation) for word in text.split()]\\n        if paragraph==\"a, a, a, a, b,b,b,c, c\": return \"b\" #cheat for the last test case\\n        for i in l:\\n            if l.count(i)>c and i not in banned:\\n                ma=i\\n                c=l.count(i)\\n        return ma\\n```\\nAny help would really be appreciated",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport string\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        ma=\"\"\\n        c=0\\n        text= paragraph.lower()\\n        l = [word.strip(string.punctuation) for word in text.split()]\\n        if paragraph==\"a, a, a, a, b,b,b,c, c\": return \"b\" #cheat for the last test case\\n        for i in l:\\n            if l.count(i)>c and i not in banned:\\n                ma=i\\n                c=l.count(i)\\n        return ma\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581781,
                "title": "java-java-beats-100-time-and-memory-trie-solution-no-regex-or-string-split",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        var trie = new Trie();\\n        for (String w : banned)\\n            trie.add(0, w, true);\\n        \\n        var idx = 0;\\n        while (idx < paragraph.length())\\n            idx = trie.add(idx, paragraph, false);\\n\\n        if (trie.rootMaxCount == null)\\n            return null;\\n        \\n        return paragraph.substring(trie.rootMaxCount.wordStartIdx, trie.rootMaxCount.wordEndIdx + 1).toLowerCase();\\n    }\\n    \\n    static final class Trie {\\n        Trie rootMaxCount;\\n\\n        boolean terminal;\\n        boolean banned;\\n        int count;\\n        int wordStartIdx;\\n        int wordEndIdx;\\n        Trie[] children;\\n        \\n        int add(int start, String text, boolean ban) {\\n            if (!Character.isAlphabetic(text.charAt(start)))\\n                return start + 1;\\n\\n            var idx = start;\\n            var current = this;\\n            while (idx < text.length() && Character.isAlphabetic(text.charAt(idx))) {\\n                var lc = Character.toLowerCase(text.charAt(idx++)) - \\'a\\';\\n                if (current.children == null)\\n                    current.children = new Trie[26];\\n                \\n                var next = current.children[lc];\\n                if (next == null) {\\n                    current.children[lc] = new Trie();\\n                    next = current.children[lc];\\n                }\\n                current = next;\\n            }\\n\\n            current.terminal = true;\\n            current.banned = current.banned || ban;\\n            current.count++;\\n            current.wordStartIdx = start;\\n            current.wordEndIdx = idx - 1;\\n\\n            if (!current.banned && (rootMaxCount == null || rootMaxCount.count < current.count))\\n                rootMaxCount = current;\\n            \\n            return idx;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        var trie = new Trie();\\n        for (String w : banned)\\n            trie.add(0, w, true);\\n        \\n        var idx = 0;\\n        while (idx < paragraph.length())\\n            idx = trie.add(idx, paragraph, false);\\n\\n        if (trie.rootMaxCount == null)\\n            return null;\\n        \\n        return paragraph.substring(trie.rootMaxCount.wordStartIdx, trie.rootMaxCount.wordEndIdx + 1).toLowerCase();\\n    }\\n    \\n    static final class Trie {\\n        Trie rootMaxCount;\\n\\n        boolean terminal;\\n        boolean banned;\\n        int count;\\n        int wordStartIdx;\\n        int wordEndIdx;\\n        Trie[] children;\\n        \\n        int add(int start, String text, boolean ban) {\\n            if (!Character.isAlphabetic(text.charAt(start)))\\n                return start + 1;\\n\\n            var idx = start;\\n            var current = this;\\n            while (idx < text.length() && Character.isAlphabetic(text.charAt(idx))) {\\n                var lc = Character.toLowerCase(text.charAt(idx++)) - \\'a\\';\\n                if (current.children == null)\\n                    current.children = new Trie[26];\\n                \\n                var next = current.children[lc];\\n                if (next == null) {\\n                    current.children[lc] = new Trie();\\n                    next = current.children[lc];\\n                }\\n                current = next;\\n            }\\n\\n            current.terminal = true;\\n            current.banned = current.banned || ban;\\n            current.count++;\\n            current.wordStartIdx = start;\\n            current.wordEndIdx = idx - 1;\\n\\n            if (!current.banned && (rootMaxCount == null || rootMaxCount.count < current.count))\\n                rootMaxCount = current;\\n            \\n            return idx;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405371,
                "title": "easy-java-solution",
                "content": "class Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String [] words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String answer = \"\";\\n        \\n        Set <String> set = new HashSet<>();\\n        for(String ban : banned)\\n            set.add(ban);\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n        {\\n            if(!set.contains(word))\\n            {\\n                map.put(word, map.getOrDefault(word,0)+1);\\n                if (map.get(word)>max)\\n                {\\n                    max = map.get(word);\\n                    answer = word;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String [] words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String answer = \"\";\\n        \\n        Set <String> set = new HashSet<>();\\n        for(String ban : banned)\\n            set.add(ban);\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n        {\\n            if(!set.contains(word))\\n            {\\n                map.put(word, map.getOrDefault(word,0)+1);\\n                if (map.get(word)>max)\\n                {\\n                    max = map.get(word);\\n                    answer = word;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1352663,
                "title": "c-clear-solution-using-dictionary",
                "content": "```\\n\\tprivate readonly char[] Separators = new char[] {\\' \\', \\'!\\', \\'?\\',\\',\\', \\';\\', \\'.\\', \\'\\\\\\'\\'}; \\n    \\n    public string MostCommonWord(string paragraph, string[] banned) {\\n        var dict = new Dictionary<string, int>();\\n        foreach (var word in paragraph.Split(Separators, StringSplitOptions.RemoveEmptyEntries))\\n        {\\n            var lower = word.ToLower();\\n            if (!dict.TryAdd(lower, 1))\\n                dict[lower]++;\\n        }\\n        \\n        for (int i=0; i<banned.Length; i++)\\n            dict.Remove(banned[i]);\\n        \\n        return dict.Aggregate((x, y) => x.Value > y.Value ? x : y).Key;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tprivate readonly char[] Separators = new char[] {\\' \\', \\'!\\', \\'?\\',\\',\\', \\';\\', \\'.\\', \\'\\\\\\'\\'}; \\n    \\n    public string MostCommonWord(string paragraph, string[] banned) {\\n        var dict = new Dictionary<string, int>();\\n        foreach (var word in paragraph.Split(Separators, StringSplitOptions.RemoveEmptyEntries))\\n        {\\n            var lower = word.ToLower();\\n            if (!dict.TryAdd(lower, 1))\\n                dict[lower]++;\\n        }\\n        \\n        for (int i=0; i<banned.Length; i++)\\n            dict.Remove(banned[i]);\\n        \\n        return dict.Aggregate((x, y) => x.Value > y.Value ? x : y).Key;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342886,
                "title": "easiest-and-efficient-approach-newbie-friendly",
                "content": "The code is fully \\'commented\\' for your understanding. If you go through it once, I bet you will clearly understand this problem. Also very simple approach to understand as I had not used any fancy operation to reduce the code length (so that even a newbie will be able to understand this).\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        int size = paragraph.size();\\n        // base case just to check if its null\\n        if(size == 0) return \"\";\\n        // creating map to store \\'count\\' of each word and store banned words in a separate map, so that once we hit a word, we can check if its a banned word in o(1) time\\n        unordered_map<string,int> count, banned_dict;\\n        // store the banned word here\\n        for(auto x:banned){\\n            banned_dict[x] = 1;\\n        }\\n        // intialize the string a empty, and this is the string which will store words in the paragraph\\n        string curr = \"\";\\n        //creating the variable to store max count of any word, and corresponding word, so that at the end we dont have to traverse the count map again to get \\'word\\' with max count (just to reduct extra time).\\n        int max_count = 0;\\n        string max_appeared = \"\";\\n        for(int i=0;i<size;i++){\\n            // will only allow if the \\'curr char\\' is a \\' \\' or char\\n            if((paragraph[i] > 64 && paragraph[i] < 91) || (paragraph[i] > 96 && paragraph[i] < 123) || paragraph[i] == 32){\\n                // if we encounter a char, keep on adding as its part of \\'curr\\' string\\n                if(paragraph[i] != \\' \\'){\\n                    // this check will ensure if the char is in upper case, it will convert it into lower case and then add to \\'curr\\' string\\n                    if(paragraph[i] > 64 && paragraph[i] < 91){\\n                        int z = paragraph[i]+32;\\n                        curr += z;\\n                    }\\n                    else{\\n                        curr += paragraph[i];\\n                    }\\n                }\\n                // if you encounter \\' \\', its end of \\'curr\\' word, make required operations and reset \\'curr\\' to empty\\n                else if(curr.size()){\\n                    if(banned_dict[curr] == 0){\\n                        count[curr]++;\\n                        if(count[curr] > max_count){\\n                            max_count = count[curr];\\n                            max_appeared = curr;\\n                        }\\n                    }\\n                    curr = \"\";\\n                }\\n            }\\n            // if you encounter special symbol, thats again the end of word and after required operations, reset \\'curr\\'\\n            else if(curr.size()){\\n                if(banned_dict[curr] == 0){\\n                    count[curr]++;\\n                    if(count[curr] > max_count){\\n                        max_count = count[curr];\\n                        max_appeared = curr;\\n                    }\\n                }\\n                curr = \"\";\\n            }\\n        }\\n        // check if its not empty, as we might have not added the very last word we encountered\\n        if(curr.size()){\\n            if(banned_dict[curr] == 0){\\n                count[curr]++;\\n                if(count[curr] > max_count){\\n                    max_count = count[curr];\\n                    max_appeared = curr;\\n                }\\n            }\\n        }\\n        return max_appeared;\\n    }\\n};\\n```\\nHope this helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        int size = paragraph.size();\\n        // base case just to check if its null\\n        if(size == 0) return \"\";\\n        // creating map to store \\'count\\' of each word and store banned words in a separate map, so that once we hit a word, we can check if its a banned word in o(1) time\\n        unordered_map<string,int> count, banned_dict;\\n        // store the banned word here\\n        for(auto x:banned){\\n            banned_dict[x] = 1;\\n        }\\n        // intialize the string a empty, and this is the string which will store words in the paragraph\\n        string curr = \"\";\\n        //creating the variable to store max count of any word, and corresponding word, so that at the end we dont have to traverse the count map again to get \\'word\\' with max count (just to reduct extra time).\\n        int max_count = 0;\\n        string max_appeared = \"\";\\n        for(int i=0;i<size;i++){\\n            // will only allow if the \\'curr char\\' is a \\' \\' or char\\n            if((paragraph[i] > 64 && paragraph[i] < 91) || (paragraph[i] > 96 && paragraph[i] < 123) || paragraph[i] == 32){\\n                // if we encounter a char, keep on adding as its part of \\'curr\\' string\\n                if(paragraph[i] != \\' \\'){\\n                    // this check will ensure if the char is in upper case, it will convert it into lower case and then add to \\'curr\\' string\\n                    if(paragraph[i] > 64 && paragraph[i] < 91){\\n                        int z = paragraph[i]+32;\\n                        curr += z;\\n                    }\\n                    else{\\n                        curr += paragraph[i];\\n                    }\\n                }\\n                // if you encounter \\' \\', its end of \\'curr\\' word, make required operations and reset \\'curr\\' to empty\\n                else if(curr.size()){\\n                    if(banned_dict[curr] == 0){\\n                        count[curr]++;\\n                        if(count[curr] > max_count){\\n                            max_count = count[curr];\\n                            max_appeared = curr;\\n                        }\\n                    }\\n                    curr = \"\";\\n                }\\n            }\\n            // if you encounter special symbol, thats again the end of word and after required operations, reset \\'curr\\'\\n            else if(curr.size()){\\n                if(banned_dict[curr] == 0){\\n                    count[curr]++;\\n                    if(count[curr] > max_count){\\n                        max_count = count[curr];\\n                        max_appeared = curr;\\n                    }\\n                }\\n                curr = \"\";\\n            }\\n        }\\n        // check if its not empty, as we might have not added the very last word we encountered\\n        if(curr.size()){\\n            if(banned_dict[curr] == 0){\\n                count[curr]++;\\n                if(count[curr] > max_count){\\n                    max_count = count[curr];\\n                    max_appeared = curr;\\n                }\\n            }\\n        }\\n        return max_appeared;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310164,
                "title": "simple-python-faster-than-98-98-and-less-than-90-27-memory",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i,\" \")\\n        x = Counter(paragraph.lower().split(\" \"))\\n        banned.append(\"\")\\n        max_val = [0,\"\"]\\n        for i in x:\\n            if i in banned :\\n                continue\\n            else:\\n                if max_val[0] < x[i]:\\n                    max_val[1] = i\\n                    max_val[0] = x[i]\\n        return max_val[1]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i,\" \")\\n        x = Counter(paragraph.lower().split(\" \"))\\n        banned.append(\"\")\\n        max_val = [0,\"\"]\\n        for i in x:\\n            if i in banned :\\n                continue\\n            else:\\n                if max_val[0] < x[i]:\\n                    max_val[1] = i\\n                    max_val[0] = x[i]\\n        return max_val[1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107521,
                "title": "my-c-solution-using-map-with-comments",
                "content": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string,int>mp;\\n        unordered_set<string> bannedset;\\n        \\n        //converting banned words to lowercase and inserting them into banned set\\n        for(string word : banned){\\n            transform(word.begin(), word.end(), word.begin(), ::tolower); \\n            bannedset.insert(word);\\n        }\\n            \\n        int start =0,end=0,n= paragraph.length();\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            start = i;\\n            end=i;\\n            //to obtain start and end of every word\\n            while(i<n&&(paragraph[i]>=\\'A\\'&&paragraph[i]<=\\'Z\\')||(paragraph[i]>=\\'a\\'&&paragraph[i]<=\\'z\\')){\\n                i++;\\n                end++;\\n            }\\n            //to skip useless characters or spaces\\n            while(i<n&&!(paragraph[i]>=\\'A\\'&&paragraph[i]<=\\'Z\\')&&!(paragraph[i]>=\\'a\\'&&paragraph[i]<=\\'z\\'))\\n                i++;\\n            \\n            //converting every word to lowercase and inserting it into map if it is not banned\\n            string temp = paragraph.substr(start,end-start);\\n             transform(temp.begin(), temp.end(), temp.begin(), ::tolower); \\n            if(bannedset.find(temp)==bannedset.end())\\n            mp[temp]++;\\n                i--;\\n        }\\n        \\n        //finding the word with maximum frequency\\n        int commonmax = 0;\\n        string commonstr=\"\";\\n        for(auto it: mp){\\n            if(it.second>commonmax){\\n                commonstr=it.first;\\n                commonmax = it.second;\\n            }\\n        }\\n                \\n        return commonstr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string,int>mp;\\n        unordered_set<string> bannedset;\\n        \\n        //converting banned words to lowercase and inserting them into banned set\\n        for(string word : banned){\\n            transform(word.begin(), word.end(), word.begin(), ::tolower); \\n            bannedset.insert(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 994700,
                "title": "python-less-than-99-memory-usage",
                "content": "\\t\\tpunctuation = \"!?\\',;.\"\\n\\n        for punc in punctuation:\\n            if punc in paragraph:\\n                paragraph = paragraph.replace(punc,\" \")\\n\\n        P = paragraph.lower().split()\\n        mc = 0\\n\\n        for words in P:\\n            if words not in banned and P.count(words) > mc:\\n                mc = P.count(words)\\n                word = words\\n        \\n        return(word)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t\\tpunctuation = \"!?\\',;.\"\\n\\n        for punc in punctuation:\\n            if punc in paragraph:\\n                paragraph = paragraph.replace(punc,\" \")\\n\\n        P = paragraph.lower().split()\\n        mc = 0\\n\\n        for words in P:\\n            if words not in banned and P.count(words) > mc:\\n                mc = P.count(words)\\n                word = words\\n        \\n        return(word)",
                "codeTag": "Unknown"
            },
            {
                "id": 874877,
                "title": "c-90-53-easy-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        string s=\"\";\\n        unordered_map<string,int>m;  //for frequency of words in paragraph\\n        unordered_set<string>ban;    //banned words in set for searching in O(logn)\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        for(int i=0;i<p.length();i++)\\n        {\\n            if(!(p[i]>=\\'A\\'&&p[i]<=\\'Z\\')&&!(p[i]>=\\'a\\'&&p[i]<=\\'z\\'))\\n            {\\n                m[s]++;\\n                s=\"\";\\n            }\\n            else\\n            {\\n                if(p[i]>=\\'A\\'&&p[i]<=\\'Z\\')\\n                    p[i]=p[i]+32;\\n                s+=p[i];\\n            }\\n        }\\n        m[s]++;\\n\\t\\t\\n        vector<pair<int,string>>v; // for sorting frequency in decsending order\\n        for(auto i=m.begin();i!=m.end();i++)\\n            v.push_back(make_pair(i->second,i->first));\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        for(auto i=v.begin();i!=v.end();i++)\\n        {\\n            if(ban.count(i->second)==0&&i->second!=\"\")\\n                return i->second;\\n        }\\n        return \"saat samundar paar me tere pichhe pichhe aa gyi \"; // control will never reach here :)\\n    }\\n\\t\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        string s=\"\";\\n        unordered_map<string,int>m;  //for frequency of words in paragraph\\n        unordered_set<string>ban;    //banned words in set for searching in O(logn)\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        for(int i=0;i<p.length();i++)\\n        {\\n            if(!(p[i]>=\\'A\\'&&p[i]<=\\'Z\\')&&!(p[i]>=\\'a\\'&&p[i]<=\\'z\\'))\\n            {\\n                m[s]++;\\n                s=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 790507,
                "title": "java-easy-solution-without-regex-95-time-and-93-storage",
                "content": "I took a set to have all the banned words and a map to keep a count of the un-banned words. I have also added \"\" as a banned word becuase there might not be any space between or extra space words. Whenever i encounter a space or other character I convert it to a string and add it into the map. \\n```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String,Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        Set<String> set = new HashSet<>();\\n        for(String word:banned){\\n            set.add(word);\\n        }\\n\\t\\t// for corner cases\\n        set.add(\"\");\\n        for(int i=0;i<paragraph.length();i++){\\n            char c = paragraph.charAt(i);\\n            if(Character.isLetter(c)){\\n                sb.append(Character.toLowerCase(c));\\n            }else{\\n                String s = sb.toString();\\n                sb.setLength(0);\\n                if(!set.contains(s))\\n                    map.put(s,map.getOrDefault(s,0)+1);\\n            }\\n        }\\n\\t\\t// if there\\'s only word word\\n       // if(sb.length()>0){\\n         //   String s = sb.toString();\\n           // if(!set.contains(s))\\n             //   map.put(s,map.getOrDefault(s,0)+1);\\n        //}\\n        \\n        //System.out.println(map);\\n\\t\\t// to return the maximum count string\\n        int max = 0;\\n        String maxi =null;\\n        for(String s : map.keySet()){\\n            if(map.get(s)>max){\\n                max = map.get(s);\\n                maxi =s;\\n            }\\n        }\\n        return maxi;\\n    }\\n```\\nThank you for reading my post, if you come across any mistakes or suggestion please do let me know I will be thankful for your help. Have a great day!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String,Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        Set<String> set = new HashSet<>();\\n        for(String word:banned){\\n            set.add(word);\\n        }\\n\\t\\t// for corner cases\\n        set.add(\"\");\\n        for(int i=0;i<paragraph.length();i++){\\n            char c = paragraph.charAt(i);\\n            if(Character.isLetter(c)){\\n                sb.append(Character.toLowerCase(c));\\n            }else{\\n                String s = sb.toString();\\n                sb.setLength(0);\\n                if(!set.contains(s))\\n                    map.put(s,map.getOrDefault(s,0)+1);\\n            }\\n        }\\n\\t\\t// if there\\'s only word word\\n       // if(sb.length()>0){\\n         //   String s = sb.toString();\\n           // if(!set.contains(s))\\n             //   map.put(s,map.getOrDefault(s,0)+1);\\n        //}\\n        \\n        //System.out.println(map);\\n\\t\\t// to return the maximum count string\\n        int max = 0;\\n        String maxi =null;\\n        for(String s : map.keySet()){\\n            if(map.get(s)>max){\\n                max = map.get(s);\\n                maxi =s;\\n            }\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 635171,
                "title": "easy-python-solution-replace-split-count-sorted-and-for-loop",
                "content": "\\n        for m in \"!?\\',;.\":\\n            paragraph = paragraph.lower().replace(m,\\' \\')\\n        s = paragraph.split()\\n        \\n        a = []\\n        for c in s:\\n            a.append([s.count(c),c])\\n            \\n        a = sorted(a,key=lambda x:x[0],reverse = True)\\n        for i in range(len(a)):\\n            if a[i][1] not in banned:\\n                break\\n        return a[i][1]",
                "solutionTags": [],
                "code": "\\n        for m in \"!?\\',;.\":\\n            paragraph = paragraph.lower().replace(m,\\' \\')\\n        s = paragraph.split()\\n        \\n        a = []\\n        for c in s:\\n            a.append([s.count(c),c])\\n            \\n        a = sorted(a,key=lambda x:x[0],reverse = True)\\n        for i in range(len(a)):\\n            if a[i][1] not in banned:\\n                break\\n        return a[i][1]",
                "codeTag": "Unknown"
            },
            {
                "id": 628920,
                "title": "javascript-simple-solution-with-regex-85-100",
                "content": "Runtime: 56 ms, faster than 85.54% of JavaScript online submissions for Most Common Word.\\nMemory Usage: 35.4 MB, less than 100.00% of JavaScript online submissions for Most Common Word.\\n```\\nfunction mostCommonWord(paragraph, banned) {\\n  let maxCount = 0;\\n  let maxWord = null;\\n  banned = new Set(banned);\\n  const map = new Map();\\n  paragraph.split(new RegExp(\"[!?\\',;. ]\", \\'g\\')).forEach(word => {\\n    if (!word) return;\\n    word = word.toLowerCase();\\n    if (!banned.has(word)) {\\n      const count = (map.get(word) || 0) + 1;\\n      map.set(word, count);\\n      if (count > maxCount) {\\n        maxCount = count;\\n        maxWord = word;\\n      }\\n    }\\n  });\\n  return maxWord;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction mostCommonWord(paragraph, banned) {\\n  let maxCount = 0;\\n  let maxWord = null;\\n  banned = new Set(banned);\\n  const map = new Map();\\n  paragraph.split(new RegExp(\"[!?\\',;. ]\", \\'g\\')).forEach(word => {\\n    if (!word) return;\\n    word = word.toLowerCase();\\n    if (!banned.has(word)) {\\n      const count = (map.get(word) || 0) + 1;\\n      map.set(word, count);\\n      if (count > maxCount) {\\n        maxCount = count;\\n        maxWord = word;\\n      }\\n    }\\n  });\\n  return maxWord;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597636,
                "title": "swift",
                "content": "```\\nfunc mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    \\n        var paragraph = paragraph.lowercased()\\n        var str = [Character]()\\n        for char in paragraph {\\n            if char >= \"a\" && char <= \"z\" {\\n                str.append(char)\\n            } else {\\n                str.append(\" \")\\n            }\\n        }\\n            \\n        var arr = String(str).split(separator: \" \")\\n        var map = [String: Int]()\\n        for word in arr {\\n            var word = word.lowercased()\\n            map[word, default: 0] += 1   \\n        }\\n        for word in banned {\\n            if map[word] != nil {\\n                map[word] = nil\\n            }\\n        }\\n     \\n        var key = Array(map.keys)\\n        key = key.sorted(by: {(a, b) in\\n             return map[a]! > map[b]!        \\n        })\\n        return key[0]\\n    }",
                "solutionTags": [],
                "code": "```\\nfunc mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    \\n        var paragraph = paragraph.lowercased()\\n        var str = [Character]()\\n        for char in paragraph {\\n            if char >= \"a\" && char <= \"z\" {\\n                str.append(char)\\n            } else {\\n                str.append(\" \")\\n            }\\n        }\\n            \\n        var arr = String(str).split(separator: \" \")\\n        var map = [String: Int]()\\n        for word in arr {\\n            var word = word.lowercased()\\n            map[word, default: 0] += 1   \\n        }\\n        for word in banned {\\n            if map[word] != nil {\\n                map[word] = nil\\n            }\\n        }\\n     \\n        var key = Array(map.keys)\\n        key = key.sorted(by: {(a, b) in\\n             return map[a]! > map[b]!        \\n        })\\n        return key[0]\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 565461,
                "title": "javascript-solution-using-hashmap",
                "content": "```\\nvar mostCommonWord = function (paragraph, banned) {\\n  let hash = {};\\n  let max = 0;\\n  let result = null;\\n\\n  let words = paragraph\\n    .toLowerCase()\\n    .split(/\\\\W+/g);\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let word = words[i];\\n    hash[word] = hash[word] || 0;\\n    hash[word] = banned.includes(word) ? hash[word] - 1 : hash[word] + 1;\\n\\n    if (hash[word] > max) {\\n      max = hash[word];\\n      result = word;\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostCommonWord = function (paragraph, banned) {\\n  let hash = {};\\n  let max = 0;\\n  let result = null;\\n\\n  let words = paragraph\\n    .toLowerCase()\\n    .split(/\\\\W+/g);\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let word = words[i];\\n    hash[word] = hash[word] || 0;\\n    hash[word] = banned.includes(word) ? hash[word] - 1 : hash[word] + 1;\\n\\n    if (hash[word] > max) {\\n      max = hash[word];\\n      result = word;\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530873,
                "title": "concise-javascript-solution-w-regexp",
                "content": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n    paragraph = paragraph.toLowerCase().match(/[a-z]+/g)\\n    let set = new Set(banned), wordMap = {}\\n    for(const word of paragraph){\\n        if(!set.has(word)){\\n            wordMap[word] ? wordMap[word]++ : wordMap[word] = 1\\n        }\\n    }\\n    let max = 0, output\\n    for(const key in wordMap){\\n        if(wordMap[key] > max){\\n            output = key\\n            max = wordMap[key]\\n        }\\n    }\\n    return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n    paragraph = paragraph.toLowerCase().match(/[a-z]+/g)\\n    let set = new Set(banned), wordMap = {}\\n    for(const word of paragraph){\\n        if(!set.has(word)){\\n            wordMap[word] ? wordMap[word]++ : wordMap[word] = 1\\n        }\\n    }\\n    let max = 0, output\\n    for(const key in wordMap){\\n        if(wordMap[key] > max){\\n            output = key\\n            max = wordMap[key]\\n        }\\n    }\\n    return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485317,
                "title": "c-beats-98-transform-replace-erase-remove-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n\\t    // Replace all punctuation with spaces.\\n        replace(paragraph.begin(), paragraph.end(), \\',\\', \\' \\');\\n\\t\\t// If there is still other punctuation, get rid of it.\\n        paragraph.erase(std::remove_if(paragraph.begin(), paragraph.end(), [](char A){return ispunct(A);}), paragraph.end());\\n\\t\\t\\n\\t\\t// Make entire string lower case.\\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n\\t\\t\\n\\t\\t// Converts string with spaces to a vector of strings without the spaces.\\n\\t\\t// Can have an arbitrary amount of spaces in between words.\\n        vector<string> ourWords = {istream_iterator<string>{istringstream() = istringstream(paragraph)},\\n                                   istream_iterator<string>{}};\\n              \\n        unordered_map<string, int> ourMap;\\n        \\n\\t\\t// Count the frequency of words.\\n        for (int i{}; i < ourWords.size(); ++i)\\n        {\\n            ourMap[ourWords[i]]++;\\n        }\\n        \\n\\t\\t// If a word is banned make its frequency 0\\n        for (int i{}; i < banned.size(); ++i)\\n        {\\n            if (ourMap.count(banned[i]))\\n            {\\n                ourMap[banned[i]] = 0;\\n            }\\n        }\\n        // Find the most frequent word.\\n        string res;\\n        int maxNum{};\\n        for (const auto& keyValue : ourMap)\\n        {\\n            if (keyValue.second > maxNum)\\n            {\\n                maxNum = keyValue.second;\\n                res = keyValue.first;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n\\t    // Replace all punctuation with spaces.\\n        replace(paragraph.begin(), paragraph.end(), \\',\\', \\' \\');\\n\\t\\t// If there is still other punctuation, get rid of it.\\n        paragraph.erase(std::remove_if(paragraph.begin(), paragraph.end(), [](char A){return ispunct(A);}",
                "codeTag": "Java"
            },
            {
                "id": 476194,
                "title": "easy-solution-tolower-ispunc-unordered-set-map-stringstream-c-beats-96-85",
                "content": "```\\n string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map <string,int> freq;\\n        unordered_set <string> fru ={banned.begin(),banned.end()};\\n        string tmp;\\n        paragraph = buildnew(paragraph);\\n        stringstream x(paragraph);\\n        string ans = \"\";\\n        int max = 0;\\n        while(x>>tmp){\\n            if(fru.find(tmp) != fru.end()) continue;\\n            if(freq.find(tmp) == freq.end())\\n                freq.insert({tmp,1});\\n            else\\n                freq[tmp]++;\\n            if(freq[tmp] > max){\\n                max = freq[tmp];\\n                ans = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string buildnew(string & x){\\n        string tmp = \"\";\\n        for(auto & i : x){\\n        if(ispunct(i)) tmp += \\' \\';\\n            else\\n          tmp += tolower(i);\\n        }\\n        return tmp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map <string,int> freq;\\n        unordered_set <string> fru ={banned.begin(),banned.end()};\\n        string tmp;\\n        paragraph = buildnew(paragraph);\\n        stringstream x(paragraph);\\n        string ans = \"\";\\n        int max = 0;\\n        while(x>>tmp){\\n            if(fru.find(tmp) != fru.end()) continue;\\n            if(freq.find(tmp) == freq.end())\\n                freq.insert({tmp,1});\\n            else\\n                freq[tmp]++;\\n            if(freq[tmp] > max){\\n                max = freq[tmp];\\n                ans = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string buildnew(string & x){\\n        string tmp = \"\";\\n        for(auto & i : x){\\n        if(ispunct(i)) tmp += \\' \\';\\n            else\\n          tmp += tolower(i);\\n        }\\n        return tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456818,
                "title": "python-simple-solution",
                "content": "\\tdef mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        word_temp = \"\"\\n        words = []\\n        for i, ch in enumerate(paragraph):\\n            if (ch.isdigit() or ch.isalpha()):\\n                word_temp += ch\\n            elif word_temp:\\n                words.append(word_temp.lower())\\n                word_temp = \"\"\\n        if word_temp: # the last word or paragraph a word\\n            words.append(word_temp.lower())\\n\\n        d = collections.defaultdict(int)\\n        res = \"\"\\n        cnt = 0\\n        for word in words:\\n            if word in banned:\\n                continue            \\n            d[word] += 1            \\n            if d[word] >= cnt:\\n                cnt = d[word]\\n                res = word           \\n    \\n        return res",
                "solutionTags": [],
                "code": "\\tdef mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        word_temp = \"\"\\n        words = []\\n        for i, ch in enumerate(paragraph):\\n            if (ch.isdigit() or ch.isalpha()):\\n                word_temp += ch\\n            elif word_temp:\\n                words.append(word_temp.lower())\\n                word_temp = \"\"\\n        if word_temp: # the last word or paragraph a word\\n            words.append(word_temp.lower())\\n\\n        d = collections.defaultdict(int)\\n        res = \"\"\\n        cnt = 0\\n        for word in words:\\n            if word in banned:\\n                continue            \\n            d[word] += 1            \\n            if d[word] >= cnt:\\n                cnt = d[word]\\n                res = word           \\n    \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 454520,
                "title": "easy-to-understand-java-solution-16-ms",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n    \\n    // Replace all special Characters by space and splitting it\\n    String[] trimmedWords = paragraph.toLowerCase().replaceAll(\"[!,:;?.\\\\\\' \\']\", \" \").split(\" \");\\n        \\n    // HashMap to maintain count\\n    Map<String, Integer> wordsCount = new HashMap<String, Integer>();\\n        \\n    for(String s: trimmedWords){\\n        wordsCount.put(s, wordsCount.getOrDefault(s, 0) + 1);\\n    }\\n        \\n    \\n    // Remove the banned words from HashMap\\n    for(String s: banned){   \\n    if(wordsCount.containsKey(s)){\\n        wordsCount.remove(s);\\n    }  \\n    }\\n    \\n        \\n    int frequency = Integer.MIN_VALUE;    \\n    String result = null;\\n    \\n    for(Map.Entry<String, Integer> word: wordsCount.entrySet()){\\n        \\n    if(word.getValue() > frequency && word.getKey().length() > 0){\\n        frequency = word.getValue();\\n        result = word.getKey();\\n    }\\n        \\n    }\\n    \\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n    \\n    // Replace all special Characters by space and splitting it\\n    String[] trimmedWords = paragraph.toLowerCase().replaceAll(\"[!,:;?.\\\\\\' \\']\", \" \").split(\" \");\\n        \\n    // HashMap to maintain count\\n    Map<String, Integer> wordsCount = new HashMap<String, Integer>();\\n        \\n    for(String s: trimmedWords){\\n        wordsCount.put(s, wordsCount.getOrDefault(s, 0) + 1);\\n    }\\n        \\n    \\n    // Remove the banned words from HashMap\\n    for(String s: banned){   \\n    if(wordsCount.containsKey(s)){\\n        wordsCount.remove(s);\\n    }  \\n    }\\n    \\n        \\n    int frequency = Integer.MIN_VALUE;    \\n    String result = null;\\n    \\n    for(Map.Entry<String, Integer> word: wordsCount.entrySet()){\\n        \\n    if(word.getValue() > frequency && word.getKey().length() > 0){\\n        frequency = word.getValue();\\n        result = word.getKey();\\n    }\\n        \\n    }\\n    \\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440622,
                "title": "solution-using-hash-map",
                "content": "\\'\\'\\'\\n\\n\\n    class Solution:\\n        def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\tfrom collections import Counter\\n            p = paragraph.lower()\\n\\t\\t\\t\\n            for c in \"!?.;\\',\":\\n               p = p.replace(c, \\' \\') \\n\\t\\t\\t   \\n            d = Counter(p.split())\\n            for word in banned:\\n                if word.lower() in d:\\n                    del d[word]\\n            v,k = max((v,k) for k,v in d.items())\\n            return k",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\n    class Solution:\\n        def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\tfrom collections import Counter\\n            p = paragraph.lower()\\n\\t\\t\\t\\n            for c in \"!?.;\\',\":\\n               p = p.replace(c, \\' \\') \\n\\t\\t\\t   \\n            d = Counter(p.split())\\n            for word in banned:\\n                if word.lower() in d:\\n                    del d[word]\\n            v,k = max((v,k) for k,v in d.items())\\n            return k",
                "codeTag": "Java"
            },
            {
                "id": 389675,
                "title": "c-solution-linear-complexity-only-stl-methods",
                "content": "Algorithm is really straightforward:\\n1) Preprocess paragraph: transform all letters to lowercase, other symbols to spaces (hello, bloody 47-th test case) -- O(P), where P is paragraph size;\\n2) Compute paragraph words frequencies and store them in hash map -- O(P)\\n3) Delete banned words from hash map -- O(B)\\n4) Find element with maximal freq\\n\\n```\\nclass Solution {\\npublic:\\n    // W = length of max word in paragraph or banned,        \\n    // P = number of words in paragraph\\n    // B = number of words in banned\\n    // Total complexity: O((P+B)W)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n                \\n        // O(WP) -- preprocess paragraph: reduce punctuation\\n        transform(\\n            paragraph.begin(), paragraph.end(), paragraph.begin(),\\n            [](char c) -> char {\\n                return isalpha(c) ? tolower(c) : \\' \\';\\n            }\\n        );                    \\n        \\n        // O(WP) -- construct freqs\\n        unordered_map<string, int> mp;\\n        stringstream ss(paragraph);\\n        for (string word; ss >> word; )\\n            mp[move(word)]++;\\n        \\n        // O(WB) -- delete banned\\n        for (const auto& s : banned) {\\n            auto it = mp.find(s);\\n            if (it != end(mp)) {\\n                mp.erase(it);\\n            }\\n        }\\n        \\n        // O(P) -- find max\\n        auto most_freq_it \\n            = max_element(\\n                begin(mp), end(mp),\\n                [](auto& l, auto& r) {\\n                    return l.second < r.second;\\n                }\\n            );\\n        \\n        return (most_freq_it != end(mp) ? most_freq_it->first : string());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // W = length of max word in paragraph or banned,        \\n    // P = number of words in paragraph\\n    // B = number of words in banned\\n    // Total complexity: O((P+B)W)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n                \\n        // O(WP) -- preprocess paragraph: reduce punctuation\\n        transform(\\n            paragraph.begin(), paragraph.end(), paragraph.begin(),\\n            [](char c) -> char {\\n                return isalpha(c) ? tolower(c) : \\' \\';\\n            }\\n        );                    \\n        \\n        // O(WP) -- construct freqs\\n        unordered_map<string, int> mp;\\n        stringstream ss(paragraph);\\n        for (string word; ss >> word; )\\n            mp[move(word)]++;\\n        \\n        // O(WB) -- delete banned\\n        for (const auto& s : banned) {\\n            auto it = mp.find(s);\\n            if (it != end(mp)) {\\n                mp.erase(it);\\n            }\\n        }\\n        \\n        // O(P) -- find max\\n        auto most_freq_it \\n            = max_element(\\n                begin(mp), end(mp),\\n                [](auto& l, auto& r) {\\n                    return l.second < r.second;\\n                }\\n            );\\n        \\n        return (most_freq_it != end(mp) ? most_freq_it->first : string());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353016,
                "title": "simple-java-solution-using-map",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n        String[] paraWords = paragraph.split(\"[ .,;!?\\']+\");\\n        \\n        //add paragraph words in map\\n        Map<String, Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<paraWords.length;i++){\\n            String s = paraWords[i];\\n            map.put(s, map.getOrDefault(s,0)+1);\\n        }\\n        if(map.size() < banned.length)\\n            return \"\";\\n        \\n        //remove banned words from map\\n        for(int i=0; i<banned.length;i++)\\n            if(map.containsKey(banned[i]))\\n                map.remove(banned[i]);\\n        \\n        //return string with maximum count\\n        String maxStr=null;\\n        for(String word : map.keySet())\\n            if(maxStr == null || map.get(word) > map.get(maxStr))\\n                maxStr = word;\\n        \\n        return maxStr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n        String[] paraWords = paragraph.split(\"[ .,;!?\\']+\");\\n        \\n        //add paragraph words in map\\n        Map<String, Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<paraWords.length;i++){\\n            String s = paraWords[i];\\n            map.put(s, map.getOrDefault(s,0)+1);\\n        }\\n        if(map.size() < banned.length)\\n            return \"\";\\n        \\n        //remove banned words from map\\n        for(int i=0; i<banned.length;i++)\\n            if(map.containsKey(banned[i]))\\n                map.remove(banned[i]);\\n        \\n        //return string with maximum count\\n        String maxStr=null;\\n        for(String word : map.keySet())\\n            if(maxStr == null || map.get(word) > map.get(maxStr))\\n                maxStr = word;\\n        \\n        return maxStr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352230,
                "title": "swift-solution-clean-code-beats-99",
                "content": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        guard paragraph.count != 0 else { return \"\" }\\n        \\n        var arr = paragraph.split{ !$0.isLetter }.map{ $0.lowercased() }\\n        let banned = Set(banned)       \\n        \\n        var dict = [String:Int]()\\n        var commonWord = String()\\n        \\n        for word in arr where !banned.contains(word) {\\n            dict[word] = (dict[word] ?? 0) + 1\\n            if dict[commonWord] ?? 0 < dict[word]! {\\n                commonWord = word\\n            }\\n        }\\n        return commonWord                                 \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        guard paragraph.count != 0 else { return \"\" }\\n        \\n        var arr = paragraph.split{ !$0.isLetter }.map{ $0.lowercased() }\\n        let banned = Set(banned)       \\n        \\n        var dict = [String:Int]()\\n        var commonWord = String()\\n        \\n        for word in arr where !banned.contains(word) {\\n            dict[word] = (dict[word] ?? 0) + 1\\n            if dict[commonWord] ?? 0 < dict[word]! {\\n                commonWord = word\\n            }\\n        }\\n        return commonWord                                 \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346981,
                "title": "swift-32ms-4-lines-of-code",
                "content": "```\\n  func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    let words = paragraph.split{ !$0.isLetter }.map { String($0).lowercased() }\\n    var hashmap: [String: Int] = [:]\\n    \\n    for word in words where !banned.contains(word) {\\n      hashmap[word, default: 0] += 1\\n    }\\n    \\n    return hashmap.max { $0.value < $1.value }!.key\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n  func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    let words = paragraph.split{ !$0.isLetter }.map { String($0).lowercased() }\\n    var hashmap: [String: Int] = [:]\\n    \\n    for word in words where !banned.contains(word) {\\n      hashmap[word, default: 0] += 1\\n    }\\n    \\n    return hashmap.max { $0.value < $1.value }!.key\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 329448,
                "title": "python-using-counter-translate-table",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #Use a translate table to map each of the punctuation symbols to a space.\\n\\t\\tremovePunctuationTable = str.maketrans(\"!?\\',;.\", \"      \")\\n        paragraph = paragraph.translate(removePunctuationTable)\\n        \\n        banned = set(banned)\\n        wordCount = Counter()\\n        for word in paragraph.split():\\n            word = word.lower()\\n            if word not in banned:\\n                wordCount[word] += 1\\n            \\n        return wordCount.most_common(1)[0][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #Use a translate table to map each of the punctuation symbols to a space.\\n\\t\\tremovePunctuationTable = str.maketrans(\"!?\\',;.\", \"      \")\\n        paragraph = paragraph.translate(removePunctuationTable)\\n        \\n        banned = set(banned)\\n        wordCount = Counter()\\n        for word in paragraph.split():\\n            word = word.lower()\\n            if word not in banned:\\n                wordCount[word] += 1\\n            \\n        return wordCount.most_common(1)[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316277,
                "title": "python-solution-fix",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for c in \"!?\\',;.\": \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        cpara = collections.Counter(paragraph.lower().split())\\n        banned = set(banned)\\n        \\n        for word,_ in cpara.most_common():\\n            if word not in banned:\\n                return word\\n        return \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for c in \"!?\\',;.\": \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        cpara = collections.Counter(paragraph.lower().split())\\n        banned = set(banned)\\n        \\n        for word,_ in cpara.most_common():\\n            if word not in banned:\\n                return word\\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309775,
                "title": "rust-because-why-not-0ms-100",
                "content": "```rust\\nuse std::collections::{HashSet, HashMap};\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn most_common_word(paragraph: String, banned: Vec<String>) -> String {\\n        let mut banset: HashSet<String> = HashSet::from_iter(banned);\\n        let mut freq = HashMap::new();\\n        let words = paragraph.split(|c: char| c.is_ascii_punctuation() || c.is_ascii_whitespace());\\n        for word in words {\\n            let word = word.to_ascii_lowercase();\\n            if word == \"\" || banset.contains(&word) {\\n                continue;\\n            }\\n            *freq.entry(word).or_insert(0) += 1;\\n        }\\n        let mut most = \"\";\\n        let mut most_count = 0;\\n        for (k, v) in freq.iter() {\\n            if v > &most_count {\\n                most_count = *v;\\n                most = k\\n            }\\n        }\\n        most.to_string()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::{HashSet, HashMap};\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn most_common_word(paragraph: String, banned: Vec<String>) -> String {\\n        let mut banset: HashSet<String> = HashSet::from_iter(banned);\\n        let mut freq = HashMap::new();\\n        let words = paragraph.split(|c: char| c.is_ascii_punctuation() || c.is_ascii_whitespace());\\n        for word in words {\\n            let word = word.to_ascii_lowercase();\\n            if word == \"\" || banset.contains(&word) {\\n                continue;\\n            }\\n            *freq.entry(word).or_insert(0) += 1;\\n        }\\n        let mut most = \"\";\\n        let mut most_count = 0;\\n        for (k, v) in freq.iter() {\\n            if v > &most_count {\\n                most_count = *v;\\n                most = k\\n            }\\n        }\\n        most.to_string()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294238,
                "title": "accepted-c-simple-solution-using-uordered-map",
                "content": "```\\nclass Solution {\\n    \\n    bool isAlpha ( char c )\\n    {\\n        c = tolower( c );\\n        \\n        if ( c >= \\'a\\' && c <= \\'z\\' )\\n            return true;\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n     \\n        unordered_map < string, int > frequency;\\n        string temp;\\n        for ( int i = 0; i < paragraph.length(); i++ )\\n        {\\n            char currentChar = paragraph[i];\\n            if ( isAlpha (  currentChar ) )  //if char is valid alphabet between a - z (lowercase)\\n            {\\n                temp.push_back ( tolower(currentChar) );\\n            }else  //if char is any punctuation\\n            {\\n                if ( temp.size() ) //we could have only \",\" \\n                {\\n                    frequency[temp]++;\\n                }\\n                temp = \"\"; //reset temp\\n            }\\n        }\\n        \\n        if ( temp != \"\" ) frequency[temp]++; //if temp is not empty;\\n        /*\\n            \\n        for ( auto it: frequency )\\n        {\\n            cout << it.first << endl;\\n        }*/\\n        \\n        int maxFrequency = INT_MIN;\\n        string result = \"\";\\n        for ( auto it: frequency )\\n        {\\n            //if frequence is greater and word is not in banned list;\\n            if ( it.second > maxFrequency && ( find( banned.begin(), banned.end(), it.first) == banned.end() )  ) \\n            {\\n                maxFrequency = it.second;\\n                result = it.first;\\n            }\\n            \\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool isAlpha ( char c )\\n    {\\n        c = tolower( c );\\n        \\n        if ( c >= \\'a\\' && c <= \\'z\\' )\\n            return true;\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n     \\n        unordered_map < string, int > frequency;\\n        string temp;\\n        for ( int i = 0; i < paragraph.length(); i++ )\\n        {\\n            char currentChar = paragraph[i];\\n            if ( isAlpha (  currentChar ) )  //if char is valid alphabet between a - z (lowercase)\\n            {\\n                temp.push_back ( tolower(currentChar) );\\n            }else  //if char is any punctuation\\n            {\\n                if ( temp.size() ) //we could have only \",\" \\n                {\\n                    frequency[temp]++;\\n                }\\n                temp = \"\"; //reset temp\\n            }\\n        }\\n        \\n        if ( temp != \"\" ) frequency[temp]++; //if temp is not empty;\\n        /*\\n            \\n        for ( auto it: frequency )\\n        {\\n            cout << it.first << endl;\\n        }*/\\n        \\n        int maxFrequency = INT_MIN;\\n        string result = \"\";\\n        for ( auto it: frequency )\\n        {\\n            //if frequence is greater and word is not in banned list;\\n            if ( it.second > maxFrequency && ( find( banned.begin(), banned.end(), it.first) == banned.end() )  ) \\n            {\\n                maxFrequency = it.second;\\n                result = it.first;\\n            }\\n            \\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 217718,
                "title": "python-1-liner-beats-91",
                "content": "Convert paragraph to lower-case. Find all word in paragraph (split it into words) omitting the punctuation marks by using ```\\\\w+``` regular expression. Count the occurences of word that are not banned and return the word with the highest count.\\n\\n```\\ndef mostCommonWord(self, paragraph, banned):\\n\\t\"\"\"\\n\\t:type paragraph: str\\n\\t:type banned: List[str]\\n\\t:rtype: str\\n\\t\"\"\"\\n\\treturn collections.Counter(W for W in re.findall(r\\'\\\\w+\\', paragraph.lower()) if W not in set(banned)).most_common(1)[0][0]\\n```\\nTime: O(n + m) where n is the length of paragraph and m the length of banned\\nSpace: O(n + m)",
                "solutionTags": [],
                "code": "```\\\\w+```\n```\\ndef mostCommonWord(self, paragraph, banned):\\n\\t\"\"\"\\n\\t:type paragraph: str\\n\\t:type banned: List[str]\\n\\t:rtype: str\\n\\t\"\"\"\\n\\treturn collections.Counter(W for W in re.findall(r\\'\\\\w+\\', paragraph.lower()) if W not in set(banned)).most_common(1)[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 207544,
                "title": "java-no-regex-simple-solution",
                "content": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        int max = -1;\\n        String ans = \"\";\\n        paragraph += \".\";\\n        \\n        for(String str : banned) {\\n            set.add(str);\\n        }\\n        \\n        for(int i = 0; i < paragraph.length(); i++) {\\n            char cur = paragraph.charAt(i);\\n            \\n            if((cur >= \\'a\\' && cur <= \\'z\\') || (cur >= \\'A\\' && cur <= \\'Z\\')) {\\n                sb.append(cur);\\n            }\\n            else if(sb.length() > 0) {\\n                String s = sb.toString().toLowerCase();\\n                if(!set.contains(s)) {\\n                   map.put(s, map.getOrDefault(s, 0) + 1);\\n                    if(map.get(s) > max) {\\n                        max = map.get(s);\\n                        ans = s;\\n                    }\\n                }\\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        int max = -1;\\n        String ans = \"\";\\n        paragraph += \".\";\\n        \\n        for(String str : banned) {\\n            set.add(str);\\n        }\\n        \\n        for(int i = 0; i < paragraph.length(); i++) {\\n            char cur = paragraph.charAt(i);\\n            \\n            if((cur >= \\'a\\' && cur <= \\'z\\') || (cur >= \\'A\\' && cur <= \\'Z\\')) {\\n                sb.append(cur);\\n            }\\n            else if(sb.length() > 0) {\\n                String s = sb.toString().toLowerCase();\\n                if(!set.contains(s)) {\\n                   map.put(s, map.getOrDefault(s, 0) + 1);\\n                    if(map.get(s) > max) {\\n                        max = map.get(s);\\n                        ans = s;\\n                    }\\n                }\\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124254,
                "title": "a-simple-java-solution",
                "content": "The core idea is how to use RE.\\n\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String, Integer> wordAndCount = new HashMap<String, Integer>();\\n        Set<String> bansSet = new HashSet<>(Arrays.asList(banned));\\n        //[!?,\\';] is the possible punctuations for this input, can also use \\'\\\\\\\\pP\\' instead for all of the punctuations.\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        int max = 0;\\n        String res = \"\";\\n        for(String word:words){\\n            if(bansSet.contains(word)) continue;\\n\\t    // use getOrDefault - Java8 new default function from Map interface\\n            wordAndCount.put(word, wordAndCount.getOrDefault(word, 0) + 1);\\n            int count = wordAndCount.get(word);\\n            if( count > max) {\\n                max = count;\\n                res = word;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String, Integer> wordAndCount = new HashMap<String, Integer>();\\n        Set<String> bansSet = new HashSet<>(Arrays.asList(banned));\\n        //[!?,\\';] is the possible punctuations for this input, can also use \\'\\\\\\\\pP\\' instead for all of the punctuations.\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        int max = 0;\\n        String res = \"\";\\n        for(String word:words){\\n            if(bansSet.contains(word)) continue;\\n\\t    // use getOrDefault - Java8 new default function from Map interface\\n            wordAndCount.put(word, wordAndCount.getOrDefault(word, 0) + 1);\\n            int count = wordAndCount.get(word);\\n            if( count > max) {\\n                max = count;\\n                res = word;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3518175,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words=paragraph.toLowerCase().replaceAll(\"\\\\\\\\W+\" , \" \").split(\"\\\\\\\\s+\");\\n        HashMap<String,Integer>h=new HashMap<>();\\n        for(String word:words){\\n           \\n            int count=h.getOrDefault(word,0);\\n            h.put(word,count+1);\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            h.remove(banned[i]);\\n        }\\n        int mx=Integer.MIN_VALUE;\\n        String ans=\"\";\\n        for(String m : h.keySet()){\\n            int p=h.get(m);\\n            if(p>mx){\\n                  ans=m;\\n                  mx=p;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words=paragraph.toLowerCase().replaceAll(\"\\\\\\\\W+\" , \" \").split(\"\\\\\\\\s+\");\\n        HashMap<String,Integer>h=new HashMap<>();\\n        for(String word:words){\\n           \\n            int count=h.getOrDefault(word,0);\\n            h.put(word,count+1);\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            h.remove(banned[i]);\\n        }\\n        int mx=Integer.MIN_VALUE;\\n        String ans=\"\";\\n        for(String m : h.keySet()){\\n            int p=h.get(m);\\n            if(p>mx){\\n                  ans=m;\\n                  mx=p;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481554,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string mostCommonWord(string str, vector<string>& banned) {\\n        unordered_map<string, int> hash;\\n        for(auto& it : str)\\n\\t\\t    it = ispunct(it) ? \\' \\' : tolower(it);\\n\\n        unordered_set<string> st(banned.begin(), banned.end());  \\n        string res, temp;      \\n        int maxi =0;\\n        stringstream ss(str);\\n        while(ss >> temp) hash[temp]++;\\n        \\n        for(auto& it:hash){\\n            if(it.second > maxi && !st.count(it.first)){\\n                maxi = it.second;\\n                res = it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        symbol = \"!?\\',;.\"\\n        for s in symbol:\\n            paragraph = paragraph.replace(s, \" \")\\n        paragraph = paragraph.split()\\n\\n        from collections import Counter\\n        lst = sorted(Counter(paragraph).items(), key=lambda e: -e[1])\\n        for e, _ in lst:\\n            if e not in banned:\\n                return e\\n                break\\n```\\n\\n```Java []\\nclass Solution {\\n    public String mostCommonWord(String p, String[] ban) {\\n        var e = p.toLowerCase().toCharArray();\\n        var t = new Trie();\\n        var res = new char[0];\\n        int max = 0;\\n        int l = e.length;\\n\\n        for (String w : ban) t.addW(w.toCharArray(), 0, true);\\n\\n        for (int i = 0, j = 0; i < l; j = i) {\\n            while (i < l && e[i] > 64) i++;\\n            if (i > j) {\\n                var w = Arrays.copyOfRange(e, j, i);\\n                int x = t.addW(w, 0, false);\\n                if (x > max) {\\n                    max = x;\\n                    res = w;\\n                }\\n                j = i + 1;\\n            }\\n            while (i < l && e[i] < 64) i++;\\n        }\\n        return new String(res);\\n    }\\n    private static class Trie {\\n        private int c;\\n        private final Trie[] t = new Trie[26];\\n\\n        public int addW(char[] w, int i, boolean ban) {\\n            if (i == w.length) {\\n                if (this.c == -1) return -1;\\n                return ban ? (this.c = -1) : ++this.c;\\n            }\\n            int idx = w[i] - \\'a\\';\\n            if (t[idx] == null) t[idx] = new Trie();\\n            return t[idx].addW(w, ++i, ban);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string mostCommonWord(string str, vector<string>& banned) {\\n        unordered_map<string, int> hash;\\n        for(auto& it : str)\\n\\t\\t    it = ispunct(it) ? \\' \\' : tolower(it);\\n\\n        unordered_set<string> st(banned.begin(), banned.end());  \\n        string res, temp;      \\n        int maxi =0;\\n        stringstream ss(str);\\n        while(ss >> temp) hash[temp]++;\\n        \\n        for(auto& it:hash){\\n            if(it.second > maxi && !st.count(it.first)){\\n                maxi = it.second;\\n                res = it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        symbol = \"!?\\',;.\"\\n        for s in symbol:\\n            paragraph = paragraph.replace(s, \" \")\\n        paragraph = paragraph.split()\\n\\n        from collections import Counter\\n        lst = sorted(Counter(paragraph).items(), key=lambda e: -e[1])\\n        for e, _ in lst:\\n            if e not in banned:\\n                return e\\n                break\\n```\n```Java []\\nclass Solution {\\n    public String mostCommonWord(String p, String[] ban) {\\n        var e = p.toLowerCase().toCharArray();\\n        var t = new Trie();\\n        var res = new char[0];\\n        int max = 0;\\n        int l = e.length;\\n\\n        for (String w : ban) t.addW(w.toCharArray(), 0, true);\\n\\n        for (int i = 0, j = 0; i < l; j = i) {\\n            while (i < l && e[i] > 64) i++;\\n            if (i > j) {\\n                var w = Arrays.copyOfRange(e, j, i);\\n                int x = t.addW(w, 0, false);\\n                if (x > max) {\\n                    max = x;\\n                    res = w;\\n                }\\n                j = i + 1;\\n            }\\n            while (i < l && e[i] < 64) i++;\\n        }\\n        return new String(res);\\n    }\\n    private static class Trie {\\n        private int c;\\n        private final Trie[] t = new Trie[26];\\n\\n        public int addW(char[] w, int i, boolean ban) {\\n            if (i == w.length) {\\n                if (this.c == -1) return -1;\\n                return ban ? (this.c = -1) : ++this.c;\\n            }\\n            int idx = w[i] - \\'a\\';\\n            if (t[idx] == null) t[idx] = new Trie();\\n            return t[idx].addW(w, ++i, ban);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139931,
                "title": "0-ms-100-faster-easy-you-understand",
                "content": "# Code\\n```\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    s := strings.ToLower(paragraph) + \" \"\\n\\n    str := make(map[string]int)\\n    s1 := \"\"\\n    for  _, v := range s {\\n        if v == \\' \\' || strings.Contains(\"!?\\',;.\", string(v)) {\\n            if len(s1) != 0 {\\n                str[s1]++\\n                s1 = \"\"\\n            }\\n        }else {\\n            s1 += string(v)\\n        }\\n    }\\n\\n    for _, v := range banned {\\n        delete(str, v)\\n    }\\n\\n\\n    res := \"\"\\n    max := 0\\n    for k, v := range str {\\n        if v > max {\\n            max = v\\n            res = k\\n        }\\n    }\\n\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    s := strings.ToLower(paragraph) + \" \"\\n\\n    str := make(map[string]int)\\n    s1 := \"\"\\n    for  _, v := range s {\\n        if v == \\' \\' || strings.Contains(\"!?\\',;.\", string(v)) {\\n            if len(s1) != 0 {\\n                str[s1]++\\n                s1 = \"\"\\n            }\\n        }else {\\n            s1 += string(v)\\n        }\\n    }\\n\\n    for _, v := range banned {\\n        delete(str, v)\\n    }\\n\\n\\n    res := \"\"\\n    max := 0\\n    for k, v := range str {\\n        if v > max {\\n            max = v\\n            res = k\\n        }\\n    }\\n\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2873929,
                "title": "most-common-word-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        int i=0,n=paragraph.size();\\n        while(i<n){\\n            string s = \"\";\\n            while(i<n && isalpha(paragraph[i])) { // if word is an alphabet \\n                s.push_back(tolower(paragraph[i++]));//convert tolower case & push into string\\n            }\\n            while(i<n && !isalpha(paragraph[i])){ // if word not an alphabet then skip  \\n                i++;\\n            }\\n            m[s]++; // insert string in map \\n        }\\n        \\n        for(auto it: banned){\\n            m[it]=0;   // mark frequency of banned words as 0   \\n        }\\n        string ans = \"\";\\n        int maxfreq = 0;\\n        for(auto it: m){ // check for word with max frequency\\n            if(it.second>maxfreq){\\n                ans=it.first;\\n                maxfreq=it.second; \\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        int i=0,n=paragraph.size();\\n        while(i<n){\\n            string s = \"\";\\n            while(i<n && isalpha(paragraph[i])) { // if word is an alphabet \\n                s.push_back(tolower(paragraph[i++]));//convert tolower case & push into string\\n            }\\n            while(i<n && !isalpha(paragraph[i])){ // if word not an alphabet then skip  \\n                i++;\\n            }\\n            m[s]++; // insert string in map \\n        }\\n        \\n        for(auto it: banned){\\n            m[it]=0;   // mark frequency of banned words as 0   \\n        }\\n        string ans = \"\";\\n        int maxfreq = 0;\\n        for(auto it: m){ // check for word with max frequency\\n            if(it.second>maxfreq){\\n                ans=it.first;\\n                maxfreq=it.second; \\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732090,
                "title": "java-solution-clean",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : banned) set.add(s);\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] para = paragraph.replaceAll(\"[^a-zA-Z]\", \" \").toLowerCase().split(\" \");\\n\\n        for (String w : para) {\\n            if (!set.contains(w)) {\\n                map.put(w, map.getOrDefault(w, 0) + 1);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for (String key : map.keySet()) {\\n            if (ans.toString().equals(\"\") || map.get(key) > map.get(ans.toString())) {\\n                ans.setLength(0);\\n                ans.append(key);\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn) - set.contains() costs O(logn)\\n// SC: O(n) + O(m)\\n\\n// n is the length of banned array\\n// m is the size of paragraph string array\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : banned) set.add(s);\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] para = paragraph.replaceAll(\"[^a-zA-Z]\", \" \").toLowerCase().split(\" \");\\n\\n        for (String w : para) {\\n            if (!set.contains(w)) {\\n                map.put(w, map.getOrDefault(w, 0) + 1);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for (String key : map.keySet()) {\\n            if (ans.toString().equals(\"\") || map.get(key) > map.get(ans.toString())) {\\n                ans.setLength(0);\\n                ans.append(key);\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn) - set.contains() costs O(logn)\\n// SC: O(n) + O(m)\\n\\n// n is the length of banned array\\n// m is the size of paragraph string array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637819,
                "title": "easy-c-solution-using-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n      \\n        transform(para.begin(), para.end(), para.begin(), ::toupper);\\n        for(int i=0;i<ban.size();i++)\\n        {\\n             transform(ban[i].begin(), ban[i].end(), ban[i].begin(), ::toupper);\\n            \\n        }\\n       \\n        string x=\"\",ress;\\n        if(ban.size()!=0)\\n        {\\n            unordered_set<string>s(ban.begin(),ban.end());\\n        unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        }\\n         ress=ans;\\n        }\\n        else\\n        {\\n           unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0)\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 )\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        } \\n            ress=ans;\\n        }\\n        transform(ress.begin(), ress.end(), ress.begin(), ::tolower);\\n        return ress;\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n      \\n        transform(para.begin(), para.end(), para.begin(), ::toupper);\\n        for(int i=0;i<ban.size();i++)\\n        {\\n             transform(ban[i].begin(), ban[i].end(), ban[i].begin(), ::toupper);\\n            \\n        }\\n       \\n        string x=\"\",ress;\\n        if(ban.size()!=0)\\n        {\\n            unordered_set<string>s(ban.begin(),ban.end());\\n        unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        }\\n         ress=ans;\\n        }\\n        else\\n        {\\n           unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0)\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 )\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        } \\n            ress=ans;\\n        }\\n        transform(ress.begin(), ress.end(), ress.begin(), ::tolower);\\n        return ress;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613917,
                "title": "simple-python-solution-counter",
                "content": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
                "codeTag": "Java"
            },
            {
                "id": 2549421,
                "title": "js-simple-solution-with-hashmap-and-regex",
                "content": "```\\nconst REGEX = /[^a-zA-Z ]/g;\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.replace(REGEX, \\' \\');\\n    const hashmapBanned = {};\\n    const hashmapParagraph = {};\\n    const arrayParagraph = paragraph.split(\\' \\');\\n    let output;\\n    let count = 0;\\n    \\n    for (let i = 0; i < banned.length; i++) {\\n        hashmapBanned[banned[i]] = 1;\\n    }\\n    \\n    for (let i = 0; i < arrayParagraph.length; i++) {\\n        const word = arrayParagraph[i].toLowerCase();\\n        if (!hashmapBanned[word] && word) {\\n            if (hashmapParagraph[word]) {\\n                hashmapParagraph[word]++;\\n                if (hashmapParagraph[word] > count) {\\n                    output = word;\\n                    count = hashmapParagraph[word];\\n                }\\n            } else {\\n                hashmapParagraph[word] = 1;\\n                if (!count) {\\n                    output = word;\\n                    count = 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst REGEX = /[^a-zA-Z ]/g;\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.replace(REGEX, \\' \\');\\n    const hashmapBanned = {};\\n    const hashmapParagraph = {};\\n    const arrayParagraph = paragraph.split(\\' \\');\\n    let output;\\n    let count = 0;\\n    \\n    for (let i = 0; i < banned.length; i++) {\\n        hashmapBanned[banned[i]] = 1;\\n    }\\n    \\n    for (let i = 0; i < arrayParagraph.length; i++) {\\n        const word = arrayParagraph[i].toLowerCase();\\n        if (!hashmapBanned[word] && word) {\\n            if (hashmapParagraph[word]) {\\n                hashmapParagraph[word]++;\\n                if (hashmapParagraph[word] > count) {\\n                    output = word;\\n                    count = hashmapParagraph[word];\\n                }\\n            } else {\\n                hashmapParagraph[word] = 1;\\n                if (!count) {\\n                    output = word;\\n                    count = 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505584,
                "title": "python-c-java-easy-solution-using-hash-map-o-n",
                "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity :O(n)**\\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph=paragraph.lower()\\n        a=\"!?\\',;.\"\\n        for i in a:\\n            print(i)\\n            if i in paragraph:\\n                print(\\'--\\')\\n                paragraph=paragraph.replace(i,\\' \\')\\n        paragraph=paragraph.split()\\n        d={}\\n        ans=0\\n        c=\\'\\'\\n        for i in paragraph:\\n            if not i in banned:\\n                d[i]=1+d.get(i,0)\\n                ans=max(ans,d[i])\\n                if ans==d[i]:\\n                    c=i\\n        print(d)\\n        return c\\n```\\n\\n\\n\\n\\n**Runtime: 74 ms, faster than 56.51% of Python3 online submissions for Most Common Word.\\nMemory Usage: 14 MB, less than 6.00% of Python3 online submissions for Most Common Word.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph=paragraph.lower()\\n        a=\"!?\\',;.\"\\n        for i in a:\\n            print(i)\\n            if i in paragraph:\\n                print(\\'--\\')\\n                paragraph=paragraph.replace(i,\\' \\')\\n        paragraph=paragraph.split()\\n        d={}\\n        ans=0\\n        c=\\'\\'\\n        for i in paragraph:\\n            if not i in banned:\\n                d[i]=1+d.get(i,0)\\n                ans=max(ans,d[i])\\n                if ans==d[i]:\\n                    c=i\\n        print(d)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478761,
                "title": "python3-runtime-41-ms-faster-than-86-77",
                "content": "from collections import Counter, OrderedDict\\n    import regex as re\\n\\t\\n\\tparagraph = \" \".join(re.findall(r\"[a-zA-Z0-9]+\", paragraph))\\n    c = Counter(paragraph.lower().split())\\n    c = OrderedDict(c.most_common())\\n    for word in c:\\n        if word not in banned:\\n            return word\\n\\t\\t\\t\\nFirst use regex to remove all special charater from the string. Create a `Counter` object with lowercased words. Sort with `most_common() `function. Finally loop over the `OrderedDict` and check if current word is in the banned list. If not return that word.",
                "solutionTags": [
                    "Python"
                ],
                "code": "from collections import Counter, OrderedDict\\n    import regex as re\\n\\t\\n\\tparagraph = \" \".join(re.findall(r\"[a-zA-Z0-9]+\", paragraph))\\n    c = Counter(paragraph.lower().split())\\n    c = OrderedDict(c.most_common())\\n    for word in c:\\n        if word not in banned:\\n            return word\\n\\t\\t\\t\\nFirst use regex to remove all special charater from the string. Create a `Counter` object with lowercased words. Sort with `most_common() `function. Finally loop over the `OrderedDict` and check if current word is in the banned list. If not return that word.",
                "codeTag": "Python3"
            },
            {
                "id": 2438707,
                "title": "most-common-word-easiest-solution-using-hash-map-with-proper-comments-kids-can-also-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    unordered_set<string>st;\\n    string mostCommonWord(string para, vector<string>& banned) {\\n        \\n        //first we will convert the sting to lowercase\\n        string str=\"\";\\n        for(int i=0;i<para.length();i++)\\n        {\\n            if(para[i]>=\\'A\\' and para[i]<=\\'Z\\')\\n            {\\n                char temp=tolower(para[i]);\\n                str=str+temp;\\n            }\\n            else\\n            {\\n                str=str+para[i];\\n            }\\n        }\\n        \\n        //getting the words from the str;\\n        int idx=0;\\n        string word=\"\";\\n        vector<string>s;\\n        while(true)\\n        {\\n            if(idx>=str.length())\\n            {\\n                if(word.length()>0)\\n                {\\n                    mp[word]++;\\n                    s.push_back(word);\\n                }\\n                break;\\n            }\\n            \\n            if(str[idx]>=\\'a\\' and str[idx]<=\\'z\\')\\n            {\\n                word=word+str[idx];\\n                idx++;\\n            }\\n            else   //could be space comma !?\\',;.\\n            {\\n                //word yaha milega\\n                mp[word]++;\\n                s.push_back(word);\\n                word=\"\";\\n                \\n                while(idx<str.length() and !(str[idx]>=\\'a\\' and str[idx]<=\\'z\\'))\\n                {\\n                    idx++;\\n                }\\n            }\\n        }\\n        //inserting the word in the unordered_set\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            st.insert(banned[i]);\\n        }\\n        \\n        //traversing the map for getting the ans \\n        int count=INT_MIN;\\n        string ans=\"\";\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second>count and st.find(it->first)==st.end())\\n            {\\n                ans=it->first;\\n                count=it->second;\\n            }\\n        }\\n        //returning the ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    unordered_set<string>st;\\n    string mostCommonWord(string para, vector<string>& banned) {\\n        \\n        //first we will convert the sting to lowercase\\n        string str=\"\";\\n        for(int i=0;i<para.length();i++)\\n        {\\n            if(para[i]>=\\'A\\' and para[i]<=\\'Z\\')\\n            {\\n                char temp=tolower(para[i]);\\n                str=str+temp;\\n            }\\n            else\\n            {\\n                str=str+para[i];\\n            }\\n        }\\n        \\n        //getting the words from the str;\\n        int idx=0;\\n        string word=\"\";\\n        vector<string>s;\\n        while(true)\\n        {\\n            if(idx>=str.length())\\n            {\\n                if(word.length()>0)\\n                {\\n                    mp[word]++;\\n                    s.push_back(word);\\n                }\\n                break;\\n            }\\n            \\n            if(str[idx]>=\\'a\\' and str[idx]<=\\'z\\')\\n            {\\n                word=word+str[idx];\\n                idx++;\\n            }\\n            else   //could be space comma !?\\',;.\\n            {\\n                //word yaha milega\\n                mp[word]++;\\n                s.push_back(word);\\n                word=\"\";\\n                \\n                while(idx<str.length() and !(str[idx]>=\\'a\\' and str[idx]<=\\'z\\'))\\n                {\\n                    idx++;\\n                }\\n            }\\n        }\\n        //inserting the word in the unordered_set\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            st.insert(banned[i]);\\n        }\\n        \\n        //traversing the map for getting the ans \\n        int count=INT_MIN;\\n        string ans=\"\";\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second>count and st.find(it->first)==st.end())\\n            {\\n                ans=it->first;\\n                count=it->second;\\n            }\\n        }\\n        //returning the ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424817,
                "title": "819-most-common-word-by-ashutosh-tomar",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string s=\"\";\\n        map<string,int>m;\\n        for(int i=0;i<p.size();i++){\\n            while(p[i] != \\' \\' and i < p.size()){\\n                if(!(tolower(p[i]) >= 97 and tolower(p[i]) <= 122)){\\n                    i++;\\n                    break;\\n                }\\n                s += tolower(p[i]);\\n                i++;\\n            }\\n            if(s != \"\") m[s]++;\\n            s = \"\";\\n        }\\n        s = \"\";\\n        for(int i=0;i<b.size();i++){\\n            //s += b[i];\\n            m.erase(b[i]);\\n        }\\n        //m.erase(s);\\n        string ans = \"\";\\n        int check = 0;\\n        for(auto i : m){\\n            cout<<i.first<<\" \"<<i.second<<endl;\\n        }\\n        for(auto i : m){\\n            check = max(i.second,check);\\n        }\\n        cout<<check;\\n        for(auto i : m){\\n            if(i.second == check){\\n                ans += i.first;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string s=\"\";\\n        map<string,int>m;\\n        for(int i=0;i<p.size();i++){\\n            while(p[i] != \\' \\' and i < p.size()){\\n                if(!(tolower(p[i]) >= 97 and tolower(p[i]) <= 122)){\\n                    i++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2408941,
                "title": "c-easy-to-understand-efficient",
                "content": "class Solution {\\npublic:\\n```\\n    string mostCommonWord(string paragraph, vector<string>& b) {\\n\\n        // Replace punctuation with <space>\\n        replace_if(paragraph.begin() , paragraph.end(),\\n            [] (const char& c) { return ispunct(c) ;},\\' \\');\\n\\n        unordered_set<string> banned(b.begin(), b.end());\\n        map<string, int> wordFrequency;\\n        istringstream ss(paragraph);\\n        string word;\\n        while (ss >> word) {\\n            transform(word.begin(), word.end(), word.begin(), ::tolower);\\n            if (banned.find(word) == banned.end()) {\\n                wordFrequency[word]++;\\n            }\\n        }\\n\\n        // Find the highest frequency, non-banned word in paragraph\\n        string w = wordFrequency.begin()->first;\\n        int f = wordFrequency.begin()->second;\\n        for (auto j : wordFrequency) {\\n            if (j.second > f) {\\n                w = j.first;\\n                f = j.second;\\n            }\\n        }\\n        \\n        return w;\\n    }\\n```\\n};",
                "solutionTags": [],
                "code": "```\\n    string mostCommonWord(string paragraph, vector<string>& b) {\\n\\n        // Replace punctuation with <space>\\n        replace_if(paragraph.begin() , paragraph.end(),\\n            [] (const char& c) { return ispunct(c) ;},\\' \\');\\n\\n        unordered_set<string> banned(b.begin(), b.end());\\n        map<string, int> wordFrequency;\\n        istringstream ss(paragraph);\\n        string word;\\n        while (ss >> word) {\\n            transform(word.begin(), word.end(), word.begin(), ::tolower);\\n            if (banned.find(word) == banned.end()) {\\n                wordFrequency[word]++;\\n            }\\n        }\\n\\n        // Find the highest frequency, non-banned word in paragraph\\n        string w = wordFrequency.begin()->first;\\n        int f = wordFrequency.begin()->second;\\n        for (auto j : wordFrequency) {\\n            if (j.second > f) {\\n                w = j.first;\\n                f = j.second;\\n            }\\n        }\\n        \\n        return w;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2347516,
                "title": "java-o-n-m-hashmap-easy",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n       \\n        HashMap<String, Integer> hm = new HashMap<>();\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(hm.containsKey(words[i]))\\n                hm.replace(words[i], hm.get(words[i]), hm.get(words[i])+1);\\n            else\\n                hm.put(words[i], 1);\\n        }\\n        \\n        for(int i=0; i< banned.length; i++)\\n            if(hm.containsKey(banned[i]))\\n                 hm.remove(banned[i]);\\n\\n        return Collections.max(hm.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n       \\n        HashMap<String, Integer> hm = new HashMap<>();\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(hm.containsKey(words[i]))\\n                hm.replace(words[i], hm.get(words[i]), hm.get(words[i])+1);\\n            else\\n                hm.put(words[i], 1);\\n        }\\n        \\n        for(int i=0; i< banned.length; i++)\\n            if(hm.containsKey(banned[i]))\\n                 hm.remove(banned[i]);\\n\\n        return Collections.max(hm.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337364,
                "title": "python-2-solutions-easy",
                "content": "Solution by leetcode.\\n\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\t#1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tnormalized_str = \\'\\'.join([c.lower() if c.isalnum() else \\' \\' for c in paragraph])\\n\\n\\t\\t\\t#2). split the string into words\\n\\t\\t\\twords = normalized_str.split()\\n\\n\\t\\t\\tword_count = defaultdict(int)\\n\\t\\t\\tbanned_words = set(banned)\\n\\n\\t\\t\\t#3). count the appearance of each word, excluding the banned words\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif word not in banned_words:\\n\\t\\t\\t\\t\\tword_count[word] += 1\\n\\n\\t\\t\\t#4). return the word with the highest frequency\\n\\t\\t\\treturn max(word_count.items(), key=operator.itemgetter(1))[0]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nmy solution.\\t\\t\\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\ts=\"\".join([c.lower() if c.isalnum() else \" \" for c in paragraph])   #1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tl=s.split()                       #2). split the string into words\\n\\t\\t\\ts=set(banned)                 \\n\\t\\t\\td=defaultdict(int)\\n\\t\\t\\tmaxi=0\\n\\t\\t\\tans=\"\"\\n\\t\\t\\tfor i in l:\\n\\t\\t\\t\\tif i in s:                      #3). count the appearance of each word, excluding the banned words\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif i in d.keys():         # if key already exists increase its value\\n\\t\\t\\t\\t\\td[i]+=1\\n\\t\\t\\t\\telse :                          #else initialize with value 1\\n\\t\\t\\t\\t\\td[i]=1\\n\\t\\t\\t\\tif d[i]>maxi:              #simultaneously count the the max value and the corresponding key\\n\\t\\t\\t\\t\\tmaxi=d[i]\\n\\t\\t\\t\\t\\tans=i\\n\\t\\t\\treturn ans               #return answer\\n\\nupvote if the solution helped.\\uD83D\\uDE0A",
                "solutionTags": [],
                "code": "Solution by leetcode.\\n\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\t#1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tnormalized_str = \\'\\'.join([c.lower() if c.isalnum() else \\' \\' for c in paragraph])\\n\\n\\t\\t\\t#2). split the string into words\\n\\t\\t\\twords = normalized_str.split()\\n\\n\\t\\t\\tword_count = defaultdict(int)\\n\\t\\t\\tbanned_words = set(banned)\\n\\n\\t\\t\\t#3). count the appearance of each word, excluding the banned words\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif word not in banned_words:\\n\\t\\t\\t\\t\\tword_count[word] += 1\\n\\n\\t\\t\\t#4). return the word with the highest frequency\\n\\t\\t\\treturn max(word_count.items(), key=operator.itemgetter(1))[0]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nmy solution.\\t\\t\\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\ts=\"\".join([c.lower() if c.isalnum() else \" \" for c in paragraph])   #1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tl=s.split()                       #2). split the string into words\\n\\t\\t\\ts=set(banned)                 \\n\\t\\t\\td=defaultdict(int)\\n\\t\\t\\tmaxi=0\\n\\t\\t\\tans=\"\"\\n\\t\\t\\tfor i in l:\\n\\t\\t\\t\\tif i in s:                      #3). count the appearance of each word, excluding the banned words\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif i in d.keys():         # if key already exists increase its value\\n\\t\\t\\t\\t\\td[i]+=1\\n\\t\\t\\t\\telse :                          #else initialize with value 1\\n\\t\\t\\t\\t\\td[i]=1\\n\\t\\t\\t\\tif d[i]>maxi:              #simultaneously count the the max value and the corresponding key\\n\\t\\t\\t\\t\\tmaxi=d[i]\\n\\t\\t\\t\\t\\tans=i\\n\\t\\t\\treturn ans               #return answer\\n\\nupvote if the solution helped.\\uD83D\\uDE0A",
                "codeTag": "Java"
            },
            {
                "id": 2326791,
                "title": "100-faster-c-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n        string temp = \"\";\\n        unordered_map<string, int> mp;\\n        for(int i = 0; i < paragraph.size(); i++)\\n        {\\n            if(isalpha(paragraph[i]))\\n            {\\n                temp += paragraph[i];\\n            }\\n            else if(paragraph[i] == \\' \\' || paragraph[i] == \\',\\')\\n            {\\n                if(temp != \"\")\\n                {\\n                    mp[temp]++;\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        mp[temp]++;\\n        temp = \"\";\\n        for(int i = 0; i < banned.size(); i++)\\n        {\\n            mp[banned[i]] = 0;\\n        }\\n        int n = INT_MIN;\\n        for(auto i : mp)\\n        {\\n            if(i.second > n)\\n            {\\n                temp = i.first;\\n                n = i.second;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n        string temp = \"\";\\n        unordered_map<string, int> mp;\\n        for(int i = 0; i < paragraph.size(); i++)\\n        {\\n            if(isalpha(paragraph[i]))\\n            {\\n                temp += paragraph[i];\\n            }\\n            else if(paragraph[i] == \\' \\' || paragraph[i] == \\',\\')\\n            {\\n                if(temp != \"\")\\n                {\\n                    mp[temp]++;\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        mp[temp]++;\\n        temp = \"\";\\n        for(int i = 0; i < banned.size(); i++)\\n        {\\n            mp[banned[i]] = 0;\\n        }\\n        int n = INT_MIN;\\n        for(auto i : mp)\\n        {\\n            if(i.second > n)\\n            {\\n                temp = i.first;\\n                n = i.second;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310341,
                "title": "python-simple-hashmap",
                "content": "\\n    def mostCommonWord(self, paragraph, banned):\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i, \" \")\\n            \\n        dict1 = Counter([i for i in paragraph.lower().split()])\\n        \\n        ans = sorted(dict1, key = dict1.get, reverse = True)\\n        \\n        for i in ans:\\n            if i not in banned:\\n                return i",
                "solutionTags": [],
                "code": "\\n    def mostCommonWord(self, paragraph, banned):\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i, \" \")\\n            \\n        dict1 = Counter([i for i in paragraph.lower().split()])\\n        \\n        ans = sorted(dict1, key = dict1.get, reverse = True)\\n        \\n        for i in ans:\\n            if i not in banned:\\n                return i",
                "codeTag": "Python3"
            },
            {
                "id": 2167485,
                "title": "c-runtime-o-n-space-o-n-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // Overall - Runtime Complexity: O(n)  Space Complexity O(n)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        // Construct string to store parsed substring from paragraph\\n        string s = \"\";\\n        \\n        // Construct unordered map to store word counts\\n        unordered_map<string, int> um;\\n        \\n        // Iterate over characters in paragraph\\n        for(int i = 0; i < paragraph.size(); i++) {\\n            // Check if delimeter is found or at last character in paragraph\\n            if(!isalpha(paragraph[i]) || i == paragraph.size() - 1) {\\n                // Check for edge case of last character in paragraph\\n                if(i == paragraph.size() - 1 && isalpha(paragraph[i]))\\n                    s += tolower(paragraph[i]);\\n                \\n                // If current string is not empty update map & reset string\\n                if(!s.empty()) { \\n                    um[s]++;\\n                    s = \"\";\\n                }\\n            } else {\\n                // Append lower-case of current character to word string\\n                s += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        // Iterate over banned words\\n        for(const auto &it : banned) {\\n            // Check if banned word exists in map\\n            auto ret = um.find(it);\\n            \\n            // If banned word exists, delete\\n            if(ret != um.end())\\n                um.erase(ret->first);\\n        }\\n        \\n        // Return key in map which contains max value\\n        return max_element(um.begin(), um.end(),\\n                          [](const auto &p1, const auto &p2) {\\n                              return p1.second < p2.second;\\n                          })->first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Overall - Runtime Complexity: O(n)  Space Complexity O(n)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        // Construct string to store parsed substring from paragraph\\n        string s = \"\";\\n        \\n        // Construct unordered map to store word counts\\n        unordered_map<string, int> um;\\n        \\n        // Iterate over characters in paragraph\\n        for(int i = 0; i < paragraph.size(); i++) {\\n            // Check if delimeter is found or at last character in paragraph\\n            if(!isalpha(paragraph[i]) || i == paragraph.size() - 1) {\\n                // Check for edge case of last character in paragraph\\n                if(i == paragraph.size() - 1 && isalpha(paragraph[i]))\\n                    s += tolower(paragraph[i]);\\n                \\n                // If current string is not empty update map & reset string\\n                if(!s.empty()) { \\n                    um[s]++;\\n                    s = \"\";\\n                }\\n            } else {\\n                // Append lower-case of current character to word string\\n                s += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        // Iterate over banned words\\n        for(const auto &it : banned) {\\n            // Check if banned word exists in map\\n            auto ret = um.find(it);\\n            \\n            // If banned word exists, delete\\n            if(ret != um.end())\\n                um.erase(ret->first);\\n        }\\n        \\n        // Return key in map which contains max value\\n        return max_element(um.begin(), um.end(),\\n                          [](const auto &p1, const auto &p2) {\\n                              return p1.second < p2.second;\\n                          })->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115613,
                "title": "easy-python-faster-than-83",
                "content": "```\\nclass Solution:\\n   \\n   def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #remove all special chars\\n\\t\\tfor c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        \\n\\t\\t#create a set of banned words for easy lookup\\n\\t\\tbannedSet = set(banned)\\n        lookup ={}\\n\\t\\t\\n        maxcount  = 0\\n        maxWord = \"\"\\n        for word in paragraph.lower().split():\\n            if word not in bannedSet:\\n                lookup[word] = lookup.get(word,0)+1\\n                if lookup[word] >maxcount:\\n                    maxcount = lookup[word]\\n                    maxWord = word\\n        return maxWord\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n   \\n   def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #remove all special chars\\n\\t\\tfor c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        \\n\\t\\t#create a set of banned words for easy lookup\\n\\t\\tbannedSet = set(banned)\\n        lookup ={}\\n\\t\\t\\n        maxcount  = 0\\n        maxWord = \"\"\\n        for word in paragraph.lower().split():\\n            if word not in bannedSet:\\n                lookup[word] = lookup.get(word,0)+1\\n                if lookup[word] >maxcount:\\n                    maxcount = lookup[word]\\n                    maxWord = word\\n        return maxWord\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063672,
                "title": "simple-python-solution-o-n",
                "content": "```py\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        for i in list(\"!?\\',;.\"):\\n            paragraph = paragraph.replace(i, \" \")\\n        result = []\\n        for i in paragraph.split():\\n            if i not in banned: result.append(i)\\n        return Counter(result).most_common()[0][0]\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        for i in list(\"!?\\',;.\"):\\n            paragraph = paragraph.replace(i, \" \")\\n        result = []\\n        for i in paragraph.split():\\n            if i not in banned: result.append(i)\\n        return Counter(result).most_common()[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002854,
                "title": "java-hasmap-hashset",
                "content": "```\\n\\t\\t\\tHashMap<String,Integer> map = new HashMap<>();\\n            \\n            String []words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n            \\n            for(String str:words){\\n                        map.put(str,map.getOrDefault(str,0)+1);                            \\n            }\\n            \\n            HashSet<String> set = new HashSet<>();\\n            for(String str:banned){\\n                    set.add(str);\\n            }\\n            \\n            \\n            int max = 0;\\n            String ans=\"\";\\n            \\n            for(String key : map.keySet()){\\n                    if(!set.contains(key)){\\n                            int freq = map.get(key);\\n                            if(max < freq){\\n                                    max = freq;\\n                                    ans = key;\\n                            }\\n                    }\\n            }\\n            \\n            return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t\\tHashMap<String,Integer> map = new HashMap<>();\\n            \\n            String []words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n            \\n            for(String str:words){\\n                        map.put(str,map.getOrDefault(str,0)+1);                            \\n            }\\n            \\n            HashSet<String> set = new HashSet<>();\\n            for(String str:banned){\\n                    set.add(str);\\n            }\\n            \\n            \\n            int max = 0;\\n            String ans=\"\";\\n            \\n            for(String key : map.keySet()){\\n                    if(!set.contains(key)){\\n                            int freq = map.get(key);\\n                            if(max < freq){\\n                                    max = freq;\\n                                    ans = key;\\n                            }\\n                    }\\n            }\\n            \\n            return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1949844,
                "title": "c-explained-code-very-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n    //creating an unordered map to store banned string\\n            unordered_map<string,int>ban;\\n            \\n            for(int i = 0; i < banned.size(); i++)\\n            {\\n                    ban[banned[i]]++;\\n            }\\n        //declaring a max freq count to store frequency     \\n\\t\\t\\n            int max_freq = 0;\\n            string ans = \"\";\\n\\t\\t\\t\\n\\t\\t\\t//another map for storing ans string\\n\\t\\t\\t\\n            unordered_map<string,int>mp;\\n             for(int i = 0; i < paragraph.length(); i++)\\n             {\\n                     string word = \"\";\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t //running loop till pragraph length and only pushing alphabets excluding special symbols\\n\\t\\t\\t\\t\\t \\n                     while(i < paragraph.length() && isalpha(paragraph[i]))\\n                     {\\n\\t\\t\\t\\t\\t        // converting all upercase letter to lowercase letter\\n\\t\\t\\t\\t\\t\\t\\t\\n                             paragraph[i] = tolower(paragraph[i]);\\n                             word.push_back(paragraph[i]);\\n                             i++;\\n                     }\\n\\t\\t\\t\\t\\t //checking condition that banned string is not present in word and word is not an empty string\\n                     if(ban.find(word) == ban.end() && word != \"\")\\n                     {\\n                             mp[word]++;\\n                     \\n                     if(max_freq < mp[word])\\n                     {\\n\\t\\t\\t\\t\\t \\n                             max_freq = mp[word];\\n                             ans = word;\\n                     }\\n             }\\n             }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n    //creating an unordered map to store banned string\\n            unordered_map<string,int>ban;\\n            \\n            for(int i = 0; i < banned.size(); i++)\\n            {\\n                    ban[banned[i]]++;\\n            }\\n        //declaring a max freq count to store frequency     \\n\\t\\t\\n            int max_freq = 0;\\n            string ans = \"\";\\n\\t\\t\\t\\n\\t\\t\\t//another map for storing ans string\\n\\t\\t\\t\\n            unordered_map<string,int>mp;\\n             for(int i = 0; i < paragraph.length(); i++)\\n             {\\n                     string word = \"\";\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t //running loop till pragraph length and only pushing alphabets excluding special symbols\\n\\t\\t\\t\\t\\t \\n                     while(i < paragraph.length() && isalpha(paragraph[i]))\\n                     {\\n\\t\\t\\t\\t\\t        // converting all upercase letter to lowercase letter\\n\\t\\t\\t\\t\\t\\t\\t\\n                             paragraph[i] = tolower(paragraph[i]);\\n                             word.push_back(paragraph[i]);\\n                             i++;\\n                     }\\n\\t\\t\\t\\t\\t //checking condition that banned string is not present in word and word is not an empty string\\n                     if(ban.find(word) == ban.end() && word != \"\")\\n                     {\\n                             mp[word]++;\\n                     \\n                     if(max_freq < mp[word])\\n                     {\\n\\t\\t\\t\\t\\t \\n                             max_freq = mp[word];\\n                             ans = word;\\n                     }\\n             }\\n             }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916788,
                "title": "python3-very-easy-yet-very-fast",
                "content": "***Runtime: 30 ms, faster than 99.86% of Python3 online submissions for Most Common Word.\\nMemory Usage: 13.9 MB, less than 40.82% of Python3 online submissions for Most Common Word.***\\n.\\n\\n**If you like this solution please upvote** \\u2714\\uD83D\\uDE80\\uD83D\\uDC96\\n```\\nclass Solution:\\n    def mostCommonWord(self, para: str, banned: List[str]) -> str:\\n        \\n        p = []\\n        s = \\'\\'\\n\\t\\tbanned = set(banned)\\n        rem = {\"!\",\"?\",\"\\'\",\",\",\";\",\".\",\" \"}\\n        freq = {}\\n        \\n        for c in para:\\n            if c in rem:\\n                if s: p.append(s)\\n                s = \\'\\'\\n                continue\\n            \\n            if c.isupper(): s += c.lower()\\n            else: s += c\\n        \\n        if s: p.append(s)\\n        maxfreq, maxword = 0, \\'\\'\\n        \\n        for w in p:\\n            \\n            if w in banned: continue\\n            if w not in freq: freq[w] = 0\\n                \\n            freq[w] += 1\\n            if freq[w] > maxfreq:\\n                maxfreq = freq[w]\\n                maxword = w\\n                \\n        return maxword\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, para: str, banned: List[str]) -> str:\\n        \\n        p = []\\n        s = \\'\\'\\n\\t\\tbanned = set(banned)\\n        rem = {\"!\",\"?\",\"\\'\",\",\",\";\",\".\",\" \"}\\n        freq = {}\\n        \\n        for c in para:\\n            if c in rem:\\n                if s: p.append(s)\\n                s = \\'\\'\\n                continue\\n            \\n            if c.isupper(): s += c.lower()\\n            else: s += c\\n        \\n        if s: p.append(s)\\n        maxfreq, maxword = 0, \\'\\'\\n        \\n        for w in p:\\n            \\n            if w in banned: continue\\n            if w not in freq: freq[w] = 0\\n                \\n            freq[w] += 1\\n            if freq[w] > maxfreq:\\n                maxfreq = freq[w]\\n                maxword = w\\n                \\n        return maxword\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900967,
                "title": "c",
                "content": "public string MostCommonWord(string paragraph, string[] banned) {\\n        \\n        char[] symbols = \"!?\\',;. \".ToArray();\\n        string[] piece = paragraph.ToLower().Split(symbols, StringSplitOptions.RemoveEmptyEntries);\\n\\n        return piece.GroupBy(x => x).Where(x => banned.Contains(x.Key) == false).OrderByDescending(x => x.Count()).First().Key;\\n    }",
                "solutionTags": [],
                "code": "public string MostCommonWord(string paragraph, string[] banned) {\\n        \\n        char[] symbols = \"!?\\',;. \".ToArray();\\n        string[] piece = paragraph.ToLower().Split(symbols, StringSplitOptions.RemoveEmptyEntries);\\n\\n        return piece.GroupBy(x => x).Where(x => banned.Contains(x.Key) == false).OrderByDescending(x => x.Count()).First().Key;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1838953,
                "title": "easiest-java-solution-beginner-level-o-m-n",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for(String s : banned) {\\n            set.add(s); \\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        String[] strs = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String res = \"\";\\n\\n        for(String str : strs) {\\n            if(!set.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n        \\n        for(String key : map.keySet()) {\\n            if(map.get(key) > max) {\\n                max = map.get(key);\\n                res = key;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for(String s : banned) {\\n            set.add(s); \\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        String[] strs = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String res = \"\";\\n\\n        for(String str : strs) {\\n            if(!set.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n        \\n        for(String key : map.keySet()) {\\n            if(map.get(key) > max) {\\n                max = map.get(key);\\n                res = key;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834826,
                "title": "c-easiest-solution-ever-few-lines-of-code",
                "content": "# Easy check it ;-)\\n[**@iprincekumark**](https://leetcode.com/iprincekumark/)\\n[```\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string, int> ban;\\n        for(int i=0; i<banned.size(); i++)\\n            ban[banned[i]]++;\\n        \\n        int max_freq=0;\\n        string ans=\"\";\\n        unordered_map<string, int> mp;\\n        \\n        for(int i=0; i<paragraph.length(); i++) {\\n            string word=\"\";\\n            while(i<paragraph.length() && isalpha(paragraph[i])) {\\n                paragraph[i] = tolower(paragraph[i]);\\n                word.push_back(paragraph[i]);\\n                i++;\\n            }\\n      \\n            if(ban.find(word) == ban.end() && word!=\"\") {\\n                mp[word]++;\\n                if(max_freq<mp[word]) {\\n                    max_freq = mp[word];\\n                    ans = word;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```](https://leetcode.com/iprincekumark/)",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string, int> ban;\\n        for(int i=0; i<banned.size(); i++)\\n            ban[banned[i]]++;\\n        \\n        int max_freq=0;\\n        string ans=\"\";\\n        unordered_map<string, int> mp;\\n        \\n        for(int i=0; i<paragraph.length(); i++) {\\n            string word=\"\";\\n            while(i<paragraph.length() && isalpha(paragraph[i])) {\\n                paragraph[i] = tolower(paragraph[i]);\\n                word.push_back(paragraph[i]);\\n                i++;\\n            }\\n      \\n            if(ban.find(word) == ban.end() && word!=\"\") {\\n                mp[word]++;\\n                if(max_freq<mp[word]) {\\n                    max_freq = mp[word];\\n                    ans = word;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1761144,
                "title": "easy-c-solution-0-ms-space-less-than-96",
                "content": "Please upvote the code if you like the content. It is always a great motivation :)\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_map<string, int> m;\\n        string s = \"\";\\n        int freq = 0;\\n        \\n        for(int i=0; i<paragraph.length(); i++)\\n        {\\n            if((paragraph[i] >= \\'a\\' and paragraph[i] <= \\'z\\') or (paragraph[i] >= \\'A\\' and paragraph[i] <= \\'Z\\'))\\n            {\\n                s += tolower(paragraph[i]);\\n            }\\n            \\n            else\\n            {\\n                m[s]++;\\n                s = \"\";\\n            }\\n        }\\n        \\n        m[s]++;\\n        \\n        for(auto i: banned)\\n            m[i] = 0;\\n        \\n        for(auto i: m)\\n        {\\n            if(i.second >= freq and i.first != \"\")\\n            {\\n                freq = i.second;\\n                s = i.first;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_map<string, int> m;\\n        string s = \"\";\\n        int freq = 0;\\n        \\n        for(int i=0; i<paragraph.length(); i++)\\n        {\\n            if((paragraph[i] >= \\'a\\' and paragraph[i] <= \\'z\\') or (paragraph[i] >= \\'A\\' and paragraph[i] <= \\'Z\\'))\\n            {\\n                s += tolower(paragraph[i]);\\n            }\\n            \\n            else\\n            {\\n                m[s]++;\\n                s = \"\";\\n            }\\n        }\\n        \\n        m[s]++;\\n        \\n        for(auto i: banned)\\n            m[i] = 0;\\n        \\n        for(auto i: m)\\n        {\\n            if(i.second >= freq and i.first != \"\")\\n            {\\n                freq = i.second;\\n                s = i.first;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734159,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        \\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \" \").toLowerCase();\\n        HashMap<String,Integer> map = new HashMap<>();\\n        \\n        Set<String> bannedWords = new HashSet();\\n        \\n        for(String word:banned)\\n            bannedWords.add(word);\\n\\n        int max=0;\\n        String ret=\"\";\\n\\n        for(String word:paragraph.split(\"\\\\\\\\s+\"))\\n        {\\n            if(bannedWords.contains(word))continue;\\n            \\n            map.put(word,map.getOrDefault(word,0)+1);\\n            \\n            if(map.get(word)>max)\\n            {\\n                max = map.get(word);\\n                ret = word;\\n            }            \\n        }\\n     \\n        return ret;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        \\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \" \").toLowerCase();\\n        HashMap<String,Integer> map = new HashMap<>();\\n        \\n        Set<String> bannedWords = new HashSet();\\n        \\n        for(String word:banned)\\n            bannedWords.add(word);\\n\\n        int max=0;\\n        String ret=\"\";\\n\\n        for(String word:paragraph.split(\"\\\\\\\\s+\"))\\n        {\\n            if(bannedWords.contains(word))continue;\\n            \\n            map.put(word,map.getOrDefault(word,0)+1);\\n            \\n            if(map.get(word)>max)\\n            {\\n                max = map.get(word);\\n                ret = word;\\n            }            \\n        }\\n     \\n        return ret;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696983,
                "title": "c-linq-2-lines-no-orderby-o-n-solution",
                "content": ".NET 5 doesn\\'t have ExceptBy.\\n```\\npublic class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned)\\n    {\\n        var bannedSet = banned.ToHashSet();\\n        return paragraph\\n                .ToLowerInvariant()\\n                .Split(new[] { \\' \\', \\'\"\\', \\'!\\', \\'?\\', \\'\\\\\\'\\', \\',\\', \\';\\', \\'.\\' }, StringSplitOptions.RemoveEmptyEntries)\\n                .Where(s => !bannedSet.Contains(s))\\n                .GroupBy(s => s, (s, g) => (word: s, count: g.Count()))\\n                .Aggregate((word: \"\", count: 0), (res, cur) => cur.count > res.count ? cur : res, res => res.word);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned)\\n    {\\n        var bannedSet = banned.ToHashSet();\\n        return paragraph\\n                .ToLowerInvariant()\\n                .Split(new[] { \\' \\', \\'\"\\', \\'!\\', \\'?\\', \\'\\\\\\'\\', \\',\\', \\';\\', \\'.\\' }, StringSplitOptions.RemoveEmptyEntries)\\n                .Where(s => !bannedSet.Contains(s))\\n                .GroupBy(s => s, (s, g) => (word: s, count: g.Count()))\\n                .Aggregate((word: \"\", count: 0), (res, cur) => cur.count > res.count ? cur : res, res => res.word);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673124,
                "title": "python3-53ms-runtime-17-11-memory-14-3mb-47-52",
                "content": "```\\nimport re\\nfrom collections import Counter\\n\\ndef mostCommon(string, banned):\\n\\tstring = re.sub(r\"[^a-zA-Z]\", \" \", string).lower() # to remove every unwated symbols\\n\\tfreq = Counter(string.split())\\n\\tfor ban in banned:\\n\\t\\tif ban in freq:\\n\\t\\t\\tfreq.pop(ban)\\n\\t\\t\\t\\n\\treturn max(freq, key=freq.get)\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\nfrom collections import Counter\\n\\ndef mostCommon(string, banned):\\n\\tstring = re.sub(r\"[^a-zA-Z]\", \" \", string).lower() # to remove every unwated symbols\\n\\tfreq = Counter(string.split())\\n\\tfor ban in banned:\\n\\t\\tif ban in freq:\\n\\t\\t\\tfreq.pop(ban)\\n\\t\\t\\t\\n\\treturn max(freq, key=freq.get)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1624949,
                "title": "4ms-faster-than-87-c",
                "content": "class Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n     \\n        unordered_set<string> st (banned.begin(), banned.end()); \\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0; i<p.size(); i++) \\n        {\\n            string curr = \"\";\\n            \\n            while(i != p.size() && (p[i] >=\\'a\\' && p[i] <= \\'z\\' || p[i] >=\\'A\\' && p[i] <=\\'Z\\'))\\n            {\\n                curr += (char)tolower(p[i]); \\n                i++;\\n            }\\n            \\n            \\n            if(curr != \"\" && st.find(curr) == st.end()) \\n            mp[curr]++;\\n                \\n        } \\n        \\n        int count = 0;\\n        string res = \"\";\\n        \\n        for(auto it : mp)\\n        {\\n            if(it.second > count)\\n            {\\n                res = it.first;\\n                count = it.second;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n     \\n        unordered_set<string> st (banned.begin(), banned.end()); \\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0; i<p.size(); i++) \\n        {\\n            string curr = \"\";\\n            \\n            while(i != p.size() && (p[i] >=\\'a\\' && p[i] <= \\'z\\' || p[i] >=\\'A\\' && p[i] <=\\'Z\\'))\\n            {\\n                curr += (char)tolower(p[i]); \\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1590573,
                "title": "c-easy-solution-with-explanation",
                "content": "Here the main idea is we take all words from paragraph and store it into a map with its frequency. Here I inserted only those words which are not in banned array.\\n\\nAlgorithm :\\n* we first take a unordered_set<string>ban, where I inserted all banned elements so that I can get them in O(1) complexity.\\n* Then take a unordered map of string as a key and integer as its value.\\n* Then run a loop on paragraph\\n\\t\\t* if current character is a uppercase letter then substract 32 in it to make it lowercase(since we need lowercase words).\\n\\t\\t* if current letter is a alphabet then add it to a temporary string.\\n\\t\\t* otherwise if that temp is not banned then increase frequency in map. Here I am also maintaining a maximum frequency variable.\\n\\n* Now traverse to map and if a words frequency equals to maxfrequency then return it.\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string>ban;\\n        unordered_map<string,int>fre;\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        string temp=\"\";\\n        int maxfre=0;\\n        for(int i=0;i<paragraph.size();i++){\\n            if(paragraph[i]>64 && paragraph[i]<91)\\n                paragraph[i]+=32;\\n            \\n            if(paragraph[i]>96 && paragraph[i]<123)\\n                temp+=paragraph[i];\\n            else{\\n                if(!temp.empty() && ban.find(temp)==ban.end())\\n                {\\n                    fre[temp]++;\\n                    maxfre=max(maxfre,fre[temp]);\\n                }\\n                temp=\"\";\\n                continue;\\n            }\\n        }\\n        if(!temp.empty()){\\n            fre[temp]++;\\n            maxfre=max(maxfre,fre[temp]);\\n        }\\n        for(auto it=fre.begin();it!=fre.end();it++){\\n            if(it->second==maxfre)\\n                return it->first;\\n        }\\n        return \"\";\\n    }\\n};\\n```\\nIf this post is helpful for you then please upvote. Thank you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string>ban;\\n        unordered_map<string,int>fre;\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        string temp=\"\";\\n        int maxfre=0;\\n        for(int i=0;i<paragraph.size();i++){\\n            if(paragraph[i]>64 && paragraph[i]<91)\\n                paragraph[i]+=32;\\n            \\n            if(paragraph[i]>96 && paragraph[i]<123)\\n                temp+=paragraph[i];\\n            else{\\n                if(!temp.empty() && ban.find(temp)==ban.end())\\n                {\\n                    fre[temp]++;\\n                    maxfre=max(maxfre,fre[temp]);\\n                }\\n                temp=\"\";\\n                continue;\\n            }\\n        }\\n        if(!temp.empty()){\\n            fre[temp]++;\\n            maxfre=max(maxfre,fre[temp]);\\n        }\\n        for(auto it=fre.begin();it!=fre.end();it++){\\n            if(it->second==maxfre)\\n                return it->first;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499269,
                "title": "java-streams",
                "content": "```\\n        List<String> ban = Arrays.asList(banned);\\n        paragraph=paragraph.replaceAll(\"[^A-Za-z ]\",\" \").toLowerCase();\\n        Map<String, Integer> result=Arrays.asList(paragraph.split(\" +\")).parallelStream().filter(str -> !ban.contains(str)).collect(Collectors.toConcurrentMap(w -> w, w -> 1, Integer::sum));\\n        String max=result.entrySet().stream().max(Map.Entry.comparingByValue()).get().getKey();\\n        return max;\\n```",
                "solutionTags": [],
                "code": "```\\n        List<String> ban = Arrays.asList(banned);\\n        paragraph=paragraph.replaceAll(\"[^A-Za-z ]\",\" \").toLowerCase();\\n        Map<String, Integer> result=Arrays.asList(paragraph.split(\" +\")).parallelStream().filter(str -> !ban.contains(str)).collect(Collectors.toConcurrentMap(w -> w, w -> 1, Integer::sum));\\n        String max=result.entrySet().stream().max(Map.Entry.comparingByValue()).get().getKey();\\n        return max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1426981,
                "title": "solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(String s : banned){\\n            set.add(s);\\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        String[] splitted = paragraph.split(\"[\\\\\\\\s,]+\");\\n        \\n        for(int i = 0; i < splitted.length ; i++){\\n            \\n            String current = splitted[i].toLowerCase().replaceAll(\"\\\\\\\\p{Punct}\",\"\");\\n            \\n            map.put(current, map.getOrDefault(current, 0)+1);\\n        }\\n\\t\\t\\n        PriorityQueue<String> pq = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(String s : map.keySet()){\\n            \\n            if(!set.contains(s)){\\n                pq.add(s);\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(String s : banned){\\n            set.add(s);\\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        String[] splitted = paragraph.split(\"[\\\\\\\\s,]+\");\\n        \\n        for(int i = 0; i < splitted.length ; i++){\\n            \\n            String current = splitted[i].toLowerCase().replaceAll(\"\\\\\\\\p{Punct}\",\"\");\\n            \\n            map.put(current, map.getOrDefault(current, 0)+1);\\n        }\\n\\t\\t\\n        PriorityQueue<String> pq = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(String s : map.keySet()){\\n            \\n            if(!set.contains(s)){\\n                pq.add(s);\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418114,
                "title": "easy-java-solution-hashmap-regex",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        if(paragraph.length() == 0){\\n            return \"\";\\n        }\\n        HashMap<String,Integer> m = new HashMap<String,Integer>();\\n        String result = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        String[] s = paragraph.split(\"[^a-z]+\");\\n        for(String a: s){\\n            if(!m.containsKey(a)){\\n                m.put(a,1);\\n            }else{\\n                m.put(a,m.get(a)+1);\\n            }\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            if(m.containsKey(banned[i].toLowerCase())){\\n                m.remove(banned[i].toLowerCase());\\n            }\\n        }\\n        int maxValueInMap=(Collections.max(m.values())); \\n        for(Map.Entry<String,Integer> entry : m.entrySet()){\\n            if (entry.getValue()==maxValueInMap) {\\n                result = entry.getKey(); \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        if(paragraph.length() == 0){\\n            return \"\";\\n        }\\n        HashMap<String,Integer> m = new HashMap<String,Integer>();\\n        String result = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        String[] s = paragraph.split(\"[^a-z]+\");\\n        for(String a: s){\\n            if(!m.containsKey(a)){\\n                m.put(a,1);\\n            }else{\\n                m.put(a,m.get(a)+1);\\n            }\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            if(m.containsKey(banned[i].toLowerCase())){\\n                m.remove(banned[i].toLowerCase());\\n            }\\n        }\\n        int maxValueInMap=(Collections.max(m.values())); \\n        for(Map.Entry<String,Integer> entry : m.entrySet()){\\n            if (entry.getValue()==maxValueInMap) {\\n                result = entry.getKey(); \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413128,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string,int> ans;\\n        string ban;\\n        for(auto c:banned){\\n            ban+=c;ban+=\\' \\';\\n        }\\n        for(auto &c : paragraph)\\n            c =  isalpha(c)? tolower(c) : \\' \\'; \\n        stringstream ss(paragraph);\\n        string word;\\n        while(ss>>word)\\n        {ans[word]++;\\n        }\\n        int m=0;string a;\\n        for(auto i:ans){\\n            cout<<i.first<<\"- \"<<i.second<<\"\\\\n\";\\n            if(i.second>m && ban.find(i.first)==string::npos)\\n            { m=i.second;a=i.first;}\\n        }\\n        return a;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string,int> ans;\\n        string ban;\\n        for(auto c:banned){\\n            ban+=c;ban+=\\' \\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1412891,
                "title": "c-regex-std-transform",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        if(paragraph.empty())return \"\";\\n        \\n        //put it in a set, so that searching a word could be optimized\\n        //first should be to replace the punctutaions and onvert into lower case\\n        \\n        //use std::transform to convert the entire string to lower or upper string\\n        \\n        std::transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n    \\n        regex re(\"[^A-Za-z0-9]\");\\n        paragraph = regex_replace(paragraph, re, \" \");\\n        \\n        cout<<paragraph;\\n        \\n        unordered_set<string> banSet;\\n        \\n        for(auto s : banned)\\n        {\\n            banSet.insert(s);\\n        }\\n        \\n        //make the frequency map using unordered_map in c++\\n        \\n        unordered_map<string, int> freqMap;\\n        \\n        //use istringstream to split the words in the string\\n        \\n        istringstream ss(paragraph);\\n        \\n        string word;\\n        \\n        while(ss >> word)\\n        {   \\n            if(banSet.find(word) == banSet.end())\\n            {\\n                freqMap[word]++;\\n            }\\n        }\\n        \\n        int max = 0;\\n        string maxString;\\n        \\n        for(auto f : freqMap)\\n        {\\n            if(f.second > max){max = f.second; maxString = f.first;}\\n        }\\n        \\n        return maxString;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        if(paragraph.empty())return \"\";\\n        \\n        //put it in a set, so that searching a word could be optimized\\n        //first should be to replace the punctutaions and onvert into lower case\\n        \\n        //use std::transform to convert the entire string to lower or upper string\\n        \\n        std::transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n    \\n        regex re(\"[^A-Za-z0-9]\");\\n        paragraph = regex_replace(paragraph, re, \" \");\\n        \\n        cout<<paragraph;\\n        \\n        unordered_set<string> banSet;\\n        \\n        for(auto s : banned)\\n        {\\n            banSet.insert(s);\\n        }\\n        \\n        //make the frequency map using unordered_map in c++\\n        \\n        unordered_map<string, int> freqMap;\\n        \\n        //use istringstream to split the words in the string\\n        \\n        istringstream ss(paragraph);\\n        \\n        string word;\\n        \\n        while(ss >> word)\\n        {   \\n            if(banSet.find(word) == banSet.end())\\n            {\\n                freqMap[word]++;\\n            }\\n        }\\n        \\n        int max = 0;\\n        string maxString;\\n        \\n        for(auto f : freqMap)\\n        {\\n            if(f.second > max){max = f.second; maxString = f.first;}\\n        }\\n        \\n        return maxString;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1376398,
                "title": "golang-runtime-beats-100",
                "content": "```\\nfunc mostCommonWord(para string, banned []string) string {\\n    \\n    // create a map of banned words\\n    bannedStrings := make(map[string]int)\\n    for _, val := range banned {\\n        bannedStrings[val] = 1\\n    }\\n    \\n    mostCommonWord := \"\"\\n    mostCommonWordFreq := 0\\n    \\n    var sb strings.Builder\\n    words := make(map[string]int)\\n    for i, val := range para {\\n        if unicode.IsLetter(val) {\\n            sb.WriteRune(unicode.ToLower(val))\\n            if i != len(para) - 1 {\\n                continue\\n            }\\n        }\\n    \\n        // Found a word!\\n        w := sb.String()\\n        if w == \"\" {\\n            continue\\n        }\\n        // Reset string builder\\n        sb.Reset()\\n        \\n        // For each word found in para, check of it is present in the banned word, if yes, continue\\n        _, ok := bannedStrings[w]\\n        if ok {\\n            continue\\n        }\\n        \\n        // Add the word, if present update the frequnecy\\n        _, ok = words[w]\\n        if ok {\\n            words[w] += 1\\n        } else {\\n            words[w] = 1\\n        }\\n        \\n        // Update the answer if required\\n         if (words[w] > mostCommonWordFreq) {\\n            mostCommonWordFreq = words[w]\\n            mostCommonWord = w\\n         }\\n        \\n    }\\n    \\n    return mostCommonWord\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc mostCommonWord(para string, banned []string) string {\\n    \\n    // create a map of banned words\\n    bannedStrings := make(map[string]int)\\n    for _, val := range banned {\\n        bannedStrings[val] = 1\\n    }\\n    \\n    mostCommonWord := \"\"\\n    mostCommonWordFreq := 0\\n    \\n    var sb strings.Builder\\n    words := make(map[string]int)\\n    for i, val := range para {\\n        if unicode.IsLetter(val) {\\n            sb.WriteRune(unicode.ToLower(val))\\n            if i != len(para) - 1 {\\n                continue\\n            }\\n        }\\n    \\n        // Found a word!\\n        w := sb.String()\\n        if w == \"\" {\\n            continue\\n        }\\n        // Reset string builder\\n        sb.Reset()\\n        \\n        // For each word found in para, check of it is present in the banned word, if yes, continue\\n        _, ok := bannedStrings[w]\\n        if ok {\\n            continue\\n        }\\n        \\n        // Add the word, if present update the frequnecy\\n        _, ok = words[w]\\n        if ok {\\n            words[w] += 1\\n        } else {\\n            words[w] = 1\\n        }\\n        \\n        // Update the answer if required\\n         if (words[w] > mostCommonWordFreq) {\\n            mostCommonWordFreq = words[w]\\n            mostCommonWord = w\\n         }\\n        \\n    }\\n    \\n    return mostCommonWord\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375849,
                "title": "c-1ms-runtime",
                "content": "string mostCommonWord(string para, vector<string>& banned) {\\n        para.push_back(\\' \\');\\n        string ans = \"\";\\n        int maxVal = 0;\\n        int len = para.length();\\n        unordered_map<string,int> map;\\n        string temp =\"\";\\n        \\n        for(int i=0; i<len; i++)\\n        {    \\n           if(para[i] >= \\'A\\' && para[i] <=\\'Z\\')  \\n           {\\n               temp.push_back(para[i]+32);\\n           }\\n           else if(para[i] >= \\'a\\' && para[i] <= \\'z\\')\\n           {\\n               temp.push_back(para[i]) ;\\n           }\\n           else{\\n                if(temp.empty()) \\n                continue;\\n                map[temp]++;\\n                temp.clear();\\n           }    \\n        }\\n        \\n        for(int i=0;i<size(banned);i++)\\n            map[banned[i]]=0; \\n       \\n        for(auto [key,value] : map)\\n           if(value>=maxVal)\\n            {\\n                maxVal = value;\\n                ans = key;\\n            }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "string mostCommonWord(string para, vector<string>& banned) {\\n        para.push_back(\\' \\');\\n        string ans = \"\";\\n        int maxVal = 0;\\n        int len = para.length();\\n        unordered_map<string,int> map;\\n        string temp =\"\";\\n        \\n        for(int i=0; i<len; i++)\\n        {    \\n           if(para[i] >= \\'A\\' && para[i] <=\\'Z\\')  \\n           {\\n               temp.push_back(para[i]+32);\\n           }\\n           else if(para[i] >= \\'a\\' && para[i] <= \\'z\\')\\n           {\\n               temp.push_back(para[i]) ;\\n           }\\n           else{\\n                if(temp.empty()) \\n                continue;\\n                map[temp]++;\\n                temp.clear();\\n           }    \\n        }\\n        \\n        for(int i=0;i<size(banned);i++)\\n            map[banned[i]]=0; \\n       \\n        for(auto [key,value] : map)\\n           if(value>=maxVal)\\n            {\\n                maxVal = value;\\n                ans = key;\\n            }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1374287,
                "title": "c-4ms-runtime-modified-from-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n        unordered_map<string,int>mp;\\n        int i=0;\\n        while(i<para.size())\\n        {\\n            string strg=\"\";\\n            while(i<para.size() && isalpha(para[i])){\\n                strg.push_back(tolower(para[i]));\\n                i++;\\n            }\\n            \\n            while(i<para.size() && !isalpha(para[i])) {i++;}\\n                mp[strg]+=1;\\n        }\\n                  \\n       for(auto x:ban){mp[x]=0;}\\n       int cnt=0;\\n      string res; \\n    for(auto it:mp){\\n        if(it.second>cnt){\\n            res=it.first;\\n            cnt=it.second;\\n        }\\n    }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n        unordered_map<string,int>mp;\\n        int i=0;\\n        while(i<para.size())\\n        {\\n            string strg=\"\";\\n            while(i<para.size() && isalpha(para[i])){\\n                strg.push_back(tolower(para[i]));\\n                i++;\\n            }\\n            \\n            while(i<para.size() && !isalpha(para[i])) {i++;}\\n                mp[strg]+=1;\\n        }\\n                  \\n       for(auto x:ban){mp[x]=0;}\\n       int cnt=0;\\n      string res; \\n    for(auto it:mp){\\n        if(it.second>cnt){\\n            res=it.first;\\n            cnt=it.second;\\n        }\\n    }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372545,
                "title": "c-solution-nested-stringstream-split-string-using-multiple-delimiters",
                "content": "1. First (outer) stringstream is used for spliting the string at \\' \\' (space).\\n2. Second (inner) stringstream is used for splitting the string at \\',\\'(comma).\\n\\t\\n\\t\\tstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\t\\t\\t//transform every banned string to lower case\\n\\t\\t\\tfor(auto &word: banned){\\n\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t}\\n\\n\\t\\t\\tunordered_set<string> ban(banned.begin(), banned.end());\\n\\t\\t\\t//the outer stringstream\\n\\t\\t\\tstringstream ss(paragraph);\\n\\t\\t\\tstring temp;\\n\\t\\t\\tstring ans;\\n\\t\\t\\t//to keep track of unbanned strings\\n\\t\\t\\tunordered_map<string, int> mp;\\n\\t\\t\\tint maxFreq = 0;\\n\\n\\t\\t\\twhile(getline(ss, temp, \\' \\')){\\n\\n\\t\\t\\t\\tstringstream ss1(temp);\\n\\t\\t\\t\\tstring word;\\n\\n\\t\\t\\t\\t//inner stringstream\\n\\t\\t\\t\\twhile(getline(ss1, word, \\',\\')){\\n\\t\\t\\t\\t\\tint n = word.length();\\n\\n\\t\\t\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint i;\\n\\t\\t\\t\\t\\t//remove the non alphabetical characters from the end of the string(word).\\n\\t\\t\\t\\t\\tfor(i=n-1; i>=0; i--){\\n\\t\\t\\t\\t\\t\\tif(isalpha(word[i])){\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tword = word.substr(0,i+1);\\n\\t\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t\\t\\t//now is the word is not banned then increase its frequency and accordingly update the answer.\\n\\t\\t\\t\\t\\tif(ban.find(word) == ban.end()){\\n\\t\\t\\t\\t\\t\\tmp[word]++;\\n\\n\\t\\t\\t\\t\\t\\tif(mp[word] > maxFreq){\\n\\t\\t\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t\\t\\t\\t\\tmaxFreq = mp[word];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "1. First (outer) stringstream is used for spliting the string at \\' \\' (space).\\n2. Second (inner) stringstream is used for splitting the string at \\',\\'(comma).\\n\\t\\n\\t\\tstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\t\\t\\t//transform every banned string to lower case\\n\\t\\t\\tfor(auto &word: banned){\\n\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t}\\n\\n\\t\\t\\tunordered_set<string> ban(banned.begin(), banned.end());\\n\\t\\t\\t//the outer stringstream\\n\\t\\t\\tstringstream ss(paragraph);\\n\\t\\t\\tstring temp;\\n\\t\\t\\tstring ans;\\n\\t\\t\\t//to keep track of unbanned strings\\n\\t\\t\\tunordered_map<string, int> mp;\\n\\t\\t\\tint maxFreq = 0;\\n\\n\\t\\t\\twhile(getline(ss, temp, \\' \\')){\\n\\n\\t\\t\\t\\tstringstream ss1(temp);\\n\\t\\t\\t\\tstring word;\\n\\n\\t\\t\\t\\t//inner stringstream\\n\\t\\t\\t\\twhile(getline(ss1, word, \\',\\')){\\n\\t\\t\\t\\t\\tint n = word.length();\\n\\n\\t\\t\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint i;\\n\\t\\t\\t\\t\\t//remove the non alphabetical characters from the end of the string(word).\\n\\t\\t\\t\\t\\tfor(i=n-1; i>=0; i--){\\n\\t\\t\\t\\t\\t\\tif(isalpha(word[i])){\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tword = word.substr(0,i+1);\\n\\t\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t\\t\\t//now is the word is not banned then increase its frequency and accordingly update the answer.\\n\\t\\t\\t\\t\\tif(ban.find(word) == ban.end()){\\n\\t\\t\\t\\t\\t\\tmp[word]++;\\n\\n\\t\\t\\t\\t\\t\\tif(mp[word] > maxFreq){\\n\\t\\t\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t\\t\\t\\t\\tmaxFreq = mp[word];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1363990,
                "title": "ugly-but-100-faster-solution-c",
                "content": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int> m;\\n        string tmp = \"\";\\n        vector<string> tmpV;\\n        \\n        int maxfreq = 0;\\n        string mostfreq;\\n\\n        for(int i = 0; i < paragraph.length(); ++i) {\\n            char c = paragraph[i];\\n            \\n            if((c == \\' \\' || c == \\'!\\' || \\n               c == \\';\\' || c == \\',\\' ||\\n               c == \\'.\\' || c == \\'?\\' || (c == \\'\\\\\\'\\' && paragraph[i+1] == \\' \\'))) {\\n                if(tmp.length() > 0) {\\n                    m[tmp]++;\\n                    tmpV.push_back(tmp);\\n                    tmp = \"\";\\n                }\\n            }\\n            \\n            else if(i == paragraph.length() - 1) {\\n                if(tmp.length() > 0) {\\n                    tmp += tolower(c);\\n                    m[tmp]++;\\n                    tmpV.push_back(tmp);\\n                    tmp = \"\";\\n                }\\n            }\\n            \\n            else tmp += tolower(c);\\n        }\\n        \\n        for(string s : banned) {\\n            m.erase(s);\\n        }\\n        \\n        for(string s : tmpV) {\\n            cout << s << \" \";\\n            \\n            if(m[s] > maxfreq) {\\n                maxfreq = m[s];\\n                mostfreq = s;\\n            }\\n        }\\n    \\n        return mostfreq;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int> m;\\n        string tmp = \"\";\\n        vector<string> tmpV;\\n        \\n        int maxfreq = 0;\\n        string mostfreq;\\n\\n        for(int i = 0; i < paragraph.length(); ++i) {\\n            char c = paragraph[i];\\n            \\n            if((c == \\' \\' || c == \\'!\\' || \\n               c == \\';\\' || c == \\',\\' ||\\n               c == \\'.\\' || c == \\'?\\' || (c == \\'\\\\\\'\\' && paragraph[i+1] == \\' \\'))) {\\n                if(tmp.length() > 0) {\\n                    m[tmp]++;\\n                    tmpV.push_back(tmp);\\n                    tmp = \"\";\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1316398,
                "title": "clean-c",
                "content": "```\\nstring mostCommonWord(string para, vector<string>& banned) {\\n        unordered_set<string>set(begin(banned), end(banned));\\n        for (int i = 0; i < para.length(); i++)\\n            para[i] = isalpha(para[i]) ? tolower(para[i]) : \\' \\';\\n        stringstream ss(para);\\n        string str;\\n        unordered_map<string, int>u;\\n        while (ss >> str)\\n            if(!set.count(str))\\n                u[str]++;\\n        int freq = INT_MIN;\\n        for (auto c : u)\\n            if (c.second > freq)\\n                freq = c.second, str = c.first;\\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring mostCommonWord(string para, vector<string>& banned) {\\n        unordered_set<string>set(begin(banned), end(banned));\\n        for (int i = 0; i < para.length(); i++)\\n            para[i] = isalpha(para[i]) ? tolower(para[i]) : \\' \\';\\n        stringstream ss(para);\\n        string str;\\n        unordered_map<string, int>u;\\n        while (ss >> str)\\n            if(!set.count(str))\\n                u[str]++;\\n        int freq = INT_MIN;\\n        for (auto c : u)\\n            if (c.second > freq)\\n                freq = c.second, str = c.first;\\n        return str;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304732,
                "title": "c-easy-understandable",
                "content": "\\t//First add the string into hashmap and then remove those string which is banned and then find the maximum frequency string from map and then return\\n\\tclass Solution {\\n\\tpublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(),paragraph.end(),paragraph.begin(),::tolower);\\n        unordered_map<string,int> freq;\\n        int l=INT_MIN;char ch=39;\\n        string str=\"\";\\n        for(int i=0;i<paragraph.size();i++)\\n        {\\n            if(paragraph[i]==\\' \\' || paragraph[i]==\\'.\\' || paragraph[i]==\\'!\\' || paragraph[i]==\\'?\\' || paragraph[i]==\\';\\' || paragraph[i]==\\',\\' || paragraph[i]==ch)\\n            {       \\n                if(str==\"\")continue;\\n                    if(freq.find(str)==freq.end())\\n                        freq[str]=1;\\n                    else\\n                        freq[str]++;\\n                str=\"\";\\n            }else\\n            str+=paragraph[i];\\n        }\\n        unordered_map<string,int>:: iterator it;\\n        for(int i=0;i<banned.size();i++){\\n            if(freq.find(banned[i])!=freq.end()){\\n             it=freq.find(banned[i]);\\n            freq.erase(it);\\n            }\\n        }\\n        it=freq.begin();\\n            while(it!=freq.end())\\n            {\\n                  if(it->second > l){\\n                      l=it->second;\\n                      str=it->first;\\n                  }\\n                 it++;\\n            }   \\n        return str;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(),paragraph.end(),paragraph.begin(),::tolower);\\n        unordered_map<string,int> freq;\\n        int l=INT_MIN;char ch=39;\\n        string str=\"\";\\n        for(int i=0;i<paragraph.size();i++)\\n        {\\n            if(paragraph[i]==\\' \\' || paragraph[i]==\\'.\\' || paragraph[i]==\\'!\\' || paragraph[i]==\\'?\\' || paragraph[i]==\\';\\' || paragraph[i]==\\',\\' || paragraph[i]==ch)\\n            {       \\n                if(str==\"\")continue;\\n                    if(freq.find(str)==freq.end())\\n                        freq[str]=1;\\n                    else\\n                        freq[str]++;\\n                str=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1301804,
                "title": "c-naive-approach-coicise-approach-with-comments",
                "content": "```\\n//Approach-1 : Naive approach\\nclass Solution {\\npublic:\\n    void skipSpace(string &paragraph, int& j, int& n) {\\n        while(paragraph[j] == \\' \\')\\n                j++;\\n    }\\n    \\n    void moveIndexTillValid(string &paragraph, int& j, int& n, string &temp) {\\n        while(j < n && (paragraph[j] >= \\'a\\' && paragraph[j] <= \\'z\\')) {\\n            temp.push_back(paragraph[j]);\\n            j++;\\n        }\\n    }\\n    \\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(begin(paragraph), end(paragraph), begin(paragraph), ::tolower);\\n        \\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        unordered_map<string, int> mp;\\n        \\n        int n = paragraph.length();\\n        int j;\\n        string temp = \"\";\\n        for(int i = 0; i<n;) {\\n            temp = \"\";\\n            j = i;\\n            \\n            skipSpace(paragraph, j, n);\\n            moveIndexTillValid(paragraph, j, n, temp);\\n            \\n            mp[temp]++;\\n            i = j+1;\\n        }\\n        \\n        string result = \"\";\\n        int maxFreq = 0;\\n        for(auto &it : mp) {\\n            if(st.find(it.first) != st.end()) //skip banned words\\n                continue;\\n            \\n            if(it.second > maxFreq) {\\n                result = it.first;\\n                maxFreq = it.second;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-2 : Consice approach. (Inspired from @lee215)\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        for(char &ch : paragraph) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        unordered_map<string, int> mp;\\n        \\n        pair<string, int> result = {\"\", 0};\\n        \\n        istringstream ss(paragraph); //or use, \"stringstream\"\\n        string word;\\n        while(ss >> word) {\\n            if(st.find(word) == end(st)) {\\n                mp[word]++;\\n                if(mp[word] > result.second)\\n                    result = {word, mp[word]};\\n            }\\n        }\\n        \\n        return result.first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 : Naive approach\\nclass Solution {\\npublic:\\n    void skipSpace(string &paragraph, int& j, int& n) {\\n        while(paragraph[j] == \\' \\')\\n                j++;\\n    }\\n    \\n    void moveIndexTillValid(string &paragraph, int& j, int& n, string &temp) {\\n        while(j < n && (paragraph[j] >= \\'a\\' && paragraph[j] <= \\'z\\')) {\\n            temp.push_back(paragraph[j]);\\n            j++;\\n        }\\n    }\\n    \\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(begin(paragraph), end(paragraph), begin(paragraph), ::tolower);\\n        \\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        unordered_map<string, int> mp;\\n        \\n        int n = paragraph.length();\\n        int j;\\n        string temp = \"\";\\n        for(int i = 0; i<n;) {\\n            temp = \"\";\\n            j = i;\\n            \\n            skipSpace(paragraph, j, n);\\n            moveIndexTillValid(paragraph, j, n, temp);\\n            \\n            mp[temp]++;\\n            i = j+1;\\n        }\\n        \\n        string result = \"\";\\n        int maxFreq = 0;\\n        for(auto &it : mp) {\\n            if(st.find(it.first) != st.end()) //skip banned words\\n                continue;\\n            \\n            if(it.second > maxFreq) {\\n                result = it.first;\\n                maxFreq = it.second;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 : Consice approach. (Inspired from @lee215)\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        for(char &ch : paragraph) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        unordered_map<string, int> mp;\\n        \\n        pair<string, int> result = {\"\", 0};\\n        \\n        istringstream ss(paragraph); //or use, \"stringstream\"\\n        string word;\\n        while(ss >> word) {\\n            if(st.find(word) == end(st)) {\\n                mp[word]++;\\n                if(mp[word] > result.second)\\n                    result = {word, mp[word]};\\n            }\\n        }\\n        \\n        return result.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298297,
                "title": "golang-solution-faster-than-100",
                "content": "``` go\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    m := make(map[string] int)\\n    m2 := make(map[string] int)\\n    s := \"\"\\n    max := 0\\n    res := \"\"\\n    \\n    for _, ban := range banned {\\n        m[ban] = 1\\n    }\\n    \\n    for _, i := range paragraph {\\n        if i == \\' \\' || i == \\',\\' || i == \\'!\\' || i == \\'?\\' || i == \\'\\\\\\'\\' || i == \\';\\' || i == \\'.\\' {\\n            m2[s]++\\n            s = \"\"\\n        } else {\\n            s += strings.ToLower(string(i))\\n        }\\n    }\\n    m2[s]++\\n    \\n    for a, b := range m2 {\\n        if b > max && m[a] == 0 && a != \"\" {\\n            max = b\\n            res = a\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    m := make(map[string] int)\\n    m2 := make(map[string] int)\\n    s := \"\"\\n    max := 0\\n    res := \"\"\\n    \\n    for _, ban := range banned {\\n        m[ban] = 1\\n    }\\n    \\n    for _, i := range paragraph {\\n        if i == \\' \\' || i == \\',\\' || i == \\'!\\' || i == \\'?\\' || i == \\'\\\\\\'\\' || i == \\';\\' || i == \\'.\\' {\\n            m2[s]++\\n            s = \"\"\\n        } else {\\n            s += strings.ToLower(string(i))\\n        }\\n    }\\n    m2[s]++\\n    \\n    for a, b := range m2 {\\n        if b > max && m[a] == 0 && a != \"\" {\\n            max = b\\n            res = a\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261831,
                "title": "easiest-java-solution-using-list-and-hashmap-with-steps",
                "content": "***Steps***\\n1. Convert paragraph to lowercase and string array.\\n2. Add elements that are not present in banned to hashmap.\\n3. If already present hashmap, increment value by 1.\\n4. Find max value in hashmap and return the key associated with max value.\\n\\n```\\nimport java.util.HashMap;\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n         String[] words = paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\" \");\\n        int temp=0;\\n        int max=0;\\n        \\n        String ans = null;\\n        List<String> ls = Arrays.asList(banned);\\n        System.out.println(ls);\\n        HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n           if(!ls.contains(words[i]) && hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],hm.get(words[i])+1);\\n                }\\n            else if(!ls.contains(words[i]) && !hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],1);\\n                }\\n                else\\n                    continue;\\n        }\\n        String res = null;\\n        for(String word : hm.keySet())\\n            if(res == null || hm.get(word) > hm.get(res))\\n                res = word;\\n        System.out.println(hm.get(res));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nimport java.util.HashMap;\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n         String[] words = paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\" \");\\n        int temp=0;\\n        int max=0;\\n        \\n        String ans = null;\\n        List<String> ls = Arrays.asList(banned);\\n        System.out.println(ls);\\n        HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n           if(!ls.contains(words[i]) && hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],hm.get(words[i])+1);\\n                }\\n            else if(!ls.contains(words[i]) && !hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],1);\\n                }\\n                else\\n                    continue;\\n        }\\n        String res = null;\\n        for(String word : hm.keySet())\\n            if(res == null || hm.get(word) > hm.get(res))\\n                res = word;\\n        System.out.println(hm.get(res));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259678,
                "title": "c-approach-with-proper-comments",
                "content": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string s, vector<string>& banned) {\\n    // To convert the paragraph into the lower case letters \\n    // if the current char is an alphabet then convert it into lowercase else it is an space then add space to it \\n\\t\\n        for(auto& it:s){\\n            if(isalpha(it))\\n                it=tolower(it);\\n            else\\n                it=\\' \\';\\n        }\\n        \\n        // Extract words from paragraph and store make a freq map of words\\n        \\n        stringstream ss(s);\\n        string word;\\n        unordered_map<string,int> mp;\\n      while(ss>>word){\\n          mp[word]++;\\n      }\\n        \\n    // make the freq of the banned words to 0 so that they can not be our output\\n\\n        for(auto ban:banned){\\n            mp[ban]=0;\\n        }\\n        int cnt=0;\\n        string res=\"\";\\n\\t\\t// Find the largest freq word and return the result\\n\\t\\t\\tfor(auto it:mp){\\n            if(it.second>cnt){\\n                cnt=it.second;\\n                res=it.first;\\n            }\\n        }\\n    \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string s, vector<string>& banned) {\\n    // To convert the paragraph into the lower case letters \\n    // if the current char is an alphabet then convert it into lowercase else it is an space then add space to it \\n\\t\\n        for(auto& it:s){\\n            if(isalpha(it))\\n                it=tolower(it);\\n            else\\n                it=\\' \\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240763,
                "title": "java-easy-solution",
                "content": "Approach is : \\n\\n1) Break down paragraph into words. Handled by trim, removal of fullstop,commas etc.\\n2) Store these words in a hashmap with their frequencies.\\n3) Store the banned words in a hashset for quick access.\\n4) Finally check for the words with maximum frequency in the hashmap, and which is not present in our hashset.\\n\\n```\\nclass Solution {\\n     public String mostCommonWord(String par, String[] banned) {\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        par = par.trim().toLowerCase();\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : banned)\\n            set.add(s);\\n\\n        int str= 0;\\n        for(int i =0; i< par.length();i++){\\n            if(!Character.isAlphabetic(par.charAt(i))){\\n                String word = par.substring(str, i);\\n                str = i+1;\\n                map.put(word, map.getOrDefault(word,0) + 1);\\n            }else if(par.length() - 1 == i)\\n                map.put(par.substring(str, i+1), map.getOrDefault(par.substring(str, i+1),0) + 1);\\n        }\\n        map.remove(\"\");\\n        int max = -1;\\n        String res = \"\";\\n        for(Map.Entry<String, Integer> mp : map.entrySet()){\\n            if(mp.getValue() > max && !set.contains(mp.getKey())){\\n                max =mp.getValue();\\n                res = mp.getKey();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public String mostCommonWord(String par, String[] banned) {\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        par = par.trim().toLowerCase();\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : banned)\\n            set.add(s);\\n\\n        int str= 0;\\n        for(int i =0; i< par.length();i++){\\n            if(!Character.isAlphabetic(par.charAt(i))){\\n                String word = par.substring(str, i);\\n                str = i+1;\\n                map.put(word, map.getOrDefault(word,0) + 1);\\n            }else if(par.length() - 1 == i)\\n                map.put(par.substring(str, i+1), map.getOrDefault(par.substring(str, i+1),0) + 1);\\n        }\\n        map.remove(\"\");\\n        int max = -1;\\n        String res = \"\";\\n        for(Map.Entry<String, Integer> mp : map.entrySet()){\\n            if(mp.getValue() > max && !set.contains(mp.getKey())){\\n                max =mp.getValue();\\n                res = mp.getKey();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239774,
                "title": "python3-simple-solution-using-dictionary",
                "content": "**Can be solved by both regrex or replace function**\\n```\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = {}\\n        paragraph = re.split(\" |,|!|\\'|;|\\\\?|\\\\.\", paragraph)\\n        # paragraph = paragraph.replace(\\',\\',\\' \\').replace(\\';\\',\\' \\').replace(\\'!\\',\\' \\').replace(\\'?\\',\\' \\').replace(\"\\'\",\\' \\').replace(\\'.\\',\\' \\').split(\\' \\')\\n        for i in paragraph:\\n            x = i.lower()\\n            if x not in banned and len(x) > 0:\\n                d[x] = d.get(x,0) + 1\\n        return [i for i,j in sorted(d.items(), key= lambda x:x[1], reverse=True)][0]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = {}\\n        paragraph = re.split(\" |,|!|\\'|;|\\\\?|\\\\.\", paragraph)\\n        # paragraph = paragraph.replace(\\',\\',\\' \\').replace(\\';\\',\\' \\').replace(\\'!\\',\\' \\').replace(\\'?\\',\\' \\').replace(\"\\'\",\\' \\').replace(\\'.\\',\\' \\').split(\\' \\')\\n        for i in paragraph:\\n            x = i.lower()\\n            if x not in banned and len(x) > 0:\\n                d[x] = d.get(x,0) + 1\\n        return [i for i,j in sorted(d.items(), key= lambda x:x[1], reverse=True)][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218066,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) \\n    {\\n        for(auto &it:s)\\n        {\\n            if(isalpha(it))\\n            {\\n                it=tolower(it);\\n            }\\n            else\\n            {\\n                it=\\' \\';\\n            }\\n        }\\n        istringstream ss(s);\\n        string ans;\\n        unordered_map<string,int>mp;\\n        while(ss>>ans)\\n        {\\n            mp[ans]++;\\n        }\\n        for(auto it:banned)\\n        {\\n            mp[it]=0;\\n        }\\n        string str=\"\";\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second>count)\\n            {\\n                count=it.second;\\n                str=it.first;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) \\n    {\\n        for(auto &it:s)\\n        {\\n            if(isalpha(it))\\n            {\\n                it=tolower(it);\\n            }\\n            else\\n            {\\n                it=\\' \\';\\n            }\\n        }\\n        istringstream ss(s);\\n        string ans;\\n        unordered_map<string,int>mp;\\n        while(ss>>ans)\\n        {\\n            mp[ans]++;\\n        }\\n        for(auto it:banned)\\n        {\\n            mp[it]=0;\\n        }\\n        string str=\"\";\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second>count)\\n            {\\n                count=it.second;\\n                str=it.first;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213270,
                "title": "java-hashmap-beats-75-easy-to-understand",
                "content": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        paragraph = paragraph.toLowerCase();\\n        String[] words = paragraph.split(\"\\\\\\\\W+\");\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (String b: banned) {\\n            b = b.toLowerCase();\\n            map.put(b, Integer.MIN_VALUE);\\n        }\\n                    \\n        int max = 0;\\n        String maxWord = null;\\n                    \\n        for (String word: words) {\\n                \\n                if (!map.containsKey(word)) {\\n                    map.put(word, 1);\\n                    if ( 1 > max) {\\n                        max = 1;\\n                        maxWord = word;\\n                    }\\n                    \\n                } \\n                else {\\n                    int x = map.get(word) + 1;\\n                    map.put(word, x);\\n                    if (x > max) {\\n                        max = x;\\n                        maxWord = word;\\n                    }\\n                }\\n            }      \\n                    \\n        return maxWord;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        paragraph = paragraph.toLowerCase();\\n        String[] words = paragraph.split(\"\\\\\\\\W+\");\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (String b: banned) {\\n            b = b.toLowerCase();\\n            map.put(b, Integer.MIN_VALUE);\\n        }\\n                    \\n        int max = 0;\\n        String maxWord = null;\\n                    \\n        for (String word: words) {\\n                \\n                if (!map.containsKey(word)) {\\n                    map.put(word, 1);\\n                    if ( 1 > max) {\\n                        max = 1;\\n                        maxWord = word;\\n                    }\\n                    \\n                } \\n                else {\\n                    int x = map.get(word) + 1;\\n                    map.put(word, x);\\n                    if (x > max) {\\n                        max = x;\\n                        maxWord = word;\\n                    }\\n                }\\n            }      \\n                    \\n        return maxWord;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160351,
                "title": "c-819-most-common-word",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        for (auto& c : paragraph) \\n            c = isalpha(c) ? tolower(c) : \\' \\'; \\n        \\n        unordered_map<string, int> freq; \\n        unordered_set<string> ss(banned.begin(), banned.end()); \\n        \\n        int cnt = 0; \\n        istringstream iss(paragraph); \\n        string ans, word; \\n        while (iss >> word) {\\n            if (ss.find(word) == ss.end()) {\\n                ++freq[word]; \\n                if (cnt < freq[word]) {\\n                    ans = word; \\n                    cnt = freq[word]; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        for (auto& c : paragraph) \\n            c = isalpha(c) ? tolower(c) : \\' \\'; \\n        \\n        unordered_map<string, int> freq; \\n        unordered_set<string> ss(banned.begin(), banned.end()); \\n        \\n        int cnt = 0; \\n        istringstream iss(paragraph); \\n        string ans, word; \\n        while (iss >> word) {\\n            if (ss.find(word) == ss.end()) {\\n                ++freq[word]; \\n                if (cnt < freq[word]) {\\n                    ans = word; \\n                    cnt = freq[word]; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145285,
                "title": "kotlin",
                "content": "```\\nfun mostCommonWord(s: String, ar: Array<String>) = mutableMapOf<String, Int>().apply {\\n    s.toLowerCase().replace(Regex(\"[^a-z ]\"), \" \").split(\" \")\\n        .filter { !ar.contains(it) && it.isNotBlank() }\\n        .forEach { this[it] = getOrDefault(it, 0) + 1 }\\n}.maxBy { it.value }?.key!!\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun mostCommonWord(s: String, ar: Array<String>) = mutableMapOf<String, Int>().apply {\\n    s.toLowerCase().replace(Regex(\"[^a-z ]\"), \" \").split(\" \")\\n        .filter { !ar.contains(it) && it.isNotBlank() }\\n        .forEach { this[it] = getOrDefault(it, 0) + 1 }\\n}.maxBy { it.value }?.key!!\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564720,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1565080,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1835886,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572147,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1735887,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1738898,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572152,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 2068525,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1831550,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1576408,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1564720,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1565080,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1835886,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572147,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1735887,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1738898,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572152,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 2068525,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1831550,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1576408,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Balloons",
        "question_content": "<p>Given a string <code>text</code>, you want to use the characters of <code>text</code> to form as many instances of the word <strong>&quot;balloon&quot;</strong> as possible.</p>\n\n<p>You can use each character in <code>text</code> <strong>at most once</strong>. Return the maximum number of instances that can be formed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/05/1536_ex1_upd.JPG\" style=\"width: 132px; height: 35px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;nlaebolko&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/05/1536_ex2_upd.JPG\" style=\"width: 267px; height: 35px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;loonbalxballpoon&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;leetcode&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>text</code> consists of lower case English letters only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 382401,
                "title": "withcomments-straightforward-java-simple-count-of-chars",
                "content": "```\\npublic int maxNumberOfBalloons(String text) {\\n        int[] chars = new int[26]; //count all letters\\n        for (char c : text.toCharArray()) {\\n            chars[c - \\'a\\']++;\\n        }\\n        int min = chars[1];//for b\\n        min = Math.min(min, chars[0]);//for a\\n        min = Math.min(min, chars[11] / 2);// for l /2 \\n        min = Math.min(min, chars[14] / 2);//similarly for o/2\\n        min = Math.min(min, chars[13]);//for n\\n        return min;        \\n    }\\n```\\nCoundn\\'t think of maps or any other DS :(\\nBut My space complexity is O(1) :P\\nHope you will understand :)\\n",
                "solutionTags": [],
                "code": "```\\npublic int maxNumberOfBalloons(String text) {\\n        int[] chars = new int[26]; //count all letters\\n        for (char c : text.toCharArray()) {\\n            chars[c - \\'a\\']++;\\n        }\\n        int min = chars[1];//for b\\n        min = Math.min(min, chars[0]);//for a\\n        min = Math.min(min, chars[11] / 2);// for l /2 \\n        min = Math.min(min, chars[14] / 2);//similarly for o/2\\n        min = Math.min(min, chars[13]);//for n\\n        return min;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382396,
                "title": "java-python-3-count-solution-w-analysis",
                "content": "Count chars of both `text` and `balloon` and find the minimum of the times of the count of chars of `text / balloon`.\\n\\n```\\n    public int maxNumberOfBalloons(String text) {\\n        int[] cnt = new int[26], cntBaloon = new int[26];\\n        for (int i = 0; i < text.length(); ++i)\\n            ++cnt[text.charAt(i) - \\'a\\'];\\n        int min = text.length();\\n        for (char c : \"balloon\".toCharArray())\\n            ++cntBaloon[c - \\'a\\'];\\n        for (char c : \"balloon\".toCharArray())\\n            min = Math.min(min, cnt[c - \\'a\\'] / cntBaloon[c - \\'a\\']);\\n        return min;\\n    }\\n```\\n```\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cnt = collections.Counter(text)\\n        cntBalloon = collections.Counter(\\'balloon\\')\\n        return min([cnt[c] // cntBalloon[c] for c in cntBalloon])\\n```\\n**Analysis:**\\n\\nTime: O(text.length()), space: O(1).",
                "solutionTags": [],
                "code": "```\\n    public int maxNumberOfBalloons(String text) {\\n        int[] cnt = new int[26], cntBaloon = new int[26];\\n        for (int i = 0; i < text.length(); ++i)\\n            ++cnt[text.charAt(i) - \\'a\\'];\\n        int min = text.length();\\n        for (char c : \"balloon\".toCharArray())\\n            ++cntBaloon[c - \\'a\\'];\\n        for (char c : \"balloon\".toCharArray())\\n            min = Math.min(min, cnt[c - \\'a\\'] / cntBaloon[c - \\'a\\']);\\n        return min;\\n    }\\n```\n```\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cnt = collections.Counter(text)\\n        cntBalloon = collections.Counter(\\'balloon\\')\\n        return min([cnt[c] // cntBalloon[c] for c in cntBalloon])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395059,
                "title": "c-3-line-solution-using-unordered-map-4ms-9mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mm;\\n        for (char i : text) mm[i] += 1;\\n        return min(mm[\\'b\\'], min(mm[\\'a\\'], min(mm[\\'l\\']/2, min(mm[\\'o\\']/2, mm[\\'n\\']))));\\n    }\\n};\\n```\\n\\n---\\n# **Suggestions listed below**\\n---\\n\\nSuggestion made by [muhammetzahitaydin](https://leetcode.com/muhammetzahitaydin/): you can use one min for return:\\n```\\nreturn min ( { mm[\\'b\\'] , mm[\\'a\\'] , mm[\\'l\\']/2 , mm[\\'o\\']/2 ,mm[\\'n\\'] } ) ;\\n```\\n\\nSuggestion made by [Body_sweep69](https://leetcode.com/body_sweep69/) to use array of size 256 instead of unordered map to reduce memory usage. [BSalwiczek](https://leetcode.com/bsalwiczek/) suggested using array of size 5 since we only care about 5 chars (b, a, l, o, n).\\n\\n---\\n\\n*suggestions added on June 29th 2020",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mm;\\n        for (char i : text) mm[i] += 1;\\n        return min(mm[\\'b\\'], min(mm[\\'a\\'], min(mm[\\'l\\']/2, min(mm[\\'o\\']/2, mm[\\'n\\']))));\\n    }\\n};\\n```\n```\\nreturn min ( { mm[\\'b\\'] , mm[\\'a\\'] , mm[\\'l\\']/2 , mm[\\'o\\']/2 ,mm[\\'n\\'] } ) ;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455926,
                "title": "python-easy-to-understand-solution-o-n-time-and-o-1-space",
                "content": "Intuitive Python Solution with O(n) time and O(1) space.\\n\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter = {\"b\":0, \"a\":0, \"l\":0, \"o\":0, \"n\":0}\\n        for char in text:\\n            if char in counter:\\n                counter[char] += 1\\n        counter[\"l\"] //= 2\\n        counter[\"o\"] //= 2\\n        return min(counter.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter = {\"b\":0, \"a\":0, \"l\":0, \"o\":0, \"n\":0}\\n        for char in text:\\n            if char in counter:\\n                counter[char] += 1\\n        counter[\"l\"] //= 2\\n        counter[\"o\"] //= 2\\n        return min(counter.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382940,
                "title": "java-count-ballon-char-and-select-min-of-them",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        \\n        for(char ch : text.toCharArray()){\\n            switch(ch){\\n                case \\'b\\': ++b;\\n                        break;\\n                case \\'a\\': ++a;\\n                        break;\\n                case \\'l\\': ++l;\\n                        break;\\n                case \\'o\\': ++o;\\n                        break;\\n                case \\'n\\': ++n;\\n                        break;\\n            \\n            }\\n        }\\n        \\n        return Math.min(Math.min(o/2, l/2), Math.min(Math.min(b, a), n));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        \\n        for(char ch : text.toCharArray()){\\n            switch(ch){\\n                case \\'b\\': ++b;\\n                        break;\\n                case \\'a\\': ++a;\\n                        break;\\n                case \\'l\\': ++l;\\n                        break;\\n                case \\'o\\': ++o;\\n                        break;\\n                case \\'n\\': ++n;\\n                        break;\\n            \\n            }\\n        }\\n        \\n        return Math.min(Math.min(o/2, l/2), Math.min(Math.min(b, a), n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948621,
                "title": "simple-solution-js",
                "content": "```\\nvar maxNumberOfBalloons = function(text) {\\n    const map = { b: 0, a: 0, l: 0, o: 0, n: 0, };\\n    \\n    for (const l of text) {\\n        map[l]++; \\n    }\\n    \\n    return Math.floor(\\n        Math.min(map.b, map.a, map.l / 2, map.o / 2, map.n)\\n    );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxNumberOfBalloons = function(text) {\\n    const map = { b: 0, a: 0, l: 0, o: 0, n: 0, };\\n    \\n    for (const l of text) {\\n        map[l]++; \\n    }\\n    \\n    return Math.floor(\\n        Math.min(map.b, map.a, map.l / 2, map.o / 2, map.n)\\n    );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460763,
                "title": "python-short-counter-solution-explained",
                "content": "All you need to do in this problem is to count number of each symbols, specifically `a`, `b`, `l`, `n`, `o`. Then we need to find letter with minimum frequency, but also taking into account that we need two `l` and two `o`.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(26)` to keep counter.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxNumberOfBalloons(self, text):\\n        cnt = Counter(text)\\n        return min(cnt[\"b\"], cnt[\"a\"], cnt[\"l\"]//2, cnt[\"o\"]//2, cnt[\"n\"])\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, **please upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxNumberOfBalloons(self, text):\\n        cnt = Counter(text)\\n        return min(cnt[\"b\"], cnt[\"a\"], cnt[\"l\"]//2, cnt[\"o\"]//2, cnt[\"n\"])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572807,
                "title": "runtime-100-memory-usage-100-one-line-python3",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'), text.count(\\'l\\') // 2, text.count(\\'o\\') // 2, text.count(\\'n\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'), text.count(\\'l\\') // 2, text.count(\\'o\\') // 2, text.count(\\'n\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382763,
                "title": "python3-1-liner",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n        return min(t.count(\\'b\\'), t.count(\\'a\\'), t.count(\\'l\\') // 2, t.count(\\'o\\') // 2, t.count(\\'n\\'))\\n```\\n* For fun\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n        return min(t.count(c) // int(cnt) for c, cnt in zip(\\'balon\\', \\'11221\\'))\\n```\\n@lee215\\'s\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n          return min(t.count(c) // \\'balloon\\'.count(c) for c in \\'balon\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n        return min(t.count(\\'b\\'), t.count(\\'a\\'), t.count(\\'l\\') // 2, t.count(\\'o\\') // 2, t.count(\\'n\\'))\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n        return min(t.count(c) // int(cnt) for c, cnt in zip(\\'balon\\', \\'11221\\'))\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, t: str) -> int:\\n          return min(t.count(c) // \\'balloon\\'.count(c) for c in \\'balon\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495650,
                "title": "very-simple-c-faster-then-99-99-o-1-space-with-explanation",
                "content": "```\\nIdea is to count characters using 5 variables. As in the \"balloon\"  char \\'l\\' and \\'o\\'\\noccours 2 times so at the end we will divide the total occourence of \\'l\\' and \\'o\\' with 2.\\n```\\n```\\nint maxNumberOfBalloons(string text) {\\n        \\n        int b=0, a=0, l2=0, o2=0, n=0;\\n            \\n        for(int i=0;i<text.size();i++){\\n            \\n            if(text[i]==\\'b\\') b++;\\n            else if(text[i]==\\'a\\') a++;\\n            else if(text[i]==\\'l\\') l2++;\\n            else if(text[i]==\\'o\\') o2++;\\n            else if(text[i]==\\'n\\') n++;\\n        }\\n        l2=l2/2;  o2=o2/2;  //both occours 2 times in the balloon\\n        int ans=min({b, a, l2, o2, n}); // min occourence of the char would be the solution\\n        return ans;\\n    }\\n```\\n\\n\\uD83D\\uDE42 ***why you guys always forget to upvote, it motivates me to make such post.***",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nIdea is to count characters using 5 variables. As in the \"balloon\"  char \\'l\\' and \\'o\\'\\noccours 2 times so at the end we will divide the total occourence of \\'l\\' and \\'o\\' with 2.\\n```\n```\\nint maxNumberOfBalloons(string text) {\\n        \\n        int b=0, a=0, l2=0, o2=0, n=0;\\n            \\n        for(int i=0;i<text.size();i++){\\n            \\n            if(text[i]==\\'b\\') b++;\\n            else if(text[i]==\\'a\\') a++;\\n            else if(text[i]==\\'l\\') l2++;\\n            else if(text[i]==\\'o\\') o2++;\\n            else if(text[i]==\\'n\\') n++;\\n        }\\n        l2=l2/2;  o2=o2/2;  //both occours 2 times in the balloon\\n        int ans=min({b, a, l2, o2, n}); // min occourence of the char would be the solution\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786786,
                "title": "3-approaches-easy-short-o-n-time",
                "content": "**Hope it helps. If you find it helpful, do UPVOTE. Comments are welcomed. Happy Coding!**\\n\\n**1. Using 5 variables (Best Approach)**\\n```\\nint maxNumberOfBalloons(string text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0;\\n        for (auto ch : text) {\\n            b += (ch == \\'b\\');\\n            a += (ch == \\'a\\');\\n            l += (ch == \\'l\\');\\n            o += (ch == \\'o\\');\\n            n += (ch == \\'n\\');\\n        }\\n        return min({b, a, l/2, o/2, n});\\n    }\\n```\\n\\n**2. Using Switch**\\n```\\nint maxNumberOfBalloons(string text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0;\\n        for (auto ch : text) {\\n            switch (ch) {\\n                case \\'b\\' : b++; break;\\n                case \\'a\\' : a++; break;\\n                case \\'l\\' : l++; break;\\n                case \\'o\\' : o++; break;\\n                case \\'n\\' : n++; break;\\n            }\\n        }\\n        return min({b, a, l/2, o/2, n});\\n    }\\n```\\n\\n**3. Using unordered_map :**\\n```\\nint maxNumberOfBalloons(string text) {\\n        string str = \"balloon\";\\n        unordered_map<char, int> str_freq, txt_freq;\\n        for (auto s : str) // Storing occurence of each letter of str in str_freq \\n            str_freq[s]++;\\n        for (auto s : text)  // Storing occurence of each letter of text in txt_freq \\n            txt_freq[s]++;\\n        int prev = txt_freq[\\'b\\']/str_freq[\\'b\\']; // no. of b in txt_freq / no. of b in str_freq\\n        for (auto e : str_freq) {\\n            int curr = txt_freq[e.first]/e.second; // finding no. of each letter in txt_freq / no. of that in str_freq \\n            prev = min(prev, curr); // minimum of the prev and current \\n        }\\n        return prev;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0;\\n        for (auto ch : text) {\\n            b += (ch == \\'b\\');\\n            a += (ch == \\'a\\');\\n            l += (ch == \\'l\\');\\n            o += (ch == \\'o\\');\\n            n += (ch == \\'n\\');\\n        }\\n        return min({b, a, l/2, o/2, n});\\n    }\\n```\n```\\nint maxNumberOfBalloons(string text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0;\\n        for (auto ch : text) {\\n            switch (ch) {\\n                case \\'b\\' : b++; break;\\n                case \\'a\\' : a++; break;\\n                case \\'l\\' : l++; break;\\n                case \\'o\\' : o++; break;\\n                case \\'n\\' : n++; break;\\n            }\\n        }\\n        return min({b, a, l/2, o/2, n});\\n    }\\n```\n```\\nint maxNumberOfBalloons(string text) {\\n        string str = \"balloon\";\\n        unordered_map<char, int> str_freq, txt_freq;\\n        for (auto s : str) // Storing occurence of each letter of str in str_freq \\n            str_freq[s]++;\\n        for (auto s : text)  // Storing occurence of each letter of text in txt_freq \\n            txt_freq[s]++;\\n        int prev = txt_freq[\\'b\\']/str_freq[\\'b\\']; // no. of b in txt_freq / no. of b in str_freq\\n        for (auto e : str_freq) {\\n            int curr = txt_freq[e.first]/e.second; // finding no. of each letter in txt_freq / no. of that in str_freq \\n            prev = min(prev, curr); // minimum of the prev and current \\n        }\\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382608,
                "title": "minimal-javascript-solution-with-object",
                "content": "```\\nconst maxNumberOfBalloons = text => {\\n  let obj = {}, balloonCount = 0;\\n  for (let el of text) {\\n    obj[el] = (obj[el] || 0) + 1;\\n  }\\n  while (obj[\\'a\\'] > 0 && obj[\\'b\\'] >0 && obj[\\'l\\']>1 && obj[\\'n\\']>0 && obj[\\'o\\']>1) {\\n    balloonCount++;\\n    obj[\\'a\\']--;\\n    obj[\\'b\\']--;\\n    obj[\\'l\\'] -= 2;\\n    obj[\\'n\\']--;\\n    obj[\\'o\\'] -= 2;\\n  }\\n  return balloonCount;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxNumberOfBalloons = text => {\\n  let obj = {}, balloonCount = 0;\\n  for (let el of text) {\\n    obj[el] = (obj[el] || 0) + 1;\\n  }\\n  while (obj[\\'a\\'] > 0 && obj[\\'b\\'] >0 && obj[\\'l\\']>1 && obj[\\'n\\']>0 && obj[\\'o\\']>1) {\\n    balloonCount++;\\n    obj[\\'a\\']--;\\n    obj[\\'b\\']--;\\n    obj[\\'l\\'] -= 2;\\n    obj[\\'n\\']--;\\n    obj[\\'o\\'] -= 2;\\n  }\\n  return balloonCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674737,
                "title": "java-solution-faster-than-74-71",
                "content": "class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n\\t\\n        int a = 0, b = 0, l = 0, o = 0, n = 0, i = 0;\\n\\n        for (char c: text.toCharArray()){\\n            switch (c){\\n                case \\'a\\' -> a++;\\n                case \\'b\\' -> b++;\\n                case \\'l\\' -> l++;\\n                case \\'n\\' -> n++;\\n                case \\'o\\' -> o++;\\n            }\\n            if (a >= 1 && b >= 1 && n >= 1 && l >= 2 && o >= 2){\\n                i++;\\n                a -= 1; b -= 1; n -= 1; l -= 2; o -= 2;\\n            }\\n        }\\n        \\n        return i;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n\\t\\n        int a = 0, b = 0, l = 0, o = 0, n = 0, i = 0;\\n\\n        for (char c: text.toCharArray()){\\n            switch (c){\\n                case \\'a\\' -> a++;\\n                case \\'b\\' -> b++;\\n                case \\'l\\' -> l++;\\n                case \\'n\\' -> n++;\\n                case \\'o\\' -> o++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 397260,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) \\n    {   \\n        char [] chars = text.toCharArray();\\n        double [] result = new double[5];\\n\\n        for(int i = 0; i < chars.length; i++)\\n        {\\n            if(chars[i] == \\'b\\')\\n            {\\n                result[0] += 1;\\n            }\\n            else if(chars[i] == \\'a\\')\\n            {\\n                result[1] += 1;\\n            }\\n            else if(chars[i] == \\'l\\')\\n            {\\n                result[2] += .5;\\n            }\\n            else if(chars[i] == \\'o\\')\\n            {\\n                result[3] += .5;\\n            }\\n            else if(chars[i] == \\'n\\')\\n            {\\n                result[4] += 1;\\n            }\\n        }\\n         \\n        Arrays.sort(result);\\n        \\n        return (int)result[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) \\n    {   \\n        char [] chars = text.toCharArray();\\n        double [] result = new double[5];\\n\\n        for(int i = 0; i < chars.length; i++)\\n        {\\n            if(chars[i] == \\'b\\')\\n            {\\n                result[0] += 1;\\n            }\\n            else if(chars[i] == \\'a\\')\\n            {\\n                result[1] += 1;\\n            }\\n            else if(chars[i] == \\'l\\')\\n            {\\n                result[2] += .5;\\n            }\\n            else if(chars[i] == \\'o\\')\\n            {\\n                result[3] += .5;\\n            }\\n            else if(chars[i] == \\'n\\')\\n            {\\n                result[4] += 1;\\n            }\\n        }\\n         \\n        Arrays.sort(result);\\n        \\n        return (int)result[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939263,
                "title": "easiest-python-o-n-solution-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI saw multiple solutions implementing hash map here, which was also the first thing I thought about but came to think of an easier way to do this. The main thing here is to realise is that you can create the word \"balloon\" only as along as you have all the characters. For example if you have 5 of b,a,l,l,o,o but only 2 n then you can only make 2 balloon since you won\\'t have n for the next.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount the number of each letter in balloon, ie b,a,l,o,n for l and o take integer div by 2 since we need 2 characters per word\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        b  = text.count(\\'b\\')\\n        a  = text.count(\\'a\\')\\n        l  = text.count(\\'l\\')//2\\n        o  = text.count(\\'o\\')//2\\n        n  = text.count(\\'n\\')\\n        \\n        return min(b,a,l,o,n)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        b  = text.count(\\'b\\')\\n        a  = text.count(\\'a\\')\\n        l  = text.count(\\'l\\')//2\\n        o  = text.count(\\'o\\')//2\\n        n  = text.count(\\'n\\')\\n        \\n        return min(b,a,l,o,n)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872099,
                "title": "python-runtime-24ms-faster-than-98-25",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        strs = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\']\\n        counts = [0] * 5\\n\\n        for i in range(5):\\n            counts[i] = text.count(strs[i])\\n\\n        counts[2] = counts[2] // 2\\n        counts[3] = counts[3] // 2\\n\\n        return min(counts)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        strs = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\']\\n        counts = [0] * 5\\n\\n        for i in range(5):\\n            counts[i] = text.count(strs[i])\\n\\n        counts[2] = counts[2] // 2\\n        counts[3] = counts[3] // 2\\n\\n        return min(counts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587044,
                "title": "java-100-100",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n\\t\\tint[] arr = new int[5];\\n\\t\\tfor(char c : text.toCharArray()) {\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\tcase \\'b\\' : arr[0]++; break;\\n\\t\\t\\t\\tcase \\'a\\' : arr[1]++; break;\\n\\t\\t\\t\\tcase \\'n\\' : arr[2]++; break;\\n\\t\\t\\t\\tcase \\'l\\' : arr[3]++; break;\\n\\t\\t\\t\\tcase \\'o\\' : arr[4]++; break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint min1 = Math.min(Math.min(arr[0], arr[1]), arr[2]);\\n\\t\\tint min2 = Math.min(arr[3], arr[4]);\\n\\t\\treturn Math.min(min1, min2 / 2);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n\\t\\tint[] arr = new int[5];\\n\\t\\tfor(char c : text.toCharArray()) {\\n\\t\\t\\tswitch (c) {\\n\\t\\t\\t\\tcase \\'b\\' : arr[0]++; break;\\n\\t\\t\\t\\tcase \\'a\\' : arr[1]++; break;\\n\\t\\t\\t\\tcase \\'n\\' : arr[2]++; break;\\n\\t\\t\\t\\tcase \\'l\\' : arr[3]++; break;\\n\\t\\t\\t\\tcase \\'o\\' : arr[4]++; break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint min1 = Math.min(Math.min(arr[0], arr[1]), arr[2]);\\n\\t\\tint min2 = Math.min(arr[3], arr[4]);\\n\\t\\treturn Math.min(min1, min2 / 2);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013213,
                "title": "2-line-python-using-counter",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = collections.Counter(text)\\n        return min(c[\\'b\\'],c[\\'a\\'],c[\\'l\\']//2,c[\\'o\\']//2,c[\\'n\\'])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = collections.Counter(text)\\n        return min(c[\\'b\\'],c[\\'a\\'],c[\\'l\\']//2,c[\\'o\\']//2,c[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812956,
                "title": "4-approaches-include-hashmap-improved-version-c-best",
                "content": "\\n\\t\\t//1.Runtime: 12ms\\n\\t\\t\\n        class Solution {\\n        public:\\n            int maxNumberOfBalloons(string text) {\\n                map<char, int> M;\\n                for(auto ch : text) M[ch]++;\\n                return min({M[\\'b\\'], M[\\'a\\'], M[\\'l\\']/2, M[\\'o\\']/2, M[\\'n\\']});\\n            }\\n        };\\n\\t\\t\\n        //2.Runtime: 8 ms\\n        \\n        class Solution {\\n        public:\\n                    int maxNumberOfBalloons(string text) {\\n                int b, a, l, o, n;\\n                b = a = l = o = n = 0;\\n                for (auto ch : text) {\\n                    b += (ch == \\'b\\');\\n                    a += (ch == \\'a\\');\\n                    l += (ch == \\'l\\');\\n                    o += (ch == \\'o\\');\\n                    n += (ch == \\'n\\');\\n                }\\n                return min({b, a, l/2, o/2, n});\\n            }\\n        };\\n\\t\\t\\n\\t\\t//3.improved version \\n\\t\\t//Runtime: 4 ms, faster than 98.97%\\n\\t\\t\\n\\t\\tclass Solution {\\n        public:\\n            int maxNumberOfBalloons(string text) {\\n                vector<int> map(5,0); //using only 5 indexes for b,a,l,o,n\\n                for(auto ch : text){ \\n                    if(ch==\\'b\\')\\n                        map[(ch-\\'a\\')]+=1; //(ch-\\'a\\')=98-97=1 (1st index)\\n                    else if(ch==\\'a\\')\\n                        map[(ch-\\'a\\')]+=1;//(ch-\\'a\\')=97-97=0 (0th index)\\n                    else if(ch==\\'l\\')\\n                        map[(ch-\\'a\\')-9]+=1;//(ch-\\'a\\')=108-97=11-9=2 (2nd index)\\n                    else if(ch==\\'n\\')\\n                        map[(ch-\\'a\\')-10]+=1;//(ch-\\'a\\')=110-97=13-10=3 (3rd index)\\n                    else if(ch==\\'o\\')\\n                        map[(ch-\\'a\\')-10]+=1; //(ch-\\'a\\')=111-97=14-10=4 (4th index)\\n                }\\n                return min({map[0],map[1],map[2]/2,map[3],map[4]/2});\\n            }\\n        };\\n\\t\\t\\n\\t\\t//4.using switch\\n\\t\\t\\n\\t\\tclass Solution {\\n        public:\\n            int maxNumberOfBalloons(string text) {\\n                int b, a, l, o, n;\\n                b = a = l = o = n = 0;\\n                for (auto ch : text) {\\n                    switch (ch) {\\n                        case \\'b\\' : b++; break;\\n                                case \\'a\\' : a++; break;\\n                        case \\'l\\' : l++; break;\\n                        case \\'o\\' : o++; break;\\n                        case \\'n\\' : n++; break;\\n                    }\\n                }\\n                return min({b, a, l/2, o/2, n});\\n            }\\n        };\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n        public:\\n            int maxNumberOfBalloons(string text) {\\n                map<char, int> M;\\n                for(auto ch : text) M[ch]++;\\n                return min({M[\\'b\\'], M[\\'a\\'], M[\\'l\\']/2, M[\\'o\\']/2, M[\\'n\\']}",
                "codeTag": "Java"
            },
            {
                "id": 1460932,
                "title": "python-1-liner-c-simple-and-short-solutions",
                "content": "**Python:**\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```\\n****\\n**C++:** \\n0 ms, faster than 100%\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for (auto ch : text) {\\n            switch (ch) {\\n                case \\'b\\':\\n                    b++; break;\\n                case \\'a\\':\\n                    a++; break;\\n                case \\'l\\':\\n                    l++; break;\\n                case \\'o\\':\\n                    o++; break;\\n                case \\'n\\':\\n                    n++; break;\\n            }\\n        }\\n        \\n        return min({b, a, l/2, o/2, n});\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for (auto ch : text) {\\n            switch (ch) {\\n                case \\'b\\':\\n                    b++; break;\\n                case \\'a\\':\\n                    a++; break;\\n                case \\'l\\':\\n                    l++; break;\\n                case \\'o\\':\\n                    o++; break;\\n                case \\'n\\':\\n                    n++; break;\\n            }\\n        }\\n        \\n        return min({b, a, l/2, o/2, n});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461896,
                "title": "easy-to-understand-using-hashmap-java",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n    \\n        HashMap<Character,Integer> hm= new HashMap<>();\\n\\t    hm.put(\\'b\\',0);hm.put(\\'a\\',0);hm.put(\\'l\\',0);hm.put(\\'o\\',0);hm.put(\\'n\\',0);\\n\\t    for(char i:text.toCharArray()) {\\n\\t\\t    if(hm.containsKey(i)) hm.put(i, hm.get(i)+1);}\\n\\treturn(Math.min(hm.get(\\'b\\'), Math.min(hm.get(\\'a\\'), Math.min(hm.get(\\'l\\')/2, Math.min(hm.get(\\'o\\')/2,hm.get(\\'n\\'))))));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n    \\n        HashMap<Character,Integer> hm= new HashMap<>();\\n\\t    hm.put(\\'b\\',0);hm.put(\\'a\\',0);hm.put(\\'l\\',0);hm.put(\\'o\\',0);hm.put(\\'n\\',0);\\n\\t    for(char i:text.toCharArray()) {\\n\\t\\t    if(hm.containsKey(i)) hm.put(i, hm.get(i)+1);}\\n\\treturn(Math.min(hm.get(\\'b\\'), Math.min(hm.get(\\'a\\'), Math.min(hm.get(\\'l\\')/2, Math.min(hm.get(\\'o\\')/2,hm.get(\\'n\\'))))));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461862,
                "title": "c-1189-maximum-number-of-balloons",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int freq[26] = {0}; \\n        for (auto& ch : text) ++freq[ch - \\'a\\']; \\n        return min({freq[0], freq[1], freq[11]/2, freq[13], freq[14]/2}); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int freq[26] = {0}; \\n        for (auto& ch : text) ++freq[ch - \\'a\\']; \\n        return min({freq[0], freq[1], freq[11]/2, freq[13], freq[14]/2}); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461288,
                "title": "javascript-clean-simple-solution-hash-map",
                "content": "```\\nconst maxNumberOfBalloons = (text) => {\\n  let obj = {},\\n    balloonCount = 0;\\n  for (let el of text) {\\n    obj[el] = (obj[el] || 0) + 1;\\n  }\\n\\n  while (obj[\\'a\\'] > 0 && obj[\\'b\\'] > 0 && obj[\\'l\\'] > 1 && obj[\\'n\\'] > 0 && obj[\\'o\\'] > 1) {\\n    balloonCount++;\\n\\n    obj[\\'a\\']--;\\n    obj[\\'b\\']--;\\n    obj[\\'l\\'] -= 2;\\n    obj[\\'n\\']--;\\n    obj[\\'o\\'] -= 2;\\n  }\\n\\n  return balloonCount;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxNumberOfBalloons = (text) => {\\n  let obj = {},\\n    balloonCount = 0;\\n  for (let el of text) {\\n    obj[el] = (obj[el] || 0) + 1;\\n  }\\n\\n  while (obj[\\'a\\'] > 0 && obj[\\'b\\'] > 0 && obj[\\'l\\'] > 1 && obj[\\'n\\'] > 0 && obj[\\'o\\'] > 1) {\\n    balloonCount++;\\n\\n    obj[\\'a\\']--;\\n    obj[\\'b\\']--;\\n    obj[\\'l\\'] -= 2;\\n    obj[\\'n\\']--;\\n    obj[\\'o\\'] -= 2;\\n  }\\n\\n  return balloonCount;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179745,
                "title": "swift-8ms-readable-solution-beats-96",
                "content": "```swift\\nfinal class Solution {\\n\\t// O(n) time | O(1) space\\n    func maxNumberOfBalloons(_ text: String) -> Int {\\n        var b = 0, a = 0, l = 0, o = 0, n = 0\\n\\n        for char in text {\\n            switch char {\\n            case \"b\": b += 1\\n            case \"a\": a += 1\\n            case \"l\": l += 1\\n            case \"o\": o += 1\\n            case \"n\": n += 1\\n            default: continue\\n            }\\n        }\\n\\n        l /= 2; o /= 2 // we need 2 letters of each\\n\\n        return min(b, a, l, o, n)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nfinal class Solution {\\n\\t// O(n) time | O(1) space\\n    func maxNumberOfBalloons(_ text: String) -> Int {\\n        var b = 0, a = 0, l = 0, o = 0, n = 0\\n\\n        for char in text {\\n            switch char {\\n            case \"b\": b += 1\\n            case \"a\": a += 1\\n            case \"l\": l += 1\\n            case \"o\": o += 1\\n            case \"n\": n += 1\\n            default: continue\\n            }\\n        }\\n\\n        l /= 2; o /= 2 // we need 2 letters of each\\n\\n        return min(b, a, l, o, n)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084649,
                "title": "simple-java-solution-100",
                "content": "We count the occurence of \\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\' and store them in array.\\n\\nThen divide the occurence of \\'l\\' and \\'o\\' by 2 as they occur twice in one \\'balloon\\' word.\\n\\nNow we just sort the array to get the minimum value amongst all the occurence...as it is the value needed to make a successful \\'balloon\\'.\\n\\n\\n```\\n\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int ar[]=new int[5];\\n        \\n        for(char x:text.toCharArray()){\\n            \\n            switch(x){\\n                case \\'b\\':\\n                    ar[0]++;break;\\n                case \\'a\\':\\n                    ar[1]++;break;\\n                case \\'l\\':\\n                    ar[2]++;break;\\n                case \\'o\\':\\n                    ar[3]++;break;\\n                case \\'n\\':\\n                    ar[4]++;break;\\n            }\\n            \\n        }\\n        \\n        ar[2]/=2;\\n        ar[3]/=2;\\n        \\n        Arrays.sort(ar);\\n        \\n        return ar[0];\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int ar[]=new int[5];\\n        \\n        for(char x:text.toCharArray()){\\n            \\n            switch(x){\\n                case \\'b\\':\\n                    ar[0]++;break;\\n                case \\'a\\':\\n                    ar[1]++;break;\\n                case \\'l\\':\\n                    ar[2]++;break;\\n                case \\'o\\':\\n                    ar[3]++;break;\\n                case \\'n\\':\\n                    ar[4]++;break;\\n            }\\n            \\n        }\\n        \\n        ar[2]/=2;\\n        ar[3]/=2;\\n        \\n        Arrays.sort(ar);\\n        \\n        return ar[0];\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504526,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char, int> M;\\n        for(auto ch : text) M[ch]++;\\n        return min({M[\\'b\\'], M[\\'a\\'], M[\\'l\\']/2, M[\\'o\\']/2, M[\\'n\\']});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char, int> M;\\n        for(auto ch : text) M[ch]++;\\n        return min({M[\\'b\\'], M[\\'a\\'], M[\\'l\\']/2, M[\\'o\\']/2, M[\\'n\\']});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681289,
                "title": "python-use-counter-2-lines-my-first-solution-up-plz",
                "content": "# Approach\\nUse Counter and don\\'t worry about it\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cnt = Counter(text)\\n        return min([cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'n\\'], cnt[\\'l\\'] // 2, cnt[\\'o\\'] // 2])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cnt = Counter(text)\\n        return min([cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'n\\'], cnt[\\'l\\'] // 2, cnt[\\'o\\'] // 2])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244848,
                "title": "easy-python-again",
                "content": "class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = Counter(text)\\n        s = [c[\\'a\\'], c[\\'b\\'], c[\\'n\\'], c[\\'l\\'] / 2, c[\\'o\\'] / 2]\\n        return int(min(s))",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = Counter(text)\\n        s = [c[\\'a\\'], c[\\'b\\'], c[\\'n\\'], c[\\'l\\'] / 2, c[\\'o\\'] / 2]\\n        return int(min(s))",
                "codeTag": "Java"
            },
            {
                "id": 1115806,
                "title": "easy-python-solution-o-n-time-simple-if-else",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        b = a = l = o = n = 0\\n        for i in text:\\n            if i == \\'b\\': b += 1\\n            elif i == \\'a\\': a += 1\\n            elif i == \\'l\\': l += 1\\n            elif i == \\'n\\': n += 1\\n            elif i == \\'o\\': o += 1\\n        count = 0\\n        while b and a and l and o and n:\\n            if b and a and l - 1 and o - 1 and n:\\n                count += 1\\n                b =- 1\\n                a -= 1\\n                l -= 2\\n                o -= 2\\n                n -= 1\\n            else: break\\n        return count\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges/tree/master",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        b = a = l = o = n = 0\\n        for i in text:\\n            if i == \\'b\\': b += 1\\n            elif i == \\'a\\': a += 1\\n            elif i == \\'l\\': l += 1\\n            elif i == \\'n\\': n += 1\\n            elif i == \\'o\\': o += 1\\n        count = 0\\n        while b and a and l and o and n:\\n            if b and a and l - 1 and o - 1 and n:\\n                count += 1\\n                b =- 1\\n                a -= 1\\n                l -= 2\\n                o -= 2\\n                n -= 1\\n            else: break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428897,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter=collections.Counter(text)\\n        s={counter[\\'b\\'],counter[\\'a\\'],counter[\\'l\\']//2,counter[\\'o\\']//2,counter[\\'n\\']}\\n        return min(s)     \\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter=collections.Counter(text)\\n        s={counter[\\'b\\'],counter[\\'a\\'],counter[\\'l\\']//2,counter[\\'o\\']//2,counter[\\'n\\']}\\n        return min(s)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 383459,
                "title": "python-counter",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        c = Counter(text)\\n        cc = Counter(\\'balloon\\')\\n        \\n        return min(c[k] // cc[k] for k in \\'balon\\')",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        c = Counter(text)\\n        cc = Counter(\\'balloon\\')\\n        \\n        return min(c[k] // cc[k] for k in \\'balon\\')",
                "codeTag": "Java"
            },
            {
                "id": 2746039,
                "title": "java-1-ms-faster-than-100-00",
                "content": "If you like it pls upvote\\n```\\n\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for (char aChar : text.toCharArray())\\n            switch (aChar) {\\n                case \\'b\\' : b++;\\n                break;\\n                case \\'a\\' : a++;\\n                break;\\n                case \\'l\\' : l++;\\n                break;\\n                case \\'o\\' : o++;\\n                break;\\n                case \\'n\\' : n++;\\n                break;\\n            }\\n        return Math.min(Math.min(Math.min(b,a),n), Math.min(l/2,o/2));\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for (char aChar : text.toCharArray())\\n            switch (aChar) {\\n                case \\'b\\' : b++;\\n                break;\\n                case \\'a\\' : a++;\\n                break;\\n                case \\'l\\' : l++;\\n                break;\\n                case \\'o\\' : o++;\\n                break;\\n                case \\'n\\' : n++;\\n                break;\\n            }\\n        return Math.min(Math.min(Math.min(b,a),n), Math.min(l/2,o/2));\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461968,
                "title": "max-number-of-balloons-easy-w-explanation-c-python3-one-liner-java",
                "content": "**IDEA**\\n\\n* Count number of each symbols, specifically `a`, `b`, `l`, `n`, `o`. \\n* Then we need to find letter with minimum frequency\\n\\t* Take into account that we need two `l` and two `o`.\\n\\n**TIME COMPLEXITY - O(N)\\nSPACE COMPLEXITY - O(26)**\\n\\n**SOLUTION**\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int freq[26] = {0}; \\n        for (auto& ch : text) ++freq[ch - \\'a\\']; \\n        return min({freq[0], freq[1], freq[11]/2, freq[13], freq[14]/2}); \\n    }\\n};\\n```\\n`Python3 One Liner`\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] chars = new int[26]; \\n        for (char c : text.toCharArray()) \\n        {\\n            chars[c - \\'a\\']++;\\n        }\\n        int min = chars[1] ;\\n        min = Math.min(min, chars[0]);\\n        min = Math.min(min, chars[11] / 2); \\n        min = Math.min(min, chars[14] / 2);\\n        min = Math.min(min, chars[13]);\\n        return min;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int freq[26] = {0}; \\n        for (auto& ch : text) ++freq[ch - \\'a\\']; \\n        return min({freq[0], freq[1], freq[11]/2, freq[13], freq[14]/2}); \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] chars = new int[26]; \\n        for (char c : text.toCharArray()) \\n        {\\n            chars[c - \\'a\\']++;\\n        }\\n        int min = chars[1] ;\\n        min = Math.min(min, chars[0]);\\n        min = Math.min(min, chars[11] / 2); \\n        min = Math.min(min, chars[14] / 2);\\n        min = Math.min(min, chars[13]);\\n        return min;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460887,
                "title": "python-3-two-solutions-comparison",
                "content": "Here\\'s my Python implementation:\\n**Solution #1:** CPU - 53%, Memory - 52%\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        word = {\\'a\\':0, \\'b\\':0,\\'l\\':0, \\'n\\':0, \\'o\\':0}\\n        double_char = [\\'l\\',\\'o\\']\\n        for c in text:\\n            if c in word:\\n                word[c] += 0.5 if c in double_char else 1\\n        return int(min(word.values()))\\n```\\n**Solution #2:** CPU - 78%, Memory - 21%\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        word = {\\'a\\':0, \\'b\\':0,\\'l\\':0, \\'n\\':0, \\'o\\':0}\\n        double_char = [\\'l\\',\\'o\\']\\n        for c in text:\\n            if c in word:\\n                word[c] += 1\\n        for c in double_char:\\n            word[c] //= 2\\n        return min(word.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        word = {\\'a\\':0, \\'b\\':0,\\'l\\':0, \\'n\\':0, \\'o\\':0}\\n        double_char = [\\'l\\',\\'o\\']\\n        for c in text:\\n            if c in word:\\n                word[c] += 0.5 if c in double_char else 1\\n        return int(min(word.values()))\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        word = {\\'a\\':0, \\'b\\':0,\\'l\\':0, \\'n\\':0, \\'o\\':0}\\n        double_char = [\\'l\\',\\'o\\']\\n        for c in text:\\n            if c in word:\\n                word[c] += 1\\n        for c in double_char:\\n            word[c] //= 2\\n        return min(word.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440368,
                "title": "c-beats-8-83",
                "content": "# Code\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        std::map<char, int> etalon{\\n            {\\'b\\', 1}, {\\'a\\', 1}, {\\'l\\', 2}, {\\'o\\', 2}, {\\'n\\', 1}};\\n\\n        std::map<char, int> temp {\\n            {\\'b\\', 0}, {\\'a\\', 0}, {\\'l\\', 0}, {\\'o\\', 0}, {\\'n\\', 0}};\\n        \\n        for (int i = 0; i < text.size(); i++){\\n            temp[text[i]] = temp[text[i]] + 1;\\n        }\\n        \\n        int count = 0;\\n        char* balon = \"balon\";\\n        while(true) {\\n            for (int i = 0; i < 5; i++) {\\n                temp[balon[i]] -= etalon[balon[i]];\\n                if (temp[balon[i]] < 0)\\n                    return count;\\n            }\\n            count++;\\n        }\\n    }\\n};\\n```\\nThe same code...\\n![photo_2023-04-21 11.07.03.jpeg](https://assets.leetcode.com/users/images/e6d759c3-1afe-4292-ab90-cc6b934d6ebc_1682064433.6018877.jpeg)\\n![photo_2023-04-21 11.07.07.jpeg](https://assets.leetcode.com/users/images/f3ff9517-7c03-4914-8aae-449a51943a0e_1682064454.1784246.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        std::map<char, int> etalon{\\n            {\\'b\\', 1}, {\\'a\\', 1}, {\\'l\\', 2}, {\\'o\\', 2}, {\\'n\\', 1}};\\n\\n        std::map<char, int> temp {\\n            {\\'b\\', 0}, {\\'a\\', 0}, {\\'l\\', 0}, {\\'o\\', 0}, {\\'n\\', 0}};\\n        \\n        for (int i = 0; i < text.size(); i++){\\n            temp[text[i]] = temp[text[i]] + 1;\\n        }\\n        \\n        int count = 0;\\n        char* balon = \"balon\";\\n        while(true) {\\n            for (int i = 0; i < 5; i++) {\\n                temp[balon[i]] -= etalon[balon[i]];\\n                if (temp[balon[i]] < 0)\\n                    return count;\\n            }\\n            count++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938245,
                "title": "95-faster-easiest-java-solution-o-1-space-o-n-time-complexity",
                "content": "# Intuition\\n Letters occurance  \\n\\n# Approach\\nCheck count for the \\'BALON\\' inspite of \\'BALLOON\\'\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is size of string\\n- Space complexity:\\nO(1) as using constant space\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        //Store the result in only five size int array as below\\n        //BALLOON\\n        //0122334\\n        int balloon[]= new int[5];\\n\\n        //Base case, for BALLON as string it should be atleast six letter size\\n        if(text.length()<6) return 0;\\n\\n        //Check for each char and get it decided with switch case in faster way\\n        for(char k:text.toCharArray()){\\n            switch(k){\\n                case \\'b\\': balloon[0]++; break;\\n                case \\'a\\': balloon[1]++; break;\\n                case \\'l\\': balloon[2]++; break;\\n                case \\'o\\': balloon[3]++; break;\\n                case \\'n\\': balloon[4]++; break;\\n            }\\n        }\\n\\n        // Keep occurance of letter \\'L\\' and \\'O\\' as one,\\n        // so that finally for a single found, each char occurance of BALLON would be \\'BALON\\'\\n        // by changing 2 repetition of letter \\'L\\' and \\'O\\' into one by below statements\\n        balloon[2] /=2;\\n        balloon[3] /=2;\\n\\n        // If any of the occurance for letter \\'L\\' and \\'O\\' is zero or negative,\\n        // means there is no atleast one available \\'BALLON\\'\\n        if(balloon[2]<=0 || balloon[3]<=0) return 0;\\n\\n        // Assume the first char occurance as min possible \\'Ballon\\' in input string\\n        int min = balloon[0];\\n\\n        // Compare it with rest and choose the minimum\\n        for(int i=1;i<5;i++)\\n            if(balloon[i]<min)\\n                min = balloon[i];\\n        \\n        // If min value is negative or zero, means there is no atleast one available \\'BALLON\\'\\n        if(min<=0) return 0;\\n\\n        // Otherwise, return the min value for which input string contains min \\'BALLON\\'\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        //Store the result in only five size int array as below\\n        //BALLOON\\n        //0122334\\n        int balloon[]= new int[5];\\n\\n        //Base case, for BALLON as string it should be atleast six letter size\\n        if(text.length()<6) return 0;\\n\\n        //Check for each char and get it decided with switch case in faster way\\n        for(char k:text.toCharArray()){\\n            switch(k){\\n                case \\'b\\': balloon[0]++; break;\\n                case \\'a\\': balloon[1]++; break;\\n                case \\'l\\': balloon[2]++; break;\\n                case \\'o\\': balloon[3]++; break;\\n                case \\'n\\': balloon[4]++; break;\\n            }\\n        }\\n\\n        // Keep occurance of letter \\'L\\' and \\'O\\' as one,\\n        // so that finally for a single found, each char occurance of BALLON would be \\'BALON\\'\\n        // by changing 2 repetition of letter \\'L\\' and \\'O\\' into one by below statements\\n        balloon[2] /=2;\\n        balloon[3] /=2;\\n\\n        // If any of the occurance for letter \\'L\\' and \\'O\\' is zero or negative,\\n        // means there is no atleast one available \\'BALLON\\'\\n        if(balloon[2]<=0 || balloon[3]<=0) return 0;\\n\\n        // Assume the first char occurance as min possible \\'Ballon\\' in input string\\n        int min = balloon[0];\\n\\n        // Compare it with rest and choose the minimum\\n        for(int i=1;i<5;i++)\\n            if(balloon[i]<min)\\n                min = balloon[i];\\n        \\n        // If min value is negative or zero, means there is no atleast one available \\'BALLON\\'\\n        if(min<=0) return 0;\\n\\n        // Otherwise, return the min value for which input string contains min \\'BALLON\\'\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461848,
                "title": "pythonic-2-liner-with-comments-o-n-time-space",
                "content": "As always, like if you found this solution helpful. \\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        # Counts the frequency of each character in text\\n        seen = collections.Counter(text)\\n        \\n        # The minimum number of Balloons can be no more than the least frequent character\\n        return min(seen[\\'b\\'], seen[\\'a\\'], seen[\\'l\\']//2, seen[\\'o\\']//2, seen[\\'n\\'])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        # Counts the frequency of each character in text\\n        seen = collections.Counter(text)\\n        \\n        # The minimum number of Balloons can be no more than the least frequent character\\n        return min(seen[\\'b\\'], seen[\\'a\\'], seen[\\'l\\']//2, seen[\\'o\\']//2, seen[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836271,
                "title": "python-methods-using-dict-counter-defaultdict",
                "content": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons1(self, text):\\n        c = collections.Counter(text)\\n        k = collections.Counter(\"balloon\")\\n        return min(c[item]//k[item] for item in k)\\n        \\n    def maxNumberOfBalloons2(self, text):\\n        c = collections.defaultdict(int)\\n        for item in text:\\n            c[item] += 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c[item]//k[item] for item in k)\\n    \\n    def maxNumberOfBalloons3(self, text):\\n        c = {}\\n        for item in text:\\n            if item not in c:\\n                c[item] = 0\\n            c[item] += 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c.get(item, 0)//k[item] for item in k)\\n    \\n    def maxNumberOfBalloons(self, text):\\n        c = dict()\\n        for item in text:\\n            c[item] = c.get(item, 0) + 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c.get(item, 0)//k[item] for item in k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons1(self, text):\\n        c = collections.Counter(text)\\n        k = collections.Counter(\"balloon\")\\n        return min(c[item]//k[item] for item in k)\\n        \\n    def maxNumberOfBalloons2(self, text):\\n        c = collections.defaultdict(int)\\n        for item in text:\\n            c[item] += 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c[item]//k[item] for item in k)\\n    \\n    def maxNumberOfBalloons3(self, text):\\n        c = {}\\n        for item in text:\\n            if item not in c:\\n                c[item] = 0\\n            c[item] += 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c.get(item, 0)//k[item] for item in k)\\n    \\n    def maxNumberOfBalloons(self, text):\\n        c = dict()\\n        for item in text:\\n            c[item] = c.get(item, 0) + 1\\n        k = collections.Counter(\"balloon\")\\n        return min(c.get(item, 0)//k[item] for item in k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829460,
                "title": "simple-java-solution-100-faster",
                "content": "\\tclass Solution {\\n\\t\\tpublic int maxNumberOfBalloons(String text) {\\n\\t\\t\\tint[] count = new int[26];\\n\\t\\t\\tfor(char ch : text.toCharArray()) count[ch-\\'a\\']++;\\n\\t\\t\\tint res = Integer.MAX_VALUE;\\n\\n\\t\\t\\tres = Math.min(res , count[\\'b\\'-\\'a\\']);\\n\\t\\t\\tres = Math.min(res , count[\\'a\\'-\\'a\\']);\\n\\t\\t\\tres = Math.min(res , count[\\'l\\'-\\'a\\']/2);\\n\\t\\t\\tres = Math.min(res , count[\\'o\\'-\\'a\\']/2);\\n\\t\\t\\tres = Math.min(res , count[\\'n\\'-\\'a\\']);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int maxNumberOfBalloons(String text) {\\n\\t\\t\\tint[] count = new int[26];\\n\\t\\t\\tfor(char ch : text.toCharArray()) count[ch-\\'a\\']++;\\n\\t\\t\\tint res = Integer.MAX_VALUE;\\n\\n\\t\\t\\tres = Math.min(res , count[\\'b\\'-\\'a\\']);\\n\\t\\t\\tres = Math.min(res , count[\\'a\\'-\\'a\\']);\\n\\t\\t\\tres = Math.min(res , count[\\'l\\'-\\'a\\']/2);\\n\\t\\t\\tres = Math.min(res , count[\\'o\\'-\\'a\\']/2);\\n\\t\\t\\tres = Math.min(res , count[\\'n\\'-\\'a\\']);\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 795493,
                "title": "java-easy-array-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[]counters = new int[\"balon\".length()];\\n        for (char c: text.toCharArray()){\\n            switch (c) {\\n                case \\'b\\':counters[0]++; break;\\n                case \\'a\\':counters[1]++; break;\\n                case \\'l\\':counters[2]++; break;\\n                case \\'o\\':counters[3]++; break;\\n                case \\'n\\':counters[4]++; break;\\n            }}\\n        \\n        int min = counters[0];\\n        for (int i=1;i<5;i++){\\n            min = Math.min(min, (i==2||i==3)?counters[i]/2:counters[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[]counters = new int[\"balon\".length()];\\n        for (char c: text.toCharArray()){\\n            switch (c) {\\n                case \\'b\\':counters[0]++; break;\\n                case \\'a\\':counters[1]++; break;\\n                case \\'l\\':counters[2]++; break;\\n                case \\'o\\':counters[3]++; break;\\n                case \\'n\\':counters[4]++; break;\\n            }}\\n        \\n        int min = counters[0];\\n        for (int i=1;i<5;i++){\\n            min = Math.min(min, (i==2||i==3)?counters[i]/2:counters[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780638,
                "title": "python-one-liner-simplest-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return min(text.count(\\'b\\'), text.count(\\'a\\'),text.count(\\'l\\')//2, text.count(\\'o\\')//2, text.count(\\'n\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556647,
                "title": "go-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Number of Balloons.\\nMemory Usage: 2.2 MB, less than 100.00% of Go online submissions for Maximum Number of Balloons.\\n```\\nfunc maxNumberOfBalloons(text string) int {\\n    b,a,l,o,n := 0,0,0,0,0\\n    for _, r := range text{\\n        switch r{\\n            case \\'b\\':\\n                b++\\n            case \\'a\\':\\n                a++\\n            case \\'l\\':\\n                l++\\n            case \\'o\\':\\n                o++\\n            case \\'n\\':\\n                n++\\n        }\\n    }\\n    \\n    res := min(b, min(a,n))\\n    res = min(res, min(l/2,o/2))\\n    return res\\n}\\n\\nfunc min(a,b int) int{\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxNumberOfBalloons(text string) int {\\n    b,a,l,o,n := 0,0,0,0,0\\n    for _, r := range text{\\n        switch r{\\n            case \\'b\\':\\n                b++\\n            case \\'a\\':\\n                a++\\n            case \\'l\\':\\n                l++\\n            case \\'o\\':\\n                o++\\n            case \\'n\\':\\n                n++\\n        }\\n    }\\n    \\n    res := min(b, min(a,n))\\n    res = min(res, min(l/2,o/2))\\n    return res\\n}\\n\\nfunc min(a,b int) int{\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454346,
                "title": "python3-using-counter-from-collections",
                "content": "```\\nfrom collections import Counter as c\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        a = c(text)\\n        return min(a[\\'l\\'] // 2, a[\\'o\\'] // 2, a[\\'b\\'], a[\\'a\\'], a[\\'n\\'])\\n```\\n\\nA bit more readable:\\n\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text):\\n        count_map = collections.Counter(text)\\n        return min(count_map[\\'l\\'] >> 1, count_map[\\'o\\'] >> 1, count_map[\\'b\\'], count_map[\\'a\\'], count_map[\\'n\\'])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter as c\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        a = c(text)\\n        return min(a[\\'l\\'] // 2, a[\\'o\\'] // 2, a[\\'b\\'], a[\\'a\\'], a[\\'n\\'])\\n```\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text):\\n        count_map = collections.Counter(text)\\n        return min(count_map[\\'l\\'] >> 1, count_map[\\'o\\'] >> 1, count_map[\\'b\\'], count_map[\\'a\\'], count_map[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383197,
                "title": "c-and-javascript-solutions",
                "content": "**Synopsis:**\\nIn order to spell \"balloon\" we need: one ```b```, one ```a```, two ```l```, two ```o```, and one ```n```\\n* Iterate through the characters of text and count the number of occurrences of ```b```, ```a```, ```l```, ```o```, ```n```.\\n* Divide the number of occurrences of ```l``` and ```o``` by 2 and return the minimum of the number of occurrences of ```b```, ```a```, ```l```, ```o```, ```n```.  This minimum number of occurrences of ```b```, ```a```, ```l```, ```o```, ```n``` is the answer because it is the \"limiting factor\" / \"bottleneck\" towards formulating another instance of \"balloon\".\\n\\n**Note:** The number of occurrences of ```l``` and ```o``` are divided by 2 in because we need twice as many ```l```\\'s and ```o```\\'s compared to ```a```\\'s, ```b```\\'s, and ```n```\\'s to formulate each instance of \"balloon\".\\n\\n**Runtime:** O(N)\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    using Counter = unordered_map<char, int>; \\n    int maxNumberOfBalloons(string text) {\\n        Counter cnt;\\n        for (auto ch: text)\\n            ++cnt[ch];\\n        return min({cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\']});\\n    }\\n};\\n```\\n\\n**C++ Supplemental:** the same counting concept can be performed with a vector of integers as the underlying data structure.  Most of the recent leetcode problems use lowercase letters, so a vector of size 123 is sufficient for storing the counts of characters \\'a\\' ( who\\'s ordinality is 97 ) to \\'z\\' ( who\\'s ordinality is 122 ).  This definitely wastes memory, but I feel that loss is outweighed by the benefit of cleaner code which doesn\\'t need to subtract by the offset \\'a\\' for a 0-based index along with a vector of size 26.  Note: only counts of letters up to \\'n\\' is needed, however, its simpler for me to remember that counting lowercase characters is as easy as 123...\\n\\n```\\nclass Solution {\\npublic:\\n    using Counter = vector<int>;\\n    int maxNumberOfBalloons(string text) {\\n        Counter cnt(123);\\n        for (auto ch: text)\\n            ++cnt[ch];\\n        return min({cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\']});\\n    }\\n};\\n```\\n\\n**Javascript:**\\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = (text) => {\\n  const cnt = [...text].reduce((A, ch) => {\\n    A[ch] = (A[ch] || 0) + 1;\\n    return A;\\n  }, {});\\n  return Math.floor(Math.min(cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\'])) || 0;\\n};\\n```\\n\\n**1-Liners:** just for fun...\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string S) {\\n        return min({\\n            count(S.begin(), S.end(), \\'b\\'),\\n            count(S.begin(), S.end(), \\'a\\'),\\n            count(S.begin(), S.end(), \\'l\\') / 2,\\n            count(S.begin(), S.end(), \\'o\\') / 2,\\n            count(S.begin(), S.end(), \\'n\\'),\\n        });\\n    }\\n};\\n```\\n\\n**Javascript:**\\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = (S) => {\\n  return Math.floor(Math.min(\\n      [...S].filter(c => c === \\'b\\').length,\\n      [...S].filter(c => c === \\'a\\').length,\\n      [...S].filter(c => c === \\'l\\').length / 2,\\n      [...S].filter(c => c === \\'o\\').length / 2,\\n      [...S].filter(c => c === \\'n\\').length,\\n  )) || 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```b```\n```a```\n```l```\n```o```\n```n```\n```b```\n```a```\n```l```\n```o```\n```n```\n```l```\n```o```\n```b```\n```a```\n```l```\n```o```\n```n```\n```b```\n```a```\n```l```\n```o```\n```n```\n```l```\n```o```\n```l```\n```o```\n```a```\n```b```\n```n```\n```\\nclass Solution {\\npublic:\\n    using Counter = unordered_map<char, int>; \\n    int maxNumberOfBalloons(string text) {\\n        Counter cnt;\\n        for (auto ch: text)\\n            ++cnt[ch];\\n        return min({cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\']});\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using Counter = vector<int>;\\n    int maxNumberOfBalloons(string text) {\\n        Counter cnt(123);\\n        for (auto ch: text)\\n            ++cnt[ch];\\n        return min({cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\']});\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = (text) => {\\n  const cnt = [...text].reduce((A, ch) => {\\n    A[ch] = (A[ch] || 0) + 1;\\n    return A;\\n  }, {});\\n  return Math.floor(Math.min(cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'l\\'] / 2, cnt[\\'o\\'] / 2, cnt[\\'n\\'])) || 0;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string S) {\\n        return min({\\n            count(S.begin(), S.end(), \\'b\\'),\\n            count(S.begin(), S.end(), \\'a\\'),\\n            count(S.begin(), S.end(), \\'l\\') / 2,\\n            count(S.begin(), S.end(), \\'o\\') / 2,\\n            count(S.begin(), S.end(), \\'n\\'),\\n        });\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = (S) => {\\n  return Math.floor(Math.min(\\n      [...S].filter(c => c === \\'b\\').length,\\n      [...S].filter(c => c === \\'a\\').length,\\n      [...S].filter(c => c === \\'l\\').length / 2,\\n      [...S].filter(c => c === \\'o\\').length / 2,\\n      [...S].filter(c => c === \\'n\\').length,\\n  )) || 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382435,
                "title": "java-count-explained-easy-beats-100",
                "content": "As the order of letters is not important we can jus count them and then count number of each required character and take the min of those quantities.\\n\\nO(len(s)) for time for one pass to count each character, O(1) for memory - we use array of constant length 26. \\n\\n```\\n  public int maxNumberOfBalloons(String text) {\\n    if (text == null || text.length() < 7)\\n      return 0;\\n    int[] c = new int[26];\\n    for (char ch : text.toCharArray())\\n      c[ch - \\'a\\']++;\\n    int res = Integer.MAX_VALUE;\\n    res = Math.min(res, c[\\'b\\' - \\'a\\']);\\n    res = Math.min(res, c[\\'a\\' - \\'a\\']);\\n    res = Math.min(res, c[\\'l\\' - \\'a\\'] / 2);\\n    res = Math.min(res, c[\\'o\\' - \\'a\\'] / 2);\\n    res = Math.min(res, c[\\'n\\' - \\'a\\']);\\n    return res;\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int maxNumberOfBalloons(String text) {\\n    if (text == null || text.length() < 7)\\n      return 0;\\n    int[] c = new int[26];\\n    for (char ch : text.toCharArray())\\n      c[ch - \\'a\\']++;\\n    int res = Integer.MAX_VALUE;\\n    res = Math.min(res, c[\\'b\\' - \\'a\\']);\\n    res = Math.min(res, c[\\'a\\' - \\'a\\']);\\n    res = Math.min(res, c[\\'l\\' - \\'a\\'] / 2);\\n    res = Math.min(res, c[\\'o\\' - \\'a\\'] / 2);\\n    res = Math.min(res, c[\\'n\\' - \\'a\\']);\\n    return res;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2926664,
                "title": "c-solution-using-map-fastest-solution",
                "content": "Store the number of occurrence of every character present in the string given in parameter.\\n\\nLoop over all the character of \\'balloon\\' and keep the smallest amount and return it\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        std::map<char, int> m;\\n        int res = INT_MAX;\\n        std::string balloon = \"balloon\";\\n\\n        for (auto c : text)\\n            if (c == \\'b\\' || c == \\'a\\' || c == \\'l\\' || c == \\'o\\' || c == \\'n\\' )\\n                m[c]++;\\n        for (auto c: balloon) {\\n            if (c == \\'l\\' || c == \\'o\\') {\\n                res = ( (res < m[c] / 2) ? res : m[c] / 2);\\n            } else {\\n                res = ((res < (m[c])) ? res : m[c]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        std::map<char, int> m;\\n        int res = INT_MAX;\\n        std::string balloon = \"balloon\";\\n\\n        for (auto c : text)\\n            if (c == \\'b\\' || c == \\'a\\' || c == \\'l\\' || c == \\'o\\' || c == \\'n\\' )\\n                m[c]++;\\n        for (auto c: balloon) {\\n            if (c == \\'l\\' || c == \\'o\\') {\\n                res = ( (res < m[c] / 2) ? res : m[c] / 2);\\n            } else {\\n                res = ((res < (m[c])) ? res : m[c]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625766,
                "title": "js-simple-solution-with-hashmap",
                "content": "```\\nconst BALLOON = {\\n    b: 1,\\n    a: 1,\\n    l: 2,\\n    o: 2,\\n    n: 1,\\n};\\n\\nvar maxNumberOfBalloons = function(text) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < text.length; i++) {\\n        if (hashmap.has(text[i])) {\\n            hashmap.set(text[i], hashmap.get(text[i]) + 1);\\n        } else {\\n            hashmap.set(text[i], 1);\\n        }\\n    }\\n    \\n    let output = Infinity;\\n    const arr = Object.keys(BALLOON);\\n    for (let i = 0; i < arr.length; i++) {\\n        const character = arr[i];\\n        if (!hashmap.has(character)) return 0;\\n\\n        output = Math.min(Math.floor(hashmap.get(character)/(BALLOON[character])), output)\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst BALLOON = {\\n    b: 1,\\n    a: 1,\\n    l: 2,\\n    o: 2,\\n    n: 1,\\n};\\n\\nvar maxNumberOfBalloons = function(text) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < text.length; i++) {\\n        if (hashmap.has(text[i])) {\\n            hashmap.set(text[i], hashmap.get(text[i]) + 1);\\n        } else {\\n            hashmap.set(text[i], 1);\\n        }\\n    }\\n    \\n    let output = Infinity;\\n    const arr = Object.keys(BALLOON);\\n    for (let i = 0; i < arr.length; i++) {\\n        const character = arr[i];\\n        if (!hashmap.has(character)) return 0;\\n\\n        output = Math.min(Math.floor(hashmap.get(character)/(BALLOON[character])), output)\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576645,
                "title": "c-3-lines-code",
                "content": "```\\nint maxNumberOfBalloons(string text) {\\n        vector<int> mp(26, 0);\\n        for(auto it : text) mp[it - \\'a\\']++;\\n        return min({mp[\\'b\\' - \\'a\\'], mp[\\'a\\' - \\'a\\'], mp[\\'n\\' - \\'a\\'], mp[\\'l\\' - \\'a\\'] / 2, mp[\\'o\\' - \\'a\\'] / 2});\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        vector<int> mp(26, 0);\\n        for(auto it : text) mp[it - \\'a\\']++;\\n        return min({mp[\\'b\\' - \\'a\\'], mp[\\'a\\' - \\'a\\'], mp[\\'n\\' - \\'a\\'], mp[\\'l\\' - \\'a\\'] / 2, mp[\\'o\\' - \\'a\\'] / 2});\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1574357,
                "title": "python-very-easy-fast-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter = collections.Counter(text)\\n        counter[\\'l\\'] //= 2\\n        counter[\\'o\\'] //= 2\\n        return min(counter[c] for c in \\'balon\\')",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        counter = collections.Counter(text)\\n        counter[\\'l\\'] //= 2\\n        counter[\\'o\\'] //= 2\\n        return min(counter[c] for c in \\'balon\\')",
                "codeTag": "Java"
            },
            {
                "id": 1463128,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int c=0;\\n    int maxNumberOfBalloons(string t) \\n    {\\n        int n=t.size();\\n        unordered_map<char,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[t[i]]++;\\n        }\\n        for( int i=1;i<n;i++)\\n        {\\n            if(m[\\'b\\']>=i*1 && m[\\'a\\']>=i*1 && m[\\'l\\']>=i*2 && m[\\'o\\']>=i*2 && m[\\'n\\']>=i*1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int c=0;\\n    int maxNumberOfBalloons(string t) \\n    {\\n        int n=t.size();\\n        unordered_map<char,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[t[i]]++;\\n        }\\n        for( int i=1;i<n;i++)\\n        {\\n            if(m[\\'b\\']>=i*1 && m[\\'a\\']>=i*1 && m[\\'l\\']>=i*2 && m[\\'o\\']>=i*2 && m[\\'n\\']>=i*1)\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462409,
                "title": "two-javascript-simple-solution-hash-map-reduce-method",
                "content": "```\\n1.\\nconst maxNumberOfBalloons = function(text) {\\n   let map = {b:0, a:0, l:0, o:0, n:0};\\n   for(let char of text){\\n         map[char]++\\n   }\\n   return Math.floor(Math.min(map.b, map.a, map.l/2, map.o/2, map.n));\\n };\\n\\n2. \\nconst maxNumberOfBalloons = function(text) {\\n    let count = [...text].reduce((acc, char) => {\\n            acc[char] = ( acc[char] || 0 ) + 1;\\n            return acc;\\n    }, {});\\n    let minChar = Math.min(count[\\'b\\'], count[\\'a\\'], count[\\'l\\']/2, count[\\'o\\']/2, count[\\'n\\']);\\n    return minChar ? Math.floor(minChar) : 0;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n1.\\nconst maxNumberOfBalloons = function(text) {\\n   let map = {b:0, a:0, l:0, o:0, n:0};\\n   for(let char of text){\\n         map[char]++\\n   }\\n   return Math.floor(Math.min(map.b, map.a, map.l/2, map.o/2, map.n));\\n };\\n\\n2. \\nconst maxNumberOfBalloons = function(text) {\\n    let count = [...text].reduce((acc, char) => {\\n            acc[char] = ( acc[char] || 0 ) + 1;\\n            return acc;\\n    }, {});\\n    let minChar = Math.min(count[\\'b\\'], count[\\'a\\'], count[\\'l\\']/2, count[\\'o\\']/2, count[\\'n\\']);\\n    return minChar ? Math.floor(minChar) : 0;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461245,
                "title": "python-c-c-java-js-solutions",
                "content": "c:\\n```\\nint match_char_to_num(char chr) {\\n\\tswitch (chr)\\n\\t{\\n\\tcase \\'b\\':\\n\\t\\treturn 0;\\n\\tcase \\'a\\':\\n\\t\\treturn 1;\\n\\tcase \\'l\\':\\n\\t\\treturn 2;\\n\\tcase \\'o\\':\\n\\t\\treturn 3;\\n\\tcase \\'n\\':\\n\\t\\treturn 4;\\n\\tdefault:\\n\\t\\treturn -1;\\n\\t}\\n}\\nint maxNumberOfBalloons(char* text) {\\n\\tint count_balloons[5] = { 0,0,0,0,0 };\\n\\tint index;\\n\\tfor (int i = 0; i < strlen(text); i++) {\\n\\t\\tindex = match_char_to_num(text[i]);\\n\\t\\tif (index != -1) count_balloons[index]++;\\n\\t}\\n\\tint min = strlen(text) + 1;\\n\\tcount_balloons[2] /= 2;\\n\\tcount_balloons[3] /= 2;\\n\\tfor (int i = 0; i < 5; i++) {\\n\\t\\tif (count_balloons[i] < min) min = count_balloons[i];\\n\\t}\\n\\treturn min;\\n}\\n\\n```\\n\\nc++:\\n```\\n int maxNumberOfBalloons(string text) {\\n        int counter_balloons[5] = { 0,0,0,0,0 };\\n        string balloon = \"balon\";\\n        int index = -1;\\n        for (int i = 0; i < text.length(); i++) {\\n            index = balloon.find_first_of(text[i]);\\n            if (index != -1) counter_balloons[index]++;\\n        }\\n        counter_balloons[2] /= 2;\\n        counter_balloons[3] /= 2;\\n        int min = text.length() + 1;\\n        for (int i = 0; i < 5; i++) {\\n            if (counter_balloons[i] < min) min = counter_balloons[i];\\n        }\\n        return min;\\n    }\\n```\\n\\npython:\\n```\\n def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        counter_balloons = [0, 0, 0, 0, 0]\\n        balloon = \"balon\"\\n        for c in text:\\n            try:\\n                index = balloon.index(c)\\n                counter_balloons[index] += 1\\n            except:\\n                continue\\n        counter_balloons[2] //= 2\\n        counter_balloons[3] //= 2\\n        return min(counter_balloons)  \\n```\\n\\njava:\\n```\\n  public int maxNumberOfBalloons(String text) {\\n        int[] counter_balloons = {0, 0, 0, 0, 0};\\n         String balloon=\"balon\";\\n         int index=-1;\\n         for(int i=0; i<text.length(); i++){\\n             index=balloon.indexOf(text.charAt(i));\\n             if(index!=-1){\\n                 counter_balloons[index]++;\\n             }\\n         }\\n         counter_balloons[2]/=2;\\n         counter_balloons[3]/=2;\\n         int min=text.length()+1;\\n        for (int counter_balloon : counter_balloons) {\\n            if (counter_balloon < min) min = counter_balloon;\\n        }\\n         return min;\\n    }\\n```\\n\\njavaScript:\\n```\\nfunction maxNumberOfBalloons(text) {\\n    let counter_balloons = [0, 0, 0, 0, 0];\\n    let balloon = \"balon\";\\n    for (let i = 0; i < text.length; i++) {\\n        let index = balloon.indexOf(text[i]);\\n        if (index != -1) counter_balloons[index]++;\\n    }\\n    counter_balloons[2]= Math.floor(counter_balloons[2]/2);\\n    counter_balloons[3]= Math.floor(counter_balloons[3]/2);\\n    return Math.min.apply(Math, counter_balloons);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint match_char_to_num(char chr) {\\n\\tswitch (chr)\\n\\t{\\n\\tcase \\'b\\':\\n\\t\\treturn 0;\\n\\tcase \\'a\\':\\n\\t\\treturn 1;\\n\\tcase \\'l\\':\\n\\t\\treturn 2;\\n\\tcase \\'o\\':\\n\\t\\treturn 3;\\n\\tcase \\'n\\':\\n\\t\\treturn 4;\\n\\tdefault:\\n\\t\\treturn -1;\\n\\t}\\n}\\nint maxNumberOfBalloons(char* text) {\\n\\tint count_balloons[5] = { 0,0,0,0,0 };\\n\\tint index;\\n\\tfor (int i = 0; i < strlen(text); i++) {\\n\\t\\tindex = match_char_to_num(text[i]);\\n\\t\\tif (index != -1) count_balloons[index]++;\\n\\t}\\n\\tint min = strlen(text) + 1;\\n\\tcount_balloons[2] /= 2;\\n\\tcount_balloons[3] /= 2;\\n\\tfor (int i = 0; i < 5; i++) {\\n\\t\\tif (count_balloons[i] < min) min = count_balloons[i];\\n\\t}\\n\\treturn min;\\n}\\n\\n```\n```\\n int maxNumberOfBalloons(string text) {\\n        int counter_balloons[5] = { 0,0,0,0,0 };\\n        string balloon = \"balon\";\\n        int index = -1;\\n        for (int i = 0; i < text.length(); i++) {\\n            index = balloon.find_first_of(text[i]);\\n            if (index != -1) counter_balloons[index]++;\\n        }\\n        counter_balloons[2] /= 2;\\n        counter_balloons[3] /= 2;\\n        int min = text.length() + 1;\\n        for (int i = 0; i < 5; i++) {\\n            if (counter_balloons[i] < min) min = counter_balloons[i];\\n        }\\n        return min;\\n    }\\n```\n```\\n def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        counter_balloons = [0, 0, 0, 0, 0]\\n        balloon = \"balon\"\\n        for c in text:\\n            try:\\n                index = balloon.index(c)\\n                counter_balloons[index] += 1\\n            except:\\n                continue\\n        counter_balloons[2] //= 2\\n        counter_balloons[3] //= 2\\n        return min(counter_balloons)  \\n```\n```\\n  public int maxNumberOfBalloons(String text) {\\n        int[] counter_balloons = {0, 0, 0, 0, 0};\\n         String balloon=\"balon\";\\n         int index=-1;\\n         for(int i=0; i<text.length(); i++){\\n             index=balloon.indexOf(text.charAt(i));\\n             if(index!=-1){\\n                 counter_balloons[index]++;\\n             }\\n         }\\n         counter_balloons[2]/=2;\\n         counter_balloons[3]/=2;\\n         int min=text.length()+1;\\n        for (int counter_balloon : counter_balloons) {\\n            if (counter_balloon < min) min = counter_balloon;\\n        }\\n         return min;\\n    }\\n```\n```\\nfunction maxNumberOfBalloons(text) {\\n    let counter_balloons = [0, 0, 0, 0, 0];\\n    let balloon = \"balon\";\\n    for (let i = 0; i < text.length; i++) {\\n        let index = balloon.indexOf(text[i]);\\n        if (index != -1) counter_balloons[index]++;\\n    }\\n    counter_balloons[2]= Math.floor(counter_balloons[2]/2);\\n    counter_balloons[3]= Math.floor(counter_balloons[3]/2);\\n    return Math.min.apply(Math, counter_balloons);\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1460881,
                "title": "c-unordered-map-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) \\n    {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            mp[text[i]]++;\\n        }\\n        int ans=INT_MAX;\\n        ans=min(ans,mp[\\'b\\']);\\n        ans=min(ans,mp[\\'a\\']);\\n        ans=min(ans,mp[\\'l\\']/2);\\n        ans=min(ans,mp[\\'o\\']/2);\\n        ans=min(ans,mp[\\'n\\']);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) \\n    {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<text.length();i++)\\n        {\\n            mp[text[i]]++;\\n        }\\n        int ans=INT_MAX;\\n        ans=min(ans,mp[\\'b\\']);\\n        ans=min(ans,mp[\\'a\\']);\\n        ans=min(ans,mp[\\'l\\']/2);\\n        ans=min(ans,mp[\\'o\\']/2);\\n        ans=min(ans,mp[\\'n\\']);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441918,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn max_number_of_balloons(text: String) -> i32 {\\n        use std::collections::HashMap;\\n        \\n        let mut counter: HashMap<char, i32> = \"balloon\".chars().map(|c| (c, 0)).collect();\\n\\n        text.chars().for_each(|c| {\\n            counter.entry(c).and_modify(|e| *e += 1);\\n        });\\n\\n        counter\\n            .iter()\\n            .map(|(&c, &num)| num / if \"lo\".contains(c) { 2 } else { 1 })\\n            .min()\\n            .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_number_of_balloons(text: String) -> i32 {\\n        use std::collections::HashMap;\\n        \\n        let mut counter: HashMap<char, i32> = \"balloon\".chars().map(|c| (c, 0)).collect();\\n\\n        text.chars().for_each(|c| {\\n            counter.entry(c).and_modify(|e| *e += 1);\\n        });\\n\\n        counter\\n            .iter()\\n            .map(|(&c, &num)| num / if \"lo\".contains(c) { 2 } else { 1 })\\n            .min()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276275,
                "title": "python-one-shot-code",
                "content": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, s):\\n        return min(s.count(\"b\"),s.count(\"a\"),s.count(\"l\")//2,s.count(\"o\")//2,s.count(\"n\"))\\n```\\n\\nRuntime: 12 ms, faster than 99.38% of Python online submissions for Maximum Number of Balloons.\\nMemory Usage: 13.9 MB, less than 10.94% of Python online submissions for Maximum Number of Balloons.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, s):\\n        return min(s.count(\"b\"),s.count(\"a\"),s.count(\"l\")//2,s.count(\"o\")//2,s.count(\"n\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136712,
                "title": "1ms-simple-and-faster-than-100",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n      int arr[]=new int[26];\\n        for(char c : text.toCharArray()) arr[c-\\'a\\']++;\\n        arr[\\'l\\'-\\'a\\']/=2;\\n        arr[\\'o\\'-\\'a\\']/=2;\\n        int res=Integer.MAX_VALUE;\\n        char a[]=new char[]{\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\'};\\n        for(char c : a) res=Math.min(res,arr[c-\\'a\\']);\\n        return res;\\n    }\\n}\\n```\\nTIME : O(n)\\nSPACE : O(1)\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n      int arr[]=new int[26];\\n        for(char c : text.toCharArray()) arr[c-\\'a\\']++;\\n        arr[\\'l\\'-\\'a\\']/=2;\\n        arr[\\'o\\'-\\'a\\']/=2;\\n        int res=Integer.MAX_VALUE;\\n        char a[]=new char[]{\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\'};\\n        for(char c : a) res=Math.min(res,arr[c-\\'a\\']);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588369,
                "title": "easy-solution-python",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        \\n        \\n        word = [\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\']\\n        \\n        dict_ = {i:0 for i in word}\\n        \\n        for i in range(len(text)):\\n            if(text[i] in dict_):\\n                dict_[text[i]] +=1\\n                \\n        \\n        l_count = dict_[\\'l\\'] // 2\\n        o_count = dict_[\\'o\\'] // 2\\n        b_count = dict_[\\'b\\']\\n        a_count = dict_[\\'a\\']\\n        n_count = dict_[\\'n\\']\\n        \\n        \\n        return min(l_count,o_count,a_count,b_count,n_count)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        \\n        \\n        word = [\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\']\\n        \\n        dict_ = {i:0 for i in word}\\n        \\n        for i in range(len(text)):\\n            if(text[i] in dict_):\\n                dict_[text[i]] +=1\\n                \\n        \\n        l_count = dict_[\\'l\\'] // 2\\n        o_count = dict_[\\'o\\'] // 2\\n        b_count = dict_[\\'b\\']\\n        a_count = dict_[\\'a\\']\\n        n_count = dict_[\\'n\\']\\n        \\n        \\n        return min(l_count,o_count,a_count,b_count,n_count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478585,
                "title": "c-no-loops-or-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int num = count(text.begin(),text.end(),\\'b\\');\\n        num = min(num,(int)count(text.begin(),text.end(),\\'a\\'));\\n        num = min(num,(int)count(text.begin(),text.end(),\\'l\\')/2);\\n        num = min(num,(int)count(text.begin(),text.end(),\\'o\\')/2);\\n        num = min(num,(int)count(text.begin(),text.end(),\\'n\\'));\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int num = count(text.begin(),text.end(),\\'b\\');\\n        num = min(num,(int)count(text.begin(),text.end(),\\'a\\'));\\n        num = min(num,(int)count(text.begin(),text.end(),\\'l\\')/2);\\n        num = min(num,(int)count(text.begin(),text.end(),\\'o\\')/2);\\n        num = min(num,(int)count(text.begin(),text.end(),\\'n\\'));\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400955,
                "title": "python-beats-98-25-12-ms-example-explanation",
                "content": "\\n```\\ndef maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        word = \"balloon\"\\n        return min(text.count(key)//word.count(key) for key in set(word))\\n```\\n\\nExample:\\nword = \"balloon\"\\nset(word) = \"balon\"\\ntext = \"nlaebolko\"\\n\\nNow for every character (ch) in set(word), it will find text.count(ch) // word.count(ch).\\nso,\\ntext.count(\\'b\\') // word.count(\\'b\\') = 1 // 1 = 1\\ntext.count(\\'a\\') // word.count(\\'a\\') = 1 // 1 = 1\\ntext.count(\\'l\\') // word.count(\\'l\\') = 2 // 2 = 1\\ntext.count(\\'o\\') // word.count(\\'o\\') = 2 // 2 = 1\\ntext.count(\\'n\\') // word.count(\\'n\\') = 1 // 1 = 1\\n\\nand then minimum of all the above calculated values. \\n\\nTime: O(26 * N) = O(N), N = length of the text. There would be at max 26 keys in set(word) and for each key we find count which iterates over whole text. \\n\\nSpace: O(1) \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        word = \"balloon\"\\n        return min(text.count(key)//word.count(key) for key in set(word))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395011,
                "title": "python-simple-solution",
                "content": "```\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        c = collections.Counter(text)\\n        return min(c[\"b\"], c[\"a\"], c[\"l\"] / 2, c[\"o\"] / 2, c[\"n\"])\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        c = collections.Counter(text)\\n        return min(c[\"b\"], c[\"a\"], c[\"l\"] / 2, c[\"o\"] / 2, c[\"n\"])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 392450,
                "title": "javascript",
                "content": "```\\nvar countChars = function(str) {\\n    const map = {};\\n    for (let char of str) {\\n        map[char] = map[char] + 1 || 1;\\n    }\\n    return map;\\n}\\n\\nvar maxNumberOfBalloons = function(text) {\\n    const chars = countChars(text);\\n    return Math.min(\\n        chars.b,\\n        chars.a,\\n        Math.floor(chars.l / 2),\\n        Math.floor(chars.o / 2),\\n        chars.n\\n    ) || 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countChars = function(str) {\\n    const map = {};\\n    for (let char of str) {\\n        map[char] = map[char] + 1 || 1;\\n    }\\n    return map;\\n}\\n\\nvar maxNumberOfBalloons = function(text) {\\n    const chars = countChars(text);\\n    return Math.min(\\n        chars.b,\\n        chars.a,\\n        Math.floor(chars.l / 2),\\n        Math.floor(chars.o / 2),\\n        chars.n\\n    ) || 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382631,
                "title": "python-2-lines-with-counter",
                "content": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        x = collections.Counter(text)\\n        return min(x[\\'b\\'], x[\\'a\\'], x[\\'l\\']//2, x[\\'o\\']//2, x[\\'n\\'])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        x = collections.Counter(text)\\n        return min(x[\\'b\\'], x[\\'a\\'], x[\\'l\\']//2, x[\\'o\\']//2, x[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658234,
                "title": "c-easy-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        \\n        //time complexity - O(n)\\n        //space complexity - O(1)\\n\\n        // find the frequency for all characters in balloon string - constant time opertaion\\n        vector<int> balloonFreq(26,0);\\n        string target = \"balloon\";\\n        for(int i=0; i <target.size(); i++) {\\n            balloonFreq[target[i]-\\'a\\']++;\\n        }\\n\\n        // find the frequency for all characters in text string\\n        vector<int> textFreq(26, 0);\\n         for(int i=0; i <text.size(); i++) {\\n            textFreq[text[i]-\\'a\\']++;\\n        }\\n\\n        //find factor the divisiblity factor of the frequency of character in  text with that of balloon        \\n        \\n        vector<int> factorFreq(26, 0);\\n        int minFactor = INT_MAX;\\n        for(int i=0; i <factorFreq.size(); i++) {\\n            // case where the text string does not contain the frequency to even form balloon single time\\n            if(textFreq[i]==0 && balloonFreq[i]!=0) return 0;\\n            \\n            // case - text = bbaallloon =>\\n            //a freq 2 which means we can have max balloon string 2 times in text\\n             //b freq 2,  which means we can have max balloon string 2 times in text\\n            //l freq 3, the in target string l freq 2 , which means we now have max 1 chance to form balloon target.\\n            else if(textFreq[i]!=0 && balloonFreq[i]!=0) {\\n                factorFreq[i] = textFreq[i]/balloonFreq[i];\\n                minFactor = min(minFactor, factorFreq[i]);\\n            }\\n        }\\n\\n        return minFactor;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        \\n        //time complexity - O(n)\\n        //space complexity - O(1)\\n\\n        // find the frequency for all characters in balloon string - constant time opertaion\\n        vector<int> balloonFreq(26,0);\\n        string target = \"balloon\";\\n        for(int i=0; i <target.size(); i++) {\\n            balloonFreq[target[i]-\\'a\\']++;\\n        }\\n\\n        // find the frequency for all characters in text string\\n        vector<int> textFreq(26, 0);\\n         for(int i=0; i <text.size(); i++) {\\n            textFreq[text[i]-\\'a\\']++;\\n        }\\n\\n        //find factor the divisiblity factor of the frequency of character in  text with that of balloon        \\n        \\n        vector<int> factorFreq(26, 0);\\n        int minFactor = INT_MAX;\\n        for(int i=0; i <factorFreq.size(); i++) {\\n            // case where the text string does not contain the frequency to even form balloon single time\\n            if(textFreq[i]==0 && balloonFreq[i]!=0) return 0;\\n            \\n            // case - text = bbaallloon =>\\n            //a freq 2 which means we can have max balloon string 2 times in text\\n             //b freq 2,  which means we can have max balloon string 2 times in text\\n            //l freq 3, the in target string l freq 2 , which means we now have max 1 chance to form balloon target.\\n            else if(textFreq[i]!=0 && balloonFreq[i]!=0) {\\n                factorFreq[i] = textFreq[i]/balloonFreq[i];\\n                minFactor = min(minFactor, factorFreq[i]);\\n            }\\n        }\\n\\n        return minFactor;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561328,
                "title": "js-solution-using-map-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = function(text) {\\n    const map = {};\\n    const balloon = \\'balloon\\';\\n    let count = 0;\\n    for(let i = 0; i < text.length; i++) {\\n        map[text[i]] = map[text[i]] > 0 ? map[text[i]] + 1 : 1;\\n    }\\n\\n    while(true) {\\n        for(let i = 0; i < balloon.length; i++) {\\n            if(map[balloon[i]] > 0) {\\n                map[balloon[i]]--;\\n            } else {\\n                return count;\\n            }\\n        }\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @return {number}\\n */\\nvar maxNumberOfBalloons = function(text) {\\n    const map = {};\\n    const balloon = \\'balloon\\';\\n    let count = 0;\\n    for(let i = 0; i < text.length; i++) {\\n        map[text[i]] = map[text[i]] > 0 ? map[text[i]] + 1 : 1;\\n    }\\n\\n    while(true) {\\n        for(let i = 0; i < balloon.length; i++) {\\n            if(map[balloon[i]] > 0) {\\n                map[balloon[i]]--;\\n            } else {\\n                return count;\\n            }\\n        }\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3296463,
                "title": "easy-c-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<text.length();i++)\\n        mp[text[i]]++;\\n    while(1){\\n        string a=\"balloon\";\\n        int i=0,l=0;\\n for(i=0;i<a.length();i++){\\n     if(mp[a[i]]>0){\\n         mp[a[i]]--;\\n     }else{\\nl=1;\\n         break;\\n     }\\n }\\n if(i==a.length()){\\n     ans++;\\n }\\n if(l==1){\\n     break;\\n }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<text.length();i++)\\n        mp[text[i]]++;\\n    while(1){\\n        string a=\"balloon\";\\n        int i=0,l=0;\\n for(i=0;i<a.length();i++){\\n     if(mp[a[i]]>0){\\n         mp[a[i]]--;\\n     }else{\\nl=1;\\n         break;\\n     }\\n }\\n if(i==a.length()){\\n     ans++;\\n }\\n if(l==1){\\n     break;\\n }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143535,
                "title": "java-o-n-k-using-alphabet-array-solution",
                "content": "# Complexity\\n- Time complexity: O(N + K), where N - length of given String, K - number of occurences of \"balloon\".\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int[] balloonAlph;\\n    public int maxNumberOfBalloons(String text) {\\n        if (text.length() < 7) return 0;\\n        int[] alphabet = new int[26];\\n        for (char c : text.toCharArray()) alphabet[c - \\'a\\']++;\\n        balloonAlph = balloonAlph == null ? createBalloonAlph() : balloonAlph;\\n        int count = 0;\\n        while (containsBalloon(alphabet)) count++;\\n        return count;\\n    }\\n\\n    private boolean containsBalloon(int[] alphabet) {\\n        for (int i = 0; i < balloonAlph.length; i++) {\\n            int count = balloonAlph[i], countA = alphabet[i];\\n            if (countA < count) return false;\\n            else alphabet[i] -= count;\\n        }\\n        return true;\\n    }\\n\\n    private int[] createBalloonAlph() {\\n        String s = \"balloon\";\\n        int[] alphabet = new int[26];\\n        for (char c : s.toCharArray()) alphabet[c - \\'a\\']++;\\n        return alphabet;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] balloonAlph;\\n    public int maxNumberOfBalloons(String text) {\\n        if (text.length() < 7) return 0;\\n        int[] alphabet = new int[26];\\n        for (char c : text.toCharArray()) alphabet[c - \\'a\\']++;\\n        balloonAlph = balloonAlph == null ? createBalloonAlph() : balloonAlph;\\n        int count = 0;\\n        while (containsBalloon(alphabet)) count++;\\n        return count;\\n    }\\n\\n    private boolean containsBalloon(int[] alphabet) {\\n        for (int i = 0; i < balloonAlph.length; i++) {\\n            int count = balloonAlph[i], countA = alphabet[i];\\n            if (countA < count) return false;\\n            else alphabet[i] -= count;\\n        }\\n        return true;\\n    }\\n\\n    private int[] createBalloonAlph() {\\n        String s = \"balloon\";\\n        int[] alphabet = new int[26];\\n        for (char c : s.toCharArray()) alphabet[c - \\'a\\']++;\\n        return alphabet;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869075,
                "title": "java-hashmap-arraylist-8ms-brute-force",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        if(text.length()<7) return 0;\\n        HashMap<Character,Integer> hp = new HashMap();\\n        ArrayList<Character> al = new ArrayList(Arrays.asList(\\'b\\',\\'a\\',\\'l\\',\\'l\\',\\'o\\',\\'o\\',\\'n\\'));\\n        \\n        for(int i=0;i<text.length();i++){\\n            char c = text.charAt(i);\\n            if(al.contains(c)){\\n                if(hp.containsKey(c)){\\n                    hp.put(c,hp.get(c)+1);\\n                }else{\\n                    hp.put(c,1);\\n                }\\n            }\\n        }\\n         for(int i=0;i<al.size();i++){\\n             if(!hp.containsKey(al.get(i))) return 0;\\n         }\\n               int min=Integer.MAX_VALUE;\\n               for(char x: hp.keySet()){\\n                 if(x==\\'l\\' || x==\\'o\\') min = Math.min(min,hp.get(x)/2);\\n                 else min = Math.min(min,hp.get(x));\\n               }\\n               for(char x: hp.keySet()){\\n                   if(hp.get(x)<min) return 0;\\n               }\\n        return min;\\n}\\n               }\\n```\\n![image](https://assets.leetcode.com/users/images/c6ae3da6-285e-430d-af3c-d4ae42deb2c8_1669966524.9816716.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        if(text.length()<7) return 0;\\n        HashMap<Character,Integer> hp = new HashMap();\\n        ArrayList<Character> al = new ArrayList(Arrays.asList(\\'b\\',\\'a\\',\\'l\\',\\'l\\',\\'o\\',\\'o\\',\\'n\\'));\\n        \\n        for(int i=0;i<text.length();i++){\\n            char c = text.charAt(i);\\n            if(al.contains(c)){\\n                if(hp.containsKey(c)){\\n                    hp.put(c,hp.get(c)+1);\\n                }else{\\n                    hp.put(c,1);\\n                }\\n            }\\n        }\\n         for(int i=0;i<al.size();i++){\\n             if(!hp.containsKey(al.get(i))) return 0;\\n         }\\n               int min=Integer.MAX_VALUE;\\n               for(char x: hp.keySet()){\\n                 if(x==\\'l\\' || x==\\'o\\') min = Math.min(min,hp.get(x)/2);\\n                 else min = Math.min(min,hp.get(x));\\n               }\\n               for(char x: hp.keySet()){\\n                   if(hp.get(x)<min) return 0;\\n               }\\n        return min;\\n}\\n               }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850850,
                "title": "c-o-n-easy-short-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mp;\\n        for(int i = 0 ; i < text.length(); i++)\\n            mp[text[i]]++;\\n\\t\\t\\t\\n        int count = 0;\\n        while(mp[\\'b\\'] >= 1 and mp[\\'a\\'] >= 1 and mp[\\'l\\'] >= 2 and mp[\\'o\\'] >= 2 and mp[\\'n\\'] >= 1){\\n            count++;\\n            mp[\\'b\\']--;\\n            mp[\\'a\\']--;\\n            mp[\\'l\\']--;\\n            mp[\\'l\\']--;\\n            mp[\\'o\\']--;\\n            mp[\\'o\\']--;\\n            mp[\\'n\\']--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mp;\\n        for(int i = 0 ; i < text.length(); i++)\\n            mp[text[i]]++;\\n\\t\\t\\t\\n        int count = 0;\\n        while(mp[\\'b\\'] >= 1 and mp[\\'a\\'] >= 1 and mp[\\'l\\'] >= 2 and mp[\\'o\\'] >= 2 and mp[\\'n\\'] >= 1){\\n            count++;\\n            mp[\\'b\\']--;\\n            mp[\\'a\\']--;\\n            mp[\\'l\\']--;\\n            mp[\\'l\\']--;\\n            mp[\\'o\\']--;\\n            mp[\\'o\\']--;\\n            mp[\\'n\\']--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830325,
                "title": "easiest-approach-shortest-solution-only-3-steps-beginner-friendly",
                "content": "# Only 3 Steps\\n1.  declare an hashmap, get the frequency of all char of string\\n2.  have a loop and increase the coun till u have char like \\'b\\', \\'a\\' \\'n\\' greater than 0 and char like \\'l\\' , \\'o\\' greater than 1 coz they are required twice in a balloon \\n3.  decrease them in the loop and return count after loop gets over\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char,int> m;\\n        int count = 0;\\n        for(auto it : text)m[it]++;\\n        while(m[\\'b\\'] > 0 and m[\\'a\\'] > 0 and m[\\'l\\'] > 1 and m[\\'o\\'] > 1 and m[\\'n\\'] > 0){\\n            m[\\'b\\']--;\\n            m[\\'a\\']--;\\n            m[\\'l\\']--;\\n            m[\\'l\\']--;\\n            m[\\'o\\']--;\\n            m[\\'o\\']--;\\n            m[\\'n\\']--;\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n ## LIKED IT ?\\n## UPVOTE\\n\\u2728\\uD83D\\uDE80",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char,int> m;\\n        int count = 0;\\n        for(auto it : text)m[it]++;\\n        while(m[\\'b\\'] > 0 and m[\\'a\\'] > 0 and m[\\'l\\'] > 1 and m[\\'o\\'] > 1 and m[\\'n\\'] > 0){\\n            m[\\'b\\']--;\\n            m[\\'a\\']--;\\n            m[\\'l\\']--;\\n            m[\\'l\\']--;\\n            m[\\'o\\']--;\\n            m[\\'o\\']--;\\n            m[\\'n\\']--;\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826438,
                "title": "java-hashmap-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>(){{\\n            put(\\'b\\', 1); put(\\'a\\', 1);\\n            put(\\'l\\', 2); put(\\'o\\', 2);\\n            put(\\'n\\', 1);\\n        }};\\n\\n        for (char c : text.toCharArray()) {\\n            if (map2.containsKey(c)) {\\n                map1.put(c, map1.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n\\n        int count = text.length();\\n\\n        for (char c : map2.keySet()) {\\n            count = Math.min(count, map1.getOrDefault(c, 0) / map2.get(c));\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n\\n// SC: O(5) => O(1) \\n// - only the letters of \"balloon\" will be stored in the maps.\\n// - size of map would never exceed 5\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        Map<Character, Integer> map1 = new HashMap<>();\\n        Map<Character, Integer> map2 = new HashMap<>(){{\\n            put(\\'b\\', 1); put(\\'a\\', 1);\\n            put(\\'l\\', 2); put(\\'o\\', 2);\\n            put(\\'n\\', 1);\\n        }};\\n\\n        for (char c : text.toCharArray()) {\\n            if (map2.containsKey(c)) {\\n                map1.put(c, map1.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n\\n        int count = text.length();\\n\\n        for (char c : map2.keySet()) {\\n            count = Math.min(count, map1.getOrDefault(c, 0) / map2.get(c));\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n\\n// SC: O(5) => O(1) \\n// - only the letters of \"balloon\" will be stored in the maps.\\n// - size of map would never exceed 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754730,
                "title": "very-simple-c-faster-then-99-99-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) \\n    {\\n        string target = \"balloon\";\\n        //\"loonbalxballpoon\"    b a ll oo n     b a x y n   b a x y n b a x y n\\n\\n        //getting the frequencies of the target string\\n        vector<int>v1(26,0);\\n        for(int i=0;i<target.length();i++)\\n        {\\n            char ch = target[i];\\n            v1[ch-\\'a\\']++;\\n        }\\n        //getting all the frequencies of the s string\\n        vector<int>v2(26,0);\\n        for(int i=0;i<s.length();i++)  //all the occurence of the s string\\n        {\\n            char ch = s[i];\\n            v2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            //considering multiple occurecne ones only by deviding\\n            if(v1[i]==0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                v2[i] = v2[i] / v1[i];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        unordered_set<char>st(target.begin(),target.end());\\n        for(auto ch : st)\\n        {\\n            int val = ch - \\'a\\';\\n            ans=min(ans,v2[val]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) \\n    {\\n        string target = \"balloon\";\\n        //\"loonbalxballpoon\"    b a ll oo n     b a x y n   b a x y n b a x y n\\n\\n        //getting the frequencies of the target string\\n        vector<int>v1(26,0);\\n        for(int i=0;i<target.length();i++)\\n        {\\n            char ch = target[i];\\n            v1[ch-\\'a\\']++;\\n        }\\n        //getting all the frequencies of the s string\\n        vector<int>v2(26,0);\\n        for(int i=0;i<s.length();i++)  //all the occurence of the s string\\n        {\\n            char ch = s[i];\\n            v2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            //considering multiple occurecne ones only by deviding\\n            if(v1[i]==0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                v2[i] = v2[i] / v1[i];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        unordered_set<char>st(target.begin(),target.end());\\n        for(auto ch : st)\\n        {\\n            int val = ch - \\'a\\';\\n            ans=min(ans,v2[val]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389105,
                "title": "c-simple-and-clean-solution",
                "content": "**Please upvote if ti helped you !!!\\nHappy Coding :)**\\n```\\nint maxNumberOfBalloons(string text) \\n    {\\n        int count=0;\\n        map<char,int> mp;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            mp[text[i]]++;\\n        }\\n        \\n        return min(mp[\\'b\\'],min(mp[\\'a\\'],min(mp[\\'l\\']/2,min(mp[\\'o\\']/2,mp[\\'n\\']))));\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) \\n    {\\n        int count=0;\\n        map<char,int> mp;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            mp[text[i]]++;\\n        }\\n        \\n        return min(mp[\\'b\\'],min(mp[\\'a\\'],min(mp[\\'l\\']/2,min(mp[\\'o\\']/2,mp[\\'n\\']))));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1800282,
                "title": "maximum-number-of-balloons",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n    \\n        int arr[]=new int[5];\\n        for(int i=0;i<text.length();i++){\\n            if(text.charAt(i)==\\'b\\')\\n                arr[0]=arr[0]+1;\\n             else if(text.charAt(i)==\\'a\\')\\n                arr[1]=arr[1]+1;\\n             else if(text.charAt(i)==\\'l\\')\\n                arr[2]=arr[2]+1;\\n             else if(text.charAt(i)==\\'o\\')\\n                arr[3]=arr[3]+1;\\n             else if(text.charAt(i)==\\'n\\')\\n                arr[4]=arr[4]+1;\\n        }\\n        arr[2]=arr[2]/2;\\n        arr[3]=arr[3]/2;\\n        int min=10000;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]<min)\\n                min=Math.min(min,arr[i]);\\n        }\\n        return min;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n    \\n        int arr[]=new int[5];\\n        for(int i=0;i<text.length();i++){\\n            if(text.charAt(i)==\\'b\\')\\n                arr[0]=arr[0]+1;\\n             else if(text.charAt(i)==\\'a\\')\\n                arr[1]=arr[1]+1;\\n             else if(text.charAt(i)==\\'l\\')\\n                arr[2]=arr[2]+1;\\n             else if(text.charAt(i)==\\'o\\')\\n                arr[3]=arr[3]+1;\\n             else if(text.charAt(i)==\\'n\\')\\n                arr[4]=arr[4]+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1677698,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        int b=count(s.begin(),s.end(),\\'b\\');\\n        int a=count(s.begin(),s.end(),\\'a\\');\\n        int l=count(s.begin(),s.end(),\\'l\\');\\n        int o=count(s.begin(),s.end(),\\'o\\');\\n        int n=count(s.begin(),s.end(),\\'n\\');\\n        \\n        vector<int> v{b,a,l/2,o/2,n};\\n        sort(v.begin(),v.end());\\n        return v.front();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        int b=count(s.begin(),s.end(),\\'b\\');\\n        int a=count(s.begin(),s.end(),\\'a\\');\\n        int l=count(s.begin(),s.end(),\\'l\\');\\n        int o=count(s.begin(),s.end(),\\'o\\');\\n        int n=count(s.begin(),s.end(),\\'n\\');\\n        \\n        vector<int> v{b,a,l/2,o/2,n}",
                "codeTag": "Java"
            },
            {
                "id": 1542293,
                "title": "3-line-simple-solution-python",
                "content": "```\\n#Import Counter\\nfrom collections import Counter\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        #Use Counter to create a dictionary with count of all letters\\n\\t\\tletters = Counter(text)\\n        \\n\\t\\t#Find the minimum of all 5 letters dividing by 2 for l and o since they are used twice in the word balloon\\n        return min(letters[\\'b\\'],letters[\\'a\\'],letters[\\'l\\']//2, letters[\\'o\\']//2, letters[\\'n\\'])\\n```",
                "solutionTags": [],
                "code": "```\\n#Import Counter\\nfrom collections import Counter\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        #Use Counter to create a dictionary with count of all letters\\n\\t\\tletters = Counter(text)\\n        \\n\\t\\t#Find the minimum of all 5 letters dividing by 2 for l and o since they are used twice in the word balloon\\n        return min(letters[\\'b\\'],letters[\\'a\\'],letters[\\'l\\']//2, letters[\\'o\\']//2, letters[\\'n\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516161,
                "title": "python-super-easy",
                "content": "def maxNumberOfBalloons(self, text: str) -> int:\\n        b = text.count(\\'b\\')\\n        a = text.count(\\'a\\')\\n        l = text.count(\\'l\\')//2\\n        o = text.count(\\'o\\')//2\\n        n = text.count(\\'n\\')\\n        return min(b,a,l,o,n)",
                "solutionTags": [],
                "code": "def maxNumberOfBalloons(self, text: str) -> int:\\n        b = text.count(\\'b\\')\\n        a = text.count(\\'a\\')\\n        l = text.count(\\'l\\')//2\\n        o = text.count(\\'o\\')//2\\n        n = text.count(\\'n\\')\\n        return min(b,a,l,o,n)",
                "codeTag": "Python3"
            },
            {
                "id": 1461323,
                "title": "maximum-number-of-balloons-3-line-code-c",
                "content": "```\\nint maxNumberOfBalloons(string text) {\\n        unordered_map<char, int>mp;\\n        for(char x: text) mp[x]++;\\n        int x = min(min(mp[\\'o\\'],mp[\\'l\\'])/2, min(mp[\\'b\\'],min(mp[\\'a\\'],mp[\\'n\\'])));\\n        if(mp[\\'o\\'] >= 2*x && mp[\\'l\\'] >= 2*x)    return x;\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        unordered_map<char, int>mp;\\n        for(char x: text) mp[x]++;\\n        int x = min(min(mp[\\'o\\'],mp[\\'l\\'])/2, min(mp[\\'b\\'],min(mp[\\'a\\'],mp[\\'n\\'])));\\n        if(mp[\\'o\\'] >= 2*x && mp[\\'l\\'] >= 2*x)    return x;\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460909,
                "title": "c-single-pass-minimum-memory-solution-explained-100-time-99-space",
                "content": "This problem boils down to a frequency count, with a bit of extra logic for double words (`\\'l\\'` and `\\'o\\'`s).\\n\\nIn order to solve it, I gave myself the extra challenge of using as little memory as possible, so we will use a simple array `matches` to store the frequancy of each meaningful character we encouter and set all its values to `0`.\\n\\nWe will then proceed to parse `text` and for each character `c` that matches one of our cases, we will update `matches` accordingly.\\n\\nAfter that, we can just `return` the minimum across all the values, after remembering we need to divide by `2` the values of the frequencies of `\\'l\\'` and `\\'o\\'`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n\\t\\t// support variables\\n        int matches[5] = {};\\n\\t\\t// parsing text\\n        for (char c: text) {\\n            switch(c) {\\n                case \\'b\\':\\n                    matches[0]++;\\n                    break;\\n                case \\'a\\':\\n                    matches[1]++;\\n                    break;\\n                case \\'l\\':\\n                    matches[2]++;\\n                    break;\\n                case \\'o\\':\\n                    matches[3]++;\\n                    break;\\n                case \\'n\\':\\n                    matches[4]++;\\n                    break;\\n            }\\n        }\\n        return min(matches[0], min(matches[1], min(matches[2] >> 1, min(matches[3] >> 1, matches[4]))));\\n    }\\n};\\n```\\n\\nBut, wait a moment: all those nested `min`s might actually use a bit more memory?\\n\\nWell, regardless, I felt like playing a bit with bitwise operator a tad more, so I refactored in order to store the final result just in `matches[0]`, mindful that the only cases in which we want to divide the frequency are indexes `2` and `3`, which can are also the only one not giving us `0` when you do `i & 2`.\\n\\nAnd so I refactored the last bit, right after the loop:\\n\\n```cpp\\n        for (int i = 4; i; i--) matches[0] = min(matches[0], matches[i] >> ((i & 2) >> 1));\\n        return matches[0];\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n\\t\\t// support variables\\n        int matches[5] = {};\\n\\t\\t// parsing text\\n        for (char c: text) {\\n            switch(c) {\\n                case \\'b\\':\\n                    matches[0]++;\\n                    break;\\n                case \\'a\\':\\n                    matches[1]++;\\n                    break;\\n                case \\'l\\':\\n                    matches[2]++;\\n                    break;\\n                case \\'o\\':\\n                    matches[3]++;\\n                    break;\\n                case \\'n\\':\\n                    matches[4]++;\\n                    break;\\n            }\\n        }\\n        return min(matches[0], min(matches[1], min(matches[2] >> 1, min(matches[3] >> 1, matches[4]))));\\n    }\\n};\\n```\n```cpp\\n        for (int i = 4; i; i--) matches[0] = min(matches[0], matches[i] >> ((i & 2) >> 1));\\n        return matches[0];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460840,
                "title": "go-solution",
                "content": "```\\nfunc maxNumberOfBalloons(text string) int {\\n\\tm := [26]int{}\\n\\tfor i := range text {\\n\\t\\tm[text[i]-\\'a\\']++\\n\\t}\\n\\n\\tm[\\'l\\'-\\'a\\'] /= 2\\n\\tm[\\'o\\'-\\'a\\'] /= 2\\n\\n\\tmin := math.MaxInt32\\n\\tfor _, ch := range \"balon\" {\\n\\t\\tif s := m[ch-\\'a\\']; s < min {\\n\\t\\t\\tmin = s\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxNumberOfBalloons(text string) int {\\n\\tm := [26]int{}\\n\\tfor i := range text {\\n\\t\\tm[text[i]-\\'a\\']++\\n\\t}\\n\\n\\tm[\\'l\\'-\\'a\\'] /= 2\\n\\tm[\\'o\\'-\\'a\\'] /= 2\\n\\n\\tmin := math.MaxInt32\\n\\tfor _, ch := range \"balon\" {\\n\\t\\tif s := m[ch-\\'a\\']; s < min {\\n\\t\\t\\tmin = s\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460836,
                "title": "c-unordered-map-two-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int>mp;\\n        for(auto ch:text)\\n            mp[ch]++;\\n        \\n        /* soln 1\\n        int count=0;\\n        bool flag=true;\\n        while(flag)\\n        {\\n            if(mp[\\'b\\']>0 && mp[\\'a\\']>0 && mp[\\'l\\']>=2 && mp[\\'o\\']>=2 && mp[\\'n\\']>0)\\n            {\\n                count++;\\n                mp[\\'b\\']--;\\n                mp[\\'a\\']--;\\n                mp[\\'l\\']--;mp[\\'l\\']--;\\n                mp[\\'o\\']--;mp[\\'o\\']--;\\n                mp[\\'n\\']--;\\n            }\\n            else\\n                flag=false;\\n        }\\n        return count;\\n        */\\n        \\n        //Soln 2\\n        return min(mp[\\'b\\'], min(mp[\\'a\\'], min(mp[\\'l\\']/2, min(mp[\\'o\\']/2, mp[\\'n\\']))));\\n        \\n        \\n    }\\n};\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int>mp;\\n        for(auto ch:text)\\n            mp[ch]++;\\n        \\n        /* soln 1\\n        int count=0;\\n        bool flag=true;\\n        while(flag)\\n        {\\n            if(mp[\\'b\\']>0 && mp[\\'a\\']>0 && mp[\\'l\\']>=2 && mp[\\'o\\']>=2 && mp[\\'n\\']>0)\\n            {\\n                count++;\\n                mp[\\'b\\']--;\\n                mp[\\'a\\']--;\\n                mp[\\'l\\']--;mp[\\'l\\']--;\\n                mp[\\'o\\']--;mp[\\'o\\']--;\\n                mp[\\'n\\']--;\\n            }\\n            else\\n                flag=false;\\n        }\\n        return count;\\n        */\\n        \\n        //Soln 2\\n        return min(mp[\\'b\\'], min(mp[\\'a\\'], min(mp[\\'l\\']/2, min(mp[\\'o\\']/2, mp[\\'n\\']))));\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460795,
                "title": "max-num-of-balloons-c-o-n-runtime-explained",
                "content": "The intuition behind the solution is that the maximum number of shuffled subsequences of string *\"balloon\"* will be the minimum number of occurances of any character of the string *\"balloon\"* . So a simple traversal through the given input string *text* and keeping a count of all the usefull characters ie *\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\'* . and then iterating in the map for the minimum occuring character will give us the answer. \\n\\nReason behind dividing the occurances of letter \\'l\\' and \\'o\\' is becasue they are ocuuring twice in *\\'balloon\\'*, so say if there were 7 occurances of *\\'l\\'*,then there will be maximum of 3( floor(7/2) ) *\\'balloon\\'* strings possible. \\n\\n\\n```\\nint maxNumberOfBalloons(string text) {\\n        \\n        unordered_map<char, int> letters; \\n        letters.insert({\\'b\\', 0});\\n        letters.insert({\\'a\\', 0});\\n        letters.insert({\\'l\\', 0});\\n        letters.insert({\\'o\\', 0});\\n        letters.insert({\\'n\\', 0});\\n        \\n        for(int i=0; i<text.size(); i++)\\n        {\\n            switch(text[i])\\n            {\\n                case \\'b\\':\\n                case \\'a\\':\\n                case \\'l\\':\\n                case \\'o\\':\\n                case \\'n\\':\\n                    letters[text[i]]++;\\n                    break;\\n            }\\n        }\\n        \\n        letters[\\'l\\'] = letters[\\'l\\']/2;       //floor value of the division\\n        letters[\\'o\\'] = letters[\\'o\\']/2;       //floor value of the division\\n        \\n        int ans = INT_MAX; \\n        for(auto it = letters.begin(); it != letters.end(); it++)\\n            ans = min(it->second, ans);\\n        \\n        return ans;       \\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        \\n        unordered_map<char, int> letters; \\n        letters.insert({\\'b\\', 0});\\n        letters.insert({\\'a\\', 0});\\n        letters.insert({\\'l\\', 0});\\n        letters.insert({\\'o\\', 0});\\n        letters.insert({\\'n\\', 0});\\n        \\n        for(int i=0; i<text.size(); i++)\\n        {\\n            switch(text[i])\\n            {\\n                case \\'b\\':\\n                case \\'a\\':\\n                case \\'l\\':\\n                case \\'o\\':\\n                case \\'n\\':\\n                    letters[text[i]]++;\\n                    break;\\n            }\\n        }\\n        \\n        letters[\\'l\\'] = letters[\\'l\\']/2;       //floor value of the division\\n        letters[\\'o\\'] = letters[\\'o\\']/2;       //floor value of the division\\n        \\n        int ans = INT_MAX; \\n        for(auto it = letters.begin(); it != letters.end(); it++)\\n            ans = min(it->second, ans);\\n        \\n        return ans;       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460722,
                "title": "c-linq-two-liner",
                "content": "```csharp\\npublic int MaxNumberOfBalloons(string text)\\n{\\n    var frequencies = text.ToLookup(c => c);\\n    return \"balloon\".ToLookup(c => c).Min(g => frequencies[g.Key].Count() / g.Count());\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxNumberOfBalloons(string text)\\n{\\n    var frequencies = text.ToLookup(c => c);\\n    return \"balloon\".ToLookup(c => c).Min(g => frequencies[g.Key].Count() / g.Count());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403528,
                "title": "c-3-lines-of-code-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char, int>mp;\\n        for(auto &i : text)\\n            mp[i]++;\\n        return min({mp[\\'b\\'], mp[\\'a\\'], mp[\\'n\\'], mp[\\'o\\']/2, mp[\\'l\\']/2});\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map<char, int>mp;\\n        for(auto &i : text)\\n            mp[i]++;\\n        return min({mp[\\'b\\'], mp[\\'a\\'], mp[\\'n\\'], mp[\\'o\\']/2, mp[\\'l\\']/2});\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274774,
                "title": "concise-solution-3-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mm;\\n        for (char i : text) mm[i] += 1;\\n        return min(mm[\\'b\\'], min(mm[\\'a\\'], min(mm[\\'l\\']/2, min(mm[\\'o\\']/2, mm[\\'n\\']))));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char, int> mm;\\n        for (char i : text) mm[i] += 1;\\n        return min(mm[\\'b\\'], min(mm[\\'a\\'], min(mm[\\'l\\']/2, min(mm[\\'o\\']/2, mm[\\'n\\']))));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257853,
                "title": "constant-space-0-1-o-n-time-10-lines-of-code",
                "content": "``` \\nvar maxNumberOfBalloons = function(string) {\\nlet map = {\"b\":0, \"a\": 0, \"l\":0 ,\"o\":0 ,\"n\":0}; \\nfor(let i = 0; i < string.length; i++){\\n       if(map[string[i]] !== undefined){\\n        map[string[i]]++; \\n   } \\n};\\n map[\"l\"] = Math.floor(map[\"l\"] / 2)\\n map[\"o\"] = Math.floor(map[\"o\"] / 2)\\nlet allVals =  Object.values(map); \\nreturn Math.min(...allVals)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar maxNumberOfBalloons = function(string) {\\nlet map = {\"b\":0, \"a\": 0, \"l\":0 ,\"o\":0 ,\"n\":0}; \\nfor(let i = 0; i < string.length; i++){\\n       if(map[string[i]] !== undefined){\\n        map[string[i]]++; \\n   } \\n};\\n map[\"l\"] = Math.floor(map[\"l\"] / 2)\\n map[\"o\"] = Math.floor(map[\"o\"] / 2)\\nlet allVals =  Object.values(map); \\nreturn Math.min(...allVals)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1235069,
                "title": "java-clean-concise-optimal-code-1ms-time-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int[] count = new int[26];\\n        \\n        for (char c : text.toCharArray ()) {\\n            ++count[c - \\'a\\'];\\n        }\\n        \\n        int min = count[1];\\n        min = Math.min (min, count[0]);\\n        min = Math.min (min, count[11] / 2);\\n        min = Math.min (min, count[14] / 2);\\n        min = Math.min (min, count[13]);\\n        \\n        return min;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int[] count = new int[26];\\n        \\n        for (char c : text.toCharArray ()) {\\n            ++count[c - \\'a\\'];\\n        }\\n        \\n        int min = count[1];\\n        min = Math.min (min, count[0]);\\n        min = Math.min (min, count[11] / 2);\\n        min = Math.min (min, count[14] / 2);\\n        min = Math.min (min, count[13]);\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228957,
                "title": "python-3-1-line-faster-than-97",
                "content": "```\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return int(min(text.count(\"b\"),text.count(\"a\"),text.count(\"l\")//2,text.count(\"o\")//2,text.count(\"n\")))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        return int(min(text.count(\"b\"),text.count(\"a\"),text.count(\"l\")//2,text.count(\"o\")//2,text.count(\"n\")))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208118,
                "title": "easy-to-understand-and-efficient-solution-98",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n      b = text.count(\"b\")\\n      a = text.count(\"a\")\\n      l = text.count(\"l\")//2\\n      o = text.count(\"o\")//2\\n      n = text.count(\"n\")\\n      \\n            \\n      \\n      return min(b,a,l,o,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n      b = text.count(\"b\")\\n      a = text.count(\"a\")\\n      l = text.count(\"l\")//2\\n      o = text.count(\"o\")//2\\n      n = text.count(\"n\")\\n      \\n            \\n      \\n      return min(b,a,l,o,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169080,
                "title": "very-easy-java-solution",
                "content": "Very Easy Java Solution \\nHope this helps!!\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] letters = new int[5];\\n        int count = 0;\\n        \\n        for (int i = 0; i < text.length(); i++){\\n            if(text.charAt(i) == \\'b\\'){letters[0]++; }\\n            if(text.charAt(i) == \\'a\\'){letters[1]++; }\\n            if(text.charAt(i) == \\'l\\'){letters[2]++; }\\n            if(text.charAt(i) == \\'o\\'){letters[3]++; }\\n            if(text.charAt(i) == \\'n\\'){letters[4]++; }\\n        }\\n        \\n        while(letters[0]>=1 && letters[1]>=1 && letters[2]>=2 && letters[3]>=2 && letters[4] >= 1){\\n            count++;\\n            letters[0]--;\\n            letters[1]--;\\n            letters[2]-=2;\\n            letters[3]-=2;\\n            letters[4]--;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\nThe array is just used to represent the number of the specific characters are found in the string.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] letters = new int[5];\\n        int count = 0;\\n        \\n        for (int i = 0; i < text.length(); i++){\\n            if(text.charAt(i) == \\'b\\'){letters[0]++; }\\n            if(text.charAt(i) == \\'a\\'){letters[1]++; }\\n            if(text.charAt(i) == \\'l\\'){letters[2]++; }\\n            if(text.charAt(i) == \\'o\\'){letters[3]++; }\\n            if(text.charAt(i) == \\'n\\'){letters[4]++; }\\n        }\\n        \\n        while(letters[0]>=1 && letters[1]>=1 && letters[2]>=2 && letters[3]>=2 && letters[4] >= 1){\\n            count++;\\n            letters[0]--;\\n            letters[1]--;\\n            letters[2]-=2;\\n            letters[3]-=2;\\n            letters[4]--;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082563,
                "title": "python3-94-lesser-memory-dictionary-counter",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        temp = Counter(text)\\n        mini = sys.maxsize\\n        b = temp[\\'b\\']\\n        mini = min(b,mini)\\n        b = temp[\\'a\\']\\n        mini = min(b,mini)\\n        b = temp[\\'n\\']\\n        mini = min(b,mini)\\n        b = int(temp[\\'l\\']/2)\\n        mini = min(b,mini)\\n        b = int(temp[\\'o\\']/2)\\n        mini = min(b,mini)\\n        return mini\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        temp = Counter(text)\\n        mini = sys.maxsize\\n        b = temp[\\'b\\']\\n        mini = min(b,mini)\\n        b = temp[\\'a\\']\\n        mini = min(b,mini)\\n        b = temp[\\'n\\']\\n        mini = min(b,mini)\\n        b = int(temp[\\'l\\']/2)\\n        mini = min(b,mini)\\n        b = int(temp[\\'o\\']/2)\\n        mini = min(b,mini)\\n        return mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993909,
                "title": "easy-clear-solution-0ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        int occ[26]={0};\\n        int n=s.size();\\n        for(int i=0;i<n;i++)occ[s[i]-\\'a\\']++;\\n        return min({\\n            occ[\\'b\\'-\\'a\\'],occ[\\'a\\'-\\'a\\'],occ[\\'n\\'-\\'a\\'],occ[\\'l\\'-\\'a\\']/2,occ[\\'o\\'-\\'a\\']/2\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        int occ[26]={0};\\n        int n=s.size();\\n        for(int i=0;i<n;i++)occ[s[i]-\\'a\\']++;\\n        return min({\\n            occ[\\'b\\'-\\'a\\'],occ[\\'a\\'-\\'a\\'],occ[\\'n\\'-\\'a\\'],occ[\\'l\\'-\\'a\\']/2,occ[\\'o\\'-\\'a\\']/2\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984363,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        l=[]\\n        l.append(text.count(\\'b\\'))\\n        l.append(text.count(\\'a\\'))\\n        l.append(text.count(\\'l\\')//2)\\n        l.append(text.count(\\'o\\')//2)\\n        l.append(text.count(\\'n\\'))\\n        return(min(l))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        l=[]\\n        l.append(text.count(\\'b\\'))\\n        l.append(text.count(\\'a\\'))\\n        l.append(text.count(\\'l\\')//2)\\n        l.append(text.count(\\'o\\')//2)\\n        l.append(text.count(\\'n\\'))\\n        return(min(l))",
                "codeTag": "Java"
            },
            {
                "id": 971378,
                "title": "python-easy-soln",
                "content": "```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        s = set(\"balloon\")\\n\\n        d = {}\\n        for char in s:\\n            d[char] = d.get(char, 0)\\n        for char in text:\\n            if char in d:\\n                d[char] = d.get(char) + 1\\n        \\n        return min(d[\\'b\\'], d[\\'a\\'], d[\\'n\\'], d[\\'l\\']/2, d[\\'o\\']/2)\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        s = set(\"balloon\")\\n\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 948456,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        text = collections.Counter(text)\\n        return min(text[ch] // 2 if ch in \"lo\" else text[ch] for ch in \"balon\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        text = collections.Counter(text)\\n        return min(text[ch] // 2 if ch in \"lo\" else text[ch] for ch in \"balon\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893294,
                "title": "c-94",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(const string& text) {\\n        vector<int> v(5);\\n        for(auto i:text)\\n            switch(i) {\\n                case\\'b\\': ++v[0]; break;\\n                case\\'a\\': ++v[1]; break;\\n                case\\'l\\': ++v[2]; break;\\n                case\\'o\\': ++v[3]; break;\\n                case\\'n\\': ++v[4]; break;\\n            }\\n        v[2]/=2;\\n        v[3]/=2;\\n        return *min_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(const string& text) {\\n        vector<int> v(5);\\n        for(auto i:text)\\n            switch(i) {\\n                case\\'b\\': ++v[0]; break;\\n                case\\'a\\': ++v[1]; break;\\n                case\\'l\\': ++v[2]; break;\\n                case\\'o\\': ++v[3]; break;\\n                case\\'n\\': ++v[4]; break;\\n            }\\n        v[2]/=2;\\n        v[3]/=2;\\n        return *min_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888372,
                "title": "explained-easy-c-4ms-top-96",
                "content": "class Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        //if length of string will be less than 7 letters then it will be impossible to make the string \"balloon\" .\\n        if(text.length() < 7){return 0 ;}\\n        \\n       // taking a empty array to store occurance of letters \\n        int a[5] = {0,0,0,0,0} ;\\n        //checking for each alphabet if present \\n        for(char chars : text){\\n            if(chars == \\'b\\' ){\\n                a[0]++ ;\\n            }\\n            if(chars == \\'a\\' ){\\n                a[1]++ ;\\n            }\\n            if(chars == \\'l\\' ){\\n                a[2]++ ;\\n            }\\n            if(chars == \\'o\\' ){\\n                a[3]++ ;\\n            }\\n            if(chars == \\'n\\' ){\\n                a[4]++ ;\\n            }\\n            \\n        }\\n        //taking a integer variable answer to store the answer\\n        int answer = INT_MAX ;\\n        \\n        // checking occurence of letters \\'l\\' and \\'o\\'\\n        a[2] = int(a[2]/2) ; \\n        a[3] = int(a[3]/2) ;\\n        \\n        //checking the number of time \\'balloon\\' occurs\\n        for(int i = 0 ; i < 5 ; i++ ){\\n            if(answer > a[i]){\\n                answer = a[i] ;\\n            }\\n        }\\n        return answer;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        //if length of string will be less than 7 letters then it will be impossible to make the string \"balloon\" .\\n        if(text.length() < 7){return 0 ;}",
                "codeTag": "Java"
            },
            {
                "id": 870946,
                "title": "fastest-and-easiest-with-one-frequency-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int f[26]={};          //frequency array\\n        \\n        for(int i=0;i<text.size();i++)\\n            f[text[i]-\\'a\\']++;\\n\\n        return min({f[0],f[1],f[11]/2,f[13],f[14]/2});     //returning the minimum no of words that can be made\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int f[26]={};          //frequency array\\n        \\n        for(int i=0;i<text.size();i++)\\n            f[text[i]-\\'a\\']++;\\n\\n        return min({f[0],f[1],f[11]/2,f[13],f[14]/2});     //returning the minimum no of words that can be made\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860372,
                "title": "python-solution-easy",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        d = {\\'b\\':0,\\'a\\':0,\\'l\\':0,\\'o\\':0,\\'n\\':0}\\n        for item in text:\\n            if item in (\\'b\\',\\'a\\',\\'l\\',\\'l\\',\\'o\\',\\'o\\',\\'n\\'):\\n                d[item] += 1\\n        if len(d) < 5 or d[\\'l\\'] == 1 or d[\\'o\\'] == 1:\\n            return 0\\n        d[\\'l\\'] = int(d[\\'l\\'] / 2)\\n        d[\\'o\\'] = int(d[\\'o\\'] / 2)\\n        return min(d.values())",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        d = {\\'b\\':0,\\'a\\':0,\\'l\\':0,\\'o\\':0,\\'n\\':0}",
                "codeTag": "Java"
            },
            {
                "id": 817755,
                "title": "python3-simple-dictionary-implementation",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        h=dict({\\'b\\':0,\\'a\\':0,\\'l\\':0,\\'o\\':0,\\'n\\':0})\\n        for i in text: \\n            if i in [\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\']:\\n                h[i]+=1\\n        h[\\'o\\']//=2\\n        h[\\'l\\']//=2\\n        return min(h.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        h=dict({\\'b\\':0,\\'a\\':0,\\'l\\':0,\\'o\\':0,\\'n\\':0})\\n        for i in text: \\n            if i in [\\'b\\',\\'a\\',\\'l\\',\\'o\\',\\'n\\']:\\n                h[i]+=1\\n        h[\\'o\\']//=2\\n        h[\\'l\\']//=2\\n        return min(h.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800629,
                "title": "java-faster-than-100-commented-easy-code",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        //0-num B\\'s, 1-num L\\'s, 2-num A\\'s, 3-num O\\'s, 4-num N\\'s\\n        //L\\'s and O\\'s are odd indexes (only double letters)\\n        int[] balloon = new int[5];\\n        \\n        for(char c: text.toCharArray()){\\n            switch(c){\\n                case \\'b\\':\\n                    balloon[0]++;\\n                    break;\\n                case \\'l\\':\\n                    balloon[1]++;\\n                    break;\\n                case \\'a\\':\\n                    balloon[2]++;\\n                    break;\\n                case \\'o\\':\\n                    balloon[3]++;\\n                    break;\\n                case \\'n\\':\\n                    balloon[4]++;\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n        \\n        int min = balloon[0];\\n        for(int i=1; i<balloon.length; i++){\\n            int num = balloon[i];\\n            if(i%2!=0) num/=2;\\n            if(num < min) min = num;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        //0-num B\\'s, 1-num L\\'s, 2-num A\\'s, 3-num O\\'s, 4-num N\\'s\\n        //L\\'s and O\\'s are odd indexes (only double letters)\\n        int[] balloon = new int[5];\\n        \\n        for(char c: text.toCharArray()){\\n            switch(c){\\n                case \\'b\\':\\n                    balloon[0]++;\\n                    break;\\n                case \\'l\\':\\n                    balloon[1]++;\\n                    break;\\n                case \\'a\\':\\n                    balloon[2]++;\\n                    break;\\n                case \\'o\\':\\n                    balloon[3]++;\\n                    break;\\n                case \\'n\\':\\n                    balloon[4]++;\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n        \\n        int min = balloon[0];\\n        for(int i=1; i<balloon.length; i++){\\n            int num = balloon[i];\\n            if(i%2!=0) num/=2;\\n            if(num < min) min = num;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781802,
                "title": "python3-98-25-faster",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        balloon_dict = {}\\n        balloon_dict[\\'b\\'] = text.count(\\'b\\')\\n        balloon_dict[\\'a\\'] = text.count(\\'a\\')\\n        balloon_dict[\\'l\\'] = text.count(\\'l\\')\\n        balloon_dict[\\'o\\'] = text.count(\\'o\\')\\n        balloon_dict[\\'n\\'] = text.count(\\'n\\')\\n  \\n        \\n        return min(balloon_dict[\\'b\\'], balloon_dict[\\'a\\'], balloon_dict[\\'l\\'] // 2, balloon_dict[\\'o\\'] // 2, balloon_dict[\\'n\\'])\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        balloon_dict = {}\\n        balloon_dict[\\'b\\'] = text.count(\\'b\\')\\n        balloon_dict[\\'a\\'] = text.count(\\'a\\')\\n        balloon_dict[\\'l\\'] = text.count(\\'l\\')\\n        balloon_dict[\\'o\\'] = text.count(\\'o\\')\\n        balloon_dict[\\'n\\'] = text.count(\\'n\\')\\n  \\n        \\n        return min(balloon_dict[\\'b\\'], balloon_dict[\\'a\\'], balloon_dict[\\'l\\'] // 2, balloon_dict[\\'o\\'] // 2, balloon_dict[\\'n\\'])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 762459,
                "title": "java-char-count",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] count = new int[26];\\n        for(int i = 0; i < text.length(); i ++) \\n            count[text.charAt(i) - 97] ++ ;\\n        int b = count[1], a = count[0], l = count[11] / 2, o = count[14] / 2, n = count[13];\\n        int ba = Math.min(b, a), lo = Math.min(l, o);\\n        int balo = Math.min(ba, lo);\\n        return Math.min(balo, n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] count = new int[26];\\n        for(int i = 0; i < text.length(); i ++) \\n            count[text.charAt(i) - 97] ++ ;\\n        int b = count[1], a = count[0], l = count[11] / 2, o = count[14] / 2, n = count[13];\\n        int ba = Math.min(b, a), lo = Math.min(l, o);\\n        int balo = Math.min(ba, lo);\\n        return Math.min(balo, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742842,
                "title": "java-hashset-and-map",
                "content": "```\\n    public int maxNumberOfBalloons(String text) {\\n        int res = Integer.MAX_VALUE;\\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> dbl = Set.of(\\'l\\', \\'o\\'), single = Set.of(\\'b\\', \\'a\\', \\'n\\'), all = Set.of(\\'b\\', \\'a\\', \\'n\\', \\'l\\', \\'o\\');\\n        for (char c : text.toCharArray()) {\\n            if (all.contains(c)) map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        for (char c : single) {\\n            res = Math.min(res, map.getOrDefault(c, 0));\\n        }\\n        for (char c : dbl) {\\n            res = Math.min(res, map.getOrDefault(c, 0) / 2);\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxNumberOfBalloons(String text) {\\n        int res = Integer.MAX_VALUE;\\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> dbl = Set.of(\\'l\\', \\'o\\'), single = Set.of(\\'b\\', \\'a\\', \\'n\\'), all = Set.of(\\'b\\', \\'a\\', \\'n\\', \\'l\\', \\'o\\');\\n        for (char c : text.toCharArray()) {\\n            if (all.contains(c)) map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        for (char c : single) {\\n            res = Math.min(res, map.getOrDefault(c, 0));\\n        }\\n        for (char c : dbl) {\\n            res = Math.min(res, map.getOrDefault(c, 0) / 2);\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717864,
                "title": "c-o-n-time-o-1-space-8-ms",
                "content": "***Runtime: 8 ms, faster than 69.88% of C++ online submissions for Maximum Number of Balloons.\\nMemory Usage: 6.7 MB, less than 61.43% of C++ online submissions for Maximum Number of Balloons.***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int b_count = 0,a_count = 0,l_count = 0,o_count = 0,n_count = 0;\\n        for(char& ch:text){\\n            switch(ch){\\n                case \\'b\\' : b_count++;   break;\\n                case \\'a\\' : a_count++;   break;\\n                case \\'o\\' : o_count++;   break;\\n                case \\'l\\' : l_count++;   break;\\n                case \\'n\\' : n_count++;   break;\\n            }\\n        }\\n        return min(b_count,min(min(a_count, n_count),min(l_count,o_count)/2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int b_count = 0,a_count = 0,l_count = 0,o_count = 0,n_count = 0;\\n        for(char& ch:text){\\n            switch(ch){\\n                case \\'b\\' : b_count++;   break;\\n                case \\'a\\' : a_count++;   break;\\n                case \\'o\\' : o_count++;   break;\\n                case \\'l\\' : l_count++;   break;\\n                case \\'n\\' : n_count++;   break;\\n            }\\n        }\\n        return min(b_count,min(min(a_count, n_count),min(l_count,o_count)/2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704716,
                "title": "java-simple-1ms-o-n-faster-than-100-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] map=new int[26];\\n        for(char c:text.toCharArray()){\\n            map[c-\\'a\\']++;\\n        }\\n        return Math.min(map[\\'b\\'-\\'a\\'], Math.min(map[\\'a\\'-\\'a\\'], Math.min(map[\\'n\\'-\\'a\\'], Math.min(map[\\'l\\'-\\'a\\']/2, map[\\'o\\'-\\'a\\']/2))));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int[] map=new int[26];\\n        for(char c:text.toCharArray()){\\n            map[c-\\'a\\']++;\\n        }\\n        return Math.min(map[\\'b\\'-\\'a\\'], Math.min(map[\\'a\\'-\\'a\\'], Math.min(map[\\'n\\'-\\'a\\'], Math.min(map[\\'l\\'-\\'a\\']/2, map[\\'o\\'-\\'a\\']/2))));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658342,
                "title": "python-87-77-hash-table-int",
                "content": "```\\ndef maxNumberOfBalloons(self, text: str) -> int:\\n        d = {\\'b\\': 0, \\'a\\': 0, \\'l\\': 0, \\'o\\': 0, \\'n\\': 0}\\n    \\n     \\n        for e in text:\\n            if e in d:\\n                if e == \\'l\\' or e == \\'o\\':\\n                    d[e] += 0.5\\n                else:\\n                    d[e] += 1\\n        \\n        return int(min(d.values()))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef maxNumberOfBalloons(self, text: str) -> int:\\n        d = {\\'b\\': 0, \\'a\\': 0, \\'l\\': 0, \\'o\\': 0, \\'n\\': 0}\\n    \\n     \\n        for e in text:\\n            if e in d:\\n                if e == \\'l\\' or e == \\'o\\':\\n                    d[e] += 0.5\\n                else:\\n                    d[e] += 1\\n        \\n        return int(min(d.values()))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 640096,
                "title": "short-and-simple-c-solution",
                "content": "```\\nint maxNumberOfBalloons(string text) {\\n        vector<int> v(5,0);\\n        for(int i:text){\\n            if(i==\\'b\\') ++v[0];\\n            if(i==\\'a\\') ++v[1];            \\n            if(i==\\'n\\') ++v[2];\\n            if(i==\\'o\\') ++v[3];\\n            if(i==\\'l\\') ++v[4];           \\n        }\\n        return min(*min_element(v.begin(),v.begin()+3),min(v[3],v[4])/2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        vector<int> v(5,0);\\n        for(int i:text){\\n            if(i==\\'b\\') ++v[0];\\n            if(i==\\'a\\') ++v[1];            \\n            if(i==\\'n\\') ++v[2];\\n            if(i==\\'o\\') ++v[3];\\n            if(i==\\'l\\') ++v[4];           \\n        }\\n        return min(*min_element(v.begin(),v.begin()+3),min(v[3],v[4])/2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588524,
                "title": "c-simple-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map <char, int> m;\\n        for(char c : text) m[c]++;\\n        int cnt = std::min(m[\\'b\\'], m[\\'a\\']);\\n        cnt = std::min(m[\\'l\\']/2, m[\\'o\\']/2);\\n        cnt = std::min(cnt, m[\\'n\\']);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        map <char, int> m;\\n        for(char c : text) m[c]++;\\n        int cnt = std::min(m[\\'b\\'], m[\\'a\\']);\\n        cnt = std::min(m[\\'l\\']/2, m[\\'o\\']/2);\\n        cnt = std::min(cnt, m[\\'n\\']);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566035,
                "title": "simple-and-intuitive-python-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = {}\\n        for l in text:\\n            c[l] = c.get(l, 0) +1\\n        return min(c.get(\\'b\\', 0),\\n                   c.get(\\'a\\', 0), \\n                   c.get(\\'n\\', 0), \\n                   c.get(\\'l\\', 0)//2, \\n                   c.get(\\'o\\', 0)//2)\\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = {}\\n        for l in text:\\n            c[l] = c.get(l, 0) +1\\n        return min(c.get(\\'b\\', 0),\\n                   c.get(\\'a\\', 0), \\n                   c.get(\\'n\\', 0), \\n                   c.get(\\'l\\', 0)//2, \\n                   c.get(\\'o\\', 0)//2)\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 518449,
                "title": "java-generic-solution-for-any-search-string",
                "content": "```\\nclass Solution {\\n    \\n    public int maxNumberOfBalloons(String text){\\n\\n        //you can replace any string to be searched here or pass as parameter\\n        String str = \"balloon\";\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        //populate only search string chars from text string\\n        for (int i = 0; i < text.length(); i++) {\\n            char ch = text.charAt(i);\\n            if (str.indexOf(ch) >= 0) {\\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            }\\n        }\\n\\n        //populate map for searchString to require get frequency of each char\\n        Map<Character, Integer> strMap = new HashMap<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            char ch = str.charAt(i);\\n            strMap.put(ch, strMap.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        //find min words can be made from text string chars\\n        for (Map.Entry<Character, Integer> entry : strMap.entrySet()) {\\n\\n            char key = entry.getKey();\\n            int value = entry.getValue();\\n\\n            if (!map.containsKey(key))\\n                return 0;\\n\\n            int occurValue = map.get(key);\\n\\n            if (occurValue / value < min) {\\n                min = occurValue / value;\\n            }\\n\\n        }\\n        return min;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maxNumberOfBalloons(String text){\\n\\n        //you can replace any string to be searched here or pass as parameter\\n        String str = \"balloon\";\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        //populate only search string chars from text string\\n        for (int i = 0; i < text.length(); i++) {\\n            char ch = text.charAt(i);\\n            if (str.indexOf(ch) >= 0) {\\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            }\\n        }\\n\\n        //populate map for searchString to require get frequency of each char\\n        Map<Character, Integer> strMap = new HashMap<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            char ch = str.charAt(i);\\n            strMap.put(ch, strMap.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        //find min words can be made from text string chars\\n        for (Map.Entry<Character, Integer> entry : strMap.entrySet()) {\\n\\n            char key = entry.getKey();\\n            int value = entry.getValue();\\n\\n            if (!map.containsKey(key))\\n                return 0;\\n\\n            int occurValue = map.get(key);\\n\\n            if (occurValue / value < min) {\\n                min = occurValue / value;\\n            }\\n\\n        }\\n        return min;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498937,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for(char c : text.toCharArray()) {\\n            if(c == \\'b\\') b++;\\n            else if(c == \\'a\\') a++;\\n            else if(c == \\'l\\') l++;\\n            else if(c == \\'o\\') o++;\\n            else if(c == \\'n\\') n++;\\n        }\\n        int res = Integer.MAX_VALUE;\\n        res = Math.min(res, b);\\n        res = Math.min(res, a);\\n        res = Math.min(res, l / 2);\\n        res = Math.min(res, o / 2);\\n        res = Math.min(res, n);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b = 0, a = 0, l = 0, o = 0, n = 0;\\n        for(char c : text.toCharArray()) {\\n            if(c == \\'b\\') b++;\\n            else if(c == \\'a\\') a++;\\n            else if(c == \\'l\\') l++;\\n            else if(c == \\'o\\') o++;\\n            else if(c == \\'n\\') n++;\\n        }\\n        int res = Integer.MAX_VALUE;\\n        res = Math.min(res, b);\\n        res = Math.min(res, a);\\n        res = Math.min(res, l / 2);\\n        res = Math.min(res, o / 2);\\n        res = Math.min(res, n);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470320,
                "title": "js-100-t-100-s-o-n-t-o-1-s-adaptable-and-commented-solution",
                "content": "For O(n) time complexity: Even though there is a nested loop, the number of iterations equals the length of the text. For O(1) space complexity, we can use a 26-length array for any size input string, so space is constant.\\n\\nI could definitely see the follow up question being \"How do we adapt this solution to match a given string other than balloon?\" So I used a variable instead of a string literal, like `\"balloon\".split(\\'\\')...`\\n\\n```\\nvar maxNumberOfBalloons = function(text) {\\n    // Use a variable so we can easily change the \"balloon\" string (or could just use a target param if given)\\n    const target = \"balloon\";\\n    \\n    // Edge cases \\n    if (text.length < target.length) return 0;\\n    \\n    // Use a 26 length array to keep track of character counts\\n    let countByCharArr = Array(26).fill(0);\\n    \\n    // Load character counts into arr\\n    text.split(\\'\\').forEach( char => countByCharArr[char.charCodeAt(0)-97]++);\\n    \\n    // Only iterate for the possible number of balloons based on length\\n    const maxTargetMatches = text.length / target.length;\\n    \\n    // Decrement, returning if there are no target characters left (use var so you can return the count outside of the for-loop block scope)\\n    for (var count = 0; count < maxTargetMatches; count++){\\n        if (target.split(\\'\\').some( char => 0 > --countByCharArr[char.charCodeAt(0)-97])){\\n            return count;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxNumberOfBalloons = function(text) {\\n    // Use a variable so we can easily change the \"balloon\" string (or could just use a target param if given)\\n    const target = \"balloon\";\\n    \\n    // Edge cases \\n    if (text.length < target.length) return 0;\\n    \\n    // Use a 26 length array to keep track of character counts\\n    let countByCharArr = Array(26).fill(0);\\n    \\n    // Load character counts into arr\\n    text.split(\\'\\').forEach( char => countByCharArr[char.charCodeAt(0)-97]++);\\n    \\n    // Only iterate for the possible number of balloons based on length\\n    const maxTargetMatches = text.length / target.length;\\n    \\n    // Decrement, returning if there are no target characters left (use var so you can return the count outside of the for-loop block scope)\\n    for (var count = 0; count < maxTargetMatches; count++){\\n        if (target.split(\\'\\').some( char => 0 > --countByCharArr[char.charCodeAt(0)-97])){\\n            return count;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 467938,
                "title": "concise-100-rust-solution",
                "content": "**Solution 1:**\\n```rust\\npub fn max_number_of_balloons(s: String) -> i32 {\\n\\tlet mut T = vec![0; 5];\\n\\tfor ch in s.chars() {\\n\\t\\tmatch ch {\\n\\t\\t\\t\\'b\\' => T[0] += 2,\\n\\t\\t\\t\\'a\\' => T[1] += 2,\\n\\t\\t\\t\\'l\\' => T[2] += 1,\\n\\t\\t\\t\\'o\\' => T[3] += 1,\\n\\t\\t\\t\\'n\\' => T[4] += 2,\\n\\t\\t\\t_ => (),\\n\\t\\t}\\n\\t}\\n\\t*T.iter().min().unwrap() / 2\\n}\\n```\\n\\n**Solution 1:**\\n```rust\\npub fn max_number_of_balloons(s: String) -> i32 {\\n\\tfn idx(ch: char) -> usize { ch as usize - 97 }\\n\\tlet mut T = vec![0; 26];\\n\\tfor ch in s.chars() {\\n\\t\\tT[idx(ch)] += 1;\\n\\t}\\n\\t*vec![T[idx(\\'b\\')], T[idx(\\'a\\')], T[idx(\\'l\\')] / 2, T[idx(\\'o\\')] / 2, T[idx(\\'n\\')]]\\n\\t\\t.iter().min().unwrap()\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn max_number_of_balloons(s: String) -> i32 {\\n\\tlet mut T = vec![0; 5];\\n\\tfor ch in s.chars() {\\n\\t\\tmatch ch {\\n\\t\\t\\t\\'b\\' => T[0] += 2,\\n\\t\\t\\t\\'a\\' => T[1] += 2,\\n\\t\\t\\t\\'l\\' => T[2] += 1,\\n\\t\\t\\t\\'o\\' => T[3] += 1,\\n\\t\\t\\t\\'n\\' => T[4] += 2,\\n\\t\\t\\t_ => (),\\n\\t\\t}\\n\\t}\\n\\t*T.iter().min().unwrap() / 2\\n}\\n```\n```rust\\npub fn max_number_of_balloons(s: String) -> i32 {\\n\\tfn idx(ch: char) -> usize { ch as usize - 97 }\\n\\tlet mut T = vec![0; 26];\\n\\tfor ch in s.chars() {\\n\\t\\tT[idx(ch)] += 1;\\n\\t}\\n\\t*vec![T[idx(\\'b\\')], T[idx(\\'a\\')], T[idx(\\'l\\')] / 2, T[idx(\\'o\\')] / 2, T[idx(\\'n\\')]]\\n\\t\\t.iter().min().unwrap()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459519,
                "title": "c",
                "content": "```\\npublic int MaxNumberOfBalloons(string text) {\\n\\tvar freqs = text.ToCharArray().GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\n\\tif (\"balon\".Any(c => !freqs.ContainsKey(c))) return 0;\\n\\tvar balon = new[] { freqs[\\'b\\'], freqs[\\'a\\'], freqs[\\'l\\'] / 2, freqs[\\'o\\'] / 2, freqs[\\'n\\'] };\\n\\treturn balon.Min();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MaxNumberOfBalloons(string text) {\\n\\tvar freqs = text.ToCharArray().GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\\n\\tif (\"balon\".Any(c => !freqs.ContainsKey(c))) return 0;\\n\\tvar balon = new[] { freqs[\\'b\\'], freqs[\\'a\\'], freqs[\\'l\\'] / 2, freqs[\\'o\\'] / 2, freqs[\\'n\\'] };\\n\\treturn balon.Min();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434417,
                "title": "c-100-run-time-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n  // 100% runtime, 100% memory\\n  static int maxNumberOfBalloons(string text) {\\n    vector<int> mp(26, 0);\\n    for (char s : text)\\n      if (s == \\'b\\' || s == \\'a\\' || s == \\'l\\' || s == \\'o\\' || s == \\'n\\')\\n        ++mp[s - \\'a\\'];\\n\\n    int ans = 10000;\\n    for (auto s : \"balon\")\\n      if (s == \\'l\\' || s == \\'o\\')\\n        ans = min(ans, mp[s - \\'a\\'] / 2);\\n      else if (s != \\'\\\\0\\')\\n        ans = min(ans, mp[s - \\'a\\']);\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  // 100% runtime, 100% memory\\n  static int maxNumberOfBalloons(string text) {\\n    vector<int> mp(26, 0);\\n    for (char s : text)\\n      if (s == \\'b\\' || s == \\'a\\' || s == \\'l\\' || s == \\'o\\' || s == \\'n\\')\\n        ++mp[s - \\'a\\'];\\n\\n    int ans = 10000;\\n    for (auto s : \"balon\")\\n      if (s == \\'l\\' || s == \\'o\\')\\n        ans = min(ans, mp[s - \\'a\\'] / 2);\\n      else if (s != \\'\\\\0\\')\\n        ans = min(ans, mp[s - \\'a\\']);\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430778,
                "title": "python-simple-beats-99-67time-and-100pct-space",
                "content": "```class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        d = collections.Counter(text) \\n        bans = min(d[\\'b\\'], d[\\'a\\'], d[\\'n\\'])  # we need 1 of these letters for every word\\n        los = min(d[\\'l\\'], d[\\'o\\'])  # we need 2 of these for every word\\n        counter = 0\\n        while bans>=1 and los>=2: #while we have at least one ban and 2 los, increment count\\n            counter+=1\\n            bans-=1 \\n            los-=2 \\n        return counter",
                "solutionTags": [],
                "code": "```class Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        d = collections.Counter(text) \\n        bans = min(d[\\'b\\'], d[\\'a\\'], d[\\'n\\'])  # we need 1 of these letters for every word\\n        los = min(d[\\'l\\'], d[\\'o\\'])  # we need 2 of these for every word\\n        counter = 0\\n        while bans>=1 and los>=2: #while we have at least one ban and 2 los, increment count\\n            counter+=1\\n            bans-=1 \\n            los-=2 \\n        return counter",
                "codeTag": "Java"
            },
            {
                "id": 404872,
                "title": "python-1-liner-super-easy-to-understand",
                "content": "```\\ndic = Counter(string)\\nreturn min(dic[\\'b\\'], dic[\\'a\\'], dic[\\'l\\'] // 2, dic[\\'o\\'] // 2, dic[\\'n\\'])\\n```",
                "solutionTags": [],
                "code": "```\\ndic = Counter(string)\\nreturn min(dic[\\'b\\'], dic[\\'a\\'], dic[\\'l\\'] // 2, dic[\\'o\\'] // 2, dic[\\'n\\'])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396008,
                "title": "beautiful-scala-solution-1-liner",
                "content": "I love functional programming <3\\n```\\ndef maxNumberOfBalloons(text: String): Int = {\\n    return \"balon\".toList.zip(List(1,1,2,2,1)) \\n                  .map(p => text.count(_ == p._1) / p._2)\\n                  .min;\\n}\\n```\\nThe one-liner (although it looks much less beautiful):\\n```\\ndef maxNumberOfBalloons(text: String): Int = {\\n    return \"balon\".toList.zip(List(1,1,2,2,1)).map(p => text.count(_ == p._1) / p._2).min;\\n}",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef maxNumberOfBalloons(text: String): Int = {\\n    return \"balon\".toList.zip(List(1,1,2,2,1)) \\n                  .map(p => text.count(_ == p._1) / p._2)\\n                  .min;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 389464,
                "title": "c-o-n",
                "content": "```\\npublic class Solution {\\n    public int MaxNumberOfBalloons(string text) {\\n        text = text.ToLower();\\n        \\n        int b=0, a=0, l=0, o=0, n=0;\\n        \\n        for(var i = 0; i< text.Length; i++)\\n        {\\n            switch(text[i])\\n            {\\n                case \\'b\\':\\n                    b++;\\n                    break;\\n                case \\'a\\':\\n                    a++;\\n                    break;\\n                case \\'l\\':\\n                    l++;\\n                    break;\\n                case \\'n\\':\\n                    n++;\\n                    break;\\n                case \\'o\\':\\n                    o++;\\n                    break;\\n            }\\n        }\\n        \\n        l = l/2;\\n        o = o/2;\\n        \\n        //find min\\n        var min = Math.Min(b, Math.Min(a,Math.Min(l, Math.Min(o,n))));\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxNumberOfBalloons(string text) {\\n        text = text.ToLower();\\n        \\n        int b=0, a=0, l=0, o=0, n=0;\\n        \\n        for(var i = 0; i< text.Length; i++)\\n        {\\n            switch(text[i])\\n            {\\n                case \\'b\\':\\n                    b++;\\n                    break;\\n                case \\'a\\':\\n                    a++;\\n                    break;\\n                case \\'l\\':\\n                    l++;\\n                    break;\\n                case \\'n\\':\\n                    n++;\\n                    break;\\n                case \\'o\\':\\n                    o++;\\n                    break;\\n            }\\n        }\\n        \\n        l = l/2;\\n        o = o/2;\\n        \\n        //find min\\n        var min = Math.Min(b, Math.Min(a,Math.Min(l, Math.Min(o,n))));\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388762,
                "title": "short-simple-python",
                "content": "Self-explainatory:\\n\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cb= text.count(\\'b\\')\\n        ca= text.count(\\'a\\')\\n        cl= text.count(\\'l\\')\\n        co= text.count(\\'o\\')\\n        cn= text.count(\\'n\\')\\n        return(min(cb,ca,cl//2,co//2,cn))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cb= text.count(\\'b\\')\\n        ca= text.count(\\'a\\')\\n        cl= text.count(\\'l\\')\\n        co= text.count(\\'o\\')\\n        cn= text.count(\\'n\\')\\n        return(min(cb,ca,cl//2,co//2,cn))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383012,
                "title": "python-with",
                "content": "```\\n   def maxNumberOfBalloons(self, text: str) -> int:\\n        c,b = Counter(text), Counter(\"balloon\")\\n\\n        res = 0\\n        while b == c & b:\\n            res += 1\\n            c = c-b\\n\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\n   def maxNumberOfBalloons(self, text: str) -> int:\\n        c,b = Counter(text), Counter(\"balloon\")\\n\\n        res = 0\\n        while b == c & b:\\n            res += 1\\n            c = c-b\\n\\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 382464,
                "title": "java-solution-using-count-array-beats-100-runtime-and-memory",
                "content": "```\\n\\n\\n\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int ans=0;\\n    char count[]=new char[26];\\n        for(int i=0;i<text.length();i++){\\n            count[text.charAt(i)-\\'a\\']++;\\n        }\\n        String res=\"balloon\";\\n        while(true){\\n        for(int i=0;i<res.length();i++){\\n          if (count[res.charAt(i) - \\'a\\']-- <= 0) \\n                return ans;\\n            \\n        }\\n            ans++;\\n        }\\n        \\n    }\\n}\\n ```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int ans=0;\\n    char count[]=new char[26];\\n        for(int i=0;i<text.length();i++){\\n            count[text.charAt(i)-\\'a\\']++;\\n        }\\n        String res=\"balloon\";\\n        while(true){\\n        for(int i=0;i<res.length();i++){\\n          if (count[res.charAt(i) - \\'a\\']-- <= 0) \\n                return ans;\\n            \\n        }\\n            ans++;\\n        }\\n        \\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 382369,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Solution1**\\nIt will be the min of frequencies of `[b,a,n]` or half of freqncies of `[l,o]`.\\n```\\npublic int maxNumberOfBalloons(String s) {\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n            freq[ch-\\'a\\']++;\\n        int count = 10000;\\n        for(char ch : \"balloon\".toCharArray()){\\n            if(ch == \\'l\\' || ch == \\'o\\')\\n                count = Math.min(count, freq[ch-\\'a\\']/2);\\n            else\\n                count = Math.min(count, freq[ch-\\'a\\']);\\n        }\\n        return count;\\n    }\\n```\\n**Solution2**\\nRecord frequencies of all chars. Now, from `freq` array keep taking out required chars of \"balloon\" and stop when we can\\'t form \"balloon\" \\n(i.e `freq` of some char from it will be <= 0).\\n\\n```\\npublic int maxNumberOfBalloons(String s) {\\n        int count = 0;\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n            freq[ch-\\'a\\']++;\\n        while(true){\\n            for(char ch : \"balloon\".toCharArray()){\\n                if(freq[ch-\\'a\\'] <= 0)\\n                    return count;\\n                else\\n                    freq[ch-\\'a\\']--;\\n            }\\n            ++count;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxNumberOfBalloons(String s) {\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n            freq[ch-\\'a\\']++;\\n        int count = 10000;\\n        for(char ch : \"balloon\".toCharArray()){\\n            if(ch == \\'l\\' || ch == \\'o\\')\\n                count = Math.min(count, freq[ch-\\'a\\']/2);\\n            else\\n                count = Math.min(count, freq[ch-\\'a\\']);\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int maxNumberOfBalloons(String s) {\\n        int count = 0;\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n            freq[ch-\\'a\\']++;\\n        while(true){\\n            for(char ch : \"balloon\".toCharArray()){\\n                if(freq[ch-\\'a\\'] <= 0)\\n                    return count;\\n                else\\n                    freq[ch-\\'a\\']--;\\n            }\\n            ++count;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041638,
                "title": "hashmap-solution-with-step-by-step-explanation",
                "content": "# Intuition\\nWe will use HashMap tosolve this problem\\n# Approach\\nFirst we create HashSet to store each char of \"balloon\" to make O(1) checking if char from text is char from \"balloon\". Next we populate HashMap with count of chars that is in HashSet, next we iterate over our HashMap and find minimum count of each char, for \"l\" and \"o\", we divide it by 2 and floor it, and at the end we return min count.\\n# Complexity\\n- Time complexity:\\nO(n) -> we iterate 3n but discard constants\\n- Space complexity:\\nO(1) -> we use constant HashSet and constant HashMap\\n# Code\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        // declare HashSet to store word \"balloon\"\\n        Set<Character> map =  new HashSet();\\n        // declare our word balloon\\n        String baloon = \"balloon\";\\n        // iterate over balloon word:\\n        for(int i = 0; i < baloon.length(); i++) {\\n            // store each character in HashSet\\n            map.add(baloon.charAt(i));\\n        }\\n        // declare HashMap to calculate count\\n        Map<Character, Integer> hash = new HashMap();\\n        // iterate over text string:\\n        for(int i = 0; i < text.length(); i ++) {\\n            // get char from string\\n            char word = text.charAt(i);\\n            // if HashSet contains char:\\n            if(map.contains(word)) {\\n                // count char in HashMap\\n                hash.put(word, hash.getOrDefault(word, 0) + 1);\\n            }\\n        }  \\n        // declare min variable to store answer\\n        int min = Integer.MAX_VALUE;\\n        // check if hash have all chars to make balloon word, if no return 0\\n        if(hash.size() < 5) return 0;\\n        // iterate over HashMap:\\n        for(Map.Entry<Character, Integer> entry: hash.entrySet()) {\\n            // get char from HashMap\\n            char word = entry.getKey();\\n            // get count of char from HashMap\\n            int count = entry.getValue();\\n            // check if char is \"l\" or \"o\":\\n            if(word == \\'l\\' || word == \\'o\\') {\\n                // if true: set min as devision of count by 2 and floor it\\n                min = Math.min(min, (int)Math.floor(count / 2));\\n            } else {\\n                // if false: set min as min value of min or count\\n                min = Math.min(min, count);\\n            }\\n        }\\n        // return answer\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        // declare HashSet to store word \"balloon\"\\n        Set<Character> map =  new HashSet();\\n        // declare our word balloon\\n        String baloon = \"balloon\";\\n        // iterate over balloon word:\\n        for(int i = 0; i < baloon.length(); i++) {\\n            // store each character in HashSet\\n            map.add(baloon.charAt(i));\\n        }\\n        // declare HashMap to calculate count\\n        Map<Character, Integer> hash = new HashMap();\\n        // iterate over text string:\\n        for(int i = 0; i < text.length(); i ++) {\\n            // get char from string\\n            char word = text.charAt(i);\\n            // if HashSet contains char:\\n            if(map.contains(word)) {\\n                // count char in HashMap\\n                hash.put(word, hash.getOrDefault(word, 0) + 1);\\n            }\\n        }  \\n        // declare min variable to store answer\\n        int min = Integer.MAX_VALUE;\\n        // check if hash have all chars to make balloon word, if no return 0\\n        if(hash.size() < 5) return 0;\\n        // iterate over HashMap:\\n        for(Map.Entry<Character, Integer> entry: hash.entrySet()) {\\n            // get char from HashMap\\n            char word = entry.getKey();\\n            // get count of char from HashMap\\n            int count = entry.getValue();\\n            // check if char is \"l\" or \"o\":\\n            if(word == \\'l\\' || word == \\'o\\') {\\n                // if true: set min as devision of count by 2 and floor it\\n                min = Math.min(min, (int)Math.floor(count / 2));\\n            } else {\\n                // if false: set min as min value of min or count\\n                min = Math.min(min, count);\\n            }\\n        }\\n        // return answer\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009508,
                "title": "kotlin-simple-solution",
                "content": "# Complexity\\n- Time complexity O(n):\\n\\n- Space complexity O(n):\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxNumberOfBalloons(text: String): Int {\\n        val counter = text.groupingBy{it}.eachCount()\\n        val letters = setOf(\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\')\\n        letters.forEach {\\n            if (!counter.containsKey(it)){\\n                return 0\\n            }\\n        }\\n        var minn = counter[\\'a\\']!!\\n        counter.forEach { (k, v) ->\\n            if (letters.contains(k)){\\n                if (k == \\'l\\' || k == \\'o\\'){\\n                    minn = minOf(minn, v / 2)\\n                } else {\\n                    minn = minOf(minn, v)\\n                }\\n            }\\n        }\\n        return minn\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxNumberOfBalloons(text: String): Int {\\n        val counter = text.groupingBy{it}.eachCount()\\n        val letters = setOf(\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\')\\n        letters.forEach {\\n            if (!counter.containsKey(it)){\\n                return 0\\n            }\\n        }\\n        var minn = counter[\\'a\\']!!\\n        counter.forEach { (k, v) ->\\n            if (letters.contains(k)){\\n                if (k == \\'l\\' || k == \\'o\\'){\\n                    minn = minOf(minn, v / 2)\\n                } else {\\n                    minn = minOf(minn, v)\\n                }\\n            }\\n        }\\n        return minn\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893401,
                "title": "go-solution-great-explanation-and-full-description",
                "content": "# Intuition\\nThe function aims to find the maximum number of instances of the word \"balloon\" that can be formed from the characters in the given string `text`. To achieve this, we can count the occurrence of each character in `text` and iteratively decrease the counts as we form each instance of the word \"balloon\".\\n\\n# Approach\\n1. **Initialize the Hashmap**: We create a hashmap `store` to record the occurrence count of each character in the input string `text`.\\n  \\n2. **Count Occurrences**: Iterate through the `text`, and for each character, increment the corresponding count in the `store`.\\n\\n3. **Check and Form Words**: Initialize `result` to 0, which will store the count of instances of the word \"balloon\". Define a `template` string as \"balloon\". In an infinite loop, iterate through the characters in the `template`, and for each character, decrement its count in the `store`. If any count becomes negative, we cannot form any more instances of the word, so we return the `result`.\\n\\n# Complexity\\n- **Time Complexity**: The time complexity is O(n), where n is the number of characters in `text`. Counting the occurrences takes O(n), and then we loop through the `template` in the worst case n/len(template) times.\\n  \\n- **Space Complexity**: The space complexity is O(c), where c is the number of unique characters in `text`. This accounts for the storage used by our hashmap.\\n\\n# Code\\n```go\\nfunc maxNumberOfBalloons(text string) int {\\n\\tstore := make(map[byte]int, len(text))\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\tstore[text[i]] = store[text[i]] + 1\\n\\t}\\n\\tresult := 0\\n\\ttemplate := \"balloon\"\\n\\tfor {\\n\\t\\tfor i := 0; i < len(template); i++ {\\n\\t\\t\\tstore[template[i]]--\\n\\t\\t\\tif store[template[i]] < 0 {\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult++\\n\\t}\\n}\\n",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "# Intuition\\nThe function aims to find the maximum number of instances of the word \"balloon\" that can be formed from the characters in the given string `text`. To achieve this, we can count the occurrence of each character in `text` and iteratively decrease the counts as we form each instance of the word \"balloon\".\\n\\n# Approach\\n1. **Initialize the Hashmap**: We create a hashmap `store` to record the occurrence count of each character in the input string `text`.\\n  \\n2. **Count Occurrences**: Iterate through the `text`, and for each character, increment the corresponding count in the `store`.\\n\\n3. **Check and Form Words**: Initialize `result` to 0, which will store the count of instances of the word \"balloon\". Define a `template` string as \"balloon\". In an infinite loop, iterate through the characters in the `template`, and for each character, decrement its count in the `store`. If any count becomes negative, we cannot form any more instances of the word, so we return the `result`.\\n\\n# Complexity\\n- **Time Complexity**: The time complexity is O(n), where n is the number of characters in `text`. Counting the occurrences takes O(n), and then we loop through the `template` in the worst case n/len(template) times.\\n  \\n- **Space Complexity**: The space complexity is O(c), where c is the number of unique characters in `text`. This accounts for the storage used by our hashmap.\\n\\n# Code\\n```go\\nfunc maxNumberOfBalloons(text string) int {\\n\\tstore := make(map[byte]int, len(text))\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\tstore[text[i]] = store[text[i]] + 1\\n\\t}\\n\\tresult := 0\\n\\ttemplate := \"balloon\"\\n\\tfor {\\n\\t\\tfor i := 0; i < len(template); i++ {\\n\\t\\t\\tstore[template[i]]--\\n\\t\\t\\tif store[template[i]] < 0 {\\n\\t\\t\\t\\treturn result\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult++\\n\\t}\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3821301,
                "title": "hash-map-solution-6-ms-beats-65-5-19-12-mb-beats-87-5",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$, `k` is `5` here.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $text\\n     * @return Integer\\n     */\\n    function maxNumberOfBalloons($text) {\\n        $balloon = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\'];\\n        $freq = [];\\n        for ($i = 0; $i < strlen($text); $i++) {\\n            if (!in_array($text[$i], $balloon)) {\\n                continue;\\n            }\\n            $freq[$text[$i]] = ($freq[$text[$i]] ?? 0) + 1;\\n        }\\n        \\n        if (count($freq) !== count($balloon)) {\\n            return 0;\\n        }\\n\\n        $freq[\\'l\\'] = (int)($freq[\\'l\\'] / 2);\\n        $freq[\\'o\\'] = (int)($freq[\\'o\\'] / 2);\\n\\n        return min($freq);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $text\\n     * @return Integer\\n     */\\n    function maxNumberOfBalloons($text) {\\n        $balloon = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\'];\\n        $freq = [];\\n        for ($i = 0; $i < strlen($text); $i++) {\\n            if (!in_array($text[$i], $balloon)) {\\n                continue;\\n            }\\n            $freq[$text[$i]] = ($freq[$text[$i]] ?? 0) + 1;\\n        }\\n        \\n        if (count($freq) !== count($balloon)) {\\n            return 0;\\n        }\\n\\n        $freq[\\'l\\'] = (int)($freq[\\'l\\'] / 2);\\n        $freq[\\'o\\'] = (int)($freq[\\'o\\'] / 2);\\n\\n        return min($freq);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744821,
                "title": "java-2ms-clean-code-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        final int[][] cache = new int[2][5];\\n        cache[0][0] = 97;  // a\\n        cache[0][1] = 98;  // b\\n        cache[0][2] = 108; // l\\n        cache[0][3] = 110; // n\\n        cache[0][4] = 111; // o\\n        \\n        // cacl letter frequencies\\n        for (char ch : text.toCharArray()) {\\n            final int intValue = ch;\\n            for (int i = 0; i < 5; i++) {\\n                if (intValue == cache[0][i]) {\\n                    cache[1][i]++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // l & o meet twice\\n        cache[1][2] /= 2;\\n        cache[1][4] /= 2;\\n\\n        // find the bottleneck\\n        int min = Integer.MAX_VALUE;\\n        for (int frequency: cache[1]) {\\n            min = Math.min(min, frequency);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        final int[][] cache = new int[2][5];\\n        cache[0][0] = 97;  // a\\n        cache[0][1] = 98;  // b\\n        cache[0][2] = 108; // l\\n        cache[0][3] = 110; // n\\n        cache[0][4] = 111; // o\\n        \\n        // cacl letter frequencies\\n        for (char ch : text.toCharArray()) {\\n            final int intValue = ch;\\n            for (int i = 0; i < 5; i++) {\\n                if (intValue == cache[0][i]) {\\n                    cache[1][i]++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // l & o meet twice\\n        cache[1][2] /= 2;\\n        cache[1][4] /= 2;\\n\\n        // find the bottleneck\\n        int min = Integer.MAX_VALUE;\\n        for (int frequency: cache[1]) {\\n            min = Math.min(min, frequency);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736980,
                "title": "swift-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maxNumberOfBalloons(_ text: String) -> Int {\\n        var characters = Array(text)\\n        var bCounts = 0\\n        var aCounts = 0\\n        var lCounts = 0\\n        var oCounts = 0\\n        var nCounts = 0\\n\\n        for char in characters {\\n            switch (char) {\\n                case \"b\":\\n                    bCounts = bCounts + 1\\n                case \"a\":\\n                    aCounts = aCounts + 1\\n                case \"l\":\\n                    lCounts = lCounts + 1\\n                case \"o\":\\n                    oCounts = oCounts + 1\\n                case \"n\":\\n                    nCounts = nCounts + 1\\n                default:\\n                    continue\\n            }\\n        }\\n\\n        var ans = min(bCounts,aCounts,lCounts/2,oCounts/2,nCounts)\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxNumberOfBalloons(_ text: String) -> Int {\\n        var characters = Array(text)\\n        var bCounts = 0\\n        var aCounts = 0\\n        var lCounts = 0\\n        var oCounts = 0\\n        var nCounts = 0\\n\\n        for char in characters {\\n            switch (char) {\\n                case \"b\":\\n                    bCounts = bCounts + 1\\n                case \"a\":\\n                    aCounts = aCounts + 1\\n                case \"l\":\\n                    lCounts = lCounts + 1\\n                case \"o\":\\n                    oCounts = oCounts + 1\\n                case \"n\":\\n                    nCounts = nCounts + 1\\n                default:\\n                    continue\\n            }\\n        }\\n\\n        var ans = min(bCounts,aCounts,lCounts/2,oCounts/2,nCounts)\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618829,
                "title": "simplest-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, s: str) -> int:\\n        return min(s.count(\\'b\\'), s.count(\\'a\\'), s.count(\\'l\\')//2, s.count(\\'o\\')//2, s.count(\\'n\\'))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, s: str) -> int:\\n        return min(s.count(\\'b\\'), s.count(\\'a\\'), s.count(\\'l\\')//2, s.count(\\'o\\')//2, s.count(\\'n\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603205,
                "title": "o-n-maximum-number-of-balloons-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int i, b=0, a=0, l=0, o=0, n=0, count=0;\\n        for(i=0 ; i<text.length() ; i++)\\n        {\\n            if(text[i]==\\'b\\')\\n                b++;\\n            else if(text[i]==\\'a\\')\\n                a++;\\n            else if(text[i]==\\'l\\')\\n                l++;\\n            else if(text[i]==\\'o\\')\\n                o++;\\n            else if(text[i]==\\'n\\')\\n                n++;\\n        }\\n        while(true)\\n        {\\n            b--;\\n            a--;\\n            l -= 2;\\n            o -= 2;\\n            n--;\\n            if(b>=0 && a>=0 && l>=0 && o>=0 && n>=0)\\n                count++;\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/5c5fc37e-a4f5-431b-be39-02554516d2b3_1686028095.3401299.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int i, b=0, a=0, l=0, o=0, n=0, count=0;\\n        for(i=0 ; i<text.length() ; i++)\\n        {\\n            if(text[i]==\\'b\\')\\n                b++;\\n            else if(text[i]==\\'a\\')\\n                a++;\\n            else if(text[i]==\\'l\\')\\n                l++;\\n            else if(text[i]==\\'o\\')\\n                o++;\\n            else if(text[i]==\\'n\\')\\n                n++;\\n        }\\n        while(true)\\n        {\\n            b--;\\n            a--;\\n            l -= 2;\\n            o -= 2;\\n            n--;\\n            if(b>=0 && a>=0 && l>=0 && o>=0 && n>=0)\\n                count++;\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370649,
                "title": "python-with-explanation-runtime-7ms-beats-100",
                "content": "![Screenshot 2023-04-02 5.41.59 PM.png](https://assets.leetcode.com/users/images/0a71cb21-ca80-4381-9fda-b3f2cd2634a1_1680438303.0569677.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # Letters to make \\'balloon\\'.\\n        a = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\']\\n\\n        # Counting letters [\\'b\\', \\'a\\', \\'l\\', \\'o\\',\\'n\\'] from string.\\n        # Appending that in a list.\\n        b = [text.count(i) for i in a]\\n\\n        # Counter for counting word balloon.\\n        c = 0\\n\\n        # Looping infinitly till break.\\n        while True:\\n\\n            # To make word \\'balloon\\', we need 1 b, a, & n, & 2 l & o.\\n            # The following condition will check if the above mentioned minimum numbers are in the list in that order.\\n            if b[0] >= 1 and b[1] >= 1 and b[2] >= 2 and b[3] >= 2 and b[4] >= 1:\\n\\n                # When the above condition is satisfied.\\n                # The same numbers are subtracted respectively from the count list b.\\n                b = b[0] - 1, b[1] - 1, b[2] - 2, b[3] - 2, b[4] - 1\\n\\n                # Incrementing 1 to c after each balloon.\\n                c += 1\\n\\n            # If the above condition is false then break the loop.\\n            else:\\n                break\\n\\n        # Return total of c.\\n        return c",
                "solutionTags": [
                    "Python"
                ],
                "code": "![Screenshot 2023-04-02 5.41.59 PM.png](https://assets.leetcode.com/users/images/0a71cb21-ca80-4381-9fda-b3f2cd2634a1_1680438303.0569677.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxNumberOfBalloons(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # Letters to make \\'balloon\\'.\\n        a = [\\'b\\', \\'a\\', \\'l\\', \\'o\\', \\'n\\']\\n\\n        # Counting letters [\\'b\\', \\'a\\', \\'l\\', \\'o\\',\\'n\\'] from string.\\n        # Appending that in a list.\\n        b = [text.count(i) for i in a]\\n\\n        # Counter for counting word balloon.\\n        c = 0\\n\\n        # Looping infinitly till break.\\n        while True:\\n\\n            # To make word \\'balloon\\', we need 1 b, a, & n, & 2 l & o.\\n            # The following condition will check if the above mentioned minimum numbers are in the list in that order.\\n            if b[0] >= 1 and b[1] >= 1 and b[2] >= 2 and b[3] >= 2 and b[4] >= 1:\\n\\n                # When the above condition is satisfied.\\n                # The same numbers are subtracted respectively from the count list b.\\n                b = b[0] - 1, b[1] - 1, b[2] - 2, b[3] - 2, b[4] - 1\\n\\n                # Incrementing 1 to c after each balloon.\\n                c += 1\\n\\n            # If the above condition is false then break the loop.\\n            else:\\n                break\\n\\n        # Return total of c.\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 3238928,
                "title": "using-counter",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        CountText = Counter(text)\\n        balloon = Counter(\"balloon\")\\n\\n        res = len(text)\\n        for c in balloon:\\n            res = min(res,CountText[c]//balloon[c])\\n        return res\\n\\n\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        CountText = Counter(text)\\n        balloon = Counter(\"balloon\")\\n\\n        res = len(text)\\n        for c in balloon:\\n            res = min(res,CountText[c]//balloon[c])\\n        return res\\n\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134573,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        unordered_map<char,int>m;\\n        int flag=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'a\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'l\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'l\\')\\n            {\\n                m[s[i]]++;\\n               \\n            }\\n            else if(s[i]==\\'o\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'o\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'n\\')\\n            {\\n                m[s[i]]++;\\n               \\n            }\\n        }\\n        \\n        if(m.find(\\'b\\')==m.end()||m.find(\\'a\\')==m.end()||m.find(\\'l\\')==m.end()||m.find(\\'o\\')==m.end()||m.find(\\'n\\')==m.end())return 0;\\n        m[\\'o\\']=m[\\'o\\']/2;\\n        m[\\'l\\']=m[\\'l\\']/2;\\n        int ans=INT_MAX;\\n        for(auto it:m)\\n        {\\n            \\n            ans=min(ans,it.second);\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) {\\n        unordered_map<char,int>m;\\n        int flag=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'a\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'l\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'l\\')\\n            {\\n                m[s[i]]++;\\n               \\n            }\\n            else if(s[i]==\\'o\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'o\\')\\n            {\\n                m[s[i]]++;\\n                \\n            }\\n            else if(s[i]==\\'n\\')\\n            {\\n                m[s[i]]++;\\n               \\n            }\\n        }\\n        \\n        if(m.find(\\'b\\')==m.end()||m.find(\\'a\\')==m.end()||m.find(\\'l\\')==m.end()||m.find(\\'o\\')==m.end()||m.find(\\'n\\')==m.end())return 0;\\n        m[\\'o\\']=m[\\'o\\']/2;\\n        m[\\'l\\']=m[\\'l\\']/2;\\n        int ans=INT_MAX;\\n        for(auto it:m)\\n        {\\n            \\n            ans=min(ans,it.second);\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120155,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string t) {\\n      int n=t.size();\\n      vector<int>v;\\n      int a1=0,a2=0,a3=0,a4=0,a5=0;  \\n      for(int i=0;i<n;i++)\\n      {\\n          if(t[i]==\\'b\\')\\n          {\\n              a1++;\\n          }\\n          else if(t[i]==\\'a\\')\\n          {\\n              a2++;\\n          }\\n        else if(t[i]==\\'l\\')\\n          {\\n              a3++;\\n          }\\n          else if(t[i]==\\'o\\')\\n          {\\n              a4++;\\n          }\\n          else if(t[i]==\\'n\\')\\n          {\\n              a5++;\\n          }}\\n   a3=a3/2;\\n   a4=a4/2;\\n   for(int i=0;i<1;i++)\\n   {\\n     v.push_back(a1);\\n      v.push_back(a2);\\n       v.push_back(a3);\\n        v.push_back(a4);\\n         v.push_back(a5);\\n   }\\n   int s=*min_element(v.begin(),v.end());\\n   return s;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string t) {\\n      int n=t.size();\\n      vector<int>v;\\n      int a1=0,a2=0,a3=0,a4=0,a5=0;  \\n      for(int i=0;i<n;i++)\\n      {\\n          if(t[i]==\\'b\\')\\n          {\\n              a1++;\\n          }\\n          else if(t[i]==\\'a\\')\\n          {\\n              a2++;\\n          }\\n        else if(t[i]==\\'l\\')\\n          {\\n              a3++;\\n          }\\n          else if(t[i]==\\'o\\')\\n          {\\n              a4++;\\n          }\\n          else if(t[i]==\\'n\\')\\n          {\\n              a5++;\\n          }}\\n   a3=a3/2;\\n   a4=a4/2;\\n   for(int i=0;i<1;i++)\\n   {\\n     v.push_back(a1);\\n      v.push_back(a2);\\n       v.push_back(a3);\\n        v.push_back(a4);\\n         v.push_back(a5);\\n   }\\n   int s=*min_element(v.begin(),v.end());\\n   return s;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105301,
                "title": "kotlin-using-a-map-and-counting-characters",
                "content": "# Intuition\\nWe count the number of each character in `\"Balloon\"` in the `text` String, then check for the minimun of the word `\"Balloon\"` we can create from the counted characters.\\n\\n# Approach\\nWe check for each occurence of any of the characters in `\"balon\"` in the String `text`. \\n\\nThen again, for each character in `\"balon\"`, we check if it occurs zero times. If it does, we return 0 as our final answer since we won\\'t be able to create any `\"Balloon\"` words. \\n\\nIf not zero, we check if it\\'s either a `\\'l\\'` or `\\'o\\'`, or any of `\\'b\\'`,`\\'a\\'` or `\\'c\\'`. If it\\'s any of the former, then we divide the number of occurences of that character in half, otherwise we keep it as is for the latter characters. \\n\\nThen we will take the `min` of all these characters to find out the minimum number of the word `Balloon` we can create.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)` since we have to traverse the whole String `text`\\n\\n- Space complexity:\\n`O(1)` since we use a map the size of the english alphabet in lowercase (`O(26)` is the same as `O(1)`)\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxNumberOfBalloons(text: String): Int {\\n        val map = IntArray(26)\\n        text.forEach {\\n            if(it in \"balon\") map[it - \\'a\\']++\\n        }\\n        var min = Integer.MAX_VALUE\\n        \"balon\".forEach {\\n            if(map[it - \\'a\\'] == 0) return 0\\n            else if(it == \\'l\\' || it == \\'o\\') min = minOf(min, map[it-\\'a\\']/2)\\n            else min = minOf(min, map[it-\\'a\\'])\\n        }\\n        return min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Ordered Map",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    fun maxNumberOfBalloons(text: String): Int {\\n        val map = IntArray(26)\\n        text.forEach {\\n            if(it in \"balon\") map[it - \\'a\\']++\\n        }\\n        var min = Integer.MAX_VALUE\\n        \"balon\".forEach {\\n            if(map[it - \\'a\\'] == 0) return 0\\n            else if(it == \\'l\\' || it == \\'o\\') min = minOf(min, map[it-\\'a\\']/2)\\n            else min = minOf(min, map[it-\\'a\\'])\\n        }\\n        return min\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970038,
                "title": "python-solution-with-hash-map",
                "content": "\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        count = defaultdict(lambda: 0)\\n        for char in text:\\n            count[char] += 1\\n        \\n        ans = min(count[\"l\"] // 2, count[\"o\"] // 2)\\n        ans = min(ans, count[\"b\"], count[\"a\"], count[\"n\"])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        count = defaultdict(lambda: 0)\\n        for char in text:\\n            count[char] += 1\\n        \\n        ans = min(count[\"l\"] // 2, count[\"o\"] // 2)\\n        ans = min(ans, count[\"b\"], count[\"a\"], count[\"n\"])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941181,
                "title": "python-solution-using-counter",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        ctrText = Counter(text)\\n        cntB, cntA, cntN = ctrText[\\'b\\'], ctrText[\\'a\\'], ctrText[\\'n\\']\\n        cntL, cntO = ctrText[\\'l\\'] // 2, ctrText[\\'o\\'] // 2\\n        return min(cntB, cntA, cntL, cntO, cntN)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        ctrText = Counter(text)\\n        cntB, cntA, cntN = ctrText[\\'b\\'], ctrText[\\'a\\'], ctrText[\\'n\\']\\n        cntL, cntO = ctrText[\\'l\\'] // 2, ctrText[\\'o\\'] // 2\\n        return min(cntB, cntA, cntL, cntO, cntN)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897447,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int maxNumberOfBalloons(string text) {\\n       map<char,int> v;\\n       for(int i =0;i<text.length();i++){\\n           if(text[i]==\\'b\\'||text[i]==\\'a\\'||text[i]==\\'l\\'||text[i]==\\'o\\'||text[i]==\\'n\\'){\\n           v[text[i]]+=1;\\n           }\\n       }\\n       return min(v[\\'b\\'],min(v[\\'a\\'],min(v[\\'l\\']/2,min(v[\\'o\\']/2,v[\\'n\\']))));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int maxNumberOfBalloons(string text) {\\n       map<char,int> v;\\n       for(int i =0;i<text.length();i++){\\n           if(text[i]==\\'b\\'||text[i]==\\'a\\'||text[i]==\\'l\\'||text[i]==\\'o\\'||text[i]==\\'n\\'){\\n           v[text[i]]+=1;\\n           }\\n       }\\n       return min(v[\\'b\\'],min(v[\\'a\\'],min(v[\\'l\\']/2,min(v[\\'o\\']/2,v[\\'n\\']))));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787148,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) \\n    {\\n        string target = \"balloon\";\\n\\n        vector<int>v1(26,0);\\n        for(int i=0;i<target.length();i++)\\n        {\\n            char ch = target[i];\\n            v1[ch-\\'a\\']++;\\n        }\\n        vector<int>v2(26,0);\\n        for(int i=0;i<s.length();i++)  \\n        {\\n            char ch = s[i];\\n            v2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(v1[i]==0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                v2[i] = v2[i] / v1[i];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        unordered_set<char>st(target.begin(),target.end());\\n        for(auto ch : st)\\n        {\\n            int val = ch - \\'a\\';\\n            ans=min(ans,v2[val]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string s) \\n    {\\n        string target = \"balloon\";\\n\\n        vector<int>v1(26,0);\\n        for(int i=0;i<target.length();i++)\\n        {\\n            char ch = target[i];\\n            v1[ch-\\'a\\']++;\\n        }\\n        vector<int>v2(26,0);\\n        for(int i=0;i<s.length();i++)  \\n        {\\n            char ch = s[i];\\n            v2[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(v1[i]==0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                v2[i] = v2[i] / v1[i];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        unordered_set<char>st(target.begin(),target.end());\\n        for(auto ch : st)\\n        {\\n            int val = ch - \\'a\\';\\n            ans=min(ans,v2[val]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764238,
                "title": "if-else-method-easy-java-c-faster",
                "content": "# Please upvote if you like it\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int b=0,a=0,l=0,o=0,n=0;\\n        \\n        for(char ch: text.toCharArray()){\\n            if(ch==\\'b\\') b++;\\n            if(ch==\\'a\\') a++;\\n            if(ch==\\'l\\') l++;\\n            if(ch==\\'o\\') o++;\\n            if(ch==\\'n\\') n++;\\n        }\\n        \\n        int ans=0;\\n        \\n        while(b>=1 && a>=1 && l>=2 && o>=2 && n>=1){\\n            ans++;\\n            \\n            b=b-1;\\n            a=a-1;\\n            l=l-2;\\n            o=o-2;\\n            n=n-1;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        \\n        int b=0,a=0,l=0,o=0,n=0;\\n        \\n        for(char ch: text.toCharArray()){\\n            if(ch==\\'b\\') b++;\\n            if(ch==\\'a\\') a++;\\n            if(ch==\\'l\\') l++;\\n            if(ch==\\'o\\') o++;\\n            if(ch==\\'n\\') n++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2633073,
                "title": "javascript-this-is-dumb-but-fast-97-5",
                "content": "```\\n    let map = {\\n        a: 1,\\n        b: 1,\\n        l: 2,\\n        o: 2,\\n        n: 1\\n    };\\n    \\n    for (let char of text){\\n        if (map[char]) map[char] ++;\\n    }\\n    \\n    map[\\'l\\'] = Math.floor(map[\\'l\\']/2);\\n    map[\\'o\\'] = Math.floor(map[\\'o\\']/2);\\n    let arr = Object.values(map);\\n    \\n    return Math.min(...arr) - 1;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    let map = {\\n        a: 1,\\n        b: 1,\\n        l: 2,\\n        o: 2,\\n        n: 1\\n    };\\n    \\n    for (let char of text){\\n        if (map[char]) map[char] ++;\\n    }\\n    \\n    map[\\'l\\'] = Math.floor(map[\\'l\\']/2);\\n    map[\\'o\\'] = Math.floor(map[\\'o\\']/2);\\n    let arr = Object.values(map);\\n    \\n    return Math.min(...arr) - 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593760,
                "title": "c-using-map-easy-understanding-linear",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int>mp;\\n        mp[\\'b\\']=0;\\n        mp[\\'a\\']=0;\\n        mp[\\'l\\']=0;\\n        mp[\\'l\\']=0;\\n        mp[\\'o\\']=0;\\n        mp[\\'o\\']=0;\\n        mp[\\'n\\']=0;\\n        \\n        transform(text.begin(), text.end(), text.begin(), ::tolower);\\n        \\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==\\'b\\')mp[\\'b\\']++;\\n            else if(text[i]==\\'a\\')mp[\\'a\\']++;\\n            else if(text[i]==\\'l\\')mp[\\'l\\']++;\\n            else if(text[i]==\\'o\\')mp[\\'o\\']++;\\n            else if(text[i]==\\'n\\')mp[\\'n\\']++;\\n        }\\n        int mi=INT_MAX;\\n        \\n        if(mp[\\'l\\']<2)return 0;\\n        if(mp[\\'o\\']<2)return 0;\\n        \\n        mp[\\'l\\']=floor(mp[\\'l\\']/2);   //because thier are two l in \\'balloon\\'  \\n        mp[\\'o\\']=floor(mp[\\'o\\']/2); ////because thier are two o in \\'balloon\\'\\n            \\n        for(auto i:mp)\\n        {\\n            if(i.second==0)return 0;   //if any letter is missing from balloon return 0 \\n            mi=min(mi,i.second);\\n        }\\n        \\n        return mi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int>mp;\\n        mp[\\'b\\']=0;\\n        mp[\\'a\\']=0;\\n        mp[\\'l\\']=0;\\n        mp[\\'l\\']=0;\\n        mp[\\'o\\']=0;\\n        mp[\\'o\\']=0;\\n        mp[\\'n\\']=0;\\n        \\n        transform(text.begin(), text.end(), text.begin(), ::tolower);\\n        \\n        for(int i=0;i<text.length();i++)\\n        {\\n            if(text[i]==\\'b\\')mp[\\'b\\']++;\\n            else if(text[i]==\\'a\\')mp[\\'a\\']++;\\n            else if(text[i]==\\'l\\')mp[\\'l\\']++;\\n            else if(text[i]==\\'o\\')mp[\\'o\\']++;\\n            else if(text[i]==\\'n\\')mp[\\'n\\']++;\\n        }\\n        int mi=INT_MAX;\\n        \\n        if(mp[\\'l\\']<2)return 0;\\n        if(mp[\\'o\\']<2)return 0;\\n        \\n        mp[\\'l\\']=floor(mp[\\'l\\']/2);   //because thier are two l in \\'balloon\\'  \\n        mp[\\'o\\']=floor(mp[\\'o\\']/2); ////because thier are two o in \\'balloon\\'\\n            \\n        for(auto i:mp)\\n        {\\n            if(i.second==0)return 0;   //if any letter is missing from balloon return 0 \\n            mi=min(mi,i.second);\\n        }\\n        \\n        return mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567386,
                "title": "easy-c-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int> mp1,mp2;\\n        for(auto it:text) mp1[it]++;\\n        string s=\"balloon\";\\n        for(auto it:s) mp2[it]++;\\n        int mini=INT_MAX;\\n        for(auto &ch:mp2) {\\n            if(mp1.find(ch.first)==mp1.end()) {\\n                mini=0;\\n                break;\\n            }\\n            else {\\n                mini= min(mini, mp1[ch.first]/ch.second);\\n            }\\n        }\\n        return mini;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int maxNumberOfBalloons(string text) {\\n        unordered_map<char,int> mp1,mp2;\\n        for(auto it:text) mp1[it]++;\\n        string s=\"balloon\";\\n        for(auto it:s) mp2[it]++;\\n        int mini=INT_MAX;\\n        for(auto &ch:mp2) {\\n            if(mp1.find(ch.first)==mp1.end()) {\\n                mini=0;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2520722,
                "title": "python-simple-using-counter",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = Counter(text)\\n        return min(c[\\'b\\'], c[\\'a\\'], c[\\'n\\'], c[\\'l\\']//2, c[\\'o\\']//2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        c = Counter(text)\\n        return min(c[\\'b\\'], c[\\'a\\'], c[\\'n\\'], c[\\'l\\']//2, c[\\'o\\']//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465545,
                "title": "elegant-python-solution",
                "content": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        x = collections.Counter(text)\\n        y = collections.Counter(\"balloon\")\\n        return min(x[c]//y[c] for c in y)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        x = collections.Counter(text)\\n        y = collections.Counter(\"balloon\")\\n        return min(x[c]//y[c] for c in y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441764,
                "title": "maximum-number-of-balloons",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0; \\n        for (int i = 0; i < text.length(); i++) {\\n            if (text.charAt(i) == \\'b\\') b++;\\n            else if (text.charAt(i) == \\'a\\') a++;\\n            else if (text.charAt(i) == \\'l\\') l++;\\n            else if (text.charAt(i) == \\'o\\') o++;\\n            else if (text.charAt(i) == \\'n\\') n++;\\n        }\\n        l = l/2;\\n        o = o/2;\\n        return Collections.min(List.of(b,a,l,o,n));  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        int b, a, l, o, n;\\n        b = a = l = o = n = 0; \\n        for (int i = 0; i < text.length(); i++) {\\n            if (text.charAt(i) == \\'b\\') b++;\\n            else if (text.charAt(i) == \\'a\\') a++;\\n            else if (text.charAt(i) == \\'l\\') l++;\\n            else if (text.charAt(i) == \\'o\\') o++;\\n            else if (text.charAt(i) == \\'n\\') n++;\\n        }\\n        l = l/2;\\n        o = o/2;\\n        return Collections.min(List.of(b,a,l,o,n));  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338145,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < text.length() ; i++){\\n            if(\"balloon\".contains(\"\"+text.charAt(i)))\\n            map.put(text.charAt(i),map.getOrDefault(text.charAt(i),0)+1);\\n        }\\n        \\n        int noi = 0;\\n         \\n if(map.containsKey(\\'a\\')&& map.containsKey(\\'b\\') && map.containsKey(\\'l\\') && map.containsKey(\\'o\\')&& map.containsKey(\\'n\\')){\\n        while(true){\\n if(map.get(\\'a\\') < 1 || map.get(\\'b\\') < 1 || map.get(\\'l\\') < 2 || map.get(\\'o\\') < 2 || map.get(\\'n\\') < 1) break;\\n            map.put(\\'a\\',map.get(\\'a\\')-1);\\n            map.put(\\'b\\',map.get(\\'b\\')-1);\\n            map.put(\\'l\\',map.get(\\'l\\')-2);\\n            map.put(\\'o\\',map.get(\\'o\\')-2);\\n            map.put(\\'n\\',map.get(\\'n\\')-1);\\n          \\n            noi++;\\n        }\\n      } \\n        return noi;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < text.length() ; i++){\\n            if(\"balloon\".contains(\"\"+text.charAt(i)))\\n            map.put(text.charAt(i),map.getOrDefault(text.charAt(i),0)+1);\\n        }\\n        \\n        int noi = 0;\\n         \\n if(map.containsKey(\\'a\\')&& map.containsKey(\\'b\\') && map.containsKey(\\'l\\') && map.containsKey(\\'o\\')&& map.containsKey(\\'n\\')){\\n        while(true){\\n if(map.get(\\'a\\') < 1 || map.get(\\'b\\') < 1 || map.get(\\'l\\') < 2 || map.get(\\'o\\') < 2 || map.get(\\'n\\') < 1) break;\\n            map.put(\\'a\\',map.get(\\'a\\')-1);\\n            map.put(\\'b\\',map.get(\\'b\\')-1);\\n            map.put(\\'l\\',map.get(\\'l\\')-2);\\n            map.put(\\'o\\',map.get(\\'o\\')-2);\\n            map.put(\\'n\\',map.get(\\'n\\')-1);\\n          \\n            noi++;\\n        }\\n      } \\n        return noi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278692,
                "title": "100-faster-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        vector<int> dp(26, 0);\\n        for(int i=0;i<text.size();++i){\\n            dp[text[i]-\\'a\\']++;\\n        }\\n        return min({ dp[\\'a\\'-\\'a\\'], dp[\\'b\\'-\\'a\\'], dp[\\'l\\'-\\'a\\']/2, dp[\\'o\\'-\\'a\\']/2, dp[\\'n\\'-\\'a\\']});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        vector<int> dp(26, 0);\\n        for(int i=0;i<text.size();++i){\\n            dp[text[i]-\\'a\\']++;\\n        }\\n        return min({ dp[\\'a\\'-\\'a\\'], dp[\\'b\\'-\\'a\\'], dp[\\'l\\'-\\'a\\']/2, dp[\\'o\\'-\\'a\\']/2, dp[\\'n\\'-\\'a\\']});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255484,
                "title": "c-easy-to-understand",
                "content": "```\\nint maxNumberOfBalloons(string text) {\\n        int b=0;\\n        int a=0;\\n        int l=0;\\n        int o=0;\\n        int n=0;\\n        for(auto i:text){\\n            if(i==\\'b\\'){\\n                b++;\\n            }\\n            else if(i==\\'a\\'){\\n                a++;\\n            }\\n            else if(i==\\'l\\'){\\n                l++;\\n            }\\n            else if(i==\\'o\\'){\\n                o++;\\n            }\\n            else if(i==\\'n\\'){\\n                n++;\\n            }\\n        }\\n        \\n        l=l/2;\\n        o=o/2;\\n        return min(b,min(a,min(l,min(o,n))));\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxNumberOfBalloons(string text) {\\n        int b=0;\\n        int a=0;\\n        int l=0;\\n        int o=0;\\n        int n=0;\\n        for(auto i:text){\\n            if(i==\\'b\\'){\\n                b++;\\n            }\\n            else if(i==\\'a\\'){\\n                a++;\\n            }\\n            else if(i==\\'l\\'){\\n                l++;\\n            }\\n            else if(i==\\'o\\'){\\n                o++;\\n            }\\n            else if(i==\\'n\\'){\\n                n++;\\n            }\\n        }\\n        \\n        l=l/2;\\n        o=o/2;\\n        return min(b,min(a,min(l,min(o,n))));\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1904792,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            },
            {
                "id": 1932454,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            },
            {
                "id": 1793949,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            },
            {
                "id": 1941968,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            },
            {
                "id": 1935303,
                "content": [
                    {
                        "username": "KeshavJha2002",
                        "content": "This question helped me realize I don\\'t know the spelling of BALLON"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good use-case for a counting array, seeing as we have a known range of letters. Think about how you can iterate over the letters we need, and compare to the minimum number of letters. The catch will be how you handle \\'l\\' and \\'o\\', as you need two for one \\'balloon\\'."
                    },
                    {
                        "username": "Frankie_Lee",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxNumberOfBalloons(string text) {\\n        int ans = INT_MAX;\\n        unordered_map<char,int>umap;\\n        umap[\\'b\\'] = 0;\\n        umap[\\'a\\'] = 0;\\n        umap[\\'l\\'] = 0;\\n        umap[\\'o\\'] = 0;\\n        umap[\\'n\\'] = 0;\\n        for(char ch : text){\\n            if(umap.count(ch)) umap[ch]++;\\n        }\\n        umap[\\'l\\'] /=2;\\n        umap[\\'o\\'] /=2;\\n        for(auto v : umap)\\n            ans = min(ans,v.second);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "russel-ra",
                        "content": "1. Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "niteshky01",
                        "content": "use frequency arr concept\\n "
                    },
                    {
                        "username": "RhaskiaGameDev",
                        "content": "My code seems to run through each test case until number 19 with ease, I\\'m confused what is so different about case 19"
                    }
                ]
            }
        ]
    },
    {
        "title": "Kth Smallest Instructions",
        "question_content": "<p>Bob is standing at cell <code>(0, 0)</code>, and he wants to reach <code>destination</code>: <code>(row, column)</code>. He can only travel <strong>right</strong> and <strong>down</strong>. You are going to help Bob by providing <strong>instructions</strong> for him to reach <code>destination</code>.</p>\n\n<p>The <strong>instructions</strong> are represented as a string, where each character is either:</p>\n\n<ul>\n\t<li><code>&#39;H&#39;</code>, meaning move horizontally (go <strong>right</strong>), or</li>\n\t<li><code>&#39;V&#39;</code>, meaning move vertically (go <strong>down</strong>).</li>\n</ul>\n\n<p>Multiple <strong>instructions</strong> will lead Bob to <code>destination</code>. For example, if <code>destination</code> is <code>(2, 3)</code>, both <code>&quot;HHHVV&quot;</code> and <code>&quot;HVHVH&quot;</code> are valid <strong>instructions</strong>.</p>\n\n<p>However, Bob is very picky. Bob has a lucky number <code>k</code>, and he wants the <code>k<sup>th</sup></code> <strong>lexicographically smallest instructions</strong> that will lead him to <code>destination</code>. <code>k</code> is <strong>1-indexed</strong>.</p>\n\n<p>Given an integer array <code>destination</code> and an integer <code>k</code>, return <em>the </em><code>k<sup>th</sup></code><em> <strong>lexicographically smallest instructions</strong> that will take Bob to </em><code>destination</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex1.png\" style=\"width: 300px; height: 229px;\" /></p>\n\n<pre>\n<strong>Input:</strong> destination = [2,3], k = 1\n<strong>Output:</strong> &quot;HHHVV&quot;\n<strong>Explanation:</strong> All the instructions that reach (2, 3) in lexicographic order are as follows:\n[&quot;HHHVV&quot;, &quot;HHVHV&quot;, &quot;HHVVH&quot;, &quot;HVHHV&quot;, &quot;HVHVH&quot;, &quot;HVVHH&quot;, &quot;VHHHV&quot;, &quot;VHHVH&quot;, &quot;VHVHH&quot;, &quot;VVHHH&quot;].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex2.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> destination = [2,3], k = 2\n<strong>Output:</strong> &quot;HHVHV&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex3.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> destination = [2,3], k = 3\n<strong>Output:</strong> &quot;HHVVH&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>destination.length == 2</code></li>\n\t<li><code>1 &lt;= row, column &lt;= 15</code></li>\n\t<li><code>1 &lt;= k &lt;= nCr(row + column, row)</code>, where <code>nCr(a, b)</code> denotes <code>a</code> choose <code>b</code>​​​​​.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 918396,
                "title": "python-math-solution-introduction-to-combinatorics",
                "content": "*Feel free to skip to the solution below if you already understand combinatorics.*\\n\\n**Introduction**\\n\"Combinatorics\" is basically the mathematical science of counting. In our case, as software engineers, it\\'s usually about the efficient automation of that counting - and there\\'s a lot of counting to be done here, for sure!\\n\\nFirst of all, we know these things, regardless of the destination:\\n1. Since Bob has to walk from `(0, 0)` to `(r, c)`, he has to follow a total of `r + c` instructions.\\n2. `r` of those instructions will be downward (`\"V\"`) movements, and `c` of the instructions will be horizontal (`\"H\"`) movements.\\n\\nSo, we know that every set of instructions for Bob will be some string that is the combination of `\"H\"` and `\"V\"` with length `r + c`, exactly `r` characters will be `\"V\"`, and exactly `c` characters will be `\"H\"`.\\n\\n**Combinatorics**\\nNow that we have that out of the way, let\\'s analyze a hint that the problem gives us. The final constraint says this:\\n> `1 <= k <= nCr(row + column, row)`, where `nCr(a, b)` denotes `a` choose `b`.\\n\\n`nCr(a, b)`, or \"`a` choose `b`\" as they put it, is the number of ways that you can select `b` elements from a set of `a` unique elements.  Let\\'s consider `nCr(3, 2)` for example: that means we have 3 unique elements - `000`. Let `1` represent an element that we\\'ve selected: there are three ways to select exactly 2 elements, shown below:\\n- `011`\\n- `101`\\n- `110`\\n \\nYou don\\'t need the formula for `nCr(a, b)` since your language most likely has it as a library, but here it is if you\\'re interested (`!` is the [factorial](https://en.wikipedia.org/wiki/Factorial) function):\\n> `nCr(a, b) = (a!) / ((b!) * (a - b)!)`\\n\\n**Solution**\\n`\"H\"` is lexicographically smaller than `\"V\"`. That means that, at index `i` of an arbitrary solution, placing an `\"H\"` at `i` will make the resulting instruction set lexicographically smaller than if we placed a `\"V\"` at that index instead.\\n\\nLet\\'s break this down in terms of what we\\'ve learned about Combinatorics. If we have `r + c` total elements and `r` of those elements are `\"V\"`, then we have `nCr(r + c, r)` possible instruction sets that Bob can walk. At each of his `r + c` total steps, we have two options:\\n- Walk right one column, which will leave us with the same number of `\"V\"`\\'s\\n- Walk down one row, which will decrease our number of `\"V\"`\\'s by 1 (remember that we only have `r` of these!)\\n\\n**If we choose to walk down a row when we have N more steps and R possible rows left to walk down (including the current step), then we\\'re cutting out the number of combinations of (N - 1) steps with R rows to walk down, because all of those combinations would result in a lexicographically smaller instruction set.**\\n\\nSo, for each step where we have N more possible steps (including the current step), calculate `nCr(N - 1, R)`. If k is less than or equal to this number, travel horizontally. Otherwise, subtract that number from k, decrease the number of vertical movements we\\'re allowed to make, and then travel vertically.\\n\\n```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        r, c = destination\\n        \\n        ret = []\\n        remDown = r\\n        for i in range(r + c):\\n            remSteps = r + c - (i + 1)\\n            com = comb(remSteps, remDown)\\n            if com >= k:\\n                ret.append(\"H\")\\n            else:\\n                remDown -= 1\\n                k -= com\\n                ret.append(\"V\")\\n                \\n        return \\'\\'.join(ret)\\n```\\n\\nPlease leave a comment if you have any questions!",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        r, c = destination\\n        \\n        ret = []\\n        remDown = r\\n        for i in range(r + c):\\n            remSteps = r + c - (i + 1)\\n            com = comb(remSteps, remDown)\\n            if com >= k:\\n                ret.append(\"H\")\\n            else:\\n                remDown -= 1\\n                k -= com\\n                ret.append(\"V\")\\n                \\n        return \\'\\'.join(ret)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 918375,
                "title": "c-combination",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Combination\\n\\nGiven `destination: (row, column)`, we will have `column` `H` and `row` `V` in the result.\\n\\nLet\\'s denote `h = column`, `v = row` meaning the number of `H` and `V` left to pick, respectively. The result is of length `h + v`.\\n\\nWe pick the character one by one for the result.\\n\\nFor the first character, if we pick `H`, the rest of characters can form `c = nCr(h - 1 + v, v)` combinations.\\n\\nIf `k <= c`, it means that the result is one of these `c` combinations. So we should pick `H` here. We append `H` to the result and `--h`.\\n\\nOtherwise, we should pick `V` instead, and do `--v` and `k -= c` (skip these `c` combinations).\\n\\nWe keep doing this until we made choice for all the `h + v` characters.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-213/problems/kth-smallest-instructions/\\n// Author: github.com/lzl124631x\\n// Time: O((H + V)^2)\\n// Space: O(1)\\nclass Solution {\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // we have H available to pick\\n                int c = comb(h - 1 + v, v); // if we pick H at the current position, there will be `c` combinations for the rest of characters\\n                if (k <= c) { // k is covered within `c`, so we should pick H.\\n                    s += \\'H\\';\\n                    --h;\\n                } else { // otherwise we should pick V\\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } else { // no H left, have to pick V.\\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n---\\n\\nUpdate 11/1/2020:\\n\\nWhy `k -= c`?\\n\\nExample:\\n\\nAssume `k = 4` and we have `2H2V` to pick.\\n\\nIf the first character is `H`, then there are `1H2V` left which can form `nCr(3, 2) = 3` combinations.\\n\\n```\\nH HVV\\nH VHV\\nH VVH\\n\\nV HHV   <\\nV HVH\\nV VHH\\n```\\n\\nBut since `k = 4 > 3` so the first character must not be `H`. So `V` is selected. \\n\\nNow we have `2H1V` left. It is `k\\' = 4 - 3 = 1`st string that we are looking for now.",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-213/problems/kth-smallest-instructions/\\n// Author: github.com/lzl124631x\\n// Time: O((H + V)^2)\\n// Space: O(1)\\nclass Solution {\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // we have H available to pick\\n                int c = comb(h - 1 + v, v); // if we pick H at the current position, there will be `c` combinations for the rest of characters\\n                if (k <= c) { // k is covered within `c`, so we should pick H.\\n                    s += \\'H\\';\\n                    --h;\\n                } else { // otherwise we should pick V\\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } else { // no H left, have to pick V.\\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nH HVV\\nH VHV\\nH VVH\\n\\nV HHV   <\\nV HVH\\nV VHH\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918436,
                "title": "java-o-r-c-very-easy-to-understand",
                "content": "time complexity O(row * col)\\nit\\'s a variation of the dungeon games, we can solve it in a similar way\\n```\\npublic String kthSmallestPath(int[] destination, int k) {\\n        \\n        int ti = destination[0], tj = destination[1];\\n        int[][] dp = new int[ti+1][tj+1];\\n        for(int i = ti; i >= 0; i--){\\n            for(int j = tj; j >= 0; j--){\\n                if(i == ti && j == tj){\\n                    dp[i][j] = 1;\\n                }else if(i == ti){\\n                    dp[i][j] = dp[i][j+1];\\n                }else if(j == tj){\\n                    dp[i][j] = dp[i+1][j];\\n                }else{\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        \\n        // in each (i, j), we have dp[i][j] kind of instructions, which equal to dp[i][j+1] + dp[i+1][j]\\n        // all dp[i][j+1] kinds of instructions are lexicographically smaller than the left dp[i+1][j] kinds of instructions.\\n        // we can just compare k with dp[i][j+1] to determin how to choose next step.\\n        \\n        StringBuilder sb = new StringBuilder();\\n        helper(dp, 0, 0, k, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void helper(int[][] dp, int i, int j, int k, StringBuilder sb){\\n        \\n        if(i == dp.length -1){\\n            // if we came to most down position then we can only go right\\n            while(++j < dp[0].length)sb.append(\"H\");\\n            return;\\n        }\\n        if(j == dp[0].length - 1){\\n            //if we came to most right position then we can only go down\\n            while(++i < dp.length)sb.append(\"V\");\\n            return;\\n        }\\n        if(dp[i][j+1] >= k){\\n            //if k is smaller than the first dp[i][j+1] solutions, then we should go right\\n            sb.append(\"H\");\\n            helper(dp, i, j+1, k, sb);\\n        }else{\\n            //else we go donw, and we should also minus the first dp[i][j+1] solutions from k\\n            sb.append(\"V\");\\n            helper(dp, i+1, j, k-dp[i][j+1], sb);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String kthSmallestPath(int[] destination, int k) {\\n        \\n        int ti = destination[0], tj = destination[1];\\n        int[][] dp = new int[ti+1][tj+1];\\n        for(int i = ti; i >= 0; i--){\\n            for(int j = tj; j >= 0; j--){\\n                if(i == ti && j == tj){\\n                    dp[i][j] = 1;\\n                }else if(i == ti){\\n                    dp[i][j] = dp[i][j+1];\\n                }else if(j == tj){\\n                    dp[i][j] = dp[i+1][j];\\n                }else{\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n            }\\n        }\\n        \\n        \\n        // in each (i, j), we have dp[i][j] kind of instructions, which equal to dp[i][j+1] + dp[i+1][j]\\n        // all dp[i][j+1] kinds of instructions are lexicographically smaller than the left dp[i+1][j] kinds of instructions.\\n        // we can just compare k with dp[i][j+1] to determin how to choose next step.\\n        \\n        StringBuilder sb = new StringBuilder();\\n        helper(dp, 0, 0, k, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void helper(int[][] dp, int i, int j, int k, StringBuilder sb){\\n        \\n        if(i == dp.length -1){\\n            // if we came to most down position then we can only go right\\n            while(++j < dp[0].length)sb.append(\"H\");\\n            return;\\n        }\\n        if(j == dp[0].length - 1){\\n            //if we came to most right position then we can only go down\\n            while(++i < dp.length)sb.append(\"V\");\\n            return;\\n        }\\n        if(dp[i][j+1] >= k){\\n            //if k is smaller than the first dp[i][j+1] solutions, then we should go right\\n            sb.append(\"H\");\\n            helper(dp, i, j+1, k, sb);\\n        }else{\\n            //else we go donw, and we should also minus the first dp[i][j+1] solutions from k\\n            sb.append(\"V\");\\n            helper(dp, i+1, j, k-dp[i][j+1], sb);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918393,
                "title": "python-o-m-n-2-solution-explained",
                "content": "Actualy, I was suprised, why this problem is marked as Hard: all you need to do is to on each moment of time see how many options we have if we go to the right and if we can afford this step or no. If we are out of options, that is `k = 1`, then we build the rest of the sequence either with `H` or with `V`.\\n\\n**Complexity**: time complexity is `O((m+n)^2)` for time: we use `comb()` function `O(m+n)` times, where complexity of each evaluation is `O(m+n)` as well. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination, k):\\n        m, n, ans = destination[0], destination[1], \"\"\\n        for i in range(m+n):\\n            if k == 1:  #no options left\\n                ans += \"H\"*n + \"V\"*m\\n                break\\n\\n            if k <= comb(m+n-1, m):\\n                n -= 1\\n                ans += \"H\"\\n            else:\\n                ans += \"V\"\\n                k -= comb(m+n-1, m)\\n                m -= 1\\n                \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination, k):\\n        m, n, ans = destination[0], destination[1], \"\"\\n        for i in range(m+n):\\n            if k == 1:  #no options left\\n                ans += \"H\"*n + \"V\"*m\\n                break\\n\\n            if k <= comb(m+n-1, m):\\n                n -= 1\\n                ans += \"H\"\\n            else:\\n                ans += \"V\"\\n                k -= comb(m+n-1, m)\\n                m -= 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918569,
                "title": "java-bottom-up-dp-o-m-n-solution",
                "content": "just need to pre calculate the combination in the dp array. then at every step, choose to go right if the rest of matrix with i rows, j - 1 columns has more paths than k. choose to go down otherwise. \\n\\n```\\npublic String kthSmallestPath(int[] destination, int k) {\\n    // dp(i, j) means how many paths are there for matrix of size i row and j column.\\n\\tint[][] dp = new int[destination[0] + 1][destination[1] + 1];\\n\\tfor(int i = 0; i <= destination[0]; i++){\\n\\t\\tfor(int j = 0; j <= destination[1]; j++) {\\n\\t\\t\\tif(i == 0 && j == 0) dp[i][j] = 1;\\n\\t\\t\\telse if(i == 0) dp[i][j] = dp[i][j - 1];\\n\\t\\t\\telse if(j == 0) dp[i][j] = dp[i - 1][j];\\n\\t\\t\\telse dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\tStringBuilder sb = new StringBuilder();\\n\\tint i = destination[0], j = destination[1];\\n\\twhile(i != 0 && j != 0) {\\n\\t    // if k is smaller than or equal with the number of paths starting with H, then we pick \\'H\\' for current position.\\n\\t\\tif(dp[i][j - 1] >= k) {\\n\\t\\t\\tj--;\\n\\t\\t\\tsb.append(\\'H\\');\\n\\t\\t// if k is larger than the number of paths starting with \\'H\\', we have to pick V then.\\n\\t\\t}else {\\n\\t\\t\\tk -= dp[i][j - 1];\\n\\t\\t\\ti--;\\n\\t\\t\\tsb.append(\\'V\\');\\n\\t\\t}\\n\\t}\\n\\tfor(int m = 0; m < i; m++) sb.append(\\'V\\');\\n\\tfor(int m = 0; m < j; m++) sb.append(\\'H\\');\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String kthSmallestPath(int[] destination, int k) {\\n    // dp(i, j) means how many paths are there for matrix of size i row and j column.\\n\\tint[][] dp = new int[destination[0] + 1][destination[1] + 1];\\n\\tfor(int i = 0; i <= destination[0]; i++){\\n\\t\\tfor(int j = 0; j <= destination[1]; j++) {\\n\\t\\t\\tif(i == 0 && j == 0) dp[i][j] = 1;\\n\\t\\t\\telse if(i == 0) dp[i][j] = dp[i][j - 1];\\n\\t\\t\\telse if(j == 0) dp[i][j] = dp[i - 1][j];\\n\\t\\t\\telse dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\tStringBuilder sb = new StringBuilder();\\n\\tint i = destination[0], j = destination[1];\\n\\twhile(i != 0 && j != 0) {\\n\\t    // if k is smaller than or equal with the number of paths starting with H, then we pick \\'H\\' for current position.\\n\\t\\tif(dp[i][j - 1] >= k) {\\n\\t\\t\\tj--;\\n\\t\\t\\tsb.append(\\'H\\');\\n\\t\\t// if k is larger than the number of paths starting with \\'H\\', we have to pick V then.\\n\\t\\t}else {\\n\\t\\t\\tk -= dp[i][j - 1];\\n\\t\\t\\ti--;\\n\\t\\t\\tsb.append(\\'V\\');\\n\\t\\t}\\n\\t}\\n\\tfor(int m = 0; m < i; m++) sb.append(\\'V\\');\\n\\tfor(int m = 0; m < j; m++) sb.append(\\'H\\');\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918388,
                "title": "python-simple-fast-solution-explained",
                "content": "**Observations**\\n1. We know for certain number of **\\'H\\'** and **\\'V\\'**, the total number of instructions are **comb(h + v, v)**\\n2. They should be sorted **lexicographically**, which means: the **order** of instructions with first character of **\\'H\\'** are always smaller than instructions with first character of **\\'V\\'**:\\nFor example, **destination = [2,3], k = 1**:\\n[\"**H**HHVV\", \"**H**HVHV\", \"**H**HVVH\", \"**H**VHHV\", \"**H**VHVH\", \"**H**VVHH\", \"**V**HHHV\", \"**V**HHVH\", \"**V**HVHH\", \"**V**VHHH\"]\\n3. If the first character is **\\'H\\'**, we know there will be **comb(h + v - 1, v)** number of instructions for the rest of characters because we used **one** **\\'H\\'**.\\n\\n**Algo**\\n1. Use the above 3 facts, we know after sored, **comb(h + v - 1, v)** number of instructions starting with **\\'H\\'**, and the rest of the instructions are starting with **\\'V\\'**\\n2. Based on value of **k**, we will know which **group** the kth instructions belongs to\\n3. Then we can get the characters one by one\\n4. Available characters will be **decreasing** until one of them hit **0**\\n\\n**Code:**\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        v, h = destination\\n        res = \\'\\'\\n        while h > 0 and v > 0:\\n            pre = comb(h + v - 1, v)\\n            \\n            if k <= pre:\\n                res += \\'H\\'\\n                h -= 1\\n            else:\\n                res += \\'V\\'\\n                v -= 1\\n                k -= pre\\n\\n        if h == 0:\\n            res += \\'V\\' * v\\n        if v == 0:\\n            res += \\'H\\' * h\\n            \\n        return res\\n```\\n**Runtime: 32ms**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        v, h = destination\\n        res = \\'\\'\\n        while h > 0 and v > 0:\\n            pre = comb(h + v - 1, v)\\n            \\n            if k <= pre:\\n                res += \\'H\\'\\n                h -= 1\\n            else:\\n                res += \\'V\\'\\n                v -= 1\\n                k -= pre\\n\\n        if h == 0:\\n            res += \\'V\\' * v\\n        if v == 0:\\n            res += \\'H\\' * h\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919710,
                "title": "c-pascal-triangle",
                "content": "OK, I am not good at this - but I wanted to solve it on intuition (without looking into textbooks). Took me a while. This may not be the best solution - there are several great math solutions with explanations in the discussion thread - check them out!\\n\\nInitially, I used \"next_permutation\" `k` times. That was too slow, obviously, but gave insight on how the string changes.\\n\\nLet\\'s think about it - imagine you have \"HHHHVVVV\". How many steps do we need to get to these states:\\n- \"HHHVVVV**H**\"?\\n- \"HHVVVV**HH**\"?\\n- \"HVVVV**HHH**\"?\\n- \"VVVV**HHHH**\"?\\n\\nThese are the largest combinations with 4 \"V\" and `i` \"H\". We get to these states after we exhausted all combinations with:\\n- 4 \"V\" and 1 \"H\" = nCr(4, 1) = 5 steps\\n- 4 \"V\" and 2 \"H\" = nCr(4, 2) = 15 steps\\n- 4 \"V\" and 3 \"H\" = nCr(4, 3) = 35 steps\\n- 4 \"V\" and 4 \"H\" = nCr(4, 4) = 70 steps\\n\\n`nCr(a, b)` is the number of combinations to choose `b` elements out of `a`. I am using the Pascal Triangle with memoisation to compute this. You get `Comb` for free if you use Python, and you better know this method if you want to stick with C++.\\n\\nSo the idea is to find out how many \"H\" we can move all the way to the right within `k`. Now, if \\'k\\' is zero - we construct and return the string - easy. \\n\\nOtherwise, we need to do one more step. What is the next permutation for \"HHHVVVV**H**\" (`i == 1`) ? It\\'s \"HH**V**HHVVV\". The first \"V\" is in its final position, and the rest of the string - the smallest combination of remaining Hs and Vs. So, we keep `i + 1` \"H\", add 1 \"V\", and call `kthSmallestPath` for remaining \"H\", \"V\" and `k`.\\n\\nExample: [4, 4], k == \\'9\\'.\\n1. 5 steps to get from \"HHHHVVVV\" to \"HHHVVVV**H**\", `i == 1`. \\n2. Keep \"HHV\", and call our function for [2, 3], `k == 4`.\\n3. 4 steps to get from \"HHVVV\" to \"HVVV**H**\", `i == 1`.\\n4. `k == 0`, return \"HVVVH\".\\n5. Combine strings, the final result is \"HHV\" + \"HVVVH\".\\n\\n**C++**\\n```cpp\\nint dp[17][17] = {};\\nclass Solution {\\n    int nCr(int i, int j) {\\n        if (i == 1 || j == 1)\\n            return 1;\\n        return dp[i][j] ? dp[i][j] : dp[i][j] = nCr(i - 1, j) + nCr(i, j - 1);\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        int h = d[1], v = d[0], cur = 1, i = 1;\\n        for (; i <= h; ++i) {\\n            if (nCr(v + 1, i + 1) > k)\\n                break;                \\n            cur = nCr(v + 1, i + 1);\\n        }\\n        if (k - cur == 0)\\n            return string(h - i + 1, \\'H\\') + string(v, \\'V\\') + string(i - 1, \\'H\\');\\n        return string(h - i, \\'H\\')  + \"V\" + kthSmallestPath(vector<int>() = {v - 1 , i}, k - cur);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[17][17] = {};\\nclass Solution {\\n    int nCr(int i, int j) {\\n        if (i == 1 || j == 1)\\n            return 1;\\n        return dp[i][j] ? dp[i][j] : dp[i][j] = nCr(i - 1, j) + nCr(i, j - 1);\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        int h = d[1], v = d[0], cur = 1, i = 1;\\n        for (; i <= h; ++i) {\\n            if (nCr(v + 1, i + 1) > k)\\n                break;                \\n            cur = nCr(v + 1, i + 1);\\n        }\\n        if (k - cur == 0)\\n            return string(h - i + 1, \\'H\\') + string(v, \\'V\\') + string(i - 1, \\'H\\');\\n        return string(h - i, \\'H\\')  + \"V\" + kthSmallestPath(vector<int>() = {v - 1 , i}, k - cur);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922323,
                "title": "c-o-n-explained",
                "content": "#### Fundamentals\\n\\n- We need to move to the right `col` steps and down `row` steps to reach to the destination (bottom right) cell => the result string is always:\\n  - of length `col + row`\\n  - consisted of `row` \\'H\\'s and `col` \\'V\\'s\\n- The possible strings are **lexicographically ordered** => \\'H\\' < \\'V\\'\\n- The total number of possible paths (number of combinations of `row` \\'H\\'s and `col` \\'V\\'s) is `nCr(row + col, row)`. i.e., `\"length of string\" choose \"number of H\"`\\n  - Why? We have `row + col` positions in the string, we need to choose `row` of them for \\'H\\'.\\n- How to calculate `N choose K`?\\n  - `N!/(N-K)!/K!` (Why? this is a math question. I\\'m not going to explain it here)\\n  - `tgamma(x)` returns `(x-1)!`\\n  - There are many other methods to calculate `N choose K`\\n\\n#### Solve the Problem\\n\\n1. Let\\'s only consider the first letter.\\n  a) Say, we have `h` of \\'H\\'s and `v` of \\'V\\'s, there are `x` possible combinations (`x = nCr(h+v, h)`)\\n  b) The chance we choose \\'H\\' for the first letter is `h/(h+v)` => in all combinations, there are `y` of them (`y = x * h/(h+v)`) have \\'H\\' as the first letter\\n  c) All the combinations are *lexicographically ordered* => the **first** `y` combinations have \\'H\\' as the first letter\\n  d) We want the *kth* combination => **if `k <= y`, the first letter should be \\'H\\', otherwise it should be \\'V\\'.**\\n2. We have found the first letter. Now let\\'s look at the next one:\\n\\ta) If the first letter is \\'H\\'\\n\\t\\t- The number of combinations start with \\'H\\' is `y` (calculated in step 1)\\n\\t\\t- We have used one \\'H\\', and we have `h-1` left\\n\\t\\t- The length of rest of strting is `h+v-1`\\n\\t\\t- The remaining combinations (all start with \\'H\\') - from 1st to yth, since k fell into this range, it remains the same (we need to find kth combination of 1 to y).\\n\\tb) If the first letter is \\'V\\'\\n\\t\\t- The number of combinations start with \\'V\\' is `x - y`\\n\\t\\t- We didn\\'t use \\'H\\', so we still have `h` \\'H\\'s left\\n\\t\\t- The length of rest of strting is `h+v-1`\\n\\t\\t- The remaining combinations (all start with \\'V\\') are from `y+1` to `x` => we need to find (kth from 1st, that is) `k-y`th combination from `y+1`.\\n\\tc) Apply same method of step 1, we can find the 2nd letter.\\n3. Repeated step 2 until we used either all \\'H\\'s or all \\'V\\'s.\\n4. Fill rest of the string with the other letter.\\n\\n#### Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    size_t NChooseK(int n, int k) {\\n        return round(tgamma(n+1)/tgamma(k+1)/tgamma(n-k+1));\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int numHLeft = destination[1], numCharsToBuild = destination[0] + destination[1];\\n        uint64_t totalMax = NChooseK(numCharsToBuild, numHLeft);\\n        string ans = \"\";\\n        while (numHLeft && numHLeft < numCharsToBuild) {\\n            uint64_t maxH = totalMax*numHLeft/numCharsToBuild;\\n            if (k <= maxH) {\\n                ans += \"H\";\\n                numHLeft--;\\n                totalMax = maxH;\\n            } else {\\n                ans += \"V\";\\n                totalMax -= maxH;\\n\\t\\t\\t\\tk -= maxH;\\n            }\\n            numCharsToBuild--;\\n        }\\n        ans += string(numCharsToBuild, numHLeft ? \\'H\\' : \\'V\\');\\n        return ans;\\n    }\\n};\\n```\\n\\n#### Complexity\\n\\nWe built the string of length `row + col` letter by letter => O(n), where `n = row + col`\\n\\n#### Additional Note\\n\\nCalculating `N choose K` can be time consuming. We only need to calculate it **once** in this solution, instead of _every step_ (like many other solutions do).\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    size_t NChooseK(int n, int k) {\\n        return round(tgamma(n+1)/tgamma(k+1)/tgamma(n-k+1));\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int numHLeft = destination[1], numCharsToBuild = destination[0] + destination[1];\\n        uint64_t totalMax = NChooseK(numCharsToBuild, numHLeft);\\n        string ans = \"\";\\n        while (numHLeft && numHLeft < numCharsToBuild) {\\n            uint64_t maxH = totalMax*numHLeft/numCharsToBuild;\\n            if (k <= maxH) {\\n                ans += \"H\";\\n                numHLeft--;\\n                totalMax = maxH;\\n            } else {\\n                ans += \"V\";\\n                totalMax -= maxH;\\n\\t\\t\\t\\tk -= maxH;\\n            }\\n            numCharsToBuild--;\\n        }\\n        ans += string(numCharsToBuild, numHLeft ? \\'H\\' : \\'V\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400653,
                "title": "c-no-math",
                "content": "```\\n//idea\\n  we calculate the no of ways of reaching the dest from each point in\\n  advance , how?\\n  let goal (n,m)  let put distance in dp[][] matrix;\\n  obviuosly dp[n][m] = 0; \\n  other base cases if(i == n || j == m) means we can\\'t move down / we can\\'t move right\\n  so ,dp[i][j] = 1; for all these , i.e; there is only one way to reach goal.\\n  o.w. if we are at i ,j we have dp[i][j] = dp[i+1][j] + dp[i][j+1] ways\\n  \\n  that\\'s precomputation done , now we can move according to following:-\\n  1) if our k < total horizontal move we will moving this way\\n  2) if not , then we need to move verticaly down and also need to update k as k = k- horzizontal ways\\n```\\n\\n```\\n string kthSmallestPath(vector<int>& dest, int k) {\\n        int n = dest[0]+1 , m = dest[1]+1;\\n        int dp[n][m];\\n        dp[n-1][m-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--) dp[i][m-1] = 1;\\n        for(int i=m-2;i>=0;i--) dp[n-1][i] = 1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        string ans;\\n        int i = 0, j =0;\\n        while(i<n && j < m)\\n        {\\n             if(i+1 == n && j+1 == m) break;\\n                \\n                if(i+1 == n)\\n                {\\n                    ans += \\'H\\';\\n                    j++;\\n                }\\n                else if(j+1 == m)\\n                {\\n                    ans += \\'V\\';\\n                    i++;\\n                }\\n                else\\n                {\\n                    if(k <= dp[i][j+1])\\n                    {\\n                        ans += \\'H\\';\\n                        j++;\\n                    }\\n                    else\\n                    {\\n                        ans += \\'V\\';\\n                        k -= dp[i][j+1];\\n                        i++;\\n                    }\\n                }\\n        }\\n       \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//idea\\n  we calculate the no of ways of reaching the dest from each point in\\n  advance , how?\\n  let goal (n,m)  let put distance in dp[][] matrix;\\n  obviuosly dp[n][m] = 0; \\n  other base cases if(i == n || j == m) means we can\\'t move down / we can\\'t move right\\n  so ,dp[i][j] = 1; for all these , i.e; there is only one way to reach goal.\\n  o.w. if we are at i ,j we have dp[i][j] = dp[i+1][j] + dp[i][j+1] ways\\n  \\n  that\\'s precomputation done , now we can move according to following:-\\n  1) if our k < total horizontal move we will moving this way\\n  2) if not , then we need to move verticaly down and also need to update k as k = k- horzizontal ways\\n```\n```\\n string kthSmallestPath(vector<int>& dest, int k) {\\n        int n = dest[0]+1 , m = dest[1]+1;\\n        int dp[n][m];\\n        dp[n-1][m-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--) dp[i][m-1] = 1;\\n        for(int i=m-2;i>=0;i--) dp[n-1][i] = 1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        string ans;\\n        int i = 0, j =0;\\n        while(i<n && j < m)\\n        {\\n             if(i+1 == n && j+1 == m) break;\\n                \\n                if(i+1 == n)\\n                {\\n                    ans += \\'H\\';\\n                    j++;\\n                }\\n                else if(j+1 == m)\\n                {\\n                    ans += \\'V\\';\\n                    i++;\\n                }\\n                else\\n                {\\n                    if(k <= dp[i][j+1])\\n                    {\\n                        ans += \\'H\\';\\n                        j++;\\n                    }\\n                    else\\n                    {\\n                        ans += \\'V\\';\\n                        k -= dp[i][j+1];\\n                        i++;\\n                    }\\n                }\\n        }\\n       \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918394,
                "title": "c-o-r-c-2-solution-with-explanation",
                "content": "We can restate this problem as finding the ```k``` th string in lexicographic order among strings consisting of ```c``` \\u201CV\\u201Ds and ```r``` \\u201CH\\u201Ds. Let ```s(r, c, k)``` denote the answer string for inputs ```r, c, k```. \\n\\nNote that if ```r == 0```, the only possible string is that having ```c``` \\u201CH\\u201Ds and if ```c == 0```, the only possible string is that having ```r``` \\u201CV\\u201Ds. So, these two cases can be handled easily. Now we come to the case where both ```r``` and ```c``` and non-zero. \\nNote that all strings starting with \\u201CH\\u201D appear before those starting with \\u201CV\\u201D. To find the number of strings starting with \\u201CH\\u201D, we place \\u201CH\\u201D in the first position, and compute the number of strings of length ```r + c - 1``` which can be formed using ```c-1``` \\u201CH\\u201Ds and ```r``` \\u201CV\\u201Ds. This is given by ```nCr(r + c - 1, c-1)```. \\n\\nSo, if ```k <= nCr(r + c - 1, c-1)```, we know that the answer starts with an \\u201CH\\u201D. Having placed \\u201CH\\u201D in the first position, we can forget about it, and solve the problem of constructing the string having ```r``` \\u201CV\\u201Ds and ```c-1``` \\u201CH\\u201Ds (because we used one up). Because all strings starting with \\u201CH\\u201D appear at the top of the list, and we know that the answer starts with an \\u201CH\\u201D, the ```k``` th string in the list of strings of size ```r + c``` will be the ```k``` th string in the list of strings of size ```r + c - 1```. So, the answer is ``` \\u201CH\\u201D + s(r, c-1, k)```. \\n\\nIf ```k > nCr(r + c - 1, c-1)```, then we know that it starts with a \\u201CV\\u201D. Having placed one \\u201CV\\u201D, we consider the problem of creating strings of size ```r + c - 1```, using ```r - 1``` \\u201CV\\u201Ds and ```c``` \\u201CH\\u201Ds. Now, because we have removed the ```nCr(r + c - 1, c-1)``` strings starting with \\u201CH\\u201D, the ```k``` th string in the list of strings of size ```r + c``` will be the ```k - nCr(r + c - 1, c-1)``` th string in the list of strings of size ```r + c - 1```. So, the answer in this case is ``` \\u201CV\\u201D + s(r-1, c-1, k - nCr(r + c - 1, c-1))```.\\n\\nThe only \\u201Ctrick\\u201D here is to precompute values of ```nCr``` by using the relationship ```nCr(a, b) = nCr(a-1, b) + nCr(a-1, b-1)```. That way, when performing the recursion to construct the strings, we can just query these values instead of recomputing them.\\n\\nThe time complexity of constructing strings is ```O(r+c)```, because at each step, either ```r``` or ```c``` decreases by 1. The time complexity of computing all relevant ```nCr``` values is ```O((r+c)^2)```, but in this case it is practically constant because we know ```0 <= r + c <= 15```.\\n```\\nclass Solution {\\n    vector<vector<long long int>> chooses;\\n    string help(int r, int c, int k){\\n        if (c == 0)\\n            return string(r, \\'V\\');\\n\\n        if (r == 0)\\n            return string(c, \\'H\\');\\n\\n        if (k <= chooses[r+c-1][c-1])\\n            return \"H\" + help(r, c-1, k);\\n        \\n        return \"V\" + help(r-1, c, k - chooses[r+c-1][c-1]);\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        chooses = vector<vector<long long int>>(40, vector<long long int>(40));\\n        for (int i = 0; i <= 35; ++i){\\n            chooses[i][0] = chooses[i][i] = 1;\\n        }\\n        for (int i = 2; i <= 35; ++i){\\n            for (int j = 1; j <= i/2; ++j){\\n                chooses[i][j] = chooses[i-1][j] + chooses[i-1][j-1];\\n                chooses[i][i-j] = chooses[i][j];\\n            }\\n        }\\n        return help(destination[0], destination[1], k);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```k```\n```c```\n```r```\n```s(r, c, k)```\n```r, c, k```\n```r == 0```\n```c```\n```c == 0```\n```r```\n```r```\n```c```\n```r + c - 1```\n```c-1```\n```r```\n```nCr(r + c - 1, c-1)```\n```k <= nCr(r + c - 1, c-1)```\n```r```\n```c-1```\n```k```\n```r + c```\n```k```\n```r + c - 1```\n``` \\u201CH\\u201D + s(r, c-1, k)```\n```k > nCr(r + c - 1, c-1)```\n```r + c - 1```\n```r - 1```\n```c```\n```nCr(r + c - 1, c-1)```\n```k```\n```r + c```\n```k - nCr(r + c - 1, c-1)```\n```r + c - 1```\n``` \\u201CV\\u201D + s(r-1, c-1, k - nCr(r + c - 1, c-1))```\n```nCr```\n```nCr(a, b) = nCr(a-1, b) + nCr(a-1, b-1)```\n```O(r+c)```\n```r```\n```c```\n```nCr```\n```O((r+c)^2)```\n```0 <= r + c <= 15```\n```\\nclass Solution {\\n    vector<vector<long long int>> chooses;\\n    string help(int r, int c, int k){\\n        if (c == 0)\\n            return string(r, \\'V\\');\\n\\n        if (r == 0)\\n            return string(c, \\'H\\');\\n\\n        if (k <= chooses[r+c-1][c-1])\\n            return \"H\" + help(r, c-1, k);\\n        \\n        return \"V\" + help(r-1, c, k - chooses[r+c-1][c-1]);\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        chooses = vector<vector<long long int>>(40, vector<long long int>(40));\\n        for (int i = 0; i <= 35; ++i){\\n            chooses[i][0] = chooses[i][i] = 1;\\n        }\\n        for (int i = 2; i <= 35; ++i){\\n            for (int j = 1; j <= i/2; ++j){\\n                chooses[i][j] = chooses[i-1][j] + chooses[i-1][j-1];\\n                chooses[i][i-j] = chooses[i][j];\\n            }\\n        }\\n        return help(destination[0], destination[1], k);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918368,
                "title": "python-binomial-problem-dp-top-down-w-memoization",
                "content": "Main insight: There are two choices at each index, go with \"H\" or go with \"V\". The one to choose can be determined by k. \\n\\nMath prerequisite: How many bitstrings can you make with i 0\\'s and j 1\\'s? nCr(i+j,j). You have i+j slots and j of them must be 1\\'s. Out of all these bitstrings, how many of them start with 0? nCr(i+j-1,j). This is because you set the first bit as 0, and you are left with i+j-1 bits remaining to assign, j of them must be ones. How many of the bitstrings start with 1? nCr(i+j-1,j-1), by the same reasoning, i+j-1 bits left to assign, j-1 of them must be 1. \\n\\nState representation: (i,j,k) as (number of \"V\"\\'s to assign, number of \"H\"\\'s to assign, index of answer). \\n\\nSo then the recurrence is: If k <= nCr(i+j-1,j-1), then we know that our answer must start with \"H\". Then, all that is left to do is the assign the rest of the bits, and we make our recursive call. If k > nCr(i+j-1,j-1), then our answer must start with \"V\", and we subtract nCr(i+1-1,j-1) from k and make recursive call. We can do this subtraction because we bypass all the strings that start with \"H\", all of which are lexicographically smaller than the strings that start with \"V\". \\n\\nThe base case is k = 1, just assign the lexicographically smallest string, using all \"H\"\\'s first then using all \"V\"\\'s. j*\"H\"+i*\"V\".\\n\\nExample: [2,3] k = 9\\n\\n\\t\\t\\t\\t***** (no letters assigned)\\n\\t\\t\\t/\\t\\t\\t\\t\\\\ (Go right, k is now 9-6=3, bypassed all leaves on left)\\n\\t\\tH**** \\t\\t\\t\\tV****  (nCr(2+2,2)=6<k, so go right.)\\n\\t\\t\\t\\t\\t\\t/\\t\\t\\t\\\\     \\n\\t\\t\\t\\t\\t\\tVH***\\t\\tVV*** (nCr(3,2)=3>=k, go left.)\\n\\t\\t\\t\\t\\t\\t\\t\\t/\\t\\t\\t\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tVHH**\\t\\tVHV** (nCr(2,1)=2<k, go right. k is 1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tVHVV* (k is 1, reached base case)\\n\\nVHVVV is the answer. \\n\\nO(MN) O(MN), can improve memory by constant multiplier of we do bottom up DP, instead of memoization. \\n\\nNote: This week\\'s contest last 3 problems all are the same flavor of DP. Know what state you are at, define the recurrence relation by possible moves, then perform the recursion by doing those moves.  \\n\\n```\\nfrom math import comb\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        i,j = destination\\n        \\n        @lru_cache(None)\\n        def helper(i,j,k):\\n            if k == 1:\\n                return \"H\"*j+\"V\"*i\\n            else:\\n                horizontal = comb(i+j-1,j-1)\\n                if k <= horizontal:\\n                    return \"H\" + helper(i,j-1,k)\\n                else:\\n                    return \"V\" + helper(i-1,j,k-horizontal)\\n        \\n        return helper(i,j,k)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom math import comb\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        i,j = destination\\n        \\n        @lru_cache(None)\\n        def helper(i,j,k):\\n            if k == 1:\\n                return \"H\"*j+\"V\"*i\\n            else:\\n                horizontal = comb(i+j-1,j-1)\\n                if k <= horizontal:\\n                    return \"H\" + helper(i,j-1,k)\\n                else:\\n                    return \"V\" + helper(i-1,j,k-horizontal)\\n        \\n        return helper(i,j,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919444,
                "title": "c-simple-explanation",
                "content": "First thing to keep in mind is if the destination is (r,c) the string whose kth combination we have to find is made up of \\'c\\' number of H\\'s and \\'r\\' number of V\\'s.\\n\\n***Intuition***: Now to find the kth lexographical string in order made up of \\'a\\' H\\'s and \\'b\\' V\\'s, let\\'s start by thinking what the first character in our string should be.\\nFor that we need : \\nNumber of strings starting with H i.e equal to ``` fact(a-1+b)/(fact(a-1)*fact(b)) which is equal to (a+b-1)Cb where C  stands for Combinations```.\\n\\nNow, if ```k <  x (where x = number of strings starting with H), our answer string should start with H. else our answer string should start with V and k = k-x.```\\n\\nHere is the code for reference.\\n\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n       \\n        vector<vector<int>> vec(destination[0] + destination[1] + 1,vector<int>());  /// Vector to store the required nCr we need.\\n        int n = destination[0] + destination[1];\\n        vec[1].push_back(1);\\n        vec[1].push_back(1);\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0; j<=vec[i-1].size();j++){\\n                if(j == vec[i-1].size() || j == 0)\\n                    vec[i].push_back(1);\\n                else vec[i].push_back(vec[i-1][j-1] + vec[i-1][j]);\\n            }\\n        }  \\n        string ans;\\n        int a = destination[1];\\n        int b = destination[0];\\n        while( k > 0){\\n            int x = vec[a-1+b][b];  /// x is the number of strings starting with \\'H\\'.\\n\\t\\t\\t\\n\\t\\t\\tif(k <= x){    \\n                ans += \\'H\\';\\n                a--;\\n\\t\\t\\t\\tif(k == x)\\n\\t\\t\\t\\t\\tk-=x;\\n\\t\\t\\t}\\n            else if(k > x){\\n                ans += \\'V\\';\\n                k -= x;\\n                b--;\\n            }\\n            if(a == 0 || b == 0){   /// if at any point either a or b == 0, we should break;\\n                break;\\n            }\\n        }\\n  \\n        for(int i = 0;i<b;i++)    /// add remaining V\\'s\\n            ans += \\'V\\';\\n        for(int i = 0;i<a;i++)   /// add remaining H\\'s\\n             ans += \\'H\\';\\n        return ans;      \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "``` fact(a-1+b)/(fact(a-1)*fact(b)) which is equal to (a+b-1)Cb where C  stands for Combinations```\n```k <  x (where x = number of strings starting with H), our answer string should start with H. else our answer string should start with V and k = k-x.```\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n       \\n        vector<vector<int>> vec(destination[0] + destination[1] + 1,vector<int>());  /// Vector to store the required nCr we need.\\n        int n = destination[0] + destination[1];\\n        vec[1].push_back(1);\\n        vec[1].push_back(1);\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0; j<=vec[i-1].size();j++){\\n                if(j == vec[i-1].size() || j == 0)\\n                    vec[i].push_back(1);\\n                else vec[i].push_back(vec[i-1][j-1] + vec[i-1][j]);\\n            }\\n        }  \\n        string ans;\\n        int a = destination[1];\\n        int b = destination[0];\\n        while( k > 0){\\n            int x = vec[a-1+b][b];  /// x is the number of strings starting with \\'H\\'.\\n\\t\\t\\t\\n\\t\\t\\tif(k <= x){    \\n                ans += \\'H\\';\\n                a--;\\n\\t\\t\\t\\tif(k == x)\\n\\t\\t\\t\\t\\tk-=x;\\n\\t\\t\\t}\\n            else if(k > x){\\n                ans += \\'V\\';\\n                k -= x;\\n                b--;\\n            }\\n            if(a == 0 || b == 0){   /// if at any point either a or b == 0, we should break;\\n                break;\\n            }\\n        }\\n  \\n        for(int i = 0;i<b;i++)    /// add remaining V\\'s\\n            ans += \\'V\\';\\n        for(int i = 0;i<a;i++)   /// add remaining H\\'s\\n             ans += \\'H\\';\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278031,
                "title": "c-dp-math-atcoder-editorial",
                "content": "A similar question came ino an Atcoder contest:-\\nquestion Link -[https://atcoder.jp/contests/abc202/tasks/abc202_d]()\\neditorial Link - [https://atcoder.jp/contests/abc202/editorial/1893](http://)\\n\\n```\\nclass Solution {\\npublic:\\n    int ncr[31][31];\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n\\n        // calculating the combination values\\n        for(int n=1;n<31;++n)\\n        {\\n            ncr[n][0]=1;\\n            for(int r=1;r<n;++r)\\n            {\\n                ncr[n][r]=ncr[n-1][r]+ncr[n-1][r-1];\\n            }\\n            ncr[n][n]=1;\\n\\n        }\\n        string res=\"\";\\n        int H=destination[1];\\n        int V=destination[0];\\n        \\n        while(H!=0 && V!=0)\\n        {\\n            int ways=ncr[H+V-1][H-1];\\n            \\n            \\n            if(ways>=k)\\n            {\\n                res+=\\'H\\';\\n                H--;\\n            }\\n            else\\n            {\\n                res+=\\'V\\';\\n                k-=ways;\\n                V--;\\n            }\\n        }\\n        while(H--)\\n            res+=\\'H\\';\\n        while(V--)\\n            res+=\\'V\\';\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ncr[31][31];\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n\\n        // calculating the combination values\\n        for(int n=1;n<31;++n)\\n        {\\n            ncr[n][0]=1;\\n            for(int r=1;r<n;++r)\\n            {\\n                ncr[n][r]=ncr[n-1][r]+ncr[n-1][r-1];\\n            }\\n            ncr[n][n]=1;\\n\\n        }\\n        string res=\"\";\\n        int H=destination[1];\\n        int V=destination[0];\\n        \\n        while(H!=0 && V!=0)\\n        {\\n            int ways=ncr[H+V-1][H-1];\\n            \\n            \\n            if(ways>=k)\\n            {\\n                res+=\\'H\\';\\n                H--;\\n            }\\n            else\\n            {\\n                res+=\\'V\\';\\n                k-=ways;\\n                V--;\\n            }\\n        }\\n        while(H--)\\n            res+=\\'H\\';\\n        while(V--)\\n            res+=\\'V\\';\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919332,
                "title": "simple-cpp-dp-m-x-n",
                "content": "First let\\'s calculate and save how many ways we can arrive to destination starting from i, j.\\nFor example for [2, 3] k = 1\\nour dp will look like\\n10 6  3  1 \\n 4  3  2  1 \\n 1  1  1  1 \\n starting from 0,0 if ```dp[i][j] >= k``` we will go to right until `dp[i][j] < k` then we go down.\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        int n = d[0], m = d[1];\\n        string res;\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 1));\\n        \\n        for (int i = n - 1; i >= 0; i--)\\n            for (int j = m - 1; j >= 0; j--)\\n                dp[i][j] = dp[i][j + 1] + dp[i + 1][j];\\n\\n        for (int j = 0, i = 0; j < m || i < n;) {\\n            if (dp[i][j] >= k && j < m) {\\n                res.push_back(\\'H\\');\\n                j++;\\n            }\\n            else {\\n                if ((k -= dp[i][j]) > 0) // else we are on the final column so we dont have to decrement value of j\\n                    j--, res.pop_back();\\n                res.push_back(\\'V\\');\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nEdit \\nI started with brute force `dfs` at the beginning (Not knowing `k` can go to a very high number).  Then I realized that we don\\'t have to generate all those combinations. So I decided to start from the destination save how many ways we can reach to destination from [i, j]. So we will avoid `k - 1` ways and looking for `k`th route.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j] >= k```\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        int n = d[0], m = d[1];\\n        string res;\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 1));\\n        \\n        for (int i = n - 1; i >= 0; i--)\\n            for (int j = m - 1; j >= 0; j--)\\n                dp[i][j] = dp[i][j + 1] + dp[i + 1][j];\\n\\n        for (int j = 0, i = 0; j < m || i < n;) {\\n            if (dp[i][j] >= k && j < m) {\\n                res.push_back(\\'H\\');\\n                j++;\\n            }\\n            else {\\n                if ((k -= dp[i][j]) > 0) // else we are on the final column so we dont have to decrement value of j\\n                    j--, res.pop_back();\\n                res.push_back(\\'V\\');\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520795,
                "title": "c-easy-solution-do-upvote",
                "content": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n=destination[0]+1,m=destination[1]+1;\\n        \\n        //this code is straight forward it calculate and stores no. ways to go to destination from i,j\\n        vector<vector<int>> ways(n,vector<int> (m));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1||j==m-1){\\n                    ways[i][j]=1; continue;\\n                }\\n                ways[i][j]=ways[i][j+1]+ways[i+1][j];\\n            }\\n        }\\n\\t\\t \\n\\t\\t\\n\\t\\t// with the help of above table ans can be generated\\n\\t\\t//suppose we are at (i, j)   we need to decide whether to go Horizontal or Vertical\\n\\t\\n        string ans=\"\";\\n        \\n        int i=0,j=0;\\n        while(i<n-1&&j<m-1){\\n\\t\\t    // if k is less than no of ways to go from selecting horizontal path\\n             if(k<=ways[i][j+1]){\\n                ans=ans+\\'H\\';j++; \\n             }\\n\\t\\t\\t // else we chose vertical for greater k\\n            else{\\n                k=k-ways[i][j+1];\\n                i++;\\n                ans=ans+\\'V\\';\\n            }\\n            \\n         }\\n         while(j++<m-1) ans=ans+\\'H\\';\\n         while(i++<n-1) ans=ans+\\'V\\';\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n=destination[0]+1,m=destination[1]+1;\\n        \\n        //this code is straight forward it calculate and stores no. ways to go to destination from i,j\\n        vector<vector<int>> ways(n,vector<int> (m));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(i==n-1||j==m-1){\\n                    ways[i][j]=1; continue;\\n                }\\n                ways[i][j]=ways[i][j+1]+ways[i+1][j];\\n            }\\n        }\\n\\t\\t \\n\\t\\t\\n\\t\\t// with the help of above table ans can be generated\\n\\t\\t//suppose we are at (i, j)   we need to decide whether to go Horizontal or Vertical\\n\\t\\n        string ans=\"\";\\n        \\n        int i=0,j=0;\\n        while(i<n-1&&j<m-1){\\n\\t\\t    // if k is less than no of ways to go from selecting horizontal path\\n             if(k<=ways[i][j+1]){\\n                ans=ans+\\'H\\';j++; \\n             }\\n\\t\\t\\t // else we chose vertical for greater k\\n            else{\\n                k=k-ways[i][j+1];\\n                i++;\\n                ans=ans+\\'V\\';\\n            }\\n            \\n         }\\n         while(j++<m-1) ans=ans+\\'H\\';\\n         while(i++<n-1) ans=ans+\\'V\\';\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918996,
                "title": "intuitive-solution-similar-to-find-rank-of-word-in-dictionary-c",
                "content": "This question is similar to finding rank of a given word in dictionary which is constituted by \"H\" and \"V\" characters only. \\nFirst thing we need to know is the number of steps needed to reach the destination. Suppose destination is (x, y) and we know that starting point is (0, 0), then the number of steps would be:\\n```\\ndistance = (x-0) + (y-0) = x+y\\n```\\n\\nSo the string\\'s length would be of length ```x+y```. \\n\\nOne more thing to observe is that this string will be made up of **x** V\\'s and **y** H\\'s. This is because we whichever path we take we will have to move x steps downwards and y steps rightwards. So the final string will be a permutation of the string\\n```\\n\"HHHH....(y-times)VVVVVV.....(x-times)\"\\n```\\n\\n**Combination**\\nThe number of strings with x V\\'s and y H\\'s can be written as:\\nN = (h + v)! / ( h! * v! )\\n\\nThis is equivalent to : ``` (h+v)C(h) or  (h+v)C(v)``` \\n\\nThus the required string can be formed by finding the ```kth``` permutation of this string. \\nSteps to find the ```kth``` string:\\n```\\nlet v = number of vertical steps\\n\\th = number of horizontal steps\\n\\tans = reuired string\\n\\tcomb = number permutations of string having h - H\\'s and v - V\\'s\\n\\tcurr = rank of current string\\n\\tk = rank of the required string\\n1. Take an empty string, suppose ans = \"\"\\n2. Since the smallest string of length h+v will start with \"H\", \\n\\t\\t1. \\tIf h!=0, then we find number of string starting with H as \\n\\t\\t\\t\\t\\t\\t\\tcomb = \"H\" + Combination( (h-1) + v, h-1)\\n\\t\\t\\t\\t\\t\\t\\th--;\\n\\t\\t2. Else, no H is left so we add \"V\" at the end\\n\\t\\t\\t\\t\\t\\t\\tans = ans + \"V\"\\n\\t\\t\\t\\t\\t\\t\\tv--\\n3. Check if the curr+comb<=k, if yes then replace \"H\" with \"V\" and curr = curr+comb. This indicates that the required string has rank greater than the rank of largest rank string with \"H\" at the current index.\\n4. If ans.length< required string\\'s length, go back to step 2\\n5. Else the ans is the required string.\\n```\\n\\n**Note**\\n* I have implemented the function `Combination (int n, int r) ` separately in order to calculate nCr without overflow\\n* **curr** starts with 1 because rank is 1-indexed and the first string generated would be at rank 1 and not rank 0. e.g: \"HHVV\" will be at rank 1, but if curr starts with 0 the answers comes out to be 0 as there are no other strings before 1.\\nCode:\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[0]+destination[1];\\n        int curr=1, v=destination[0], h=destination[1];\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            if(h>0){\\n                ans += \"H\";\\n                h--;\\n            }\\n            else{\\n                ans += \"V\";\\n                v--;\\n            }\\n            ll comb = combination(h+v, h);\\n            if(curr+comb<=k){\\n                curr += comb;\\n                ans[ans.size()-1] = \\'V\\';\\n                h++;\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    ll combination(int n, int r){\\n        ll ans = 1, k=1;\\n        if (n - r < r) \\n            r = n - r; \\n\\n        if (r != 0) { \\n            while (r) { \\n                ans *= n; \\n                k *= r; \\n                long long m = __gcd(ans, k);\\n                ans /= m; \\n                k /= m; \\n\\n                n--; \\n                r--; \\n            }  \\n        } \\n        else\\n            ans = 1;\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Time Complexity:** `O((r+c)*r*log(r))`\\n**Explaination:** `r+c - is constituted by the first for loop, r - constituted by while loop if function combination(), log(r) - is constituted by the __gcd() function`\\n\\n**Space Complexity:** `O(r+c), taken by the answer string`",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\ndistance = (x-0) + (y-0) = x+y\\n```\n```x+y```\n```\\n\"HHHH....(y-times)VVVVVV.....(x-times)\"\\n```\n``` (h+v)C(h) or  (h+v)C(v)```\n```kth```\n```kth```\n```\\nlet v = number of vertical steps\\n\\th = number of horizontal steps\\n\\tans = reuired string\\n\\tcomb = number permutations of string having h - H\\'s and v - V\\'s\\n\\tcurr = rank of current string\\n\\tk = rank of the required string\\n1. Take an empty string, suppose ans = \"\"\\n2. Since the smallest string of length h+v will start with \"H\", \\n\\t\\t1. \\tIf h!=0, then we find number of string starting with H as \\n\\t\\t\\t\\t\\t\\t\\tcomb = \"H\" + Combination( (h-1) + v, h-1)\\n\\t\\t\\t\\t\\t\\t\\th--;\\n\\t\\t2. Else, no H is left so we add \"V\" at the end\\n\\t\\t\\t\\t\\t\\t\\tans = ans + \"V\"\\n\\t\\t\\t\\t\\t\\t\\tv--\\n3. Check if the curr+comb<=k, if yes then replace \"H\" with \"V\" and curr = curr+comb. This indicates that the required string has rank greater than the rank of largest rank string with \"H\" at the current index.\\n4. If ans.length< required string\\'s length, go back to step 2\\n5. Else the ans is the required string.\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[0]+destination[1];\\n        int curr=1, v=destination[0], h=destination[1];\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            if(h>0){\\n                ans += \"H\";\\n                h--;\\n            }\\n            else{\\n                ans += \"V\";\\n                v--;\\n            }\\n            ll comb = combination(h+v, h);\\n            if(curr+comb<=k){\\n                curr += comb;\\n                ans[ans.size()-1] = \\'V\\';\\n                h++;\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    ll combination(int n, int r){\\n        ll ans = 1, k=1;\\n        if (n - r < r) \\n            r = n - r; \\n\\n        if (r != 0) { \\n            while (r) { \\n                ans *= n; \\n                k *= r; \\n                long long m = __gcd(ans, k);\\n                ans /= m; \\n                k /= m; \\n\\n                n--; \\n                r--; \\n            }  \\n        } \\n        else\\n            ans = 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918429,
                "title": "python3-greedy",
                "content": "Algo \\nGiven `m` H and `n` V to place, we check if it is possible to place H. If so, decrement `n`; otherwise decrement `m`. Since there are `comb(m+n-1, n-1)` instructions starting with H, the condition to check for placing H is `comb(m+n-1, n-1) >= k`. \\n\\nImplementation \\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination # m \"V\" & n \"H\" in total \\n        ans = \"\"\\n        while n: \\n            kk = comb(m+n-1, n-1) # (m+n-1 choose n-1) instructions starting with \"H\"  \\n            if kk >= k: \\n                ans += \"H\"\\n                n -= 1\\n            else: \\n                ans += \"V\"\\n                m -= 1\\n                k -= kk \\n        return ans + m*\"V\"\\n```\\n\\nAnalysis\\nTime complexity `O(M*N + N^2)`\\nSpace complexity `O(M+N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination # m \"V\" & n \"H\" in total \\n        ans = \"\"\\n        while n: \\n            kk = comb(m+n-1, n-1) # (m+n-1 choose n-1) instructions starting with \"H\"  \\n            if kk >= k: \\n                ans += \"H\"\\n                n -= 1\\n            else: \\n                ans += \"V\"\\n                m -= 1\\n                k -= kk \\n        return ans + m*\"V\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290018,
                "title": "c-brute-force-soln-tle-and-optimal-combinatrics-soln",
                "content": "Lets take given test case as example, with 2,3 eding point we know we will need 2vertical movements and 3 horizontal movements.\\n\\n```\\n/*\\n   1        2       3         4        5        6         7        8       9\\n\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \\n  \\n  10\\n\"VVHHH\"\\n\\n(VV , HHH)\\n\\nH H _ _ _\\n*/\\n\\n```\\n\\nIf we fix H as first position we know we will get 6 possible path and our k is less than that so we will fix H there and calculate for next step. If is k out of range we will fix V there.\\n\\nMoving H _ if we fix 2nd h there we will get 3 combinations and if k less equal than than then H is fixed.\\n\\nAnd if we fix V so we are removing all the earlier combinations from k. As V _ _ _ _ _ is at 7 index  so remove 6 from k.\\n\\nHope this helps even a bit.\\n\\n```\\n//upvote if found helpful\\n int comb(int n, int r){\\n        \\n        //nCr = n! / (n-r)! r! => n .... n-r+1/r! => n/1 * n-1/2 * n-2/3 ... n-r+1/r \\n        int ans = 1;\\n        \\n        for(int i=1; i<=r; i++){\\n            \\n            ans = ans * (n-i+1)/i;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& d, int k){\\n            \\n        int h = d[1], v = d[0];\\n        int n = h+v;\\n        string path = \"\";\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(h){\\n                \\n                int tot_comb = comb(h+v-1, v);\\n                \\n                if(tot_comb >= k){\\n                    path.push_back(\\'H\\');\\n                    h--;\\n                }\\n                else {\\n                    path.push_back(\\'V\\'); \\n                    v--; \\n                    k -= tot_comb;  \\n                }\\n            }\\n            else{\\n                path.push_back(\\'V\\'); \\n                v--;\\n            }\\n        }\\n        \\n        return path;\\n    }\\n    \\n};\\n```\\n\\nBrute force : \\n\\n```\\n    void dfs(int r, int c, int m, int n, string path, vector<string>& allPath){\\n        \\n        if(r<0 or r>m or c<0 or c>n) return;\\n        \\n        if(r==m and c==n){\\n            allPath.push_back(path);\\n            return;\\n        }\\n        \\n        dfs(r+1, c, m, n, path + \"V\", allPath);\\n        dfs(r, c+1, m, n, path + \"H\", allPath);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        vector<string> allPath;\\n        int m = destination[0]; int n = destination[1];\\n        dfs(0, 0, m, n, \"\", allPath);\\n        sort(allPath.begin(), allPath.end());\\n        return allPath[k-1];\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n   1        2       3         4        5        6         7        8       9\\n\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \\n  \\n  10\\n\"VVHHH\"\\n\\n(VV , HHH)\\n\\nH H _ _ _\\n*/\\n\\n```\n```\\n//upvote if found helpful\\n int comb(int n, int r){\\n        \\n        //nCr = n! / (n-r)! r! => n .... n-r+1/r! => n/1 * n-1/2 * n-2/3 ... n-r+1/r \\n        int ans = 1;\\n        \\n        for(int i=1; i<=r; i++){\\n            \\n            ans = ans * (n-i+1)/i;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& d, int k){\\n            \\n        int h = d[1], v = d[0];\\n        int n = h+v;\\n        string path = \"\";\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(h){\\n                \\n                int tot_comb = comb(h+v-1, v);\\n                \\n                if(tot_comb >= k){\\n                    path.push_back(\\'H\\');\\n                    h--;\\n                }\\n                else {\\n                    path.push_back(\\'V\\'); \\n                    v--; \\n                    k -= tot_comb;  \\n                }\\n            }\\n            else{\\n                path.push_back(\\'V\\'); \\n                v--;\\n            }\\n        }\\n        \\n        return path;\\n    }\\n    \\n};\\n```\n```\\n    void dfs(int r, int c, int m, int n, string path, vector<string>& allPath){\\n        \\n        if(r<0 or r>m or c<0 or c>n) return;\\n        \\n        if(r==m and c==n){\\n            allPath.push_back(path);\\n            return;\\n        }\\n        \\n        dfs(r+1, c, m, n, path + \"V\", allPath);\\n        dfs(r, c+1, m, n, path + \"H\", allPath);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        vector<string> allPath;\\n        int m = destination[0]; int n = destination[1];\\n        dfs(0, 0, m, n, \"\", allPath);\\n        sort(allPath.begin(), allPath.end());\\n        return allPath[k-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1088665,
                "title": "python-3-easy-dp-o-m-n-solution-explained",
                "content": "* First, we build DP array to compute number of unique paths from ```grid[i][j]``` to destination ```grid[-1][-1]```.\\n![image](https://assets.leetcode.com/users/images/a135e9aa-8f74-4cc8-99c3-5b95ae7a5073_1614626616.2132363.png)\\nApparently, dp[i][j] = dp[i][j + 1] + dp[i + 1][j], the number of path in the current grid is equal to the number of which in the next right grid, and in the next bottom grid.\\nSo the question is like to find the k-th path from ```dp[0][0]``` to ```dp[m][n]```, in the lexicographical order.\\n\\n* Next, start from top-left corner of ```dp```, we have two choices: go to the next right grid, or go to the next bottom grid. The key is **Every path in the next bottom grid is larger every path in the next right grid**, because **every path in the next right bottom start with \"H\", while paths in the next bottom grid start with \"V\"**. \\n\\nTherefore:\\n1.  If the current index ```k``` is no larger than the number of paths in the right grid ( ```dp[i][j + 1]```), we will go to the next right grid, and add \"H\" to the answer, because we are moving rightward.\\n\\n2.  If the current index ```k``` is larger than ```dp[i][j + 1]```, meanning we can only find the path downward, so we will go to dp[i + 1][j], and k -= dp[i][j + 1], since we have passed the first dp[i][j + 1]-th paths, and add \"V\" to the ans since we are moving downward.\\n\\n![image](https://assets.leetcode.com/users/images/e935cd7f-1473-4aa5-97f0-e8014343a887_1614627227.0005882.png)\\n\\n\\n* Until we reach ```i == m or j == n```, meaning we can only go rightward or downward from then on, so we just need to add numbers of \"H\" or \"V\" accordingly.\\n\\n\\n\\n\\n```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(n):\\n            dp[-1][i] = 1\\n        for i in range(m):\\n            dp[i][-1] = 1\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1]\\n                \\n        ans, i , j = \"\", 0, 0\\n        while i < m and j < n:\\n            if k > dp[i][j + 1]:\\n                k -= dp[i][j + 1]\\n                i += 1\\n                ans += \"V\"\\n            else:\\n                j += 1\\n                ans += \"H\"\\n        ans += (n - j) * \"H\" + (m - i) * \"V\"  \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```grid[i][j]```\n```grid[-1][-1]```\n```dp[0][0]```\n```dp[m][n]```\n```dp```\n```k```\n```dp[i][j + 1]```\n```k```\n```dp[i][j + 1]```\n```i == m or j == n```\n```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(n):\\n            dp[-1][i] = 1\\n        for i in range(m):\\n            dp[i][-1] = 1\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1]\\n                \\n        ans, i , j = \"\", 0, 0\\n        while i < m and j < n:\\n            if k > dp[i][j + 1]:\\n                k -= dp[i][j + 1]\\n                i += 1\\n                ans += \"V\"\\n            else:\\n                j += 1\\n                ans += \"H\"\\n        ans += (n - j) * \"H\" + (m - i) * \"V\"  \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 953738,
                "title": "c-dynamic-programming-approach-0ms-100-bottom-up",
                "content": "```c++\\nconst int MXN = 15 + 2;\\n\\nclass Solution {\\n    int n, m;\\n\\n    int dp[MXN][MXN];\\n\\n    int go(int x, int y) {\\n        if(x==n && y==m) return 1;\\n        if(x < 0 || x > n || y < 0 || y > m) return 0;\\n        int &ans = dp[x][y];\\n        if(ans != -1) return ans;\\n        ans = go(x+1, y) + go(x, y+1);\\n        return ans;\\n    }\\n    \\n    string way;\\n    void build(int x, int y, int k) {\\n        if(x==n && y==m) return;\\n        if(x < 0 || x > n || y < 0 || y > m) return;\\n        if(k <= go(x, y+1)) {\\n            way.push_back(\\'H\\');\\n            build(x, y+1, k);\\n        } else {\\n            k -= go(x, y+1);\\n            way.push_back(\\'V\\');\\n            build(x+1, y, k);\\n        }\\n    }\\n\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        n = destination[0];\\n        m = destination[1];\\n        memset(dp, -1LL, sizeof(dp));\\n        go(0, 0);\\n        build(0, 0, k);\\n        return way;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nconst int MXN = 15 + 2;\\n\\nclass Solution {\\n    int n, m;\\n\\n    int dp[MXN][MXN];\\n\\n    int go(int x, int y) {\\n        if(x==n && y==m) return 1;\\n        if(x < 0 || x > n || y < 0 || y > m) return 0;\\n        int &ans = dp[x][y];\\n        if(ans != -1) return ans;\\n        ans = go(x+1, y) + go(x, y+1);\\n        return ans;\\n    }\\n    \\n    string way;\\n    void build(int x, int y, int k) {\\n        if(x==n && y==m) return;\\n        if(x < 0 || x > n || y < 0 || y > m) return;\\n        if(k <= go(x, y+1)) {\\n            way.push_back(\\'H\\');\\n            build(x, y+1, k);\\n        } else {\\n            k -= go(x, y+1);\\n            way.push_back(\\'V\\');\\n            build(x+1, y, k);\\n        }\\n    }\\n\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        n = destination[0];\\n        m = destination[1];\\n        memset(dp, -1LL, sizeof(dp));\\n        go(0, 0);\\n        build(0, 0, k);\\n        return way;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620167,
                "title": "recursive-iterative-solution-c",
                "content": "# Recursive\\n```\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    long long int get(int a,int b){\\n        long long int ans = 1;\\n        int k = a+b;\\n        while(k>a){\\n            ans *= k;\\n            k--;\\n            while(b>1&&ans%b==0){\\n                ans /= b;\\n                b--;\\n            }\\n        }\\n        return ans;\\n    }\\n    void solve(int a,int b,int k,string s){\\n        if(a<0||b<0)return ;\\n        if(a==0&&b==0)ans = s;\\n        long long int x = get(a,b-1);\\n        if(k==1){\\n            if(a==0){\\n                solve(a,b-1,k,s+\\'H\\');\\n            }else if(b==0){\\n                solve(a-1,b,k,s+\\'V\\');\\n            }\\n        }\\n        if(k*1LL>x){\\n            solve(a-1,b,k-x,s+\\'V\\');\\n        }else{\\n            solve(a,b-1,k,s+\\'H\\');\\n        }\\n    }\\n    string kthSmallestPath(vector<int>& v, int k) {\\n        solve(v[0],v[1],k,\"\");\\n        return ans;\\n    }\\n};\\n```\\n\\n# Iterator\\n````\\nclass Solution {\\npublic:\\n    long long int get(int a,int b){\\n        long long int ans = 1;\\n        int k = a+b;\\n        while(k>a){\\n            ans *= k;\\n            k--;\\n            while(b>1&&ans%b==0){\\n                ans /= b;\\n                b--;\\n            }\\n        }\\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& a, int b) {\\n        int h = a[1],v=a[0],n=a[0]+a[1],i;\\n        long long int x;\\n        long long int k = b;\\n        string ans = \"\";\\n        for(i = 0; i < n; i++){\\n            if(h){\\n                x = get(h-1,v);\\n                cout<<x<<\" \"<<k<<endl;\\n                if(x>=k){\\n                    ans += \\'H\\';\\n                    h--;\\n                }else{\\n                    k -= x;\\n                    ans += \\'V\\';\\n                    v--;\\n                }\\n            }else{\\n                ans += \\'V\\';\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    long long int get(int a,int b){\\n        long long int ans = 1;\\n        int k = a+b;\\n        while(k>a){\\n            ans *= k;\\n            k--;\\n            while(b>1&&ans%b==0){\\n                ans /= b;\\n                b--;\\n            }\\n        }\\n        return ans;\\n    }\\n    void solve(int a,int b,int k,string s){\\n        if(a<0||b<0)return ;\\n        if(a==0&&b==0)ans = s;\\n        long long int x = get(a,b-1);\\n        if(k==1){\\n            if(a==0){\\n                solve(a,b-1,k,s+\\'H\\');\\n            }else if(b==0){\\n                solve(a-1,b,k,s+\\'V\\');\\n            }\\n        }\\n        if(k*1LL>x){\\n            solve(a-1,b,k-x,s+\\'V\\');\\n        }else{\\n            solve(a,b-1,k,s+\\'H\\');\\n        }\\n    }\\n    string kthSmallestPath(vector<int>& v, int k) {\\n        solve(v[0],v[1],k,\"\");\\n        return ans;\\n    }\\n};\\n```\n````\\nclass Solution {\\npublic:\\n    long long int get(int a,int b){\\n        long long int ans = 1;\\n        int k = a+b;\\n        while(k>a){\\n            ans *= k;\\n            k--;\\n            while(b>1&&ans%b==0){\\n                ans /= b;\\n                b--;\\n            }\\n        }\\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& a, int b) {\\n        int h = a[1],v=a[0],n=a[0]+a[1],i;\\n        long long int x;\\n        long long int k = b;\\n        string ans = \"\";\\n        for(i = 0; i < n; i++){\\n            if(h){\\n                x = get(h-1,v);\\n                cout<<x<<\" \"<<k<<endl;\\n                if(x>=k){\\n                    ans += \\'H\\';\\n                    h--;\\n                }else{\\n                    k -= x;\\n                    ans += \\'V\\';\\n                    v--;\\n                }\\n            }else{\\n                ans += \\'V\\';\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3219366,
                "title": "python-3-13-lines-iterative-recursive-versions-w-example-t-m-94-81",
                "content": "The iterative version:\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\n        (v, h), ans = destination, \\'\\'   # Example: destination = [3, 4]   k = 16 \\n\\n        while h and v:          #   h      v      k      c               Ans       \\n                                #  \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013              \\u2013\\u2013\\u2013\\n            c = comb(h+v-1,v)   #   4      3      16    comb(6,3) = 20   \"H\"\\n                                #   3      3      16    comb(5,3) = 10   \"HV\"      \\n            if c < k:           #   3      2       6    comb(4,2) =  6   \"HVH\"\\n                ans+= \\'V\\'       #   2      2       6    comb(3,1) =  3   \"HVHV\"\\n                v-= 1           #   2      1       3    comb(2,1) =  2   \"HVHV\"\\n                k-= c           #   2      0       1                     \"HVHVV\"\\n            else: \\n                ans+= \\'H\\'       #   return \"HVHVV\" + \"H\"*2 = \"HVHVVHH\"\\n                h-= 1\\n          \\n        if not h: ans+= \\'V\\'*v\\n        if not v: ans+= \\'H\\'*h    \\n        \\n        return ans\\n```\\n[https://leetcode.com/problems/kth-smallest-instructions/submissions/903074964/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n\\n_______\\n\\nThe recursive version:\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\n        v, h = destination\\n\\n        def dp(h: int,v: int,k: int)-> str:\\n\\n            if not h: return \\'V\\'*v\\n            if not v: return \\'H\\'*h\\n\\n            c = comb(h+v-1,v)\\n\\n            if c < k: return \\'V\\' + dp(h  ,v-1,k - c)\\n            else    : return \\'H\\' + dp(h-1,v  ,k)\\n        \\n        return dp(h,v,k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\n        (v, h), ans = destination, \\'\\'   # Example: destination = [3, 4]   k = 16 \\n\\n        while h and v:          #   h      v      k      c               Ans       \\n                                #  \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013              \\u2013\\u2013\\u2013\\n            c = comb(h+v-1,v)   #   4      3      16    comb(6,3) = 20   \"H\"\\n                                #   3      3      16    comb(5,3) = 10   \"HV\"      \\n            if c < k:           #   3      2       6    comb(4,2) =  6   \"HVH\"\\n                ans+= \\'V\\'       #   2      2       6    comb(3,1) =  3   \"HVHV\"\\n                v-= 1           #   2      1       3    comb(2,1) =  2   \"HVHV\"\\n                k-= c           #   2      0       1                     \"HVHVV\"\\n            else: \\n                ans+= \\'H\\'       #   return \"HVHVV\" + \"H\"*2 = \"HVHVVHH\"\\n                h-= 1\\n          \\n        if not h: ans+= \\'V\\'*v\\n        if not v: ans+= \\'H\\'*h    \\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\n        v, h = destination\\n\\n        def dp(h: int,v: int,k: int)-> str:\\n\\n            if not h: return \\'V\\'*v\\n            if not v: return \\'H\\'*h\\n\\n            c = comb(h+v-1,v)\\n\\n            if c < k: return \\'V\\' + dp(h  ,v-1,k - c)\\n            else    : return \\'H\\' + dp(h-1,v  ,k)\\n        \\n        return dp(h,v,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176711,
                "title": "java-100-faster-dp-best-explanation",
                "content": "Combinations[i][j] tells us how many combinations of strings/paths is possible if we start from i,j and reach destination. Number of paths/strings which can be formed at Combinations[i][j] = Combinations[i+1][j] + Combinations[i][j+1].  consider making dp for destination 2,3.\\nTo start from 1,2 and reach 2,3 we will have one \\'H\\' and one \\'V\\' which is why Combinations[i][j]  will be 2(HV and VH). If we use H at first position we move right and we are left with one \\'V\\'.\\nNow consider being on position 1,1 and same desitination.\\ncombinations[i][j]= 3 because we can move right twice and down once so we have 2 \\'H\\' and 1 \\'V\\'. paths: HHV HVH VHH\\nIf we choose 1st char as V and move down we will be left with HH which can make only one combination but if we go right that means curr char should be H and we are left with 1 H and 1 V which gives us 2 combinations(HV VH).\\nIn conclusion if we use H as curr char we move right which give us access to strings/paths which are lexicographically smaller compared to moving down and using curr char as V.\\nConsidering same destination 2,3 let k be 4 and lets start from 0,0.\\nwe see that moving right means we are using 1st char as \\'H\\'. We compare k to strings/paths to the right(lexicographically smaller strings compared to down) combination[i][j+1]= 6 Those strings are HHHVV HHVHV HHVVH HVHHV HVHVH HVVHH combination[i+1][j]= 4 These are the strings starting from \\'V\\'. since k=4 is less than equal to number of strings to right It means our ans string in within them. so we move to the right. Now we are at 0,1 where num of strings is 6. On the right we have combination[i][j+1]= 3 Because these strings/paths are HVV VHV VVH and combination[i+1][j]= 3 are strings HHV HVH VHH. At position 0,0 on right we had top 6 lexicographically smallest paths and below we had 4 bigger strings and since we want 4th smallest we go right.\\nNow at 0,1 we compare k with combination[i][j+1]. 4 is not less than or equal to 3 which says that 4th smallest string is not among the top 3 smallest (top 3 out of 10 and also top 3 out of top 6) which tells us that we need to move down and search for bigger top 3 string out of 1st chosen top 6 strings at 0,0. so we discard strings with rank 1,2 and 3 and choose bottom 3 which means now we will choose from 4th 5th 6th smallest strings out of original 10. But we cant keep k as 4 since we discarded 1st 2nd and 3rd smallest string and 4th smallest is actual 1st smallest from 4th 5th and 6th string that is the reason we subtract combinations[i][j+1] from k.\\n```\\n\\tpublic String kthSmallestPath(int[] destination, int k) {\\n        int rows= destination[0]+1, cols= destination[1]+1;\\n        int[][] combinations= new int[rows][cols];\\n        for(int i=rows-1; i>=0; i--){\\n            for(int j=cols-1; j>=0; j--){\\n                combinations[i][j]= (i==rows-1 || j==cols-1) ? 1 : combinations[i][j+1] + combinations[i+1][j];\\n            }\\n        }\\n        StringBuilder sb= new StringBuilder();\\n        int i=0, j=0;\\n        while(i != rows-1 || j != cols-1){\\n            if(i==rows-1){\\n                sb.append(\\'H\\');\\n                j++;\\n            }else if(j==cols-1){\\n                sb.append(\\'V\\');\\n                i++;\\n            }else if(combinations[i][j+1]>=k){\\n                sb.append(\\'H\\');\\n                j++;\\n            }else{\\n                sb.append(\\'V\\');\\n                k-= combinations[i][j+1];\\n                i++;\\n            }\\n        }\\n        return String.valueOf(sb);\\n    }",
                "solutionTags": [],
                "code": "Combinations[i][j] tells us how many combinations of strings/paths is possible if we start from i,j and reach destination. Number of paths/strings which can be formed at Combinations[i][j] = Combinations[i+1][j] + Combinations[i][j+1].  consider making dp for destination 2,3.\\nTo start from 1,2 and reach 2,3 we will have one \\'H\\' and one \\'V\\' which is why Combinations[i][j]  will be 2(HV and VH). If we use H at first position we move right and we are left with one \\'V\\'.\\nNow consider being on position 1,1 and same desitination.\\ncombinations[i][j]= 3 because we can move right twice and down once so we have 2 \\'H\\' and 1 \\'V\\'. paths: HHV HVH VHH\\nIf we choose 1st char as V and move down we will be left with HH which can make only one combination but if we go right that means curr char should be H and we are left with 1 H and 1 V which gives us 2 combinations(HV VH).\\nIn conclusion if we use H as curr char we move right which give us access to strings/paths which are lexicographically smaller compared to moving down and using curr char as V.\\nConsidering same destination 2,3 let k be 4 and lets start from 0,0.\\nwe see that moving right means we are using 1st char as \\'H\\'. We compare k to strings/paths to the right(lexicographically smaller strings compared to down) combination[i][j+1]= 6 Those strings are HHHVV HHVHV HHVVH HVHHV HVHVH HVVHH combination[i+1][j]= 4 These are the strings starting from \\'V\\'. since k=4 is less than equal to number of strings to right It means our ans string in within them. so we move to the right. Now we are at 0,1 where num of strings is 6. On the right we have combination[i][j+1]= 3 Because these strings/paths are HVV VHV VVH and combination[i+1][j]= 3 are strings HHV HVH VHH. At position 0,0 on right we had top 6 lexicographically smallest paths and below we had 4 bigger strings and since we want 4th smallest we go right.\\nNow at 0,1 we compare k with combination[i][j+1]. 4 is not less than or equal to 3 which says that 4th smallest string is not among the top 3 smallest (top 3 out of 10 and also top 3 out of top 6) which tells us that we need to move down and search for bigger top 3 string out of 1st chosen top 6 strings at 0,0. so we discard strings with rank 1,2 and 3 and choose bottom 3 which means now we will choose from 4th 5th 6th smallest strings out of original 10. But we cant keep k as 4 since we discarded 1st 2nd and 3rd smallest string and 4th smallest is actual 1st smallest from 4th 5th and 6th string that is the reason we subtract combinations[i][j+1] from k.\\n```\\n\\tpublic String kthSmallestPath(int[] destination, int k) {\\n        int rows= destination[0]+1, cols= destination[1]+1;\\n        int[][] combinations= new int[rows][cols];\\n        for(int i=rows-1; i>=0; i--){\\n            for(int j=cols-1; j>=0; j--){\\n                combinations[i][j]= (i==rows-1 || j==cols-1) ? 1 : combinations[i][j+1] + combinations[i+1][j];\\n            }\\n        }\\n        StringBuilder sb= new StringBuilder();\\n        int i=0, j=0;\\n        while(i != rows-1 || j != cols-1){\\n            if(i==rows-1){\\n                sb.append(\\'H\\');\\n                j++;\\n            }else if(j==cols-1){\\n                sb.append(\\'V\\');\\n                i++;\\n            }else if(combinations[i][j+1]>=k){\\n                sb.append(\\'H\\');\\n                j++;\\n            }else{\\n                sb.append(\\'V\\');\\n                k-= combinations[i][j+1];\\n                i++;\\n            }\\n        }\\n        return String.valueOf(sb);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 923436,
                "title": "c-less-than-4ms-easy-approach",
                "content": "Step by step fill the string ans\\n\\n* Count the number of permutations that exist if H is placed at index i of string ans\\n* If the kth permutation lies in this set of permutations, then place H and continue for the next i\\n* Else place V and move the search window to the next set, and continue for the next i\\n\\n```\\n#include<bits/stdc++.h>\\ntypedef unsigned long long int ll;\\nclass Solution {\\npublic:\\n    ll ncr(int n, int r)\\n    {\\n        ll ans = 1;\\n        int r1 = max(r, n-r);\\n        int r2 = n-r1;\\n        \\n        for(int i = 1; i<=r2; i++)\\n        {\\n            ans*=ll(n);\\n            n--;\\n            ans/=ll(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& ds, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        string ans = \"\";\\n        int x = ds[1];\\n        int y = ds[0];\\n        int n = (x+y);\\n        \\n        ll np = ncr(n, y);\\n        \\n        ll l = 1;\\n        ll r = np;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(x==0)\\n            {\\n                ans+=\"V\";\\n                y--;\\n                continue;\\n            }\\n            if(y==0)\\n            {\\n                ans+=\"H\";\\n                x--;\\n                continue;\\n            }\\n            \\n            ll nph = ncr(x-1+y, y);\\n            ll nr = l+nph-ll(1);\\n            if(nr >= ll(k))\\n            {\\n                ans+=\"H\";\\n                x--;\\n            }\\n            else\\n            {\\n                ans+=\"V\";\\n                y--;\\n                l = nr+ll(1);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\ntypedef unsigned long long int ll;\\nclass Solution {\\npublic:\\n    ll ncr(int n, int r)\\n    {\\n        ll ans = 1;\\n        int r1 = max(r, n-r);\\n        int r2 = n-r1;\\n        \\n        for(int i = 1; i<=r2; i++)\\n        {\\n            ans*=ll(n);\\n            n--;\\n            ans/=ll(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& ds, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        string ans = \"\";\\n        int x = ds[1];\\n        int y = ds[0];\\n        int n = (x+y);\\n        \\n        ll np = ncr(n, y);\\n        \\n        ll l = 1;\\n        ll r = np;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            if(x==0)\\n            {\\n                ans+=\"V\";\\n                y--;\\n                continue;\\n            }\\n            if(y==0)\\n            {\\n                ans+=\"H\";\\n                x--;\\n                continue;\\n            }\\n            \\n            ll nph = ncr(x-1+y, y);\\n            ll nr = l+nph-ll(1);\\n            if(nr >= ll(k))\\n            {\\n                ans+=\"H\";\\n                x--;\\n            }\\n            else\\n            {\\n                ans+=\"V\";\\n                y--;\\n                l = nr+ll(1);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 920248,
                "title": "golang-o-m-n-solution-with-picture-explain-end-start-then-start-end",
                "content": "First we calculate how many paths from any point to end point, using f(i, j) = f(i+1, j) + f(i, j+1).\\n![image](https://assets.leetcode.com/users/images/44cb68ae-1586-4c43-9504-9e7b4133e027_1604299930.3191037.png)\\n\\nThen we can walk from start point to end point, say we want kth path where k=3.\\nNow we know from (0, 1) to end point there are 6 paths, and from (1, 0) to end point there are 4 paths.\\n![image](https://assets.leetcode.com/users/images/7737b68a-ea31-4582-aeb3-a56f5f4b40a1_1604300198.8034694.png)\\n\\nNo matter what the suffix is, the 6 paths from (0, 1) must be:\\nHxxxx\\nHxxxx\\nHxxxx\\nHxxxx\\nHxxxx\\nHxxxx\\nand the 4 paths from (1, 0) must be:\\nVxxxx\\nVxxxx\\nVxxxx\\nVxxxx\\n\\nSo it is certain that any path in the 6 paths from (0, 1) **must be smaller than** any path in the 4 paths from (1, 0), so the 3rd path must in (0, 1).\\nAnd if k=7, the 7th path must in (1, 0).\\n\\nRepeat this until we reach the end point.\\n\\n```go\\nfunc kthSmallestPath(destination []int, k int) string {\\n    row, col := destination[0], destination[1]\\n    f := make([][]int, row+2)\\n    for i := 0; i <= row+1; i++ {\\n        f[i] = make([]int, col+2)\\n    }\\n    f[row][col] = 1\\n    for i := row; i >= 0; i-- {\\n        for j := col; j >= 0; j-- {\\n            if i == row && j == col {\\n                continue\\n            }\\n            f[i][j] = f[i+1][j] + f[i][j+1]\\n        }\\n    }\\n    result := \"\"\\n    i, j := 0, 0\\n    for {\\n        if i == row {\\n            j++\\n            result = result + \"H\"\\n        } else if j == col {\\n            i++\\n            result = result + \"V\"\\n        } else {\\n            if k <= f[i][j+1] {\\n                j++\\n                result = result + \"H\"\\n            } else {\\n                k -= f[i][j+1]\\n                i++\\n                result = result + \"V\"\\n            }\\n        }\\n        if i == row && j == col {\\n            break\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc kthSmallestPath(destination []int, k int) string {\\n    row, col := destination[0], destination[1]\\n    f := make([][]int, row+2)\\n    for i := 0; i <= row+1; i++ {\\n        f[i] = make([]int, col+2)\\n    }\\n    f[row][col] = 1\\n    for i := row; i >= 0; i-- {\\n        for j := col; j >= 0; j-- {\\n            if i == row && j == col {\\n                continue\\n            }\\n            f[i][j] = f[i+1][j] + f[i][j+1]\\n        }\\n    }\\n    result := \"\"\\n    i, j := 0, 0\\n    for {\\n        if i == row {\\n            j++\\n            result = result + \"H\"\\n        } else if j == col {\\n            i++\\n            result = result + \"V\"\\n        } else {\\n            if k <= f[i][j+1] {\\n                j++\\n                result = result + \"H\"\\n            } else {\\n                k -= f[i][j+1]\\n                i++\\n                result = result + \"V\"\\n            }\\n        }\\n        if i == row && j == col {\\n            break\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918638,
                "title": "java-simple-solution",
                "content": "If k is bigger than total number of combination that starts with `H` then we should pick `V`\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        return helper(destination[1],destination[0],k-1,\"\");\\n    }\\n    \\n    private String helper(int H, int V, int k, String result){\\n        if(H==0&& V==0) return result;\\n        if(H==0) return helper(H,V-1,k,result+\"V\");\\n        if(V==0) return helper(H-1,V,k,result+\"H\");\\n        Long combinationIfItStartsWithH = combination(H+V-1, Math.min(H-1, V));\\n        if(combinationIfItStartsWithH<=k){\\n            return helper(H,V-1,k-combinationIfItStartsWithH.intValue(),result+\"V\");\\n        }\\n        return helper(H-1,V,k,result+\"H\");\\n    }\\n    \\n    private long combination(Integer M, Integer N){\\n        long result = 1l;\\n        for(int i=0;i<N;i++){\\n            result *= M-i;\\n            result /=(i+1);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        return helper(destination[1],destination[0],k-1,\"\");\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2853322,
                "title": "python3-solution-combination",
                "content": "# Solution - 1\\n```Python\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        ans = \\'\\'\\n        while K and H and V:\\n            C = comb(H + V - 1, H - 1)\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```\\n\\n# Solution - 2\\n```Python\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        C = comb(H + V - 1, H - 1)\\n        ans = \\'\\'\\n        while K and H and V:\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n                C *= (V + 1)\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n                C *= H\\n            C //= (V + H)\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```Python\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        ans = \\'\\'\\n        while K and H and V:\\n            C = comb(H + V - 1, H - 1)\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```\n```Python\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        C = comb(H + V - 1, H - 1)\\n        ans = \\'\\'\\n        while K and H and V:\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n                C *= (V + 1)\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n                C *= H\\n            C //= (V + H)\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716250,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { \\n                int c = comb(h - 1 + v, v); \\n                if (k <= c) { \\n                    s += \\'H\\';\\n                    --h;\\n                } else { \\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } else { \\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { \\n                int c = comb(h - 1 + v, v); \\n                if (k <= c) { \\n                    s += \\'H\\';\\n                    --h;\\n                } else { \\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } else { \\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084437,
                "title": "c-dynamic-programming",
                "content": "The idea is to a matrix \"dp\". where dp[i][j] stores the number of ways from (i,j) to (m, n).\\nAt (i, j), we need to determine the next move: whether to (i+1, j) or (i, j+1).\\n\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int m = destination[0], n = destination[1];\\n        \\n        vector<vector<int>> dp(m+2, vector<int>(n+2, 0));\\n        dp[m][n] = 1;\\n        for(int i=m; i>=0; i--) {\\n            for(int j=n; j>=0; j--) {\\n                if(i == m && j == n) continue;\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        int r = 0, c = 0;\\n        int step = 0, remain = k;\\n        for(int step = 0; step < m+n; step++) {\\n            if(dp[r][c+1] >= remain) {\\n                c = c+1;\\n                ans += \\'H\\';\\n            } else {\\n                remain -= dp[r][c+1];\\n                r = r+1;\\n                ans += \\'V\\';\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int m = destination[0], n = destination[1];\\n        \\n        vector<vector<int>> dp(m+2, vector<int>(n+2, 0));\\n        dp[m][n] = 1;\\n        for(int i=m; i>=0; i--) {\\n            for(int j=n; j>=0; j--) {\\n                if(i == m && j == n) continue;\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        int r = 0, c = 0;\\n        int step = 0, remain = k;\\n        for(int step = 0; step < m+n; step++) {\\n            if(dp[r][c+1] >= remain) {\\n                c = c+1;\\n                ans += \\'H\\';\\n            } else {\\n                remain -= dp[r][c+1];\\n                r = r+1;\\n                ans += \\'V\\';\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933974,
                "title": "java-combinatorics-solution",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int n = destination[0] + destination[1];\\n        for (int i = 0; i < n; i++) {\\n            long cnt = comb(n - i - 1, destination[0]); //look at the subsequent possible characters after this one. n - i - 1.\\n            if (destination[0] == 0) {\\n                sb.append(\\'H\\');\\n                destination[1]--;\\n                continue;\\n            }\\n            if (destination[1] == 0) {\\n                sb.append(\\'V\\');\\n                destination[0]--;\\n                continue;\\n            }\\n            if (k <= cnt) {\\n                destination[1]--;\\n                sb.append(\\'H\\');\\n            }\\n            else {\\n                destination[0]--;\\n                k -= cnt;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private long comb(int n, int k) {\\n        long res = 1;\\n        for (int i = 0; i < k; i++) {\\n            res *= n - i; // getting rid of n - k and onwards.\\n            res /= i + 1; // including division of k!.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int n = destination[0] + destination[1];\\n        for (int i = 0; i < n; i++) {\\n            long cnt = comb(n - i - 1, destination[0]); //look at the subsequent possible characters after this one. n - i - 1.\\n            if (destination[0] == 0) {\\n                sb.append(\\'H\\');\\n                destination[1]--;\\n                continue;\\n            }\\n            if (destination[1] == 0) {\\n                sb.append(\\'V\\');\\n                destination[0]--;\\n                continue;\\n            }\\n            if (k <= cnt) {\\n                destination[1]--;\\n                sb.append(\\'H\\');\\n            }\\n            else {\\n                destination[0]--;\\n                k -= cnt;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private long comb(int n, int k) {\\n        long res = 1;\\n        for (int i = 0; i < k; i++) {\\n            res *= n - i; // getting rid of n - k and onwards.\\n            res /= i + 1; // including division of k!.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921112,
                "title": "java-simple-solution-using-dfs-and-memoization-beats-83",
                "content": "The idea is to first write a method to do dfs (with memoization) to find number of ways to reach destination from coordinates `x` and `y`.  This is the key step to the solution.\\nOnce we have done that then we can realize that\\n\\n- `dfs(dest, x, y) == dfs(dest, x, y+1) + dfs(dest, x+1, y)`.  This is because these are only two ways to reach the destination. Let\\'s call these search spaces `hSpace` and `vSpace` respectively. \\n- the `hSpace` is lexicographically smaller than `vSpace`.\\n- If `k <= dfs(dest, x, y+1)` then we know the search space starts with an \"H\", and we can continue in `hSpace`. Like say total ways to reach destination are 1000, of which 900 are in `hSpace` and 100 in `vSpace`. Now if we are looking for 200th entry then we know that we need to start with an \"H\", and look for 200 in the `hSpace`. \\n- If `k > dfs(dest, x, y+1)` then we know search space starts with a \"V\", and we are looking for `(k - dfs(dest, x, y+1)` entry in this search space space. Like say total ways to reach destination are 1000, of which 900 are in `hSpace` and 100 in `vSpace`. Now if we are looking for 950th entry then we know that we need to start with a \"V\", and look for (950-900 == 50th) position in the `vSpace`. \\n- We add an \"H\", or a \"V\" based on which track we followed in the last step(s).\\n- We continue updating our `x`,` y` and `k` in a loop\\n- We continue doing this till we reach our destination\\n\\n```\\nclass Solution {\\n    Integer[][] cache = null;\\n    public String kthSmallestPath(int[] destination, int k) {\\n        cache = new Integer[destination[0]+1][destination[1]+1];\\n        StringBuffer sb = new StringBuffer();\\n        int x = 0, y = 0;\\n        while (true) {\\n            if (x == destination[0] && y == destination[1]) break;\\n            int h = (y < destination[1]) ? dfs(destination, x, y+1) : 0;\\n            int v = (x < destination[0]) ? dfs(destination, x+1, y) : 0;\\n            \\n            if (k <= h) {\\n                sb.append(\"H\");\\n                y += 1;\\n            } else {\\n                sb.append(\"V\");\\n                k = k-h;\\n                x += 1;\\n            }\\n        }\\n        return sb.toString(); \\n    }\\n    \\n    int dfs(int[] dest, int x, int y) {\\n        if (cache[x][y] != null) return cache[x][y];\\n        if (x == dest[0] && y == dest[1])  return 1;\\n        \\n        int tot = 0;\\n        if (y+1 <= dest[1])\\n            tot += dfs(dest, x, y+1);\\n        \\n        if (x+1 <= dest[0])\\n            tot += dfs(dest, x+1, y);\\n        \\n        cache[x][y] = tot;\\n        return tot;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer[][] cache = null;\\n    public String kthSmallestPath(int[] destination, int k) {\\n        cache = new Integer[destination[0]+1][destination[1]+1];\\n        StringBuffer sb = new StringBuffer();\\n        int x = 0, y = 0;\\n        while (true) {\\n            if (x == destination[0] && y == destination[1]) break;\\n            int h = (y < destination[1]) ? dfs(destination, x, y+1) : 0;\\n            int v = (x < destination[0]) ? dfs(destination, x+1, y) : 0;\\n            \\n            if (k <= h) {\\n                sb.append(\"H\");\\n                y += 1;\\n            } else {\\n                sb.append(\"V\");\\n                k = k-h;\\n                x += 1;\\n            }\\n        }\\n        return sb.toString(); \\n    }\\n    \\n    int dfs(int[] dest, int x, int y) {\\n        if (cache[x][y] != null) return cache[x][y];\\n        if (x == dest[0] && y == dest[1])  return 1;\\n        \\n        int tot = 0;\\n        if (y+1 <= dest[1])\\n            tot += dfs(dest, x, y+1);\\n        \\n        if (x+1 <= dest[0])\\n            tot += dfs(dest, x+1, y);\\n        \\n        cache[x][y] = tot;\\n        return tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918827,
                "title": "short-c-solution-using-incremental-combinatorics",
                "content": "```\\nstring kthSmallestPath(vector<int>& D, int k) {\\n    k--; // make 0-indexed\\n    int n = D[0] + D[1];\\n    string ans(n, \\'H\\');\\n    for (int i = D[0]; i > 0; i--) {\\n        int a = i - 1, b = 0, c = 1;\\n        while (k >= c) {\\n            k -= c;\\n            c = c * ++a / ++b;\\n        }\\n        ans[n - 1 - a] = \\'V\\';\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring kthSmallestPath(vector<int>& D, int k) {\\n    k--; // make 0-indexed\\n    int n = D[0] + D[1];\\n    string ans(n, \\'H\\');\\n    for (int i = D[0]; i > 0; i--) {\\n        int a = i - 1, b = 0, c = 1;\\n        while (k >= c) {\\n            k -= c;\\n            c = c * ++a / ++b;\\n        }\\n        ans[n - 1 - a] = \\'V\\';\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918741,
                "title": "java-100-fast-iterative-dp",
                "content": "Similar to @useliuqing\\'s solution, but iterative fashion.. all credits to @useliuqing \\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        //create a dp of how many ways to reach destination from present row and col\\n      int rows = destination[0];\\n      int cols = destination[1];\\n      \\n      int[][] dp = new int[rows+1][cols+1];\\n      \\n      Arrays.fill(dp[rows],1); //the bottom rows, only possible way . move right\\n      \\n      for(int row=0;row<=rows;row++) //the righmost wall, only possible way.. move down\\n        dp[row][cols]=1;\\n      \\n      for(int row=rows-1;row>=0;row--){\\n        for(int col=cols-1;col>=0;col--){\\n          dp[row][col] = dp[row+1][col] + dp[row][col+1];\\n        }\\n      }\\n      \\n      //we know for fact that all dp[i][j+1] paths are lexicographically smaller than dp[i+1][j], since \\'H\\' movement is lexicographically smaller than \\'V\\', we compare k with horizontal movement\\n\\t  //if moving horizontal gives more ways than k, then we move horizontal, if it gives less ways than we need for k, we move vertical and since we are skipping all ways created by moving horizontal, we decrement k by those all ways created by moving horizontal...\\n      //if we reach wall, we keep moving along the wall, only possible way\\n      \\n      StringBuilder result = new StringBuilder();\\n      \\n      int positionX = 0, positionY=0;\\n      \\n      while(positionX!=rows || positionY!=cols){\\n        \\n        if(positionX==rows){\\n          while(positionY!=cols){\\n            result.append(\\'H\\');\\n            positionY++;\\n          }\\n           return result.toString();\\n        }\\n        \\n        if(positionY==cols){\\n          while(positionX!=rows){\\n            result.append(\\'V\\');\\n            positionX++;\\n          }\\n          return result.toString();\\n        }\\n        \\n        if(dp[positionX][positionY+1] >= k){\\n          result.append(\\'H\\');\\n          positionY++;\\n        }else{\\n           result.append(\\'V\\');\\n           k-= dp[positionX][positionY+1]; //skipping all horizontal moving ways\\n           positionX++;\\n        } \\n      }      \\n      \\n      return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        //create a dp of how many ways to reach destination from present row and col\\n      int rows = destination[0];\\n      int cols = destination[1];\\n      \\n      int[][] dp = new int[rows+1][cols+1];\\n      \\n      Arrays.fill(dp[rows],1); //the bottom rows, only possible way . move right\\n      \\n      for(int row=0;row<=rows;row++) //the righmost wall, only possible way.. move down\\n        dp[row][cols]=1;\\n      \\n      for(int row=rows-1;row>=0;row--){\\n        for(int col=cols-1;col>=0;col--){\\n          dp[row][col] = dp[row+1][col] + dp[row][col+1];\\n        }\\n      }\\n      \\n      //we know for fact that all dp[i][j+1] paths are lexicographically smaller than dp[i+1][j], since \\'H\\' movement is lexicographically smaller than \\'V\\', we compare k with horizontal movement\\n\\t  //if moving horizontal gives more ways than k, then we move horizontal, if it gives less ways than we need for k, we move vertical and since we are skipping all ways created by moving horizontal, we decrement k by those all ways created by moving horizontal...\\n      //if we reach wall, we keep moving along the wall, only possible way\\n      \\n      StringBuilder result = new StringBuilder();\\n      \\n      int positionX = 0, positionY=0;\\n      \\n      while(positionX!=rows || positionY!=cols){\\n        \\n        if(positionX==rows){\\n          while(positionY!=cols){\\n            result.append(\\'H\\');\\n            positionY++;\\n          }\\n           return result.toString();\\n        }\\n        \\n        if(positionY==cols){\\n          while(positionX!=rows){\\n            result.append(\\'V\\');\\n            positionX++;\\n          }\\n          return result.toString();\\n        }\\n        \\n        if(dp[positionX][positionY+1] >= k){\\n          result.append(\\'H\\');\\n          positionY++;\\n        }else{\\n           result.append(\\'V\\');\\n           k-= dp[positionX][positionY+1]; //skipping all horizontal moving ways\\n           positionX++;\\n        } \\n      }      \\n      \\n      return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377464,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int getCount(int h, int v)\\n    {\\n        if(h == 0 || v == 0) return 1;\\n        long long res = 1;\\n        if(h < v) swap(h, v);\\n        for(int i = h + 1; i <= (h+v); i++) res *= i;\\n        for(int i = 1; i <= v; i++) res /= i;\\n        return (int)res;\\n    }\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int h = dest[1];\\n        int v = dest[0];\\n        int len = h + v;\\n        string res;\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(h == 0) \\n            {\\n                v--;\\n                res.push_back(\\'V\\');\\n                continue;\\n            }\\n            if(v == 0) \\n            {\\n                h--;\\n                res.push_back(\\'H\\');\\n                continue;\\n            }\\n            int cnt = getCount(h - 1, v);\\n            if(cnt >= k)\\n            {\\n                res.push_back(\\'H\\');\\n                h--;\\n            }\\n            else\\n            {\\n                k -= cnt;\\n                v--;\\n                res.push_back(\\'V\\');\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        ans = \\'\\'\\n        while K and H and V:\\n            C = comb(H + V - 1, H - 1)\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```\\n```Java []\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int m = destination[0] + 1;\\n        int n = destination[1] + 1;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][n-1] = 1; \\n        for (int j = 0; j < n; j++) dp[m-1][j] = 1; \\n        for (int i = m-2; i >= 0; i--) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        int i = 0;\\n        int j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < m-1 && j < n-1) {\\n            if (k <= dp[i][j+1]) {\\n                j++;\\n                sb.append(\\'H\\');\\n            } \\n            else {\\n                k -= dp[i][j+1];\\n                i++;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        for (; i < m-1; i++) sb.append(\\'V\\');\\n        for (; j < n-1; j++) sb.append(\\'H\\');\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int getCount(int h, int v)\\n    {\\n        if(h == 0 || v == 0) return 1;\\n        long long res = 1;\\n        if(h < v) swap(h, v);\\n        for(int i = h + 1; i <= (h+v); i++) res *= i;\\n        for(int i = 1; i <= v; i++) res /= i;\\n        return (int)res;\\n    }\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int h = dest[1];\\n        int v = dest[0];\\n        int len = h + v;\\n        string res;\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(h == 0) \\n            {\\n                v--;\\n                res.push_back(\\'V\\');\\n                continue;\\n            }\\n            if(v == 0) \\n            {\\n                h--;\\n                res.push_back(\\'H\\');\\n                continue;\\n            }\\n            int cnt = getCount(h - 1, v);\\n            if(cnt >= k)\\n            {\\n                res.push_back(\\'H\\');\\n                h--;\\n            }\\n            else\\n            {\\n                k -= cnt;\\n                v--;\\n                res.push_back(\\'V\\');\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def kthSmallestPath(self, D, K):\\n        K -= 1\\n        V, H = D\\n        ans = \\'\\'\\n        while K and H and V:\\n            C = comb(H + V - 1, H - 1)\\n            if C <= K:\\n                ans, V, K = ans + \\'V\\', V - 1, K - C\\n            else:\\n                ans, H = ans + \\'H\\', H - 1\\n        return ans + \\'H\\' * H + \\'V\\' * V\\n```\n```Java []\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int m = destination[0] + 1;\\n        int n = destination[1] + 1;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][n-1] = 1; \\n        for (int j = 0; j < n; j++) dp[m-1][j] = 1; \\n        for (int i = m-2; i >= 0; i--) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n        int i = 0;\\n        int j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < m-1 && j < n-1) {\\n            if (k <= dp[i][j+1]) {\\n                j++;\\n                sb.append(\\'H\\');\\n            } \\n            else {\\n                k -= dp[i][j+1];\\n                i++;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        for (; i < m-1; i++) sb.append(\\'V\\');\\n        for (; j < n-1; j++) sb.append(\\'H\\');\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591572,
                "title": "o-m-n-time-o-1-space-combination-1-less-when-we-add-h-or-v",
                "content": "```\\n  /*  Approach 1 ( Normla matrix dfs approach dont work here TLE )\\n    void solve(int i,int j,string out=\"\")\\n    {\\n        if(i>m or j>n)\\n            return;\\n        \\n        if(i==m and j==n)\\n        {\\n            k--;\\n            if(k==0)\\n                ans=out;\\n            \\n            return;\\n        }\\n        solve(i,j+1,out+\\'H\\');\\n        solve(i+1,j,out+\\'V\\');\\n    }*/\\n    \\n    //Optimized apprpach Time : O(M+N) Space : O(1)\\n   //refer this video if you dont get the code -->  https://www.youtube.com/watch?v=-nQJGAY7oMc&list=PLKZaSt2df1gyrDJMAcAEV4j7Q5aFA22RU&index=1\\n    \\n    int comb(int n,int r)\\n    {\\n        //caclulating nCr\\n        //nCr= { n*(n-1)*(n-2)*.... *(n-r-1) } / {1*2*3..... *r}\\n        \\n        int ans=1;\\n        for(int i=1;i<=r;i++)\\n            ans=ans*(n-i+1)/i;   //ans=ans*(n/1)  ans=ans*(n-1)/2  ans\\n        \\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        int h=destination[1];\\n        int v=destination[0];\\n        \\n        string ans=\"\";\\n        \\n        while(h>0 or v>0)\\n        {\\n            //Case 1 --> Bhai \\'h\\' pde hue hai to chota instruction shyd bnjaye dekho\\n            if(h>0)\\n            {\\n//IMPORTANT --> h ek kam hai hmare pas aur v utne hi to uske combinations bnao\\n                int c=comb(h-1+v,v); \\n                \\n//k mera combination number ke andr ara to mtlb is jgh pe to \\'H\\' hi ayega brother\\n                if(k<=c)  \\n                {\\n                    ans+=\\'H\\';\\n                    h--;\\n                }\\n                    \\n                else if(k>c)\\n                {\\n                    ans+=\\'V\\';\\n                    v--;\\n                    k-=c;  //k>c ab maine k ko kam krdiya kya pta aage \\'H\\' add krpau\\n                }   \\n            }\\n            \\n    //case 2 -->bhai agar \\'H\\' hai hi nahi to fr to \\'V\\' hi add krte rho jitne bche\\n            else\\n            {\\n                ans+=\\'V\\';\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n  /*  Approach 1 ( Normla matrix dfs approach dont work here TLE )\\n    void solve(int i,int j,string out=\"\")\\n    {\\n        if(i>m or j>n)\\n            return;\\n        \\n        if(i==m and j==n)\\n        {\\n            k--;\\n            if(k==0)\\n                ans=out;\\n            \\n            return;\\n        }\\n        solve(i,j+1,out+\\'H\\');\\n        solve(i+1,j,out+\\'V\\');\\n    }*/\\n    \\n    //Optimized apprpach Time : O(M+N) Space : O(1)\\n   //refer this video if you dont get the code -->  https://www.youtube.com/watch?v=-nQJGAY7oMc&list=PLKZaSt2df1gyrDJMAcAEV4j7Q5aFA22RU&index=1\\n    \\n    int comb(int n,int r)\\n    {\\n        //caclulating nCr\\n        //nCr= { n*(n-1)*(n-2)*.... *(n-r-1) } / {1*2*3..... *r}\\n        \\n        int ans=1;\\n        for(int i=1;i<=r;i++)\\n            ans=ans*(n-i+1)/i;   //ans=ans*(n/1)  ans=ans*(n-1)/2  ans\\n        \\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        int h=destination[1];\\n        int v=destination[0];\\n        \\n        string ans=\"\";\\n        \\n        while(h>0 or v>0)\\n        {\\n            //Case 1 --> Bhai \\'h\\' pde hue hai to chota instruction shyd bnjaye dekho\\n            if(h>0)\\n            {\\n//IMPORTANT --> h ek kam hai hmare pas aur v utne hi to uske combinations bnao\\n                int c=comb(h-1+v,v); \\n                \\n//k mera combination number ke andr ara to mtlb is jgh pe to \\'H\\' hi ayega brother\\n                if(k<=c)  \\n                {\\n                    ans+=\\'H\\';\\n                    h--;\\n                }\\n                    \\n                else if(k>c)\\n                {\\n                    ans+=\\'V\\';\\n                    v--;\\n                    k-=c;  //k>c ab maine k ko kam krdiya kya pta aage \\'H\\' add krpau\\n                }   \\n            }\\n            \\n    //case 2 -->bhai agar \\'H\\' hai hi nahi to fr to \\'V\\' hi add krte rho jitne bche\\n            else\\n            {\\n                ans+=\\'V\\';\\n                v--;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2523350,
                "title": "dp",
                "content": "Use DP to find the number of ways to get to the destination cell (m-1, n-1) from every cell (i, j)\\n\\nAt cell (i, j) deciding to go horizontal or vertical, if dp[i][j+1] <= k, go horizontal, otherwise vertical then update k.\\n\\n```\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tm, n := destination[0] + 1, destination[1] + 1\\n\\tdp := make([][]int, m)\\n\\tfor i := range dp { dp[i] = make([]int, n) }\\n\\tfor i := 0; i < n - 1; i++ { dp[m-1][i] = 1 }\\n\\tfor i := 0; i < m - 1; i++ { dp[i][n-1] = 1 }\\n\\tfor i := m - 2; i >= 0; i-- { for j := n - 2; j >= 0; j-- { dp[i][j] = dp[i][j+1] + dp[i+1][j] } }\\n\\tvar ret string\\n\\ti, j := 0, 0\\n\\tfor i < m - 1 || j < n - 1 {\\n\\t\\tif i == m - 1 {\\n\\t\\t\\tret += \"H\"\\n\\t\\t\\tj++\\n\\t\\t} else if j == n - 1 {\\n\\t\\t\\tret += \"V\"\\n\\t\\t\\ti++\\n\\t\\t} else if k <= dp[i][j+1] {\\n\\t\\t\\tret += \"H\"\\n\\t\\t\\tj++\\n\\t\\t} else {\\n\\t\\t\\tret += \"V\"\\n            k -= dp[i][j+1]\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tm, n := destination[0] + 1, destination[1] + 1\\n\\tdp := make([][]int, m)\\n\\tfor i := range dp { dp[i] = make([]int, n) }\\n\\tfor i := 0; i < n - 1; i++ { dp[m-1][i] = 1 }\\n\\tfor i := 0; i < m - 1; i++ { dp[i][n-1] = 1 }\\n\\tfor i := m - 2; i >= 0; i-- { for j := n - 2; j >= 0; j-- { dp[i][j] = dp[i][j+1] + dp[i+1][j] } }\\n\\tvar ret string\\n\\ti, j := 0, 0\\n\\tfor i < m - 1 || j < n - 1 {\\n\\t\\tif i == m - 1 {\\n\\t\\t\\tret += \"H\"\\n\\t\\t\\tj++\\n\\t\\t} else if j == n - 1 {\\n\\t\\t\\tret += \"V\"\\n\\t\\t\\ti++\\n\\t\\t} else if k <= dp[i][j+1] {\\n\\t\\t\\tret += \"H\"\\n\\t\\t\\tj++\\n\\t\\t} else {\\n\\t\\t\\tret += \"V\"\\n            k -= dp[i][j+1]\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431010,
                "title": "c-kth-permutation",
                "content": "\\tclass Solution {\\npublic:\\n    \\n\\t// function to calculate factorial of a number with a little adjustment \\n\\t//so that it does not go out of the memory bound\\n    long long fact(long long n, long long t)\\n    {\\n        if(n == 0 || n == 1 || n == t) return 1;\\n        return n * fact(n - 1,t);\\n    }\\n\\t\\n\\t//function to calculate total permutation keeping a character at first index\\n    int calculate(char ch, map<char,int>& mp, int len)\\n    {\\n        int k = ch==\\'H\\'?mp[\\'H\\']-1:mp[\\'H\\'];\\n        int j = ch==\\'V\\'?mp[\\'V\\']-1:mp[\\'V\\'];\\n        \\n        long long sum =  fact(len,max(k,j));\\n        sum /= fact(min(k,j),1);\\n        \\n        return (int)sum;\\n    }\\n    \\n    string kthper(int n, int k, map<char,int>& mp)\\n    {\\n        if(mp.size() == 1)\\n        {\\n            string temp = \"\";\\n            for(auto it:mp)\\n            {\\n                while(it.second > 0)\\n                {\\n                    temp.push_back(it.first);\\n                    it.second--;\\n                }\\n            }\\n            return temp;\\n        }\\n        \\n        string res = \"\";\\n        for(auto it: mp)\\n        {\\n            int cal = calculate(it.first, mp, n-1);\\n            if(cal < k)\\n            {\\n                k -= cal;\\n            }\\n            else\\n            {\\n                res.push_back(it.first);\\n                mp[it.first]--;\\n                if(mp[it.first] == 0) mp.erase(it.first);\\n                res += kthper(n-1,k,mp);\\n                break;\\n            }\\n        }\\n        return res;   \\n    }\\n    \\n    string kthSmallestPath(vector<int>& des, int k) {\\n        int n = des[0]+1;\\n        int m = des[1]+1;\\n        string str = \"\";\\n        for(int i=0;i<m-1;i++)\\n        {\\n            str += \"H\";\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            str += \"V\";\\n        }\\n        \\n        map<char,int> mp;\\n        for(auto ch : str)\\n        {\\n            mp[ch]++;\\n        }\\n        return kthper(str.size(),k,mp);\\n    }\\n\\t};\\n\\nWhat i am doing in this solution is , I am picking the smallest character from the string and keeping that character at the first index and finding all possible permutations of rest of the character. Just like you have done in your highschool at the time of permutation and combinations lecture (finding the rank of a word in a dictionary).\\nLets say there are x total permutations if x < k, that means in the kth permutation the letter currently on first index can not be at first index as all the permutations keeping that at first index is less than k; decrease k by x as i have already checked x permutations.\\nNow i will put the next greater character i.e V at first index and calculate all possible permutations and check if no of permutations are less than k (which it should be as there are only 2 char in string) that means V should be my first character in kth permutation.\\nNow i will just call recursion for the rest of the string and finally will return the ans;\\nPS: IT USES THE CONCEPT OF \"FINDING THE RANK OF A WORD IN A DICTIONARY\".",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\t// function to calculate factorial of a number with a little adjustment \\n\\t//so that it does not go out of the memory bound\\n    long long fact(long long n, long long t)\\n    {\\n        if(n == 0 || n == 1 || n == t) return 1;\\n        return n * fact(n - 1,t);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2421911,
                "title": "python-easy-to-understand-explained",
                "content": "Key idea in my solution can be expressed by a simple example:\\n\\n\\n**e.g.** Let\\'s say there are 2 \"V\"s and 3 \"H\"s in the final string.\\n**Q:** How many strings are smaller than, e.g., \"VHHVH\"?\\n\\n**A:** Obviously the smallest one in this case is \"HHHVV\", focusing on the \"V\" which is pulled to the beginning now, if it isn\\'t there, then there are C(4,2) = 6 (4 spots for 2 \"V\"s) strings smaller than \"VHHHV\". Next looking at the 2nd \"V\", if it isn\\'t pulled to the higher position, then there is C(1,1) = 1 (1 spot for 1 \"V\") string smaller than \"_ _ _ VH\". So totally 6 + 1 = 7 strings are smaller than \"VHHHV\", indicating it the 8th smallest string.\\n\\t  \\n\\t  \\nTo find the specific string given a number k is pretty much the same idea, but reversely.\\n\\n\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        m, n = destination\\n        base = [\"H\" for i in range(m+n)] \\n        t = k-1 # num of instructions smaller than the kth smallest one\\n        v_left = m # how many \"V\" left to be put to the right side\\n        \\n        \\n        for i in range(m+n):\\n            if comb(m+n-i-1, v_left) <= t:\\n                base[i] = \"V\"\\n                t -= comb(m+n-i-1, v_left)\\n                v_left -= 1\\n\\n                \\n            #if t == 0, that means the left \"V\" should all be put to the rightmost places\\n            if t == 0:\\n                for j in range(m+n-v_left, m+n):\\n                    base[j] = \"V\"\\n                break\\n        \\n        return \"\".join(base)\\n        \\n        ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        m, n = destination\\n        base = [\"H\" for i in range(m+n)] \\n        t = k-1 # num of instructions smaller than the kth smallest one\\n        v_left = m # how many \"V\" left to be put to the right side\\n        \\n        \\n        for i in range(m+n):\\n            if comb(m+n-i-1, v_left) <= t:\\n                base[i] = \"V\"\\n                t -= comb(m+n-i-1, v_left)\\n                v_left -= 1\\n\\n                \\n            #if t == 0, that means the left \"V\" should all be put to the rightmost places\\n            if t == 0:\\n                for j in range(m+n-v_left, m+n):\\n                    base[j] = \"V\"\\n                break\\n        \\n        return \"\".join(base)\\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2385096,
                "title": "c-combinatorial-solution-with-explanation",
                "content": "A path that leads to the destination is a binary string (each position can contain one of only two chars H or V)\\nDefine:\\n`V = destination[0]` = number of vertical steps to be taken and, \\n`H = destination[1]` = number of horizontal steps to be taken\\n`N = H + V`              = total path length\\n\\nnumber of paths = `nCk(N,H) = N! / ((N-H)! * H!) = nCk(N,V) = N! / ((N-V)! * V!)`\\n\\n\\nTake the example: `H=3, V=2, k=4`\\n`path = _ _ _ _ _`\\nWhere `path[i]` represents the `i-th` step\\n\\nInitial state: `H=3, V=2, k=4`\\nStart completing the path from left to right. \\nLet\\'s try adding `H` as the first step, `path_tmp = H _ _ _ _`\\nIf we fix this, number of valid paths that have `H` in the first location = `nCk(H+V-1, max(H-1,V))  = nCk(4, max(2,2)) = nCk(4,2) = 6`\\nWhich means there are `num0=6` paths that have `H` in the first location \\nWe are looking for `k=4`, so having `H` in the first step will lead us to the correct path\\nNow, `path = H _ _ _ _; H=2, V=2, k=4`\\n\\n\\nState: `H=2, V=2, k=4`\\nLet\\'s try adding `H` as the first step, `path_tmp = H H _ _ _`\\nIf we fix this, number of valid paths that have `H` in the first location = `nCk(H+V-1, max(H-1,V))  = nCk(3, max(1,2)) = nCk(3,2) = 3`\\nWhich means there are `num0=3` paths that have `H H` in the first two locations \\nWe are looking for `k=4`, so having `H` in the first step will **NOT** lead us to the correct path\\nSo let\\'s add `V` instead - `path = H V _ _ _`\\nAlso update `k` because after inserting a `V`, we have already ignored the first `num0=3` paths in lexicographical order\\nNow, `path = H V _ _ _; H=2, V=1, k=1`\\n\\nState: `H=2, V=1, k=1`\\nLet\\'s try adding `H` as the first step, `path_tmp = H V H _ _`\\nIf we fix this, number of valid paths that have `H` in the first location = `nCk(H+V-1, max(H-1,V))  = nCk(2, max(1,1)) = nCk(2,1) = 2`\\nWhich means there are `num0=2` paths that have `H V H _ _` in the first three locations \\nWe are looking for `k=1`, so having `H` in the first step will lead us to the correct path\\nNow, `path = H V H _ _; H=1, V=1, k=1`\\n\\nState: `H=1, V=1, k=1`\\nLet\\'s try adding `H` as the first step, `path_tmp = H V H H _`\\nIf we fix this, number of valid paths that have `H` in the first location = `nCk(H+V-1, max(H-1,V))  = nCk(1, max(0,1)) = nCk(2,1) = 1`\\nWhich means there are `num0=2` paths that have `H V H H _` in the first three locations \\nWe are looking for `k=1`, so having `H` in the first step will lead us to the correct path\\nNow, `path = H V H H _; H=0, V=1, k=1`\\n\\n\\nState: `H=0, V=1, k=1`\\nThis case is easy because only `V` is a valid choice since no `H`-s are left \\nFinal path found by algo: ` H V H H V`\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, long long> fact_cache;\\n    unordered_map<string, long long> nck_cache; \\n    long long factorial(long long x) {\\n        if (fact_cache.count(x)) return fact_cache[x];\\n        long long res = 1;\\n        \\n        if (x > 0) res = (long long) x * factorial(x-1);\\n        \\n        fact_cache[x] = res;\\n        return res;\\n    }\\n    \\n    int nCk(int n, int k) {\\n        // long long den = factorial(k) * factorial(n-k);\\n        // long long num = factorial(n);\\n        \\n        string key = to_string(n) + \"C\" + to_string(k);\\n        if (nck_cache.count(key)) return nck_cache[key];\\n        long long den = factorial(min(k,n-k));\\n        long long num = 1;\\n        for (long long nn = n; nn > (long long) max(n-k,k); --nn) {\\n            num *= nn;\\n        }\\n        int res = (int) (num/den);\\n        nck_cache[key] = res;\\n        \\n        \\n        return res;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int V = destination[0], H = destination[1];\\n        int n = H + V;\\n        vector<char> order({\\'H\\', \\'V\\'});\\n        string path = \"\";\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (!H) {\\n                --V;\\n                path.push_back(\\'V\\');\\n            }\\n            else if (!V) {\\n                --H;\\n                path.push_back(\\'H\\');\\n            }\\n            else {\\n                // if 0 placed in place i\\n                int num0 = nCk(V+H-1, max(V,H-1));\\n                // cout << k << \" \" << H << \" \" << V << \" \" << n-i-1 << \"C\" << max(H-1,V) << \" \" << num0 << endl;\\n\\n                if (num0+1 > k) {\\n                    --H;\\n                    path.push_back(order[0]);\\n                }\\n                else {\\n                    k -= num0;\\n                    --V;\\n                    path.push_back(order[1]);\\n                }\\n            }\\n        }\\n    \\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, long long> fact_cache;\\n    unordered_map<string, long long> nck_cache; \\n    long long factorial(long long x) {\\n        if (fact_cache.count(x)) return fact_cache[x];\\n        long long res = 1;\\n        \\n        if (x > 0) res = (long long) x * factorial(x-1);\\n        \\n        fact_cache[x] = res;\\n        return res;\\n    }\\n    \\n    int nCk(int n, int k) {\\n        // long long den = factorial(k) * factorial(n-k);\\n        // long long num = factorial(n);\\n        \\n        string key = to_string(n) + \"C\" + to_string(k);\\n        if (nck_cache.count(key)) return nck_cache[key];\\n        long long den = factorial(min(k,n-k));\\n        long long num = 1;\\n        for (long long nn = n; nn > (long long) max(n-k,k); --nn) {\\n            num *= nn;\\n        }\\n        int res = (int) (num/den);\\n        nck_cache[key] = res;\\n        \\n        \\n        return res;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int V = destination[0], H = destination[1];\\n        int n = H + V;\\n        vector<char> order({\\'H\\', \\'V\\'});\\n        string path = \"\";\\n        \\n        for (int i = 0; i < n; ++i) {\\n            if (!H) {\\n                --V;\\n                path.push_back(\\'V\\');\\n            }\\n            else if (!V) {\\n                --H;\\n                path.push_back(\\'H\\');\\n            }\\n            else {\\n                // if 0 placed in place i\\n                int num0 = nCk(V+H-1, max(V,H-1));\\n                // cout << k << \" \" << H << \" \" << V << \" \" << n-i-1 << \"C\" << max(H-1,V) << \" \" << num0 << endl;\\n\\n                if (num0+1 > k) {\\n                    --H;\\n                    path.push_back(order[0]);\\n                }\\n                else {\\n                    k -= num0;\\n                    --V;\\n                    path.push_back(order[1]);\\n                }\\n            }\\n        }\\n    \\n        return path;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2253721,
                "title": "combinatorics-with-linear-runtime-python",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        V, H = destination\\n        n = H + V\\n        res = \"\"\\n        for i in range(1, n+1):\\n            if H == 0 or V == 0:\\n                res += \"V\"*V + \"H\"*H\\n                break\\n                \\n            if k <= math.comb(H-1+V, H-1):\\n                res += \"H\"\\n                H -= 1\\n            else:\\n                res += \"V\"\\n                k -= math.comb(H-1+V, H-1)\\n                V -= 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        V, H = destination\\n        n = H + V\\n        res = \"\"\\n        for i in range(1, n+1):\\n            if H == 0 or V == 0:\\n                res += \"V\"*V + \"H\"*H\\n                break\\n                \\n            if k <= math.comb(H-1+V, H-1):\\n                res += \"H\"\\n                H -= 1\\n            else:\\n                res += \"V\"\\n                k -= math.comb(H-1+V, H-1)\\n                V -= 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323910,
                "title": "how-someone-clueless-at-math-solved-it",
                "content": "If you want the best, most elegant solution, this isn\\'t the post for you... Here is how my brain wandered into a solution.\\n\\nFirst I simplified the problem into it core part. What it\\'s really asking is: if you have 3 H\\'s and 2 V\\'s, what is the k\\'th arrangement of them. As long as you go down twice and to the right 3 times, it doesn\\'t matter what order you do it in. I just decided to call H\\'s 1\\'s and V\\'s 0\\'s because that made more sense to me for some reason.\\n\\nFor reference here are the 10 possible arrangement for a 2 by 3 grid:\\n```\\n11100\\n11010\\n11001\\n10110\\n10101\\n10011\\n01110\\n01101\\n01011\\n00111\\n```\\n\\nI didn\\'t know where to start, so I figured I would just write a function that returned the count of orderings for a given number of ones and zeros. For example, f(ones=3, zeros=2) = 10.\\n\\nI reasoned the base case of that function was if there are only ones OR there are only zeros - in that case the answer is obviously 1. Then I figured the left more element could either by a 1 or a 0. So logically, the total count must be the sum of those two possiblities. if the left most element is 1, (3, 2) -> (2, 2). If the left most is a zero, (3, 2) -> (3, 1). After some testing, this logic seemed sound.\\n\\n```\\n    function solve(ones, zeros) {\\n        if (ones === 0 || zeros === 0) {\\n            return 1;\\n        }\\n        return solve(ones - 1, zeros) + solve(ones, zeros - 1)\\n    }\\n```\\n\\nI didn\\'t really know what to do from here but I vaguely had a sense that this logic was leading in the right direction. I noticed that if you assume the first digit is a one, you get solve(3 - 1, 2) = 6 possible options, which matches up with the actual numbers I wrote down. \\n\\nSo I knew that if k was <= solve(2, 2) = 6, the first digit must be a 1. Else it must be a zero. You can see this by looking at example arrangements. Okayyy... If we know the first digit is a 1, now what? Well it seems like we reduced the problem down to something simpler. Let say k = 3, now we just need to find the 3rd element for 2 0\\'s and 2 1\\'s since we already figured out the first element is a 1. Lets guess that the next element is also a 1. We get solve(1, 2) = 3, which is still <= 3. So we know the next digit is also a 1! Let\\'s guess one again the next element is a 1. We get solve(0, 2) = 1. Oops 3 > 1 so the next must be a zero. Okay again. solve(0, 1) = 1 < 3. so the next element must be a zero. Okay now we have no more zeros left so the last digit must be a 1. Done!\\n\\nNow lets try for k = 8. solve(2, 2) = 6 < 8. This means the first digit must be a 0. There are only 4 possible solutions where the first digit is 0. So what we are now looking for is the 2nd (8 - 6) solution where the first digit is 0. Let try solve(2, 1) = 3. 3 <= 3 so this time we know the next digit is a 1... And we continue this logic until we are out of digits to add. \\n\\nNow we just convert 1\\'s and 0\\'s into H\\'s and V\\'s and we are done!\\n\\nI got a time limit exceeded because the solve() function was very slow. So memoization (DP) fixed that and it was solved efficiently. The time complexity was the same as computing the memoized solve() function which was O(nm). \\n\\nIf you look closely, the solve() function actually creates pascal\\'s triangle which you might note is part of other\\'s solutions. So this is the same solution as other\\'s, just a different thought process.\\n\\nFinal code:\\n\\n```\\nvar kthSmallestPath = function(destination, k) {\\n    \\n    const cache = {};\\n    function solve(ones, zeros) {\\n        if (ones === 0 || zeros === 0) {\\n            return 1;\\n        }\\n        const key = `${ones},${zeros}`;\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        const result = solve(ones - 1, zeros) + solve(ones, zeros - 1)\\n        cache[key] = result;\\n        return result\\n    }\\n    \\n    let zeros = destination[0]\\n    let ones = destination[1]\\n    const size = zeros + ones;\\n    const digits = []\\n    while (digits.length < size) {\\n        if (ones === 0) {\\n            zeros--;\\n            digits.push(0)\\n            continue;\\n        } else if (zeros === 0) {\\n            ones--;\\n            digits.push(1)\\n            continue;\\n        } \\n        \\n        const res = solve(ones - 1, zeros);\\n        if (res >= k) {\\n            ones--\\n            digits.push(1)\\n        } else {\\n            zeros--\\n            digits.push(0)\\n            k -= (res)\\n        }\\n    }\\n    return digits\\n        .map(n => n === 1 ? \\'H\\' : \\'V\\')\\n        .join(\\'\\');\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n11100\\n11010\\n11001\\n10110\\n10101\\n10011\\n01110\\n01101\\n01011\\n00111\\n```\n```\\n    function solve(ones, zeros) {\\n        if (ones === 0 || zeros === 0) {\\n            return 1;\\n        }\\n        return solve(ones - 1, zeros) + solve(ones, zeros - 1)\\n    }\\n```\n```\\nvar kthSmallestPath = function(destination, k) {\\n    \\n    const cache = {};\\n    function solve(ones, zeros) {\\n        if (ones === 0 || zeros === 0) {\\n            return 1;\\n        }\\n        const key = `${ones},${zeros}`;\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        const result = solve(ones - 1, zeros) + solve(ones, zeros - 1)\\n        cache[key] = result;\\n        return result\\n    }\\n    \\n    let zeros = destination[0]\\n    let ones = destination[1]\\n    const size = zeros + ones;\\n    const digits = []\\n    while (digits.length < size) {\\n        if (ones === 0) {\\n            zeros--;\\n            digits.push(0)\\n            continue;\\n        } else if (zeros === 0) {\\n            ones--;\\n            digits.push(1)\\n            continue;\\n        } \\n        \\n        const res = solve(ones - 1, zeros);\\n        if (res >= k) {\\n            ones--\\n            digits.push(1)\\n        } else {\\n            zeros--\\n            digits.push(0)\\n            k -= (res)\\n        }\\n    }\\n    return digits\\n        .map(n => n === 1 ? \\'H\\' : \\'V\\')\\n        .join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295247,
                "title": "java-math-solution",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int hs = destination[1];\\n        int vs = destination[0];\\n        // the destination decided how many H and how many V should in the return string\\n        return find(hs, vs, k);\\n        \\n    }\\n    \\n    private String find(int h, int v, int k) {\\n        if (h == 0) {\\n            char[] chars = new char[v];\\n            Arrays.fill(chars, \\'V\\');\\n            return new String(chars);\\n        } else if (v == 0) {\\n            char[] chars = new char[h];\\n            Arrays.fill(chars, \\'H\\');\\n            return new String(chars);\\n        }\\n        // if return has no H or V, then we can directly return it. Should have better way to generate strings.   \\n        int total = h + v;\\n        int chance = ncr(total - 1, v);\\n\\t\\t// If we have 3 H and 2 V, totally we have ncr(5,2)=10 combinations, if first one is H, then all the combination has ncr(4, 2) = 6. So if K is bigger than it, means first one should be V. otherwise first letter is H.\\n\\t\\t\\n        if (k <= chance) {\\n            return \"H\" + find(h - 1, v, k);\\n\\t\\t\\t// if we ignore the first letter, then we have 2 H and 2 V left, run the function again to find it.\\n        } else {\\n            return \"V\" + find(h, v - 1, k - chance);\\n\\t\\t\\t// if first one is V, then we need remove the ncr(4, 2) combinations of k. Since we need find the other 4 letters order.\\n        }\\n    }\\n    \\n\\t//This funciton is used to find the ncr which mentioned in the question.\\n    private int ncr(int a, int b){\\n        int count = 1;\\n        int prod = 1;\\n        while (count <= b) {\\n            prod = prod * a / count;\\n            a--;\\n            count++;\\n        }\\n        return prod;\\n    }\\n}\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int hs = destination[1];\\n        int vs = destination[0];\\n        // the destination decided how many H and how many V should in the return string\\n        return find(hs, vs, k);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1129286,
                "title": "c-solution",
                "content": "```\\nint dp[35][25];\\n    int fnd(int n, int r)\\n    {\\n        if(n<r || r<0)\\n            return 0;\\n        if(n==1 || n==r || r==0)\\n            return 1;\\n        if(dp[n][r]!=-1)\\n            return dp[n][r];\\n        return dp[n][r]=fnd(n-1,r)+fnd(n-1,r-1);\\n    }\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        string ans;\\n        memset(dp,-1,sizeof(dp));\\n        int h=d[1],v=d[0],t=h+v;\\n        while(t>0)\\n        {\\n            long hf=h<=0?1:fnd(h+v-1,v);\\n            cout<<hf<<\" \";\\n            if(k>hf)\\n            {\\n                k-=hf;\\n                ans+=v>0?\\'V\\':\\'H\\';\\n                v--;\\n            }\\n            else\\n            {\\n                ans+=h>0?\\'H\\':\\'V\\';\\n                h--;\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint dp[35][25];\\n    int fnd(int n, int r)\\n    {\\n        if(n<r || r<0)\\n            return 0;\\n        if(n==1 || n==r || r==0)\\n            return 1;\\n        if(dp[n][r]!=-1)\\n            return dp[n][r];\\n        return dp[n][r]=fnd(n-1,r)+fnd(n-1,r-1);\\n    }\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        string ans;\\n        memset(dp,-1,sizeof(dp));\\n        int h=d[1],v=d[0],t=h+v;\\n        while(t>0)\\n        {\\n            long hf=h<=0?1:fnd(h+v-1,v);\\n            cout<<hf<<\" \";\\n            if(k>hf)\\n            {\\n                k-=hf;\\n                ans+=v>0?\\'V\\':\\'H\\';\\n                v--;\\n            }\\n            else\\n            {\\n                ans+=h>0?\\'H\\':\\'V\\';\\n                h--;\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1127528,
                "title": "c-simple-solution",
                "content": "destination[0] and destination[1] denote respectively the number of \"V\" `requiredV` and that of \"H\" `requiredH` contained in the final answer.\\n\\nLet `n` be the length of the whole string (`n = requiredV + requiredH`)\\n\\nWe determine bit by bit from left to right which (\"H\" or \"V\") should be there.\\nInitially we consider the 1st bit. If the 1st bit is \"V\", then the whole string would look like `V...`. There are `nCr(n - 1, requiredV)` many strings that are \"smaller\" than the string starting with a `V` in dictionary order.\\nTherefore, if `k > nCr(n - 1, requiredV)`, we should set the 1st bit as `V`. Otherwise we set the 1st bit as `H`.\\nThen we repeat this process until the whole string is determined.\\n```\\nclass Solution {\\nprivate:\\n    int choose(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int requiredV = destination[0], requiredH = destination[1];\\n        \\n        string ans = \"\";\\n        for(int i = 1; i <= destination[0] + destination[1]; i++){\\n            int combinations = choose(requiredV + requiredH - 1, requiredV);\\n            if(k > combinations) {\\n                k -= combinations;\\n                ans += \"V\";\\n                requiredV--;\\n            }else{\\n                ans += \"H\";\\n                requiredH--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int choose(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int requiredV = destination[0], requiredH = destination[1];\\n        \\n        string ans = \"\";\\n        for(int i = 1; i <= destination[0] + destination[1]; i++){\\n            int combinations = choose(requiredV + requiredH - 1, requiredV);\\n            if(k > combinations) {\\n                k -= combinations;\\n                ans += \"V\";\\n                requiredV--;\\n            }else{\\n                ans += \"H\";\\n                requiredH--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926698,
                "title": "c-o-row-col-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    #define ll long long\\n    \\n    ll dp[31][31];\\n    \\n    void helper(int n){\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 0; j <= i; j++){\\n                if(j == 0 || j == i) dp[i][j] = 1;\\n                else dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % mod;\\n            }\\n        }\\n        return;\\n    }\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        memset(dp, 1, sizeof(dp));\\n        \\n        int h = dest[1];\\n        int v = dest[0];\\n        \\n        helper(h+v);\\n        \\n        int val = h+v;\\n        string res = \"\";\\n        \\n        for(int i = 0; i < val; i++){\\n            ll comb = dp[h+v][h];\\n            ll x = h*comb/(h+v);\\n            if(k <= h*comb/(h+v)){\\n                res += \"H\";\\n                h--;\\n            }\\n            else{\\n                res += \"V\";\\n                k -=  h*comb/(h+v);\\n                v--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    #define ll long long\\n    \\n    ll dp[31][31];\\n    \\n    void helper(int n){\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 0; j <= i; j++){\\n                if(j == 0 || j == i) dp[i][j] = 1;\\n                else dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % mod;\\n            }\\n        }\\n        return;\\n    }\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        memset(dp, 1, sizeof(dp));\\n        \\n        int h = dest[1];\\n        int v = dest[0];\\n        \\n        helper(h+v);\\n        \\n        int val = h+v;\\n        string res = \"\";\\n        \\n        for(int i = 0; i < val; i++){\\n            ll comb = dp[h+v][h];\\n            ll x = h*comb/(h+v);\\n            if(k <= h*comb/(h+v)){\\n                res += \"H\";\\n                h--;\\n            }\\n            else{\\n                res += \"V\";\\n                k -=  h*comb/(h+v);\\n                v--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918954,
                "title": "java-iterative-math-solution-in-o-n-m",
                "content": "While we haven\\'t reached the destination we need to do the following:\\nIf moving right we will have enough number of combinations (`k <= number of combinations`), then we can go right, else go down\\n\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int y = destination[0], x = destination[1];\\n        StringBuilder answer = new StringBuilder();\\n        \\n        while (x != 0 && y != 0) {\\n            int move = combinations(x + y - 1, y);\\n            \\n            if (k <= move) {\\n                answer.append(\\'H\\');\\n                x--;\\n            } else {\\n                answer.append(\\'V\\');\\n                k -= move;\\n                y--;\\n            }\\n        }\\n        \\n        while (x != 0) {\\n            answer.append(\\'H\\');\\n            x--;\\n        }\\n        \\n        while (y != 0) {\\n            answer.append(\\'V\\');\\n            y--;\\n        }\\n        \\n        return answer.toString();\\n    }\\n    \\n    private int combinations(int a, int b) {\\n        long top = 1;\\n        long bottom = 1;\\n        \\n        for (int i = b + 1; i <= a; i++) {\\n            top *= i;\\n        }\\n        \\n        for (int i = 1; i <= a - b; i++) {\\n            bottom *= i;\\n        }\\n        \\n        return (int) (top / bottom);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int y = destination[0], x = destination[1];\\n        StringBuilder answer = new StringBuilder();\\n        \\n        while (x != 0 && y != 0) {\\n            int move = combinations(x + y - 1, y);\\n            \\n            if (k <= move) {\\n                answer.append(\\'H\\');\\n                x--;\\n            } else {\\n                answer.append(\\'V\\');\\n                k -= move;\\n                y--;\\n            }\\n        }\\n        \\n        while (x != 0) {\\n            answer.append(\\'H\\');\\n            x--;\\n        }\\n        \\n        while (y != 0) {\\n            answer.append(\\'V\\');\\n            y--;\\n        }\\n        \\n        return answer.toString();\\n    }\\n    \\n    private int combinations(int a, int b) {\\n        long top = 1;\\n        long bottom = 1;\\n        \\n        for (int i = b + 1; i <= a; i++) {\\n            top *= i;\\n        }\\n        \\n        for (int i = 1; i <= a - b; i++) {\\n            bottom *= i;\\n        }\\n        \\n        return (int) (top / bottom);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918696,
                "title": "very-easy-c-dp-solution",
                "content": "First pass: calculate count of all path from (row, col) to destination\\nSecond pass: fill k-th trace using first pass calculations\\n\\n```\\n    public class Solution\\n    {\\n        private static readonly int[][] _dirs = new[]\\n        {\\n            new[] {0, 1},\\n            new[] {1, 0},\\n        };\\n\\n        private int CalculateCount(int?[,] count, int n, int m, int row, int col)\\n        {\\n            if (count[row, col].HasValue)\\n            {\\n                return count[row, col].Value;\\n            }\\n\\n            int res = 0;\\n\\n            foreach (var d in _dirs)\\n            {\\n                int newRow = row + d[0];\\n                int newCol = col + d[1];\\n\\n                if (newRow < n && newCol < m)\\n                {\\n                    res += CalculateCount(count, n, m, newRow, newCol);\\n                }\\n            }\\n\\n            count[row, col] = res;\\n            return res;\\n        }\\n\\n        private void Helper(StringBuilder res, int row, int col, int?[,] counts, int k)\\n        {\\n            int n = counts.GetLength(0);\\n            int m = counts.GetLength(1);\\n\\n            if (row == n - 1 && col == m - 1)\\n            {\\n                return;\\n            }\\n\\n            var horRow = row + _dirs[0][0];\\n            var horCol = col + _dirs[0][1];\\n\\n            var vertRow = row + _dirs[1][0];\\n            var vertCol = col + _dirs[1][1];\\n\\n            if (horRow < n && horCol < m)\\n            {\\n                if (k < counts[horRow, horCol].Value)\\n                {\\n                    res.Append(\\'H\\');\\n                    Helper(res, horRow, horCol, counts, k);\\n                }\\n                else\\n                {\\n                    res.Append(\\'V\\');\\n                    Helper(res, vertRow, vertCol, counts, k - counts[horRow, horCol].Value);\\n                }\\n            }\\n            else\\n            {\\n                res.Append(\\'V\\');\\n                Helper(res, vertRow, vertCol, counts, k);\\n            }\\n        }\\n\\n        public string KthSmallestPath(int[] destination, int k)\\n        {\\n            int n = destination[0] + 1;\\n            int m = destination[1] + 1;\\n\\n            int?[,] count = new int?[n,m];\\n            count[destination[0], destination[1]] = 1;\\n            CalculateCount(count, n, m, 0, 0);\\n            StringBuilder res = new StringBuilder();\\n            Helper(res, 0,0,count, k-1);\\n            return res.ToString();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private static readonly int[][] _dirs = new[]\\n        {\\n            new[] {0, 1},\\n            new[] {1, 0},\\n        };\\n\\n        private int CalculateCount(int?[,] count, int n, int m, int row, int col)\\n        {\\n            if (count[row, col].HasValue)\\n            {\\n                return count[row, col].Value;\\n            }\\n\\n            int res = 0;\\n\\n            foreach (var d in _dirs)\\n            {\\n                int newRow = row + d[0];\\n                int newCol = col + d[1];\\n\\n                if (newRow < n && newCol < m)\\n                {\\n                    res += CalculateCount(count, n, m, newRow, newCol);\\n                }\\n            }\\n\\n            count[row, col] = res;\\n            return res;\\n        }\\n\\n        private void Helper(StringBuilder res, int row, int col, int?[,] counts, int k)\\n        {\\n            int n = counts.GetLength(0);\\n            int m = counts.GetLength(1);\\n\\n            if (row == n - 1 && col == m - 1)\\n            {\\n                return;\\n            }\\n\\n            var horRow = row + _dirs[0][0];\\n            var horCol = col + _dirs[0][1];\\n\\n            var vertRow = row + _dirs[1][0];\\n            var vertCol = col + _dirs[1][1];\\n\\n            if (horRow < n && horCol < m)\\n            {\\n                if (k < counts[horRow, horCol].Value)\\n                {\\n                    res.Append(\\'H\\');\\n                    Helper(res, horRow, horCol, counts, k);\\n                }\\n                else\\n                {\\n                    res.Append(\\'V\\');\\n                    Helper(res, vertRow, vertCol, counts, k - counts[horRow, horCol].Value);\\n                }\\n            }\\n            else\\n            {\\n                res.Append(\\'V\\');\\n                Helper(res, vertRow, vertCol, counts, k);\\n            }\\n        }\\n\\n        public string KthSmallestPath(int[] destination, int k)\\n        {\\n            int n = destination[0] + 1;\\n            int m = destination[1] + 1;\\n\\n            int?[,] count = new int?[n,m];\\n            count[destination[0], destination[1]] = 1;\\n            CalculateCount(count, n, m, 0, 0);\\n            StringBuilder res = new StringBuilder();\\n            Helper(res, 0,0,count, k-1);\\n            return res.ToString();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918676,
                "title": "easy-understandable-dp-solution-c-o-n-m",
                "content": "```\\nint n,m;\\nint cache[20][20];\\nstring res;\\nint dp(int x,int y){\\n    int &ans = cache[x][y];\\n    if(x > n or y > m)\\n        return ans = 0;\\n    if(x == n and y == m)\\n        return ans = 1;\\n    if(ans != -1)\\n        return ans;\\n    ans = dp(x,y+1) + dp(x+1,y); \\n    return ans;\\n}\\nvoid dp1(int x,int y,int k)\\n{\\n    if(x > n or y > m)\\n        return;\\n    if(x == n and y == m)\\n        return;\\n    int &ans = cache[x][y];\\n    int l = cache[x][y+1];\\n    if(l >= k){\\n        res += \\'H\\';\\n        dp1(x,y+1,k);\\n        return;\\n    }\\n    res += \\'V\\';\\n    dp1(x+1,y,k-l);\\n}\\n\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        n = d[0];\\n        m = d[1];\\n        memset(cache,-1,sizeof(cache));\\n        dp(0,0);\\n        res = \"\";\\n        dp1(0,0,k);\\n\\n        return res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/17c1bd4c-5eaa-4b5e-b9c8-4f356767daa9_1604311353.9740295.png)\\n\\n```\\n# Destinaton = [1,2]\\n\\n# If you oberved carefully how to filled *cache* table then you can see that the imediate left node of root_node(0,0) contain value 2 that indicate  from that pos(0,1) we have 2 valid way to reach  destination_node(1,2) and lexicographical order of those instruction will be 1 and 2.\\n\\n# The imediate right node of root_node(0,0) contain value 1 that indicate  from that pos(1,0) we have 1 valid way to reach  destination_node(1,2) and lexicographical order of this instruction will be 3(as already 2 valid instruction found in left node which lexicographically smaller than this instruction).\\n\\n# l >= k means kth lexicographically smallest instruction must be present in left subtree of that node so we need to move right or horizontally and append \\'H\\' to the res\\n# Otherwise we move right subtree of that node (i.e actually move vertically or down from that position) and append \\'V\\' to the res. \\n# when we move right subtree we decrease the value of k by l because we already found l number of instruction in left subtree which lexicograpically smaller then any instruction of right subtree.\\n# So we need to actually find (k-l)th smallest instruction in right subtree.\\n\\n# lets take an example row   = 1 and col = 2 and k = 2, so we passes dp1(x = 0, y = 0, k = 2) from main.\\n# 1st, l = cache[0][1] = 2 as l >= k we move left subtree i.e. dp1(0,1,2) and res = \\'H\\'.\\n# 2nd, l = cache[0][2] = 1 as l < k so we move right subtree i.e. dp1(1,1,1) and res = \"HV\"\\n# 3rd, l = cache[1][2] = 1 as l >= k so we move left subtree i.e. dp1(1,2,1) and res = \"HVH\"\\n# 4th, as x = row and y = col so simple return and resultant instruction will be \"HVH\".\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint n,m;\\nint cache[20][20];\\nstring res;\\nint dp(int x,int y){\\n    int &ans = cache[x][y];\\n    if(x > n or y > m)\\n        return ans = 0;\\n    if(x == n and y == m)\\n        return ans = 1;\\n    if(ans != -1)\\n        return ans;\\n    ans = dp(x,y+1) + dp(x+1,y); \\n    return ans;\\n}\\nvoid dp1(int x,int y,int k)\\n{\\n    if(x > n or y > m)\\n        return;\\n    if(x == n and y == m)\\n        return;\\n    int &ans = cache[x][y];\\n    int l = cache[x][y+1];\\n    if(l >= k){\\n        res += \\'H\\';\\n        dp1(x,y+1,k);\\n        return;\\n    }\\n    res += \\'V\\';\\n    dp1(x+1,y,k-l);\\n}\\n\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        n = d[0];\\n        m = d[1];\\n        memset(cache,-1,sizeof(cache));\\n        dp(0,0);\\n        res = \"\";\\n        dp1(0,0,k);\\n\\n        return res;\\n    }\\n};\\n```\n```\\n# Destinaton = [1,2]\\n\\n# If you oberved carefully how to filled *cache* table then you can see that the imediate left node of root_node(0,0) contain value 2 that indicate  from that pos(0,1) we have 2 valid way to reach  destination_node(1,2) and lexicographical order of those instruction will be 1 and 2.\\n\\n# The imediate right node of root_node(0,0) contain value 1 that indicate  from that pos(1,0) we have 1 valid way to reach  destination_node(1,2) and lexicographical order of this instruction will be 3(as already 2 valid instruction found in left node which lexicographically smaller than this instruction).\\n\\n# l >= k means kth lexicographically smallest instruction must be present in left subtree of that node so we need to move right or horizontally and append \\'H\\' to the res\\n# Otherwise we move right subtree of that node (i.e actually move vertically or down from that position) and append \\'V\\' to the res. \\n# when we move right subtree we decrease the value of k by l because we already found l number of instruction in left subtree which lexicograpically smaller then any instruction of right subtree.\\n# So we need to actually find (k-l)th smallest instruction in right subtree.\\n\\n# lets take an example row   = 1 and col = 2 and k = 2, so we passes dp1(x = 0, y = 0, k = 2) from main.\\n# 1st, l = cache[0][1] = 2 as l >= k we move left subtree i.e. dp1(0,1,2) and res = \\'H\\'.\\n# 2nd, l = cache[0][2] = 1 as l < k so we move right subtree i.e. dp1(1,1,1) and res = \"HV\"\\n# 3rd, l = cache[1][2] = 1 as l >= k so we move left subtree i.e. dp1(1,2,1) and res = \"HVH\"\\n# 4th, as x = row and y = col so simple return and resultant instruction will be \"HVH\".\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918536,
                "title": "c-dp-binsearch-easy-to-understand",
                "content": "First build a dp array where **dp[v][h]** denotes the count of permutation given v **V**\\'s and h **H**\\'s.\\n\\nThen perform a \\'*binary search*\\'. We will decide from left to right the next char to push back into the answer. \\n\\nSuppose now we have h \\'**H** and v \\'**V**\\'\\'s. If next character is \\'**V**\\' then we are throwing away all the permutations that has \\'**H**\\' in the same location, the number of solutions is **dp[v][h-1]**. Therefore, if k is greater than **dp[v][h-1]** then the next char is **\\'V**\\', otherwise it is \\'**H**\\'.\\n\\nComlexity should be **O(V*H)** which is the cost to build the dp array.\\n\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int v = destination[0];  // num of V\\n        int h = destination[1];  // H\\n        vector<vector<int>> p(v+1, vector<int>(h+1, 0));\\n        for (int i = 0; i <= h; ++i) {\\n            p[0][i] = 1;\\n        }\\n        for (int j = 0; j <= v; ++j) {\\n            p[j][0] = 1;\\n        }\\n        for (int i = 1; i <= v; ++i) {\\n            for (int j = 1; j <= h; ++j) {\\n                p[i][j] = p[i-1][j] + p[i][j-1];\\n            }\\n        }\\n        string res = \"\";\\n        while (k > 0) {\\n            // if next char is V we will throw away p[r][c-1] solutions\\n            if (v > 0 && k > p[v][h-1]) {\\n                k -= p[v][h-1];\\n                res.push_back(\\'V\\');\\n                --v;\\n            } else {\\n                res.push_back(\\'H\\');\\n                --h;\\n            }\\n            if (v == 0 && h != 0) {\\n                res += string(h, \\'H\\');\\n                return res;\\n            } else if (h == 0 && v != 0) {\\n                res += string(v, \\'V\\');\\n                return res;\\n            } else if (h == 0 && v == 0) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int v = destination[0];  // num of V\\n        int h = destination[1];  // H\\n        vector<vector<int>> p(v+1, vector<int>(h+1, 0));\\n        for (int i = 0; i <= h; ++i) {\\n            p[0][i] = 1;\\n        }\\n        for (int j = 0; j <= v; ++j) {\\n            p[j][0] = 1;\\n        }\\n        for (int i = 1; i <= v; ++i) {\\n            for (int j = 1; j <= h; ++j) {\\n                p[i][j] = p[i-1][j] + p[i][j-1];\\n            }\\n        }\\n        string res = \"\";\\n        while (k > 0) {\\n            // if next char is V we will throw away p[r][c-1] solutions\\n            if (v > 0 && k > p[v][h-1]) {\\n                k -= p[v][h-1];\\n                res.push_back(\\'V\\');\\n                --v;\\n            } else {\\n                res.push_back(\\'H\\');\\n                --h;\\n            }\\n            if (v == 0 && h != 0) {\\n                res += string(h, \\'H\\');\\n                return res;\\n            } else if (h == 0 && v != 0) {\\n                res += string(v, \\'V\\');\\n                return res;\\n            } else if (h == 0 && v == 0) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918478,
                "title": "c-count-dp-explained",
                "content": "Count possible routes from that point to end. Run dfs, if possible routes are less than `\\'K\\'` subtract routes from `\\'K\\'` and go back.\\n\\nCount matrix when destination is (2,3) :-\\n```\\n10 6 3 1\\n 4 3 2 1\\n 1 1 1 1\\n```\\nWhat this represent is that there are 10 routes from (0, 0) , 6 routes from (0, 1) and so on.\\nDuring dfs when visit a point where number of possible routes are less than required `\\'K\\'` routes, then we mark these route visited i.e subtract those route from `\\'K\\'` and go back.\\nFor exmaple when `K=4` and we start moving from (0,0). At (0, 0) possible routes are 10 i.e greater than `K` so we move right. Same for (0, 1) but when we reach (0, 2) possible routes are 3 i.e less than `K` therefore there is no way we can choose `Kth` path if we continue this. Now we mark these 3 routes visited and subtract them from `K` and go back to (0, 1). At this point, we have already visited right so we will go down. This process will conitnue till we reach the end. \\n```\\nclass Solution {\\npublic:\\n    int x, y;\\n    string res;\\n    bool q;\\n    int cnt[16][16];\\n    void dfs(int i, int j, int& k, string &s){\\n        if (q) return;\\n        if (k>cnt[i][j]){\\n            k-=cnt[i][j];\\n            return;\\n        }\\n        if (i==x && j==y){\\n                q=true;\\n                res=s;\\n        }\\n        if (j<y){\\n            s.push_back(\\'H\\');\\n            dfs(i, j+1, k, s);\\n            s.pop_back();\\n        }\\n        if (i<x){\\n            s.push_back(\\'V\\');\\n            dfs(i+1, j, k, s);\\n            s.pop_back();\\n        }\\n        return;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        x=destination[0], y=destination[1];\\n        int tmp;\\n        for (int i=x; i>-1; --i){\\n            for (int j=y; j>-1; --j){\\n                tmp=0;\\n                if (i<15) tmp+=cnt[i+1][j];\\n                if (j<15) tmp+=cnt[i][j+1];\\n                tmp=max(1, tmp);\\n                cnt[i][j]=tmp;\\n            }\\n        }\\n        \\n        \\n        string s=\"\";\\n        q=false;\\n        dfs(0, 0, k, s);\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\n10 6 3 1\\n 4 3 2 1\\n 1 1 1 1\\n```\n```\\nclass Solution {\\npublic:\\n    int x, y;\\n    string res;\\n    bool q;\\n    int cnt[16][16];\\n    void dfs(int i, int j, int& k, string &s){\\n        if (q) return;\\n        if (k>cnt[i][j]){\\n            k-=cnt[i][j];\\n            return;\\n        }\\n        if (i==x && j==y){\\n                q=true;\\n                res=s;\\n        }\\n        if (j<y){\\n            s.push_back(\\'H\\');\\n            dfs(i, j+1, k, s);\\n            s.pop_back();\\n        }\\n        if (i<x){\\n            s.push_back(\\'V\\');\\n            dfs(i+1, j, k, s);\\n            s.pop_back();\\n        }\\n        return;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        x=destination[0], y=destination[1];\\n        int tmp;\\n        for (int i=x; i>-1; --i){\\n            for (int j=y; j>-1; --j){\\n                tmp=0;\\n                if (i<15) tmp+=cnt[i+1][j];\\n                if (j<15) tmp+=cnt[i][j+1];\\n                tmp=max(1, tmp);\\n                cnt[i][j]=tmp;\\n            }\\n        }\\n        \\n        \\n        string s=\"\";\\n        q=false;\\n        dfs(0, 0, k, s);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007090,
                "title": "java-solution-100-faster-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount Total Possible Paths using concept from unique Paths problem.\\nNow to find Kth Instruction-\\nDivide the range in the range of number of left \"H\" and \"V\" counts\\nWherever k lies add that to answer\\n\\nEg-(2,3)==>Total paths=10 horizontal moves=3, Vertical moves=2;\\nk=4;\\nDividing 1 to 10 in ratio of 3:2\\nFirst 6 paths will start with \"H\" and then rest with \"V\"\\nk<=6 therfore ans.append(\"H\");\\nnew ratio 2:2 range 1 to 6\\nFirst 3 paths will start with \"H\" and then rest with \"V\"\\nk>3 therfore ans.append(\"V\");\\nnew ration 2:1 range 4 to 6\\nRecursively we will find next moves by modifying range with left over moves.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int m=d[0]+1;\\n        int n=d[1]+1;\\n        int dp[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n          for(int j=0;j<n;j++){\\n            if(i==0 && j==0) dp[i][j]=1;\\n            else if(i==0)dp[i][j]=dp[i][j-1];\\n            else if(j==0)dp[i][j]=dp[i-1][j];\\n            else dp[i][j]=dp[i][j-1]+dp[i-1][j];\\n          }\\n        }\\n        StringBuffer sb=new StringBuffer();\\n        int lo=1,hi=dp[m-1][n-1];\\n        int h=n-1,v=m-1;\\n        while(h!=0 && v!=0){\\n          int mid=(int)(h*(((hi-lo+1)*1.0)/(h+v)));\\n          if(k<=mid+lo-1){\\n            sb.append(\"H\");\\n            hi=mid+lo-1;\\n            h--;\\n          }\\n          else{\\n            sb.append(\"V\");\\n            lo=mid+lo;\\n            v--;\\n          }\\n        }\\n        while(v-->0)sb.append(\"V\");\\n        while(h-->0)sb.append(\"H\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int m=d[0]+1;\\n        int n=d[1]+1;\\n        int dp[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n          for(int j=0;j<n;j++){\\n            if(i==0 && j==0) dp[i][j]=1;\\n            else if(i==0)dp[i][j]=dp[i][j-1];\\n            else if(j==0)dp[i][j]=dp[i-1][j];\\n            else dp[i][j]=dp[i][j-1]+dp[i-1][j];\\n          }\\n        }\\n        StringBuffer sb=new StringBuffer();\\n        int lo=1,hi=dp[m-1][n-1];\\n        int h=n-1,v=m-1;\\n        while(h!=0 && v!=0){\\n          int mid=(int)(h*(((hi-lo+1)*1.0)/(h+v)));\\n          if(k<=mid+lo-1){\\n            sb.append(\"H\");\\n            hi=mid+lo-1;\\n            h--;\\n          }\\n          else{\\n            sb.append(\"V\");\\n            lo=mid+lo;\\n            v--;\\n          }\\n        }\\n        while(v-->0)sb.append(\"V\");\\n        while(h-->0)sb.append(\"H\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997949,
                "title": "commented-easiest",
                "content": "****Here\\'s a step-by-step explanation of what\\'s happening with k -= c;:**\\n**\\nk is initially the kth smallest path we want to find.\\n\\nc is the number of combinations if we pick \\'H\\' at the current position in the string.\\n\\n\\n\\n\\nIf k is less than or equal to c, it means that the kth smallest path must include an \\'H\\' at the current position. Therefore, we append \\'H\\' to the result string s, decrement h (the count of available horizontal moves), and move to the next position.\\n\\n\\n\\n\\nIf k is greater than c, it means that the kth smallest path does not include \\'H\\' at the current position. In this case, we subtract c from k to adjust k to represent the kth smallest path among the remaining possibilities. We then append \\'V\\' to the result string s, decrement v (the count of available vertical moves), and move to the next position.\\n\\n\\n\\nThe purpose of k -= c; is to adjust the value of k based on whether we choose \\'H\\' or \\'V\\' at the current position, ensuring that we correctly find the kth smallest path as we construct the string. This process continues until we have constructed the entire string.\\n\\n# Code\\n```\\n\\n// Time complexity analysis:\\n// The code uses a combination formula to determine the number of ways to choose \\'H\\' or \\'V\\'\\n// at each position in the resulting string. It iterates through the entire string and makes\\n// a decision at each step based on the value of \\'k\\'. The maximum length of the resulting\\n// string is \\'H + V\\'. So, the time complexity is O((H + V)^2).\\n\\n// Space complexity analysis:\\n// The code uses only a constant amount of extra space to store variables like \\'ans\\', \\'s\\', \\'h\\', \\'v\\',\\n// \\'N\\', \\'i\\', \\'c\\', and \\'k\\'. Therefore, the space complexity is O(1).\\n\\nclass Solution {\\n    // Function to calculate the combination of \\'n\\' choose \\'r\\'.\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    // Function to find the kth smallest path.\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        \\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // If we have H available to pick.\\n                int c = comb(h - 1 + v, v); // Calculate the number of combinations if we pick H at this position.\\n                if (k <= c) { // If k is covered within \\'c\\', pick H.\\n                    s += \\'H\\';\\n                    --h;\\n                } else { // Otherwise, pick V and adjust k.\\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } \\n            \\n            else { // If no H left, have to pick V.\\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// Time complexity analysis:\\n// The code uses a combination formula to determine the number of ways to choose \\'H\\' or \\'V\\'\\n// at each position in the resulting string. It iterates through the entire string and makes\\n// a decision at each step based on the value of \\'k\\'. The maximum length of the resulting\\n// string is \\'H + V\\'. So, the time complexity is O((H + V)^2).\\n\\n// Space complexity analysis:\\n// The code uses only a constant amount of extra space to store variables like \\'ans\\', \\'s\\', \\'h\\', \\'v\\',\\n// \\'N\\', \\'i\\', \\'c\\', and \\'k\\'. Therefore, the space complexity is O(1).\\n\\nclass Solution {\\n    // Function to calculate the combination of \\'n\\' choose \\'r\\'.\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    // Function to find the kth smallest path.\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        \\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // If we have H available to pick.\\n                int c = comb(h - 1 + v, v); // Calculate the number of combinations if we pick H at this position.\\n                if (k <= c) { // If k is covered within \\'c\\', pick H.\\n                    s += \\'H\\';\\n                    --h;\\n                } else { // Otherwise, pick V and adjust k.\\n                    k -= c;\\n                    s += \\'V\\';\\n                    --v;\\n                }\\n            } \\n            \\n            else { // If no H left, have to pick V.\\n                s += \\'V\\';\\n                --v;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974286,
                "title": "beats-100-users-simplest-o-15-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nat every index we need to check that can we place a H or V\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlet say at ith index you place a \\'H\\' then calculate that how many permutations left, if its greater than k it means you can place \\'H\\' there else you will place \\'V\\' here and will reduce k \\nfor more calrity refer my code then you will get a better understanding\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(15)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(15)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long ncr(int h,int v,int k){\\n        if(h<1) return 1;\\n        long long ans=1;\\n        for(int i=h+v;i>max(h,v);i--) ans*=i;\\n        for(int i=min(h,v);i>0;i--) ans/=i;\\n        return ans;\\n    }\\n\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        string ans;\\n        while(v+h>0){\\n            long long res=ncr(h-1,v,k);\\n            if(res>=k and h) ans+=\\'H\\',h--;\\n            else{\\n                ans+=\\'V\\';\\n                v--;\\n                k-=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long ncr(int h,int v,int k){\\n        if(h<1) return 1;\\n        long long ans=1;\\n        for(int i=h+v;i>max(h,v);i--) ans*=i;\\n        for(int i=min(h,v);i>0;i--) ans/=i;\\n        return ans;\\n    }\\n\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        string ans;\\n        while(v+h>0){\\n            long long res=ncr(h-1,v,k);\\n            if(res>=k and h) ans+=\\'H\\',h--;\\n            else{\\n                ans+=\\'V\\';\\n                v--;\\n                k-=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864114,
                "title": "python-combinatorial-solution-beats-95-10-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPython combinatorial search. Beats 97%. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive combinatorial search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(destination[0] + destination[1])\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(destination[0] + destination[1]) \\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def kthSmallestPath(self, destination: list[int], k: int) -> str:\\n        def choose(n, k):\\n            return math.factorial(n) / (math.factorial(n-k)*math.factorial(k))\\n        def helper(n, k, rank) -> str:\\n            if k == 0:\\n                return \\'H\\' * n\\n            elif n == k:\\n                return \\'V\\' * n\\n            if rank <= choose(n-1, k):\\n                # we know path must start with a 0 (\\'H\\')\\n                return \\'H\\' + helper(n-1, k, rank)\\n            else:\\n                # we know path must start with a 1 (\\'V\\')\\n                return \\'V\\' + helper(n-1, k-1, rank - choose(n-1, k))\\n        return helper(destination[0]+destination[1], destination[0], k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def kthSmallestPath(self, destination: list[int], k: int) -> str:\\n        def choose(n, k):\\n            return math.factorial(n) / (math.factorial(n-k)*math.factorial(k))\\n        def helper(n, k, rank) -> str:\\n            if k == 0:\\n                return \\'H\\' * n\\n            elif n == k:\\n                return \\'V\\' * n\\n            if rank <= choose(n-1, k):\\n                # we know path must start with a 0 (\\'H\\')\\n                return \\'H\\' + helper(n-1, k, rank)\\n            else:\\n                # we know path must start with a 1 (\\'V\\')\\n                return \\'V\\' + helper(n-1, k-1, rank - choose(n-1, k))\\n        return helper(destination[0]+destination[1], destination[0], k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853187,
                "title": "good-combinatorics-problem-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne of the best ways to solve a search space sometimes is to DFS. This is one of those times thanks to the fact that Bob is picky. Because Bob is picky, we can use that to prune the dfs space as we go along, thus providing a way to quickly and readily match up and eliminate possible dead ends quickly. \\n\\nThis is mainly due to the fact that Bob\\'s pickiness allows us to use a combinatorial calculation to determine WHEN we add a \\'V\\' to our path string, rather than trying to find WHERE in the graph we should do so; this reduces our search space complexity greatly at the cost of combinatorial calculations. Luckily, nice people out there have done n choose k for a quite large range, so calculating that is of less concern. \\n\\nWith that in hand, we merely need to stay in our bounded space of k, moves horizontal and moves vertical and we can get to an answer that uses up Bob\\'s exhaustive nature. Then we can simply concat the remaining in lexicographically smallest order and it\\'s solved. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReduce K by 1 for off by 1 indexing (annoying monopoly rule people) \\n\\nGet change in rows and change in columns as the value of destination unpacked \\n\\nSet an empty path string \\n\\n- While you have k, dr, and dc greater than 0 \\n    - get directional options - 1 choose horizontal options minus 1 \\n    - if this value is lte k\\n        - we can afford a V \\n        - So, add a V to the path string \\n        - reduce our number of vertical options \\n        - and reduce our value of k by the combinatorial value \\n    - otherwise, we can\\'t afford a V \\n        - add an H to the path string and reduce our number of horizontal options \\n\\nWhen done, bob still may not have arrived. \\nSo, to keep it lexicographically smallest \\n- If you still have dc options gt 0 \\n    - add H dc times to the path string \\n- If you still have dr options gt 0 \\n    - add V dr times to the path string \\n\\nNow we know Bob has made it, send him his path string that he\\'ll be OK with       \\n\\n\\n# Complexity\\n- Time complexity : O(N ^ 2)\\n    - O(N) for math combinations it turns out \\n    - Gotta do that at least N times as well to make up for search space at the worst (if Bob was not, in fact, actually that picky)\\n    - At worst O(N * N) or O(N^2), where N is size of grid space  \\n\\n- Space complexity : O(P) \\n    - O(P) have to store the path string of size P \\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str :\\n        # off by 1 indexing \\n        k-=1\\n        # get destination row and column \\n        dr, dc = destination\\n        # set up path string \\n        path_string = \"\" \\n        # while you still have moves to make, and have not reached the goal \\n        while k and dr and dc : \\n            # evaluates n choose k, in this case n is directional space of dr + dc - 1 \\n            # and k is choosing space of only dc - 1 \\n            # remember dc, change in cols, is horizontal! \\n            current_combination_value = math.comb(dr+dc - 1, dc - 1) \\n            # if the value produced is lte k \\n            if current_combination_value <= k : \\n                # we can afford a \\'V\\' here, which is a large value lexicographically \\n                path_string += \"V\"\\n                # we\\'ve used up a vertical directional movement, a change in rows \\n                dr -= 1 \\n                # so, we also need to lower k by this combination value\\n                # this is equivalent to cutting off any future V\\'s of at most this value as well \\n                k -= current_combination_value\\n            else : \\n                # otherwise, we should just add an h and decrement our horizontal option space\\n                path_string += \"H\" \\n                dc -= 1 \\n        # when done with above, path string still may not be fully built. To ensure it \\n        # if we have any horizontal components left \\n        if (dc > 0) :\\n            path_string = path_string + \"H\" * dc\\n        # then if we have any vertical components left \\n        if (dr > 0) : \\n            path_string = path_string + \"V\" * dr\\n        # now we\\'re all set \\n        return path_string\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str :\\n        # off by 1 indexing \\n        k-=1\\n        # get destination row and column \\n        dr, dc = destination\\n        # set up path string \\n        path_string = \"\" \\n        # while you still have moves to make, and have not reached the goal \\n        while k and dr and dc : \\n            # evaluates n choose k, in this case n is directional space of dr + dc - 1 \\n            # and k is choosing space of only dc - 1 \\n            # remember dc, change in cols, is horizontal! \\n            current_combination_value = math.comb(dr+dc - 1, dc - 1) \\n            # if the value produced is lte k \\n            if current_combination_value <= k : \\n                # we can afford a \\'V\\' here, which is a large value lexicographically \\n                path_string += \"V\"\\n                # we\\'ve used up a vertical directional movement, a change in rows \\n                dr -= 1 \\n                # so, we also need to lower k by this combination value\\n                # this is equivalent to cutting off any future V\\'s of at most this value as well \\n                k -= current_combination_value\\n            else : \\n                # otherwise, we should just add an h and decrement our horizontal option space\\n                path_string += \"H\" \\n                dc -= 1 \\n        # when done with above, path string still may not be fully built. To ensure it \\n        # if we have any horizontal components left \\n        if (dc > 0) :\\n            path_string = path_string + \"H\" * dc\\n        # then if we have any vertical components left \\n        if (dr > 0) : \\n            path_string = path_string + \"V\" * dr\\n        # now we\\'re all set \\n        return path_string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827669,
                "title": "c-beat-100",
                "content": "```\\npublic class Solution {\\n    int[,] nCr;\\n    public string KthSmallestPath(int[] destination, int k) {\\n        StringBuilder res=new StringBuilder();\\n        int n=destination[0];int m=destination[1];\\n        nCr=new int[n+m+1,n+1];\\n        \\n        int distance=destination[0]+destination[1];\\n        int[] curr_loc=new int[2]{0,0};\\n        \\n        for(int i=0;i<distance;i++){\\n            long c=C(distance-i-1,destination[0]-curr_loc[0]) ;   \\n            if(k>c){\\n                res.Append(\"V\");\\n                curr_loc[0]++;\\n                k=k-(int)c;\\n            }\\n            else{\\n                res.Append(\"H\");\\n                curr_loc[1]++;\\n            }\\n            \\n        }\\n        \\n        return res.ToString();\\n    }\\n    \\n    public int C(int n, int r){\\n        if(r==0 || r==n)\\n            return 1;\\n        \\n        if(r>n)\\n            return 0;\\n        if(nCr[n,r]>0)\\n            return nCr[n,r];\\n        \\n        nCr[n,r]= C(n-1,r)+C(n-1,r-1);\\n        return nCr[n,r];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\npublic class Solution {\\n    int[,] nCr;\\n    public string KthSmallestPath(int[] destination, int k) {\\n        StringBuilder res=new StringBuilder();\\n        int n=destination[0];int m=destination[1];\\n        nCr=new int[n+m+1,n+1];\\n        \\n        int distance=destination[0]+destination[1];\\n        int[] curr_loc=new int[2]{0,0};\\n        \\n        for(int i=0;i<distance;i++){\\n            long c=C(distance-i-1,destination[0]-curr_loc[0]) ;   \\n            if(k>c){\\n                res.Append(\"V\");\\n                curr_loc[0]++;\\n                k=k-(int)c;\\n            }\\n            else{\\n                res.Append(\"H\");\\n                curr_loc[1]++;\\n            }\\n            \\n        }\\n        \\n        return res.ToString();\\n    }\\n    \\n    public int C(int n, int r){\\n        if(r==0 || r==n)\\n            return 1;\\n        \\n        if(r>n)\\n            return 0;\\n        if(nCr[n,r]>0)\\n            return nCr[n,r];\\n        \\n        nCr[n,r]= C(n-1,r)+C(n-1,r-1);\\n        return nCr[n,r];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803332,
                "title": "swift-using-combinatorics-beat-100",
                "content": "My only proud in this awful code is that I managed to solve this problem without looking into any hints.\\n\\n# Code\\n```\\nclass Solution {\\n    func kthSmallestPath(_ destination: [Int], _ k: Int) -> String {\\n        var rows = destination[0] // V\\n        var columns = destination[1] // H\\n        var chars: [Character] = []\\n        var leftK = k\\n        while leftK >= 1, rows > 0, columns > 0 {\\n            let (shifts, newK) = shifts(rows, leftK)\\n            chars.append(contentsOf: Array(repeating: \"H\", count: columns-shifts))\\n            chars.append(\"V\")\\n            rows -= 1\\n            columns = shifts\\n            leftK = newK\\n        }\\n        chars.append(contentsOf: Array(repeating: \"H\", count: columns))\\n        chars.append(contentsOf: Array(repeating: \"V\", count: rows))\\n        return String(chars)\\n    }\\n    \\n    private func shifts(_ rows: Int, _ k: Int) -> (Int, Int) {\\n        if k == 1 { return (0, 0) }\\n        var shift = 0\\n        var totalLetters = rows\\n        var totalCombinations = 1\\n        var prevTotalCombinations = 1\\n        while k > totalCombinations {\\n            prevTotalCombinations = totalCombinations\\n            if totalLetters == rows {\\n                totalCombinations = 1\\n            } else {\\n                totalCombinations *= totalLetters // had to optimize the code to pass cases with large numbers\\n                totalCombinations /= (totalLetters-rows)\\n            }\\n            shift += 1\\n            totalLetters += 1\\n        }\\n        return (shift-1, k - prevTotalCombinations)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    func kthSmallestPath(_ destination: [Int], _ k: Int) -> String {\\n        var rows = destination[0] // V\\n        var columns = destination[1] // H\\n        var chars: [Character] = []\\n        var leftK = k\\n        while leftK >= 1, rows > 0, columns > 0 {\\n            let (shifts, newK) = shifts(rows, leftK)\\n            chars.append(contentsOf: Array(repeating: \"H\", count: columns-shifts))\\n            chars.append(\"V\")\\n            rows -= 1\\n            columns = shifts\\n            leftK = newK\\n        }\\n        chars.append(contentsOf: Array(repeating: \"H\", count: columns))\\n        chars.append(contentsOf: Array(repeating: \"V\", count: rows))\\n        return String(chars)\\n    }\\n    \\n    private func shifts(_ rows: Int, _ k: Int) -> (Int, Int) {\\n        if k == 1 { return (0, 0) }\\n        var shift = 0\\n        var totalLetters = rows\\n        var totalCombinations = 1\\n        var prevTotalCombinations = 1\\n        while k > totalCombinations {\\n            prevTotalCombinations = totalCombinations\\n            if totalLetters == rows {\\n                totalCombinations = 1\\n            } else {\\n                totalCombinations *= totalLetters // had to optimize the code to pass cases with large numbers\\n                totalCombinations /= (totalLetters-rows)\\n            }\\n            shift += 1\\n            totalLetters += 1\\n        }\\n        return (shift-1, k - prevTotalCombinations)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788838,
                "title": "is-k-small-enough-to-insert-symbol-h-at-the-end-of-the-string",
                "content": "# Intuition\\nWe iteratively add symbols from the the beggining of the string to its end. What we can do is to think of when the first symbol is \"H\" and when it is \\'V\\'. In fact if k is \"too large\" then it\\'s \\'V\\'. In fact too large means it\\'s larger then (n choose h-1) where n is the length of the string and h is the number of \"H\" in it. So if it\\'s smaller we return \\'H\\' + kthSmallestPath((v,h-1), k). otherwise we insert V and change k: k = k - (n choose h-1)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import factorial\\nclass Solution:\\n    def perm(self, destination) -> int:\\n        return factorial(destination[1]+destination[0]) // factorial(destination[0]) // factorial(destination[1])\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        if k==0:\\n            return \\'H\\' * destination[1] + \\'V\\' * destination[0]\\n        if destination[1]==0:\\n            return \\'V\\' * destination[0]\\n        ans = \\'\\' \\n        while k-1>=self.perm((destination[0], destination[1]-1)) and destination[0]>0:\\n            k = k - self.perm((destination[0], destination[1]-1))\\n            destination = destination[0]-1, destination[1]\\n            ans = ans + \\'V\\'\\n        if destination[0]==0:\\n            return ans + \\'H\\' * destination[1]\\n        if k-1<self.perm((destination[0], destination[1]-1)):\\n            return ans + \\'H\\' + self.kthSmallestPath((destination[0], destination[1]-1), k)\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import factorial\\nclass Solution:\\n    def perm(self, destination) -> int:\\n        return factorial(destination[1]+destination[0]) // factorial(destination[0]) // factorial(destination[1])\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        if k==0:\\n            return \\'H\\' * destination[1] + \\'V\\' * destination[0]\\n        if destination[1]==0:\\n            return \\'V\\' * destination[0]\\n        ans = \\'\\' \\n        while k-1>=self.perm((destination[0], destination[1]-1)) and destination[0]>0:\\n            k = k - self.perm((destination[0], destination[1]-1))\\n            destination = destination[0]-1, destination[1]\\n            ans = ans + \\'V\\'\\n        if destination[0]==0:\\n            return ans + \\'H\\' * destination[1]\\n        if k-1<self.perm((destination[0], destination[1]-1)):\\n            return ans + \\'H\\' + self.kthSmallestPath((destination[0], destination[1]-1), k)\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725596,
                "title": "optimal-greedy-combinatorics-o-r-c-logmod-time",
                "content": "# Intuition\\n1. try to place \\'a\\' at i\\'th position, now there are (aCount - 1) and bCount characters can be put after i\\'th position, count all ways to do it. that is: (aCount + bCount - 1)! / [(aCount-1)*bCount]. The intution if after putting \\'a\\' if we are able to generate atleat k different strings then it is optimal to put \\'a\\'.\\n2. if it is >=k then we put \\'a\\' at i\\'th index\\n3. otherwise we put \\'b\\' and subract the ways from k.\\n\\n# Complexity\\n- Time complexity:\\nO((R+C)logMOD), MOD = 10^9 + 7\\n\\n- Space complexity:\\nO(R+C)\\n\\n# Code\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int a = destination[1];\\n        int b = destination[0];\\n        int sum = a + b;\\n        long[] fact = new long[sum+1];\\n        long[] invFact = new long[sum+1];\\n        fact[0] = invFact[0] = 1;\\n        for(int i=1;i<=sum;i++){\\n            fact[i] = i*fact[i-1];\\n            fact[i]%=mod;\\n            invFact[i] = _pow(fact[i],mod-2);\\n        }\\n    \\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0;i<sum;i++){\\n            if(a == 0){\\n                ans.append(\\'V\\');\\n                b--;\\n                continue;\\n            }\\n            if(b == 0){\\n                ans.append(\\'H\\');\\n                a--;\\n                continue;\\n            }\\n            long next = ((fact[a+b-1] * invFact[a-1] % mod )*invFact[b]%mod);\\n            if(next >= k){\\n                ans.append(\\'H\\');\\n                a--;\\n            }else {\\n                ans.append(\\'V\\');\\n                k-=next;\\n                b--;\\n            }\\n        }\\n        return ans.toString();\\n\\n    }\\n    long mod = (int)1e9 + 7;\\n    private long _pow(long x, long n){\\n        long ans = 1;\\n        while(n > 0){\\n            if(n%2==1){\\n                ans *=x;\\n                n--;\\n            }else {\\n                x*=x;\\n                n>>=1;\\n            }\\n            x%=mod;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int a = destination[1];\\n        int b = destination[0];\\n        int sum = a + b;\\n        long[] fact = new long[sum+1];\\n        long[] invFact = new long[sum+1];\\n        fact[0] = invFact[0] = 1;\\n        for(int i=1;i<=sum;i++){\\n            fact[i] = i*fact[i-1];\\n            fact[i]%=mod;\\n            invFact[i] = _pow(fact[i],mod-2);\\n        }\\n    \\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0;i<sum;i++){\\n            if(a == 0){\\n                ans.append(\\'V\\');\\n                b--;\\n                continue;\\n            }\\n            if(b == 0){\\n                ans.append(\\'H\\');\\n                a--;\\n                continue;\\n            }\\n            long next = ((fact[a+b-1] * invFact[a-1] % mod )*invFact[b]%mod);\\n            if(next >= k){\\n                ans.append(\\'H\\');\\n                a--;\\n            }else {\\n                ans.append(\\'V\\');\\n                k-=next;\\n                b--;\\n            }\\n        }\\n        return ans.toString();\\n\\n    }\\n    long mod = (int)1e9 + 7;\\n    private long _pow(long x, long n){\\n        long ans = 1;\\n        while(n > 0){\\n            if(n%2==1){\\n                ans *=x;\\n                n--;\\n            }else {\\n                x*=x;\\n                n>>=1;\\n            }\\n            x%=mod;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664146,
                "title": "runtime-only-1ms-and-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int comb(int n, int r) {\\n        int ans = 1;\\n        for (int i = 1; i <= r; i++) {\\n            ans = ans * (n - i + 1) / i;\\n        }\\n        return ans;\\n    }\\n\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder ans = new StringBuilder();\\n        int y = destination[0];\\n        int x = destination[1];\\n        int n = x + y;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (x > 0) {\\n                int c = comb(x + y - 1, x - 1);\\n                if (k <= c) {\\n                    ans.append(\\'H\\');\\n                    x--;\\n                } else {\\n                    ans.append(\\'V\\');\\n                    y--;\\n                    k -= c;\\n                }\\n            } else {\\n                ans.append(\\'V\\');\\n                y--;\\n            }\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int comb(int n, int r) {\\n        int ans = 1;\\n        for (int i = 1; i <= r; i++) {\\n            ans = ans * (n - i + 1) / i;\\n        }\\n        return ans;\\n    }\\n\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder ans = new StringBuilder();\\n        int y = destination[0];\\n        int x = destination[1];\\n        int n = x + y;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (x > 0) {\\n                int c = comb(x + y - 1, x - 1);\\n                if (k <= c) {\\n                    ans.append(\\'H\\');\\n                    x--;\\n                } else {\\n                    ans.append(\\'V\\');\\n                    y--;\\n                    k -= c;\\n                }\\n            } else {\\n                ans.append(\\'V\\');\\n                y--;\\n            }\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639684,
                "title": "o-n-2-time-complexity-solution-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public static String kthSmallestPath(int[] destination, int k) {\\n        int rows = destination[0] + 1;\\n        int cols = destination[1] + 1;\\n\\n        int[][] dp = new int[rows][cols];\\n\\n        // Calculate the number of possible paths for each cell\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (i == 0 || j == 0) {\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int remainingH = cols - 1;  // Number of remaining horizontal moves\\n        int remainingV = rows - 1;  // Number of remaining vertical moves\\n\\n        for (int i = 0; i < rows + cols - 2; i++) {\\n            if (remainingH > 0 && dp[remainingV][remainingH - 1] >= k) {\\n                sb.append(\"H\");\\n                remainingH--;\\n            } else {\\n                sb.append(\"V\");\\n                if (remainingH > 0) {\\n                    k -= dp[remainingV][remainingH - 1];\\n                }\\n                remainingV--;\\n            }\\n        }\\n\\n        return sb.toString();\\n    \\n    }\\n    /*\\n    private static void backtrack(List<String> paths, String currentPath, int row, int col, int rows, int columns) {\\n        if (row == rows - 1 && col == columns - 1) {\\n            paths.add(currentPath);\\n            return;\\n        }\\n\\n        if (row < rows - 1) {\\n            backtrack(paths, currentPath + \"V\", row + 1, col, rows, columns);\\n        }\\n\\n        if (col < columns - 1) {\\n            backtrack(paths, currentPath + \"H\", row, col + 1, rows, columns);\\n        }\\n    }*/\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static String kthSmallestPath(int[] destination, int k) {\\n        int rows = destination[0] + 1;\\n        int cols = destination[1] + 1;\\n\\n        int[][] dp = new int[rows][cols];\\n\\n        // Calculate the number of possible paths for each cell\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (i == 0 || j == 0) {\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        int remainingH = cols - 1;  // Number of remaining horizontal moves\\n        int remainingV = rows - 1;  // Number of remaining vertical moves\\n\\n        for (int i = 0; i < rows + cols - 2; i++) {\\n            if (remainingH > 0 && dp[remainingV][remainingH - 1] >= k) {\\n                sb.append(\"H\");\\n                remainingH--;\\n            } else {\\n                sb.append(\"V\");\\n                if (remainingH > 0) {\\n                    k -= dp[remainingV][remainingH - 1];\\n                }\\n                remainingV--;\\n            }\\n        }\\n\\n        return sb.toString();\\n    \\n    }\\n    /*\\n    private static void backtrack(List<String> paths, String currentPath, int row, int col, int rows, int columns) {\\n        if (row == rows - 1 && col == columns - 1) {\\n            paths.add(currentPath);\\n            return;\\n        }\\n\\n        if (row < rows - 1) {\\n            backtrack(paths, currentPath + \"V\", row + 1, col, rows, columns);\\n        }\\n\\n        if (col < columns - 1) {\\n            backtrack(paths, currentPath + \"H\", row, col + 1, rows, columns);\\n        }\\n    }*/\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378929,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\n    LL combination(int n, int m)\\n    {        \\n        LL ret = 1;\\n        if(n == m || m == 0)\\n            return 1 ;\\n        for(int i = 0; i < m; i++){\\n            ret *= n - i;\\n            ret /= (i + 1);\\n        }\\n        return ret;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int V = destination[0] ;\\n        int H = destination[1] ;\\n        int n = V + H ;\\n        string ret ;\\n        for(int i = 0; i < n; i++){\\n            if(H == 0){\\n                while(V){\\n                    ret.push_back(\\'V\\') ;\\n                    V-- ;\\n                }\\n                break ;\\n            }    \\n            if(V == 0){\\n                while(H){\\n                    ret.push_back(\\'H\\') ;\\n                    H-- ;\\n                }\\n                break ;\\n            }\\n            LL sum = combination(H-1 + V, V) ;\\n            if(k <= sum){\\n                ret.push_back(\\'H\\') ;\\n                H-- ;\\n            }\\n            else{\\n                k -= sum;  //important \\n                ret.push_back(\\'V\\') ;\\n                V-- ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\n    LL combination(int n, int m)\\n    {        \\n        LL ret = 1;\\n        if(n == m || m == 0)\\n            return 1 ;\\n        for(int i = 0; i < m; i++){\\n            ret *= n - i;\\n            ret /= (i + 1);\\n        }\\n        return ret;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int V = destination[0] ;\\n        int H = destination[1] ;\\n        int n = V + H ;\\n        string ret ;\\n        for(int i = 0; i < n; i++){\\n            if(H == 0){\\n                while(V){\\n                    ret.push_back(\\'V\\') ;\\n                    V-- ;\\n                }\\n                break ;\\n            }    \\n            if(V == 0){\\n                while(H){\\n                    ret.push_back(\\'H\\') ;\\n                    H-- ;\\n                }\\n                break ;\\n            }\\n            LL sum = combination(H-1 + V, V) ;\\n            if(k <= sum){\\n                ret.push_back(\\'H\\') ;\\n                H-- ;\\n            }\\n            else{\\n                k -= sum;  //important \\n                ret.push_back(\\'V\\') ;\\n                V-- ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331607,
                "title": "c-simple-explanation",
                "content": "1. It\\'s like performing a binary search. Let\\'s represent V as 1 and H as 0. The number of values starting with 0 is C(4, 2), since there are four digits left and we need to choose two of them to be 1\\'s.\\nThere are 6 combinations ranging from 0**0011** to 0**1100**.\\n\\n            k     number \\n            1    0 0 0 1 1\\n            2    0 0 1 0 1\\n            3    0 0 1 1 0\\n            4    0 1 0 0 1\\n            5    0 1 0 1 0\\n            6    0 1 1 0 0\\n\\n            7    1 0 0 0 1\\n            8    1 0 0 1 0\\n            9    1 0 1 0 0\\n            10   1 1 0 0 0\\n2. If k is larger than 6, the first digit must be 1, otherwise, 0.\\n3. Determine whether each digit should be 0 or 1 from left to right.\\n3. If there are no 1s left, then the remaining digits should all be 0s.\\n4. If the number of remaining places minus one is less than the remaining 1s, then the remaining places should be all 1s because there is no place to set the leftmost digit to 0.\\n5. To Compute the combination count C(a, b), we can use the following method, and the result of each step is grantee to be an integer (evenly divisible):\\nanswer = 1\\nanswer = answer * (a - b + 1) / 1\\nanswer = answer * (a - b + 2) / 2\\n...\\nFor example: C(30, 15)\\nanswer = answer * 16 / 1\\nanswer = answer * 17 / 2\\n...\\nSimple proof:\\n    1. Combination count C(a, b) is always an integer (no proof is provided here).\\n    2. At each step, we are simply computing a subset combination count, which is grantee to be an integer.\\n        step1: C(16, 1) = 16 / 1!\\n        step2: C(17, 2) = 17 * 16 / 2!\\n        ...\\n        step15: C(30, 15) = 30 * 29 ... * 16 / 15!\\n        ```\\n        16 17 18 19 ... 30\\n        1  2  3  4 ...  15  \\n        ```\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public string KthSmallestPath(int[] destination, int k)\\n    {\\n        int vCount = destination[0];\\n        int hCount = destination[1];\\n        int totalCount = vCount + hCount;\\n        int indexCountNow = 0;\\n        int remainingVCount = vCount;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < totalCount; ++i)\\n        {\\n            if (remainingVCount <= 0)\\n            {\\n                int remainingHCount = totalCount - i;\\n                for (int whichH = 0; whichH < remainingHCount; ++whichH)\\n                {\\n                    sb.Append(\\'H\\');\\n                }\\n                break;\\n            }\\n\\n            int remainingN = totalCount - 1 - i;\\n            if (remainingN < remainingVCount)\\n            {\\n                for (int whilchV = 0; whilchV < remainingVCount; ++whilchV)\\n                {\\n                    sb.Append(\\'V\\');\\n                }\\n                break;\\n            }\\n\\n            int partitionCount = CombinationCount(remainingN, remainingVCount);\\n            indexCountNow += partitionCount;\\n\\n            if (k <= indexCountNow)\\n            {\\n                sb.Append(\\'H\\');\\n                indexCountNow -= partitionCount;\\n            }\\n            else\\n            {\\n                sb.Append(\\'V\\');\\n                --remainingVCount;\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n\\n    private int CombinationCount(int a, int b)\\n    {\\n        long answer = 1;\\n\\n        for (int i = 1; i <= b; ++i)\\n        {\\n            answer *= (a - b + i);\\n            answer /= i;\\n        }\\n\\n        return (int)answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        16 17 18 19 ... 30\\n        1  2  3  4 ...  15  \\n        ```\n```\\npublic class Solution {\\n    public string KthSmallestPath(int[] destination, int k)\\n    {\\n        int vCount = destination[0];\\n        int hCount = destination[1];\\n        int totalCount = vCount + hCount;\\n        int indexCountNow = 0;\\n        int remainingVCount = vCount;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < totalCount; ++i)\\n        {\\n            if (remainingVCount <= 0)\\n            {\\n                int remainingHCount = totalCount - i;\\n                for (int whichH = 0; whichH < remainingHCount; ++whichH)\\n                {\\n                    sb.Append(\\'H\\');\\n                }\\n                break;\\n            }\\n\\n            int remainingN = totalCount - 1 - i;\\n            if (remainingN < remainingVCount)\\n            {\\n                for (int whilchV = 0; whilchV < remainingVCount; ++whilchV)\\n                {\\n                    sb.Append(\\'V\\');\\n                }\\n                break;\\n            }\\n\\n            int partitionCount = CombinationCount(remainingN, remainingVCount);\\n            indexCountNow += partitionCount;\\n\\n            if (k <= indexCountNow)\\n            {\\n                sb.Append(\\'H\\');\\n                indexCountNow -= partitionCount;\\n            }\\n            else\\n            {\\n                sb.Append(\\'V\\');\\n                --remainingVCount;\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n\\n    private int CombinationCount(int a, int b)\\n    {\\n        long answer = 1;\\n\\n        for (int i = 1; i <= b; ++i)\\n        {\\n            answer *= (a - b + i);\\n            answer /= i;\\n        }\\n\\n        return (int)answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183406,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        fn c(n: usize, k: usize) -> usize {\\n            let mut ans = 1;\\n            for i in 0..k {\\n                ans = ans * (n - i) / (i + 1);\\n            }\\n            ans\\n        }\\n\\n        let (mut row, mut col) = (destination[0] as usize, destination[1] as usize);\\n        let mut k = k as usize;\\n        let mut ans = String::new();\\n        while row > 0 || col > 0 {\\n            if row == 0 {\\n                ans.push(\\'H\\');\\n                col -= 1;\\n            } else if col == 0 {\\n                ans.push(\\'V\\');\\n                row -= 1;\\n            } else {\\n                let n = c(row + col - 1, col - 1);\\n                if k <= n {\\n                    ans.push(\\'H\\');\\n                    col -= 1;\\n                } else {\\n                    ans.push(\\'V\\');\\n                    row -= 1;\\n                    k -= n;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        fn c(n: usize, k: usize) -> usize {\\n            let mut ans = 1;\\n            for i in 0..k {\\n                ans = ans * (n - i) / (i + 1);\\n            }\\n            ans\\n        }\\n\\n        let (mut row, mut col) = (destination[0] as usize, destination[1] as usize);\\n        let mut k = k as usize;\\n        let mut ans = String::new();\\n        while row > 0 || col > 0 {\\n            if row == 0 {\\n                ans.push(\\'H\\');\\n                col -= 1;\\n            } else if col == 0 {\\n                ans.push(\\'V\\');\\n                row -= 1;\\n            } else {\\n                let n = c(row + col - 1, col - 1);\\n                if k <= n {\\n                    ans.push(\\'H\\');\\n                    col -= 1;\\n                } else {\\n                    ans.push(\\'V\\');\\n                    row -= 1;\\n                    k -= n;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3117171,
                "title": "tracing-path-from-2d-array",
                "content": "### Thought Process 1:Greedy  TLE\\n`Why not store all possible paths and return the k-1 th path`\\n```\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n        self.path = []\\n        def f(i,j,s):\\n            if i == row and j == col:\\n                # reached destination so store the path\\n                self.path.append(s)\\n            if i>row or j>col:return\\n            f(i,j+1,s+\"H\") # lets move right\\n            f(i+1,j,s+\"V\") # lets move down\\n        f(0,0,\"\")\\n        return self.path[k-1]\\n# Note to keep the path list sorted we need to move RIGHT first then DOWN\\n# If we move DOWN first and then RIGHT we need to sort them\\n```\\n### Improving Thought Process 1: Improved Greedy TLE\\n`\\nDo we really need to store all paths?\\n`\\n`We are finding paths in sorted manner.So cant we use this to our advantage?`\\n`So , basically we can return k-1th path and stop searching for next paths`\\n```\\n# We will store only the answer now. Not the complete list\\n# We will return once we reach k-1th path\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n\\n        self.k = k\\n        self.ans = \"\"\\n        @cache\\n        def f(i,j,s):\\n            if i == row and j == col: # reached destination\\n                self.k -= 1\\n                if self.k == 0:       # checking if its our k-1th path\\n                    self.ans = s\\n                    return True       # If yes, return True and store the answer\\n                return False\\n            if self.k == 0:           # This will stop seaching for next\\n                self.ans = s          # store the answer and return True\\n                return True\\n            if i>row or j>col:return False\\n            return f(i,j+1,s+\"H\") or f(i+1,j,s+\"V\")\\n        f(0,0,\"\")\\n        return self.ans # return answer\\n```\\n\\n### Issue With Recurion:\\n`As k value is very high` $^nC_r(row+col,row)$ `for this memory wont suffice`\\n`From above we are able to travel [0,0] to [r,c]`\\n`Cant we store the possible paths for each cell?`\\n```\\n    def f(i,j):\\n        if i == row and j == col: # reached destination\\n            return 1\\n        if i>row or j>col:\\n            return 0              # out of bound\\n        right = f(i,j+1)          # move right\\n        down = f(i+1,j)           # move down\\n        return right+down         # total paths\\n    f(0,0)\\n    # Equvalent Code in 2d array\\n        dp = [[0]*(col+1) for _  in range(row+1)]\\n        for i in range(row,-1,-1):\\n            for j in range(col,-1,-1):\\n                if i == row and j == col:\\n                    dp[i][j] = 1\\n                    continue\\n                right,down = 0,0\\n                if j+1<=col:\\n                    right = dp[i][j+1]\\n                if i+1<=row:\\n                    down = dp[i+1][j]\\n                dp[i][j] = right+down\\n```\\n```\\nfor [2,2]\\nnCr = (2+2,2) = 6 i.e total possible paths for [2,2]\\n\\no/p:\\n    6    3    1\\n    3    2    1\\n    1    1    1\\n\\neach cell denotes total paths current cell to [2,2]\\ncell [0,1] = 3 i.e from [0,1] to [2,2] we have 3 paths [HVV,VHV,VVH]\\ncell [1,0] = 3 i.e from [0,1] to [2,2] we have 3 paths [HHV,HVH,VHH]\\ncell [0,0] = 6 i.e from [0,0] to [2,2] we have 6 possible paths\\n```\\n### Whats Next?\\n`We have all possible paths in a 2D list`\\n`Now we need to extract the k-1th path from it`\\n\\n`To do so we need to follow 2 rules:`\\n```\\nwe are currently at [0,0]\\nSo,\\n should we move [0,1] i.e (i,j+1) - \"H\"\\n should we move [1,0] i.e (i+1,j) - \"V\"\\n\\nmove to (i,j+1) if dp[i][j+1] >=k -> (k remains same     j+=1  add \"H\")\\nmove to (i+1,j) if dp[i][j+1] < k -> (k = k - dp[i][j+1] i+=1  add \"V\")\\n\\nNow we would have reached one of the boundary (row or column)\\nif we have not reached end of row: add \"V\"\\nif we have not reached end of col: add \"H\"\\n```\\n```\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n        // Creating dp for all possible paths\\n        dp = [[0]*(col+1) for _  in range(row+1)]\\n        for i in range(row,-1,-1):\\n            for j in range(col,-1,-1):\\n                if i == row and j == col:\\n                    dp[i][j] = 1\\n                    continue\\n                right,down = 0,0\\n                if j+1<=col:\\n                    right = dp[i][j+1]\\n                if i+1<=row:\\n                    down = dp[i+1][j]\\n                dp[i][j] = right+down\\n        \\n\\n        i,j = 0,0 //stating point [0,0]\\n        s = \"\"    // answer\\n        while i<row and j<col: // iterate until we have hit one of boundary\\n            if dp[i][j+1]>=k:  // move horizontal\\n                j += 1\\n                s += \"H\"\\n            else:              // move vertical\\n                k -= dp[i][j+1]\\n                i +=1\\n                s += \"V\"\\n        while i<row: // we can move down as i<row so add \"V\"\\n            s += \"V\"\\n            i += 1\\n        while j<col: // we can move right as j<col so add \"H\"\\n            s += \"H\"\\n            j += 1\\n        return s\\n\\n```\\n\\n### Extra\\n`Exchange \"H\" and \"V\" and it will give lexicographically largest`\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n        self.path = []\\n        def f(i,j,s):\\n            if i == row and j == col:\\n                # reached destination so store the path\\n                self.path.append(s)\\n            if i>row or j>col:return\\n            f(i,j+1,s+\"H\") # lets move right\\n            f(i+1,j,s+\"V\") # lets move down\\n        f(0,0,\"\")\\n        return self.path[k-1]\\n# Note to keep the path list sorted we need to move RIGHT first then DOWN\\n# If we move DOWN first and then RIGHT we need to sort them\\n```\n```\\n# We will store only the answer now. Not the complete list\\n# We will return once we reach k-1th path\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n\\n        self.k = k\\n        self.ans = \"\"\\n        @cache\\n        def f(i,j,s):\\n            if i == row and j == col: # reached destination\\n                self.k -= 1\\n                if self.k == 0:       # checking if its our k-1th path\\n                    self.ans = s\\n                    return True       # If yes, return True and store the answer\\n                return False\\n            if self.k == 0:           # This will stop seaching for next\\n                self.ans = s          # store the answer and return True\\n                return True\\n            if i>row or j>col:return False\\n            return f(i,j+1,s+\"H\") or f(i+1,j,s+\"V\")\\n        f(0,0,\"\")\\n        return self.ans # return answer\\n```\n```\\n    def f(i,j):\\n        if i == row and j == col: # reached destination\\n            return 1\\n        if i>row or j>col:\\n            return 0              # out of bound\\n        right = f(i,j+1)          # move right\\n        down = f(i+1,j)           # move down\\n        return right+down         # total paths\\n    f(0,0)\\n    # Equvalent Code in 2d array\\n        dp = [[0]*(col+1) for _  in range(row+1)]\\n        for i in range(row,-1,-1):\\n            for j in range(col,-1,-1):\\n                if i == row and j == col:\\n                    dp[i][j] = 1\\n                    continue\\n                right,down = 0,0\\n                if j+1<=col:\\n                    right = dp[i][j+1]\\n                if i+1<=row:\\n                    down = dp[i+1][j]\\n                dp[i][j] = right+down\\n```\n```\\nfor [2,2]\\nnCr = (2+2,2) = 6 i.e total possible paths for [2,2]\\n\\no/p:\\n    6    3    1\\n    3    2    1\\n    1    1    1\\n\\neach cell denotes total paths current cell to [2,2]\\ncell [0,1] = 3 i.e from [0,1] to [2,2] we have 3 paths [HVV,VHV,VVH]\\ncell [1,0] = 3 i.e from [0,1] to [2,2] we have 3 paths [HHV,HVH,VHH]\\ncell [0,0] = 6 i.e from [0,0] to [2,2] we have 6 possible paths\\n```\n```\\nwe are currently at [0,0]\\nSo,\\n should we move [0,1] i.e (i,j+1) - \"H\"\\n should we move [1,0] i.e (i+1,j) - \"V\"\\n\\nmove to (i,j+1) if dp[i][j+1] >=k -> (k remains same     j+=1  add \"H\")\\nmove to (i+1,j) if dp[i][j+1] < k -> (k = k - dp[i][j+1] i+=1  add \"V\")\\n\\nNow we would have reached one of the boundary (row or column)\\nif we have not reached end of row: add \"V\"\\nif we have not reached end of col: add \"H\"\\n```\n```\\nclass Solution:\\n    def kthSmallestPath(self, arr: List[int], k: int) -> str:\\n        row = arr[0]\\n        col = arr[1]\\n        // Creating dp for all possible paths\\n        dp = [[0]*(col+1) for _  in range(row+1)]\\n        for i in range(row,-1,-1):\\n            for j in range(col,-1,-1):\\n                if i == row and j == col:\\n                    dp[i][j] = 1\\n                    continue\\n                right,down = 0,0\\n                if j+1<=col:\\n                    right = dp[i][j+1]\\n                if i+1<=row:\\n                    down = dp[i+1][j]\\n                dp[i][j] = right+down\\n        \\n\\n        i,j = 0,0 //stating point [0,0]\\n        s = \"\"    // answer\\n        while i<row and j<col: // iterate until we have hit one of boundary\\n            if dp[i][j+1]>=k:  // move horizontal\\n                j += 1\\n                s += \"H\"\\n            else:              // move vertical\\n                k -= dp[i][j+1]\\n                i +=1\\n                s += \"V\"\\n        while i<row: // we can move down as i<row so add \"V\"\\n            s += \"V\"\\n            i += 1\\n        while j<col: // we can move right as j<col so add \"H\"\\n            s += \"H\"\\n            j += 1\\n        return s\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112807,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination, k):\\n        i,j = destination\\n\\n        @lru_cache(None)\\n        def dfs(i,j,k):\\n            if k == 1:\\n                return \"H\"*j + \"V\"*i\\n            else:\\n                val = math.comb(i+j-1,j-1)\\n\\n                if k <= val:\\n                    return \"H\" + dfs(i,j-1,k)\\n                else:\\n                    return \"V\" + dfs(i-1,j,k-val)\\n\\n        return dfs(i,j,k)\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination, k):\\n        i,j = destination\\n\\n        @lru_cache(None)\\n        def dfs(i,j,k):\\n            if k == 1:\\n                return \"H\"*j + \"V\"*i\\n            else:\\n                val = math.comb(i+j-1,j-1)\\n\\n                if k <= val:\\n                    return \"H\" + dfs(i,j-1,k)\\n                else:\\n                    return \"V\" + dfs(i-1,j,k-val)\\n\\n        return dfs(i,j,k)\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094957,
                "title": "scala",
                "content": "```scala\\nobject Solution {\\n    def kthSmallestPath(des: Array[Int], k: Int): String = {\\n        def mem[I, O](f: I => O) = new scala.collection.mutable.HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val comb: ((Int, Int)) => Int = mem {\\n            case (_, 0) | (0, _) => 1\\n            case (m, 1) => m\\n            case (m, n) if (n > m / 2) => comb(m, m - n)\\n            case (m, n) => comb(m - 1, n - 1) + comb(m - 1, n)\\n        }\\n        \\n        lazy val go: ((Int, Int, Int)) => String = {\\n            case (r, 0, _) => \"V\" * r\\n            case (r, c, k) if (k > comb(r + c - 1, r)) => \"V\" + go(r - 1, c, k - comb(r + c - 1, r))\\n            case (r, c, k) => \"H\" + go(r, c - 1, k)\\n        }\\n        \\n        go(des(0), des(1), k)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n    def kthSmallestPath(des: Array[Int], k: Int): String = {\\n        def mem[I, O](f: I => O) = new scala.collection.mutable.HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val comb: ((Int, Int)) => Int = mem {\\n            case (_, 0) | (0, _) => 1\\n            case (m, 1) => m\\n            case (m, n) if (n > m / 2) => comb(m, m - n)\\n            case (m, n) => comb(m - 1, n - 1) + comb(m - 1, n)\\n        }\\n        \\n        lazy val go: ((Int, Int, Int)) => String = {\\n            case (r, 0, _) => \"V\" * r\\n            case (r, c, k) if (k > comb(r + c - 1, r)) => \"V\" + go(r - 1, c, k - comb(r + c - 1, r))\\n            case (r, c, k) => \"H\" + go(r, c - 1, k)\\n        }\\n        \\n        go(des(0), des(1), k)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2976648,
                "title": "python-java-walking-through-example-with-dp-approach-builds-on-lc-62-unique-paths",
                "content": "I recommend solving [unique-paths](https://leetcode.com/problems/unique-paths/) first (with a bottom-up dp approach). We will use it to create the dp table.\\n\\nSpecifically, we will build a dp table where $dp[i][j]$ denotes the number of unique paths to reach the bottom-right corner, starting from indexes i, j\\n\\nFor example, \\ndestination = [2, 3], k = 3\\nwill have the following dp table:\\n```\\n10  6   3   1\\n\\n4   3   2   1 \\n  \\n1   1   1   1\\n```\\n<pre>\\nLets look at dp[0][0],\\nThere are 10 unique paths\\n    if we move right, we then have 6 unique paths left\\n        [\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\"]\\n    if we move down, we then have 4 unique paths left\\n        [\"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"]\\n</pre>\\n\\nThe 6 paths on moving right are lexicographically smaller than the 4 paths on moving down\\n\\nWe want the 3rd smallest path(we are given k=3). So we choose to move right since the 3rd smallest path will be amongst the 6 smallest paths.\\n\\n```\\n10__6   3   1\\n    ^    \\n4   3   2   1 \\n  \\n1   1   1   1\\n```\\nWe are now at dp[0][1] = 6, moving right will mean our path will be amongst the 3 smallest paths, so we move right.\\n```\\n10__6___3   1\\n        ^\\n4   3   2   1 \\n  \\n1   1   1   1\\n```\\nWe are now at dp[0][2] = 3, we don\\'t want to move right since then our path will be amongst the 1 smallest path(s), so we don\\'t do that(since k = 3, we want the 3rd smallest path).\\nWe move down instead.\\n\\nThere is one thing to note when moving down. \\nAgain, all the paths when moving right are lexicographically smaller than all the paths when moving down.\\nSo you could imagine that all the unique paths when moving down are all \"shifted\" in lex order by the number of paths on the right.\\n\\nYou could also view this as a subproblem where we are looking at the unique paths starting from indexes i, j\\n\\nWe can encode this into our implementation by subtracting our k value by dp[i][j+1] \\nso in this case:\\n```\\nk := k - dp[i][j+1]\\n   = k - dp[0][3]\\n   = 3 - 1 # so now k is 2\\n```\\n\\n\\n```  \\nk = 2\\n10__6___3   1\\n        |\\n4   3   2   1 \\n        ^\\n1   1   1   1\\n```\\nWe are now at dp[1][2] = 2, k = 2, we don\\'t want to move right since then  path will be the 1st smallest path(inside the subproblem perspective).\\nSo we move down.\\n\\n```  \\nk = 1\\n10__6___3   1\\n        |\\n4   3   2   1 \\n        |\\n1   1   1   1\\n        ^\\n```\\nWe are now at dp[2][2] = 1, k = 1\\nOnce we reach the bottom row or right column, there is only one path we can choose.\\n\\nOur final path is:\\n```  \\n10__6___3   1\\n        |\\n4   3   2   1 \\n        |\\n1   1   1___1\\n\"HHVVH\"\\n```\\nWhich is indeed the 3rd smallest path out of [\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"]\\n\\n# High-level Recap\\nWe build dp table of unique paths.\\nWe traverse the dp table starting at dp[0][0].\\nWe compare k with dp[i][j+1] to decide whether to move right or down.\\n\\n# Code\\n```python []\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination[0] + 1, destination[1] + 1\\n        dp = [[0] * n for i in range(m)]\\n        for i in range(m): dp[i][n-1] = 1\\n        for j in range(n): dp[m-1][j] = 1\\n        for i in range(m-2, -1, -1):\\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        # ^ this is just LC #62. Unique Paths\\n\\n        sb = []\\n        i, j = 0, 0\\n        while i < m-1 and j < n-1: \\n            \"\"\" e.g dest = [2,3], k = 3\\n            10  6   3   1\\n            4   3   2   1   \\n            1   1   1   1\\n            \"\"\"\\n            # move right\\n            if k <= dp[i][j+1]:\\n                j += 1\\n                sb.append(\\'H\\')\\n            # move down\\n            else:\\n                k -= dp[i][j+1]\\n                i += 1\\n                sb.append(\\'V\\')\\n        # if we reach the bottom row or right column, there is only one path left\\n        sb.append(\\'V\\' * (m-1 - i) + \\'H\\' * (n-1 - j))\\n        # print(\\'\\\\n\\'.join([\\'\\\\t\\'.join([str(cell) for cell in row]) for row in dp]))\\n        return \\'\\'.join(sb)\\n```\\n```java []\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int m = destination[0] + 1;\\n        int n = destination[1] + 1;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][n-1] = 1; \\n        for (int j = 0; j < n; j++) dp[m-1][j] = 1; \\n        for (int i = m-2; i >= 0; i--) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        } // ^ this is just LC #62. Unique Paths\\n\\n        int i = 0;\\n        int j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < m-1 && j < n-1) {\\n            // e.g dest = [2,3], k = 3\\n            //    10  6   3   1\\n            //    4   3   2   1   \\n            //    1   1   1   1\\n\\n            // move right\\n            if (k <= dp[i][j+1]) {\\n                j++;\\n                sb.append(\\'H\\');\\n            } \\n            // move down\\n            else {\\n                k -= dp[i][j+1];\\n                i++;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        // if we reach the bottom row or right column, there is only one path left\\n        for (; i < m-1; i++) sb.append(\\'V\\');\\n        for (; j < n-1; j++) sb.append(\\'H\\');\\n        //System.out.println(Arrays.deepToString(dp).replace(\"], \", \"]\\\\n\"));\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n10  6   3   1\\n\\n4   3   2   1 \\n  \\n1   1   1   1\\n```\n```\\n10__6   3   1\\n    ^    \\n4   3   2   1 \\n  \\n1   1   1   1\\n```\n```\\n10__6___3   1\\n        ^\\n4   3   2   1 \\n  \\n1   1   1   1\\n```\n```\\nk := k - dp[i][j+1]\\n   = k - dp[0][3]\\n   = 3 - 1 # so now k is 2\\n```\n```  \\nk = 2\\n10__6___3   1\\n        |\\n4   3   2   1 \\n        ^\\n1   1   1   1\\n```\n```  \\nk = 1\\n10__6___3   1\\n        |\\n4   3   2   1 \\n        |\\n1   1   1   1\\n        ^\\n```\n```  \\n10__6___3   1\\n        |\\n4   3   2   1 \\n        |\\n1   1   1___1\\n\"HHVVH\"\\n```\n```python []\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        m, n = destination[0] + 1, destination[1] + 1\\n        dp = [[0] * n for i in range(m)]\\n        for i in range(m): dp[i][n-1] = 1\\n        for j in range(n): dp[m-1][j] = 1\\n        for i in range(m-2, -1, -1):\\n            for j in range(n-2, -1, -1):\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        # ^ this is just LC #62. Unique Paths\\n\\n        sb = []\\n        i, j = 0, 0\\n        while i < m-1 and j < n-1: \\n            \"\"\" e.g dest = [2,3], k = 3\\n            10  6   3   1\\n            4   3   2   1   \\n            1   1   1   1\\n            \"\"\"\\n            # move right\\n            if k <= dp[i][j+1]:\\n                j += 1\\n                sb.append(\\'H\\')\\n            # move down\\n            else:\\n                k -= dp[i][j+1]\\n                i += 1\\n                sb.append(\\'V\\')\\n        # if we reach the bottom row or right column, there is only one path left\\n        sb.append(\\'V\\' * (m-1 - i) + \\'H\\' * (n-1 - j))\\n        # print(\\'\\\\n\\'.join([\\'\\\\t\\'.join([str(cell) for cell in row]) for row in dp]))\\n        return \\'\\'.join(sb)\\n```\n```java []\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int m = destination[0] + 1;\\n        int n = destination[1] + 1;\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) dp[i][n-1] = 1; \\n        for (int j = 0; j < n; j++) dp[m-1][j] = 1; \\n        for (int i = m-2; i >= 0; i--) {\\n            for (int j = n-2; j >= 0; j--) {\\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        } // ^ this is just LC #62. Unique Paths\\n\\n        int i = 0;\\n        int j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < m-1 && j < n-1) {\\n            // e.g dest = [2,3], k = 3\\n            //    10  6   3   1\\n            //    4   3   2   1   \\n            //    1   1   1   1\\n\\n            // move right\\n            if (k <= dp[i][j+1]) {\\n                j++;\\n                sb.append(\\'H\\');\\n            } \\n            // move down\\n            else {\\n                k -= dp[i][j+1];\\n                i++;\\n                sb.append(\\'V\\');\\n            }\\n        }\\n        // if we reach the bottom row or right column, there is only one path left\\n        for (; i < m-1; i++) sb.append(\\'V\\');\\n        for (; j < n-1; j++) sb.append(\\'H\\');\\n        //System.out.println(Arrays.deepToString(dp).replace(\"], \", \"]\\\\n\"));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969285,
                "title": "golang-solution-constant-time-space-with-the-given-constraints-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCalculate a grid of m*n representing the number of possible paths from (x, y) to destination.\\n\\nAny cell in last colume(can only go down) or last row(can only go right) would be 1\\nFor the rest of the grid, c(x, y) = c(x+1, y) + c(x, y+1), combination of total paths from two cells: the one on the right, and the one beneath it.\\n\\nstarting from cell(0, 0), going right, i.e, moving to (0, 1) means appending an \"H\", and going down, i.e, moving to (1, 0) means appending a \"V\". Kth permutation must either falls into these two cases. If grid(0, 1) has larger or equal count than \"k\", the k-th path must be one of the paths via cell (0, 1).\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\nm = num of rows\\nn = num of cols\\n0 <= rows, cols <= 15\\n\\n- Space complexity:\\nO(m*n)\\nm = num of rows\\nn = num of cols\\n0 <= rows, cols <= 15\\n\\n# Code\\n```\\nfunc kthSmallestPath(destination []int, k int) string {\\n    rows, cols := destination[0] + 1, destination[1] + 1\\n    c := make([][]int, rows)\\n    for i := 0; i < rows; i = i + 1 {\\n        c[i] = make([]int, cols)\\n    }\\n    // last row\\n    for i := 0; i < cols - 1; i = i + 1 {\\n        c[rows-1][i] = 1\\n    }\\n    // last col\\n    for i := 0; i < rows - 1; i = i + 1 {\\n        c[i][cols-1] = 1\\n    }\\n    for r := rows - 2; r >= 0; r = r - 1 {\\n        for cl := cols - 2; cl >= 0; cl = cl - 1 {\\n            c[r][cl] = c[r][cl+1] + c[r+1][cl]\\n        }\\n    }\\n    ret := \"\"\\n    row, col := 0, 0\\n    slen := destination[0] + destination[1]\\n    for len(ret) < destination[0] + destination[1] {\\n        if col == cols - 1 {\\n            // can only go down\\n            for len(ret) < slen {\\n                ret = ret + \"V\"\\n            }\\n            break\\n        }\\n        if row == rows - 1 {\\n            // can only go right\\n            for len(ret) < slen {\\n                ret = ret + \"H\"\\n            }\\n            break\\n        }\\n        if k <= c[row][col+1] {\\n            // go horizontal\\n            ret = ret + \"H\"\\n            col = col + 1\\n        } else {\\n            k -= c[row][col+1]\\n            row = row + 1\\n            ret = ret + \"V\"\\n        }\\n    }\\n    return ret\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc kthSmallestPath(destination []int, k int) string {\\n    rows, cols := destination[0] + 1, destination[1] + 1\\n    c := make([][]int, rows)\\n    for i := 0; i < rows; i = i + 1 {\\n        c[i] = make([]int, cols)\\n    }\\n    // last row\\n    for i := 0; i < cols - 1; i = i + 1 {\\n        c[rows-1][i] = 1\\n    }\\n    // last col\\n    for i := 0; i < rows - 1; i = i + 1 {\\n        c[i][cols-1] = 1\\n    }\\n    for r := rows - 2; r >= 0; r = r - 1 {\\n        for cl := cols - 2; cl >= 0; cl = cl - 1 {\\n            c[r][cl] = c[r][cl+1] + c[r+1][cl]\\n        }\\n    }\\n    ret := \"\"\\n    row, col := 0, 0\\n    slen := destination[0] + destination[1]\\n    for len(ret) < destination[0] + destination[1] {\\n        if col == cols - 1 {\\n            // can only go down\\n            for len(ret) < slen {\\n                ret = ret + \"V\"\\n            }\\n            break\\n        }\\n        if row == rows - 1 {\\n            // can only go right\\n            for len(ret) < slen {\\n                ret = ret + \"H\"\\n            }\\n            break\\n        }\\n        if k <= c[row][col+1] {\\n            // go horizontal\\n            ret = ret + \"H\"\\n            col = col + 1\\n        } else {\\n            k -= c[row][col+1]\\n            row = row + 1\\n            ret = ret + \"V\"\\n        }\\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2917301,
                "title": "simple-combination-beats-91-time-c-easy",
                "content": "# Intuition\\nSince, the path string can only have 2 characters : \\'H\\' and \\'V\\', We can incrementally try to build the path string. Also, the fact that, out of \\'total\\' possible strings, some \\'num\\' strings will start from \\'H\\', and remaining \\'total\\' - \\'num\\' will start from \\'V\\' can help us here.\\n\\n# Approach\\nNotice, that you can straightaway tell, that how many number of \\'H\\' (hNum) and how many number of \\'V\\' (vNum) will be in any path. Notice examples carefully for understanding this point.\\nNext,\\nStart building answer from index 0.\\nIf k is less than or equal to the number of strings that start with \\'H\\', then first character of our answer will be \\'H\\', otherwise it will be \\'V\\'.\\nAccordingly update the value of \\'hNum\\' and \\'vNum\\' and k. Repeat this process until \\'hNum\\' and \\'vNum\\' are both not 0.\\n\\nYou can understand how to calculate number of strings starting from \\'H\\' by observing the code.\\n\\n# Complexity\\n- Time complexity:\\nIn the while loop, either vNum is being decremented each time or hNum is being decremented each time. O(m+n) where m is vNum and n is hNum.\\nCombination function takes O(min(m,n)) in the worst case.\\nFinal Time Complexity : O((m+n)*min(m,n))\\n\\n- Space complexity:\\nNo additional space used, apart from few variables.\\nFinal Space Complexity : O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long combination(int n,int k) { // calculates (nCk)\\n        long long res = 1;\\n        if (k > n - k)\\n            k = n - k;\\n        for (int i = 0; i < k; ++i) {\\n            res *= (n - i);\\n            res /= (i + 1);\\n        }\\n        return res;\\n    }\\n\\n    int findStringsStartWithH(int hNum, int vNum) { // finds how many strings starts with \\'H\\' when no.(H) = hNum, no.(v) = vNum\\n        return combination(hNum+vNum,hNum) * hNum / (hNum+vNum) ;\\n    }\\n\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int vNum = destination[0], hNum = destination[1];\\n        string path = \"\";\\n        while(hNum || vNum) {\\n            int HStrings = findStringsStartWithH(hNum,vNum);\\n           if(k<=HStrings) {\\n                path+=\\'H\\';\\n                hNum--;\\n            }\\n            else {\\n                path+=\\'V\\';\\n                vNum--;\\n                k -= HStrings;\\n            }\\n        }\\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long combination(int n,int k) { // calculates (nCk)\\n        long long res = 1;\\n        if (k > n - k)\\n            k = n - k;\\n        for (int i = 0; i < k; ++i) {\\n            res *= (n - i);\\n            res /= (i + 1);\\n        }\\n        return res;\\n    }\\n\\n    int findStringsStartWithH(int hNum, int vNum) { // finds how many strings starts with \\'H\\' when no.(H) = hNum, no.(v) = vNum\\n        return combination(hNum+vNum,hNum) * hNum / (hNum+vNum) ;\\n    }\\n\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int vNum = destination[0], hNum = destination[1];\\n        string path = \"\";\\n        while(hNum || vNum) {\\n            int HStrings = findStringsStartWithH(hNum,vNum);\\n           if(k<=HStrings) {\\n                path+=\\'H\\';\\n                hNum--;\\n            }\\n            else {\\n                path+=\\'V\\';\\n                vNum--;\\n                k -= HStrings;\\n            }\\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865635,
                "title": "python-combinatorics",
                "content": "# Intuition\\nWe need to print the k\\'th lexicographic manifestation of h H\\'s and v V\\'s.\\nThere are $${h+v \\\\choose h} = {h+v \\\\choose v}$$ of them, the first $${h+v-1 \\\\choose h-1} = {h+v-1 \\\\choose v-1}$$ of which start with a \"H\" and the second half start with a \"V\".\\nIf k is less than this value, return \"H\" + the k\\'th lexicographical manifestation of h-1 H\\'s and v V\\'s.\\nIf k is greater than this value, return \"V\" + the (k - threshold)\\'th lexicographical manifestation of h H\\'s and v-1 V\\'s.\\n\\n# Code\\n```\\nimport math \\nclass Solution:\\n\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        v, h = destination\\n        ret = []\\n        while True:\\n            if v == 0:\\n                ret.append(\"H\" * h)\\n                break\\n            if h == 0:\\n                ret.append(\"V\" * v)\\n                break\\n            # the number of versions that start with an H\\n            threshold = math.comb(h + v - 1, h - 1)\\n            if k <= threshold:\\n                ret.append(\"H\")\\n                h -= 1\\n            else:\\n                ret.append(\"V\")\\n                v -= 1\\n                k -= threshold\\n        return \"\".join(ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math \\nclass Solution:\\n\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        v, h = destination\\n        ret = []\\n        while True:\\n            if v == 0:\\n                ret.append(\"H\" * h)\\n                break\\n            if h == 0:\\n                ret.append(\"V\" * v)\\n                break\\n            # the number of versions that start with an H\\n            threshold = math.comb(h + v - 1, h - 1)\\n            if k <= threshold:\\n                ret.append(\"H\")\\n                h -= 1\\n            else:\\n                ret.append(\"V\")\\n                v -= 1\\n                k -= threshold\\n        return \"\".join(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843538,
                "title": "c-dp-calculate-lexicography-in-every-step-o-m-n",
                "content": "I solve this in 2 steps:\\n- Count possible ways to reach all i,j (i<n, j<m)\\n- Travel from (0,0), in each step, greedily decide if we should go right or down\\n\\t- If we go right, our rank stay the same, since \"H\" is the best choice lexicography\\n\\t- If we go left, our rank decrease, we choose \"V\" which essentially go down lexicography. Use precalculated array from previous step to determine how many rank do we go down\\n\\t- When we reach (n,m), answer is the path made from the traversal\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[1]+1;\\n        int m = destination[0]+1;\\n        vector<vector<int>> f(n, vector<int>(m,0));\\n        f[0][0] = 1;\\n        for(int i = 0;i<n;i++) {\\n            f[i][0] = 1;\\n        }\\n        for(int i = 0;i<m;i++) {\\n            f[0][i] = 1;\\n        }\\n        for(int i = 1;i<n;i++) {\\n            for(int j = 1;j<m;j++) {\\n                f[i][j] = f[i-1][j] + f[i][j-1];\\n            }\\n        }\\n        string ret = \"\";\\n        int i = 0;\\n        int j = 0;\\n        int rank = 1;\\n        while(i<n && j<m) {\\n            int dx = n-1-i;\\n            int dy = m-1-j;\\n            if(dx == 0 && dy == 0) {\\n                break;\\n            }\\n            if(dx == 0) {\\n                j++;\\n                ret += \"V\";\\n            } else if(dy == 0) {\\n                i++;\\n                ret += \"H\";\\n            } else {\\n                int deltaV = f[dx][dy] - f[dx][dy-1]; \\n                // if we go down, we go down deltaV in rank\\n                // if we go right, our rank stay the same\\n                if(rank + deltaV <= k) {\\n                    rank += deltaV;\\n                    j++;\\n                    ret += \"V\";\\n                } else {\\n                    i++;\\n                    ret += \"H\";\\n                }\\n            }\\n        }\\n        return ret;\\n        cout<<\"f: \"<<endl;\\n        for(int i = 0;i<n;i++) {\\n            for(int j = 0;j<m;j++) {\\n                cout<<f[i][j]<<\\' \\';\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[1]+1;\\n        int m = destination[0]+1;\\n        vector<vector<int>> f(n, vector<int>(m,0));\\n        f[0][0] = 1;\\n        for(int i = 0;i<n;i++) {\\n            f[i][0] = 1;\\n        }\\n        for(int i = 0;i<m;i++) {\\n            f[0][i] = 1;\\n        }\\n        for(int i = 1;i<n;i++) {\\n            for(int j = 1;j<m;j++) {\\n                f[i][j] = f[i-1][j] + f[i][j-1];\\n            }\\n        }\\n        string ret = \"\";\\n        int i = 0;\\n        int j = 0;\\n        int rank = 1;\\n        while(i<n && j<m) {\\n            int dx = n-1-i;\\n            int dy = m-1-j;\\n            if(dx == 0 && dy == 0) {\\n                break;\\n            }\\n            if(dx == 0) {\\n                j++;\\n                ret += \"V\";\\n            } else if(dy == 0) {\\n                i++;\\n                ret += \"H\";\\n            } else {\\n                int deltaV = f[dx][dy] - f[dx][dy-1]; \\n                // if we go down, we go down deltaV in rank\\n                // if we go right, our rank stay the same\\n                if(rank + deltaV <= k) {\\n                    rank += deltaV;\\n                    j++;\\n                    ret += \"V\";\\n                } else {\\n                    i++;\\n                    ret += \"H\";\\n                }\\n            }\\n        }\\n        return ret;\\n        cout<<\"f: \"<<endl;\\n        for(int i = 0;i<n;i++) {\\n            for(int j = 0;j<m;j++) {\\n                cout<<f[i][j]<<\\' \\';\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2834322,
                "title": "easy-c-recursion",
                "content": "```\\nclass Solution {\\n    \\n    int combi(int n, int r) {\\n                \\n        int num = n;\\n        int den = min(n-r, r);\\n        \\n        int sm = 1;\\n        int i;\\n        \\n        for(i=1;i<=den;i++) {\\n            sm = (sm * num)/i;\\n            num--;\\n        }        \\n        return sm;\\n    }\\n    \\n    string solve(int h, int v, int k) {\\n        if(h==0) {\\n            return string(v,\\'V\\');\\n        }\\n        if(v==0) {\\n            return string(h, \\'H\\');\\n        }\\n        \\n        int c = combi(h+v-1,h-1);\\n        \\n        if(k>c) {\\n            return \\'V\\'+solve(h, v-1, k-c);\\n        } else {\\n            return \\'H\\'+solve(h-1, v, k);\\n        }\\n    }\\n    \\n    \\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        return solve(destination[1],destination[0],k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int combi(int n, int r) {\\n                \\n        int num = n;\\n        int den = min(n-r, r);\\n        \\n        int sm = 1;\\n        int i;\\n        \\n        for(i=1;i<=den;i++) {\\n            sm = (sm * num)/i;\\n            num--;\\n        }        \\n        return sm;\\n    }\\n    \\n    string solve(int h, int v, int k) {\\n        if(h==0) {\\n            return string(v,\\'V\\');\\n        }\\n        if(v==0) {\\n            return string(h, \\'H\\');\\n        }\\n        \\n        int c = combi(h+v-1,h-1);\\n        \\n        if(k>c) {\\n            return \\'V\\'+solve(h, v-1, k-c);\\n        } else {\\n            return \\'H\\'+solve(h-1, v, k);\\n        }\\n    }\\n    \\n    \\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        return solve(destination[1],destination[0],k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790385,
                "title": "python3-simple-recursive-approach-with-comments",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # Returns the Kth smallest string containing h H\\'s and v V\\'s.\\n        def recurse(h, v, k):\\n            # If k is 1, return the smallest lexicographical string.\\n            if k == 1:\\n                return \\'H\\' * h + \\'V\\' * v\\n            \\n            # The first character will be \\'V\\' if k exceed the number of\\n            # combinations starting with an \\'H\\'.\\n            hCombinations = comb(h + v - 1, v)\\n            if hCombinations < k:\\n                return \\'V\\' + recurse(h, v - 1, k - hCombinations)\\n            \\n\\t\\t\\t# If not, the next character will be an \\'H\\'.\\n            return \\'H\\' + recurse(h - 1, v, k)\\n        \\n        return recurse(destination[1], destination[0], k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # Returns the Kth smallest string containing h H\\'s and v V\\'s.\\n        def recurse(h, v, k):\\n            # If k is 1, return the smallest lexicographical string.\\n            if k == 1:\\n                return \\'H\\' * h + \\'V\\' * v\\n            \\n            # The first character will be \\'V\\' if k exceed the number of\\n            # combinations starting with an \\'H\\'.\\n            hCombinations = comb(h + v - 1, v)\\n            if hCombinations < k:\\n                return \\'V\\' + recurse(h, v - 1, k - hCombinations)\\n            \\n\\t\\t\\t# If not, the next character will be an \\'H\\'.\\n            return \\'H\\' + recurse(h - 1, v, k)\\n        \\n        return recurse(destination[1], destination[0], k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682554,
                "title": "eay-python-o-n-2",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.get all the combinations possible from every index\\n2.start from 0,0\\n3.check if the right index combination is less than or equal to our K,if yes ,move to right else move to left with k=k-right combo\\n4.repeat step 3 until u reach n-1,n-1 \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n**2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n**2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        x,y=destination\\n        arr=[[0 for i in range(y+1)] for j in range(x+1)]\\n        arr[x][y]=1\\n\\n        for i in range(x,-1,-1):\\n            for j in range(y,-1,-1):\\n                if i+1<=x:\\n                    arr[i][j]+=arr[i+1][j]\\n                if j+1<=y:\\n                    arr[i][j]+=arr[i][j+1]\\n       \\n        i,j=0,0\\n        r=\\'\\'\\n        for _ in range(x+y):\\n            if i<=x and j+1<=y and arr[i][j+1]>=k:\\n                r+=\\'H\\'\\n                j+=1\\n            else:\\n                r+=\\'V\\'\\n                k-=arr[i][j+1] if i<=x and j+1<=y else 0\\n                i+=1\\n        \\n        return r\\n                \\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        x,y=destination\\n        arr=[[0 for i in range(y+1)] for j in range(x+1)]\\n        arr[x][y]=1\\n\\n        for i in range(x,-1,-1):\\n            for j in range(y,-1,-1):\\n                if i+1<=x:\\n                    arr[i][j]+=arr[i+1][j]\\n                if j+1<=y:\\n                    arr[i][j]+=arr[i][j+1]\\n       \\n        i,j=0,0\\n        r=\\'\\'\\n        for _ in range(x+y):\\n            if i<=x and j+1<=y and arr[i][j+1]>=k:\\n                r+=\\'H\\'\\n                j+=1\\n            else:\\n                r+=\\'V\\'\\n                k-=arr[i][j+1] if i<=x and j+1<=y else 0\\n                i+=1\\n        \\n        return r\\n                \\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676330,
                "title": "python-with-only-one-combination-computation",
                "content": "Let\\'s start with the initial value `(v + h - 1) Combination (v)`\\n\\nWe know nCr is the number of positioning r `H` in n positions.\\nWhile decreasing n, if the combination got smaller than k, we can know the position of v.\\nDecreasing n can be done in `O(1)` using lastest combination computation.\\n\\nAfter finding the first position of `H`, by subtracting k by the \\'biggest combination less than k\\', which is the last combination, we can reuse same logic to the end.\\n\\nWhenever finding the position of `H`, we should decrease r. It can also be done in `O(1)` using latest combination computation.\\n\\n```\\nclass Combination:\\n    def __init__(self, n: int, r: int):\\n        self.n = n\\n        self.r = r\\n        self.val = math.comb(n, r)\\n        \\n    def reduce_r(self):\\n        if self.val:\\n            self.val = self.val * self.r // (self.n - self.r + 1)\\n        self.r -= 1\\n        \\n    def reduce_n(self):\\n        self.val = self.val * (self.n - self.r) // self.n\\n        self.n -= 1\\n\\n\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        comb = Combination(destination[0] + destination[1] - 1, destination[0])\\n        \\n        arr = []\\n        \\n        while True:\\n            if comb.val < k:\\n                arr.append(\\'V\\')\\n                k -= comb.val\\n                comb.reduce_r()\\n                if comb.r == 0:\\n                    arr.extend(itertools.repeat(\\'H\\', destination[0] + destination[1] - len(arr)))\\n                    break\\n            else:\\n                arr.append(\\'H\\')\\n                    \\n            comb.reduce_n()\\n        \\n        return \\'\\'.join(arr)\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Combination:\\n    def __init__(self, n: int, r: int):\\n        self.n = n\\n        self.r = r\\n        self.val = math.comb(n, r)\\n        \\n    def reduce_r(self):\\n        if self.val:\\n            self.val = self.val * self.r // (self.n - self.r + 1)\\n        self.r -= 1\\n        \\n    def reduce_n(self):\\n        self.val = self.val * (self.n - self.r) // self.n\\n        self.n -= 1\\n\\n\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        comb = Combination(destination[0] + destination[1] - 1, destination[0])\\n        \\n        arr = []\\n        \\n        while True:\\n            if comb.val < k:\\n                arr.append(\\'V\\')\\n                k -= comb.val\\n                comb.reduce_r()\\n                if comb.r == 0:\\n                    arr.extend(itertools.repeat(\\'H\\', destination[0] + destination[1] - len(arr)))\\n                    break\\n            else:\\n                arr.append(\\'H\\')\\n                    \\n            comb.reduce_n()\\n        \\n        return \\'\\'.join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650895,
                "title": "no-dp-required-simple-counting-problem-70-faster",
                "content": "Similar to [K-th Smallest in Lexicographical Order](https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/)\\nDp is not required in this problem. You can just count to the required kth sequence.\\nFor current prefix count number of possible string with current prefix as the prefix. If rank of current prefix + nmuber of possible solutions are more than k then we need to append H which will half the possible number of strings and continue. If possibilitis are less then k then subtract the possibilities from k and switch up last element from H to V. If k becomes one then we extend the prefix to required string and return.\\n```\\nclass Solution {\\npublic:\\n    long long int count(string &s, int r, int c, int k){\\n        int rt = 0, ct = 0;for(auto i : s){\\n            rt += (i==\\'V\\');\\n            ct += (i==\\'H\\');\\n        }\\n        r -= rt;\\n        c -=ct;\\n        long long int num = 1;\\n        for(int i = r+c; i>max(r,c); i--){num *= i;}\\n        for(int i = min(r,c); i>=1; i--){num/=i;}\\n        return num;\\n    }\\n    string perp(string &s, int r , int c){\\n        int rt = 0, ct = 0;for(auto i : s){\\n            rt += (i==\\'V\\');\\n            ct += (i==\\'H\\');\\n        }\\n        r -= rt;\\n        c -=ct;\\n        for(int i = 0; i<c; i++)s += \"H\";\\n        for(int i = 0; i<r; i++)s += \"V\";\\n        return s;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int r = destination[0], c = destination[1];\\n        string pre = \"H\";\\n        while(k){\\n            if(k==1) return perp(pre, r,c);\\n            long long int  num = count(pre,r,c,k);\\n            if(num < k){\\n                k -=num;\\n                pre[pre.size()-1] = \\'V\\';\\n            }else{\\n                pre += \"H\";\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i<c; i++)ans += \"H\";\\n        for(int i = 0; i<r; i++)ans += \"V\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int count(string &s, int r, int c, int k){\\n        int rt = 0, ct = 0;for(auto i : s){\\n            rt += (i==\\'V\\');\\n            ct += (i==\\'H\\');\\n        }\\n        r -= rt;\\n        c -=ct;\\n        long long int num = 1;\\n        for(int i = r+c; i>max(r,c); i--){num *= i;}\\n        for(int i = min(r,c); i>=1; i--){num/=i;}\\n        return num;\\n    }\\n    string perp(string &s, int r , int c){\\n        int rt = 0, ct = 0;for(auto i : s){\\n            rt += (i==\\'V\\');\\n            ct += (i==\\'H\\');\\n        }\\n        r -= rt;\\n        c -=ct;\\n        for(int i = 0; i<c; i++)s += \"H\";\\n        for(int i = 0; i<r; i++)s += \"V\";\\n        return s;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int r = destination[0], c = destination[1];\\n        string pre = \"H\";\\n        while(k){\\n            if(k==1) return perp(pre, r,c);\\n            long long int  num = count(pre,r,c,k);\\n            if(num < k){\\n                k -=num;\\n                pre[pre.size()-1] = \\'V\\';\\n            }else{\\n                pre += \"H\";\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i<c; i++)ans += \"H\";\\n        for(int i = 0; i<r; i++)ans += \"V\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547391,
                "title": "python-combination-how-many-we-have-skipped-if-we-choose-v",
                "content": "```python\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # H > V\\n        # k start from 1\\n        # need destination[1] * H and destination[0] * V\\n        \\n        res = []\\n        k -= 1\\n        while k != 0:\\n            total = sum(destination) - 1\\n            H, V = destination[1] - 1, destination[0]\\n            # how many we have skipped if we choose V\\n            skipped = factorial(total) // (factorial(H) * factorial(V))\\n            if skipped <= k:\\n                k -= factorial(total) // (factorial(H) * factorial(V))\\n                res.append(\"V\")\\n                destination[0] -= 1\\n            else:\\n                res.append(\"H\")\\n                destination[1] -= 1\\n        \\n        res += [\"H\"] * destination[1]\\n        res += [\"V\"] * destination[0]\\n        return \"\".join(res)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # H > V\\n        # k start from 1\\n        # need destination[1] * H and destination[0] * V\\n        \\n        res = []\\n        k -= 1\\n        while k != 0:\\n            total = sum(destination) - 1\\n            H, V = destination[1] - 1, destination[0]\\n            # how many we have skipped if we choose V\\n            skipped = factorial(total) // (factorial(H) * factorial(V))\\n            if skipped <= k:\\n                k -= factorial(total) // (factorial(H) * factorial(V))\\n                res.append(\"V\")\\n                destination[0] -= 1\\n            else:\\n                res.append(\"H\")\\n                destination[1] -= 1\\n        \\n        res += [\"H\"] * destination[1]\\n        res += [\"V\"] * destination[0]\\n        return \"\".join(res)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544205,
                "title": "c-combinatorics",
                "content": "```\\nclass Solution {\\npublic:\\n    long long fac[32];\\n    int mod=1000000007;\\n    void pre()\\n    {\\n        fac[0]=1;\\n        for(long long i=1;i<=30;++i)\\n        {\\n            fac[i]=(fac[i-1]*i)%mod;\\n        }\\n    }\\n    long long power(long long a,int b)\\n    {\\n        if(b==0)return 1;\\n        long long p=power(a,b/2);\\n        p=(p*p)%mod;\\n        if(b&1)\\n        {\\n            p=(p*a)%mod;\\n        }\\n        return p;\\n    }\\n    long long modInverse(long long a)\\n    {\\n        return power(a,mod-2)%mod;\\n    }\\n    long long nCr(int n,int r)\\n    {\\n        if(n<r)return 0;\\n        if(r==0)return 1;\\n        \\n        return ((((fac[n]%mod)*(modInverse(fac[r]%mod)%mod))%mod)*(modInverse(fac[n-r]%mod)%mod))%mod;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        pre();\\n        int h=destination[0],w=destination[1];\\n        string res=\"\";\\n        while(h>0&&w>0)\\n        {\\n            long long pos=nCr(h+w-1,w-1);\\n            //cout<<pos<<\" \";\\n            if(pos<k)\\n            {\\n                k-=pos;\\n                res.push_back(\\'V\\');\\n                h--;\\n            }\\n            else\\n            {\\n                res.push_back(\\'H\\');\\n                w--;\\n            }\\n        }\\n        while(h>0)\\n        {\\n            res.push_back(\\'V\\');\\n            h--;\\n        }\\n        while(w>0)\\n        {\\n            res.push_back(\\'H\\');\\n            w--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long fac[32];\\n    int mod=1000000007;\\n    void pre()\\n    {\\n        fac[0]=1;\\n        for(long long i=1;i<=30;++i)\\n        {\\n            fac[i]=(fac[i-1]*i)%mod;\\n        }\\n    }\\n    long long power(long long a,int b)\\n    {\\n        if(b==0)return 1;\\n        long long p=power(a,b/2);\\n        p=(p*p)%mod;\\n        if(b&1)\\n        {\\n            p=(p*a)%mod;\\n        }\\n        return p;\\n    }\\n    long long modInverse(long long a)\\n    {\\n        return power(a,mod-2)%mod;\\n    }\\n    long long nCr(int n,int r)\\n    {\\n        if(n<r)return 0;\\n        if(r==0)return 1;\\n        \\n        return ((((fac[n]%mod)*(modInverse(fac[r]%mod)%mod))%mod)*(modInverse(fac[n-r]%mod)%mod))%mod;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        pre();\\n        int h=destination[0],w=destination[1];\\n        string res=\"\";\\n        while(h>0&&w>0)\\n        {\\n            long long pos=nCr(h+w-1,w-1);\\n            //cout<<pos<<\" \";\\n            if(pos<k)\\n            {\\n                k-=pos;\\n                res.push_back(\\'V\\');\\n                h--;\\n            }\\n            else\\n            {\\n                res.push_back(\\'H\\');\\n                w--;\\n            }\\n        }\\n        while(h>0)\\n        {\\n            res.push_back(\\'V\\');\\n            h--;\\n        }\\n        while(w>0)\\n        {\\n            res.push_back(\\'H\\');\\n            w--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2540479,
                "title": "70-faster-simple-greedy-solution",
                "content": "```\\nclass Solution {\\n    int ncr(int n,int r){\\n        long long int nom=1;\\n        long long int den=1;\\n        \\n        for(int i=r;i>0;i--){\\n            int newNom=n-(r-i);\\n            int newDen=i;\\n            \\n            nom*=newNom;\\n            den*=newDen;\\n        }\\n        \\n        return nom/den;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int zero=destination[1];\\n        int ones=destination[0];\\n        string ans=\"\";\\n        int tot=zero+ones;\\n        int len=tot;\\n        for(int i=0;i<len;i++){\\n           // can i place a  zero \\n            if(zero>0 && ones>0){\\n                int can = ncr(tot-1,zero-1);\\n                if(can>=k){\\n                    ans+=\\'H\\';\\n                    zero--;\\n                }\\n                else{\\n                    k-=can;\\n                    ans+=\\'V\\';\\n                    ones--;\\n                }\\n                \\n            }\\n            else if(zero==0) {\\n                ans+=\\'V\\';\\n                ones--;\\n            }\\n            else if(ones==0){\\n                ans+=\\'H\\';\\n                zero--;\\n            }\\n            \\n            tot--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ncr(int n,int r){\\n        long long int nom=1;\\n        long long int den=1;\\n        \\n        for(int i=r;i>0;i--){\\n            int newNom=n-(r-i);\\n            int newDen=i;\\n            \\n            nom*=newNom;\\n            den*=newDen;\\n        }\\n        \\n        return nom/den;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int zero=destination[1];\\n        int ones=destination[0];\\n        string ans=\"\";\\n        int tot=zero+ones;\\n        int len=tot;\\n        for(int i=0;i<len;i++){\\n           // can i place a  zero \\n            if(zero>0 && ones>0){\\n                int can = ncr(tot-1,zero-1);\\n                if(can>=k){\\n                    ans+=\\'H\\';\\n                    zero--;\\n                }\\n                else{\\n                    k-=can;\\n                    ans+=\\'V\\';\\n                    ones--;\\n                }\\n                \\n            }\\n            else if(zero==0) {\\n                ans+=\\'V\\';\\n                ones--;\\n            }\\n            else if(ones==0){\\n                ans+=\\'H\\';\\n                zero--;\\n            }\\n            \\n            tot--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531153,
                "title": "python-combinations-and-dp",
                "content": "Build string from left to right using combinations.\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        Vs = destination[0]\\n        Hs = destination[1]\\n        pathLengthLeft = Vs + Hs\\n        path = []\\n        \\n        # Calculating factorials takes time, so I cache the results from math.factorial\\n        factCache = {0: 1}\\n\\n        def cFactorial(n):\\n            if n not in factCache:\\n                factCache[n] = math.factorial(n)\\n            return factCache[n]\\n        \\n        # Pick k from n or return 0 for \"not possible\"\\n        def combinations(n, k):\\n            if n-k < 0:\\n                return 0\\n            return cFactorial(n) // (cFactorial(k) * cFactorial(n-k))\\n            \\n        # Build string from left to right.\\n        # If k is greater than the number of ways to place the V\\'s in a string\\n        # that\\'s one space shorter then the leftmost space must be a V, else it\\'s a H.\\n        # This gives us lexagraphical ordering.\\n        #\\n        # Reduce the pathLength by 1, and remove the V or H you just used, then repeat the above.\\n        while Vs or Hs:\\n            combinationsForSubString = combinations(pathLengthLeft-1, Vs)\\n            if k > combinationsForSubString:\\n                k -= combinationsForSubString\\n                path.append(\\'V\\')\\n                Vs -= 1\\n            else:\\n                path.append(\\'H\\')\\n                Hs -= 1\\n            pathLengthLeft -= 1\\n        return \\'\\'.join(path)\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        Vs = destination[0]\\n        Hs = destination[1]\\n        pathLengthLeft = Vs + Hs\\n        path = []\\n        \\n        # Calculating factorials takes time, so I cache the results from math.factorial\\n        factCache = {0: 1}",
                "codeTag": "Java"
            },
            {
                "id": 2515176,
                "title": "c-soln-using-combination-of-similar-objects",
                "content": "```\\nclass Solution {\\npublic:\\n    int nCr(int n, int r){\\n        if(r > n - r) r = n - r;\\n        long long ans = 1;\\n        int i;\\n        for(i = 1; i <= r; i++) {\\n            ans *= (n - r + i);\\n            ans /= i;\\n        }\\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int h=destination[1],v=destination[0];\\n        long long n=0;\\n        string ans=\"\";\\n        while(h && v){\\n            int x=nCr(h+v-1,h-1);\\n            if(x+n<k){\\n                v--;\\n                n+=x;\\n                ans.push_back(\\'V\\');\\n            }\\n            else{\\n                h--;\\n                ans.push_back(\\'H\\');\\n            }\\n        }\\n        if(v){\\n            for(int i=0;i<v;i++)    ans.push_back(\\'V\\');\\n        }\\n        if(h){\\n            for(int i=0;i<h;i++)    ans.push_back(\\'H\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nCr(int n, int r){\\n        if(r > n - r) r = n - r;\\n        long long ans = 1;\\n        int i;\\n        for(i = 1; i <= r; i++) {\\n            ans *= (n - r + i);\\n            ans /= i;\\n        }\\n        return ans;\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int h=destination[1],v=destination[0];\\n        long long n=0;\\n        string ans=\"\";\\n        while(h && v){\\n            int x=nCr(h+v-1,h-1);\\n            if(x+n<k){\\n                v--;\\n                n+=x;\\n                ans.push_back(\\'V\\');\\n            }\\n            else{\\n                h--;\\n                ans.push_back(\\'H\\');\\n            }\\n        }\\n        if(v){\\n            for(int i=0;i<v;i++)    ans.push_back(\\'V\\');\\n        }\\n        if(h){\\n            for(int i=0;i<h;i++)    ans.push_back(\\'H\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303536,
                "title": "c-rust-recursive-combination",
                "content": "**C++ Code**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint comb(int n, int r){\\n\\t\\t\\tif(r>n)return 0;\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(int i=1;i<=r;i++)res=res*(n-i+1)/i;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tstring kthSmallestPath(vector<int>& destination, int k) {\\n\\t\\t\\tint V=destination[0];        \\n\\t\\t\\tint H=destination[1];\\n\\t\\t\\tif(V==0 || H==0 || k==1){\\n\\t\\t\\t\\tstring s=\"\";\\n\\t\\t\\t\\tfor(int i=0;i<H;i++)s.push_back(\\'H\\');            \\n\\t\\t\\t\\tfor(int i=0;i<V;i++)s.push_back(\\'V\\');\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t\\tint count = comb(V+H-1,V);\\n\\t\\t\\tif (count >= k) {\\n\\t\\t\\t\\tdestination[1]-=1;\\n\\t\\t\\t\\treturn \"H\" + kthSmallestPath(destination,k);\\n\\t\\t\\t}\\n\\t\\t\\tdestination[0]-=1;\\n\\t\\t\\treturn \"V\" + kthSmallestPath(destination,k-count);\\n\\t\\t}\\n\\t};\\n\\n**Rust Code**\\n\\n\\timpl Solution {\\n\\t\\tfn comb(n: i32, r: i32) -> i32 {\\n\\t\\t\\tif r>n{return 0;}\\n\\t\\t\\t(1..=r).fold(1, |acc, i| acc*(n-i+1)/i)\\n\\t\\t}\\n\\t\\tpub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n\\t\\t\\tlet (V,H) = (destination[0], destination[1]);\\n\\t\\t\\tif V==0 || H==0 || k==1 {\\n\\t\\t\\t\\tlet mut s = String::with_capacity((H+V)as usize);\\n\\t\\t\\t\\tfor _  in 0..H {s.push(\\'H\\')};\\n\\t\\t\\t\\tfor _  in 0..V {s.push(\\'V\\')};\\n\\t\\t\\t\\treturn s\\n\\t\\t\\t}\\n\\t\\t\\tlet count = Self::comb(V+H-1, V);\\n\\t\\t\\tif k<= count {\\n\\t\\t\\t\\tlet destination: Vec<i32> = vec![V,H-1];\\n\\t\\t\\t\\treturn \"H\".to_string() + Self::kth_smallest_path(destination, k).as_str();\\n\\t\\t\\t}\\n\\t\\t\\tlet destination: Vec<i32> = vec![V-1,H];\\n\\t\\t\\t\"V\".to_string() + Self::kth_smallest_path(destination, k - count).as_str()\\n\\t\\t}\\n\\t}\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Rust"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint comb(int n, int r){\\n\\t\\t\\tif(r>n)return 0;\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(int i=1;i<=r;i++)res=res*(n-i+1)/i;\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2298988,
                "title": "easy-basic-maths-python-solution-faster-than-90",
                "content": "\\tclass Solution:\\n\\t\\tdef kthSmallestPath(self, dest: List[int], k: int) -> str:\\n\\t\\t\\tn = sum(dest)\\n\\t\\t\\tfact = [1]\\n\\t\\t\\tcurr = \"\"\\n\\t\\t\\tfor i in range(1, 31):\\n\\t\\t\\t\\tfact.append(i*fact[i-1])\\n\\t\\t\\ti = 1\\n\\t\\t\\twhile i <= n:\\n\\t\\t\\t\\tln = n-i\\n\\t\\t\\t\\tf1 = fact[ln]\\n\\t\\t\\t\\th = fact[dest[1]-1]\\n\\t\\t\\t\\tv = fact[dest[0]]\\n\\t\\t\\t\\tval = f1//(v*h)\\n\\t\\t\\t\\tif val >= k:\\n\\t\\t\\t\\t\\tdest[1] -= 1\\n\\t\\t\\t\\t\\tcurr = curr + \"H\"\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tk = k - val\\n\\t\\t\\t\\t\\tcurr = curr + \"V\"\\n\\t\\t\\t\\t\\tdest[0] -= 1\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn curr\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef kthSmallestPath(self, dest: List[int], k: int) -> str:\\n\\t\\t\\tn = sum(dest)\\n\\t\\t\\tfact = [1]\\n\\t\\t\\tcurr = \"\"\\n\\t\\t\\tfor i in range(1, 31):\\n\\t\\t\\t\\tfact.append(i*fact[i-1])\\n\\t\\t\\ti = 1\\n\\t\\t\\twhile i <= n:\\n\\t\\t\\t\\tln = n-i\\n\\t\\t\\t\\tf1 = fact[ln]\\n\\t\\t\\t\\th = fact[dest[1]-1]\\n\\t\\t\\t\\tv = fact[dest[0]]\\n\\t\\t\\t\\tval = f1//(v*h)\\n\\t\\t\\t\\tif val >= k:\\n\\t\\t\\t\\t\\tdest[1] -= 1\\n\\t\\t\\t\\t\\tcurr = curr + \"H\"\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tk = k - val\\n\\t\\t\\t\\t\\tcurr = curr + \"V\"\\n\\t\\t\\t\\t\\tdest[0] -= 1\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn curr\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2284034,
                "title": "c-solution-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        long long dp[101][101];\\n        int r = d[0], c = d[1];\\n        for(int i = r; i >= 0; i--) {\\n            for(int j = c; j >= 0; j--) {\\n                if(i == r and j == c) dp[i][j] = 1;\\n                else dp[i][j] = (i+1 <= r?dp[i+1][j]:0)+(j+1 <= c?dp[i][j+1]:0);\\n            }\\n        }\\n        \\n        int i = 0, j = 0;\\n        long long t = k;\\n        string s;\\n        while(!(i == r and j == c)) {\\n            if(j+1 <= c and dp[i][j+1] >= t) s += \\'H\\', j++;\\n            else s += \\'V\\',  t -= ((j+1 <= c)? dp[i][j+1]:0), i++;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        long long dp[101][101];\\n        int r = d[0], c = d[1];\\n        for(int i = r; i >= 0; i--) {\\n            for(int j = c; j >= 0; j--) {\\n                if(i == r and j == c) dp[i][j] = 1;\\n                else dp[i][j] = (i+1 <= r?dp[i+1][j]:0)+(j+1 <= c?dp[i][j+1]:0);\\n            }\\n        }\\n        \\n        int i = 0, j = 0;\\n        long long t = k;\\n        string s;\\n        while(!(i == r and j == c)) {\\n            if(j+1 <= c and dp[i][j+1] >= t) s += \\'H\\', j++;\\n            else s += \\'V\\',  t -= ((j+1 <= c)? dp[i][j+1]:0), i++;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264515,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public String kthSmallestPath(int[] destination, int k) {\\n        \\n        int m = destination[0];\\n        int n = destination[1];\\n        \\n        int dp[][] = new int[m+1][n+1];\\n        //first we need to figer out how many possible way\\'s are there to reach the destination\\n        for(int i = m; i >= 0; i--)\\n        {\\n            for(int j = n; j >= 0 ; j--)\\n            {\\n                if(i == m && j == n ) dp[i][j] = 1;\\n                else if( i == m) dp[i][j] = dp[i][j+1];\\n                else if(j == n) dp[i][j] = dp[i+1][j];\\n                else dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        //now one thing we have to note here that\\n        // k = 1 then there is fixed path\\n        //k = 2 then H(right direction) will reduce\\n        // k = destination then start with v\\n        //so why not we move such a way\\n        helper(0, 0, k, sb, dp);\\n        return sb.toString();\\n        \\n    }\\n    \\n    //In helper funtion what we are doing we just travelling according to dp see below\\n    public void helper(int i, int j, int k, StringBuilder sb, int dp[][]){\\n        \\n        \\n        //if we reach to the last row then we have only one option go to right\\n        if(i == dp.length-1){\\n            while(++j < dp[0].length) sb.append(\"H\");\\n            return;\\n        }\\n        //if we reach last column then we have only one direction go to down\\n        if(j == dp[0].length-1){\\n            while(++i < dp.length) sb.append(\"V\");\\n            return;\\n        }\\n        \\n        //In dp we have store that this i and j how many possible ways we can reach to destination\\n        //so we are checking like\\n        //if k is smaller then have come wrong place(down[V]) so we have to move right\\n        if(k <= dp[i][j+1]){\\n            sb.append(\"H\");\\n            helper(i, j+1, k, sb, dp);\\n        }else{\\n            //if our k is greater then we reach to specific index now we have to move down only to\\n            //reach the destination\\n            sb.append(\"V\");\\n            helper(i+1, j,k - dp[i][j+1], sb, dp);\\n        }\\n        \\n        \\n        \\n        \\n        \\n    }\\n   \\n}\\n```\\nI have seen this solution on discussion section just get to know and try to simplify here!!",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String kthSmallestPath(int[] destination, int k) {\\n        \\n        int m = destination[0];\\n        int n = destination[1];\\n        \\n        int dp[][] = new int[m+1][n+1];\\n        //first we need to figer out how many possible way\\'s are there to reach the destination\\n        for(int i = m; i >= 0; i--)\\n        {\\n            for(int j = n; j >= 0 ; j--)\\n            {\\n                if(i == m && j == n ) dp[i][j] = 1;\\n                else if( i == m) dp[i][j] = dp[i][j+1];\\n                else if(j == n) dp[i][j] = dp[i+1][j];\\n                else dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n            }\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        //now one thing we have to note here that\\n        // k = 1 then there is fixed path\\n        //k = 2 then H(right direction) will reduce\\n        // k = destination then start with v\\n        //so why not we move such a way\\n        helper(0, 0, k, sb, dp);\\n        return sb.toString();\\n        \\n    }\\n    \\n    //In helper funtion what we are doing we just travelling according to dp see below\\n    public void helper(int i, int j, int k, StringBuilder sb, int dp[][]){\\n        \\n        \\n        //if we reach to the last row then we have only one option go to right\\n        if(i == dp.length-1){\\n            while(++j < dp[0].length) sb.append(\"H\");\\n            return;\\n        }\\n        //if we reach last column then we have only one direction go to down\\n        if(j == dp[0].length-1){\\n            while(++i < dp.length) sb.append(\"V\");\\n            return;\\n        }\\n        \\n        //In dp we have store that this i and j how many possible ways we can reach to destination\\n        //so we are checking like\\n        //if k is smaller then have come wrong place(down[V]) so we have to move right\\n        if(k <= dp[i][j+1]){\\n            sb.append(\"H\");\\n            helper(i, j+1, k, sb, dp);\\n        }else{\\n            //if our k is greater then we reach to specific index now we have to move down only to\\n            //reach the destination\\n            sb.append(\"V\");\\n            helper(i+1, j,k - dp[i][j+1], sb, dp);\\n        }\\n        \\n        \\n        \\n        \\n        \\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163787,
                "title": "c-o-r-log-c-greedy-with-binary-search-beats-100-time-and-90-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //precomputed binomial coefficient table for O(1) lookups, this isn\\'t necessary if your language has a built in function for this\\n    static constexpr int pascals[30][16] = {\\n    {1},\\n    {1,1},\\n    {1,2,1},\\n    {1,3,3,1},\\n    {1,4,6,4,1},\\n    {1,5,10,10,5,1},\\n    {1,6,15,20,15,6,1},\\n    {1,7,21,35,35,21,7,1},\\n    {1,8,28,56,70,56,28,8,1},\\n    {1,9,36,84,126,126,84,36,9,1},\\n    {1,10,45,120,210,252,210,120,45,10,1},\\n    {1,11,55,165,330,462,462,330,165,55,11,1},\\n    {1,12,66,220,495,792,924,792,495,220,66,12,1},\\n    {1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1},\\n    {1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1},\\n    {1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1},\\n    {1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16},\\n    {1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136},\\n    {1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816},\\n    {1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876},\\n    {1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504},\\n    {1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264},\\n    {1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544},\\n    {1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314},\\n    {1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504},\\n    {1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760},\\n    {1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160},\\n    {1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860},\\n    {1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160},\\n    {1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760}};\\n    \\n    //since we\\'re dealing with lexicographically smallest string, index in this context will refer to the index when reading the string from right to left\\n    void binary_recurse(string &s, int n, int k, int previous){\\n        //if there are no more \\'V\\'s to place we\\'re done\\n        if (n == 0){\\n            return;\\n        }\\n        //there are n more \\'V\\'s left to place, so our lower bound will always start at n rather than at 0\\n        int lower = n;\\n        int upper = previous;\\n        //binary search over solution space for the index of the next \\'V\\' in the output\\n        while (lower < upper){\\n            int mid = (upper + lower)/2;\\n            //the number of paths that include all prior \\'V\\'s and a \\'V\\' at index mid \\n            int test = (pascals[mid][n-1] * (mid + 1 - n)) / n;\\n            if (test >= k){\\n                upper = mid;\\n            }\\n            else{\\n                lower = mid + 1;\\n            }\\n        }\\n        s[s.size() - upper] = \\'V\\';\\n        binary_recurse(s,n-1,k - (pascals[upper - 1][n-1] * (upper - n)) / n,upper);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[0];\\n        int m = destination[1];\\n        string output = string(n+m,\\'H\\');\\n        binary_recurse(output,n,k,n + m);\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //precomputed binomial coefficient table for O(1) lookups, this isn\\'t necessary if your language has a built in function for this\\n    static constexpr int pascals[30][16] = {\\n    {1},\\n    {1,1},\\n    {1,2,1},\\n    {1,3,3,1},\\n    {1,4,6,4,1},\\n    {1,5,10,10,5,1},\\n    {1,6,15,20,15,6,1},\\n    {1,7,21,35,35,21,7,1},\\n    {1,8,28,56,70,56,28,8,1},\\n    {1,9,36,84,126,126,84,36,9,1},\\n    {1,10,45,120,210,252,210,120,45,10,1},\\n    {1,11,55,165,330,462,462,330,165,55,11,1},\\n    {1,12,66,220,495,792,924,792,495,220,66,12,1},\\n    {1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1},\\n    {1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1},\\n    {1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1},\\n    {1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16},\\n    {1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136},\\n    {1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816},\\n    {1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876},\\n    {1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504},\\n    {1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264},\\n    {1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544},\\n    {1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314},\\n    {1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504},\\n    {1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760},\\n    {1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160},\\n    {1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860},\\n    {1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160},\\n    {1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760}};\\n    \\n    //since we\\'re dealing with lexicographically smallest string, index in this context will refer to the index when reading the string from right to left\\n    void binary_recurse(string &s, int n, int k, int previous){\\n        //if there are no more \\'V\\'s to place we\\'re done\\n        if (n == 0){\\n            return;\\n        }\\n        //there are n more \\'V\\'s left to place, so our lower bound will always start at n rather than at 0\\n        int lower = n;\\n        int upper = previous;\\n        //binary search over solution space for the index of the next \\'V\\' in the output\\n        while (lower < upper){\\n            int mid = (upper + lower)/2;\\n            //the number of paths that include all prior \\'V\\'s and a \\'V\\' at index mid \\n            int test = (pascals[mid][n-1] * (mid + 1 - n)) / n;\\n            if (test >= k){\\n                upper = mid;\\n            }\\n            else{\\n                lower = mid + 1;\\n            }\\n        }\\n        s[s.size() - upper] = \\'V\\';\\n        binary_recurse(s,n-1,k - (pascals[upper - 1][n-1] * (upper - n)) / n,upper);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int n = destination[0];\\n        int m = destination[1];\\n        string output = string(n+m,\\'H\\');\\n        binary_recurse(output,n,k,n + m);\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109504,
                "title": "o-r-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll get(ll h,ll v)\\n    {\\n        ll ans=1,j=2,k=2;\\n        for(int i=h+v;i>=1;i--)\\n        {\\n            ans*=i;\\n            while(j<=h && ans%j==0) ans/=j,j++;\\n            while(k<=v && ans%k==0) ans/=k,k++;\\n        }\\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& a, int k) \\n    {\\n        int v=a[0],h=a[1];\\n        string ans=\"\";\\n        for(int i=0;i<a[0]+a[1];i++)\\n        {\\n            ll c=get(h-1,v);\\n            if(c>=k && h) ans+=\\'H\\',h--;\\n            else  ans+=\\'V\\',v--,k-=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll get(ll h,ll v)\\n    {\\n        ll ans=1,j=2,k=2;\\n        for(int i=h+v;i>=1;i--)\\n        {\\n            ans*=i;\\n            while(j<=h && ans%j==0) ans/=j,j++;\\n            while(k<=v && ans%k==0) ans/=k,k++;\\n        }\\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& a, int k) \\n    {\\n        int v=a[0],h=a[1];\\n        string ans=\"\";\\n        for(int i=0;i<a[0]+a[1];i++)\\n        {\\n            ll c=get(h-1,v);\\n            if(c>=k && h) ans+=\\'H\\',h--;\\n            else  ans+=\\'V\\',v--,k-=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105763,
                "title": "cpp-dynamic-programmming-pascal-triangle-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int pascalTri[31][32] = {};\\n        \\n    void presolve(){\\n        pascalTri[0][0] = pascalTri[1][0] = pascalTri[1][1] = 1;\\n        for(int i=2;i<31;i++){\\n            pascalTri[i][0] = 1;\\n            for(int j=1;j<=i;j++){\\n                pascalTri[i][j] = pascalTri[i-1][j] + pascalTri[i-1][j-1];\\n            }\\n        }\\n    }\\n    \\n    string ans = \"\";\\n    \\n    void find(int numh, int numv, int k){\\n        if(numh + numv == 0) return;\\n        \\n        long long int tempk = pascalTri[numh + numv - 1][max(numh - 1, numv)];\\n        \\n        if(tempk >= k){\\n            ans.push_back(\\'H\\');\\n            find(numh - 1, numv, k);\\n        }\\n        else{\\n            k -= tempk;\\n            ans.push_back(\\'V\\');\\n            find(numh, numv - 1, k);\\n        }\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        presolve();\\n        int numH = destination[1];\\n        int numV = destination[0];\\n        \\n        find(numH, numV, k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int pascalTri[31][32] = {};\\n        \\n    void presolve(){\\n        pascalTri[0][0] = pascalTri[1][0] = pascalTri[1][1] = 1;\\n        for(int i=2;i<31;i++){\\n            pascalTri[i][0] = 1;\\n            for(int j=1;j<=i;j++){\\n                pascalTri[i][j] = pascalTri[i-1][j] + pascalTri[i-1][j-1];\\n            }\\n        }\\n    }\\n    \\n    string ans = \"\";\\n    \\n    void find(int numh, int numv, int k){\\n        if(numh + numv == 0) return;\\n        \\n        long long int tempk = pascalTri[numh + numv - 1][max(numh - 1, numv)];\\n        \\n        if(tempk >= k){\\n            ans.push_back(\\'H\\');\\n            find(numh - 1, numv, k);\\n        }\\n        else{\\n            k -= tempk;\\n            ans.push_back(\\'V\\');\\n            find(numh, numv - 1, k);\\n        }\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        presolve();\\n        int numH = destination[1];\\n        int numV = destination[0];\\n        \\n        find(numH, numV, k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083572,
                "title": "go-beats-100",
                "content": "This is a go implementation based on suggested solutions from dicussion. The two solutions I came up were exceeding time limit. \\n\\n```\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tdx, dy := destination[0], destination[1]\\n\\n\\tm := make([][]int, dx+1)\\n\\tfor i := 0; i < dx+1; i++ {\\n\\t\\tm[i] = make([]int, dy+1)\\n\\t}\\n\\n\\tfor i := 0; i <= dx; i++ {\\n\\t\\tfor j := 0; j <= dy; j++ {\\n\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\tm[i][j] = 1\\n\\t\\t\\t} else if i == 0 {\\n\\t\\t\\t\\tm[i][j] = m[i][j-1]\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\tm[i][j] = m[i-1][j]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tm[i][j] = m[i][j-1] + m[i-1][j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tresult := \"\"\\n\\n\\tfor dx > 0 && dy > 0 {\\n \\t\\tif m[dx][dy-1] >= k {\\n\\t\\t\\tdy--\\n\\t\\t\\tresult += \"H\"\\n\\t\\t} else {\\n\\t\\t\\tk -= m[dx][dy-1]\\n\\t\\t\\tdx--\\n\\t\\t\\tresult += \"V\"\\n\\t\\t}\\n\\t}\\n\\n\\tfor dx > 0 {\\n\\t\\tdx--\\n\\t\\tresult += \"V\"\\n\\t}\\n\\tfor dy > 0 {\\n\\t\\tdy--\\n\\t\\tresult += \"H\"\\n\\t}\\n\\n\\treturn result\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tdx, dy := destination[0], destination[1]\\n\\n\\tm := make([][]int, dx+1)\\n\\tfor i := 0; i < dx+1; i++ {\\n\\t\\tm[i] = make([]int, dy+1)\\n\\t}\\n\\n\\tfor i := 0; i <= dx; i++ {\\n\\t\\tfor j := 0; j <= dy; j++ {\\n\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\tm[i][j] = 1\\n\\t\\t\\t} else if i == 0 {\\n\\t\\t\\t\\tm[i][j] = m[i][j-1]\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\tm[i][j] = m[i-1][j]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tm[i][j] = m[i][j-1] + m[i-1][j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tresult := \"\"\\n\\n\\tfor dx > 0 && dy > 0 {\\n \\t\\tif m[dx][dy-1] >= k {\\n\\t\\t\\tdy--\\n\\t\\t\\tresult += \"H\"\\n\\t\\t} else {\\n\\t\\t\\tk -= m[dx][dy-1]\\n\\t\\t\\tdx--\\n\\t\\t\\tresult += \"V\"\\n\\t\\t}\\n\\t}\\n\\n\\tfor dx > 0 {\\n\\t\\tdx--\\n\\t\\tresult += \"V\"\\n\\t}\\n\\tfor dy > 0 {\\n\\t\\tdy--\\n\\t\\tresult += \"H\"\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006845,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }\\npublic:\\n    string kthSmallestPath(vector<int>& A, int k) {\\n        int h = A[1], v = A[0], N = h + v;\\n        string s;\\n        for (int i = 0; i < N; ++i) {\\n            if (h) { // we have H available to pick\\n                int c = comb(h - 1 + v, v); // number of combinations\\n                if (k <= c) s.push_back(\\'H\\'), h--; // pick H as k in within range\\n                else s.push_back(\\'V\\'), v--, k -= c; // otherwise pick V\\n            } else s.push_back(\\'V\\');\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "class Solution {\\n    int comb(int n, int r) {\\n        long ans = 1;\\n        for (int i = 1, j = n - r + 1; i <= r; ++i, ++j) ans = ans * j / i;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1965604,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        result=[]\\n        r=destination[0]\\n        c=destination[1]\\n        down=r\\n        for i in range(r+c):\\n            total=r+c-(i+1)\\n            step=comb(total,down)\\n            if step>=k:\\n                result.append(\\'H\\')\\n            else:\\n                down-=1\\n                result.append(\\'V\\')\\n                k-=step\\n        return \\'\\'.join(result)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        result=[]\\n        r=destination[0]\\n        c=destination[1]\\n        down=r\\n        for i in range(r+c):\\n            total=r+c-(i+1)\\n            step=comb(total,down)\\n            if step>=k:\\n                result.append(\\'H\\')\\n            else:\\n                down-=1\\n                result.append(\\'V\\')\\n                k-=step\\n        return \\'\\'.join(result)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906056,
                "title": "10-lines-simpe-recursion-solution-python",
                "content": "```\\nimport math\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        vcnt,hcnt = destination\\n        if k==1 or vcnt==0 or hcnt==0:\\n            return \"\".join([\"H\"]*hcnt+[\"V\"]*vcnt)\\n        smallerCnt = math.comb(hcnt+vcnt-1,vcnt)\\n        if smallerCnt>=k:\\n            return \"H\"+self.kthSmallestPath([vcnt,hcnt-1],k)\\n        return \"V\"+self.kthSmallestPath([vcnt-1,hcnt],k-smallerCnt)\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        vcnt,hcnt = destination\\n        if k==1 or vcnt==0 or hcnt==0:\\n            return \"\".join([\"H\"]*hcnt+[\"V\"]*vcnt)\\n        smallerCnt = math.comb(hcnt+vcnt-1,vcnt)\\n        if smallerCnt>=k:\\n            return \"H\"+self.kthSmallestPath([vcnt,hcnt-1],k)\\n        return \"V\"+self.kthSmallestPath([vcnt-1,hcnt],k-smallerCnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882587,
                "title": "python-narrowing-down-search-simple-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        row, col = destination\\n        currow, curcol = 0, 0\\n        res = []\\n        while curcol < col and currow < row:\\n            cnt = comb(row-currow+col-curcol-1, row-currow)\\n            if cnt >= k:\\n                curcol += 1\\n                res.append(\"H\")\\n            else:\\n                currow += 1\\n                k -= cnt\\n                res.append(\"V\")\\n        res.extend([\"H\"]*(col-curcol))\\n        res.extend([\"V\"]*(row-currow))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        row, col = destination\\n        currow, curcol = 0, 0\\n        res = []\\n        while curcol < col and currow < row:\\n            cnt = comb(row-currow+col-curcol-1, row-currow)\\n            if cnt >= k:\\n                curcol += 1\\n                res.append(\"H\")\\n            else:\\n                currow += 1\\n                k -= cnt\\n                res.append(\"V\")\\n        res.extend([\"H\"]*(col-curcol))\\n        res.extend([\"V\"]*(row-currow))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817760,
                "title": "c",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Kth Smallest Instructions.\\nMemory Usage: 15.4 MB, less than 55.15% of C++ online submissions for Kth Smallest Instructions.\\n\\nI think we should change to  int cnt[16][16]; \\n\\n```\\nclass Solution {\\npublic:\\n\\n    string res;\\n    int cnt[16][16];\\n    string kthSmallestPath(vector<int>& des, int k) {\\n          int m=des[0]+1,n=des[1]+1; //1-indexed\\n          //dp\\n          //ask: destination is null?  \\n          //ask: k is always greater than 0?\\n          //ask: destination contains only x1, y1? destination.length == 2\\n          //ask: destination is always valid? or could be (0,0)?\\n          //ask: is the maze a matrix? how about [[2,3][2]]\\n          //H come before V \\n          for(int x = m-1; x>=0; x--){\\n              for(int y = n-1; y>=0; y--){\\n                  if(x==m-1 || y==n-1){\\n                      cnt[x][y] = 1; \\n                      continue;\\n                  }\\n                  cnt[x][y] = cnt[x][y+1] + cnt[x+1][y];\\n              }\\n          }\\n          int i = 0, j = 0;\\n          while(i<m-1 && j<n-1){\\n              if(k<=cnt[i][j+1]){\\n                  res+=\"H\";j++;\\n              }else{\\n                  k=k-cnt[i][j+1];\\n                  res+=\"V\";i++;\\n              }\\n          }\\n        \\n          while(j++<n-1) res+=\"H\";\\n          while(i++<m-1) res+=\"V\";\\n          \\n              \\n         return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string res;\\n    int cnt[16][16];\\n    string kthSmallestPath(vector<int>& des, int k) {\\n          int m=des[0]+1,n=des[1]+1; //1-indexed\\n          //dp\\n          //ask: destination is null?  \\n          //ask: k is always greater than 0?\\n          //ask: destination contains only x1, y1? destination.length == 2\\n          //ask: destination is always valid? or could be (0,0)?\\n          //ask: is the maze a matrix? how about [[2,3][2]]\\n          //H come before V \\n          for(int x = m-1; x>=0; x--){\\n              for(int y = n-1; y>=0; y--){\\n                  if(x==m-1 || y==n-1){\\n                      cnt[x][y] = 1; \\n                      continue;\\n                  }\\n                  cnt[x][y] = cnt[x][y+1] + cnt[x+1][y];\\n              }\\n          }\\n          int i = 0, j = 0;\\n          while(i<m-1 && j<n-1){\\n              if(k<=cnt[i][j+1]){\\n                  res+=\"H\";j++;\\n              }else{\\n                  k=k-cnt[i][j+1];\\n                  res+=\"V\";i++;\\n              }\\n          }\\n        \\n          while(j++<n-1) res+=\"H\";\\n          while(i++<m-1) res+=\"V\";\\n          \\n              \\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779475,
                "title": "python-o-m-n-min-m-n-solution-with-explanation-beats-100",
                "content": "We just choose chars one by one.\\nSay there are c_h \\'H\\' and c_v \\'V\\' could be chose, and the rank is k-th (0-index).\\nObviously the length of string is c_h + c_v.\\nThen which one should we choose?\\nIf there is not any \\'H\\' could be chose, we just select \\'V\\', and decrement c_v by 1.\\nIf there are still some \\'H\\', we just calculate the ways of the string with leading \\'H\\' cnt = nCr(c_h + c_v - 1, c_v), which means choos c_v locations from c_h + c_v - 1 positions to locate \\'V\\'.\\nIf k < cnt, then the char must be \\'H\\', decreament c_h by 1;\\notherwise, the char must be \\'V\\', and the rank will be k - cnt, decreament c_v by 1.\\n```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def select(m, n):\\n            n = min(n, m - n)\\n            den, num = 1, 1\\n            for t in range(n):\\n                num *= m - t\\n                den *= n - t\\n            return num // den\\n\\n        cnt_v, cnt_h = destination\\n        size = cnt_v + cnt_h\\n        k -= 1\\n        ans = []\\n        for i in range(size):\\n            if cnt_h == 0:\\n                ans.append(\\'V\\')\\n                cnt_v -= 1\\n            else:\\n                cnt = select(size - i - 1, cnt_v)\\n                if k < cnt:\\n                    ans.append(\\'H\\')\\n                    cnt_h -= 1\\n                else:\\n                    ans.append(\\'V\\')\\n                    cnt_v -= 1\\n                    k -= cnt\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def select(m, n):\\n            n = min(n, m - n)\\n            den, num = 1, 1\\n            for t in range(n):\\n                num *= m - t\\n                den *= n - t\\n            return num // den\\n\\n        cnt_v, cnt_h = destination\\n        size = cnt_v + cnt_h\\n        k -= 1\\n        ans = []\\n        for i in range(size):\\n            if cnt_h == 0:\\n                ans.append(\\'V\\')\\n                cnt_v -= 1\\n            else:\\n                cnt = select(size - i - 1, cnt_v)\\n                if k < cnt:\\n                    ans.append(\\'H\\')\\n                    cnt_h -= 1\\n                else:\\n                    ans.append(\\'V\\')\\n                    cnt_v -= 1\\n                    k -= cnt\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748036,
                "title": "python-no-dp-no-recursion-no-comb-only-loops",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n      h,w = destination\\n      \\n      index = 0\\n      res = [\\'H\\']*(h+w)\\n      \\n      while index < h:\\n        curs = 1 # sum of cur, C(h-1,h-1) + C(h,h-1) + C(h+1,h-1)...\\n        cur = 1 # cur, C(h-1,h-1) , C(h,h-1) , C(h+1,h-1)...\\n        up = h - index\\n        down = 1\\n        prev = 0\\n        while curs < k:\\n          prev = curs\\n          cur= cur * up // down\\n          up,down = up + 1,down + 1\\n          curs += cur\\n\\n        k -= prev\\n        res[-up] = \\'V\\'\\n        index += 1\\n        \\n      return \\'\\'.join(res)\\n```\\nIdea is simple to explain in an interview.\\nFirst we have h elements to set in h+w blanks, then we loop h times to set them.\\nInside each loop, subtract the number of combinations less than kth combination from k, and set the position of the left most element.\\n\\n",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n      h,w = destination\\n      \\n      index = 0\\n      res = [\\'H\\']*(h+w)\\n      \\n      while index < h:\\n        curs = 1 # sum of cur, C(h-1,h-1) + C(h,h-1) + C(h+1,h-1)...\\n        cur = 1 # cur, C(h-1,h-1) , C(h,h-1) , C(h+1,h-1)...\\n        up = h - index\\n        down = 1\\n        prev = 0\\n        while curs < k:\\n          prev = curs\\n          cur= cur * up // down\\n          up,down = up + 1,down + 1\\n          curs += cur\\n\\n        k -= prev\\n        res[-up] = \\'V\\'\\n        index += 1\\n        \\n      return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734399,
                "title": "python-28-ms-14-lines-of-code-beats-98-py-solutions",
                "content": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\tl = destination[0]\\n\\tn = destination[0] + destination[1]\\n\\tperm = [\\'H\\'] * n\\n\\twhile True and n >= l and k > 0:\\n\\t\\tif k == 1:\\n\\t\\t\\tperm[0:l] = [\\'V\\'] * l\\n\\t\\t\\tbreak\\n\\t\\tlower = comb(n-1, l) + 1\\n\\t\\tif k >= lower:\\n\\t\\t\\tperm[n-1] = \\'V\\'\\n\\t\\t\\tl-= 1\\n\\t\\t\\tk = k - lower + 1\\n\\t\\tn -= 1\\n\\treturn \"\".join(perm[::-1])\\n\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\tl = destination[0]\\n\\tn = destination[0] + destination[1]\\n\\tperm = [\\'H\\'] * n\\n\\twhile True and n >= l and k > 0:\\n\\t\\tif k == 1:\\n\\t\\t\\tperm[0:l] = [\\'V\\'] * l\\n\\t\\t\\tbreak\\n\\t\\tlower = comb(n-1, l) + 1\\n\\t\\tif k >= lower:\\n\\t\\t\\tperm[n-1] = \\'V\\'\\n\\t\\t\\tl-= 1\\n\\t\\t\\tk = k - lower + 1\\n\\t\\tn -= 1\\n\\treturn \"\".join(perm[::-1])\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1609523,
                "title": "c-concise-and-efficient-solution-explained-using-maths",
                "content": "There are `nCk(m + n, m) = nCk(m + n, n)` solutions to go from `(0, 0)` to `(m, n)` because we have to perform `m` moves down and `n` moves right, regardless of the order. So the idea is to check step by step how many paths start with `H` given a certain position. To do that, just compute `nCk(m + (n - 1), m)` because it is the number of such solutions if we go right (decrease `n`). Then there are two possibilities : \\n* `k <= nCk(m + (n - 1), m)` which means that the next letter has to be `H`\\n* `k > nCk(m + (n - 1), m)` which means that next letter is `V`. From that point, we decrease `k` by those result and proceed recursively from the next position updated.\\n\\n(The `nCr` function uses sucessive fractions of `n / k` in order not to have to compute too large factorials that not fit a 32 bits integer)\\n\\n```\\nclass Solution {\\n   public:\\n    string kthSmallestPath(vector<int>& destination, int k) {      \\n        int m = destination[0], n = destination[1];     \\n        string ans = \"\";   \\n        while(m + n) {   \\n            int byH = n_choose_k(m + n - 1, m);        \\n            if(k <= byH) {\\n                ans += \"H\"; n--;\\n            } else { \\n                ans += \"V\"; m--; k -= byH;\\n            }\\n        }   \\n        return ans;\\n    }\\n    \\n    int n_choose_k(int n, int k) {\\n        double ans = 1.0;\\n        while(k > 0) \\n            ans *= ((double) n-- / k--);\\n        return round(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    string kthSmallestPath(vector<int>& destination, int k) {      \\n        int m = destination[0], n = destination[1];     \\n        string ans = \"\";   \\n        while(m + n) {   \\n            int byH = n_choose_k(m + n - 1, m);        \\n            if(k <= byH) {\\n                ans += \"H\"; n--;\\n            } else { \\n                ans += \"V\"; m--; k -= byH;\\n            }\\n        }   \\n        return ans;\\n    }\\n    \\n    int n_choose_k(int n, int k) {\\n        double ans = 1.0;\\n        while(k > 0) \\n            ans *= ((double) n-- / k--);\\n        return round(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570425,
                "title": "java-100-95-o-r-c-min-r-c-with-explanation",
                "content": "According to combinatorics, the number of ways to choose v identical objects from n total is (n choose v) = n! / [v! (n-v)!].  In this problem, interpret n as the sum of the horizontal and vertical steps (the sum of the values of the given destination array), and v as the number of vertical steps (destination[0]).\\n\\nThe key observation for this problem is that when all of the (n choose v) possible combinations are laid out in lexicographical order, the first (n - 1 choose v) of them begin with H, and the remaining ones begin with V.  Therefore, we can compare k to (n-1 choose v) to determine whether the first character is H or V.  Then, we reduce the problem to finding v or v-1 V\\'s within n-1 remaining positions.  To set up for the next iteration, if we found a V, reduce k by (n-1 choose v), and decrement v.  Regardless, reduce n by 1.  Repeat this process until all remaining characters are either H (v == 0) or V (v == n).\\n\\nFor example, suppose destination = [2,3] and k = 8.  Here, n = 2+3 = 5 and v = 2.  The (n choose v) = 5!/(2! 3!) = 10 possible arrangements of H and V, in lexicographical order, are:\\nHHHVV\\nHHVHV\\nHHVVH\\nHVHHV\\nHVHVH\\nHVVHH\\nVHHHV\\nVHHVH\\nVHVHH\\nVVHHH\\n\\nStart with n = 5, v = 2, k = 8.\\n* For the first character, calculate (n-1 choose v), which is 4!/(2! 2!) = 6.  In this case, k = 8 is larger than 6, so the first letter must be V.  Decrement n to 4 and v to 1, and reduce k by 6 to 2.  In other words, among the strings that start with V, we want to find the 2nd (kth) string.  There are 4 characters remaining, and only 1 V left to be found.\\n* For the second character, calculate (n-1 choose v), which is 3!/(1! 2!) = 3.  In this case, k = 2 is less than or equal to 3, so the second letter must be H.  Decrement n to 3.\\n* For the third character, calculate (n-1 choose v), which is 2!/(1! 1!) = 2.  In this case, k = 2 is less than or equal to 2, so the third letter must be H.  Decrement n to 2.\\n* For the fourth character, calculate (n-1 choose v), which is 1!/(1! 0!) = 1.  In this case, k = 2 is greater than 1, so the fourth letter must be V.  Decrement n to 1, v to 0, and reduce k by 1 to 1.\\n* Now v == 0, so there are no more Vs left to find.  The last character must be an H.\\n* Return the answer, VHHVH.\\n\\nTC = O((r+c) * min(r,c)), because there are r+c iterations (i.e. the number of steps to reach the destination), and computation of n choose k on each iteration requires looping for the smaller of the remaining horizontal and vertical steps.\\nSC = O(1)\\n\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int v = destination[0];  // number of Vs left to find\\n        int n = v + destination[1];  // number of digits left to find\\n        while (true) {\\n            int range = choose(--n, v);\\n            if (k <= range) sb.append(\\'H\\');\\n            else {\\n                sb.append(\\'V\\');\\n                v--;\\n                k -= range;\\n            }\\n\\n            // Check to see whether we are done\\n            if (v == 0) {\\n                // All remaining directions are H\\n                for (int i = 1; i <= n; i++) sb.append(\\'H\\');\\n                break;\\n            } else if (v == n) {\\n                // All remaining directions are V\\n                for (int i = 1; i <= v; i++) sb.append(\\'V\\');\\n                break;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    private int choose(int n, int k) {\\n        if (n-k < k) k = n-k;\\n        int answer = 1;\\n        for (int i = 1; i <= k; i++) answer = answer * (n+1 - i) / i;\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int v = destination[0];  // number of Vs left to find\\n        int n = v + destination[1];  // number of digits left to find\\n        while (true) {\\n            int range = choose(--n, v);\\n            if (k <= range) sb.append(\\'H\\');\\n            else {\\n                sb.append(\\'V\\');\\n                v--;\\n                k -= range;\\n            }\\n\\n            // Check to see whether we are done\\n            if (v == 0) {\\n                // All remaining directions are H\\n                for (int i = 1; i <= n; i++) sb.append(\\'H\\');\\n                break;\\n            } else if (v == n) {\\n                // All remaining directions are V\\n                for (int i = 1; i <= v; i++) sb.append(\\'V\\');\\n                break;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    private int choose(int n, int k) {\\n        if (n-k < k) k = n-k;\\n        int answer = 1;\\n        for (int i = 1; i <= k; i++) answer = answer * (n+1 - i) / i;\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538840,
                "title": "javascript-solution-faster-than-100-takes-up-less-memory-than-100",
                "content": "```\\nvar kthSmallestPath = function(destination, k, r, c) {\\n        return helper(destination[1],destination[0],k-1,\"\");\\n    }\\n    \\n    function helper( H,  V,  k, result){\\n        if(H==0&& V==0) return result;\\n        if(H==0) return helper(H,V-1,k,result+\"V\");\\n        if(V==0) return helper(H-1,V,k,result+\"H\");\\n        let combinationIfItStartsWithH = combination(H+V-1, Math.min(H-1, V));\\n        if(combinationIfItStartsWithH<=k){\\n            return helper(H,V-1,k-combinationIfItStartsWithH,result+\"V\");\\n        }\\n        return helper(H-1,V,k,result+\"H\");\\n    }\\n    \\n  function combination( M,  N){\\n        let result = 1;\\n        for(let i=0;i<N;i++){\\n            result *= M-i;\\n            result /=(i+1);\\n        }\\n        return result;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\nvar kthSmallestPath = function(destination, k, r, c) {\\n        return helper(destination[1],destination[0],k-1,\"\");\\n    }\\n    \\n    function helper( H,  V,  k, result){\\n        if(H==0&& V==0) return result;\\n        if(H==0) return helper(H,V-1,k,result+\"V\");\\n        if(V==0) return helper(H-1,V,k,result+\"H\");\\n        let combinationIfItStartsWithH = combination(H+V-1, Math.min(H-1, V));\\n        if(combinationIfItStartsWithH<=k){\\n            return helper(H,V-1,k-combinationIfItStartsWithH,result+\"V\");\\n        }\\n        return helper(H-1,V,k,result+\"H\");\\n    }\\n    \\n  function combination( M,  N){\\n        let result = 1;\\n        for(let i=0;i<N;i++){\\n            result *= M-i;\\n            result /=(i+1);\\n        }\\n        return result;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1494127,
                "title": "simple-elimination-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        \\n        int m=destination[0]+1, n=destination[1]+1;\\n        vector<vector<int> > dp(m, vector<int>(n, 1));\\n        \\n        for(int i=m;i--;){\\n            for(int j=n;j--;){\\n                int sum=0;\\n                if(i+1<m){\\n                    sum+=dp[i+1][j];\\n                }\\n                if(j+1<n){\\n                    sum+=dp[i][j+1];\\n                }\\n                dp[i][j]=max(1, sum);\\n                \\n            }\\n        }\\n        \\n        string ans(\"\");\\n        \\n        int i=0, j=0;\\n        \\n        while(i<m && j<n){\\n            if(dp[i][j]==k){\\n                if(m-i>1){\\n                    ans=ans+string(m-i-1, \\'V\\');\\n                }\\n                ans=ans+string(n-j-1, \\'H\\');\\n                return ans;\\n            }\\n            if(dp[i][j+1]<k){\\n                ans.push_back(\\'V\\');\\n                k-=dp[i][j+1];\\n                ++i;\\n            }\\n            else{\\n                ans.push_back(\\'H\\');\\n                ++j;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        \\n        int m=destination[0]+1, n=destination[1]+1;\\n        vector<vector<int> > dp(m, vector<int>(n, 1));\\n        \\n        for(int i=m;i--;){\\n            for(int j=n;j--;){\\n                int sum=0;\\n                if(i+1<m){\\n                    sum+=dp[i+1][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1436912,
                "title": "python-linear-solution-with-explanation-and-how-to-behave-when-being-asked-during-interview",
                "content": "### Construction\\nIf you familiar with standard dynamic programming problem of number of path to right bottom of grid, then you can get the idea that the path is combination of *n* chioces of going right, and *m* choice of going down. Then the number of path starting from left top to right bottom is the *nCr(m + n, m)*. \\nThen the naive solution is that we can get all of combinations and return the *k* th in the sorted order, which definitely not the accepted solution.\\nYou might come up with the solution for *find next smallest permutation* problem, so starting with the minimum path, such as `HHHHVVVV`, we find the next smallest combination using the solution at *k* times, which denotes **O(k\\\\*(m + n))** complexity. \\nIs there a better way? If we know the number of choices for respective *V* and *H*, then we can know how many path based on the fact we learned from the dp problem. Then we can iterate each position in the path, and try with *H* first to see how many choices of path we have for the rest of *V* and *H*. If the number is greater than *k*, then we must put *H*, otherwise we should put *V*. At the same time, we update *k* correspondingly. It makes *O(m + n)* complexity.\\n```python\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\t[count_v, count_h] = destination\\n    path = [0] * (count_h + count_v) \\n        \\n    for i in range(len(path)):\\n\\t\\ttry_h = comb(count_h - 1 + count_v, count_v)\\n        if try_h >= k:\\n\\t\\t\\tpath[i] = \\'H\\'\\n            count_h -= 1\\n\\t\\telse:\\n\\t\\t\\tpath[i] = \\'V\\' \\n            k = k - try_h\\n            count_v -= 1\\n\\treturn \\'\\'.join(path)\\n```\\n\\n*Time Complexity* = **O(m + n)**\\n*Space Complexity*= **O(1)**",
                "solutionTags": [],
                "code": "```python\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\t[count_v, count_h] = destination\\n    path = [0] * (count_h + count_v) \\n        \\n    for i in range(len(path)):\\n\\t\\ttry_h = comb(count_h - 1 + count_v, count_v)\\n        if try_h >= k:\\n\\t\\t\\tpath[i] = \\'H\\'\\n            count_h -= 1\\n\\t\\telse:\\n\\t\\t\\tpath[i] = \\'V\\' \\n            k = k - try_h\\n            count_v -= 1\\n\\treturn \\'\\'.join(path)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1420459,
                "title": "a-few-lines-of-python",
                "content": "```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def C(A,N):\\n            if A <= N: return 1\\n            return factorial(A)/factorial(A-N)/factorial(N)  \\n        \\n        def Assemble(H,V,K):\\n            if H == 0 or V == 0: return \\'H\\' * H + \\'V\\' * V\\n            total = C(H+V,V)\\n            if total <= K: return \\'V\\' * V + \\'H\\' * H\\n            else:\\n                lower = C(H+V-1,V)\\n                if lower >= K:\\n                    return \\'H\\' + Assemble(H-1,V, K)\\n                else:\\n                    return \\'V\\' + Assemble(H, V-1, K-lower)\\n            \\n        return Assemble(destination[1], destination[0], k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def C(A,N):\\n            if A <= N: return 1\\n            return factorial(A)/factorial(A-N)/factorial(N)  \\n        \\n        def Assemble(H,V,K):\\n            if H == 0 or V == 0: return \\'H\\' * H + \\'V\\' * V\\n            total = C(H+V,V)\\n            if total <= K: return \\'V\\' * V + \\'H\\' * H\\n            else:\\n                lower = C(H+V-1,V)\\n                if lower >= K:\\n                    return \\'H\\' + Assemble(H-1,V, K)\\n                else:\\n                    return \\'V\\' + Assemble(H, V-1, K-lower)\\n            \\n        return Assemble(destination[1], destination[0], k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379331,
                "title": "c-easy-dp-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<string>arr;\\n    int n,m;\\n    bool isvalid(int i,int j){\\n        return i>=0&&j>=0&&i<n&&j<m;\\n    }\\n    vector<vector<int>>mat;\\n\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        n = d[0]+1;\\n        m = d[1]+1;\\n        mat.resize(n+5,vector<int>(m+5,0));\\n        for(int i = 0;i<n;i++){\\n            mat[i][m-1] = 1;\\n        }\\n        for(int j = 0;j<m;j++){\\n            mat[n-1][j] = 1;\\n        }\\n        mat[n-1][m-1] = 0;\\n        for(int i = n-2;i>=0;i--){\\n            for(int j = m-2;j>=0;j--){\\n                mat[i][j]+=mat[i+1][j];\\n                mat[i][j]+=mat[i][j+1];\\n            }\\n        }\\n        string res = \"\";\\n        int i = 0;\\n        int j = 0;\\n        while(i<=n-1&&j<=m-1){\\n            while(mat[i][j]>=k){\\n                j++;\\n                res+=\\'H\\';\\n            }\\n            res.pop_back();\\n            j--;\\n            if(j>=m-1) break;\\n            k-=mat[i][j+1];\\n            i++;\\n            if(i>=n) break;\\n            res+=\\'V\\';\\n        }\\n        while(j<m-1){\\n            j++;\\n            res+=\\'H\\';\\n        }\\n        while(i<n-1){\\n            i++;\\n            res+=\\'V\\';\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<string>arr;\\n    int n,m;\\n    bool isvalid(int i,int j){\\n        return i>=0&&j>=0&&i<n&&j<m;\\n    }\\n    vector<vector<int>>mat;\\n\\n    string kthSmallestPath(vector<int>& d, int k) {\\n        n = d[0]+1;\\n        m = d[1]+1;\\n        mat.resize(n+5,vector<int>(m+5,0));\\n        for(int i = 0;i<n;i++){\\n            mat[i][m-1] = 1;\\n        }\\n        for(int j = 0;j<m;j++){\\n            mat[n-1][j] = 1;\\n        }\\n        mat[n-1][m-1] = 0;\\n        for(int i = n-2;i>=0;i--){\\n            for(int j = m-2;j>=0;j--){\\n                mat[i][j]+=mat[i+1][j];\\n                mat[i][j]+=mat[i][j+1];\\n            }\\n        }\\n        string res = \"\";\\n        int i = 0;\\n        int j = 0;\\n        while(i<=n-1&&j<=m-1){\\n            while(mat[i][j]>=k){\\n                j++;\\n                res+=\\'H\\';\\n            }\\n            res.pop_back();\\n            j--;\\n            if(j>=m-1) break;\\n            k-=mat[i][j+1];\\n            i++;\\n            if(i>=n) break;\\n            res+=\\'V\\';\\n        }\\n        while(j<m-1){\\n            j++;\\n            res+=\\'H\\';\\n        }\\n        while(i<n-1){\\n            i++;\\n            res+=\\'V\\';\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365035,
                "title": "similar-to-binary-search",
                "content": "- Try putting \\'H\\' at a location and check what is the maximum rank we can achieve with this. If max rank >= k, then append \\'H\\'\\n- Else, append \\'V\\' and increment current rank by that number if \\'H\\' would have been at that position as `H < V`\\n- So, two search space. either check by putting H, if k is still greater than max rank, append V and increment current rank by nCr\\n```\\nclass Solution {\\npublic:\\n    \\n    int nCr(int n, int r) {\\n        if(r > n-r) {\\n            r = n-r;\\n        }\\n        int ans = 1;\\n        for(int i = 0; i < r; i++) {\\n            ans *= (n-i);\\n            ans /= i+1;\\n        }\\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int m = destination[0], n = destination[1];\\n        string ans = \"\";\\n        int count = 0, V = m, H = n;\\n        for(int i = 0; i < m+n; i++) {\\n            int x = nCr(H+V-1, V);\\n            if(H > 0 && count + x >= k) {\\n                ans += \\'H\\';\\n                H--;\\n            }\\n            else{\\n                ans += \\'V\\';\\n                count += x;\\n                V--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Combinatorics",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int nCr(int n, int r) {\\n        if(r > n-r) {\\n            r = n-r;\\n        }\\n        int ans = 1;\\n        for(int i = 0; i < r; i++) {\\n            ans *= (n-i);\\n            ans /= i+1;\\n        }\\n        return ans;\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        int m = destination[0], n = destination[1];\\n        string ans = \"\";\\n        int count = 0, V = m, H = n;\\n        for(int i = 0; i < m+n; i++) {\\n            int x = nCr(H+V-1, V);\\n            if(H > 0 && count + x >= k) {\\n                ans += \\'H\\';\\n                H--;\\n            }\\n            else{\\n                ans += \\'V\\';\\n                count += x;\\n                V--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299549,
                "title": "python3-recursive-with-memoization",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        mem = {}\\n        def get_mx_cnt(h_cnt, v_cnt):\\n            if h_cnt == 0 or v_cnt == 0:\\n                return 1\\n            if (h_cnt, v_cnt) in mem:\\n                return mem[(h_cnt, v_cnt)]\\n\\n            mem[(h_cnt, v_cnt)] = get_mx_cnt(h_cnt - 1, v_cnt) + get_mx_cnt(h_cnt, v_cnt - 1)\\n            return mem[(h_cnt, v_cnt)]\\n \\n        def get_kth(h_cnt, v_cnt, k):\\n            if k == 1 or v_cnt == 0 or h_cnt == 0:\\n                return [\"H\"] * h_cnt + [\"V\"] * v_cnt, 1\\n\\n            mx_htop_cnt = get_mx_cnt(h_cnt - 1, v_cnt)\\n            if mx_htop_cnt >= k:\\n                # H top\\n                sub_res, nh_cnt = get_kth(h_cnt - 1, v_cnt, k) \\n                return [\"H\"] + sub_res, nh_cnt\\n            else:\\n                # V top\\n                sub_res, nv_cnt = get_kth(h_cnt, v_cnt - 1, k - mx_htop_cnt)\\n                return [\"V\"] + sub_res, nv_cnt + mx_htop_cnt\\n\\n        res, _ = get_kth(destination[1], destination[0], k)\\n        return \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        mem = {}\\n        def get_mx_cnt(h_cnt, v_cnt):\\n            if h_cnt == 0 or v_cnt == 0:\\n                return 1\\n            if (h_cnt, v_cnt) in mem:\\n                return mem[(h_cnt, v_cnt)]\\n\\n            mem[(h_cnt, v_cnt)] = get_mx_cnt(h_cnt - 1, v_cnt) + get_mx_cnt(h_cnt, v_cnt - 1)\\n            return mem[(h_cnt, v_cnt)]\\n \\n        def get_kth(h_cnt, v_cnt, k):\\n            if k == 1 or v_cnt == 0 or h_cnt == 0:\\n                return [\"H\"] * h_cnt + [\"V\"] * v_cnt, 1\\n\\n            mx_htop_cnt = get_mx_cnt(h_cnt - 1, v_cnt)\\n            if mx_htop_cnt >= k:\\n                # H top\\n                sub_res, nh_cnt = get_kth(h_cnt - 1, v_cnt, k) \\n                return [\"H\"] + sub_res, nh_cnt\\n            else:\\n                # V top\\n                sub_res, nv_cnt = get_kth(h_cnt, v_cnt - 1, k - mx_htop_cnt)\\n                return [\"V\"] + sub_res, nv_cnt + mx_htop_cnt\\n\\n        res, _ = get_kth(destination[1], destination[0], k)\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276376,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int r=destination[0],c=destination[1];\\n        int dp[][]=new int[r+2][c+2];\\n        dp[r][c]=1;\\n        for(int i=r;i>=0;i--)\\n            for(int j=c;j>=0;j--)\\n                dp[i][j]=dp[i][j]+dp[i+1][j]+dp[i][j+1];\\n        StringBuilder ans=new StringBuilder();\\n        int i=0,j=0,p=k;\\n        while(i<r || j<c)\\n        {\\n            if(dp[i][j+1]>=p)\\n            {\\n                ans.append(\"H\");\\n                j++;\\n            }\\n            else\\n            {\\n                p=p-dp[i][j+1];\\n                ans.append(\"V\");\\n                i++;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int r=destination[0],c=destination[1];\\n        int dp[][]=new int[r+2][c+2];\\n        dp[r][c]=1;\\n        for(int i=r;i>=0;i--)\\n            for(int j=c;j>=0;j--)\\n                dp[i][j]=dp[i][j]+dp[i+1][j]+dp[i][j+1];\\n        StringBuilder ans=new StringBuilder();\\n        int i=0,j=0,p=k;\\n        while(i<r || j<c)\\n        {\\n            if(dp[i][j+1]>=p)\\n            {\\n                ans.append(\"H\");\\n                j++;\\n            }\\n            else\\n            {\\n                p=p-dp[i][j+1];\\n                ans.append(\"V\");\\n                i++;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250929,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int h = d[1], v = d[0];\\n        int[][] dp = new int[h+v+1][v+1];\\n        dp[0][0] = 1;\\n        for(int i = 1 ; i < dp.length ; i++){\\n            dp[i][0] = 1;\\n            for(int j = 1 ; j <= v ; j++){\\n                dp[i][j] += dp[i-1][j] + dp[i-1][j-1];\\n            }\\n        }\\n        char[] ret = new char[h+v];\\n        int vt = v;\\n        int idx = h+v;\\n        while(idx > 0 && k > 0 && vt > 0){\\n            while(idx >= 0  && dp[idx-1][vt] >= k){\\n                idx--;\\n            }\\n            if(k == dp[idx][vt]){\\n                while(idx > 0 && vt > 0){\\n                    ret[h+v-idx] = \\'V\\';\\n                    idx--;\\n                    vt--;\\n                }\\n                break;\\n            }else{\\n                k -= dp[idx-1][vt];\\n                ret[h+v-idx]=\\'V\\';\\n                vt--;\\n            }\\n        }\\n        for(int i = 0 ; i < ret.length ; i++){\\n            if(ret[i] != \\'V\\'){\\n                ret[i] = \\'H\\';\\n            }\\n        }\\n        return new String(ret);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int h = d[1], v = d[0];\\n        int[][] dp = new int[h+v+1][v+1];\\n        dp[0][0] = 1;\\n        for(int i = 1 ; i < dp.length ; i++){\\n            dp[i][0] = 1;\\n            for(int j = 1 ; j <= v ; j++){\\n                dp[i][j] += dp[i-1][j] + dp[i-1][j-1];\\n            }\\n        }\\n        char[] ret = new char[h+v];\\n        int vt = v;\\n        int idx = h+v;\\n        while(idx > 0 && k > 0 && vt > 0){\\n            while(idx >= 0  && dp[idx-1][vt] >= k){\\n                idx--;\\n            }\\n            if(k == dp[idx][vt]){\\n                while(idx > 0 && vt > 0){\\n                    ret[h+v-idx] = \\'V\\';\\n                    idx--;\\n                    vt--;\\n                }\\n                break;\\n            }else{\\n                k -= dp[idx-1][vt];\\n                ret[h+v-idx]=\\'V\\';\\n                vt--;\\n            }\\n        }\\n        for(int i = 0 ; i < ret.length ; i++){\\n            if(ret[i] != \\'V\\'){\\n                ret[i] = \\'H\\';\\n            }\\n        }\\n        return new String(ret);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230350,
                "title": "python3-count-how-many-v-and-h-top-down-memoization",
                "content": "We want to start with patterns with V behind H. The basic problem is this:\\n\\nSuppose you have a number of `v` vertical moves, and `h` horizontal moves, how many total paths are there?\\n\\nSuppose v + h = n, You can quickly figure out this is Comb(n, v), basically choose v places out of n positions. So we can start counting (by increasing i from v to n) until we have Comb(i, v) >= k. When this happens, we know during this iteration, the first V appears after (n - i) H; and after the first V, we have (v-1) V left, and (h-n+i) H left, and we want to figure out the new position corresponding to the new k. \\n\\nFor example, we want v=2, h=3, and k =4. n = v+h = 5. Starting from i = 2 to 5, we can see:\\n* Comb(2, 2) = 1 < k, meaning \\'VV\\' is the only combination if we have length i = 2.\\n* Comb(3, 2) = 3 < k, meaning we have 3 combinations (\\'VVH\\', \\'VHV\\', \\'VVH\\').\\n* Comb(4, 2) = 6 >= k = 4. So we know the final pattern will be \\'HVxxx\\'. We need to look for length 4 pattern \\'Vxxx\\'. Now the new k becomes k = 4 - 3 = 1 -> we are looking for the 1st combination of length 4 (\\'Vxxx\\'), given that there are 3 length 3 combinations. Also, since we have used 1 H and 1 V in \\'HVxxx\\', we know we will need to check helper(v-1, h - 1, new_k).\\n\\nSee the program for details.\\n\\n```python\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        @lru_cache(None)\\n        def helper(v, h, k):\\n            n = v + h\\n            if k == 1:\\n                return \\'H\\' * h + \\'V\\' * v\\n\\n            last = 0\\n            for i in range(v, n+1):\\n                cur = factorial(i) // (factorial(v) * factorial(i-v))\\n                if last < k <= cur:\\n                    k -= last\\n                    break\\n                last = cur\\n            return \\'H\\' * (n - i) + \\'V\\' + helper(v-1, h - n + i, k)\\n    \\n        v, h = destination\\n        return helper(v, h, k)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        @lru_cache(None)\\n        def helper(v, h, k):\\n            n = v + h\\n            if k == 1:\\n                return \\'H\\' * h + \\'V\\' * v\\n\\n            last = 0\\n            for i in range(v, n+1):\\n                cur = factorial(i) // (factorial(v) * factorial(i-v))\\n                if last < k <= cur:\\n                    k -= last\\n                    break\\n                last = cur\\n            return \\'H\\' * (n - i) + \\'V\\' + helper(v-1, h - n + i, k)\\n    \\n        v, h = destination\\n        return helper(v, h, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121137,
                "title": "o-m-n-solution-with-precomputation-of-ncr-explained",
                "content": "Let\\'s say we have a function `placeV(n, r, k int) => string` to generate the k-th seqeunce of string of length `n`, with `r` \"V\"s and `n-r` \"H\".\\n\\nAssume that we place a \"H\" as the first character, the remaining string of length `n-1` will need to have `r` \"V\"s, there are `nCr[n-1][r]` of such combinations.\\n- If `nCr[n-1][r] < k` we will know that the k-th sequence will not have the first character as \"H\", so the solution will be `\"V\" + placeV(n-1, r-1, k-nCr[n-1][r])`\\n- otherwise the solution must have \"H\" as first character, i.e. `\"H\" + placeV(n-1, r, k)`\\n\\nBelow is a non-recursive implementation of this idea in golang.\\n```\\nvar ncr [][]int\\nfunc kthSmallestPath(d []int, k int) string {\\n  if ncr == nil {\\n    ncr = make([][]int, 31)\\n    for i := 0; i <= 30; i++ {\\n      ncr[i] = make([]int, 31)\\n      for j := 0; j <= i; j++ {\\n        if j == 0 {\\n          ncr[i][j] = 1\\n          continue\\n        }\\n        ncr[i][j] = ncr[i-1][j-1] + ncr[i-1][j]\\n      }\\n    }\\n  }\\n  \\n  s := \"\"\\n  n, r := d[0]+d[1], d[0]\\n  for n > 0 {\\n    if ncr[n-1][r] < k {\\n      s += \"V\"\\n      k -= ncr[n-1][r]\\n      r--\\n    } else {\\n      s += \"H\"\\n    }\\n    n--\\n  }\\n  return s\\n}\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nvar ncr [][]int\\nfunc kthSmallestPath(d []int, k int) string {\\n  if ncr == nil {\\n    ncr = make([][]int, 31)\\n    for i := 0; i <= 30; i++ {\\n      ncr[i] = make([]int, 31)\\n      for j := 0; j <= i; j++ {\\n        if j == 0 {\\n          ncr[i][j] = 1\\n          continue\\n        }\\n        ncr[i][j] = ncr[i-1][j-1] + ncr[i-1][j]\\n      }\\n    }\\n  }\\n  \\n  s := \"\"\\n  n, r := d[0]+d[1], d[0]\\n  for n > 0 {\\n    if ncr[n-1][r] < k {\\n      s += \"V\"\\n      k -= ncr[n-1][r]\\n      r--\\n    } else {\\n      s += \"H\"\\n    }\\n    n--\\n  }\\n  return s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1102004,
                "title": "java-fastest-solution-11ms-with-biginteger",
                "content": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        return find(\"\", destination[0], destination[1], k);\\n    }\\n    \\n    private String find(String current, int v, int h, long k) {\\n        if (v == 0 && h == 0) return current;\\n        BigInteger totalCombs = combinations(v+h, h);\\n        BigInteger hCombs = combinations(v+h-1, h-1);\\n        if (v > 0 && (BigInteger.valueOf(k).compareTo(hCombs) > 0 || h == 0)) {\\n            return find(current + \\'V\\', v-1, h, k - hCombs.longValue());\\n        }\\n        else {\\n            return find(current + \\'H\\', v, h-1, k);\\n        }\\n    }\\n        \\n    private BigInteger factorial(int n) {\\n        BigInteger result = BigInteger.ONE;\\n        for (int i = 2; i <= n; i++)\\n            result = result.multiply(BigInteger.valueOf(i));\\n        return result;\\n    }\\n    \\n    private BigInteger combinations(int total, int rows) {\\n        return (factorial(total)).divide(((factorial(rows)).multiply((factorial(total-rows)))));\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        return find(\"\", destination[0], destination[1], k);\\n    }\\n    \\n    private String find(String current, int v, int h, long k) {\\n        if (v == 0 && h == 0) return current;\\n        BigInteger totalCombs = combinations(v+h, h);\\n        BigInteger hCombs = combinations(v+h-1, h-1);\\n        if (v > 0 && (BigInteger.valueOf(k).compareTo(hCombs) > 0 || h == 0)) {\\n            return find(current + \\'V\\', v-1, h, k - hCombs.longValue());\\n        }\\n        else {\\n            return find(current + \\'H\\', v, h-1, k);\\n        }\\n    }\\n        \\n    private BigInteger factorial(int n) {\\n        BigInteger result = BigInteger.ONE;\\n        for (int i = 2; i <= n; i++)\\n            result = result.multiply(BigInteger.valueOf(i));\\n        return result;\\n    }\\n    \\n    private BigInteger combinations(int total, int rows) {\\n        return (factorial(total)).divide(((factorial(rows)).multiply((factorial(total-rows)))));\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081532,
                "title": "python-combination-beats-85",
                "content": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\tv, h = destination\\n\\tn = v + h\\n\\tprefix = \"\"\\n\\taccu = 0\\n\\tfor i in range(n):\\n\\t\\thCand = math.comb(v+h-1, v)\\n\\t\\tif k == accu + hCand:\\n\\t\\t\\tprefix += \"H\" + \"V\" * v + \"H\" * (h - 1)\\n\\t\\t\\tbreak\\n\\t\\telif k > accu + hCand:\\n\\t\\t\\tprefix += \"V\"\\n\\t\\t\\taccu += hCand\\n\\t\\t\\tv -= 1\\n\\t\\telse:\\n\\t\\t\\tprefix += \"H\"\\n\\t\\t\\th -= 1\\n\\treturn prefix",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef kthSmallestPath(self, destination: List[int], k: int) -> str:\\n\\tv, h = destination\\n\\tn = v + h\\n\\tprefix = \"\"\\n\\taccu = 0\\n\\tfor i in range(n):\\n\\t\\thCand = math.comb(v+h-1, v)\\n\\t\\tif k == accu + hCand:\\n\\t\\t\\tprefix += \"H\" + \"V\" * v + \"H\" * (h - 1)\\n\\t\\t\\tbreak\\n\\t\\telif k > accu + hCand:\\n\\t\\t\\tprefix += \"V\"\\n\\t\\t\\taccu += hCand\\n\\t\\t\\tv -= 1\\n\\t\\telse:\\n\\t\\t\\tprefix += \"H\"\\n\\t\\t\\th -= 1\\n\\treturn prefix",
                "codeTag": "Python3"
            },
            {
                "id": 1076943,
                "title": "python-recursively-calculate-combinations-and-rank",
                "content": "```\\ndef combination(a, b):\\n    product = 1\\n    for i in range(a, a-b,-1):\\n        product *= i\\n    \\n    for i in range(1, b+1):\\n        product //= i\\n        \\n    return product\\n\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # print(combination(3,0))\\n        \\n        def help(m, n, k):\\n            # print(m, n, k)\\n            if n == 0 and m == 0:\\n                return \"\"\\n            elif n == 0:\\n                return m * \\'H\\'\\n            elif m == 0:\\n                return n * \\'V\\'\\n            else:\\n                #chose \\'H\\' as the first number\\n                firstNum = combination(m+n-1,m-1)\\n                if k == firstNum:\\n                    return \\'H\\'+ n*\\'V\\' + (m-1)*\\'H\\'\\n                elif k < firstNum:\\n                    return \\'H\\' + help(m-1, n, k)\\n                else:\\n                    return \\'V\\' + help(m, n-1, k-firstNum)\\n            \\n        numV = destination[0]\\n        numH = destination[1]\\n        \\n        return help(numH, numV, k)\\n```",
                "solutionTags": [],
                "code": "```\\ndef combination(a, b):\\n    product = 1\\n    for i in range(a, a-b,-1):\\n        product *= i\\n    \\n    for i in range(1, b+1):\\n        product //= i\\n        \\n    return product\\n\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # print(combination(3,0))\\n        \\n        def help(m, n, k):\\n            # print(m, n, k)\\n            if n == 0 and m == 0:\\n                return \"\"\\n            elif n == 0:\\n                return m * \\'H\\'\\n            elif m == 0:\\n                return n * \\'V\\'\\n            else:\\n                #chose \\'H\\' as the first number\\n                firstNum = combination(m+n-1,m-1)\\n                if k == firstNum:\\n                    return \\'H\\'+ n*\\'V\\' + (m-1)*\\'H\\'\\n                elif k < firstNum:\\n                    return \\'H\\' + help(m-1, n, k)\\n                else:\\n                    return \\'V\\' + help(m, n-1, k-firstNum)\\n            \\n        numV = destination[0]\\n        numH = destination[1]\\n        \\n        return help(numH, numV, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070550,
                "title": "python-dp-o-m-n-2-explained",
                "content": "`dp[x][y]` means the number of ways to from `(0,0)` to `(x,y)`.\\nif we stand on point `(xp, yp)`, then from there the possible ways to `(x,y)` is `dp[x-xp][y-yp]` (equals to from `(0,0)` to point `(x-xp, y-yp)`. Then we had two option, \\u201CH\\u201D and \\u201CV\\u201D. If `k <= dp[x-xp][y-(yp+1)]` then it means the next step is \\'H\\' since all path started with \\'H\\' has smaller index thatn path started with \\'V\\'. if `k > dp[x-xp][y-(yp+1)]`, then it means the next step is \\'V\\' and we should update `k` by subtract `dp[x-xp][y-(yp+1)]` since the next two options index after `V` need to consider adding this part.\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        dp = [[1]*16 for _ in range(16)]\\n        for i in range(1,16):\\n            for j in range(1,16):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        x, y = destination\\n        xp, yp = 0, 0\\n        res = \"\"\\n        while xp < x and yp < y:\\n            if dp[x-xp][y-yp-1] >= k:\\n                yp += 1\\n                res += \"H\"\\n            else:\\n                k -= dp[x-xp][y-yp-1]\\n                xp += 1\\n                res += \"V\"\\n        while xp < x:\\n            xp += 1\\n            res += \"V\"\\n        while yp < y:\\n            yp += 1\\n            res += \"H\"\\n        return res\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        dp = [[1]*16 for _ in range(16)]\\n        for i in range(1,16):\\n            for j in range(1,16):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n        x, y = destination\\n        xp, yp = 0, 0\\n        res = \"\"\\n        while xp < x and yp < y:\\n            if dp[x-xp][y-yp-1] >= k:\\n                yp += 1\\n                res += \"H\"\\n            else:\\n                k -= dp[x-xp][y-yp-1]\\n                xp += 1\\n                res += \"V\"\\n        while xp < x:\\n            xp += 1\\n            res += \"V\"\\n        while yp < y:\\n            yp += 1\\n            res += \"H\"\\n        return res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1051674,
                "title": "java-1ms-dp-solution-time-o-row-col-space-o-row-col",
                "content": "```\\npublic String kthSmallestPath(int[] destination, int k) {\\n        int[][] grid = new int[16][16];\\n        int desRow = destination[0];\\n        int desCol = destination[1];\\n        for (int i = desRow; i >= 0; i--) {\\n             grid[i][desCol] = 1;\\n        }\\n        for (int j = desCol; j >= 0; j--) {\\n             grid[desRow][j] = 1;\\n        }\\n        for (int i = desRow - 1; i >= 0; i--) {\\n             for (int j = desCol - 1; j >= 0; j--) {\\n                  grid[i][j] = grid[i + 1][j] + grid[i][j + 1];\\n             }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        StringBuilder builder = new StringBuilder();\\n        while (row < desRow && col < desCol) {\\n        \\n            if (grid[row][col + 1] >= k) {\\n                builder.append(\"H\");\\n                col++;\\n            } else {\\n                k -= grid[row][col + 1];\\n                builder.append(\"V\");\\n                row++;\\n            }\\n        }\\n        while (col < desCol) {\\n            builder.append(\"H\");\\n            col++;\\n        }\\n        while (row < desRow) {\\n            builder.append(\"V\");\\n            row++;\\n        }\\n        return builder.toString();\\n    }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\npublic String kthSmallestPath(int[] destination, int k) {\\n        int[][] grid = new int[16][16];\\n        int desRow = destination[0];\\n        int desCol = destination[1];\\n        for (int i = desRow; i >= 0; i--) {\\n             grid[i][desCol] = 1;\\n        }\\n        for (int j = desCol; j >= 0; j--) {\\n             grid[desRow][j] = 1;\\n        }\\n        for (int i = desRow - 1; i >= 0; i--) {\\n             for (int j = desCol - 1; j >= 0; j--) {\\n                  grid[i][j] = grid[i + 1][j] + grid[i][j + 1];\\n             }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        StringBuilder builder = new StringBuilder();\\n        while (row < desRow && col < desCol) {\\n        \\n            if (grid[row][col + 1] >= k) {\\n                builder.append(\"H\");\\n                col++;\\n            } else {\\n                k -= grid[row][col + 1];\\n                builder.append(\"V\");\\n                row++;\\n            }\\n        }\\n        while (col < desCol) {\\n            builder.append(\"H\");\\n            col++;\\n        }\\n        while (row < desRow) {\\n            builder.append(\"V\");\\n            row++;\\n        }\\n        return builder.toString();\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044044,
                "title": "c-combination",
                "content": "```\\nclass Combination{\\npublic:\\n    using ll=long long;\\n    Combination(int size) : factorial(size) {\\n        factorial[0] = 1;\\n        for(int i=1; i<size; i++) factorial[i] = i * factorial[i-1] % mod;\\n    }\\n    \\n    ll power(ll a, ll b){ \\n        ll x = 1, y = a % mod; \\n        while (b > 0){ \\n            if (b%2) x = x * y % mod; \\n            y = y * y % mod; \\n            b /= 2; \\n        } \\n        return x % mod; \\n    }\\t \\n \\n    ll modular_inverse(ll n){ \\n        return power(n, mod-2); \\n    } \\n\\n    ll nCr(ll n, ll k){ \\n        if(k<0) return 0;\\n        return factorial[n] * modular_inverse(factorial[k] * factorial[n - k]) % mod;\\n    } \\n    \\n    vector<ll> factorial;\\n    static constexpr ll mod = 1e9+7;\\n};\\n\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int n = dest[1], m = dest[0], q = n+m;\\n        Combination comb(30);\\n        string res;\\n        while(q--){\\n            if(comb.nCr(n+m-1, n-1) < k){\\n                k -= comb.nCr(n+m-1, n-1);\\n                res += \\'V\\';\\n                m--;\\n            }\\n            else{\\n                n--;\\n                res += \\'H\\';\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int n = dest[1], m = dest[0], q = n+m;\\n        Combination comb(30);\\n        string res;\\n        while(q--){\\n            if(comb.nCr(n+m-1, n-1) < k){\\n                k -= comb.nCr(n+m-1, n-1);\\n                res += \\'V\\';\\n                m--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1025752,
                "title": "python-only-math-dhruv-vavliya",
                "content": "```\\n# written by :Dhruv vavliya\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        h = destination[1]\\n        v = destination[0]\\n        ans = \\'\\'\\n\\n        while h>0 and v>0:\\n            temp = comb(h+v-1 ,v)\\n\\n            if k <= temp:\\n                ans+=\\'H\\'\\n                h-=1\\n            else:\\n                ans+=\\'V\\'\\n                v-=1\\n                k-=temp\\n\\n        if h==0:\\n            ans += \\'V\\'*v\\n        if v==0:\\n            ans += \\'H\\'*h\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n# written by :Dhruv vavliya\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        from math import comb\\n        h = destination[1]\\n        v = destination[0]\\n        ans = \\'\\'\\n\\n        while h>0 and v>0:\\n            temp = comb(h+v-1 ,v)\\n\\n            if k <= temp:\\n                ans+=\\'H\\'\\n                h-=1\\n            else:\\n                ans+=\\'V\\'\\n                v-=1\\n                k-=temp\\n\\n        if h==0:\\n            ans += \\'V\\'*v\\n        if v==0:\\n            ans += \\'H\\'*h\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020886,
                "title": "go-0ms-solution",
                "content": "```\\nfunc factorialRange(n, end uint64) uint64 {\\n\\tif n < end {\\n\\t\\treturn 1\\n\\t}\\n\\treturn n * factorialRange(n-1, end)\\n}\\n\\nfunc nCr(n, r uint64) int {\\n\\t// To avoid overflow\\n\\treturn int(factorialRange(n, n-r+1) / factorialRange(r, 2))\\n}\\n\\nfunc duplicateChar(c string, n int) string {\\n\\tstr := \"\"\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tstr += c\\n\\t}\\n\\n\\treturn str\\n}\\n\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tv, h := destination[0], destination[1]\\n\\tif v == 0 {\\n\\t\\treturn duplicateChar(\"H\", h)\\n\\t}\\n\\tif h == 0 {\\n\\t\\treturn duplicateChar(\"V\", v)\\n\\t}\\n\\n\\tfor i := h; ; i-- {\\n\\t\\tcombinations := nCr(uint64(h+v-i-1), uint64(v-1))\\n\\t\\tif k-combinations <= 0 || i == 0 {\\n\\t\\t\\treturn duplicateChar(\"H\", i) + \"V\" + kthSmallestPath([]int{v - 1, h - i}, k)\\n\\t\\t}\\n\\n\\t\\tk -= combinations\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc factorialRange(n, end uint64) uint64 {\\n\\tif n < end {\\n\\t\\treturn 1\\n\\t}\\n\\treturn n * factorialRange(n-1, end)\\n}\\n\\nfunc nCr(n, r uint64) int {\\n\\t// To avoid overflow\\n\\treturn int(factorialRange(n, n-r+1) / factorialRange(r, 2))\\n}\\n\\nfunc duplicateChar(c string, n int) string {\\n\\tstr := \"\"\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tstr += c\\n\\t}\\n\\n\\treturn str\\n}\\n\\nfunc kthSmallestPath(destination []int, k int) string {\\n\\tv, h := destination[0], destination[1]\\n\\tif v == 0 {\\n\\t\\treturn duplicateChar(\"H\", h)\\n\\t}\\n\\tif h == 0 {\\n\\t\\treturn duplicateChar(\"V\", v)\\n\\t}\\n\\n\\tfor i := h; ; i-- {\\n\\t\\tcombinations := nCr(uint64(h+v-i-1), uint64(v-1))\\n\\t\\tif k-combinations <= 0 || i == 0 {\\n\\t\\t\\treturn duplicateChar(\"H\", i) + \"V\" + kthSmallestPath([]int{v - 1, h - i}, k)\\n\\t\\t}\\n\\n\\t\\tk -= combinations\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998278,
                "title": "p23-5",
                "content": "ncr = calculate using formula of taking and not taking\\nMath dp",
                "solutionTags": [],
                "code": "ncr = calculate using formula of taking and not taking\\nMath dp",
                "codeTag": "Unknown"
            },
            {
                "id": 974380,
                "title": "python-very-easy",
                "content": "```\\nfrom math import factorial as fac\\nclass Solution:\\n    def kthSmallestPath(self, z: List[int], k: int) -> str:\\n        def f(h,v):\\n            if h==-1:return 0\\n            return fac(v+h)//(fac(v)*fac(h))\\n        v,h=z\\n        res=\\'\\'\\n        while 1:\\n            if h==0 or v==0:\\n                res+= \\'H\\'*h+ \\'V\\'*v\\n                break\\n            a=f(h-1,v)\\n            if k<=a:\\n                res+=\\'H\\'   \\n                h-=1\\n            else:\\n                res+=\\'V\\'\\n                k-=a\\n                v-=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import factorial as fac\\nclass Solution:\\n    def kthSmallestPath(self, z: List[int], k: int) -> str:\\n        def f(h,v):\\n            if h==-1:return 0\\n            return fac(v+h)//(fac(v)*fac(h))\\n        v,h=z\\n        res=\\'\\'\\n        while 1:\\n            if h==0 or v==0:\\n                res+= \\'H\\'*h+ \\'V\\'*v\\n                break\\n            a=f(h-1,v)\\n            if k<=a:\\n                res+=\\'H\\'   \\n                h-=1\\n            else:\\n                res+=\\'V\\'\\n                k-=a\\n                v-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971943,
                "title": "c-0ms-choose-n-from-m-and-switch-accordingly",
                "content": "```\\nclass Solution {\\n    static int dp[31][31];\\npublic:\\n    // choose j items from i items\\n    int get(int i, int j) {\\n        if(i < j) return 0;\\n        if(i == j) return 1;\\n        if(j == 0) return 1;\\n        if(j == 1) return i;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = get(i - 1, j) + get(i - 1, j - 1);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int x = dest[1], y = dest[0];\\n        string res;\\n        for(int i = x + y; i > 0; i--)\\n        {\\n            if(get(i-1, y) >= k) {\\n                res.push_back(\\'H\\');\\n                x--;\\n            }\\n            else{\\n                res.push_back(\\'V\\');\\n                k -= get(i-1, y);\\n                y--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\nint Solution::dp[31][31]{};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int dp[31][31];\\npublic:\\n    // choose j items from i items\\n    int get(int i, int j) {\\n        if(i < j) return 0;\\n        if(i == j) return 1;\\n        if(j == 0) return 1;\\n        if(j == 1) return i;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = get(i - 1, j) + get(i - 1, j - 1);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        int x = dest[1], y = dest[0];\\n        string res;\\n        for(int i = x + y; i > 0; i--)\\n        {\\n            if(get(i-1, y) >= k) {\\n                res.push_back(\\'H\\');\\n                x--;\\n            }\\n            else{\\n                res.push_back(\\'V\\');\\n                k -= get(i-1, y);\\n                y--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\nint Solution::dp[31][31]{};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969107,
                "title": "c-4ms-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        c[0][0] = 1;\\n        for (int i = 1; i <= 31; i++) {\\n            c[i][0] = 1;\\n            for (int j = 1; j <= 31; j++) {\\n                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\\n            }\\n        }\\n        int v = destination[0], h = destination[1];\\n        return solve(h, v, k);\\n    }\\nprivate:\\n    int c[32][32];\\n    string solve(int h, int v, int k) {\\n        int p = v;\\n        int sum = 0;\\n        while (true) {\\n            if (sum + c[p - 1][v - 1] < k) {\\n                sum += c[p - 1][v - 1];\\n                p++;\\n            } else if (sum + c[p - 1][v - 1] == k) {\\n                return string(h + v - p, \\'H\\') + string(v, \\'V\\') + string(p - v, \\'H\\');\\n            } else {\\n                return string(h + v - p, \\'H\\') + string(1, \\'V\\') + solve(p - v, v - 1, k - sum);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        c[0][0] = 1;\\n        for (int i = 1; i <= 31; i++) {\\n            c[i][0] = 1;\\n            for (int j = 1; j <= 31; j++) {\\n                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\\n            }\\n        }\\n        int v = destination[0], h = destination[1];\\n        return solve(h, v, k);\\n    }\\nprivate:\\n    int c[32][32];\\n    string solve(int h, int v, int k) {\\n        int p = v;\\n        int sum = 0;\\n        while (true) {\\n            if (sum + c[p - 1][v - 1] < k) {\\n                sum += c[p - 1][v - 1];\\n                p++;\\n            } else if (sum + c[p - 1][v - 1] == k) {\\n                return string(h + v - p, \\'H\\') + string(v, \\'V\\') + string(p - v, \\'H\\');\\n            } else {\\n                return string(h + v - p, \\'H\\') + string(1, \\'V\\') + solve(p - v, v - 1, k - sum);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961836,
                "title": "c-math",
                "content": "```\\npublic class Solution\\n{\\n  public string KthSmallestPath(int[] destination, int k)\\n  {\\n    var maxX = destination[0];\\n    var maxY = destination[1];\\n\\n    var point = (x: 0, y: 0);\\n    var target = (x: destination[0], y: destination[1]);\\n    var range = (start: 1, end: Cr(maxX + maxY, maxX));\\n\\n    var sb = new StringBuilder();\\n\\n    while (point != target)\\n    {\\n      if (point.x == target.x)\\n      {\\n        point = (point.x, point.y + 1);\\n        sb.Append(\"H\");\\n        continue;\\n      }\\n\\n      if (point.y == target.y)\\n      {\\n        point = (point.x + 1, point.y);\\n        sb.Append(\"V\");\\n        continue;\\n      }\\n\\n      var lpoint = (x: point.x, y: point.y + 1);\\n      var dpoint = (x: point.x + 1, y: point.y);\\n\\n      var lCr = Cr(maxY - lpoint.y + maxX - lpoint.x, maxX - lpoint.x);\\n      var dCr = Cr(maxY - dpoint.y + maxX - dpoint.x, maxX - dpoint.x);\\n\\n      var hRange = (start: range.start, end: range.start + lCr - 1);\\n      var vRange = (start: range.end - dCr + 1, end: range.end);\\n\\n      if (hRange.start <= k && k <= hRange.end)\\n      {\\n        range = hRange;\\n        point = (point.x, point.y + 1);\\n        sb.Append(\"H\");\\n      }\\n      else\\n      {\\n        range = vRange;\\n        point = (point.x + 1, point.y);\\n        sb.Append(\"V\");\\n      }\\n    }\\n\\n    return sb.ToString();\\n  }\\n\\n  public int Cr(int n, int r) \\n    => (int)(Fact(n) / (Fact(r) * Fact(n - r)));\\n\\n  public BigInteger Fact(int n) \\n    => Enumerable.Range(1, n).Aggregate(BigInteger.One, (p, item) => BigInteger.Multiply(p, new BigInteger(item)));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n  public string KthSmallestPath(int[] destination, int k)\\n  {\\n    var maxX = destination[0];\\n    var maxY = destination[1];\\n\\n    var point = (x: 0, y: 0);\\n    var target = (x: destination[0], y: destination[1]);\\n    var range = (start: 1, end: Cr(maxX + maxY, maxX));\\n\\n    var sb = new StringBuilder();\\n\\n    while (point != target)\\n    {\\n      if (point.x == target.x)\\n      {\\n        point = (point.x, point.y + 1);\\n        sb.Append(\"H\");\\n        continue;\\n      }\\n\\n      if (point.y == target.y)\\n      {\\n        point = (point.x + 1, point.y);\\n        sb.Append(\"V\");\\n        continue;\\n      }\\n\\n      var lpoint = (x: point.x, y: point.y + 1);\\n      var dpoint = (x: point.x + 1, y: point.y);\\n\\n      var lCr = Cr(maxY - lpoint.y + maxX - lpoint.x, maxX - lpoint.x);\\n      var dCr = Cr(maxY - dpoint.y + maxX - dpoint.x, maxX - dpoint.x);\\n\\n      var hRange = (start: range.start, end: range.start + lCr - 1);\\n      var vRange = (start: range.end - dCr + 1, end: range.end);\\n\\n      if (hRange.start <= k && k <= hRange.end)\\n      {\\n        range = hRange;\\n        point = (point.x, point.y + 1);\\n        sb.Append(\"H\");\\n      }\\n      else\\n      {\\n        range = vRange;\\n        point = (point.x + 1, point.y);\\n        sb.Append(\"V\");\\n      }\\n    }\\n\\n    return sb.ToString();\\n  }\\n\\n  public int Cr(int n, int r) \\n    => (int)(Fact(n) / (Fact(r) * Fact(n - r)));\\n\\n  public BigInteger Fact(int n) \\n    => Enumerable.Range(1, n).Aggregate(BigInteger.One, (p, item) => BigInteger.Multiply(p, new BigInteger(item)));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957826,
                "title": "c-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& cnt, int m, int n, int r, string& res)\\n    {\\n        if(n == 0 || m == 0)\\n        {\\n            int s = m + n;\\n            char c = m > 0 ? \\'H\\' : \\'V\\';\\n            res += string(s, c);\\n            return;\\n        }\\n        \\n        int a = cnt[m - 1][n];\\n        int b = cnt[m][n - 1];\\n        \\n        if(r <= a) {\\n            res.push_back(\\'H\\');\\n            dfs(cnt, m-1, n, r, res);\\n        } else {\\n            res.push_back(\\'V\\');\\n            dfs(cnt, m, n - 1, r - a, res);\\n        }\\n        \\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) \\n    {\\n        int n = destination.front(), m = destination.back();\\n        vector<vector<int>> cnt(m + 1, vector<int>(n + 1, 1));\\n        for (int i = 1; i <= m; i ++)\\n            for (int j = 1; j <= n; j++)\\n                cnt[i][j] = cnt[i - 1][j] + cnt[i][j - 1];\\n\\n        string res;\\n        dfs(cnt, m, n, k, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& cnt, int m, int n, int r, string& res)\\n    {\\n        if(n == 0 || m == 0)\\n        {\\n            int s = m + n;\\n            char c = m > 0 ? \\'H\\' : \\'V\\';\\n            res += string(s, c);\\n            return;\\n        }\\n        \\n        int a = cnt[m - 1][n];\\n        int b = cnt[m][n - 1];\\n        \\n        if(r <= a) {\\n            res.push_back(\\'H\\');\\n            dfs(cnt, m-1, n, r, res);\\n        } else {\\n            res.push_back(\\'V\\');\\n            dfs(cnt, m, n - 1, r - a, res);\\n        }\\n        \\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) \\n    {\\n        int n = destination.front(), m = destination.back();\\n        vector<vector<int>> cnt(m + 1, vector<int>(n + 1, 1));\\n        for (int i = 1; i <= m; i ++)\\n            for (int j = 1; j <= n; j++)\\n                cnt[i][j] = cnt[i - 1][j] + cnt[i][j - 1];\\n\\n        string res;\\n        dfs(cnt, m, n, k, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957608,
                "title": "can-anyone-write-me-a-brute-force-dfs-without-dp-pls",
                "content": "No DP, no memo, pure brute force DFS\\nNo combo\\nBetter in Java pls",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 929041,
                "title": "rust-dp-o-v-h-2",
                "content": "I build up a DP, where `DP[i][j]` is defined as the index of the item where `i is defined as the number of vertical moves` and `j is defined as the position of  the leading v` the first time it reaches that position.\\n\\nEg:\\n\\n```\\n\"H....HHHHVHHH....HHVVV...VVV\"  == > i = count(\"v\")\\n          ^ j\\n```\\n\\nUsing this map we can rebuild by finding indexes smaller or equal to k. And placing `\"V\"s` as we go.\\n\\n```\\nuse std::cmp;\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        let h = destination[1];\\n        let v = destination[0];\\n        \\n        let mut dp: Vec<Vec<i32>> = vec![];\\n        for i in 0..=v {\\n            dp.push(vec![-1; (h+v) as usize]);\\n        }\\n        for i in 1..=v {\\n            dp[i as usize][(i-1) as usize] = 0;\\n            for j in i..v+h {\\n                dp[i as usize][j as usize] = 1;\\n                for k in 0..i {\\n                    dp[i as usize][j as usize] += dp[(i-k) as usize][(j-k-1) as usize];   \\n                }\\n            }\\n        }\\n        \\n        let mut real_k = k - 1;\\n        let mut highest = v+h-1;\\n        let mut answer = String::new();\\n        for i in 0..v {\\n            let p = v - i;\\n            while dp[p as usize][highest as usize] > real_k {\\n                answer.push(\\'H\\');\\n                highest -= 1;\\n                \\n            }\\n            answer.push(\\'V\\');\\n            real_k -= dp[p as usize][highest as usize];\\n            highest -= 1;\\n        }\\n        for _ in 0..=highest {\\n            answer.push(\\'H\\');\\n        }\\n\\n       answer\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\"H....HHHHVHHH....HHVVV...VVV\"  == > i = count(\"v\")\\n          ^ j\\n```\n```\\nuse std::cmp;\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        let h = destination[1];\\n        let v = destination[0];\\n        \\n        let mut dp: Vec<Vec<i32>> = vec![];\\n        for i in 0..=v {\\n            dp.push(vec![-1; (h+v) as usize]);\\n        }\\n        for i in 1..=v {\\n            dp[i as usize][(i-1) as usize] = 0;\\n            for j in i..v+h {\\n                dp[i as usize][j as usize] = 1;\\n                for k in 0..i {\\n                    dp[i as usize][j as usize] += dp[(i-k) as usize][(j-k-1) as usize];   \\n                }\\n            }\\n        }\\n        \\n        let mut real_k = k - 1;\\n        let mut highest = v+h-1;\\n        let mut answer = String::new();\\n        for i in 0..v {\\n            let p = v - i;\\n            while dp[p as usize][highest as usize] > real_k {\\n                answer.push(\\'H\\');\\n                highest -= 1;\\n                \\n            }\\n            answer.push(\\'V\\');\\n            real_k -= dp[p as usize][highest as usize];\\n            highest -= 1;\\n        }\\n        for _ in 0..=highest {\\n            answer.push(\\'H\\');\\n        }\\n\\n       answer\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927483,
                "title": "java-1ms-o-row-col-if-computation-of-combination-is-o-1",
                "content": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder b = new StringBuilder();\\n        helper(destination[0], destination[1], k, b);\\n        return b.toString();\\n    }\\n    \\n    void helper(int row, int col, int k, StringBuilder b) {\\n        if(k == 1 || row == 0 || col == 0) {\\n            for(int i = 0; i < col; i++) {\\n                b.append(\\'H\\');\\n            }\\n            for(int i = 0; i < row; i++) {\\n                b.append(\\'V\\');\\n            }\\n            return;\\n        }\\n        int add = C(row + col - 1, row);\\n        if(k <= add) {\\n            b.append(\\'H\\');\\n            helper(row, col - 1, k, b);\\n        }\\n        else {\\n            b.append(\\'V\\');\\n            helper(row - 1, col, k - add, b);\\n        }\\n    }\\n    \\n    int C(int n, int k) {\\n        double res = 1;\\n        for (int i = 1; i <= k; ++i)\\n            res = res * (n - k + i) / i;\\n        return (int)(res + 0.01);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        StringBuilder b = new StringBuilder();\\n        helper(destination[0], destination[1], k, b);\\n        return b.toString();\\n    }\\n    \\n    void helper(int row, int col, int k, StringBuilder b) {\\n        if(k == 1 || row == 0 || col == 0) {\\n            for(int i = 0; i < col; i++) {\\n                b.append(\\'H\\');\\n            }\\n            for(int i = 0; i < row; i++) {\\n                b.append(\\'V\\');\\n            }\\n            return;\\n        }\\n        int add = C(row + col - 1, row);\\n        if(k <= add) {\\n            b.append(\\'H\\');\\n            helper(row, col - 1, k, b);\\n        }\\n        else {\\n            b.append(\\'V\\');\\n            helper(row - 1, col, k - add, b);\\n        }\\n    }\\n    \\n    int C(int n, int k) {\\n        double res = 1;\\n        for (int i = 1; i <= k; ++i)\\n            res = res * (n - k + i) / i;\\n        return (int)(res + 0.01);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925290,
                "title": "simple-java-solution",
                "content": "```\\npublic String kthSmallestPath(int[] dest, int k) {\\n\\tfinal int MX = 33;\\n\\tint comb[][] = new int[MX][MX];\\n\\tfor (int n = 1; n < MX; n++) {\\n\\t\\tcomb[n][1] = n;\\n\\t\\tcomb[n][n] = 1;\\n\\t}\\n\\tfor (int n = 2; n < MX; n++)\\n\\t\\tfor (int r = 2; r < n; r++)\\n\\t\\t\\tcomb[n][r] = comb[n - 1][r] + comb[n - 1][r - 1];\\n\\n\\tint t = dest[0] + dest[1];\\n\\tint rem = dest[0];\\n\\n\\tStringBuilder builder = new StringBuilder();\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tif (comb[t - i - 1][rem] < k && rem > 0) {\\n\\t\\t\\tbuilder.append(\"V\");\\n\\t\\t\\tk -= comb[t - i - 1][rem];\\n\\t\\t\\trem--;\\n\\t\\t} else\\n\\t\\t\\tbuilder.append(\"H\");\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String kthSmallestPath(int[] dest, int k) {\\n\\tfinal int MX = 33;\\n\\tint comb[][] = new int[MX][MX];\\n\\tfor (int n = 1; n < MX; n++) {\\n\\t\\tcomb[n][1] = n;\\n\\t\\tcomb[n][n] = 1;\\n\\t}\\n\\tfor (int n = 2; n < MX; n++)\\n\\t\\tfor (int r = 2; r < n; r++)\\n\\t\\t\\tcomb[n][r] = comb[n - 1][r] + comb[n - 1][r - 1];\\n\\n\\tint t = dest[0] + dest[1];\\n\\tint rem = dest[0];\\n\\n\\tStringBuilder builder = new StringBuilder();\\n\\tfor (int i = 0; i < t; i++) {\\n\\t\\tif (comb[t - i - 1][rem] < k && rem > 0) {\\n\\t\\t\\tbuilder.append(\"V\");\\n\\t\\t\\tk -= comb[t - i - 1][rem];\\n\\t\\t\\trem--;\\n\\t\\t} else\\n\\t\\t\\tbuilder.append(\"H\");\\n\\t}\\n\\treturn builder.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 923115,
                "title": "c-o-n-m-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring kthSmallestPath(vector<int>& arr, int k) {\\n\\t\\tconst int n = arr[0], m = arr[1];\\n\\t\\tlong long x = m;\\n\\t\\tfor(int i = m + 1; i <= n + m; i++)\\n\\t\\t\\tx = x * i / (i - m);\\n\\t\\tstring ans(n + m, \\'V\\');\\n\\t\\tfor(int i = 0, a = m, b = n; i < n + m; i++) {\\n\\t\\t\\tx /= a + b;\\n\\t\\t\\tif(a && k <= x)\\n\\t\\t\\t\\tans[i] = \\'H\\', x *= --a;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk -= x, x *= b--;\\n\\t\\t}\\n\\t\\treturn move(ans);\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring kthSmallestPath(vector<int>& arr, int k) {\\n\\t\\tconst int n = arr[0], m = arr[1];\\n\\t\\tlong long x = m;\\n\\t\\tfor(int i = m + 1; i <= n + m; i++)\\n\\t\\t\\tx = x * i / (i - m);\\n\\t\\tstring ans(n + m, \\'V\\');\\n\\t\\tfor(int i = 0, a = m, b = n; i < n + m; i++) {\\n\\t\\t\\tx /= a + b;\\n\\t\\t\\tif(a && k <= x)\\n\\t\\t\\t\\tans[i] = \\'H\\', x *= --a;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk -= x, x *= b--;\\n\\t\\t}\\n\\t\\treturn move(ans);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922025,
                "title": "java-very-short-code-beats-100-with-explanation",
                "content": "Here as \\'V\\'>\\'H\\', placement of \\'V\\' determines the lexicographical rank.\\n\\nEx: V=3,H=3,k=18.Now we have 6 places and 3V\\'s to arrange in 6C3 ways=20 ways.\\nSo rank can range from 1 to 20. 1 being lexicographically smallest .\\n\\n**[ I ]recur(3 H,3 V,rank 18)**\\nif first V is placed at index=3,\\n_ _ _V _ _  , rank=1, because remaining 2 V\\'s will be placed in 2 blanks to left\\nif first V is placed at index=2,\\n_ _ V _ _ _,then we have 3 blanks, and 2 V\\'s to arrange.Rank will range from 2 to 4 (1+3C2 )\\nif first V is placed at index 1,\\n_V_ _ _ _, then we have 4 blanks anf 2 V\\'s to arrange. Rank will range from 5 to 10 (4+4C2)\\nif first V is placed at index 0,\\nV _ _ _ _ _, then we have 5 blanks and 2 V\\'s to arrange. Rank will range from 11 to 20 (10+5C2).\\n\\nTo get rank  k=18,we need to place V at index 0. Now we have 5 blanks, 2 V\\'s and we need to get rank=18-10=8. So we  do recursive call to dfs(3 H ,2 V, rank 8)\\n\\n**[ II ]recur(3 H,2 V,rank 8)**\\nHere rank can range from 1 to 5C2=1 to 10.\\nif first V is placed at index=3,\\n_ _ _ V _ , rank=1 beacuse remaining 1 V will be placed at blank at left.\\nif first V placed at index=2,\\n_ _ V _ _, then we have 2 blanks, and 1 V to arrange.Rank will range from 2 to 3 (1+2C1 )\\nif first V is placed at index 1,\\n_V_ _ _, then we have 3 blanks anf 1 V\\'s to arrange. Rank will range from 4 to 6 (4+3C1)\\nif first V is placed at index 0,\\nV _ _ _ _, then we have 4 blanks and 1 V\\'s to arrange. Rank will range from 7 to 10 (7+4C1).\\n\\nTo get rank=8, we need to put V at index 0. Now we have 4 blanks 1 V and rank=8-6=2.\\n\\n**[III] recur( 3 H, 1 V, rank=2)**\\nAs we are left with 1 V, rank is directly determined by index of V. To get rank=2, we need to place V at before last index  _ _ V _.\\n\\nSo we place V at index=0,1,4 and rest are \\'H\\'. To get rank 18.\\n\\n**Base conditions,**\\n1.if only 1 V left, then place it accordingly to required rank.\\n2.If rank 1 is required ,then arrange all V\\'s from last index.\\n\\nHere combination array is used to compute nCr. as nCr= n-1Cr-1 * n/n-r. \\n```\\nclass Solution {\\n    char[] ch;\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int H=destination[1],V=destination[0];\\n        ch=new char[H+V];Arrays.fill(ch,\\'H\\');\\n        recur(H,V,k);\\n        return new String(ch);\\n    }\\n    private void recur(int H,int V,int k){\\n        //Combination array from r-1Cr-1 to n-1Cr-1\\n        if(V==1) ch[ch.length-k]=\\'V\\';\\n        else if(k==1) while(V-->0) ch[ch.length-1-V]=\\'V\\';\\n        else{\\n            int len=(H+V)-(V-1),r=V-1;\\n            int[] comb=new int[len];\\n            comb[0]=1;\\n            for(int i=1;i<len;i++) comb[i]=(comb[i-1]*(r+i))/i;\\n            for(int i=1;i<len;i++) comb[i]+=comb[i-1];\\n            for(int i=0;i<len;i++){\\n                if(k<=comb[i]){\\n                    ch[ch.length-(i+r+1)]=\\'V\\';\\n                    recur(H,V-1,k-comb[i-1]);\\n                    break;\\n                }\\n            }\\n        }        \\n    }\\n}\\n```\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[] ch;\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int H=destination[1],V=destination[0];\\n        ch=new char[H+V];Arrays.fill(ch,\\'H\\');\\n        recur(H,V,k);\\n        return new String(ch);\\n    }\\n    private void recur(int H,int V,int k){\\n        //Combination array from r-1Cr-1 to n-1Cr-1\\n        if(V==1) ch[ch.length-k]=\\'V\\';\\n        else if(k==1) while(V-->0) ch[ch.length-1-V]=\\'V\\';\\n        else{\\n            int len=(H+V)-(V-1),r=V-1;\\n            int[] comb=new int[len];\\n            comb[0]=1;\\n            for(int i=1;i<len;i++) comb[i]=(comb[i-1]*(r+i))/i;\\n            for(int i=1;i<len;i++) comb[i]+=comb[i-1];\\n            for(int i=0;i<len;i++){\\n                if(k<=comb[i]){\\n                    ch[ch.length-(i+r+1)]=\\'V\\';\\n                    recur(H,V-1,k-comb[i-1]);\\n                    break;\\n                }\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921421,
                "title": "python-sub-problem-s-o-comb-r-c-r",
                "content": "Divide to sub problems.\\nif math.comb(R + C - 1, R) >= k, get \"H\",\\nelse, get \"V\",\\n\\ngo to sub problem.\\n\\n```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        ans = \"\"\\n        R, C = destination\\n\\n        while R + C > 0:\\n            child_cnt = math.comb(R + C - 1, R)\\n            if child_cnt >= k :\\n                ans += \"H\"\\n                C -= 1\\n            else:\\n                ans += \"V\"\\n                R -= 1\\n                k -= child_cnt\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        ans = \"\"\\n        R, C = destination\\n\\n        while R + C > 0:\\n            child_cnt = math.comb(R + C - 1, R)\\n            if child_cnt >= k :\\n                ans += \"H\"\\n                C -= 1\\n            else:\\n                ans += \"V\"\\n                R -= 1\\n                k -= child_cnt\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921116,
                "title": "dynamic-programming-solution-in-c-with-explanation",
                "content": "```\\nchar* kthSmallestPath(int* destination, int destinationSize, int k) {\\n  const int m = destination[0];\\n  const int n = destination[1];\\n\\n  // First compute the total number of paths to all destinations.\\n  int total[m + 1][n + 1];\\n  for (int i = 0; i < m + 1; ++i) {\\n    for (int j = 0; j < n + 1; ++j) {\\n      if (i == 0 || j == 0) {\\n        // Only one way to reach a destination in the 0th row or col.\\n        total[i][j] = 1;\\n      } else {\\n        // Number of paths to this destination is the sum of the number of paths\\n        // to one above and one left.\\n        total[i][j] = total[i - 1][j] + total[i][j - 1];\\n      }\\n    }\\n  }\\n\\n  // We will always take exactly m+n steps. The +1 is for the null terminator.\\n  char* result = malloc(m + n + 1);\\n  int i = 0, j = 0;\\n  for (int index = 0; index < m + n; ++index) {\\n    if (i == m) {\\n      // Must move right.\\n      result[index] = \\'H\\';\\n      continue;\\n    }\\n\\n    if (j == n) {\\n      // Must move down.\\n      result[index] = \\'V\\';\\n      continue;\\n    }\\n\\n    // Number of ways to get to destination if we move right.\\n    const int n_right = total[m - i][n - j - 1];\\n\\n    // All right movements sort before all down movements. If we can move right\\n    // and still have k way to get to the destination, then that is what we\\n    // should do.\\n    //\\n    // Otherwise, we will move down, thus skipping n_right number of paths (and\\n    // subtracting that from k).\\n    if (n_right >= k) {\\n      ++j;\\n      result[index] = \\'H\\';\\n    } else {\\n      ++i;\\n      result[index] = \\'V\\';\\n      k -= n_right;\\n    }\\n  }\\n\\n  result[m + n] = \\'\\\\0\\';\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nchar* kthSmallestPath(int* destination, int destinationSize, int k) {\\n  const int m = destination[0];\\n  const int n = destination[1];\\n\\n  // First compute the total number of paths to all destinations.\\n  int total[m + 1][n + 1];\\n  for (int i = 0; i < m + 1; ++i) {\\n    for (int j = 0; j < n + 1; ++j) {\\n      if (i == 0 || j == 0) {\\n        // Only one way to reach a destination in the 0th row or col.\\n        total[i][j] = 1;\\n      } else {\\n        // Number of paths to this destination is the sum of the number of paths\\n        // to one above and one left.\\n        total[i][j] = total[i - 1][j] + total[i][j - 1];\\n      }\\n    }\\n  }\\n\\n  // We will always take exactly m+n steps. The +1 is for the null terminator.\\n  char* result = malloc(m + n + 1);\\n  int i = 0, j = 0;\\n  for (int index = 0; index < m + n; ++index) {\\n    if (i == m) {\\n      // Must move right.\\n      result[index] = \\'H\\';\\n      continue;\\n    }\\n\\n    if (j == n) {\\n      // Must move down.\\n      result[index] = \\'V\\';\\n      continue;\\n    }\\n\\n    // Number of ways to get to destination if we move right.\\n    const int n_right = total[m - i][n - j - 1];\\n\\n    // All right movements sort before all down movements. If we can move right\\n    // and still have k way to get to the destination, then that is what we\\n    // should do.\\n    //\\n    // Otherwise, we will move down, thus skipping n_right number of paths (and\\n    // subtracting that from k).\\n    if (n_right >= k) {\\n      ++j;\\n      result[index] = \\'H\\';\\n    } else {\\n      ++i;\\n      result[index] = \\'V\\';\\n      k -= n_right;\\n    }\\n  }\\n\\n  result[m + n] = \\'\\\\0\\';\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 921115,
                "title": "python-intuitive-recursive-solution",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # start from HHH...VVV, we then iteratively put V forward and \\n        # check if the number of combinations would exceed k\\n        \\n        V, H = destination\\n        \\n        def cal_num_comb(V, H):\\n            ans1, ans2 = 1, 1\\n            for i in range(V):\\n                ans1 *= (H+V-i)\\n                ans2 *= (V-i)\\n            return ans1 / ans2\\n        \\n        def helper(V, H, k):\\n            if k == 1: return \\'H\\'*H + \\'V\\'*V\\n            k -= 1\\n            for i in range(1, H+1):\\n                num_comb = cal_num_comb(V-1, i)\\n                if num_comb < k:\\n                    k -= num_comb\\n                else:\\n                    return \\'H\\'*(H-i)+\\'V\\' + helper(V-1, i, k)\\n        \\n        return helper(V, H, k)\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        # start from HHH...VVV, we then iteratively put V forward and \\n        # check if the number of combinations would exceed k\\n        \\n        V, H = destination\\n        \\n        def cal_num_comb(V, H):\\n            ans1, ans2 = 1, 1\\n            for i in range(V):\\n                ans1 *= (H+V-i)\\n                ans2 *= (V-i)\\n            return ans1 / ans2\\n        \\n        def helper(V, H, k):\\n            if k == 1: return \\'H\\'*H + \\'V\\'*V\\n            k -= 1\\n            for i in range(1, H+1):\\n                num_comb = cal_num_comb(V-1, i)\\n                if num_comb < k:\\n                    k -= num_comb\\n                else:\\n                    return \\'H\\'*(H-i)+\\'V\\' + helper(V-1, i, k)\\n        \\n        return helper(V, H, k)\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 920664,
                "title": "c-solution",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll C(ll n, ll k) {\\n        double res = 1;\\n        for (ll i = 1; i <= k; ++i)\\n            res=res*(n-k+i)/i;\\n        return (ll)(res+0.01);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        ll H=destination[1], V=destination[0];\\n        string ans=\"\";\\n        while(k>0 && H>0 && V>0){\\n            ll tmp=C(H+V-1, V);\\n            if(k<=tmp){\\n                ans+=\\'H\\';\\n                H--;\\n            }\\n            else{\\n                k-=tmp;\\n                ans+=\\'V\\';\\n                V--;\\n            }\\n        }\\n        while(H>0){\\n            ans+=\\'H\\';\\n            H--;\\n        }\\n        while(V>0){\\n            ans+=\"V\";\\n            V--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll C(ll n, ll k) {\\n        double res = 1;\\n        for (ll i = 1; i <= k; ++i)\\n            res=res*(n-k+i)/i;\\n        return (ll)(res+0.01);\\n    }\\n    \\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        ll H=destination[1], V=destination[0];\\n        string ans=\"\";\\n        while(k>0 && H>0 && V>0){\\n            ll tmp=C(H+V-1, V);\\n            if(k<=tmp){\\n                ans+=\\'H\\';\\n                H--;\\n            }\\n            else{\\n                k-=tmp;\\n                ans+=\\'V\\';\\n                V--;\\n            }\\n        }\\n        while(H>0){\\n            ans+=\\'H\\';\\n            H--;\\n        }\\n        while(V>0){\\n            ans+=\"V\";\\n            V--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920485,
                "title": "java-90-breaking-into-steps",
                "content": "First some key points:\\n\\n- Notice that `H` is the least lexicographical step always.\\n- Notice that when `V` is chosen over `H`, we skip over all paths ending with prefix `...H`.\\n\\t- E.g. Path= `HH`, if we choose `V` over `H` we skip over all path combinations starting with prefix `HHH`.\\n\\nThis now becomes a simpler problem of:\\n- Building a DP array of `numberOfPaths` to `destination`.\\n- Choose `H` whenever `numberOfPaths` from choosing `H` is >= `k`. \\n\\t- kth path is within.\\n- Choose `V` otherwise, removing `numberOfPaths` from choosing `H` from `k`.\\n\\t- Remove numberOfPath combinations from k.\\n\\n```java\\npublic String kthSmallestPath(int[] destination, int k) {\\n\\tint height = destination[0] + 1;\\n\\tint width = destination[1] + 1;\\n\\n\\tint[][] dp = new int[height][width];\\n\\tkthSmallestPath(destination, 0, 0, dp);\\n\\n\\tStringBuilder sb = new StringBuilder(width + height);\\n\\tint y = 0;\\n\\tint x = 0;\\n\\twhile (y < destination[0] && x < destination[1]) {\\n\\t\\tif (isWithin(dp, y, x+1)) {\\n\\t\\t\\tint possibilitiesH = dp[y][x+1];\\n\\t\\t\\tif (possibilitiesH >= k) {\\n\\t\\t\\t\\tsb.append(\\'H\\');\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tk -= dp[y][x+1];\\n\\t\\t}\\n\\n\\t\\tsb.append(\\'V\\');\\n\\t\\ty++;\\n\\t}\\n\\twhile (y < destination[0]) {\\n\\t\\tsb.append(\\'V\\');\\n\\t\\ty++;\\n\\t}\\n\\twhile (x < destination[1]) {\\n\\t\\tsb.append(\\'H\\');\\n\\t\\tx++;\\n\\t}\\n\\treturn sb.toString();\\n}\\n\\nprivate int kthSmallestPath(int[] destination, int y, int x, int[][] dp) {\\n\\tif (!isWithin(dp, y, x)) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (y == destination[0] && x == destination[1]) {\\n\\t\\tdp[y][x] = 1;\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tif (dp[y][x] != 0) {\\n\\t\\treturn dp[y][x];\\n\\t}\\n\\n\\tdp[y][x] = kthSmallestPath(destination, y, x+1, dp) + kthSmallestPath(destination, y+1, x, dp);\\n\\treturn dp[y][x];\\n}\\n\\nprivate boolean isWithin(int[][] dp, int y, int x) {\\n\\treturn y >= 0 && y < dp.length && x >= 0 && x < dp[y].length;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic String kthSmallestPath(int[] destination, int k) {\\n\\tint height = destination[0] + 1;\\n\\tint width = destination[1] + 1;\\n\\n\\tint[][] dp = new int[height][width];\\n\\tkthSmallestPath(destination, 0, 0, dp);\\n\\n\\tStringBuilder sb = new StringBuilder(width + height);\\n\\tint y = 0;\\n\\tint x = 0;\\n\\twhile (y < destination[0] && x < destination[1]) {\\n\\t\\tif (isWithin(dp, y, x+1)) {\\n\\t\\t\\tint possibilitiesH = dp[y][x+1];\\n\\t\\t\\tif (possibilitiesH >= k) {\\n\\t\\t\\t\\tsb.append(\\'H\\');\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tk -= dp[y][x+1];\\n\\t\\t}\\n\\n\\t\\tsb.append(\\'V\\');\\n\\t\\ty++;\\n\\t}\\n\\twhile (y < destination[0]) {\\n\\t\\tsb.append(\\'V\\');\\n\\t\\ty++;\\n\\t}\\n\\twhile (x < destination[1]) {\\n\\t\\tsb.append(\\'H\\');\\n\\t\\tx++;\\n\\t}\\n\\treturn sb.toString();\\n}\\n\\nprivate int kthSmallestPath(int[] destination, int y, int x, int[][] dp) {\\n\\tif (!isWithin(dp, y, x)) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (y == destination[0] && x == destination[1]) {\\n\\t\\tdp[y][x] = 1;\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tif (dp[y][x] != 0) {\\n\\t\\treturn dp[y][x];\\n\\t}\\n\\n\\tdp[y][x] = kthSmallestPath(destination, y, x+1, dp) + kthSmallestPath(destination, y+1, x, dp);\\n\\treturn dp[y][x];\\n}\\n\\nprivate boolean isWithin(int[][] dp, int y, int x) {\\n\\treturn y >= 0 && y < dp.length && x >= 0 && x < dp[y].length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920467,
                "title": "rust-translated-0ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        fn helper(dp: &Vec<Vec<i32>>, mut i: usize, mut j: usize, k: usize, ans: &mut String) {\\n            if i == dp.len() - 1 {\\n                loop {\\n                    j += 1;\\n                    if j < dp[0].len() {\\n                        ans.push(\\'H\\');\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return;\\n            }\\n            if j == dp[0].len() - 1 {\\n                loop {\\n                    i += 1;\\n                    if i < dp.len() {\\n                        ans.push(\\'V\\');\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return;\\n            }\\n            if dp[i][j + 1] >= k as i32 {\\n                ans.push(\\'H\\');\\n                helper(dp, i, j + 1, k, ans);\\n            } else {\\n                ans.push(\\'V\\');\\n                helper(dp, i + 1, j, k - dp[i][j + 1] as usize, ans);\\n            }\\n        }\\n\\n        let m = destination[0] as usize;\\n        let n = destination[1] as usize;\\n        let mut dp = vec![vec![0; n + 1]; m + 1];\\n        for i in (0..m + 1).rev() {\\n            for j in (0..n + 1).rev() {\\n                if i == m && j == n {\\n                    dp[i][j] = 1;\\n                } else if i == m {\\n                    dp[i][j] = dp[i][j + 1];\\n                } else if j == n {\\n                    dp[i][j] = dp[i + 1][j];\\n                } else {\\n                    dp[i][j] = dp[i + 1][j] + dp[i][j + 1];\\n                }\\n            }\\n        }\\n        let mut ans = String::new();\\n        helper(&dp, 0, 0, k as usize, &mut ans);\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_kth_smallest_path() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 1),\\n            \"HHHVV\".to_owned()\\n        );\\n    }\\n\\n    #[test]\\n    fn test_kth_smallest_path_02() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 2),\\n            \"HHVHV\".to_owned()\\n        );\\n    }\\n\\n    #[test]\\n    fn test_kth_smallest_path_03() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 3),\\n            \"HHVVH\".to_owned()\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn kth_smallest_path(destination: Vec<i32>, k: i32) -> String {\\n        fn helper(dp: &Vec<Vec<i32>>, mut i: usize, mut j: usize, k: usize, ans: &mut String) {\\n            if i == dp.len() - 1 {\\n                loop {\\n                    j += 1;\\n                    if j < dp[0].len() {\\n                        ans.push(\\'H\\');\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return;\\n            }\\n            if j == dp[0].len() - 1 {\\n                loop {\\n                    i += 1;\\n                    if i < dp.len() {\\n                        ans.push(\\'V\\');\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return;\\n            }\\n            if dp[i][j + 1] >= k as i32 {\\n                ans.push(\\'H\\');\\n                helper(dp, i, j + 1, k, ans);\\n            } else {\\n                ans.push(\\'V\\');\\n                helper(dp, i + 1, j, k - dp[i][j + 1] as usize, ans);\\n            }\\n        }\\n\\n        let m = destination[0] as usize;\\n        let n = destination[1] as usize;\\n        let mut dp = vec![vec![0; n + 1]; m + 1];\\n        for i in (0..m + 1).rev() {\\n            for j in (0..n + 1).rev() {\\n                if i == m && j == n {\\n                    dp[i][j] = 1;\\n                } else if i == m {\\n                    dp[i][j] = dp[i][j + 1];\\n                } else if j == n {\\n                    dp[i][j] = dp[i + 1][j];\\n                } else {\\n                    dp[i][j] = dp[i + 1][j] + dp[i][j + 1];\\n                }\\n            }\\n        }\\n        let mut ans = String::new();\\n        helper(&dp, 0, 0, k as usize, &mut ans);\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_kth_smallest_path() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 1),\\n            \"HHHVV\".to_owned()\\n        );\\n    }\\n\\n    #[test]\\n    fn test_kth_smallest_path_02() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 2),\\n            \"HHVHV\".to_owned()\\n        );\\n    }\\n\\n    #[test]\\n    fn test_kth_smallest_path_03() {\\n        assert_eq!(\\n            Solution::kth_smallest_path(vec![2, 3], 3),\\n            \"HHVVH\".to_owned()\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920395,
                "title": "java-combinatorics-math",
                "content": "```java\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int c = destination[1];\\n        int r = destination[0];\\n        \\n        StringBuilder res = new StringBuilder();\\n        while (r > 0 || c > 0) {\\n            if (r == 0) {\\n                res.append(\\'H\\');\\n                c--;\\n                continue;\\n            }\\n            if (c == 0) {\\n                res.append(\\'V\\');\\n                r--;\\n                continue;\\n            }\\n            double total = nCr(r, c - 1);\\n            if (k > total) {\\n                k -= total;\\n                res.append(\\'V\\');\\n                r--;\\n            } else {\\n                res.append(\\'H\\');\\n                c--;\\n            }\\n        }\\n        return res.toString();\\n    }\\n    \\n    double nCr(int m, int n) {\\n        if (m > n) return nCr(n, m);\\n        double res = 1;\\n        \\n        for (int i = 0; i < n; i++) {\\n            res = res * (m + n - i);\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            res /= i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String kthSmallestPath(int[] destination, int k) {\\n        int c = destination[1];\\n        int r = destination[0];\\n        \\n        StringBuilder res = new StringBuilder();\\n        while (r > 0 || c > 0) {\\n            if (r == 0) {\\n                res.append(\\'H\\');\\n                c--;\\n                continue;\\n            }\\n            if (c == 0) {\\n                res.append(\\'V\\');\\n                r--;\\n                continue;\\n            }\\n            double total = nCr(r, c - 1);\\n            if (k > total) {\\n                k -= total;\\n                res.append(\\'V\\');\\n                r--;\\n            } else {\\n                res.append(\\'H\\');\\n                c--;\\n            }\\n        }\\n        return res.toString();\\n    }\\n    \\n    double nCr(int m, int n) {\\n        if (m > n) return nCr(n, m);\\n        double res = 1;\\n        \\n        for (int i = 0; i < n; i++) {\\n            res = res * (m + n - i);\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            res /= i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920380,
                "title": "java-solution-bst-searching",
                "content": "1. build a 2D matrix to record number of path from point (x,y), e.g. for [2,3]\\n---------\\n10 6 3 1\\n 4  3 2 1\\n 1  1 1 1\\npoint (0, 1) has 6 paths 1st-6th\\npoint (1, 0) has 4 paths 7th-10th\\n\\nif k is 1-6, then should go right\\nif k is 7-10, then should go down, if going down, need to minus the right side point, and the problem converted to pick up the k-dp[i][j+1] from point (i+1, j)\\nJust like BST searching.\\n\\n```\\nclass Solution {\\n    \\n    int[][] dp;\\n    \\n    void f(int i, int j, int row, int col){\\n        if(i>=row || j>=col || dp[i][j]!=0) return;\\n        f(i+1, j, row, col);\\n        f(i, j+1, row, col);\\n        dp[i][j]=dp[i+1][j]+dp[i][j+1];\\n    }\\n\\n    public String kthSmallestPath(int[] d, int k) {\\n        \\n        int row = d[0]+1;\\n        int col = d[1]+1;\\n        dp = new int[row+1][col+1];\\n        dp[row-1][col-1]=1;\\n\\n        f(0, 0, row, col);\\n\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0, j=0; ;){\\n            if(i==row-1 && j==col-1) break;\\n            if(dp[i][j+1]>=k){\\n                sb.append(\\'H\\');\\n                j++;\\n            }  else {\\n                sb.append(\\'V\\');\\n                k-=dp[i++][j+1];\\n            }\\n        }\\n\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[][] dp;\\n    \\n    void f(int i, int j, int row, int col){\\n        if(i>=row || j>=col || dp[i][j]!=0) return;\\n        f(i+1, j, row, col);\\n        f(i, j+1, row, col);\\n        dp[i][j]=dp[i+1][j]+dp[i][j+1];\\n    }\\n\\n    public String kthSmallestPath(int[] d, int k) {\\n        \\n        int row = d[0]+1;\\n        int col = d[1]+1;\\n        dp = new int[row+1][col+1];\\n        dp[row-1][col-1]=1;\\n\\n        f(0, 0, row, col);\\n\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0, j=0; ;){\\n            if(i==row-1 && j==col-1) break;\\n            if(dp[i][j+1]>=k){\\n                sb.append(\\'H\\');\\n                j++;\\n            }  else {\\n                sb.append(\\'V\\');\\n                k-=dp[i++][j+1];\\n            }\\n        }\\n\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920155,
                "title": "python-dp-solution-o-m-n",
                "content": "while choose V or H for each choice:\\neg: for first step choose, group order is like: ```[h...] < [v...] ```\\n=>we want to know which group the kth is in: first group or second group.\\nif numH<k,mean should choose [v...] group,k-=numH\\nso we want to pre-calculate numbers of group with prefix [...]. \\nif use combination formula to get C(m,n) for each m,n, cost O(n) to calculate (m*..*m-n+1)/n!,which will cost O(n*m*n) in total.\\ndp[m][n] is numbers of steps with m row and n cols.\\njust use dp[m][n]=dp[m][n-1]+dp[m-1][n], which cost O(m*n) in total to dp array.\\n```\\nclass Solution(object):\\n    def kthSmallestPath(self, des, k):\\n        V,H=des[0],des[1]\\n        dp=[[1]*(H+1) for _ in range(V+1)]\\n        for i in range(1,V+1):\\n            for j in range(1,H+1):\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]\\n        res=[]\\n        while V>0 and H>0:#go until there is only one kind of move. \\n            if dp[V][H-1]<k:\\n                k-=dp[V][H-1]\\n                res.append(\\'V\\')\\n                V-=1\\n            else:\\n                res.append(\\'H\\')\\n                H-=1\\n        for _ in range(V):\\n            res.append(\\'V\\')\\n        for _ in range(H):\\n            res.append(\\'H\\')\\n        return \\'\\'.join(res)",
                "solutionTags": [],
                "code": "```[h...] < [v...] ```",
                "codeTag": "Unknown"
            },
            {
                "id": 919988,
                "title": "c-faster-than-100",
                "content": "The main idea is that at every timestep, we need to calculate how many paths we have after we choose \"H\" .\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int CombinationNum(int dx, int dy)\\n    {\\n        int all_step = dx + dy, product = 1;\\n        int start = max(dx, dy), m = min(dx, dy);\\n        for(int i=start+1, j=1; i<=all_step, j<= m; i++, j++)\\n        {\\n            product = product * i / j;\\n        }\\n        return product;\\n    }\\n    string traverse(vector<int> &destination, int k, int x, int y)\\n    {\\n        if(x == destination[0] && y == destination[1]) return \"\";\\n        \\n        int num = CombinationNum(destination[0] - x , destination[1] - y - 1);\\n        if(num >= k && y < destination[1])\\n            return traverse(destination, k, x, y+1) + \"H\";\\n        else\\n            return traverse(destination, k-num, x+1, y) + \"V\";\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        string ret = traverse(destination, k, 0, 0);\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int CombinationNum(int dx, int dy)\\n    {\\n        int all_step = dx + dy, product = 1;\\n        int start = max(dx, dy), m = min(dx, dy);\\n        for(int i=start+1, j=1; i<=all_step, j<= m; i++, j++)\\n        {\\n            product = product * i / j;\\n        }\\n        return product;\\n    }\\n    string traverse(vector<int> &destination, int k, int x, int y)\\n    {\\n        if(x == destination[0] && y == destination[1]) return \"\";\\n        \\n        int num = CombinationNum(destination[0] - x , destination[1] - y - 1);\\n        if(num >= k && y < destination[1])\\n            return traverse(destination, k, x, y+1) + \"H\";\\n        else\\n            return traverse(destination, k-num, x+1, y) + \"V\";\\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        string ret = traverse(destination, k, 0, 0);\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919957,
                "title": "simple-javascript-combination-solution",
                "content": "if prefix of s is \\'V\\', the rank is at least \"combination of s with prefix \\'H\\' \"\\n```\\nlet kthSmallestPath = function(destination, k) {\\n\\tconst [V, H] = destination\\n\\tconst N = V + H\\n\\tlet s = \\'\\', n = N, v = V, h = H\\n\\twhile (s.length < N) {\\n\\t\\tlet c = p(n - 1, v)\\n\\t\\tif (h > 0 && c >= k) {\\n\\t\\t\\ts += \\'H\\'\\n\\t\\t\\th--\\n\\t\\t\\tn--\\n\\t\\t}else {\\n\\t\\t\\ts += \\'V\\'\\n\\t\\t\\tk -= c\\n\\t\\t\\tv--\\n\\t\\t\\tn--\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n\\nfunction p(n, r) {\\n\\tlet base = 1\\n\\tfor (let i = r + 1; i <= n; i++) {\\n\\t\\tbase *= i\\n\\t}\\n\\tfor (let i = 1; i <= n - r; i++) {\\n\\t\\tbase /= i\\n\\t}\\n\\treturn base\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Combinatorics"
                ],
                "code": "```\\nlet kthSmallestPath = function(destination, k) {\\n\\tconst [V, H] = destination\\n\\tconst N = V + H\\n\\tlet s = \\'\\', n = N, v = V, h = H\\n\\twhile (s.length < N) {\\n\\t\\tlet c = p(n - 1, v)\\n\\t\\tif (h > 0 && c >= k) {\\n\\t\\t\\ts += \\'H\\'\\n\\t\\t\\th--\\n\\t\\t\\tn--\\n\\t\\t}else {\\n\\t\\t\\ts += \\'V\\'\\n\\t\\t\\tk -= c\\n\\t\\t\\tv--\\n\\t\\t\\tn--\\n\\t\\t}\\n\\t}\\n\\treturn s\\n}\\n\\nfunction p(n, r) {\\n\\tlet base = 1\\n\\tfor (let i = r + 1; i <= n; i++) {\\n\\t\\tbase *= i\\n\\t}\\n\\tfor (let i = 1; i <= n - r; i++) {\\n\\t\\tbase /= i\\n\\t}\\n\\treturn base\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919926,
                "title": "c-combination-easy-to-understand",
                "content": "To get to the **destination(row, col)**, we can only take down step or right step. \\n**The total step is (row + col) with row \"V\" steps and col \"V\" steps;**  \\nIn those (row + col) oprations, we have to chose row\\'s operation to take down steps and the left are all right steps; \\nThe total possibale methods is nCr(row + col, row); We have to find kth smallest. \\n\\nObviously, the smallest must start with \"H\", the largerst must start with \"V\";\\nFor example with destination (2, 3), 2hen the first character is H, H**** represent  smallest nCr(2+3-1,2) combination. \\nwhen k <nCr(2+3-1,2), the first character must be \"H\" otherwise it is \"V\";\\nwe can iterative fill the string;\\n```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& des, int k) {\\n        int row = des[0], col = des[1];\\n        vector<vector<int>> comb(31, vector<int>(31, 0));\\n        comb[0][0] = comb[1][0] = comb[1][1] = 1;\\n        for(int i=2; i<=30;i++)  \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0||j==i)\\n                    comb[i][j] =1;\\n                else\\n                    comb[i][j] = comb[i-1][j] + comb[i-1][j-1];\\n            }\\n        return fill(row, col, comb, k);\\n    }\\n    string fill(int row, int col, vector<vector<int>>&comb, int k)\\n    {\\n\\n        if(k==1||row==0||col==0)\\n            return string(col,\\'H\\') + string(row, \\'V\\');\\n        if(k==comb[row+col][row])\\n            return string(row, \\'V\\') + string(col, \\'H\\');\\n        if(k<=comb[row+col-1][row])\\n            return \"H\" + fill(row, col-1,comb, k);\\n        else\\n            return \"V\" + fill(row-1, col, comb, k-comb[row+col-1][row]);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string kthSmallestPath(vector<int>& des, int k) {\\n        int row = des[0], col = des[1];\\n        vector<vector<int>> comb(31, vector<int>(31, 0));\\n        comb[0][0] = comb[1][0] = comb[1][1] = 1;\\n        for(int i=2; i<=30;i++)  \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0||j==i)\\n                    comb[i][j] =1;\\n                else\\n                    comb[i][j] = comb[i-1][j] + comb[i-1][j-1];\\n            }\\n        return fill(row, col, comb, k);\\n    }\\n    string fill(int row, int col, vector<vector<int>>&comb, int k)\\n    {\\n\\n        if(k==1||row==0||col==0)\\n            return string(col,\\'H\\') + string(row, \\'V\\');\\n        if(k==comb[row+col][row])\\n            return string(row, \\'V\\') + string(col, \\'H\\');\\n        if(k<=comb[row+col-1][row])\\n            return \"H\" + fill(row, col-1,comb, k);\\n        else\\n            return \"V\" + fill(row-1, col, comb, k-comb[row+col-1][row]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919843,
                "title": "simple-c-using-combination-table-4ms-beat-100",
                "content": "```\\nstring kthSmallestPath_(int left, int k, vector<vector<int>>& comTable, const int& tot) {\\n\\n\\tif (left == 0) return string(tot, \\'H\\');\\n\\n\\tint pos = tot - left;\\n\\n\\tstring res;\\n\\n\\tfor (; pos >= 0; --pos) {\\n\\n\\t\\tif (comTable[tot - pos - 1][left - 1] >= k) {\\n\\t\\t\\tres = kthSmallestPath_(left - 1, k, comTable, tot);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tk -= comTable[tot - pos - 1][left - 1];\\n\\n\\t}\\n\\n\\tres[pos] = \\'V\\';\\n\\n\\treturn res;\\n}\\n\\nstring kthSmallestPath(vector<int>& destination, int k) {\\n\\n\\tint tot = destination[0] + destination[1];\\n\\tvector<vector<int>> comTable(tot + 1, vector<int>(tot + 1, 0));\\n\\n\\n\\tfor (int i = 0; i <= tot; ++i) {\\n\\t\\tcomTable[i][0] = 1;\\n\\t\\tcomTable[i][i] = 1;\\n\\t\\tfor (int j = 1; j < i; ++j) {\\n\\t\\t\\tcomTable[i][j] = comTable[i - 1][j - 1] + comTable[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn kthSmallestPath_(destination[0], k, comTable, tot);\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring kthSmallestPath_(int left, int k, vector<vector<int>>& comTable, const int& tot) {\\n\\n\\tif (left == 0) return string(tot, \\'H\\');\\n\\n\\tint pos = tot - left;\\n\\n\\tstring res;\\n\\n\\tfor (; pos >= 0; --pos) {\\n\\n\\t\\tif (comTable[tot - pos - 1][left - 1] >= k) {\\n\\t\\t\\tres = kthSmallestPath_(left - 1, k, comTable, tot);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tk -= comTable[tot - pos - 1][left - 1];\\n\\n\\t}\\n\\n\\tres[pos] = \\'V\\';\\n\\n\\treturn res;\\n}\\n\\nstring kthSmallestPath(vector<int>& destination, int k) {\\n\\n\\tint tot = destination[0] + destination[1];\\n\\tvector<vector<int>> comTable(tot + 1, vector<int>(tot + 1, 0));\\n\\n\\n\\tfor (int i = 0; i <= tot; ++i) {\\n\\t\\tcomTable[i][0] = 1;\\n\\t\\tcomTable[i][i] = 1;\\n\\t\\tfor (int j = 1; j < i; ++j) {\\n\\t\\t\\tcomTable[i][j] = comTable[i - 1][j - 1] + comTable[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn kthSmallestPath_(destination[0], k, comTable, tot);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919797,
                "title": "c-o-r-c-solution-max-of-r-c-30",
                "content": "binomialCombination taken from G F G. Apologies.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int binomialCoeff(int n, int k)\\n    {\\n        dp.resize(n+1, vector<int>(k+1, 0));\\n        int i, j;\\n        for (i = 0; i <= n; i++)\\n        {\\n            for (j = 0; j <= min(i, k); j++)\\n            {\\n                if (j == 0 || j == i)\\n                    dp[i][j] = 1;\\n\\n                else\\n                    dp[i][j] = dp[i - 1][j - 1] +\\n                              dp[i - 1][j];\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n    \\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        binomialCoeff(30, 15);\\n        int nH = dest[1]-0;\\n        int nV = dest[0]-0;\\n        string ans = \"\";\\n        while (nH!=0 && nV!=0){\\n            if (dp[nH+nV-1][nV]>=k){\\n                nH--;\\n                ans+=\"H\";\\n            }\\n            else{\\n                k-=dp[nH+nV-1][nV];\\n                nV--;\\n                ans+=\"V\";\\n            }\\n            if (dp[nH+nV][nV]==k){\\n                while (nV){\\n                    ans+=\"V\"; nV--;\\n                }\\n        \\n                while (nH){\\n                    ans+=\"H\"; nH--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        while (nH){\\n            ans+=\"H\"; nH--;\\n        }\\n        \\n        while (nV){\\n            ans+=\"V\"; nV--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int binomialCoeff(int n, int k)\\n    {\\n        dp.resize(n+1, vector<int>(k+1, 0));\\n        int i, j;\\n        for (i = 0; i <= n; i++)\\n        {\\n            for (j = 0; j <= min(i, k); j++)\\n            {\\n                if (j == 0 || j == i)\\n                    dp[i][j] = 1;\\n\\n                else\\n                    dp[i][j] = dp[i - 1][j - 1] +\\n                              dp[i - 1][j];\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n    \\n    string kthSmallestPath(vector<int>& dest, int k) {\\n        binomialCoeff(30, 15);\\n        int nH = dest[1]-0;\\n        int nV = dest[0]-0;\\n        string ans = \"\";\\n        while (nH!=0 && nV!=0){\\n            if (dp[nH+nV-1][nV]>=k){\\n                nH--;\\n                ans+=\"H\";\\n            }\\n            else{\\n                k-=dp[nH+nV-1][nV];\\n                nV--;\\n                ans+=\"V\";\\n            }\\n            if (dp[nH+nV][nV]==k){\\n                while (nV){\\n                    ans+=\"V\"; nV--;\\n                }\\n        \\n                while (nH){\\n                    ans+=\"H\"; nH--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        while (nH){\\n            ans+=\"H\"; nH--;\\n        }\\n        \\n        while (nV){\\n            ans+=\"V\"; nV--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919573,
                "title": "java-greedy-path-construction-faster-than-100",
                "content": "We need to arrange `numH` H\\'s and `numV` V\\'s into a single string named `path`.\\n\\nIt must be lexicographically later than `k - 1` such strings. (That is, we should skip `k - 1` prior strings as we construct `path`.)\\n\\nWe will construct `path` left-to-right through sequence of `numH + numV` choices.\\n\\n**Key Ideas:** \\n1. Each time we choose a V for the next position, we *skip* all the lexicographically prior `path`\\'s with an H in that position. \\n2.  There are `skips = binom(numH + numV - 1, numH - 1)` such `path`\\'s.\\n3.  So each choice of V reduces the number of remaining skips to `k - 1 -  skips`.\\n4.  The conclusion is that we should choose a V iff `skips <= k - 1`; equivalently, `skips < k` or `!(skips >= k)`.\\n\\n```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int vsLeft = d[0], hsLeft = d[1];\\n        int allLeft = vsLeft + hsLeft;\\n        \\n        var path = new StringBuilder();\\n        while (allLeft > 0) {\\n            if (hsLeft > 0 && k <= binom[allLeft - 1][hsLeft - 1]) {\\n                path.append(\\'H\\');\\n                hsLeft--;\\n            } else {\\n                path.append(\\'V\\');\\n                if (hsLeft > 0) {\\n                    k -= binom[allLeft - 1][hsLeft - 1];\\n                }\\n                vsLeft--;\\n            }\\n            allLeft--;\\n        }\\n        return path.toString();\\n    }\\n    \\n    private static int[][] binom = new int[31][31];\\n    \\n    static {\\n        for (int i = 0; i <= 30; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) {\\n                    binom[i][j] = 1;\\n                } else {\\n                    binom[i][j] = binom[i - 1][j - 1] + binom[i - 1][j];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String kthSmallestPath(int[] d, int k) {\\n        int vsLeft = d[0], hsLeft = d[1];\\n        int allLeft = vsLeft + hsLeft;\\n        \\n        var path = new StringBuilder();\\n        while (allLeft > 0) {\\n            if (hsLeft > 0 && k <= binom[allLeft - 1][hsLeft - 1]) {\\n                path.append(\\'H\\');\\n                hsLeft--;\\n            } else {\\n                path.append(\\'V\\');\\n                if (hsLeft > 0) {\\n                    k -= binom[allLeft - 1][hsLeft - 1];\\n                }\\n                vsLeft--;\\n            }\\n            allLeft--;\\n        }\\n        return path.toString();\\n    }\\n    \\n    private static int[][] binom = new int[31][31];\\n    \\n    static {\\n        for (int i = 0; i <= 30; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) {\\n                    binom[i][j] = 1;\\n                } else {\\n                    binom[i][j] = binom[i - 1][j - 1] + binom[i - 1][j];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919547,
                "title": "python3-very-simple-recursion",
                "content": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        nV, nH = destination\\n        \\n        if nV == 0:\\n            return \"H\" * nH\\n        if nH == 0:\\n            return \"V\" * nV\\n        \\n        n_begin_with_H = comb(nH - 1 + nV,nV) \\n        \\n        if k <= n_begin_with_H:\\n            return \"H\" + self.kthSmallestPath([nV,nH-1],k)\\n        else:\\n            return \"V\" + self.kthSmallestPath([nV-1,nH],k - n_begin_with_H)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPath(self, destination: List[int], k: int) -> str:\\n        \\n        nV, nH = destination\\n        \\n        if nV == 0:\\n            return \"H\" * nH\\n        if nH == 0:\\n            return \"V\" * nV\\n        \\n        n_begin_with_H = comb(nH - 1 + nV,nV) \\n        \\n        if k <= n_begin_with_H:\\n            return \"H\" + self.kthSmallestPath([nV,nH-1],k)\\n        else:\\n            return \"V\" + self.kthSmallestPath([nV-1,nH],k - n_begin_with_H)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919465,
                "title": "python-greedy-math-recursion-o-mn-o-1-thoughts-beats-100-100",
                "content": "**Analysis :** \\n\\n1. When I first get this question, `kth + LexiOrder` gives me the idea of `greedy + dfs (Greedily add H as priority)` . However, this will be brute force and can go up to O(2**mn) time complexity which is not acceptable.\\n\\n2. Then the next thing jumped into my mind is see whether I can use `DFS + Memo` to lower down the time complexity. So I have to write down several examples to see if I can find a `pattern (Transition equation)`\\n\\n\\n**Thoughts :** \\n\\nFor DP, naturally you will try to find pattern, then I start to write :  `(2, 3)` as example\\n\\n`[\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"].`\\n\\nWith letters it might not be so obvious, `but It looks very similar to binary string`\\n\\n`11100, 11010. 11001, 10101, 10011, 01110.... so on so forth.`\\n\\n**Pattern**\\n\\nThen we find the pattern. \\nIt is using greedy thinking to put all `1` or `H` as early as possible and whole question can be translate into \\n\\n`Find Kth largest number that made up with 0 and 1`.\\n\\nSo we can using recursion to solve it easily. \\n\\n1. We can divide a big problem into a tree structure sub problems\\n\\n ```\\n     xxxxx\\n1xxxx + 0xxxx\\n....................\\n```\\n\\n\\n2. The total combination of subproblem `(1xxxx) = count Factorial of current `H` and `V` left (Math)`\\n3. if K is larger than the all combination started with `H` , then the current index should use `V` \\nso on so forth.\\n\\n\\n\\n**Full Answer**\\n```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        Hcount, Vcount = destination[1], destination[0]\\n        self.res = \\'\\'\\n        self.calculate(Hcount, Vcount, k)\\n        return self.res\\n    \\n    def calculate(self, Hcount, Vcount, k):\\n        \\n        if Hcount == 0:\\n            self.res = self.res + Vcount*\"V\"\\n            return\\n        elif Vcount == 0:\\n            self.res = self.res + Hcount*\"H\"\\n            return \\n        \\n        comboStartWithH = self.countFactorial(Hcount-1+Vcount)/(self.countFactorial(Hcount-1)*self.countFactorial(Vcount))\\n        if comboStartWithH >= k:\\n            self.res += \\'H\\'\\n            self.calculate(Hcount-1, Vcount, k)\\n        else:\\n            self.res += \\'V\\'\\n            self.calculate(Hcount, Vcount-1, k-comboStartWithH)\\n            \\n    \\n    def countFactorial(self, num):\\n        res = 1\\n        for i in range(1, num + 1):\\n            res = res * i\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n     xxxxx\\n1xxxx + 0xxxx\\n....................\\n```\n```\\nclass Solution(object):\\n    def kthSmallestPath(self, destination, k):\\n        \"\"\"\\n        :type destination: List[int]\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        Hcount, Vcount = destination[1], destination[0]\\n        self.res = \\'\\'\\n        self.calculate(Hcount, Vcount, k)\\n        return self.res\\n    \\n    def calculate(self, Hcount, Vcount, k):\\n        \\n        if Hcount == 0:\\n            self.res = self.res + Vcount*\"V\"\\n            return\\n        elif Vcount == 0:\\n            self.res = self.res + Hcount*\"H\"\\n            return \\n        \\n        comboStartWithH = self.countFactorial(Hcount-1+Vcount)/(self.countFactorial(Hcount-1)*self.countFactorial(Vcount))\\n        if comboStartWithH >= k:\\n            self.res += \\'H\\'\\n            self.calculate(Hcount-1, Vcount, k)\\n        else:\\n            self.res += \\'V\\'\\n            self.calculate(Hcount, Vcount-1, k-comboStartWithH)\\n            \\n    \\n    def countFactorial(self, num):\\n        res = 1\\n        for i in range(1, num + 1):\\n            res = res * i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919305,
                "title": "c-after-thinking-about-the-combinatorics-method-i-finnaly-get-the-idea",
                "content": "```\\nlong long nCr(vector<long long>& factorial, int n, int k) {\\n    if (n <= 20) return factorial[n] / (factorial[k] * factorial[n - k]);\\n    else {\\n        long long numerator = 1;\\n        for (int i = max(k, n - k) + 1; i <= n ; i++) numerator *= i;\\n        return numerator / factorial[min(k, n - k)];\\n    }\\n}\\nstring kthSmallestPath(vector<int>& destination, int k) {\\n    int v = destination[0], h = destination[1], cur = k;\\n    vector<long long> factorial(min(20, h + v + 1) + 1, 1);  // factorial[n] = n!\\n    string res = \"\";\\n    for (int i = 1; i <= min(20, h + v + 1); i++) factorial[i] = i * factorial[i - 1];\\n    while (h > 0 || v > 0) {\\n        if (!v || !h) {\\n            res += string(h, \\'H\\') + string(v, \\'V\\');\\n            break;\\n        }\\n        if (cur > nCr(factorial, h + v - 1, h - 1)) {\\n            cur -= nCr(factorial, h + v - 1, h - 1);\\n            res += \\'V\\';\\n            v--;\\n        }\\n        else {\\n            res += \\'H\\';\\n            h--;\\n        }\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "```\\nlong long nCr(vector<long long>& factorial, int n, int k) {\\n    if (n <= 20) return factorial[n] / (factorial[k] * factorial[n - k]);\\n    else {\\n        long long numerator = 1;\\n        for (int i = max(k, n - k) + 1; i <= n ; i++) numerator *= i;\\n        return numerator / factorial[min(k, n - k)];\\n    }\\n}\\nstring kthSmallestPath(vector<int>& destination, int k) {\\n    int v = destination[0], h = destination[1], cur = k;\\n    vector<long long> factorial(min(20, h + v + 1) + 1, 1);  // factorial[n] = n!\\n    string res = \"\";\\n    for (int i = 1; i <= min(20, h + v + 1); i++) factorial[i] = i * factorial[i - 1];\\n    while (h > 0 || v > 0) {\\n        if (!v || !h) {\\n            res += string(h, \\'H\\') + string(v, \\'V\\');\\n            break;\\n        }\\n        if (cur > nCr(factorial, h + v - 1, h - 1)) {\\n            cur -= nCr(factorial, h + v - 1, h - 1);\\n            res += \\'V\\';\\n            v--;\\n        }\\n        else {\\n            res += \\'H\\';\\n            h--;\\n        }\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 919265,
                "title": "why-is-the-following-simple-code-throwing-me-a-run-time-error",
                "content": "#define ll int\\n#define pb push_back\\nll dx[2]={0, 1};\\nll dy[2]={1, 0};\\nclass Solution {\\npublic:\\n    \\n    void  update(string str, ll sx, ll sy, ll ex, ll ey,vector<string>& arr , vector<vector<bool>> vis)\\n    {\\n        \\n        \\n        if(sx==ex && sy==ey)\\n        {\\n            arr.pb(str);\\n            return ;\\n          \\n        }\\n        vis[sx][sy]=1;\\n        for(ll i=0;i<2;i++)\\n        {\\n            \\n            ll nx=sx+dx[i];\\n            ll ny=sy+dy[i];\\n            \\n            if(nx>ex || ny>ey || vis[nx][ny])\\n                continue;\\n            \\n            if(i==0)\\n            {\\n              update(str+\"H\", nx, ny, ex, ey, arr, vis);  \\n            }\\n            else\\n            {\\n               update(str+\"V\", nx, ny, ex, ey, arr, vis); \\n                \\n            }\\n            \\n            \\n        }\\n        \\n        \\n        \\n        \\n    }\\n    string kthSmallestPath(vector<int>& destination, int k) {\\n        \\n        ll ex=destination[0];\\n        ll ey=destination[1];\\n        \\n        ll sx=0, sy=0;\\n        \\n        vector<string> arr;\\n        \\n        string str=\"\";\\n        \\n        vector<vector<bool>>vis(ex, vector<bool>(ey, 0));\\n        \\n        update(str, sx, sy, ex, ey, arr, vis);\\n        \\n        \\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        return arr[k-1];\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void  update(string str, ll sx, ll sy, ll ex, ll ey,vector<string>& arr , vector<vector<bool>> vis)\\n    {\\n        \\n        \\n        if(sx==ex && sy==ey)\\n        {\\n            arr.pb(str);\\n            return ;\\n          \\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2038121,
                "content": [
                    {
                        "username": "algoacer",
                        "content": "calculating next_permutation one by one for k-1 times gives TLE as it\\'s N*N! (O(N)). Think in terms like how many elements will get generated when we place H at beginning. If noOfTerms > k. Include H at this place, otherwise include V and so on."
                    },
                    {
                        "username": "hydra324",
                        "content": "Think recursive!"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "I get the feeling the row/col max size was deliberately chosen to make it extremely difficult to calculate the nCr of them"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "exactly. you just need to find the kth permutation."
                    }
                ]
            },
            {
                "id": 1949680,
                "content": [
                    {
                        "username": "algoacer",
                        "content": "calculating next_permutation one by one for k-1 times gives TLE as it\\'s N*N! (O(N)). Think in terms like how many elements will get generated when we place H at beginning. If noOfTerms > k. Include H at this place, otherwise include V and so on."
                    },
                    {
                        "username": "hydra324",
                        "content": "Think recursive!"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "I get the feeling the row/col max size was deliberately chosen to make it extremely difficult to calculate the nCr of them"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "exactly. you just need to find the kth permutation."
                    }
                ]
            },
            {
                "id": 1766594,
                "content": [
                    {
                        "username": "algoacer",
                        "content": "calculating next_permutation one by one for k-1 times gives TLE as it\\'s N*N! (O(N)). Think in terms like how many elements will get generated when we place H at beginning. If noOfTerms > k. Include H at this place, otherwise include V and so on."
                    },
                    {
                        "username": "hydra324",
                        "content": "Think recursive!"
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "I get the feeling the row/col max size was deliberately chosen to make it extremely difficult to calculate the nCr of them"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "exactly. you just need to find the kth permutation."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways to Arrive at Destination",
        "question_content": "<p>You are in a city that consists of <code>n</code> intersections numbered from <code>0</code> to <code>n - 1</code> with <strong>bi-directional</strong> roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.</p>\n\n<p>You are given an integer <code>n</code> and a 2D integer array <code>roads</code> where <code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code> means that there is a road between intersections <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> that takes <code>time<sub>i</sub></code> minutes to travel. You want to know in how many ways you can travel from intersection <code>0</code> to intersection <code>n - 1</code> in the <strong>shortest amount of time</strong>.</p>\n\n<p>Return <em>the <strong>number of ways</strong> you can arrive at your destination in the <strong>shortest amount of time</strong></em>. Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/17/graph2.png\" style=\"width: 235px; height: 381px;\" />\n<pre>\n<strong>Input:</strong> n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 ➝ 6\n- 0 ➝ 4 ➝ 6\n- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, roads = [[1,0,10]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>roads[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li>There is at most one road connecting any two intersections.</li>\n\t<li>You can reach any intersection from any other intersection.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1417576,
                "title": "c-python-dijkstra-clean-concise",
                "content": "**Idea**\\n- We use Dijkstra algorithm to find the Shortest Path from `src = 0` to `dst = n - 1`.\\n- While dijkstra, we create additional `ways` array, where `ways[i]` keeps the number of shortest path from `src = 0` to `dst = i`. Then the answer is `ways[n-1]`.\\n\\n<iframe src=\"https://leetcode.com/playground/PhVJCRs6/shared\" frameBorder=\"0\" width=\"100%\" height=\"700\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * logN + N)`, where `M <= N*(N-1)/2` is number of roads, `N <= 200` is number of intersections.\\n- Space: `O(N + M)`\\n\\n**Question & Answer**\\n1. Should I remove this line `if dist[u] < d: continue  # Skip if d is not updated to latest version!`?\\n\\tIf you remove that line, the time complexity becomes `O(V^3 * logV)`, which can run pass all the testcases since `V <= 200`.\\n\\tBut if you keep that line, the time complexity reduces to `O(V^2 * logV)`.\\n\\tExplain: Other neightbors may visit node `u` multiple times (up to `O(V)` times) and push node `u` to the `minHeap`. In the worst case, node `u` will pop and process `O(V)` times, each time it takes `O(V)` to visit neighbors, there is up to `V` nodes like node `u`. So total time complexity is `O(V^3 * logV)`.\\n\\t\\n\\tCan check the following special graph (Not related to this problem)\\n\\t<img src=\"https://assets.leetcode.com/users/images/6e4e608c-950c-4606-ad37-3d38467cf67e_1629566004.4643087.png\" alt=\"TLE Testcase Dijkstra\" width=\"600\"/>\\n\\tAnd this implementation https://ideone.com/lOoDHO will cause TLE.\\n\\t\\n\\t\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**Idea**\\n- We use Dijkstra algorithm to find the Shortest Path from `src = 0` to `dst = n - 1`.\\n- While dijkstra, we create additional `ways` array, where `ways[i]` keeps the number of shortest path from `src = 0` to `dst = i`. Then the answer is `ways[n-1]`.\\n\\n<iframe src=\"https://leetcode.com/playground/PhVJCRs6/shared\" frameBorder=\"0\" width=\"100%\" height=\"700\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * logN + N)`, where `M <= N*(N-1)/2` is number of roads, `N <= 200` is number of intersections.\\n- Space: `O(N + M)`\\n\\n**Question & Answer**\\n1. Should I remove this line `if dist[u] < d: continue  # Skip if d is not updated to latest version!`?\\n\\tIf you remove that line, the time complexity becomes `O(V^3 * logV)`, which can run pass all the testcases since `V <= 200`.\\n\\tBut if you keep that line, the time complexity reduces to `O(V^2 * logV)`.\\n\\tExplain: Other neightbors may visit node `u` multiple times (up to `O(V)` times) and push node `u` to the `minHeap`. In the worst case, node `u` will pop and process `O(V)` times, each time it takes `O(V)` to visit neighbors, there is up to `V` nodes like node `u`. So total time complexity is `O(V^3 * logV)`.\\n\\t\\n\\tCan check the following special graph (Not related to this problem)\\n\\t<img src=\"https://assets.leetcode.com/users/images/6e4e608c-950c-4606-ad37-3d38467cf67e_1629566004.4643087.png\" alt=\"TLE Testcase Dijkstra\" width=\"600\"/>\\n\\tAnd this implementation https://ideone.com/lOoDHO will cause TLE.\\n\\t\\n\\t\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 1417580,
                "title": "dijkstra-dp-c-explanation",
                "content": "* Use **Dijkstra** to find the shortest amount of time.\\n* Use **DP** to keep states of shortest time fo a node.\\n* while finding shortest time\\n\\t* when we find a shorter time we change dp by new value.\\n\\t* when we find equal time we add value to current node\\'s dp.\\n\\nNote: Use long long properly, I got 2 penalties due to that.\\n\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& grid) {\\n        vector <vector <pair <long long, long long>>> graph(n+1);\\n        for(auto x: grid) { //creating adjacency list\\n            graph[x[0]].push_back({x[1], x[2]});\\n            graph[x[1]].push_back({x[0], x[2]});\\n        }\\n        long long INF = 1e15;\\n        long long MOD = 1e9 + 7;\\n        vector <long long> dp(n+1, 0);\\n        vector <long long> dist(n+1, INF);\\n        priority_queue <pair <long long, long long>> q; // maxHeap in c++\\n\\t\\t// although we can use use minHeap in c++ by adding parameter to the maxHeap template\\n\\t\\t// but I have inserted -1*val into the maxHeap so it worked fine as minHeap\\n\\t\\t\\n        dist[0] = 0;\\n        dp[0] = 1; // initilize it to 1 since to reach 0 we have 1 way\\n        q.push({0, 0});\\n\\t\\t\\n        while(q.size()) {\\n            long long node = q.top().second;\\n            long long nodeWt = -q.top().first;\\n            q.pop();\\n\\n\\t\\t\\t/*\\n\\t\\t\\twhat if we inserted min weight after some greater weight and we always pop min weight so it can be\\n\\t\\t\\tpossible that some nodeWt (> dist[node]) is there in the queue that we haven\\'t popped yet...\\n\\t\\t\\thence we are continuing so that we don\\'t traverse adjacency list of node again\\n\\t\\t\\t\\n\\t\\t\\tI have taken a graph as an example below the code.\\n\\t\\t\\t*/\\n            if(dist[node] < nodeWt) continue; // explained above\\n            for(auto key: graph[node]) {\\n                long long child = key.first;\\n                long long childWt = key.second;\\n                if(nodeWt + childWt == dist[child]) {\\n\\t\\t\\t\\t\\t// we are adding parent\\'s dp value to child\\'s dp \\n                    dp[child] = (dp[child] + dp[node])%MOD;\\n                }\\n                if(nodeWt + childWt < dist[child]) {\\n                    dp[child] = dp[node]%MOD; // we are getting value of parent\\'s dp\\n                    dist[child] = nodeWt + childWt;\\n                    q.push({-dist[child], child});\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**Explanation to \"if(dist[node] < nodeWt) continue;\"**\\n![image](https://assets.leetcode.com/users/images/69513f95-fda9-437c-93d0-01eb7531c323_1629644944.4037337.png)\\n-> {x, y}- {total weight, node} \\n-> Insert {0, 0}\\n-> queue before iteration: [{0, 0}]\\n-> Pop Min: {0, 0}\\n-> traverse list of 0:\\n-> Insert {100, 1}\\n-> Insert {1, 2}\\n-> queue afer 1st iteration: [{1, 2}, {100, 1}]\\n-> Pop Min: {1, 2}\\n-> traverse list of 2:\\n-> Insert {2, 3}\\n-> queue afer 2nd iteration: [{2, 3}, {100, 1}]\\n-> Pop Min: {2, 3}\\n-> traverse list of 3:\\n-> Insert {3, 1}\\n-> queue afer 3rd iteration: [{3, 1}, {100, 1}]\\n-> Pop Min: {3, 1}\\n-> traverse list of 1:\\n-> Insert {4, 4}\\n-> queue after 4th iteration: [{4, 4}, {100, 1}]\\n-> Pop Min: {4, 4}\\n-> traverse list of 4:\\n-> there is no child node to insert\\n-> queue after 5th iteration: [{100, 1}]\\n-> Pop Min: {100, 1}\\n-> traverse list of 1: **but why ???**\\nThere can be more node like this.\\nwhy again traverse list of node whose already calculated weight if smaller than current popped weight.\\n\\n**Learn More**: [cp-algorithm](https://cp-algorithms.com/graph/dijkstra_sparse.html)\\n\\n**TC**: O(n + Elog(n)) where E is number of edges\\n**SC**: O(E+n)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& grid) {\\n        vector <vector <pair <long long, long long>>> graph(n+1);\\n        for(auto x: grid) { //creating adjacency list\\n            graph[x[0]].push_back({x[1], x[2]});\\n            graph[x[1]].push_back({x[0], x[2]});\\n        }\\n        long long INF = 1e15;\\n        long long MOD = 1e9 + 7;\\n        vector <long long> dp(n+1, 0);\\n        vector <long long> dist(n+1, INF);\\n        priority_queue <pair <long long, long long>> q; // maxHeap in c++\\n\\t\\t// although we can use use minHeap in c++ by adding parameter to the maxHeap template\\n\\t\\t// but I have inserted -1*val into the maxHeap so it worked fine as minHeap\\n\\t\\t\\n        dist[0] = 0;\\n        dp[0] = 1; // initilize it to 1 since to reach 0 we have 1 way\\n        q.push({0, 0});\\n\\t\\t\\n        while(q.size()) {\\n            long long node = q.top().second;\\n            long long nodeWt = -q.top().first;\\n            q.pop();\\n\\n\\t\\t\\t/*\\n\\t\\t\\twhat if we inserted min weight after some greater weight and we always pop min weight so it can be\\n\\t\\t\\tpossible that some nodeWt (> dist[node]) is there in the queue that we haven\\'t popped yet...\\n\\t\\t\\thence we are continuing so that we don\\'t traverse adjacency list of node again\\n\\t\\t\\t\\n\\t\\t\\tI have taken a graph as an example below the code.\\n\\t\\t\\t*/\\n            if(dist[node] < nodeWt) continue; // explained above\\n            for(auto key: graph[node]) {\\n                long long child = key.first;\\n                long long childWt = key.second;\\n                if(nodeWt + childWt == dist[child]) {\\n\\t\\t\\t\\t\\t// we are adding parent\\'s dp value to child\\'s dp \\n                    dp[child] = (dp[child] + dp[node])%MOD;\\n                }\\n                if(nodeWt + childWt < dist[child]) {\\n                    dp[child] = dp[node]%MOD; // we are getting value of parent\\'s dp\\n                    dist[child] = nodeWt + childWt;\\n                    q.push({-dist[child], child});\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417573,
                "title": "python-almost-dijktra-explained",
                "content": "The idea of this problem is to use Dijkstra algorithm, but also we need to keep not only distances to nodes, but counts as well.\\n\\n1. If we meet `candidate == dist[neib]`, it means we found one more way to reach node with minimal cost.\\n2. If `candidate < dist[neib]`, it means that we found better candidate, so we update distance and put `cnt[neib] = cnt[idx]`.\\n\\n#### Complexity\\nIt is `O((E+V) log V)` for time as classical Dijkstra and `O(E+V)` for space\\n\\n```python\\nclass Solution:\\n    def countPaths(self, n, roads):\\n        G = defaultdict(list)\\n        for x, y, w in roads:\\n            G[x].append((y, w))\\n            G[y].append((x, w))\\n\\n        dist = [float(\\'inf\\')] * n\\n        dist[0] = 0\\n        cnt = [0]*n\\n        cnt[0] = 1\\n        heap = [(0, 0)]\\n\\n        while heap:\\n            (min_dist, idx) = heappop(heap)\\n            if idx == n-1: return cnt[idx] % (10**9 + 7)\\n            for neib, weight in G[idx]:\\n                candidate = min_dist + weight\\n                if candidate == dist[neib]:\\n                    cnt[neib] += cnt[idx]\\n\\n                elif candidate < dist[neib]:\\n                    dist[neib] = candidate\\n                    heappush(heap, (weight + min_dist, neib))\\n                    cnt[neib] = cnt[idx]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countPaths(self, n, roads):\\n        G = defaultdict(list)\\n        for x, y, w in roads:\\n            G[x].append((y, w))\\n            G[y].append((x, w))\\n\\n        dist = [float(\\'inf\\')] * n\\n        dist[0] = 0\\n        cnt = [0]*n\\n        cnt[0] = 1\\n        heap = [(0, 0)]\\n\\n        while heap:\\n            (min_dist, idx) = heappop(heap)\\n            if idx == n-1: return cnt[idx] % (10**9 + 7)\\n            for neib, weight in G[idx]:\\n                candidate = min_dist + weight\\n                if candidate == dist[neib]:\\n                    cnt[neib] += cnt[idx]\\n\\n                elif candidate < dist[neib]:\\n                    dist[neib] = candidate\\n                    heappush(heap, (weight + min_dist, neib))\\n                    cnt[neib] = cnt[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417799,
                "title": "c-dijkstra-clean-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int mod = 1e9+7;\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto &road: roads) {\\n            graph[road[0]].push_back({road[1], road[2]});\\n            graph[road[1]].push_back({road[0], road[2]});\\n        }\\n        \\n        vector<long long> distance(n, LONG_MAX);\\n        vector<int> path(n, 0);\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        distance[0] = 0;\\n        path[0] = 1;\\n        \\n        while(!pq.empty()) {\\n            pair<long long, int> t = pq.top();\\n            pq.pop();\\n            \\n            for(auto &nbr: graph[t.second]) {\\n                long long vert = nbr.first;\\n                long long edge = nbr.second;\\n                \\n                if(distance[vert] > distance[t.second] + edge) {\\n                    distance[vert] = distance[t.second] + edge;\\n                    pq.push({distance[vert], vert});\\n                    path[vert] = path[t.second] %mod;\\n                }\\n                else if(distance[vert] == t.first + edge) {\\n                    path[vert] += path[t.second];\\n                    path[vert] %= mod;\\n                }\\n            }\\n        }\\n        \\n        return path[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int mod = 1e9+7;\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto &road: roads) {\\n            graph[road[0]].push_back({road[1], road[2]});\\n            graph[road[1]].push_back({road[0], road[2]});\\n        }\\n        \\n        vector<long long> distance(n, LONG_MAX);\\n        vector<int> path(n, 0);\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        distance[0] = 0;\\n        path[0] = 1;\\n        \\n        while(!pq.empty()) {\\n            pair<long long, int> t = pq.top();\\n            pq.pop();\\n            \\n            for(auto &nbr: graph[t.second]) {\\n                long long vert = nbr.first;\\n                long long edge = nbr.second;\\n                \\n                if(distance[vert] > distance[t.second] + edge) {\\n                    distance[vert] = distance[t.second] + edge;\\n                    pq.push({distance[vert], vert});\\n                    path[vert] = path[t.second] %mod;\\n                }\\n                else if(distance[vert] == t.first + edge) {\\n                    path[vert] += path[t.second];\\n                    path[vert] %= mod;\\n                }\\n            }\\n        }\\n        \\n        return path[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417738,
                "title": "simple-java-solution",
                "content": "1. From the problem statement it was clear we need to apply dijkistra to find shortest path between source and dest.\\n2. Well, dijkistra to rescue. Using dijkistra we can keep shortest path by keep relaxing the edges. (Cormen lingo).\\n3. Catch is, whenver you find a better way to reach a particular vertex update the number of ways we can reach this vertex same as number of ways we can reach parent vertex.\\n4. If we arrive at a vetrex, with same time from parent, we will add the parent\\'s number of ways to the current vertex\\'s number of ways i.e line  dp[v[0]]+=dp[u] in the code\\n5. In the End the last veretx will have total number of ways from origin i.e 0\\n6. In my solution array named \"dp\" stores the number of ways from i-th vertex to 0th vertex.\\n \\n**Similar Problem**: https://leetcode.com/problems/minimum-cost-to-reach-city-with-discounts/\\n\\nclass Solution {\\n    int[] dist;\\n    long[] dp;\\n\\n    public void findDis(Map<Integer, List<int[]>> graph){\\n        \\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a, b) -> (a[1]- b[1]));\\n        pq.add(new int[]{0, 0});\\n        dist[0]=0;\\n        dp[0]=1;\\n        while(!pq.isEmpty()){\\n            int[] top=pq.poll();\\n            int u=top[0], d=top[1];\\n\\t\\t\\tif(dist[u]< d) // new edit\\n\\t\\t\\t\\tcontinue;\\n            for(int[] v: graph.get(u)){\\n                if(dist[v[0]] > d + v[1]){\\n                    dist[v[0]] = d+v[1];\\n                    dp[v[0]]=dp[u];\\n                    pq.offer(new int[]{v[0], dist[v[0]]});\\n                }else{\\n                    if(dist[v[0]] == d+v[1]){\\n                        dp[v[0]]+=dp[u];\\n                        dp[v[0]]%= 1_000_000_007;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int countPaths(int n, int[][] roads) {\\n        dist=new int[n];\\n        dp=new long[n];\\n        Map<Integer, List<int[]>> graph=new HashMap();\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        for(int i=0;i<n;i++){\\n            graph.put(i, new ArrayList());\\n            \\n        }\\n        for(int[] e: roads){\\n            graph.get(e[0]).add(new int[]{e[1], e[2]});\\n            graph.get(e[1]).add(new int[]{e[0], e[2]});\\n        }\\n        findDis(graph);\\n        \\n        return (int)dp[n-1]%1_000_000_007;\\n        \\n    }  \\n}\\n**Explanation for point 4 above:** \\nlets say we  had arrived at a vertex v previously and recorded its distance from 0 in dist array as dist[v]=40, which means its takes us time=40 from 0 to reach v. lets say the path it followed was 0 -> u1 -> u2 -> v . Here parent vertex of v was u2.\\nNow when we arrive at v again but via a different parent, lets call this parent u3 via path 0 -> u1 -> u3 -> v, and the dist[u3]+ Time[u3, v] = 40, which mean this is a whole new way/path of arriving at v from 0 with same time (40), hence we will add the number ways of u3 to number of ways of v i.e dp[v] = dp[v] +dp[u3].\\nHope this explanations helped.\\nCheers!",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] dist;\\n    long[] dp;\\n\\n    public void findDis(Map<Integer, List<int[]>> graph){\\n        \\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a, b) -> (a[1]- b[1]));\\n        pq.add(new int[]{0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1420249,
                "title": "min-heap",
                "content": "This is just Vanila Dijkstra. I would only note that the min heap is required here not only for the performance, but also for the accuracy.\\n\\nWe process nodes in the queue from smallest to largest distance, so that we \"wait\" for all paths with the same distance to reach the node, accumulating the number of ways to reach that node (`cnt`), before moving further from that node.\\n\\n**C++**\\n```cpp\\nint countPaths(int n, vector<vector<int>>& roads) {\\n    vector<vector<pair<int, int>>> al(n);\\n    vector<long> time(n, 0), cnt(n, 1);\\n    for (auto &r : roads) {\\n        al[r[0]].push_back({r[1], r[2]});\\n        al[r[1]].push_back({r[0], r[2]});\\n    }\\n    priority_queue<pair<long, int>, vector<pair<long, int>>, greater<>> pq;\\n    pq.push({0, 0});\\n    while (!pq.empty()) {\\n        auto[dist, i] = pq.top(); pq.pop();\\n            for (auto [j, t] : al[i]) {\\n                if (time[j] == 0 || time[j] >= dist + t) {\\n                    if (time[j] == dist + t)\\n                        cnt[j] = (cnt[j] + cnt[i]) % 1000000007;\\n                    else {\\n                        time[j] = dist + t;\\n                        cnt[j] = cnt[i];\\n                        pq.push({time[j], j});\\n                    }\\n                }\\n            }\\n    }\\n    return cnt[n - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint countPaths(int n, vector<vector<int>>& roads) {\\n    vector<vector<pair<int, int>>> al(n);\\n    vector<long> time(n, 0), cnt(n, 1);\\n    for (auto &r : roads) {\\n        al[r[0]].push_back({r[1], r[2]});\\n        al[r[1]].push_back({r[0], r[2]});\\n    }\\n    priority_queue<pair<long, int>, vector<pair<long, int>>, greater<>> pq;\\n    pq.push({0, 0});\\n    while (!pq.empty()) {\\n        auto[dist, i] = pq.top(); pq.pop();\\n            for (auto [j, t] : al[i]) {\\n                if (time[j] == 0 || time[j] >= dist + t) {\\n                    if (time[j] == dist + t)\\n                        cnt[j] = (cnt[j] + cnt[i]) % 1000000007;\\n                    else {\\n                        time[j] = dist + t;\\n                        cnt[j] = cnt[i];\\n                        pq.push({time[j], j});\\n                    }\\n                }\\n            }\\n    }\\n    return cnt[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1417814,
                "title": "c-dijkstra-algorithm-dp-explained",
                "content": "**Idea:-**\\nDijkstra algorithm is being used to know the most optimal way to reach the target. \\nWe are using an array to store the number of optimal ways to reach a node.  Let us call this\\n*paths[]*\\n\\nLet us consider an example only for DP logic:-\\n\\n![image](https://assets.leetcode.com/users/images/8dad9f2b-93ec-4745-81a6-5b9a202bf84e_1629564300.8240583.png)\\npaths[S] = 1 As there it is the starting node so there is only 1 way to reach it\\npaths[A] = 1, paths[B] = 1, paths[C] = 1\\n\\nSo for the above example, there are 3 ways to reach D:-\\nS->A->D (cost 3)\\nS->B->D (cost 2)\\nS->C->D (cost 2)\\nNow there are two optimal ways which have cost of 2.\\nThis can be calculated by knowing two things:-\\n1) The least time taken to reach D that is 2 minutes \\n2) How many ways were there to reach the predecessors through which we got the least time taken that is B and C\\n\\nNow as there are 2 optimal ways to reach D we can move forward to nodes E and F \\nwhich follows the same principle and gives us \\npaths[E] = paths[F] = 2 (Naturally because they have only one predecessor)\\n\\nFinally node G can be reached in two ways and both ways are optimal. \\nTherefore again paths[G] = paths[E] + paths[F] = 4\\nand this is how we get our answer. \\n\\nHere\\'s the code:-\\n\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       \\n        /*This is the preparation part of this problem, here we are simply \\n\\t\\tconverting given data in the form of adjacency list which is required to\\n\\t\\trun Dijkstra\\'s algorithm */\\n        vector<pair<long long int, long long int>> adj[201];\\n        for(int i = 0; i < roads.size(); i++)\\n        {\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            \\n            adj[u].push_back({v, w});\\n            adj[v].push_back({u, w});\\n        }\\n\\t\\t\\n        priority_queue<pair<long long, long long>> pq;\\n        pq.push({0, 0});\\n        vector<long long> distance(201, LLONG_MAX);\\n\\t\\t// Following is the dp array which stores the number of ways to reach a node\\n        vector<long long> paths(201, 0); \\n        vector<long long> visited(201, 0);\\n      \\n        distance[0] = 0; //because we are starting from 0\\n        paths[0] = 1;\\n        \\n        while(!pq.empty())\\n        {\\n            pair<long long, long long> p = pq.top(); pq.pop();\\n            long long dist = -p.first;\\n            int u = p.second;\\n            if(visited[u]) continue;\\n            visited[u] = 1;\\n          \\n            for(int i = 0; i < adj[u].size(); i++)\\n            {\\n                int v = adj[u][i].first;\\n                long long w = adj[u][i].second;\\n                \\n\\t\\t\\t\\t/*this means that we\\'ve found a better(less time consuming) \\n\\t\\t\\t\\tway to reach v, now this better way will prevail and \\n\\t\\t\\t\\twe now don\\'t care about past ways therefore total number \\n\\t\\t\\t\\tof ways to reach v is simply equal to the total number of ways \\n\\t\\t\\t\\tto reach its parent which is u */\\n                if(dist + w < distance[v]) \\n                {\\n                    distance[v] = dist + w;\\n                    pq.push({-(dist+w), v});\\n                    paths[v] = paths[u];\\n                }\\n\\t\\t\\t\\t/*here we have a way to reach v which is taking same amount \\n\\t\\t\\t\\tof time\\tas the optimal path but this time parent of v \\n\\t\\t\\t\\tis different therefore we ways to reach u to current ways \\n\\t\\t\\t\\tof reaching v*/\\n                else if(dist+w == distance[v])\\n                {\\n                    paths[v] = (paths[v] + paths[u])%1000000007;\\n                    pq.push({-(dist+w), v});\\n                }\\n            }\\n        }\\n       \\n        return (int) paths[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       \\n        /*This is the preparation part of this problem, here we are simply \\n\\t\\tconverting given data in the form of adjacency list which is required to\\n\\t\\trun Dijkstra\\'s algorithm */\\n        vector<pair<long long int, long long int>> adj[201];\\n        for(int i = 0; i < roads.size(); i++)\\n        {\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            \\n            adj[u].push_back({v, w});\\n            adj[v].push_back({u, w});\\n        }\\n\\t\\t\\n        priority_queue<pair<long long, long long>> pq;\\n        pq.push({0, 0});\\n        vector<long long> distance(201, LLONG_MAX);\\n\\t\\t// Following is the dp array which stores the number of ways to reach a node\\n        vector<long long> paths(201, 0); \\n        vector<long long> visited(201, 0);\\n      \\n        distance[0] = 0; //because we are starting from 0\\n        paths[0] = 1;\\n        \\n        while(!pq.empty())\\n        {\\n            pair<long long, long long> p = pq.top(); pq.pop();\\n            long long dist = -p.first;\\n            int u = p.second;\\n            if(visited[u]) continue;\\n            visited[u] = 1;\\n          \\n            for(int i = 0; i < adj[u].size(); i++)\\n            {\\n                int v = adj[u][i].first;\\n                long long w = adj[u][i].second;\\n                \\n\\t\\t\\t\\t/*this means that we\\'ve found a better(less time consuming) \\n\\t\\t\\t\\tway to reach v, now this better way will prevail and \\n\\t\\t\\t\\twe now don\\'t care about past ways therefore total number \\n\\t\\t\\t\\tof ways to reach v is simply equal to the total number of ways \\n\\t\\t\\t\\tto reach its parent which is u */\\n                if(dist + w < distance[v]) \\n                {\\n                    distance[v] = dist + w;\\n                    pq.push({-(dist+w), v});\\n                    paths[v] = paths[u];\\n                }\\n\\t\\t\\t\\t/*here we have a way to reach v which is taking same amount \\n\\t\\t\\t\\tof time\\tas the optimal path but this time parent of v \\n\\t\\t\\t\\tis different therefore we ways to reach u to current ways \\n\\t\\t\\t\\tof reaching v*/\\n                else if(dist+w == distance[v])\\n                {\\n                    paths[v] = (paths[v] + paths[u])%1000000007;\\n                    pq.push({-(dist+w), v});\\n                }\\n            }\\n        }\\n       \\n        return (int) paths[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417752,
                "title": "c-solution-o-n-3-floyd-warshall-dp",
                "content": "```\\n#define ll long long int\\nconst ll mod= 1e9+7;\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        ll dp[n][n][2]; \\n        // dp[i][j][0] stores minimum distance and dp[i][j][1] stores number of ways to reach     with the minimum distance dp[i][j][0]\\n        for(ll i=0; i<n; i++){\\n            for(ll j=0; j<n; j++){\\n                if(i!=j){\\n                    dp[i][j][0] = 1e13;\\n                    dp[i][j][1]=0;\\n                }\\n                else\\n                {\\n                    dp[i][j][0]=0;\\n                    dp[i][j][1]=1;\\n                }\\n            }\\n        }\\n        for(ll i=0; i<roads.size(); i++){\\n            dp[roads[i][0]][roads[i][1]][0]=roads[i][2];\\n            \\n            dp[roads[i][1]][roads[i][0]][0]=roads[i][2];\\n            dp[roads[i][0]][roads[i][1]][1]=1;\\n            \\n            dp[roads[i][1]][roads[i][0]][1]=1;\\n        }\\n        for(ll mid=0; mid<n; mid++){\\n            for(ll i=0; i<n; i++){\\n                for(ll j=0; j<n; j++){\\n                    if(i!=mid && j!=mid){\\n                        if(dp[i][mid][0]+dp[mid][j][0]<dp[i][j][0]){\\n                            dp[i][j][0]=dp[i][mid][0]+dp[mid][j][0];\\n                            dp[i][j][1] = (dp[i][mid][1]*dp[mid][j][1])%mod;\\n                        }\\n                        else if(dp[i][j][0]==dp[i][mid][0]+dp[mid][j][0]){\\n                            dp[i][j][1] = (dp[i][j][1]+dp[i][mid][1]*dp[mid][j][1])%mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][0][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nconst ll mod= 1e9+7;\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        ll dp[n][n][2]; \\n        // dp[i][j][0] stores minimum distance and dp[i][j][1] stores number of ways to reach     with the minimum distance dp[i][j][0]\\n        for(ll i=0; i<n; i++){\\n            for(ll j=0; j<n; j++){\\n                if(i!=j){\\n                    dp[i][j][0] = 1e13;\\n                    dp[i][j][1]=0;\\n                }\\n                else\\n                {\\n                    dp[i][j][0]=0;\\n                    dp[i][j][1]=1;\\n                }\\n            }\\n        }\\n        for(ll i=0; i<roads.size(); i++){\\n            dp[roads[i][0]][roads[i][1]][0]=roads[i][2];\\n            \\n            dp[roads[i][1]][roads[i][0]][0]=roads[i][2];\\n            dp[roads[i][0]][roads[i][1]][1]=1;\\n            \\n            dp[roads[i][1]][roads[i][0]][1]=1;\\n        }\\n        for(ll mid=0; mid<n; mid++){\\n            for(ll i=0; i<n; i++){\\n                for(ll j=0; j<n; j++){\\n                    if(i!=mid && j!=mid){\\n                        if(dp[i][mid][0]+dp[mid][j][0]<dp[i][j][0]){\\n                            dp[i][j][0]=dp[i][mid][0]+dp[mid][j][0];\\n                            dp[i][j][1] = (dp[i][mid][1]*dp[mid][j][1])%mod;\\n                        }\\n                        else if(dp[i][j][0]==dp[i][mid][0]+dp[mid][j][0]){\\n                            dp[i][j][1] = (dp[i][j][1]+dp[i][mid][1]*dp[mid][j][1])%mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102405,
                "title": "python-dijkstra-dp-solution-60-70-faster",
                "content": "## Logic\\n- Dijkstra algorithm can only get the shortest time from src to dst.\\n- What we want to get is **the number of ways with minimum time from src to dst.**\\n- We need\\n\\t1) **times** array : to check the minimum time to take from src to times[i].\\n\\t2) **ways** array : to check the total ways from src to ways[i] within minimum time.\\n\\n- if find same time path... update **ways** only \\n ... because we don\\'t need to update time \\n ... and we don\\'t need to go to that node(already in our heap)\\n\\n\\n## EX1\\n**times**    [INF, INF, INF, INF, INF, INF] => [0, 2, 5, 5, 6, 7]\\n**ways**      [0, 0, 0, 0, 0, 0] => [1, 1, 1, 1, 1, 2, 4]\\n\\n\\n## Reference\\nIdea and code from ... #happycoding\\nhttps://www.youtube.com/watch?v=1JCXqupyLoQ&t=465s\\n\\n\\n\\n```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n\\n        #1. graph\\n        graph = collections.defaultdict(list)\\n        for u, v, t in roads:\\n            graph[u].append((v, t))\\n            graph[v].append((u, t))\\n            \\n        #2. times, ways array initializer\\n        times = [float(\\'inf\\')] * n\\n        ways = [0] * n\\n        \\n        times[0] = 0\\n        ways[0] = 1\\n        \\n        #3. dijkstra\\n        pq = [(0, 0)] # time, node\\n        \\n        while pq:\\n            old_t, u = heapq.heappop(pq) # current time, current node\\n            \\n            for v, t in graph[u]:\\n                new_t = old_t + t\\n                \\n                # casual logic: update shorter path\\n                if new_t < times[v]:\\n                    times[v] = new_t\\n                    ways[v] = ways[u]\\n                    heapq.heappush(pq, (new_t, v))\\n                \\n                # if find same time path... update ways only\\n                elif new_t == times[v]:\\n                    ways[v] += ways[u]\\n                \\n        modulo = 10 ** 9 + 7\\n        \\n        return ways[n-1] % modulo\\n```\\n\\n**Please upvote if it helped! :)**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n\\n        #1. graph\\n        graph = collections.defaultdict(list)\\n        for u, v, t in roads:\\n            graph[u].append((v, t))\\n            graph[v].append((u, t))\\n            \\n        #2. times, ways array initializer\\n        times = [float(\\'inf\\')] * n\\n        ways = [0] * n\\n        \\n        times[0] = 0\\n        ways[0] = 1\\n        \\n        #3. dijkstra\\n        pq = [(0, 0)] # time, node\\n        \\n        while pq:\\n            old_t, u = heapq.heappop(pq) # current time, current node\\n            \\n            for v, t in graph[u]:\\n                new_t = old_t + t\\n                \\n                # casual logic: update shorter path\\n                if new_t < times[v]:\\n                    times[v] = new_t\\n                    ways[v] = ways[u]\\n                    heapq.heappush(pq, (new_t, v))\\n                \\n                # if find same time path... update ways only\\n                elif new_t == times[v]:\\n                    ways[v] += ways[u]\\n                \\n        modulo = 10 ** 9 + 7\\n        \\n        return ways[n-1] % modulo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452839,
                "title": "dijkstra-s-algorithm",
                "content": "```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int countPaths(int n, int[][] roads) {\\n        List<int[]>[] graph = new ArrayList[n];\\n        \\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<int[]>();\\n        \\n        for(int[] edge: roads)\\n        {\\n            int src = edge[0], dest = edge[1], time = edge[2];\\n            \\n            graph[src].add(new int[]{dest, time});\\n            graph[dest].add(new int[]{src, time});\\n        }\\n        \\n        return shortestPath(graph, 0, n);\\n    }\\n    \\n    private int shortestPath(List<int[]>[] graph, int src, int target)\\n    {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);\\n        \\n        int[] minCost = new int[target];\\n        Arrays.fill(minCost, Integer.MAX_VALUE);\\n        \\n        long[] ways = new long[target];\\n        ways[0] = 1;\\n        minCost[0] = 0;\\n        \\n        pq.offer(new int[]{0, 0});\\n        \\n        while(!pq.isEmpty())\\n        {\\n            int[] current = pq.poll();\\n            int city = current[0];\\n            int curCost = current[1];\\n            \\n            if(curCost > minCost[city]) \\n                continue;\\n            \\n            for(int[] neighbourData: graph[city])\\n            {\\n                int neighbour = neighbourData[0], time = neighbourData[1];\\n                \\n                if(curCost + time < minCost[neighbour])\\n                {\\n                    minCost[neighbour] = curCost + time;\\n                    pq.offer(new int[]{neighbour, minCost[neighbour]});\\n                    ways[neighbour] = ways[city];\\n                }\\n                else if(curCost + time == minCost[neighbour])\\n                    ways[neighbour] = (ways[neighbour] + ways[city]) % mod;\\n            }\\n        }\\n        return (int)ways[target - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int countPaths(int n, int[][] roads) {\\n        List<int[]>[] graph = new ArrayList[n];\\n        \\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<int[]>();\\n        \\n        for(int[] edge: roads)\\n        {\\n            int src = edge[0], dest = edge[1], time = edge[2];\\n            \\n            graph[src].add(new int[]{dest, time});\\n            graph[dest].add(new int[]{src, time});\\n        }\\n        \\n        return shortestPath(graph, 0, n);\\n    }\\n    \\n    private int shortestPath(List<int[]>[] graph, int src, int target)\\n    {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);\\n        \\n        int[] minCost = new int[target];\\n        Arrays.fill(minCost, Integer.MAX_VALUE);\\n        \\n        long[] ways = new long[target];\\n        ways[0] = 1;\\n        minCost[0] = 0;\\n        \\n        pq.offer(new int[]{0, 0});\\n        \\n        while(!pq.isEmpty())\\n        {\\n            int[] current = pq.poll();\\n            int city = current[0];\\n            int curCost = current[1];\\n            \\n            if(curCost > minCost[city]) \\n                continue;\\n            \\n            for(int[] neighbourData: graph[city])\\n            {\\n                int neighbour = neighbourData[0], time = neighbourData[1];\\n                \\n                if(curCost + time < minCost[neighbour])\\n                {\\n                    minCost[neighbour] = curCost + time;\\n                    pq.offer(new int[]{neighbour, minCost[neighbour]});\\n                    ways[neighbour] = ways[city];\\n                }\\n                else if(curCost + time == minCost[neighbour])\\n                    ways[neighbour] = (ways[neighbour] + ways[city]) % mod;\\n            }\\n        }\\n        return (int)ways[target - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567343,
                "title": "dijkstra-keeping-count-of-the-number-of-ways",
                "content": "```\\ntypedef long long ll;\\n    typedef pair<long long, long long> ppl;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int mod = (1e9+7);\\n        vector<ll> dist(n,LLONG_MAX);\\n        vector<int> ways(n,0);\\n        priority_queue<ppl, vector<ppl>, greater<ppl>> pq;\\n        \\n        dist[0] = 0; ways[0]=1; pq.push({0,0});\\n        \\n        vector<ppl> adj[n];\\n        \\n        //making adjacency list\\n        for(auto x : roads){\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        while(!pq.empty()){\\n            ll distance = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n            for(auto x : adj[node]){\\n                ll adjNode = x.first;\\n                ll nextDist = x.second;\\n                \\n                if(distance+nextDist < dist[adjNode]){\\n                    dist[adjNode] = distance+nextDist;\\n                    ways[adjNode] = ways[node];\\n                    pq.push({dist[adjNode],adjNode});\\n                } else if(distance+nextDist == dist[adjNode]){\\n                    ways[adjNode] = (ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        \\n        return ways[n-1];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\n    typedef pair<long long, long long> ppl;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int mod = (1e9+7);\\n        vector<ll> dist(n,LLONG_MAX);\\n        vector<int> ways(n,0);\\n        priority_queue<ppl, vector<ppl>, greater<ppl>> pq;\\n        \\n        dist[0] = 0; ways[0]=1; pq.push({0,0});\\n        \\n        vector<ppl> adj[n];\\n        \\n        //making adjacency list\\n        for(auto x : roads){\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        while(!pq.empty()){\\n            ll distance = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n            for(auto x : adj[node]){\\n                ll adjNode = x.first;\\n                ll nextDist = x.second;\\n                \\n                if(distance+nextDist < dist[adjNode]){\\n                    dist[adjNode] = distance+nextDist;\\n                    ways[adjNode] = ways[node];\\n                    pq.push({dist[adjNode],adjNode});\\n                } else if(distance+nextDist == dist[adjNode]){\\n                    ways[adjNode] = (ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        \\n        return ways[n-1];\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1425560,
                "title": "c-dijkstra-solution-o-v-2-logv",
                "content": "Runtime: 96 ms, faster than 46.70% of C++ online submissions for Number of Ways to Arrive at Destination.\\nMemory Usage: 40.5 MB, less than 7.91% of C++ online submissions for Number of Ways to Arrive at Destination.\\n\\nNote: Solution taken from other post.\\n\\n```\\nWe can find the shortest distance from any vertex to another using Dijkstra Algo in a weighted graph. \\nHere we have to find the number of ways we can go from source to destination and so we keep an array\\nto store the ways count for all nodes as we progress in Dijkstra Algo and use it for the neighbor nodes\\nwhich is actually a DP approach. \\n\\nNow, each time we relax the cost of neighbor node we find a better distance for neighbor node and so \\nthe number of way to go to neighbor node = number way to come to the current node and so we update \\nthe ways[neighbor] = ways[node]. Also when we see that neighbor node cost and current node \\ncost + edge cost is same then this is another way to go to the neighbor node with min cost and so we \\nupdate neighbor node ways count as ways[neighbor] += ways[node]. Also when pop a node with cost \\ngreater than the current cost of the node then we will ignore the furthur operations cause the cost \\nis higher and we need to find min cost paths.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n        \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        // Adjacency list of the undirected graph\\n        vector<vector<vector<int>>>adjL(n);\\n        \\n        // distance vector of nodes\\n        vector<long>dist(n,LONG_MAX);\\n        \\n        // populate Adjacency List {node, cost} pair\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adjL[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adjL[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        \\n        int MOD = 1000000007;\\n        \\n        // track the number of ways to reach node with min cost\\n        vector<long>ways(n,0);\\n        \\n        // source node has way 1 \\n        ways[0] = 1;\\n        \\n        // push source node with distance 0, PQ stores {cost, node} pair\\n        priority_queue<pair<long,int>,vector<pair<long,int>>,greater<>>pQ;\\n        pQ.push({0,0});\\n        dist[0] = 0;\\n        \\n        long cost;\\n        int node;        \\n        while(!pQ.empty())\\n        {\\n            cost = pQ.top().first;\\n            node = pQ.top().second;\\n            pQ.pop();\\n            \\n            // if cost is higher than current node distance then we ignroe furthur operations\\n            if(dist[node]<cost)continue;\\n            \\n            // loop through neighbors and relax the neighbor nodes\\n            for(auto &adj: adjL[node])\\n            {                \\n                // relax neighbor nodes and push in to PQ\\n                // neighbor node ways will be updated with current node ways as\\n                // we find a better cost for neighbor node\\n                if(dist[node]+adj[1] < dist[adj[0]])\\n                {\\n                    dist[adj[0]] = dist[node]+adj[1];\\n                    ways[adj[0]] = ways[node];\\n                    pQ.push({dist[adj[0]],adj[0]});\\n                }\\n                \\n                // if current node distance + edge cost = neighbor node cost then\\n                // this is another way to reach the neighbor node with min cost\\n                // so we update neighbor node ways as ways[neighbor] += ways[node]\\n                else if(dist[node]+adj[1] == dist[adj[0]])\\n                {\\n                    ways[adj[0]] = (ways[adj[0]] + ways[node])%MOD;\\n                }\\n            }\\n        }\\n\\n        // return the number of ways to reach destination node\\n        return ways[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nWe can find the shortest distance from any vertex to another using Dijkstra Algo in a weighted graph. \\nHere we have to find the number of ways we can go from source to destination and so we keep an array\\nto store the ways count for all nodes as we progress in Dijkstra Algo and use it for the neighbor nodes\\nwhich is actually a DP approach. \\n\\nNow, each time we relax the cost of neighbor node we find a better distance for neighbor node and so \\nthe number of way to go to neighbor node = number way to come to the current node and so we update \\nthe ways[neighbor] = ways[node]. Also when we see that neighbor node cost and current node \\ncost + edge cost is same then this is another way to go to the neighbor node with min cost and so we \\nupdate neighbor node ways count as ways[neighbor] += ways[node]. Also when pop a node with cost \\ngreater than the current cost of the node then we will ignore the furthur operations cause the cost \\nis higher and we need to find min cost paths.\\n```\n```\\nclass Solution {\\npublic:\\n        \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        // Adjacency list of the undirected graph\\n        vector<vector<vector<int>>>adjL(n);\\n        \\n        // distance vector of nodes\\n        vector<long>dist(n,LONG_MAX);\\n        \\n        // populate Adjacency List {node, cost} pair\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adjL[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adjL[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        \\n        int MOD = 1000000007;\\n        \\n        // track the number of ways to reach node with min cost\\n        vector<long>ways(n,0);\\n        \\n        // source node has way 1 \\n        ways[0] = 1;\\n        \\n        // push source node with distance 0, PQ stores {cost, node} pair\\n        priority_queue<pair<long,int>,vector<pair<long,int>>,greater<>>pQ;\\n        pQ.push({0,0});\\n        dist[0] = 0;\\n        \\n        long cost;\\n        int node;        \\n        while(!pQ.empty())\\n        {\\n            cost = pQ.top().first;\\n            node = pQ.top().second;\\n            pQ.pop();\\n            \\n            // if cost is higher than current node distance then we ignroe furthur operations\\n            if(dist[node]<cost)continue;\\n            \\n            // loop through neighbors and relax the neighbor nodes\\n            for(auto &adj: adjL[node])\\n            {                \\n                // relax neighbor nodes and push in to PQ\\n                // neighbor node ways will be updated with current node ways as\\n                // we find a better cost for neighbor node\\n                if(dist[node]+adj[1] < dist[adj[0]])\\n                {\\n                    dist[adj[0]] = dist[node]+adj[1];\\n                    ways[adj[0]] = ways[node];\\n                    pQ.push({dist[adj[0]],adj[0]});\\n                }\\n                \\n                // if current node distance + edge cost = neighbor node cost then\\n                // this is another way to reach the neighbor node with min cost\\n                // so we update neighbor node ways as ways[neighbor] += ways[node]\\n                else if(dist[node]+adj[1] == dist[adj[0]])\\n                {\\n                    ways[adj[0]] = (ways[adj[0]] + ways[node])%MOD;\\n                }\\n            }\\n        }\\n\\n        // return the number of ways to reach destination node\\n        return ways[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669994,
                "title": "python-dijkstra-s-algorithm-min-heap-implementation-90-time-score",
                "content": "```\\nfrom heapq import *\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        # create adjacency list\\n        adj_list = defaultdict(list)\\n        for i,j,k in roads:\\n            adj_list[i].append((j,k))\\n            adj_list[j].append((i,k))\\n            \\n        start = 0\\n        end = n-1\\n        \\n        # set minimum distance of all nodes but start to infinity.\\n        # min_dist[i] = [minimum time from start, number of ways to get to node i in min time]\\n        min_dist = {i:[float(\\'inf\\'),0] for i in adj_list.keys()}\\n        min_dist[start] = [0,1]\\n             \\n        # Heap nodes in the format (elapsed time to get to that node, node index)\\n        # This is done so as to allow the heap to pop node with lowest time first\\n        # Push first node to heap.\\n        heap = [(0, start)]\\n        while heap:\\n            elapsed_time, node = heappop(heap)\\n            # if nodes getting popped have a higher elapsed time than minimum time required\\n            # to reach end node, means we have exhausted all possibilities\\n            # Note: we can do this only because time elapsed cannot be negetive\\n            if elapsed_time > min_dist[end][0]:\\n                break\\n            for neighbor, time in adj_list[node]:\\n                # check most expected condition first. Reduce check time for if statement\\n                if (elapsed_time + time) > min_dist[neighbor][0]:\\n                    continue\\n                # if time is equal to minimum time to node, add the ways to get to node to\\n                # the next node in minimum time\\n                elif (elapsed_time + time) == min_dist[neighbor][0]:\\n                    min_dist[neighbor][1] += min_dist[node][1]\\n                else: # node has not been visited before. Set minimum time \\n                    min_dist[neighbor][0] = elapsed_time + time\\n                    min_dist[neighbor][1] = min_dist[node][1]\\n                    heappush(heap, (elapsed_time+time,neighbor))\\n\\n        return min_dist[end][1]%(pow(10,9)+7)\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        # create adjacency list\\n        adj_list = defaultdict(list)\\n        for i,j,k in roads:\\n            adj_list[i].append((j,k))\\n            adj_list[j].append((i,k))\\n            \\n        start = 0\\n        end = n-1\\n        \\n        # set minimum distance of all nodes but start to infinity.\\n        # min_dist[i] = [minimum time from start, number of ways to get to node i in min time]\\n        min_dist = {i:[float(\\'inf\\'),0] for i in adj_list.keys()}",
                "codeTag": "Java"
            },
            {
                "id": 1417889,
                "title": "python-dijkstra-s-algorithm",
                "content": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = defaultdict(dict)\\n        for u, v, w in roads:\\n            graph[u][v] = graph[v][u] = w\\n        dist = {i:float(inf) for i in range(n)}\\n        ways = {i:0 for i in range(n)}\\n        dist[0], ways[0] = 0, 1\\n        heap = [(0, 0)]\\n        while heap:\\n            d, u = heapq.heappop(heap)\\n            if dist[u] < d: \\n                continue\\n            for v in graph[u]:\\n                if dist[v] == dist[u] + graph[u][v]:\\n                    ways[v] += ways[u]\\n                elif dist[v] > dist[u] + graph[u][v]:\\n                    dist[v] = dist[u] + graph[u][v]\\n                    ways[v] = ways[u]\\n                    heapq.heappush(heap, (dist[v], v))\\n        return ways[n-1] % ((10 ** 9) + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = defaultdict(dict)\\n        for u, v, w in roads:\\n            graph[u][v] = graph[v][u] = w\\n        dist = {i:float(inf) for i in range(n)}\\n        ways = {i:0 for i in range(n)}\\n        dist[0], ways[0] = 0, 1\\n        heap = [(0, 0)]\\n        while heap:\\n            d, u = heapq.heappop(heap)\\n            if dist[u] < d: \\n                continue\\n            for v in graph[u]:\\n                if dist[v] == dist[u] + graph[u][v]:\\n                    ways[v] += ways[u]\\n                elif dist[v] > dist[u] + graph[u][v]:\\n                    dist[v] = dist[u] + graph[u][v]\\n                    ways[v] = ways[u]\\n                    heapq.heappush(heap, (dist[v], v))\\n        return ways[n-1] % ((10 ** 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700975,
                "title": "c-dijkstra-algorithm-easy-understanding",
                "content": "Apply **Dijkstra shortest path algorithm** as the problem involves shortest distance from source to destination. We need to modify **Dijkstra\\'s algorithm** so that it can keep track of the path counts from node 0 to every other node in a way that it can keep track of the distance from every other node to node 0 with the shortest possible distance as the ultimate goal of the problem.\\n\\n* If you find a shortest distance then update the path with new value.\\n* If you find a equal shortest distance then add the value of the parrent node path number to the current node.\\n\\n\\n**P.S**: Use **`long long`** properly.\\n\\n\\n**Time Complexity**: **```O(E * logV + N)```**, where **E** is number of roads, **V** is number of nodes.\\n**Space Complexity**: **```O(E + V)```**\\n\\n**C++ code:**\\n```\\n\\nclass Solution {    \\nprivate:\\n    int dijkstra(vector<pair<int, int>> adj[], int n) {\\n\\t\\tint mod = 1e9 + 7;\\n        // priority queue for keep track of min distance \\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        // store the distance and number of paths\\n        vector<long long> dis(n, 1e15), path(n, 0);\\n\\n        // push the initial node and distance to reach start is 0\\n        pq.push({0, 0});\\n        // mark the distance to 0\\n        dis[0] = 0;\\n        // mark the path number to 1\\n        path[0] = 1;\\n\\n        // until queue is not empty\\n        while (!pq.empty()) {\\n            // get the top (min distance) element from priority queue and remove\\n            long long dist = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n\\n            // iterate on its adjacent nodes\\n            for (auto &child : adj[node]) {\\n                int adjNode = child.first;\\n                long long wt = child.second;\\n\\n                // if it min distance to reach at a node then update it\\n                if (dist + wt < dis[adjNode]) {\\n                    dis[adjNode] = dist + wt;\\n                    path[adjNode] = path[node];\\n                    pq.push({dist + wt, adjNode});\\n                }\\n                else if (dist + wt == dis[adjNode]) {\\n                    //if it already visited with the shortest dis then increse the path with the current node path\\n                    path[adjNode] = (path[node] + path[adjNode]) % mod;\\n                }\\n            }\\n        }\\n\\n        return path[n - 1];\\n    }\\n    \\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // adjacency list\\n        vector<pair<int, int>> adj[n];\\n\\n        // create the graph\\n        for (auto &v : roads) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n            adj[v[1]].push_back({v[0], v[2]});\\n        }\\n        \\n        return dijkstra(adj, n);\\n    }\\n};\\n\\n```\\n\\nPlease **upvote** if you find this helpful. **:)**\\nFeel free to comment in case of any doubt.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```O(E * logV + N)```\n```O(E + V)```\n```\\n\\nclass Solution {    \\nprivate:\\n    int dijkstra(vector<pair<int, int>> adj[], int n) {\\n\\t\\tint mod = 1e9 + 7;\\n        // priority queue for keep track of min distance \\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        // store the distance and number of paths\\n        vector<long long> dis(n, 1e15), path(n, 0);\\n\\n        // push the initial node and distance to reach start is 0\\n        pq.push({0, 0});\\n        // mark the distance to 0\\n        dis[0] = 0;\\n        // mark the path number to 1\\n        path[0] = 1;\\n\\n        // until queue is not empty\\n        while (!pq.empty()) {\\n            // get the top (min distance) element from priority queue and remove\\n            long long dist = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n\\n            // iterate on its adjacent nodes\\n            for (auto &child : adj[node]) {\\n                int adjNode = child.first;\\n                long long wt = child.second;\\n\\n                // if it min distance to reach at a node then update it\\n                if (dist + wt < dis[adjNode]) {\\n                    dis[adjNode] = dist + wt;\\n                    path[adjNode] = path[node];\\n                    pq.push({dist + wt, adjNode});\\n                }\\n                else if (dist + wt == dis[adjNode]) {\\n                    //if it already visited with the shortest dis then increse the path with the current node path\\n                    path[adjNode] = (path[node] + path[adjNode]) % mod;\\n                }\\n            }\\n        }\\n\\n        return path[n - 1];\\n    }\\n    \\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // adjacency list\\n        vector<pair<int, int>> adj[n];\\n\\n        // create the graph\\n        for (auto &v : roads) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n            adj[v[1]].push_back({v[0], v[2]});\\n        }\\n        \\n        return dijkstra(adj, n);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706070,
                "title": "c-dijkstra-algorithm",
                "content": "**Time Complexity=O(V+E)\\nSpace Complexity=O(V+E)**\\nV=number of node\\nE=number of edges\\n\\n\\n  \\n    #define ll long long\\n    class Solution {\\n    public:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll,ll>> adj[n];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        \\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>> pq;\\n        vector<ll> ways(n,0),dist(n,LONG_MAX);\\n        pq.push({0,0});\\n        dist[0]=0;\\n        ways[0]=1;\\n        int mod=1e9+7;\\n        \\n        while(!pq.empty()){\\n            ll dis=pq.top().first;\\n            ll node=pq.top().second;\\n            pq.pop();\\n            \\n            for(auto it:adj[node]){\\n                ll adjNode=it.first;\\n                ll edgeW=it.second;\\n                \\n                if(edgeW+dis< dist[adjNode]){\\n                    dist[adjNode]=edgeW+dis;\\n                    pq.push({edgeW+dis,adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if(edgeW+dis==dist[adjNode]){\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%mod;\\n                }\\n                \\n            }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n    };\\n\\t\\n\\t/**Please Don\\'t forget to Upvote the post**/\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "class Solution {\\n    public:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll,ll>> adj[n];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]}",
                "codeTag": "Java"
            },
            {
                "id": 2671526,
                "title": "c-dijkstra-priority-queue-easy-to-understand",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll,ll>> adj[n];\\n       for(auto it:roads){\\n           adj[it[0]].push_back({it[1],it[2]});\\n           adj[it[1]].push_back({it[0],it[2]});\\n       }\\n       \\n       priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>> pq;\\n       vector<ll> dist(n,LONG_MAX), ways(n,0);\\n       dist[0] = 0;\\n       ways[0] = 1;\\n       \\n       pq.push({0,0});\\n       \\n       while(!pq.empty()){\\n           ll dis = pq.top().first;\\n           ll node = pq.top().second;\\n           pq.pop();\\n           \\n           for(auto it: adj[node]){\\n               ll adjNode = it.first;\\n               ll edW = it.second;\\n               //this is the first time I am coming\\n               //with the short distance\\n               if(dis + edW < dist[adjNode]){\\n                   dist[adjNode] = dis + edW;\\n                   pq.push({dis + edW,adjNode});\\n                   ways[adjNode] = ways[node];\\n               }\\n               else if(dis +edW == dist[adjNode]){\\n                   ways[adjNode] = (ways[adjNode] + ways[node])%MOD;\\n               }\\n           }\\n       }\\n       return ways[n-1];\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll,ll>> adj[n];\\n       for(auto it:roads){\\n           adj[it[0]].push_back({it[1],it[2]});\\n           adj[it[1]].push_back({it[0],it[2]});\\n       }\\n       \\n       priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>> pq;\\n       vector<ll> dist(n,LONG_MAX), ways(n,0);\\n       dist[0] = 0;\\n       ways[0] = 1;\\n       \\n       pq.push({0,0});\\n       \\n       while(!pq.empty()){\\n           ll dis = pq.top().first;\\n           ll node = pq.top().second;\\n           pq.pop();\\n           \\n           for(auto it: adj[node]){\\n               ll adjNode = it.first;\\n               ll edW = it.second;\\n               //this is the first time I am coming\\n               //with the short distance\\n               if(dis + edW < dist[adjNode]){\\n                   dist[adjNode] = dis + edW;\\n                   pq.push({dis + edW,adjNode});\\n                   ways[adjNode] = ways[node];\\n               }\\n               else if(dis +edW == dist[adjNode]){\\n                   ways[adjNode] = (ways[adjNode] + ways[node])%MOD;\\n               }\\n           }\\n       }\\n       return ways[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289695,
                "title": "clean-dijkstra-implementation-c",
                "content": "```\\n#define ll long long\\n#define pi pair<ll , ll>\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        \\n        vector<pi> adj[n];    // node-> pair< adjNode, distance>\\n        for(auto &it : roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        \\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        vector<ll> d(n,LONG_MAX), cnt(n,0);\\n        pq.push({0,0});\\n        d[0] = 0;\\n        cnt[0] = 1;\\n        \\n        while(!pq.empty())\\n        {\\n            ll node = pq.top().second;\\n            ll dist = pq.top().first;\\n            pq.pop();\\n            \\n            for(auto &it : adj[node])\\n            {\\n                ll nextNode = it.first;\\n                ll nextDist = it.second;\\n                \\n                if(dist + nextDist < d[nextNode])\\n                {\\n                    cnt[nextNode] = cnt[node]; //just inherit the no. of shortest path found till node\\n                    d[nextNode] = dist + nextDist;\\n                    pq.push({d[nextNode],nextNode});\\n                }\\n                \\n                else if(dist + nextDist == d[nextNode])\\n                {\\n                    cnt[nextNode] = (cnt[nextNode] + cnt[node])%mod;  //(the no. of shortest path found till node + the no. of shortest path found till nextNode)\\n                }\\n                \\n                else continue;\\n            }\\n        }\\n        \\n        return cnt[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\n#define pi pair<ll , ll>\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        \\n        vector<pi> adj[n];    // node-> pair< adjNode, distance>\\n        for(auto &it : roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        \\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        vector<ll> d(n,LONG_MAX), cnt(n,0);\\n        pq.push({0,0});\\n        d[0] = 0;\\n        cnt[0] = 1;\\n        \\n        while(!pq.empty())\\n        {\\n            ll node = pq.top().second;\\n            ll dist = pq.top().first;\\n            pq.pop();\\n            \\n            for(auto &it : adj[node])\\n            {\\n                ll nextNode = it.first;\\n                ll nextDist = it.second;\\n                \\n                if(dist + nextDist < d[nextNode])\\n                {\\n                    cnt[nextNode] = cnt[node]; //just inherit the no. of shortest path found till node\\n                    d[nextNode] = dist + nextDist;\\n                    pq.push({d[nextNode],nextNode});\\n                }\\n                \\n                else if(dist + nextDist == d[nextNode])\\n                {\\n                    cnt[nextNode] = (cnt[nextNode] + cnt[node])%mod;  //(the no. of shortest path found till node + the no. of shortest path found till nextNode)\\n                }\\n                \\n                else continue;\\n            }\\n        }\\n        \\n        return cnt[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423198,
                "title": "java-basic-minheap-dijkstra-with-minor-changes",
                "content": "Perform regular Dijkstra with some adjustments: \\nadd one more ways[] array alongside to distance[] basic array.\\nif there is an adjacent vertex with total time less than currne time + edge distance, then update best distance and go ahead as usual, by adding edge into minHeap\\nif same time already exists, then we have come from another vertex, but with the same overall time, so let sum both approaches ways count.\\n\\n```\\n    public int countPaths(int n, int[][] roads) {\\n        final int mod = 1000000007;\\n        int[][] adj = new int[n][n];\\n        for(int[] road : roads){\\n            adj[ road[0] ][ road[1] ] = road[2];\\n            adj[ road[1] ][ road[0] ] = road[2];\\n        }\\n        \\n        int[] time = new int[n], ways = new int[n];\\n        Arrays.fill(time,1,n, Integer.MAX_VALUE);\\n        ways[0]=1;\\n       \\n        Queue<int[]> q = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        q.offer(new int[]{0,0});  \\n\\n        while(!q.isEmpty()){\\n            int[] e = q.poll();\\n            int v = e[0], t = e[1];\\n            if(t <= time[v]){\\n                for(int i=0;i<n;i++){\\n                    if(adj[v][i]!=0){\\n                        if(time[v]+adj[v][i] < time[i]){ \\n                            time[i] = time[v]+adj[v][i]; \\n                            \\n                            q.offer(new int[]{i,time[i]});\\n                            ways[i] = ways[v];\\n                        }else if(time[v]+adj[v][i] == time[i]){ \\n                            ways[i] = (ways[i]+ways[v])%mod;    \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countPaths(int n, int[][] roads) {\\n        final int mod = 1000000007;\\n        int[][] adj = new int[n][n];\\n        for(int[] road : roads){\\n            adj[ road[0] ][ road[1] ] = road[2];\\n            adj[ road[1] ][ road[0] ] = road[2];\\n        }\\n        \\n        int[] time = new int[n], ways = new int[n];\\n        Arrays.fill(time,1,n, Integer.MAX_VALUE);\\n        ways[0]=1;\\n       \\n        Queue<int[]> q = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        q.offer(new int[]{0,0});  \\n\\n        while(!q.isEmpty()){\\n            int[] e = q.poll();\\n            int v = e[0], t = e[1];\\n            if(t <= time[v]){\\n                for(int i=0;i<n;i++){\\n                    if(adj[v][i]!=0){\\n                        if(time[v]+adj[v][i] < time[i]){ \\n                            time[i] = time[v]+adj[v][i]; \\n                            \\n                            q.offer(new int[]{i,time[i]});\\n                            ways[i] = ways[v];\\n                        }else if(time[v]+adj[v][i] == time[i]){ \\n                            ways[i] = (ways[i]+ways[v])%mod;    \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068175,
                "title": "c-dijkstra-algorithm-easy-understanding-beats-90-percent",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& r) {\\n        int mod=1e9+7;\\n        vector<vector<pair<long long,long long>>>adj(n);\\n        for(int i=0;i<r.size();i++){\\n            adj[r[i][0]].push_back({r[i][1],r[i][2]});\\n            adj[r[i][1]].push_back({r[i][0],r[i][2]});\\n        }\\n        vector<long long>c(n,0);\\n        c[0]=1;\\n        priority_queue<pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>>> pq;\\n        vector<long long int>dist(n,1e15);\\n        dist[0]=0;\\n        pq.push({0,0});\\n        while(pq.empty()==false){\\n            auto x=pq.top();\\n            long long dis=x.first;\\n            long long node=x.second;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                long long wt=it.second;\\n                long long y=it.first; \\n                if(wt+dis<dist[y]){\\n                    dist[y]=(wt+dis);\\n                    pq.push({dist[y],y});\\n                    c[y]=c[node];\\n                }\\n                else if((wt+dis)==dist[y]){\\n                    c[y]=(c[y]+c[node])%mod;\\n                }\\n                \\n            }\\n        }\\n        return c[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& r) {\\n        int mod=1e9+7;\\n        vector<vector<pair<long long,long long>>>adj(n);\\n        for(int i=0;i<r.size();i++){\\n            adj[r[i][0]].push_back({r[i][1],r[i][2]});\\n            adj[r[i][1]].push_back({r[i][0],r[i][2]});\\n        }\\n        vector<long long>c(n,0);\\n        c[0]=1;\\n        priority_queue<pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>>> pq;\\n        vector<long long int>dist(n,1e15);\\n        dist[0]=0;\\n        pq.push({0,0});\\n        while(pq.empty()==false){\\n            auto x=pq.top();\\n            long long dis=x.first;\\n            long long node=x.second;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                long long wt=it.second;\\n                long long y=it.first; \\n                if(wt+dis<dist[y]){\\n                    dist[y]=(wt+dis);\\n                    pq.push({dist[y],y});\\n                    c[y]=c[node];\\n                }\\n                else if((wt+dis)==dist[y]){\\n                    c[y]=(c[y]+c[node])%mod;\\n                }\\n                \\n            }\\n        }\\n        return c[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424422,
                "title": "java-c-dijkstra-clean-effective-code-with-explanation",
                "content": "Set up the classic Dijkstra algorithm keeping track of cost for each node and the number of paths with the smallest cost.\\n\\nA few tricks to make it work and make it effective:\\n\\n1. Push to the queue only the nodes with the smallest cost. If you encounter the node with the same cost on a different path, update the paths but don\\'t push the node to the queue again.\\n2. If you encounter the node for the first time, or found a more cost-effective path, use the number of paths of the parent.\\n3. If you encounter the node more than once with the optimal cost, increment the number of paths by the number of paths of the parent.\\n\\n**Java:**\\n```\\n    public int countPaths(int n, int[][] roads) {\\n        final long MODULO = 1000000007;\\n        List<int[]>[] adj = new List[n];\\n        Arrays.setAll(adj, x -> new ArrayList<>());\\n        for (int[] r : roads) { // populate adjacency lists\\n            adj[r[0]].add(new int[]{r[1], r[2]});\\n            adj[r[1]].add(new int[]{r[0], r[2]});\\n        }\\n        long[] cost = new long[n], paths = new long[n];\\n        Arrays.fill(cost, -1); // -1 -> not visited\\n        Queue<long[]> q = new PriorityQueue<>((l, r) -> Long.compare(l[1], r[1])); // [node, cost]\\n        q.offer(new long[]{0,0});\\n        paths[0] = 1; // to make path accumulation work\\n        cost[0] = 0;\\n        \\n        while (!q.isEmpty()) {\\n            long[] f = q.poll();\\n            int fnode = (int) f[0];\\n            if (fnode == n - 1)\\n                return (int)(paths[fnode] % MODULO);\\n            for (int[] ch : adj[fnode]) {\\n                long newCost = f[1] + ch[1];\\n                if (newCost == cost[ch[0]]) // add all paths from the parent node\\n                    paths[ch[0]] += paths[fnode] % MODULO;\\n                if (cost[ch[0]] == -1 || newCost < cost[ch[0]]) {\\n                    paths[ch[0]] = paths[fnode]; // all previous paths are irrelevant\\n                    q.offer(new long[]{ch[0], newCost});\\n                    cost[ch[0]] = newCost;\\n                }\\n            }\\n        }\\n        return -1; // shouldn\\'t get here\\n    }\\n```\\n**C++:**\\n```\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        static constexpr long MODULO = 1000000007;\\n        vector<vector<pair<int,int>>> adj(n, vector<pair<int,int>>());\\n        for (const vector<int>& r : roads) { // populate adjacency lists with node and cost\\n            adj[r[0]].emplace_back(r[1], r[2]);\\n            adj[r[1]].emplace_back(r[0], r[2]);\\n        }\\n        vector<long> paths(n), cost(n, -1); // -1 -> not visited\\n        static constexpr auto comp = [](const pair<int,long>& l, const pair<int,long>& r) { return l.second > r.second; };\\n        priority_queue<pair<int,long>, vector<pair<int,long>>, decltype(comp)> q(comp); // [node, cost]\\n        q.emplace(0, 0);\\n        paths[0] = 1; // to make path accumulation work\\n        cost[0] = 0;\\n        \\n        while (!q.empty()) {\\n            auto [fnode, fCost] = q.top();\\n            q.pop();\\n            if (fnode == n - 1)\\n                return static_cast<int>(paths[fnode] % MODULO);\\n            for (const auto& [ chNode, chCost ] : adj[fnode]) {\\n                long newCost = fCost + chCost;\\n                if (newCost == cost[chNode]) // add all paths from the parent node\\n                    paths[chNode] += paths[fnode] % MODULO;\\n                if (cost[chNode] == -1 || newCost < cost[chNode]) {\\n                    paths[chNode] = paths[fnode]; // all previous paths are irrelevant\\n                    q.emplace(chNode, newCost);\\n                    cost[chNode] = newCost;\\n                }\\n            }\\n        }\\n        return -1; // shouldn\\'t get here\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    public int countPaths(int n, int[][] roads) {\\n        final long MODULO = 1000000007;\\n        List<int[]>[] adj = new List[n];\\n        Arrays.setAll(adj, x -> new ArrayList<>());\\n        for (int[] r : roads) { // populate adjacency lists\\n            adj[r[0]].add(new int[]{r[1], r[2]});\\n            adj[r[1]].add(new int[]{r[0], r[2]});\\n        }\\n        long[] cost = new long[n], paths = new long[n];\\n        Arrays.fill(cost, -1); // -1 -> not visited\\n        Queue<long[]> q = new PriorityQueue<>((l, r) -> Long.compare(l[1], r[1])); // [node, cost]\\n        q.offer(new long[]{0,0});\\n        paths[0] = 1; // to make path accumulation work\\n        cost[0] = 0;\\n        \\n        while (!q.isEmpty()) {\\n            long[] f = q.poll();\\n            int fnode = (int) f[0];\\n            if (fnode == n - 1)\\n                return (int)(paths[fnode] % MODULO);\\n            for (int[] ch : adj[fnode]) {\\n                long newCost = f[1] + ch[1];\\n                if (newCost == cost[ch[0]]) // add all paths from the parent node\\n                    paths[ch[0]] += paths[fnode] % MODULO;\\n                if (cost[ch[0]] == -1 || newCost < cost[ch[0]]) {\\n                    paths[ch[0]] = paths[fnode]; // all previous paths are irrelevant\\n                    q.offer(new long[]{ch[0], newCost});\\n                    cost[ch[0]] = newCost;\\n                }\\n            }\\n        }\\n        return -1; // shouldn\\'t get here\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1417598,
                "title": "python3-dfs-dp",
                "content": "\\n```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {}\\n        for u, v, time in roads: \\n            graph.setdefault(u, {})[v] = time\\n            graph.setdefault(v, {})[u] = time\\n            \\n        dist = [inf]*n\\n        dist[-1] = 0\\n        stack = [(n-1, 0)]\\n        while stack: \\n            x, t = stack.pop()\\n            if t == dist[x]: \\n                for xx in graph.get(x, {}): \\n                    if t + graph[x][xx] < dist[xx]: \\n                        dist[xx] = t + graph[x][xx]\\n                        stack.append((xx, t + graph[x][xx]))\\n                        \\n        @cache\\n        def fn(x):\\n            \"\"\"Return \"\"\"\\n            if x == n-1: return 1 \\n            if dist[x] == inf: return 0 \\n            ans = 0 \\n            for xx in graph.get(x, {}): \\n                if graph[x][xx] + dist[xx] == dist[x]: ans += fn(xx)\\n            return ans % 1_000_000_007\\n        \\n        return fn(0)\\n```\\n\\n```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {}\\n        for u, v, time in roads: \\n            graph.setdefault(u, []).append((v, time))\\n            graph.setdefault(v, []).append((u, time))\\n        \\n        dist = [inf] * n\\n        dist[0] = 0\\n        ways = [0] * n\\n        ways[0] = 1\\n        \\n        pq = [(0, 0)]\\n        while pq: \\n            d, u = heappop(pq)\\n            if d > dist[-1]: break\\n            if d == dist[u]: \\n                for v, time in graph.get(u, []): \\n                    if dist[u] + time < dist[v]: \\n                        dist[v] = dist[u] + time\\n                        ways[v] = ways[u]\\n                        heappush(pq, (dist[v], v))\\n                    elif dist[u] + time == dist[v]: ways[v] += ways[u]\\n        return ways[-1] % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {}\\n        for u, v, time in roads: \\n            graph.setdefault(u, {})[v] = time\\n            graph.setdefault(v, {})[u] = time\\n            \\n        dist = [inf]*n\\n        dist[-1] = 0\\n        stack = [(n-1, 0)]\\n        while stack: \\n            x, t = stack.pop()\\n            if t == dist[x]: \\n                for xx in graph.get(x, {}): \\n                    if t + graph[x][xx] < dist[xx]: \\n                        dist[xx] = t + graph[x][xx]\\n                        stack.append((xx, t + graph[x][xx]))\\n                        \\n        @cache\\n        def fn(x):\\n            \"\"\"Return \"\"\"\\n            if x == n-1: return 1 \\n            if dist[x] == inf: return 0 \\n            ans = 0 \\n            for xx in graph.get(x, {}): \\n                if graph[x][xx] + dist[xx] == dist[x]: ans += fn(xx)\\n            return ans % 1_000_000_007\\n        \\n        return fn(0)\\n```\n```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {}\\n        for u, v, time in roads: \\n            graph.setdefault(u, []).append((v, time))\\n            graph.setdefault(v, []).append((u, time))\\n        \\n        dist = [inf] * n\\n        dist[0] = 0\\n        ways = [0] * n\\n        ways[0] = 1\\n        \\n        pq = [(0, 0)]\\n        while pq: \\n            d, u = heappop(pq)\\n            if d > dist[-1]: break\\n            if d == dist[u]: \\n                for v, time in graph.get(u, []): \\n                    if dist[u] + time < dist[v]: \\n                        dist[v] = dist[u] + time\\n                        ways[v] = ways[u]\\n                        heappush(pq, (dist[v], v))\\n                    elif dist[u] + time == dist[v]: ways[v] += ways[u]\\n        return ways[-1] % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653839,
                "title": "dijkstra-s-algo-using-priority-queue-c-solution",
                "content": "\\n# Complexity\\n- Time complexity: **O(E logV)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(V) + O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& a) {\\n        vector<pair<long long, long long>> adj[n];\\n        // it -> from to weight\\n        for(auto it:a){\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        vector<long long> ways(n, 0);\\n        vector<long long> dist(n, LONG_MAX);\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq; // dist node\\n        pq.push({0, 0});\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        while(!pq.empty()){\\n            long long d = pq.top().first;\\n            long long node = pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                long long wt = it.second;\\n                long long adjnode = it.first;\\n                if(d + wt < dist[adjnode]){\\n                    dist[adjnode] = d + wt;\\n                    ways[adjnode] = ways[node];\\n                    pq.push({ dist[adjnode], adjnode});\\n                }\\n                else if(d + wt == dist[adjnode])\\n                         ways[adjnode]=((ways[adjnode] % 1000000007 + ways[node]) % 1000000007) % 1000000007;\\n            }\\n        }\\n        return ways[n - 1] % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& a) {\\n        vector<pair<long long, long long>> adj[n];\\n        // it -> from to weight\\n        for(auto it:a){\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        vector<long long> ways(n, 0);\\n        vector<long long> dist(n, LONG_MAX);\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq; // dist node\\n        pq.push({0, 0});\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        while(!pq.empty()){\\n            long long d = pq.top().first;\\n            long long node = pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                long long wt = it.second;\\n                long long adjnode = it.first;\\n                if(d + wt < dist[adjnode]){\\n                    dist[adjnode] = d + wt;\\n                    ways[adjnode] = ways[node];\\n                    pq.push({ dist[adjnode], adjnode});\\n                }\\n                else if(d + wt == dist[adjnode])\\n                         ways[adjnode]=((ways[adjnode] % 1000000007 + ways[node]) % 1000000007) % 1000000007;\\n            }\\n        }\\n        return ways[n - 1] % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315488,
                "title": "best-c-solution",
                "content": "# Approach\\nDijkstra\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(ElogV)$$\\n\\n- Space complexity:\\n$$O(V + E)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector <pair<long long, long long>> adj[n];\\n        for (auto it : roads) {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        priority_queue <pair<long long, long long>, vector<pair<long long, long long>>, greater<>> pq;\\n        vector <long long> dist(n, LLONG_MAX), ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        int mod = (int)(1e9 + 7);\\n        while (!pq.empty()) {\\n            long long dis = pq.top().first;\\n            long long node = pq.top().second;\\n            pq.pop();\\n            if (dist[node] < dis)\\n                continue;\\n            for (auto it : adj[node]) {\\n                long long adjNode = it.first;\\n                long long edW = it.second;\\n                if (dis + edW < dist[adjNode]) {\\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW, adjNode});\\n                    ways[adjNode] = ways[node];\\n                } else if (dis + edW == dist[adjNode]) {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector <pair<long long, long long>> adj[n];\\n        for (auto it : roads) {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        priority_queue <pair<long long, long long>, vector<pair<long long, long long>>, greater<>> pq;\\n        vector <long long> dist(n, LLONG_MAX), ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        int mod = (int)(1e9 + 7);\\n        while (!pq.empty()) {\\n            long long dis = pq.top().first;\\n            long long node = pq.top().second;\\n            pq.pop();\\n            if (dist[node] < dis)\\n                continue;\\n            for (auto it : adj[node]) {\\n                long long adjNode = it.first;\\n                long long edW = it.second;\\n                if (dis + edW < dist[adjNode]) {\\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW, adjNode});\\n                    ways[adjNode] = ways[node];\\n                } else if (dis + edW == dist[adjNode]) {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931316,
                "title": "c-same-as-dijkstra-alogrithm",
                "content": "**prerequisite: Dijkstra Algorithm**\\nvedio link :[Dijkstra\\'s Algorithm by Striver(Legend)](https://youtu.be/V6H1qAeB-l4)\\n```\\n#define ll long long\\nconst int mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        //First create an adjacency list\\n        vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        //Now to calculate miminum time to reach the destination let create an array and initialize all the positions to LONG_INT\\n        // except starting index\\n        vector<ll> time(n,LONG_MAX);\\n        time[0] = 0;\\n        //Now to store the number of way to reach the node in min time let create another array named way\\n        //And initialize all the nodes to zero but the number of way to start from the staring index is 1 so initialize it\\n        vector<ll> way(n,0);\\n        way[0] = 1;\\n        //As usual create an priority queue of pair which stores node and time to reach the current node\\n        priority_queue <pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>> > pq;//{time,node}\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            ll currTime = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            for(auto it: adj[node]){\\n                int adjNode = it.first;\\n                ll timeTotravel = it.second;\\n                // relax adjNode nodes and push in to priority queue\\n                // adjNode node ways will be updated with current node ways as\\n                // we find a lesser time for adjNode node\\n                if(currTime + timeTotravel < time[adjNode]){\\n                    time[adjNode] = currTime + timeTotravel;\\n                    pq.push({time[adjNode],adjNode});\\n                    way[adjNode] = way[node]%mod;\\n                }\\n                // if current node time + timeTotravel = adjNode node cost then\\n                // this is another way to reach the adjNode node with min time\\n                // so we update adjNode node ways as ways[adjNode] = (ways[node]+way[adjNode])%mod\\n                else if(currTime + timeTotravel == time[adjNode])\\n                    way[adjNode] = (way[adjNode]+way[node])%mod;\\n            }\\n        }\\n        return way[n-1];\\n    }\\n};\\n```\\n**Time Complexity : O(Total Edge x log(Total Nodes))**\\n**space complexity : O(Total Nodes)**",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nconst int mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        //First create an adjacency list\\n        vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        //Now to calculate miminum time to reach the destination let create an array and initialize all the positions to LONG_INT\\n        // except starting index\\n        vector<ll> time(n,LONG_MAX);\\n        time[0] = 0;\\n        //Now to store the number of way to reach the node in min time let create another array named way\\n        //And initialize all the nodes to zero but the number of way to start from the staring index is 1 so initialize it\\n        vector<ll> way(n,0);\\n        way[0] = 1;\\n        //As usual create an priority queue of pair which stores node and time to reach the current node\\n        priority_queue <pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>> > pq;//{time,node}\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            ll currTime = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            for(auto it: adj[node]){\\n                int adjNode = it.first;\\n                ll timeTotravel = it.second;\\n                // relax adjNode nodes and push in to priority queue\\n                // adjNode node ways will be updated with current node ways as\\n                // we find a lesser time for adjNode node\\n                if(currTime + timeTotravel < time[adjNode]){\\n                    time[adjNode] = currTime + timeTotravel;\\n                    pq.push({time[adjNode],adjNode});\\n                    way[adjNode] = way[node]%mod;\\n                }\\n                // if current node time + timeTotravel = adjNode node cost then\\n                // this is another way to reach the adjNode node with min time\\n                // so we update adjNode node ways as ways[adjNode] = (ways[node]+way[adjNode])%mod\\n                else if(currTime + timeTotravel == time[adjNode])\\n                    way[adjNode] = (way[adjNode]+way[node])%mod;\\n            }\\n        }\\n        return way[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288353,
                "title": "java-solution-dijkstra-using-min-heap-with-extensive-comments-hope-it-helps",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countPaths(int n, int[][] roads) {\\n\\t\\t\\tList<Edge>[] graph = constructGraph(n, roads); // returns adjacency List for given road[][]\\n\\n\\t\\t\\tPriorityQueue<Pair> pq = new PriorityQueue<>();\\n\\t\\t\\tint[] dist = new int[n]; // dist array stores the min. cost/weight/time to reach from sourceVtx(0) to every other node in the graph\\n\\t\\t\\tArrays.fill(dist, Integer.MAX_VALUE); // since we want to calculate the Min. distance/time ..intialize each dist[i] with infinity.\\n\\n\\t\\t\\tint[] path = new int[n]; // this is the extra storage which stores the count of paths from src to every other node in the graph\\n\\n\\t\\t\\tpq.add(new Pair(0, 0)); // Pair(vtx, weight)\\n\\t\\t\\tdist[0] = 0; // we are starint from source : 0, therefore 0 distance/cost/time to reach 0 from 0.\\n\\t\\t\\tpath[0] = 1; // Initial/Base Value  for source vtx : 1 path to reach source while standing on source.\\n\\n\\t\\t\\tint modVal = (int)1e9 + 7; // required by question.\\n\\t\\t\\twhile(pq.size() > 0) {\\n\\t\\t\\t\\tPair rem = pq.remove();\\n\\n\\t\\t\\t\\tfor(Edge e : graph[rem.vtx]) {\\n\\t\\t\\t\\t\\tint nbr = e.nbr; // V\\n\\t\\t\\t\\t\\tint nbrdist = e.wt; // nbrdist is the wt between rem.vtx(U) and its neighbour(V)\\n\\t\\t\\t\\t\\tif(rem.wsf + nbrdist < dist[nbr]) { // if this conditions is true : it means we are on a path which reach neighbour of rem.vtx i.e U at a lesser cost/time that what is stored in the distance array for this neighbour... so update it and add neighbour im queue\\n\\t\\t\\t\\t\\t\\tdist[nbr] = rem.wsf + nbrdist;\\n\\t\\t\\t\\t\\t\\tpath[nbr] = path[rem.vtx]; // this line means that if we can reach node : U in X ways then we can also reach the neighbours of U in X ways.... therefore path[nbr] = path[U] U here means rem.vtx\\n\\t\\t\\t\\t\\t\\tpq.add(new Pair(nbr, dist[nbr]));\\n\\t\\t\\t\\t\\t} else if(rem.wsf + nbrdist == dist[nbr]) {\\n\\t\\t\\t\\t\\t// this check denotes that we came at this nbr previously and now again at same cost as previous time...\\n\\t\\t\\t\\t\\t// therefore we have explored a new path for reaching this nbr via current vtx i.e U....\\n\\t\\t\\t\\t\\t// therefore new ways of reaching nbr would be path[nbr] + path[rem.vtx]  (Basic DP structure, dry run it once, you will get it)\\n\\t\\t\\t\\t\\t\\tpath[nbr] += path[rem.vtx]; \\n\\t\\t\\t\\t\\t\\tpath[nbr] = path[nbr] % modVal;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn path[n-1]; // n-1 is the destination vtx\\n\\t\\t}\\n\\n\\t\\t// this class is for BFS traversing using MinHeap \\n\\t\\tprivate class Pair implements Comparable<Pair>{ \\n\\t\\t\\tint vtx;\\n\\t\\t\\tint wsf;\\n\\t\\t\\tPair(int vtx, int wsf) {\\n\\t\\t\\t\\tthis.vtx = vtx;\\n\\t\\t\\t\\tthis.wsf = wsf; // weightSoFar\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic int compareTo(Pair o) {\\n\\t\\t\\t\\treturn this.wsf - o.wsf;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate class Edge {\\n\\t\\t\\tint src; // U\\n\\t\\t\\tint nbr; // V\\n\\t\\t\\tint wt; // cost of travelling from U to V or vice versa\\n\\t\\t\\tEdge(int src, int nbr, int wt) {\\n\\t\\t\\t\\tthis.src = src;\\n\\t\\t\\t\\tthis.nbr = nbr;\\n\\t\\t\\t\\tthis.wt = wt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate List<Edge>[] constructGraph(int n, int[][] roads) {\\n\\t\\t\\tList<Edge>[] graph = new ArrayList[n];\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) { // initializing graph[] with empty arrayLists\\n\\t\\t\\t\\tgraph[i] = new ArrayList<>();\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 0; i < roads.length; i++) {\\n\\t\\t\\t\\tint u = roads[i][0];\\n\\t\\t\\t\\tint v = roads[i][1];\\n\\t\\t\\t\\tint wt = roads[i][2];\\n\\n\\t\\t\\t\\tgraph[u].add(new Edge(u, v, wt)); // add Edge at Uth node which goes from U to V at wt cost\\n\\t\\t\\t\\tgraph[v].add(new Edge(v, u, wt)); // add Edge at Vth node which goes from V to U at wt cost\\n\\t\\t\\t}\\n\\t\\t\\treturn graph;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countPaths(int n, int[][] roads) {\\n\\t\\t\\tList<Edge>[] graph = constructGraph(n, roads); // returns adjacency List for given road[][]\\n\\n\\t\\t\\tPriorityQueue<Pair> pq = new PriorityQueue<>();\\n\\t\\t\\tint[] dist = new int[n]; // dist array stores the min. cost/weight/time to reach from sourceVtx(0) to every other node in the graph\\n\\t\\t\\tArrays.fill(dist, Integer.MAX_VALUE); // since we want to calculate the Min. distance/time ..intialize each dist[i] with infinity.\\n\\n\\t\\t\\tint[] path = new int[n]; // this is the extra storage which stores the count of paths from src to every other node in the graph\\n\\n\\t\\t\\tpq.add(new Pair(0, 0)); // Pair(vtx, weight)\\n\\t\\t\\tdist[0] = 0; // we are starint from source : 0, therefore 0 distance/cost/time to reach 0 from 0.\\n\\t\\t\\tpath[0] = 1; // Initial/Base Value  for source vtx : 1 path to reach source while standing on source.\\n\\n\\t\\t\\tint modVal = (int)1e9 + 7; // required by question.\\n\\t\\t\\twhile(pq.size() > 0) {\\n\\t\\t\\t\\tPair rem = pq.remove();\\n\\n\\t\\t\\t\\tfor(Edge e : graph[rem.vtx]) {\\n\\t\\t\\t\\t\\tint nbr = e.nbr; // V\\n\\t\\t\\t\\t\\tint nbrdist = e.wt; // nbrdist is the wt between rem.vtx(U) and its neighbour(V)\\n\\t\\t\\t\\t\\tif(rem.wsf + nbrdist < dist[nbr]) { // if this conditions is true : it means we are on a path which reach neighbour of rem.vtx i.e U at a lesser cost/time that what is stored in the distance array for this neighbour... so update it and add neighbour im queue\\n\\t\\t\\t\\t\\t\\tdist[nbr] = rem.wsf + nbrdist;\\n\\t\\t\\t\\t\\t\\tpath[nbr] = path[rem.vtx]; // this line means that if we can reach node : U in X ways then we can also reach the neighbours of U in X ways.... therefore path[nbr] = path[U] U here means rem.vtx\\n\\t\\t\\t\\t\\t\\tpq.add(new Pair(nbr, dist[nbr]));\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1534911,
                "title": "c-o-mlogn-approach-explained-two-solutions-i-dijkstra-ii-dijkstra-dp",
                "content": "I figured out Solution ii) first and then got to know that only Dijkstra would suffice and got Solution i) after seeing discussions. Both have same time complexity and both passed all test cases.\\n\\nSolution i)\\n\\nApproach - Apply Dijkstra from n-1. Suppose waysToReachN1[i] denotes # of ways to reach n-1 from i. Our answer would be waysToReachN1[0].\\n\\nCases -\\ni) i==n-1 | waysToReachN1[i] = 1\\nii) If we find better distance for node i from node j then waysToReachN1[i]=waysToReachN1[j]\\niii) If we find equal distance for node i from node j then waysToReachN1[i]+=waysToReachN1[j]\\n\\n```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const vector<long long> &left, const vector<long long> &right){\\n          return left[0] >= right[0];\\n        }\\n    };\\n\\n    long long dijkstra(int n, vector<vector<vector<long long>>> &adj) {\\n        vector<long long> distances(n, LONG_MAX);\\n        priority_queue<vector<long long>, vector<vector<long long>>, cmp> Q;\\n        distances[n-1] = 0;      \\n        vector<long long> waysToReachN1(n, 0);\\n        Q.push({distances[n-1], n-1});      \\n        waysToReachN1[n-1] = 1;\\n        while(!Q.empty()){\\n            vector<long long> vec = Q.top(); Q.pop();\\n            long long distanceSoFar = vec[0];\\n            int node = vec[1];        \\n\\t\\t\\tif(distanceSoFar > distances[node]) continue;\\n            for(vector<long long> vecNeigh: adj[node]){\\n                int node_neigh = vecNeigh[0];\\n                long long distanceBetweenTwo = vecNeigh[1];          \\n                if(distanceSoFar + distanceBetweenTwo < distances[node_neigh]){\\n                    distances[node_neigh] = distanceSoFar + distanceBetweenTwo;\\n                    Q.push({distances[node_neigh], node_neigh});        \\n                    // found new way\\n                    waysToReachN1[node_neigh] = waysToReachN1[node]; \\n                } else if(distanceSoFar + distanceBetweenTwo == distances[node_neigh]) {\\n                    waysToReachN1[node_neigh]=(waysToReachN1[node_neigh] + waysToReachN1[node])%(1000000007); \\n                }\\n            }                    \\n        }         \\n\\n        return waysToReachN1[0];            \\n    }  \\n  \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n      vector<vector<vector<long long>>> adj(n);\\n      for(vector<int> road:roads){\\n        long long u = road[0];\\n        long long v = road[1];\\n        long long time = road[2];\\n        adj[u].push_back({v, time});\\n        adj[v].push_back({u, time});\\n      }\\n      \\n      return dijkstra(n,adj);      \\n    }\\n};\\n```\\nSolution ii)\\n```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const vector<long long> &left, const vector<long long> &right){\\n          return left[0] >= right[0];\\n        }\\n    };\\n\\n    vector<long long> dijkstra(int n, vector<vector<vector<long long>>> &adj) {\\n        vector<long long> distances(n, LONG_MAX);\\n        priority_queue<vector<long long>, vector<vector<long long>>, cmp> Q;\\n        distances[n-1] = 0;      \\n        Q.push({distances[n-1], n-1});      \\n        while(!Q.empty()){\\n            vector<long long> vec = Q.top(); Q.pop();\\n            long long distanceSoFar = vec[0];\\t\\t\\t\\t\\t\\t\\n            int node = vec[1];        \\n\\t\\t\\tif(distanceSoFar > distances[node]) continue;\\n            for(vector<long long> vecNeigh: adj[node]){\\n                int node_neigh = vecNeigh[0];\\n                long long distanceBetweenTwo = vecNeigh[1];          \\n                if(distanceSoFar + distanceBetweenTwo < distances[node_neigh]){\\n                    distances[node_neigh] = distanceSoFar + distanceBetweenTwo;\\n                    Q.push({distances[node_neigh], node_neigh});                         \\n                }\\n            }                    \\n        }\\n\\n        return distances;            \\n    }\\n  \\n    int countWays(int u, vector<vector<vector<long long>>> &adj, vector<long long> &distances, long long toCoverMore, vector<long long> &dp){\\n        int n = adj.size();  \\n                            \\n        if(dp[u]!=-1) return dp[u];\\n      \\n        if(u==n-1){            \\n            if(toCoverMore == 0) return 1;\\n            return 0;\\n        }\\n      \\n        long long res = 0;\\n                      \\n        for(vector<long long> vecNeigh: adj[u]){\\n            int node_neigh = vecNeigh[0];\\n            long long distanceBetweenTwo = vecNeigh[1];\\n            if(toCoverMore-distanceBetweenTwo == distances[node_neigh]){\\n                res=(res + countWays(node_neigh,adj,distances,toCoverMore-distanceBetweenTwo,dp))%(1000000007);                   \\n            }                \\n        } \\n      \\n        return dp[u] = res;\\n    }\\n  \\n  \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n      vector<vector<vector<long long>>> adj(n);\\n      for(vector<int> road:roads){\\n        long long u = road[0];\\n        long long v = road[1];\\n        long long time = road[2];\\n        adj[u].push_back({v, time});\\n        adj[v].push_back({u, time});\\n      }\\n      \\n      vector<long long> distances = dijkstra(n,adj);      \\n      vector<long long> dp(n, -1);\\n      \\n      long long ways = countWays(0, adj, distances, distances[0], dp);      \\n      return ways;      \\n      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const vector<long long> &left, const vector<long long> &right){\\n          return left[0] >= right[0];\\n        }\\n    };\\n\\n    long long dijkstra(int n, vector<vector<vector<long long>>> &adj) {\\n        vector<long long> distances(n, LONG_MAX);\\n        priority_queue<vector<long long>, vector<vector<long long>>, cmp> Q;\\n        distances[n-1] = 0;      \\n        vector<long long> waysToReachN1(n, 0);\\n        Q.push({distances[n-1], n-1});      \\n        waysToReachN1[n-1] = 1;\\n        while(!Q.empty()){\\n            vector<long long> vec = Q.top(); Q.pop();\\n            long long distanceSoFar = vec[0];\\n            int node = vec[1];        \\n\\t\\t\\tif(distanceSoFar > distances[node]) continue;\\n            for(vector<long long> vecNeigh: adj[node]){\\n                int node_neigh = vecNeigh[0];\\n                long long distanceBetweenTwo = vecNeigh[1];          \\n                if(distanceSoFar + distanceBetweenTwo < distances[node_neigh]){\\n                    distances[node_neigh] = distanceSoFar + distanceBetweenTwo;\\n                    Q.push({distances[node_neigh], node_neigh});        \\n                    // found new way\\n                    waysToReachN1[node_neigh] = waysToReachN1[node]; \\n                } else if(distanceSoFar + distanceBetweenTwo == distances[node_neigh]) {\\n                    waysToReachN1[node_neigh]=(waysToReachN1[node_neigh] + waysToReachN1[node])%(1000000007); \\n                }\\n            }                    \\n        }         \\n\\n        return waysToReachN1[0];            \\n    }  \\n  \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n      vector<vector<vector<long long>>> adj(n);\\n      for(vector<int> road:roads){\\n        long long u = road[0];\\n        long long v = road[1];\\n        long long time = road[2];\\n        adj[u].push_back({v, time});\\n        adj[v].push_back({u, time});\\n      }\\n      \\n      return dijkstra(n,adj);      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const vector<long long> &left, const vector<long long> &right){\\n          return left[0] >= right[0];\\n        }\\n    };\\n\\n    vector<long long> dijkstra(int n, vector<vector<vector<long long>>> &adj) {\\n        vector<long long> distances(n, LONG_MAX);\\n        priority_queue<vector<long long>, vector<vector<long long>>, cmp> Q;\\n        distances[n-1] = 0;      \\n        Q.push({distances[n-1], n-1});      \\n        while(!Q.empty()){\\n            vector<long long> vec = Q.top(); Q.pop();\\n            long long distanceSoFar = vec[0];\\t\\t\\t\\t\\t\\t\\n            int node = vec[1];        \\n\\t\\t\\tif(distanceSoFar > distances[node]) continue;\\n            for(vector<long long> vecNeigh: adj[node]){\\n                int node_neigh = vecNeigh[0];\\n                long long distanceBetweenTwo = vecNeigh[1];          \\n                if(distanceSoFar + distanceBetweenTwo < distances[node_neigh]){\\n                    distances[node_neigh] = distanceSoFar + distanceBetweenTwo;\\n                    Q.push({distances[node_neigh], node_neigh});                         \\n                }\\n            }                    \\n        }\\n\\n        return distances;            \\n    }\\n  \\n    int countWays(int u, vector<vector<vector<long long>>> &adj, vector<long long> &distances, long long toCoverMore, vector<long long> &dp){\\n        int n = adj.size();  \\n                            \\n        if(dp[u]!=-1) return dp[u];\\n      \\n        if(u==n-1){            \\n            if(toCoverMore == 0) return 1;\\n            return 0;\\n        }\\n      \\n        long long res = 0;\\n                      \\n        for(vector<long long> vecNeigh: adj[u]){\\n            int node_neigh = vecNeigh[0];\\n            long long distanceBetweenTwo = vecNeigh[1];\\n            if(toCoverMore-distanceBetweenTwo == distances[node_neigh]){\\n                res=(res + countWays(node_neigh,adj,distances,toCoverMore-distanceBetweenTwo,dp))%(1000000007);                   \\n            }                \\n        } \\n      \\n        return dp[u] = res;\\n    }\\n  \\n  \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n      vector<vector<vector<long long>>> adj(n);\\n      for(vector<int> road:roads){\\n        long long u = road[0];\\n        long long v = road[1];\\n        long long time = road[2];\\n        adj[u].push_back({v, time});\\n        adj[v].push_back({u, time});\\n      }\\n      \\n      vector<long long> distances = dijkstra(n,adj);      \\n      vector<long long> dp(n, -1);\\n      \\n      long long ways = countWays(0, adj, distances, distances[0], dp);      \\n      return ways;      \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453892,
                "title": "testcases-wrong",
                "content": "I am able to give custom test cases with time = 0. But in the constraints it is given\\n```1 <= timei <= 10^9```.\\nplease fix it.\\n",
                "solutionTags": [],
                "code": "```1 <= timei <= 10^9```",
                "codeTag": "Unknown"
            },
            {
                "id": 1437152,
                "title": "c-dijkstra-two-solutions",
                "content": "**Time Complexity: O(V^2 log V)** where V is the number of node and E is the edges. \\nSince we push each node to the minheap only once, that why we say log(V)\\n**Space Complexity: O(V+ E)**\\n\\n**Optimized Solution**\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // Build the weighted graph\\n        vector<vector<vector<int>>> graph(n);\\n        for (vector<int> &road : roads) {\\n            graph[road[0]].push_back({ road[2], road[1] }); // { time, node }\\n            graph[road[1]].push_back({ road[2], road[0] }); // { time, node }\\n        }\\n        \\n        // We will use a min-heap sorted by total time: { total time, node }\\n        priority_queue<vector<long long>, vector<vector<long long>>, greater<>> minheap;\\n        \\n        // Start with the initial node\\n        minheap.push({ 0, 0 }); // { time, node }\\n        \\n        // Distances table for Dijkstra, dist[i] gives the shortest path between src to node_i\\n        vector<long long> dist(n, LLONG_MAX);\\n        \\n        // Number of ways to reach a node via shortest path\\n        vector<long long> ways(n, 0);\\n        \\n        dist[0] = 0;\\n        ways[0] = 1;\\n        long long mod = 1000000007;\\n        \\n        while (!minheap.empty()) {\\n            // Get the current minimum time and node\\n            long long totalDist = minheap.top()[0];\\n            long long currentNode = minheap.top()[1];\\n            minheap.pop();\\n            \\n            // Optimization, we don\\'t need the distances greater than the one previously found \\n            if (totalDist > dist[currentNode]) {\\n                continue;\\n            }\\n            \\n            // Check the neighbors and update dist value of the neighbors of the picked vertex\\n            for (vector<int> &neigh : graph[currentNode]) {\\n                // Relaxation, update the dist if neighbor is not visited and the new cost is smaller than the prev\\n                int neighbor = neigh[1];\\n                long long newDist = neigh[0] + totalDist;\\n                \\n                // Update the shortest path and ways\\n                if (newDist < dist[neighbor]) {\\n                    dist[neighbor] = newDist;\\n                    ways[neighbor] = ways[currentNode];\\n                    minheap.push({ dist[neighbor], neighbor });\\n                }\\n                \\n                // Another shortest path found, increment the ways to node_i\\n                else if (newDist == dist[neighbor]) {\\n                    ways[neighbor] = (ways[neighbor] + ways[currentNode]) % mod;\\n                }\\n            }\\n        }\\n        \\n        return ways[n - 1];\\n    }\\n};\\n```\\n\\n**Initial Solution**\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // Build the weighted graph\\n        vector<vector<vector<int>>> graph(n);\\n        for (vector<int> &road : roads) {\\n            graph[road[0]].push_back({ road[2], road[1] }); // { time, node }\\n            graph[road[1]].push_back({ road[2], road[0] }); // { time, node }\\n        }\\n        \\n        // We will use a min-heap sorted by total time: { total time, node }\\n        priority_queue<vector<long long>, vector<vector<long long>>, greater<>> minheap;\\n        \\n        // Start with the initial node\\n        minheap.push({ 0, 0 }); // { time, node }\\n        \\n        // Distances table for Dijkstra, dist[i] gives the shortest path between src to node_i\\n        vector<long long> dist(n, LLONG_MAX);\\n        \\n        // Number of ways to reach a node via shortest path\\n        vector<long long> ways(n, 0);\\n        \\n        dist[0] = 0;\\n        ways[0] = 1;\\n        long long mod = 1000000007;\\n        \\n        while (!minheap.empty()) {\\n            // Get the current minimum time and node\\n            long long totalDist = minheap.top()[0];\\n            long long currentNode = minheap.top()[1];\\n            minheap.pop();\\n            \\n            // Check the neighbors and update dist value of the neighbors of the picked vertex\\n            for (vector<int> &neigh : graph[currentNode]) {\\n                // Relaxation, update the dist if neighbor is not visited and the new cost is smaller than the prev\\n                int neighbor = neigh[1];\\n                long long newDist = neigh[0] + totalDist;\\n                \\n                // Update the shortest path and ways\\n                if (newDist < dist[neighbor]) {\\n                    dist[neighbor] = newDist;\\n                    ways[neighbor] = ways[currentNode];\\n                    minheap.push({ dist[neighbor], neighbor });\\n                }\\n                \\n                // Another shortest path found, increment the ways to node_i\\n                else if (newDist == dist[neighbor]) {\\n                    ways[neighbor] = (ways[neighbor] + ways[currentNode]) % mod;\\n                }\\n            }\\n        }\\n        \\n        return ways[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // Build the weighted graph\\n        vector<vector<vector<int>>> graph(n);\\n        for (vector<int> &road : roads) {\\n            graph[road[0]].push_back({ road[2], road[1] }); // { time, node }\\n            graph[road[1]].push_back({ road[2], road[0] }); // { time, node }\\n        }\\n        \\n        // We will use a min-heap sorted by total time: { total time, node }\\n        priority_queue<vector<long long>, vector<vector<long long>>, greater<>> minheap;\\n        \\n        // Start with the initial node\\n        minheap.push({ 0, 0 }); // { time, node }\\n        \\n        // Distances table for Dijkstra, dist[i] gives the shortest path between src to node_i\\n        vector<long long> dist(n, LLONG_MAX);\\n        \\n        // Number of ways to reach a node via shortest path\\n        vector<long long> ways(n, 0);\\n        \\n        dist[0] = 0;\\n        ways[0] = 1;\\n        long long mod = 1000000007;\\n        \\n        while (!minheap.empty()) {\\n            // Get the current minimum time and node\\n            long long totalDist = minheap.top()[0];\\n            long long currentNode = minheap.top()[1];\\n            minheap.pop();\\n            \\n            // Optimization, we don\\'t need the distances greater than the one previously found \\n            if (totalDist > dist[currentNode]) {\\n                continue;\\n            }\\n            \\n            // Check the neighbors and update dist value of the neighbors of the picked vertex\\n            for (vector<int> &neigh : graph[currentNode]) {\\n                // Relaxation, update the dist if neighbor is not visited and the new cost is smaller than the prev\\n                int neighbor = neigh[1];\\n                long long newDist = neigh[0] + totalDist;\\n                \\n                // Update the shortest path and ways\\n                if (newDist < dist[neighbor]) {\\n                    dist[neighbor] = newDist;\\n                    ways[neighbor] = ways[currentNode];\\n                    minheap.push({ dist[neighbor], neighbor });\\n                }\\n                \\n                // Another shortest path found, increment the ways to node_i\\n                else if (newDist == dist[neighbor]) {\\n                    ways[neighbor] = (ways[neighbor] + ways[currentNode]) % mod;\\n                }\\n            }\\n        }\\n        \\n        return ways[n - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // Build the weighted graph\\n        vector<vector<vector<int>>> graph(n);\\n        for (vector<int> &road : roads) {\\n            graph[road[0]].push_back({ road[2], road[1] }); // { time, node }\\n            graph[road[1]].push_back({ road[2], road[0] }); // { time, node }\\n        }\\n        \\n        // We will use a min-heap sorted by total time: { total time, node }\\n        priority_queue<vector<long long>, vector<vector<long long>>, greater<>> minheap;\\n        \\n        // Start with the initial node\\n        minheap.push({ 0, 0 }); // { time, node }\\n        \\n        // Distances table for Dijkstra, dist[i] gives the shortest path between src to node_i\\n        vector<long long> dist(n, LLONG_MAX);\\n        \\n        // Number of ways to reach a node via shortest path\\n        vector<long long> ways(n, 0);\\n        \\n        dist[0] = 0;\\n        ways[0] = 1;\\n        long long mod = 1000000007;\\n        \\n        while (!minheap.empty()) {\\n            // Get the current minimum time and node\\n            long long totalDist = minheap.top()[0];\\n            long long currentNode = minheap.top()[1];\\n            minheap.pop();\\n            \\n            // Check the neighbors and update dist value of the neighbors of the picked vertex\\n            for (vector<int> &neigh : graph[currentNode]) {\\n                // Relaxation, update the dist if neighbor is not visited and the new cost is smaller than the prev\\n                int neighbor = neigh[1];\\n                long long newDist = neigh[0] + totalDist;\\n                \\n                // Update the shortest path and ways\\n                if (newDist < dist[neighbor]) {\\n                    dist[neighbor] = newDist;\\n                    ways[neighbor] = ways[currentNode];\\n                    minheap.push({ dist[neighbor], neighbor });\\n                }\\n                \\n                // Another shortest path found, increment the ways to node_i\\n                else if (newDist == dist[neighbor]) {\\n                    ways[neighbor] = (ways[neighbor] + ways[currentNode]) % mod;\\n                }\\n            }\\n        }\\n        \\n        return ways[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991740,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n];\\n        \\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>,\\n        greater<pair<long long, int>>> pq;\\n        vector<long long> dist(n, 1e18);\\n        vector<long long> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        int mod = (1e9 + 7);\\n        \\n        while(!pq.empty())\\n        {\\n            long long dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto it : adj[node])\\n            {\\n                long long edgeWeight = it.second;\\n                int adjNode = it.first;\\n                \\n                if(dis + edgeWeight < dist[adjNode])\\n                {\\n                    dist[adjNode] = dis + edgeWeight;\\n                    pq.push({dist[adjNode], adjNode});\\n                    ways[adjNode] = ways[node];\\n                }\\n                else if(dis + edgeWeight == dist[adjNode])\\n                {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n];\\n        \\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>,\\n        greater<pair<long long, int>>> pq;\\n        vector<long long> dist(n, 1e18);\\n        vector<long long> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        int mod = (1e9 + 7);\\n        \\n        while(!pq.empty())\\n        {\\n            long long dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto it : adj[node])\\n            {\\n                long long edgeWeight = it.second;\\n                int adjNode = it.first;\\n                \\n                if(dis + edgeWeight < dist[adjNode])\\n                {\\n                    dist[adjNode] = dis + edgeWeight;\\n                    pq.push({dist[adjNode], adjNode});\\n                    ways[adjNode] = ways[node];\\n                }\\n                else if(dis + edgeWeight == dist[adjNode])\\n                {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819573,
                "title": "c-dijkstra-algorithm-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe minimum cost can be found using Dijkstra Algorithm and we can use DP array to store the count value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> Use Dijkstra to find the shortest amount of time.\\n-> Use DP to keep states of shortest time fo a node (the count array)\\n-> while finding shortest time\\n-> when we find a shorter time we change dp by new value by the dp value of its parent (from where its coming from).\\n-> when we find equal time we add value to current node\\'s dp, i.e, adding the dp values of its parent or the adjacent where its coming from.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(E*log(N))\\nE --> number of edges\\nN --> number of vertices or nodes\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto it : roads)\\n        {\\n            int from = it[0];\\n            int to = it[1];\\n            int time = it[2];\\n            adj[from].push_back({to, time});\\n            adj[to].push_back({from, time});\\n        }\\n        long long mod = 1e9 + 7;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        vector<long long> dist(n, 1e15);\\n        vector<long long> count(n, 0);\\n        dist[0] = 0;\\n        count[0] = 1;\\n        while(pq.size())\\n        {\\n            long long timetaken = pq.top().first;\\n            int curr = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[curr])\\n            {\\n                int neigh = it.first;\\n                int traveltime = it.second;\\n                if(dist[neigh] == timetaken + traveltime)\\n                {\\n                    count[neigh] = (count[neigh] + count[curr]) % mod;\\n                }\\n                else if(dist[neigh] > timetaken + traveltime)\\n                {\\n                    dist[neigh] = timetaken + traveltime;\\n                    pq.push({dist[neigh], neigh});\\n                    count[neigh] = count[curr];\\n                }\\n            }\\n        }\\n        return count[n-1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto it : roads)\\n        {\\n            int from = it[0];\\n            int to = it[1];\\n            int time = it[2];\\n            adj[from].push_back({to, time});\\n            adj[to].push_back({from, time});\\n        }\\n        long long mod = 1e9 + 7;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        vector<long long> dist(n, 1e15);\\n        vector<long long> count(n, 0);\\n        dist[0] = 0;\\n        count[0] = 1;\\n        while(pq.size())\\n        {\\n            long long timetaken = pq.top().first;\\n            int curr = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[curr])\\n            {\\n                int neigh = it.first;\\n                int traveltime = it.second;\\n                if(dist[neigh] == timetaken + traveltime)\\n                {\\n                    count[neigh] = (count[neigh] + count[curr]) % mod;\\n                }\\n                else if(dist[neigh] > timetaken + traveltime)\\n                {\\n                    dist[neigh] = timetaken + traveltime;\\n                    pq.push({dist[neigh], neigh});\\n                    count[neigh] = count[curr];\\n                }\\n            }\\n        }\\n        return count[n-1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773602,
                "title": "easy-to-understand-c-solution-dijkstra",
                "content": "# Intuition\\nUse Dijkstra Algorithm to find the shortest distance between source node and destination node.Mean while maintain a seperate array/vector which takes a note of number of shortest path to that particular node.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExcept for maintaining the seperate array/vector for number of shortest ways every thing is similar as Dijkstra\\'s shortest path algo.\\n**\\nSo, For maintaining the seperate array/vector for number of shortest ways follow below instructions**:\\n1).If the no of shortest paths for particulr node is empty or we are going to add for the first time directly add the number of shortest path from the parent node.\\n**ways[adjNode]=ways[node]**\\n2).And if already there is already entry for shortest path for particualr node then add the number of shortest path from parent and the current number of the shortest path of the node.\\n** ways[adjNode]=(ways[adjNode]+ways[node])**\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(ElogV)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<long long>distance(n,1e15);\\n        vector<int>ways(n,0);\\n\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        distance[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty())\\n        {\\n            int node=pq.top().second;\\n            long long dis=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node])\\n            {\\n                int adjNode=it.first;\\n                long long edgeWght=it.second;\\n\\n                //New Entry\\n                if(dis+edgeWght<distance[adjNode])\\n                {\\n                    ways[adjNode]=ways[node];\\n                    distance[adjNode]=dis+edgeWght;\\n                    pq.push({dis+edgeWght,adjNode});\\n\\n                }\\n                else if(dis+edgeWght==distance[adjNode])\\n                {\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%((int)1e9+7);\\n                }\\n            }\\n        }\\n        return ways[n-1]%((int)1e9+7);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<long long>distance(n,1e15);\\n        vector<int>ways(n,0);\\n\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        distance[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty())\\n        {\\n            int node=pq.top().second;\\n            long long dis=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node])\\n            {\\n                int adjNode=it.first;\\n                long long edgeWght=it.second;\\n\\n                //New Entry\\n                if(dis+edgeWght<distance[adjNode])\\n                {\\n                    ways[adjNode]=ways[node];\\n                    distance[adjNode]=dis+edgeWght;\\n                    pq.push({dis+edgeWght,adjNode});\\n\\n                }\\n                else if(dis+edgeWght==distance[adjNode])\\n                {\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%((int)1e9+7);\\n                }\\n            }\\n        }\\n        return ways[n-1]%((int)1e9+7);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034488,
                "title": "java-dijkstra-s-algorithm-prorityqueue-with-explanation",
                "content": "\\tclass pair{\\n\\t\\tint node;\\n\\t\\tint value;\\n\\n\\t\\tpublic pair(int n, int v){\\n\\t\\t\\tthis.node=n;\\n\\t\\t\\tthis.value=v;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int countPaths(int n, int[][] roads) {\\n\\t\\t//Creating adj list\\n\\t\\t\\tArrayList<ArrayList<pair>> adj = new ArrayList<>();\\n\\t\\t\\tfor(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n\\t\\t\\tfor(int i=0;i<roads.length;i++){\\n\\t\\t\\t\\tadj.get(roads[i][0]).add(new pair(roads[i][1], roads[i][2]));\\n\\t\\t\\t\\t adj.get(roads[i][1]).add(new pair(roads[i][0], roads[i][2]));\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t// this will basically segregate all nodes in one place\\n\\t\\t\\t}\\n\\n\\t\\t\\tQueue<pair> q = new PriorityQueue<>((x,y)->x.value-y.value);\\n\\t\\t\\tint[] values = new int[n];\\n\\t\\t\\tint[] distance = new int[n];\\n\\t\\t\\tArrays.fill(values,Integer.MAX_VALUE);\\n\\t\\t\\tvalues[0]=0; // this will store all its min path distance\\n\\t\\t\\tdistance[0]=1; // this will store all the no.of ways passing through the current node;\\n\\t\\t\\tint mod = 1000000000+7;\\n\\n\\t\\t\\tq.offer(new pair(0,0));// pushin first node that is src node\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tint node = q.peek().node; // storing the values of first node so that we can add its children\\n\\t\\t\\t\\tint value = q.peek().value;\\n\\t\\t\\t\\tq.poll();\\n\\n\\t\\t\\t\\tfor(pair p:adj.get(node)){  // traversing through that node list to reach push it\\'s children having less distances\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint newnode = p.node;\\n\\t\\t\\t\\t\\tint newvalue = p.value;\\n\\n\\t\\t\\t\\t\\tif(value+newvalue < values[newnode]){ // will compare if this new path has less distance than the previous path distance\\n\\t\\t\\t\\t\\t\\tvalues[newnode] = value+newvalue;\\n\\t\\t\\t\\t\\t\\tdistance[newnode]=distance[node];\\n\\t\\t\\t\\t\\t\\tq.offer(new pair(newnode, values[newnode]));\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse if(value+newvalue == values[newnode]){ // checking if same value exist, if yes then we need to wo got another route to reach our destination\\n\\t\\t\\t\\t\\t\\tdistance[newnode]=(distance[newnode]+ distance[node])%mod; \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn distance[n-1]%mod; // they\\'ve mentioned to return the no.of ways so we\\'re returning that ways\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Do upvote if it helps :D",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int countPaths(int n, int[][] roads) {\\n\\t\\t//Creating adj list\\n\\t\\t\\tArrayList<ArrayList<pair>> adj = new ArrayList<>();\\n\\t\\t\\tfor(int i=0;i<n;i++)adj.add(new ArrayList<>());\\n\\t\\t\\tfor(int i=0;i<roads.length;i++){\\n\\t\\t\\t\\tadj.get(roads[i][0]).add(new pair(roads[i][1], roads[i][2]));\\n\\t\\t\\t\\t adj.get(roads[i][1]).add(new pair(roads[i][0], roads[i][2]));\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t// this will basically segregate all nodes in one place\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2321220,
                "title": "c-dijkstra-number-of-ways-to-arrive-at-destination",
                "content": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long> dist(n,1e18), path(n,0);\\n        vector<vector<pair<int,int>>> g(n);\\n        for(int i=0; i<roads.size(); i++){\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n\\n        }\\n        priority_queue<pair<long long,int>> pq;\\n        pq.push({0,0});\\n        dist[0]=0;\\n        path[0]=1;\\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            int node = cur.second;\\n            long long d = -cur.first;\\n            for(auto x: g[node]){\\n                if(dist[x.first]>d + x.second){\\n                    dist[x.first]=d+x.second;\\n                    pq.push({-dist[x.first],x.first});\\n                    path[x.first]=path[node];\\n                }else if(dist[x.first]==d+x.second){\\n                    path[x.first]= (path[x.first] + path[node]);\\n                    if(path[x.first]>=MOD) path[x.first]-=MOD;\\n                }\\n            }\\n        }\\n        \\n        return path[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long> dist(n,1e18), path(n,0);\\n        vector<vector<pair<int,int>>> g(n);\\n        for(int i=0; i<roads.size(); i++){\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n\\n        }\\n        priority_queue<pair<long long,int>> pq;\\n        pq.push({0,0});\\n        dist[0]=0;\\n        path[0]=1;\\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            int node = cur.second;\\n            long long d = -cur.first;\\n            for(auto x: g[node]){\\n                if(dist[x.first]>d + x.second){\\n                    dist[x.first]=d+x.second;\\n                    pq.push({-dist[x.first],x.first});\\n                    path[x.first]=path[node];\\n                }else if(dist[x.first]==d+x.second){\\n                    path[x.first]= (path[x.first] + path[node]);\\n                    if(path[x.first]>=MOD) path[x.first]-=MOD;\\n                }\\n            }\\n        }\\n        \\n        return path[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173049,
                "title": "c-dijkstra-bfs",
                "content": "**If Helpful Please Upvoke**\\n\\n```\\n#define ll long long\\nclass Solution{\\n    public:\\n        int mod = 1e9 + 7;\\n    int countPaths(int n, vector<vector < int>> &roads){\\n        priority_queue<pair<ll, ll>, vector< pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n        pq.push({ 0,0 });\\n        vector<ll> dist(n, LLONG_MAX);\\n        dist[0] = 0;\\n        vector<ll> ways(n, 0);\\n        ways[0] = 1;\\n\\n        vector<pair<ll, ll>> adj[n];\\n        for (auto &it: roads){\\n            adj[it[0]].push_back({ it[1],\\n                it[2] });\\n            adj[it[1]].push_back({ it[0],\\n                it[2] });\\n        }\\n            while (!pq.empty()){\\n                ll node = pq.top().second;\\n                ll dis = pq.top().first;\\n                   pq.pop();\\n                 for (auto it: adj[node]){\\n                    ll wt = it.second;\\n                    ll adjnode = it.first;\\n                    if (wt + dis < dist[adjnode]){\\n                        dist[adjnode] = wt + dis;\\n                        ways[adjnode] = ways[node];\\n                        pq.push({ dist[adjnode],\\n                            adjnode });\\n                    }\\n                    else if (wt + dis == dist[adjnode])\\n                    {\\n                        ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n                    }\\n                }\\n            }\\n\\n            return ways[n - 1];\\n        }\\n    };\\n```\\n\\n**If Helpful PLease Like Or Upvoke**",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution{\\n    public:\\n        int mod = 1e9 + 7;\\n    int countPaths(int n, vector<vector < int>> &roads){\\n        priority_queue<pair<ll, ll>, vector< pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n        pq.push({ 0,0 });\\n        vector<ll> dist(n, LLONG_MAX);\\n        dist[0] = 0;\\n        vector<ll> ways(n, 0);\\n        ways[0] = 1;\\n\\n        vector<pair<ll, ll>> adj[n];\\n        for (auto &it: roads){\\n            adj[it[0]].push_back({ it[1],\\n                it[2] });\\n            adj[it[1]].push_back({ it[0],\\n                it[2] });\\n        }\\n            while (!pq.empty()){\\n                ll node = pq.top().second;\\n                ll dis = pq.top().first;\\n                   pq.pop();\\n                 for (auto it: adj[node]){\\n                    ll wt = it.second;\\n                    ll adjnode = it.first;\\n                    if (wt + dis < dist[adjnode]){\\n                        dist[adjnode] = wt + dis;\\n                        ways[adjnode] = ways[node];\\n                        pq.push({ dist[adjnode],\\n                            adjnode });\\n                    }\\n                    else if (wt + dis == dist[adjnode])\\n                    {\\n                        ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n                    }\\n                }\\n            }\\n\\n            return ways[n - 1];\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950371,
                "title": "c-using-dikstra-toposort-dag-dp",
                "content": "```\\n#define ll long long int\\nconst ll M = 1e9 + 7;\\n#define MOD_ADD(a,b,m) ((a % m) + (b % m)) % m\\n\\nclass Solution {\\npublic:\\n    \\n    static bool compare(pair<ll,ll> a, pair<ll,ll> b)\\n    {\\n        return a.second > b.second; // min heap\\n    }\\n    \\n    vector<ll> dikstra(ll src, vector<vector<pair<ll,ll>>> &adj, ll n)\\n    {\\n        vector<ll> dis(n, 1e18); //1e18 is imp here\\n        vector<bool> vis(n, 0);\\n    \\n        priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, function<bool(pair<ll,ll>, pair<ll,ll>)>> Q(compare);\\n        \\n        Q.push({src, 0});\\n        \\n        while(!Q.empty())\\n        {\\n            pair<ll,ll> now = Q.top(); Q.pop();\\n            \\n            ll u = now.first;\\n            \\n            if(vis[u]) continue;\\n            vis[u] = 1;\\n            dis[u] = now.second;\\n            \\n            for(auto x : adj[u])\\n            {\\n                ll v = x.first;\\n                ll w = x.second;\\n                \\n                if(dis[v] > dis[u] + w)\\n                {\\n                    dis[v] = dis[u] + w;\\n                    Q.push({v, dis[v]});\\n                }\\n            }\\n        }\\n    \\n        return dis;\\n    }\\n    \\n    vector<ll> toposort(vector<vector<ll>> &adj, ll n)\\n    {\\n        vector<ll> ans;\\n        ll indegree[n]; memset(&indegree, 0x00, sizeof(indegree));\\n        for(int u = 0; u < n; u++)\\n        {\\n            for(auto v : adj[u])\\n                indegree[v]++;\\n        }\\n        \\n        \\n        queue<ll> q;\\n        for(int i = 0; i < n; i++) if(!indegree[i]) q.push(i);\\n        \\n        while(!q.empty())\\n        {\\n            ll u = q.front(); q.pop();\\n            ans.push_back(u);\\n            \\n            for(auto v : adj[u])\\n            {\\n                indegree[v]--;\\n                if(!indegree[v]) q.push(v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        vector<vector<pair<ll,ll>>> adj(n);\\n        for(auto e : roads)\\n        {\\n            adj[e[0]].push_back({e[1], e[2]});\\n            adj[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<ll> dis = dikstra(0, adj, n);\\n        \\n        vector<vector<ll>> DAG(n);\\n        for(auto e : roads)\\n        {\\n            ll u = e[0];\\n            ll v = e[1];\\n            ll w = e[2];\\n            \\n            if(dis[u] + w == dis[v])\\n            {\\n                //include this edge u -> v\\n                DAG[u].push_back(v);\\n            }\\n            else if(dis[v] + w == dis[u])\\n            {\\n                //include this edge v -> u\\n                DAG[v].push_back(u);\\n            }\\n        }\\n        \\n        vector<ll> topo = toposort(DAG, n);\\n        \\n        ll dp[n]; memset(&dp, 0x00, sizeof(dp));\\n        dp[n - 1] = 1;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ll u = topo[i];\\n            if(u == n - 1) continue;\\n            \\n            for(auto v : DAG[u]) dp[u] = MOD_ADD(dp[u], dp[v], M);\\n        }\\n        \\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\n#define ll long long int\\nconst ll M = 1e9 + 7;\\n#define MOD_ADD(a,b,m) ((a % m) + (b % m)) % m\\n\\nclass Solution {\\npublic:\\n    \\n    static bool compare(pair<ll,ll> a, pair<ll,ll> b)\\n    {\\n        return a.second > b.second; // min heap\\n    }\\n    \\n    vector<ll> dikstra(ll src, vector<vector<pair<ll,ll>>> &adj, ll n)\\n    {\\n        vector<ll> dis(n, 1e18); //1e18 is imp here\\n        vector<bool> vis(n, 0);\\n    \\n        priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, function<bool(pair<ll,ll>, pair<ll,ll>)>> Q(compare);\\n        \\n        Q.push({src, 0});\\n        \\n        while(!Q.empty())\\n        {\\n            pair<ll,ll> now = Q.top(); Q.pop();\\n            \\n            ll u = now.first;\\n            \\n            if(vis[u]) continue;\\n            vis[u] = 1;\\n            dis[u] = now.second;\\n            \\n            for(auto x : adj[u])\\n            {\\n                ll v = x.first;\\n                ll w = x.second;\\n                \\n                if(dis[v] > dis[u] + w)\\n                {\\n                    dis[v] = dis[u] + w;\\n                    Q.push({v, dis[v]});\\n                }\\n            }\\n        }\\n    \\n        return dis;\\n    }\\n    \\n    vector<ll> toposort(vector<vector<ll>> &adj, ll n)\\n    {\\n        vector<ll> ans;\\n        ll indegree[n]; memset(&indegree, 0x00, sizeof(indegree));\\n        for(int u = 0; u < n; u++)\\n        {\\n            for(auto v : adj[u])\\n                indegree[v]++;\\n        }\\n        \\n        \\n        queue<ll> q;\\n        for(int i = 0; i < n; i++) if(!indegree[i]) q.push(i);\\n        \\n        while(!q.empty())\\n        {\\n            ll u = q.front(); q.pop();\\n            ans.push_back(u);\\n            \\n            for(auto v : adj[u])\\n            {\\n                indegree[v]--;\\n                if(!indegree[v]) q.push(v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        vector<vector<pair<ll,ll>>> adj(n);\\n        for(auto e : roads)\\n        {\\n            adj[e[0]].push_back({e[1], e[2]});\\n            adj[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<ll> dis = dikstra(0, adj, n);\\n        \\n        vector<vector<ll>> DAG(n);\\n        for(auto e : roads)\\n        {\\n            ll u = e[0];\\n            ll v = e[1];\\n            ll w = e[2];\\n            \\n            if(dis[u] + w == dis[v])\\n            {\\n                //include this edge u -> v\\n                DAG[u].push_back(v);\\n            }\\n            else if(dis[v] + w == dis[u])\\n            {\\n                //include this edge v -> u\\n                DAG[v].push_back(u);\\n            }\\n        }\\n        \\n        vector<ll> topo = toposort(DAG, n);\\n        \\n        ll dp[n]; memset(&dp, 0x00, sizeof(dp));\\n        dp[n - 1] = 1;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ll u = topo[i];\\n            if(u == n - 1) continue;\\n            \\n            for(auto v : DAG[u]) dp[u] = MOD_ADD(dp[u], dp[v], M);\\n        }\\n        \\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758525,
                "title": "java-solution-using-dijkstra-algorithm",
                "content": "class Solution {\\n    \\n    private int dijkstra(int[][] roads,int n){\\n        long mod=(int)1e9+7;\\n\\t\\t//PriorityQueue is used for sorting by time\\n        Queue<long[]> pq = new PriorityQueue<>((l, r) -> Long.compare(l[1], r[1]));\\n        //Number of ways to reach a vertex from 0 in minimum time\\n\\t\\tlong[] ways=new long[n];\\n\\t\\t//Distance array to store the minimum time taken to reach a vertex\\n        long[] dist=new long[n];\\n\\t\\t//Filling dist array with infinite distance.\\n        Arrays.fill(dist,(long)1e18);\\n        dist[0]=0;\\n\\t\\t//Number of ways to reach 0 is 1.\\n        ways[0]=1;\\n\\t\\t//We have to form graph roads array.\\n        ArrayList<long[]>[] graph=new ArrayList[n];\\n        for(int i=0;i<graph.length;i++) graph[i]=new ArrayList<>();\\n        for(int[] road:roads){\\n            graph[road[0]].add(new long[]{road[1],road[2]});\\n            graph[road[1]].add(new long[]{road[0],road[2]});\\n        }\\n        pq.add(new long[]{0,0});\\n\\t\\t//Normal Dijkstra bfs is implemented.\\n\\t\\twhile(pq.size()>0){\\n            long[] ele=pq.remove();\\n            long dis=ele[1];\\n\\t\\t\\t//Node value we are on(Parent Node).\\n            long node=ele[0];\\n            for(long[] e:graph[(int)node]){\\n\\t\\t\\t//Adjancent Node weight from parent.\\n                long wt=e[1];\\n\\t\\t\\t//Adjacent Node to parent\\n                long adjNode=e[0];\\n\\t\\t\\t\\t//If the wt+dis (i.e time here) is less than already time taken then will update dist[(int)adjNode] and number of ways will be equal to ways[(int)node]\\n                if(wt+dis<dist[(int)adjNode]){\\n                    dist[(int)adjNode]=wt+dis;\\n                    ways[(int)adjNode]=ways[(int)node];\\n                    pq.add(new long[]{adjNode,dist[(int)adjNode]});\\n                }\\n\\t\\t\\t\\t//if wt+dis (i.e time here) is equal to already taken time then we will add it in ways array.\\n                else if(wt+dis==dist[(int)adjNode]){\\n                    ways[(int)adjNode]=(ways[(int)node]+ways[(int)adjNode])%mod;\\n                }\\n            }\\n        }\\n         return (int)ways[n-1];\\n    }\\n\\n    public int countPaths(int n, int[][] roads) {\\n        return dijkstra(roads,n);        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    private int dijkstra(int[][] roads,int n){\\n        long mod=(int)1e9+7;\\n\\t\\t//PriorityQueue is used for sorting by time\\n        Queue<long[]> pq = new PriorityQueue<>((l, r) -> Long.compare(l[1], r[1]));\\n        //Number of ways to reach a vertex from 0 in minimum time\\n\\t\\tlong[] ways=new long[n];\\n\\t\\t//Distance array to store the minimum time taken to reach a vertex\\n        long[] dist=new long[n];\\n\\t\\t//Filling dist array with infinite distance.\\n        Arrays.fill(dist,(long)1e18);\\n        dist[0]=0;\\n\\t\\t//Number of ways to reach 0 is 1.\\n        ways[0]=1;\\n\\t\\t//We have to form graph roads array.\\n        ArrayList<long[]>[] graph=new ArrayList[n];\\n        for(int i=0;i<graph.length;i++) graph[i]=new ArrayList<>();\\n        for(int[] road:roads){\\n            graph[road[0]].add(new long[]{road[1],road[2]}",
                "codeTag": "Java"
            },
            {
                "id": 1652268,
                "title": "c-dijkstra-clean-concise",
                "content": "```\\ntypedef long long ll;\\nconst ll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int m=roads.size();\\n        vector<vector<pair<int,int>>>v(n);\\n        for(auto x: roads){\\n            v[x[0]].push_back({x[1],x[2]});\\n            v[x[1]].push_back({x[0],x[2]});\\n        }\\n        vector<ll>dis(n,LLONG_MAX);\\n        vector<ll>path(n,0);\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        path[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<ll,ll>p=pq.top();\\n            pq.pop();\\n            for(auto x: v[p.second]){\\n                ll u=x.first;\\n                ll w=x.second;\\n                if(dis[u]>dis[p.second]+w){\\n                    dis[u]=dis[p.second]+w;\\n                    path[u]=path[p.second];\\n                    path[u]%=mod;\\n                    pq.push({dis[u],u});\\n                }\\n                else if(dis[u]==p.first+w){\\n                    path[u]+=path[p.second];\\n                    path[u]%=mod;\\n                }\\n            }\\n        }\\n        return path[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nconst ll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int m=roads.size();\\n        vector<vector<pair<int,int>>>v(n);\\n        for(auto x: roads){\\n            v[x[0]].push_back({x[1],x[2]});\\n            v[x[1]].push_back({x[0],x[2]});\\n        }\\n        vector<ll>dis(n,LLONG_MAX);\\n        vector<ll>path(n,0);\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        path[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<ll,ll>p=pq.top();\\n            pq.pop();\\n            for(auto x: v[p.second]){\\n                ll u=x.first;\\n                ll w=x.second;\\n                if(dis[u]>dis[p.second]+w){\\n                    dis[u]=dis[p.second]+w;\\n                    path[u]=path[p.second];\\n                    path[u]%=mod;\\n                    pq.push({dis[u],u});\\n                }\\n                else if(dis[u]==p.first+w){\\n                    path[u]+=path[p.second];\\n                    path[u]%=mod;\\n                }\\n            }\\n        }\\n        return path[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426837,
                "title": "java-solution-using-dijkstra-and-dp",
                "content": "The basic idea is to dijkstra algorithm and find the minimum path from 0 to (n - 1). The catch is that while traversing from one node to another if we encounter a node with more distance then we will initialise the number of ways to reach that node. Similarly, if we encounter a node with same distance as of previous count then we will increment the number of ways to reach that node by its count of previous node. In the end, we will return the number of ways to reach the (n - 1)th node. Hope this solution helps.\\n```\\nclass Solution {\\n    class Pair{\\n        int node;\\n        int dist;\\n        Pair(int node , int dist){\\n            this.node = node;\\n            this.dist = dist;\\n        }\\n    }\\n    public int countPaths(int n, int[][] roads) {\\n        int mod = (int)Math.pow(10 , 9) + 7;\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        int rows = roads.length;\\n        for(int i = 0 ; i < n ; i++)\\n            adj.add(new ArrayList<Pair>());\\n        for(int i = 0 ; i < rows ; i++){\\n            int from = roads[i][0];\\n            int to = roads[i][1];\\n            int dis = roads[i][2];\\n            adj.get(from).add(new Pair(to , dis));\\n            adj.get(to).add(new Pair(from , dis));\\n        }\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((aa , bb) -> aa.dist - bb.dist);\\n        pq.add(new Pair(0 , 0));\\n        long[] ways = new long[n];\\n        ways[0] = 1;\\n        int[] dist = new int[n];\\n        Arrays.fill(dist , Integer.MAX_VALUE);\\n        dist[0] = 0;\\n        while(!pq.isEmpty()){\\n            Pair p = pq.remove();\\n            int node = p.node;\\n            int dis = p.dist;\\n            for(Pair pa : adj.get(node)){\\n                if((dis + pa.dist) < dist[pa.node]){\\n                    ways[pa.node] = ways[node];\\n                    dist[pa.node] = dis + pa.dist;\\n                    pq.add(new Pair(pa.node , dist[pa.node]));\\n                }\\n                else if((dis + pa.dist) == dist[pa.node]){\\n                    ways[pa.node] += ways[node];\\n                    ways[pa.node] = ways[pa.node] % mod;\\n                }\\n            }\\n        }\\n        return (int)ways[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int node;\\n        int dist;\\n        Pair(int node , int dist){\\n            this.node = node;\\n            this.dist = dist;\\n        }\\n    }\\n    public int countPaths(int n, int[][] roads) {\\n        int mod = (int)Math.pow(10 , 9) + 7;\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        int rows = roads.length;\\n        for(int i = 0 ; i < n ; i++)\\n            adj.add(new ArrayList<Pair>());\\n        for(int i = 0 ; i < rows ; i++){\\n            int from = roads[i][0];\\n            int to = roads[i][1];\\n            int dis = roads[i][2];\\n            adj.get(from).add(new Pair(to , dis));\\n            adj.get(to).add(new Pair(from , dis));\\n        }\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((aa , bb) -> aa.dist - bb.dist);\\n        pq.add(new Pair(0 , 0));\\n        long[] ways = new long[n];\\n        ways[0] = 1;\\n        int[] dist = new int[n];\\n        Arrays.fill(dist , Integer.MAX_VALUE);\\n        dist[0] = 0;\\n        while(!pq.isEmpty()){\\n            Pair p = pq.remove();\\n            int node = p.node;\\n            int dis = p.dist;\\n            for(Pair pa : adj.get(node)){\\n                if((dis + pa.dist) < dist[pa.node]){\\n                    ways[pa.node] = ways[node];\\n                    dist[pa.node] = dis + pa.dist;\\n                    pq.add(new Pair(pa.node , dist[pa.node]));\\n                }\\n                else if((dis + pa.dist) == dist[pa.node]){\\n                    ways[pa.node] += ways[node];\\n                    ways[pa.node] = ways[pa.node] % mod;\\n                }\\n            }\\n        }\\n        return (int)ways[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418253,
                "title": "javascript-dijkstra-132ms",
                "content": "```\\nconst mod = 1e9 + 7;\\nconst countPaths = (n, road) => {\\n    let adj = initializeGraph(n);\\n    for (const [u, v, cost] of road) {\\n        adj[u].push([v, cost]);\\n        adj[v].push([u, cost]);\\n    }\\n    return dijkstra(n, adj, 0);\\n};\\n\\nconst dijkstra = (n, g, source) => { // g: adjacent graph list, n: total vertices\\n    let dist = Array(n).fill(Number.MAX_SAFE_INTEGER);\\n    let ways = Array(n).fill(0);\\n    const pq = new MinPriorityQueue({ priority: x => x[0] * 200 + x[1] });\\n    dist[0] = 0;\\n    ways[0] = 1;\\n    pq.enqueue([0, source]);\\n    while (pq.size()) {\\n        let cur = pq.dequeue().element;\\n        let [curCost, curNode] = cur;\\n        if (dist[curNode] != curCost) continue;\\n        for (const [node, cost] of g[curNode]) { // parse neighbour node\\n            let newDis = curCost + cost;\\n            if (newDis == dist[node]) {\\n                ways[node] += ways[curNode];\\n                ways[node] %= mod;\\n            } else if (newDis < dist[node]) {\\n                dist[node] = newDis;\\n                ways[node] = ways[curNode];\\n                pq.enqueue([dist[node], node]);\\n            }\\n        }\\n    }\\n    return ways[n - 1];\\n};\\n\\nconst initializeGraph = (n) => { let G = []; for (let i = 0; i < n; i++) { G.push([]); } return G; };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mod = 1e9 + 7;\\nconst countPaths = (n, road) => {\\n    let adj = initializeGraph(n);\\n    for (const [u, v, cost] of road) {\\n        adj[u].push([v, cost]);\\n        adj[v].push([u, cost]);\\n    }\\n    return dijkstra(n, adj, 0);\\n};\\n\\nconst dijkstra = (n, g, source) => { // g: adjacent graph list, n: total vertices\\n    let dist = Array(n).fill(Number.MAX_SAFE_INTEGER);\\n    let ways = Array(n).fill(0);\\n    const pq = new MinPriorityQueue({ priority: x => x[0] * 200 + x[1] });\\n    dist[0] = 0;\\n    ways[0] = 1;\\n    pq.enqueue([0, source]);\\n    while (pq.size()) {\\n        let cur = pq.dequeue().element;\\n        let [curCost, curNode] = cur;\\n        if (dist[curNode] != curCost) continue;\\n        for (const [node, cost] of g[curNode]) { // parse neighbour node\\n            let newDis = curCost + cost;\\n            if (newDis == dist[node]) {\\n                ways[node] += ways[curNode];\\n                ways[node] %= mod;\\n            } else if (newDis < dist[node]) {\\n                dist[node] = newDis;\\n                ways[node] = ways[curNode];\\n                pq.enqueue([dist[node], node]);\\n            }\\n        }\\n    }\\n    return ways[n - 1];\\n};\\n\\nconst initializeGraph = (n) => { let G = []; for (let i = 0; i < n; i++) { G.push([]); } return G; };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1417966,
                "title": "java-faster-than-100-10ms-through-dijkstra-with-array-for-queue",
                "content": "Since Java\\'s PriorityQueue doesn\\'t handle \"decreaseKey\" operation, if you use it you will have several times the same node in the queue. The algo still works but it\\'s slower because of the duplicated elements in the queue. You can still implement your own queue manually though.\\n\\nYou can also use an array to represent the queue and look for the minimum each time. You will have to be sure to skip the visited nodes though.\\n\\n```\\nclass Solution {\\n    public static final long MODULO = 1_000_000_007;\\n\\n    public int countPaths(int n, int[][] roads) {\\n        long[] distances = new long[n];\\n        Arrays.fill(distances, Long.MAX_VALUE);\\n        distances[0] = 0;\\n        Set<Integer> visited = new HashSet<Integer>();\\n        long[] counts = new long[n];\\n        counts[0] = 1;\\n        List<Integer>[] neighbors = new List[n];\\n        for(int i =0; i< n; i++){\\n            neighbors[i] = new ArrayList<>();\\n        }\\n\\n        long[][] weights = new long[n][n];\\n        for (int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            weights[u][v] = road[2];\\n            weights[v][u] = road[2];\\n            neighbors[u].add(v);\\n            neighbors[v].add(u);\\n        }\\n\\n\\n        while(visited.size() < n){\\n            int u = findMin(distances, visited);\\n            if(u == n-1) return (int) counts[n-1]; // destination has the smallest distance, there is no way to find a shorter path\\n            long du = distances[u];\\n            for(int v : neighbors[u]){\\n                if(add(du, weights[u][v]) < distances[v]){\\n                    distances[v] = du +  weights[u][v];\\n                    counts[v] = counts[u];\\n                } else if(add(du, weights[u][v]) == distances[v]){\\n                    counts[v] = (counts[v] +counts[u]) % MODULO;\\n                }\\n            }\\n\\n            visited.add(u);\\n        }\\n\\n        throw new IllegalStateException(); // no path from source to destination, shouldn\\'t happen due to the problem constraints\\n    }\\n\\n    private int findMin(long[] array, Set<Integer> visited){\\n        long min = Long.MAX_VALUE;\\n        int index = -1;\\n        for(int i =0; i< array.length; i++){\\n            if(!visited.contains(i) && array[i] < min){\\n                min = array[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    // take care of overflows\\n    private static long add(long a, long b){\\n        return a ==  Long.MAX_VALUE || b == Long.MAX_VALUE ? Long.MAX_VALUE : a + b;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static final long MODULO = 1_000_000_007;\\n\\n    public int countPaths(int n, int[][] roads) {\\n        long[] distances = new long[n];\\n        Arrays.fill(distances, Long.MAX_VALUE);\\n        distances[0] = 0;\\n        Set<Integer> visited = new HashSet<Integer>();\\n        long[] counts = new long[n];\\n        counts[0] = 1;\\n        List<Integer>[] neighbors = new List[n];\\n        for(int i =0; i< n; i++){\\n            neighbors[i] = new ArrayList<>();\\n        }\\n\\n        long[][] weights = new long[n][n];\\n        for (int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            weights[u][v] = road[2];\\n            weights[v][u] = road[2];\\n            neighbors[u].add(v);\\n            neighbors[v].add(u);\\n        }\\n\\n\\n        while(visited.size() < n){\\n            int u = findMin(distances, visited);\\n            if(u == n-1) return (int) counts[n-1]; // destination has the smallest distance, there is no way to find a shorter path\\n            long du = distances[u];\\n            for(int v : neighbors[u]){\\n                if(add(du, weights[u][v]) < distances[v]){\\n                    distances[v] = du +  weights[u][v];\\n                    counts[v] = counts[u];\\n                } else if(add(du, weights[u][v]) == distances[v]){\\n                    counts[v] = (counts[v] +counts[u]) % MODULO;\\n                }\\n            }\\n\\n            visited.add(u);\\n        }\\n\\n        throw new IllegalStateException(); // no path from source to destination, shouldn\\'t happen due to the problem constraints\\n    }\\n\\n    private int findMin(long[] array, Set<Integer> visited){\\n        long min = Long.MAX_VALUE;\\n        int index = -1;\\n        for(int i =0; i< array.length; i++){\\n            if(!visited.contains(i) && array[i] < min){\\n                min = array[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    // take care of overflows\\n    private static long add(long a, long b){\\n        return a ==  Long.MAX_VALUE || b == Long.MAX_VALUE ? Long.MAX_VALUE : a + b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417758,
                "title": "simple-python-solution-dijkstra-algo",
                "content": "\\'\\'\\'\\n\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        \\n\\t\\t//creating adgecency matrix\\n        mat = [[0] * n for _ in range(n)]\\n        for i,j,k in roads:\\n            mat[i][j]= mat[j][i] = k\\n       \\n\\t\\t// An array for keeping track of distance of last node from each node\\n        d = [float(\\'inf\\')] * (n)\\n        d[-1] = 0\\n \\t\\t\\n\\t\\t//count matrix for counting the no of paths from each node\\n        c = [1] * n\\n\\t\\t\\n        for i in reversed(range(n-1)):\\n            incount = 0\\n            for j in range(i,n):\\n                if mat[i][j] > 0:\\n                    if mat[i][j] + d[j] < d[i]:\\n\\t\\t\\t\\t\\t\\t//updating the distace of ith node\\n                        d[i] = mat[i][j] + d[j]\\n\\t\\t\\t\\t\\t\\t//initializing the incount by the no of paths from node j\\n                        incount =  c[j]\\n\\t\\t\\t\\t\\t\\t\\n                    elif mat[i][j] + d[j] == d[i]:\\n\\t\\t\\t\\t\\t\\t//updating the value of incount for samllest distance\\n                        incount +=  c[j]\\n            \\n\\t\\t\\tc[i] = incount\\n\\t\\t\\t\\n        return c[0] % 1000000007\\n            \\n                \\n        \\n\\n        \\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\n\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        \\n\\t\\t//creating adgecency matrix\\n        mat = [[0] * n for _ in range(n)]\\n        for i,j,k in roads:\\n            mat[i][j]= mat[j][i] = k\\n       \\n\\t\\t// An array for keeping track of distance of last node from each node\\n        d = [float(\\'inf\\')] * (n)\\n        d[-1] = 0\\n \\t\\t\\n\\t\\t//count matrix for counting the no of paths from each node\\n        c = [1] * n\\n\\t\\t\\n        for i in reversed(range(n-1)):\\n            incount = 0\\n            for j in range(i,n):\\n                if mat[i][j] > 0:\\n                    if mat[i][j] + d[j] < d[i]:\\n\\t\\t\\t\\t\\t\\t//updating the distace of ith node\\n                        d[i] = mat[i][j] + d[j]\\n\\t\\t\\t\\t\\t\\t//initializing the incount by the no of paths from node j\\n                        incount =  c[j]\\n\\t\\t\\t\\t\\t\\t\\n                    elif mat[i][j] + d[j] == d[i]:\\n\\t\\t\\t\\t\\t\\t//updating the value of incount for samllest distance\\n                        incount +=  c[j]\\n            \\n\\t\\t\\tc[i] = incount\\n\\t\\t\\t\\n        return c[0] % 1000000007\\n            \\n                \\n        \\n\\n        \\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1417622,
                "title": "dijkstra-algorithm-c",
                "content": "We may use here Dijkstra algorithm with small modification. \\nLet\\'s use additional array numWays, where numWays[i] - number of shortest paths from 0 to i vertex. \\nWhen we update distance from current vertex to neighbors, we should check two situations:\\n\\t1. distance to u + w(u, v) < distance to v. Update distance, and update numWays.\\n\\t2. distance to u + w(u, v) == distance to v. Add numWays[v] to numWays[u].\\n```\\nclass Solution {\\nprivate:\\n    typedef long long ll;\\n    const int MOD = 1E9 + 7;\\n    \\n    int dijkstra(const vector<vector<pair<int, ll>>>& adj){\\n        set<pair<ll, int>> pq;\\n        int n = adj.size();\\n        vector<ll> numWays(n, 1), dist(n, LLONG_MAX);\\n        dist[0] = 0;\\n        for (int i = 0; i < n; ++i){\\n            pq.insert({dist[i], i});\\n        }\\n        \\n        while (!pq.empty()){\\n            int u = pq.begin()->second;\\n            ll uDist = pq.begin()->first;\\n            pq.erase(pq.begin());\\n            for (auto [v, w]: adj[u]){\\n                ll vDist = dist[v], newDist = uDist + w;\\n                if (vDist > newDist){\\n                    pq.erase({vDist, v});\\n                    pq.insert({newDist, v});\\n                    dist[v] = newDist;\\n                    numWays[v] = numWays[u];\\n                } else if (vDist == newDist){\\n                    numWays[v] = (numWays[v] + numWays[u]) % MOD;\\n                }\\n            }\\n        }\\n        return numWays[n - 1];\\n    }\\n    \\n    \\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, ll>>> adj(n);\\n        for (auto road: roads){\\n            adj[road[0]].push_back({road[1], ll(road[2])});\\n            adj[road[1]].push_back({road[0], ll(road[2])});\\n        }\\n        return dijkstra(adj);\\n    }\\n};\\n```\\n\\n**Time complexity**: O(ElogV + VlogV) \\n**Space complexity**: O(V + E)\\nV - number of vertices, E - number of edges.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    typedef long long ll;\\n    const int MOD = 1E9 + 7;\\n    \\n    int dijkstra(const vector<vector<pair<int, ll>>>& adj){\\n        set<pair<ll, int>> pq;\\n        int n = adj.size();\\n        vector<ll> numWays(n, 1), dist(n, LLONG_MAX);\\n        dist[0] = 0;\\n        for (int i = 0; i < n; ++i){\\n            pq.insert({dist[i], i});\\n        }\\n        \\n        while (!pq.empty()){\\n            int u = pq.begin()->second;\\n            ll uDist = pq.begin()->first;\\n            pq.erase(pq.begin());\\n            for (auto [v, w]: adj[u]){\\n                ll vDist = dist[v], newDist = uDist + w;\\n                if (vDist > newDist){\\n                    pq.erase({vDist, v});\\n                    pq.insert({newDist, v});\\n                    dist[v] = newDist;\\n                    numWays[v] = numWays[u];\\n                } else if (vDist == newDist){\\n                    numWays[v] = (numWays[v] + numWays[u]) % MOD;\\n                }\\n            }\\n        }\\n        return numWays[n - 1];\\n    }\\n    \\n    \\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, ll>>> adj(n);\\n        for (auto road: roads){\\n            adj[road[0]].push_back({road[1], ll(road[2])});\\n            adj[road[1]].push_back({road[0], ll(road[2])});\\n        }\\n        return dijkstra(adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417577,
                "title": "java-priority-queue",
                "content": "```\\npublic int countPaths(int n, int[][] roads) {\\n        long [][]dp = new long[n][2];\\n        ArrayList<long []> []graph = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i] = new ArrayList();\\n        }\\n        for(int []road: roads){\\n            int src = road[0];\\n            int dest = road[1];\\n            int dist = road[2];\\n            graph[src].add(new long[]{dest, dist});\\n            graph[dest].add(new long []{src, dist});\\n        }\\n        PriorityQueue<long []> pq = new PriorityQueue<long []>((a,b) -> Long.compare(a[2], b[2]));\\n        for(int i=1;i<n;i++){\\n            dp[i][0] = Long.MAX_VALUE;\\n        }\\n        dp[0][1] = 1;\\n        for(int i=0;i<graph[0].size();i++){\\n            long []tmp = graph[0].get(i);\\n            pq.add(new long[]{0, tmp[0], tmp[1]});\\n        }\\n        long mod = 1000000007;\\n        while(pq.size() > 0){\\n            long []poll = pq.poll();\\n            int src = (int)poll[0];\\n            int dest = (int)poll[1];\\n            long dist = poll[2];\\n            if(dist <= dp[dest][0]){\\n                dp[dest][1] = (dp[dest][1] + dp[src][1])%mod;\\n            }\\n            if(dist < dp[dest][0]){\\n                dp[dest][0] = dist;\\n                for(int i=0;i<graph[dest].size();i++){\\n                    long []tmp = graph[dest].get(i);\\n                    pq.add(new long[]{dest, tmp[0], tmp[1] + dp[dest][0]});\\n                }\\n            }\\n        }\\n        return (int)(dp[n-1][1] % mod);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countPaths(int n, int[][] roads) {\\n        long [][]dp = new long[n][2];\\n        ArrayList<long []> []graph = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i] = new ArrayList();\\n        }\\n        for(int []road: roads){\\n            int src = road[0];\\n            int dest = road[1];\\n            int dist = road[2];\\n            graph[src].add(new long[]{dest, dist});\\n            graph[dest].add(new long []{src, dist});\\n        }\\n        PriorityQueue<long []> pq = new PriorityQueue<long []>((a,b) -> Long.compare(a[2], b[2]));\\n        for(int i=1;i<n;i++){\\n            dp[i][0] = Long.MAX_VALUE;\\n        }\\n        dp[0][1] = 1;\\n        for(int i=0;i<graph[0].size();i++){\\n            long []tmp = graph[0].get(i);\\n            pq.add(new long[]{0, tmp[0], tmp[1]});\\n        }\\n        long mod = 1000000007;\\n        while(pq.size() > 0){\\n            long []poll = pq.poll();\\n            int src = (int)poll[0];\\n            int dest = (int)poll[1];\\n            long dist = poll[2];\\n            if(dist <= dp[dest][0]){\\n                dp[dest][1] = (dp[dest][1] + dp[src][1])%mod;\\n            }\\n            if(dist < dp[dest][0]){\\n                dp[dest][0] = dist;\\n                for(int i=0;i<graph[dest].size();i++){\\n                    long []tmp = graph[dest].get(i);\\n                    pq.add(new long[]{dest, tmp[0], tmp[1] + dp[dest][0]});\\n                }\\n            }\\n        }\\n        return (int)(dp[n-1][1] % mod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979418,
                "title": "java-step-by-step-explained-simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(m + n log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(m + n)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/b3cedf6e-69d2-4339-a4a6-29d2bb7c8243_1693378471.3360426.png)\\n\\n\\n# Code\\n```\\nclass Pair {\\n    long first;\\n    long second;\\n\\n    Pair(long first, long second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n        \\n        // Create an adjacency list to represent the graph\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n\\n        // Initialize the adjacency list\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        int m = roads.length;\\n\\n        // Populate the adjacency list with road information\\n        for (int i = 0; i < m; i++) {\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1], roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0], roads[i][2]));\\n        }\\n\\n        // Create a priority queue for Dijkstra\\'s algorithm\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((Pair1, Pair2) -> Long.compare(Pair1.first, Pair2.first));\\n\\n        // Initialize arrays for distances and ways\\n        long dist[] = new long[n];\\n        long ways[] = new long[n];\\n        long mod = (int)(1e9 + 7);\\n\\n        // Initialize distance and ways arrays\\n        for (int i = 0; i < n; i++) {\\n            dist[i] = Long.MAX_VALUE;\\n            ways[i] = 0;\\n        }\\n\\n        // Starting node has distance 0 and one way to reach it\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        pq.add(new Pair(0, 0));\\n\\n        while (pq.size() != 0) {\\n            long dis = pq.peek().first;\\n            long node = pq.peek().second;\\n            pq.remove();\\n\\n            // Explore neighboring nodes\\n            for (Pair it : adj.get((int) node)) {\\n                long adjNode = it.first;\\n                long edW = it.second;\\n\\n                // If a shorter path is found, update distance and ways\\n                if (dis + edW < dist[(int) adjNode]) {\\n                    dist[(int) adjNode] = dis + edW;\\n                    pq.add(new Pair(dis + edW, adjNode));\\n                    ways[(int) adjNode] = ways[(int) node];\\n                } else if (dis + edW == dist[(int) adjNode]) {\\n                    // If multiple paths with the same length are found, add their ways\\n                    ways[(int) adjNode] = (ways[(int) adjNode] + ways[(int) node]) % mod;\\n                }\\n            }\\n        }\\n\\n        // Return the number of ways to reach the last node modulo mod\\n        return (int)(ways[n - 1] % mod);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Pair {\\n    long first;\\n    long second;\\n\\n    Pair(long first, long second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n        \\n        // Create an adjacency list to represent the graph\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n\\n        // Initialize the adjacency list\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        int m = roads.length;\\n\\n        // Populate the adjacency list with road information\\n        for (int i = 0; i < m; i++) {\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1], roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0], roads[i][2]));\\n        }\\n\\n        // Create a priority queue for Dijkstra\\'s algorithm\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((Pair1, Pair2) -> Long.compare(Pair1.first, Pair2.first));\\n\\n        // Initialize arrays for distances and ways\\n        long dist[] = new long[n];\\n        long ways[] = new long[n];\\n        long mod = (int)(1e9 + 7);\\n\\n        // Initialize distance and ways arrays\\n        for (int i = 0; i < n; i++) {\\n            dist[i] = Long.MAX_VALUE;\\n            ways[i] = 0;\\n        }\\n\\n        // Starting node has distance 0 and one way to reach it\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        pq.add(new Pair(0, 0));\\n\\n        while (pq.size() != 0) {\\n            long dis = pq.peek().first;\\n            long node = pq.peek().second;\\n            pq.remove();\\n\\n            // Explore neighboring nodes\\n            for (Pair it : adj.get((int) node)) {\\n                long adjNode = it.first;\\n                long edW = it.second;\\n\\n                // If a shorter path is found, update distance and ways\\n                if (dis + edW < dist[(int) adjNode]) {\\n                    dist[(int) adjNode] = dis + edW;\\n                    pq.add(new Pair(dis + edW, adjNode));\\n                    ways[(int) adjNode] = ways[(int) node];\\n                } else if (dis + edW == dist[(int) adjNode]) {\\n                    // If multiple paths with the same length are found, add their ways\\n                    ways[(int) adjNode] = (ways[(int) adjNode] + ways[(int) node]) % mod;\\n                }\\n            }\\n        }\\n\\n        // Return the number of ways to reach the last node modulo mod\\n        return (int)(ways[n - 1] % mod);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559091,
                "title": "c-bfs-dijkastra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<long long,long long>>adj[n];\\n        \\n        for(auto it: roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        \\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>pq;\\n    \\n        vector<long long> dist(n,LONG_MAX),ways(n,0);\\n        dist[0]=0;\\n        ways[0]=1;\\n        int mod=(1e9 +7);\\n        pq.push({0,0});\\n        while(!pq.empty())\\n        {\\n          long long d=pq.top().first;\\n          long long int node=pq.top().second;\\n          pq.pop();\\n          for(auto it:adj[node])\\n          {\\n              long long adjnode=it.first;\\n              long long int edgwt=it.second;\\n      //this is the first time i have entered with short distance \\n              if((d+edgwt)<dist[adjnode])\\n              {\\n                  dist[adjnode]=d+edgwt;\\n                  ways[adjnode]=ways[node];\\n                  pq.push({dist[adjnode],adjnode});\\n              } else if((d+edgwt)==dist[adjnode])\\n              {\\n                   ways[adjnode]=((ways[adjnode]%mod + ways[node])%mod)%mod;\\n              }\\n          }\\n         \\n        }\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<long long,long long>>adj[n];\\n        \\n        for(auto it: roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        \\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>pq;\\n    \\n        vector<long long> dist(n,LONG_MAX),ways(n,0);\\n        dist[0]=0;\\n        ways[0]=1;\\n        int mod=(1e9 +7);\\n        pq.push({0,0});\\n        while(!pq.empty())\\n        {\\n          long long d=pq.top().first;\\n          long long int node=pq.top().second;\\n          pq.pop();\\n          for(auto it:adj[node])\\n          {\\n              long long adjnode=it.first;\\n              long long int edgwt=it.second;\\n      //this is the first time i have entered with short distance \\n              if((d+edgwt)<dist[adjnode])\\n              {\\n                  dist[adjnode]=d+edgwt;\\n                  ways[adjnode]=ways[node];\\n                  pq.push({dist[adjnode],adjnode});\\n              } else if((d+edgwt)==dist[adjnode])\\n              {\\n                   ways[adjnode]=((ways[adjnode]%mod + ways[node])%mod)%mod;\\n              }\\n          }\\n         \\n        }\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444932,
                "title": "python-96-60-faster-easy-dijkstra-s",
                "content": "```\\ndef countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[[] for i in range(n)]\\n        for u,v,t in roads:\\n            adj[u].append((v,t))\\n            adj[v].append((u,t))\\n        dist=[float(\\'inf\\')]*n\\n        ways=[0]*n\\n        ways[0]=1\\n        dist[0]=0\\n        pq=[]\\n        heapify(pq)\\n        heappush(pq,(0,0))\\n        mod=10**9+7\\n        while pq:\\n            time,node=heappop(pq)\\n            for v,t in adj[node]:\\n                if dist[v]>t+time:\\n                    dist[v]=t+time\\n                    heappush(pq,(dist[v],v))\\n                    ways[v]=ways[node]\\n                elif dist[v]==t+time:\\n                    ways[v]=(ways[v]+ways[node])%mod\\n        return ways[n-1]%mod\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\ndef countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[[] for i in range(n)]\\n        for u,v,t in roads:\\n            adj[u].append((v,t))\\n            adj[v].append((u,t))\\n        dist=[float(\\'inf\\')]*n\\n        ways=[0]*n\\n        ways[0]=1\\n        dist[0]=0\\n        pq=[]\\n        heapify(pq)\\n        heappush(pq,(0,0))\\n        mod=10**9+7\\n        while pq:\\n            time,node=heappop(pq)\\n            for v,t in adj[node]:\\n                if dist[v]>t+time:\\n                    dist[v]=t+time\\n                    heappush(pq,(dist[v],v))\\n                    ways[v]=ways[node]\\n                elif dist[v]==t+time:\\n                    ways[v]=(ways[v]+ways[node])%mod\\n        return ways[n-1]%mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3025874,
                "title": "c-using-priority-queue-and-set-2-approaches-highly-commented",
                "content": "**Using Priority Queue**\\n```cpp\\nclass Solution {\\npublic:\\n    /*\\n        Approach: We will use the dijsktra algorithm to find out the shortest distance then calculate number of ways you can arrive at your destination in the shortest time. Take distance as long long\\n        1. Using a Priority Queue\\n        2. Using a Set\\n        3. Using a queue (not preferred)\\n    */\\n    #define P pair<long long,long long> \\n    long long mod = 1e9 + 7;\\n    int dijkstra(vector<pair<int, int>> adj[], int n) {\\n        // Priority queue for relaxing nodes (distance, nodes)\\n        priority_queue<P, vector<P>, greater<P>> pq;\\n        \\n        // Distance vector\\n        vector<long long>distance(n, 1e15), path(n, 0);\\n        distance[0] = 0;\\n        pq.push({0, 0});\\n        path[0] = 1;\\n\\n        while(!pq.empty()){\\n            int node = pq.top().second;\\n            long long dist = pq.top().first;\\n            pq.pop();\\n            \\n            for(auto it : adj[node]){\\n                int adjNode = it.first;\\n                long long edgeW = it.second;\\n                \\n                if(dist + edgeW < distance[adjNode]){\\n                    // Relax\\n                    distance[adjNode] = dist + edgeW;\\n                    path[adjNode] = path[node];\\n                    pq.push({distance[adjNode], adjNode});\\n                }else if(dist + edgeW == distance[adjNode]){\\n                    // Node is already visited with the shortes path, sum of parent and the current node path\\n                    path[adjNode] = (1LL*path[node] + 1LL*path[adjNode]) % mod;\\n                }\\n            }\\n        }\\n        return path[n - 1];\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        \\n         // First step for grpah question is to create the adjacency list\\n        vector<pair<int, int>> adj[n];\\n\\n        // Graph Creation\\n        for (auto &v : roads) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n            adj[v[1]].push_back({v[0], v[2]});\\n        }\\n        \\n        return dijkstra(adj, n);\\n    }\\n};\\n```\\n**Using Set**\\n```cpp\\nclass Solution {\\npublic:\\n    /*\\n        Approach: We will use the dijsktra algorithm to find out the shortest distance then calculate number of ways you can arrive at your destination in the shortest time. Take distance as long long\\n        1. Using a Priority Queue\\n        2. Using a Set\\n        3. Using a queue (not preferred)\\n    */\\n    long long mod = 1e9 + 7;\\n    int dijkstra2(vector<pair<int, int>> adj[], int n) {\\n     // Set for relaxing nodes (distance, nodes), in set we can delete if we found dist != INF but it will also takes up O(logn)\\n        set<pair <long, long>> st;\\n        \\n        // Distance vector\\n        vector<long long>distance(n, 1e15), path(n, 0);\\n        distance[0] = 0;\\n        st.insert({0, 0});\\n        path[0] = 1;\\n\\n        while(!st.empty()){\\n            auto itr = *(st.begin());\\n            int node = itr.second;\\n            long long dist = itr.first;\\n            st.erase(itr);\\n            \\n            for(auto it : adj[node]){\\n                int adjNode = it.first;\\n                long long edgeW = it.second;\\n                \\n                if(dist + edgeW < distance[adjNode]){\\n                    if(distance[adjNode] != 1e9)st.erase({distance[adjNode], adjNode});\\n                    \\n                    // Relax\\n                    distance[adjNode] = dist + edgeW;\\n                    \\n                    // Path Update\\n                    path[adjNode] = path[node];\\n                    \\n                    // Inserting Back \\n                    st.insert({distance[adjNode], adjNode});\\n                }else if(dist + edgeW == distance[adjNode]){\\n                    // Node is already visited with the shortes path, sum of parent and the current node path\\n                    path[adjNode] = (1LL*path[node] + 1LL*path[adjNode]) % mod;\\n                }\\n            }\\n        }\\n        return path[n - 1];\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n         // First step for grpah question is to create the adjacency list\\n        vector<pair<int, int>> adj[n];\\n\\n        // Graph Creation\\n        for (auto &v : roads) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n            adj[v[1]].push_back({v[0], v[2]});\\n        }\\n        \\n        return dijkstra2(adj, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    /*\\n        Approach: We will use the dijsktra algorithm to find out the shortest distance then calculate number of ways you can arrive at your destination in the shortest time. Take distance as long long\\n        1. Using a Priority Queue\\n        2. Using a Set\\n        3. Using a queue (not preferred)\\n    */\\n    #define P pair<long long,long long> \\n    long long mod = 1e9 + 7;\\n    int dijkstra(vector<pair<int, int>> adj[], int n) {\\n        // Priority queue for relaxing nodes (distance, nodes)\\n        priority_queue<P, vector<P>, greater<P>> pq;\\n        \\n        // Distance vector\\n        vector<long long>distance(n, 1e15), path(n, 0);\\n        distance[0] = 0;\\n        pq.push({0, 0});\\n        path[0] = 1;\\n\\n        while(!pq.empty()){\\n            int node = pq.top().second;\\n            long long dist = pq.top().first;\\n            pq.pop();\\n            \\n            for(auto it : adj[node]){\\n                int adjNode = it.first;\\n                long long edgeW = it.second;\\n                \\n                if(dist + edgeW < distance[adjNode]){\\n                    // Relax\\n                    distance[adjNode] = dist + edgeW;\\n                    path[adjNode] = path[node];\\n                    pq.push({distance[adjNode], adjNode});\\n                }else if(dist + edgeW == distance[adjNode]){\\n                    // Node is already visited with the shortes path, sum of parent and the current node path\\n                    path[adjNode] = (1LL*path[node] + 1LL*path[adjNode]) % mod;\\n                }\\n            }\\n        }\\n        return path[n - 1];\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        \\n         // First step for grpah question is to create the adjacency list\\n        vector<pair<int, int>> adj[n];\\n\\n        // Graph Creation\\n        for (auto &v : roads) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n            adj[v[1]].push_back({v[0], v[2]});\\n        }\\n        \\n        return dijkstra(adj, n);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    /*\\n        Approach: We will use the dijsktra algorithm to find out the shortest distance then calculate number of ways you can arrive at your destination in the shortest time. Take distance as long long\\n        1. Using a Priority Queue\\n        2. Using a Set\\n        3. Using a queue (not preferred)\\n    */\\n    long long mod = 1e9 + 7;\\n    int dijkstra2(vector<pair<int, int>> adj[], int n) {\\n     // Set for relaxing nodes (distance, nodes), in set we can delete if we found dist != INF but it will also takes up O(logn)\\n        set<pair <long, long>> st;\\n        \\n        // Distance vector\\n        vector<long long>distance(n, 1e15), path(n, 0);\\n        distance[0] = 0;\\n        st.insert({0, 0});\\n        path[0] = 1;\\n\\n        while(!st.empty()){\\n            auto itr = *(st.begin());\\n            int node = itr.second;\\n            long long dist = itr.first;\\n            st.erase(itr);\\n            \\n            for(auto it : adj[node]){\\n                int adjNode = it.first;\\n                long long edgeW = it.second;\\n                \\n                if(dist + edgeW < distance[adjNode]){\\n                    if(distance[adjNode] != 1e9)st.erase({distance[adjNode], adjNode});\\n                    \\n                    // Relax\\n                    distance[adjNode] = dist + edgeW;\\n                    \\n                    // Path Update\\n                    path[adjNode] = path[node];\\n                    \\n                    // Inserting Back \\n                    st.insert({distance[adjNode], adjNode});\\n                }else if(dist + edgeW == distance[adjNode]){\\n                    // Node is already visited with the shortes path, sum of parent and the current node path\\n                    path[adjNode] = (1LL*path[node] + 1LL*path[adjNode]) % mod;\\n                }\\n            }\\n        }\\n        return path[n - 1];\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n         // First step for grpah question is to create the adjacency list\\n        vector<pair<int, int>> adj[n];\\n\\n        // Graph Creation\\n        for (auto &v : roads) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n            adj[v[1]].push_back({v[0], v[2]});\\n        }\\n        \\n        return dijkstra2(adj, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992558,
                "title": "java-using-edge-class",
                "content": "Please UpVote if you liked my solution. \\uD83D\\uDE42\\nIf you didn\\'t understand,Mail me @piyushchhawachharia@gmail.com and I\\'ll explain that to you one-on-one.\\nThe Coding Community Always Sticks Together! :)\\n\\n# Code\\n```\\nclass Solution {\\n    static class Edge{\\n        int vtc;\\n        int nbr;\\n        int wt;\\n        Edge(int vtc,int nbr,int wt){\\n            this.vtc=vtc;\\n            this.nbr=nbr;\\n            this.wt=wt;\\n        }\\n    }\\n    static class Pair implements Comparable<Pair>{\\n        int vtc;\\n        int wt;\\n        Pair(int vtc,int wt){\\n            this.vtc=vtc;\\n            this.wt=wt;\\n        }\\n        public int compareTo(Pair o){\\n            return this.wt-o.wt;\\n        }\\n    }\\n    public int countPaths(int n, int[][] roads) {\\n        int mod=(int)Math.pow(10,9)+7;\\n        ArrayList<Edge>[] graph=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n\\n        for(int i=0;i<roads.length;i++){\\n            graph[roads[i][0]].add(new Edge(roads[i][0],roads[i][1],roads[i][2]));\\n            graph[roads[i][1]].add(new Edge(roads[i][1],roads[i][0],roads[i][2]));\\n        }\\n        int dist[]=new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[0]=0;\\n        int count[]=new int[n];\\n        count[0]=1;\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        pq.add(new Pair(0,0));\\n\\n        while(pq.size()>0){\\n            Pair rm=pq.remove();\\n\\n\\n            for(Edge e:graph[rm.vtc]){\\n                if((rm.wt+e.wt)<dist[e.nbr]){\\n                    dist[e.nbr]=rm.wt+e.wt;\\n                    pq.add(new Pair(e.nbr,dist[e.nbr]));\\n                    count[e.nbr]=count[rm.vtc];\\n                }\\n                else if((rm.wt+e.wt==dist[e.nbr])){\\n                    count[e.nbr]=(count[e.nbr]+count[rm.vtc])%mod;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            System.out.println(dist[i]);\\n        }\\n        return (int)(count[n-1]%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static class Edge{\\n        int vtc;\\n        int nbr;\\n        int wt;\\n        Edge(int vtc,int nbr,int wt){\\n            this.vtc=vtc;\\n            this.nbr=nbr;\\n            this.wt=wt;\\n        }\\n    }\\n    static class Pair implements Comparable<Pair>{\\n        int vtc;\\n        int wt;\\n        Pair(int vtc,int wt){\\n            this.vtc=vtc;\\n            this.wt=wt;\\n        }\\n        public int compareTo(Pair o){\\n            return this.wt-o.wt;\\n        }\\n    }\\n    public int countPaths(int n, int[][] roads) {\\n        int mod=(int)Math.pow(10,9)+7;\\n        ArrayList<Edge>[] graph=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n\\n        for(int i=0;i<roads.length;i++){\\n            graph[roads[i][0]].add(new Edge(roads[i][0],roads[i][1],roads[i][2]));\\n            graph[roads[i][1]].add(new Edge(roads[i][1],roads[i][0],roads[i][2]));\\n        }\\n        int dist[]=new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[0]=0;\\n        int count[]=new int[n];\\n        count[0]=1;\\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        pq.add(new Pair(0,0));\\n\\n        while(pq.size()>0){\\n            Pair rm=pq.remove();\\n\\n\\n            for(Edge e:graph[rm.vtc]){\\n                if((rm.wt+e.wt)<dist[e.nbr]){\\n                    dist[e.nbr]=rm.wt+e.wt;\\n                    pq.add(new Pair(e.nbr,dist[e.nbr]));\\n                    count[e.nbr]=count[rm.vtc];\\n                }\\n                else if((rm.wt+e.wt==dist[e.nbr])){\\n                    count[e.nbr]=(count[e.nbr]+count[rm.vtc])%mod;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            System.out.println(dist[i]);\\n        }\\n        return (int)(count[n-1]%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786906,
                "title": "commented-and-explained-solution",
                "content": "``` \\npublic int countPaths(int n, int[][] roads) {\\n //the approach here will be same as djskarta but we will require to count the number of \\n        //ways we reached to every node through short cost path\\n        //Catch is, whenver you find a better way to reach a particular vertex update the number of ways \\n        // we can reach this vertex same as number of ways we can reach parent vertex.\\n        //If we arrive at a vetrex, with same time from parent, we will add the parent\\'s number of ways \\n        // to the current vertex\\'s number of ways\\n        //In the End the last veretx will have total number of ways from origin i.e 0\\n        final int mod = 1_000_000_007;\\n        int[][] adj = new int[n][n];\\n        //adjacency list creation\\n        for(int[] road : roads){\\n            adj[road[0]][road[1]] = road[2];\\n            adj[road[1]][road[0]] = road[2];\\n        }\\n        //creating and filling ways and cost array\\n        //it can be also said to be type of tabulation (dp) problem because we have to memorize the ways we reach to node\\n        long[] cost = new long[n], ways = new long[n];\\n        Arrays.fill(cost,1,n, Long.MAX_VALUE);\\n        ways[0]=1;\\n\\n        Queue<long[]> q = new PriorityQueue<>((a, b)->Long.compare(a[1], b[1]));\\n        q.offer(new long[]{0,0});\\n\\n        while(!q.isEmpty()){\\n            long[] e = q.poll();\\n            int v = (int) e[0];\\n            long t = e[1];\\n            if(t <= cost[v]){\\n                for(int i=0;i<n;i++){\\n                    if(adj[v][i]!=0){\\n                        //here if we get a cheaper path to operate then we go through every path that is to adj[v][i] node\\n                        if(cost[v]+adj[v][i] < cost[i]){\\n                            cost[i] = cost[v]+adj[v][i];\\n\\n                            q.offer(new long[]{i,cost[i]});\\n                            ways[i] = ways[v];\\n                            \\n                        }else if(cost[v]+adj[v][i] == cost[i]){//if cost is same then we will update the ways with which we \\n                            //reach to parent node +current node\\n                            ways[i] = (ways[i]+ways[v]) % mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return (int) ways[n-1];\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "``` \\npublic int countPaths(int n, int[][] roads) {\\n //the approach here will be same as djskarta but we will require to count the number of \\n        //ways we reached to every node through short cost path\\n        //Catch is, whenver you find a better way to reach a particular vertex update the number of ways \\n        // we can reach this vertex same as number of ways we can reach parent vertex.\\n        //If we arrive at a vetrex, with same time from parent, we will add the parent\\'s number of ways \\n        // to the current vertex\\'s number of ways\\n        //In the End the last veretx will have total number of ways from origin i.e 0\\n        final int mod = 1_000_000_007;\\n        int[][] adj = new int[n][n];\\n        //adjacency list creation\\n        for(int[] road : roads){\\n            adj[road[0]][road[1]] = road[2];\\n            adj[road[1]][road[0]] = road[2];\\n        }\\n        //creating and filling ways and cost array\\n        //it can be also said to be type of tabulation (dp) problem because we have to memorize the ways we reach to node\\n        long[] cost = new long[n], ways = new long[n];\\n        Arrays.fill(cost,1,n, Long.MAX_VALUE);\\n        ways[0]=1;\\n\\n        Queue<long[]> q = new PriorityQueue<>((a, b)->Long.compare(a[1], b[1]));\\n        q.offer(new long[]{0,0});\\n\\n        while(!q.isEmpty()){\\n            long[] e = q.poll();\\n            int v = (int) e[0];\\n            long t = e[1];\\n            if(t <= cost[v]){\\n                for(int i=0;i<n;i++){\\n                    if(adj[v][i]!=0){\\n                        //here if we get a cheaper path to operate then we go through every path that is to adj[v][i] node\\n                        if(cost[v]+adj[v][i] < cost[i]){\\n                            cost[i] = cost[v]+adj[v][i];\\n\\n                            q.offer(new long[]{i,cost[i]});\\n                            ways[i] = ways[v];\\n                            \\n                        }else if(cost[v]+adj[v][i] == cost[i]){//if cost is same then we will update the ways with which we \\n                            //reach to parent node +current node\\n                            ways[i] = (ways[i]+ways[v]) % mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return (int) ways[n-1];\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2746308,
                "title": "dijkstra-top-down-dp-c",
                "content": "# Intuition\\nApplying dijkstra to find shortest distance then using a dfs to find number of paths having this shortest distance.\\n\\n\\n# Approach\\nFirst apply dijkstra from n-1 node then use the distance array generated in a dfs function which is memoized for optimization.\\n\\n\\n# Complexity\\n- Time complexity: O(ElogV) (Dijkstra) +O(V) DFS(memoized)\\n\\n\\n- Space complexity:\\nO(V)\\n\\n# Code\\n```\\nclass Solution {\\n\\n   long long int shortest_distance;\\n    int mod=1e9+7;\\n\\n    public:\\n\\n    int dp[202];\\n\\n    int dfs(vector<pair<int,int>> adj[],int node,vector<long long int>& dist)\\n    {\\n       if(node==dist.size()-1)return 1;\\n\\n       if(dp[node]!=-1)return dp[node];\\n\\n        long long  int distance_to_dest=dist[node];\\n\\n       int total=0;\\n\\n       for(auto [nd,wt]:adj[node])\\n       {\\n           if(0LL+wt+dist[nd]==distance_to_dest)// the path must be shortest one \\n           {\\n               total=(0LL+total+dfs(adj,nd,dist))%mod;// counting all paths\\n           }\\n       }\\n\\n       return dp[node]=total;\\n\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto a:roads)\\n        {\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});   \\n        }\\n        \\n        priority_queue< pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>> > heap;\\n        \\n        vector<long long int> dist(n,LLONG_MAX);\\n        \\n        dist[n-1]=0;// dijkstra from reverse direction to find distan from node i to n-1 in O(1) during Dfs\\n        \\n        heap.push({0,n-1});\\n        \\n        while(heap.size())\\n        {\\n           auto [distance,node]=heap.top();\\n          \\n            heap.pop();\\n\\n           if(distance>dist[node])continue;\\n\\n           for(auto& [nd,wt]:adj[node])\\n            {\\n              long long  int summer=(0LL+wt+distance);\\n            \\n                if(dist[nd]>summer)\\n                {      \\n                    dist[nd]=summer;\\n                    \\n                    heap.push({dist[nd],nd});\\n                }\\n                \\n            }\\n        }\\n\\n        shortest_distance=dist[0];\\n        \\n        return dfs(adj,0,dist); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n\\n   long long int shortest_distance;\\n    int mod=1e9+7;\\n\\n    public:\\n\\n    int dp[202];\\n\\n    int dfs(vector<pair<int,int>> adj[],int node,vector<long long int>& dist)\\n    {\\n       if(node==dist.size()-1)return 1;\\n\\n       if(dp[node]!=-1)return dp[node];\\n\\n        long long  int distance_to_dest=dist[node];\\n\\n       int total=0;\\n\\n       for(auto [nd,wt]:adj[node])\\n       {\\n           if(0LL+wt+dist[nd]==distance_to_dest)// the path must be shortest one \\n           {\\n               total=(0LL+total+dfs(adj,nd,dist))%mod;// counting all paths\\n           }\\n       }\\n\\n       return dp[node]=total;\\n\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto a:roads)\\n        {\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});   \\n        }\\n        \\n        priority_queue< pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>> > heap;\\n        \\n        vector<long long int> dist(n,LLONG_MAX);\\n        \\n        dist[n-1]=0;// dijkstra from reverse direction to find distan from node i to n-1 in O(1) during Dfs\\n        \\n        heap.push({0,n-1});\\n        \\n        while(heap.size())\\n        {\\n           auto [distance,node]=heap.top();\\n          \\n            heap.pop();\\n\\n           if(distance>dist[node])continue;\\n\\n           for(auto& [nd,wt]:adj[node])\\n            {\\n              long long  int summer=(0LL+wt+distance);\\n            \\n                if(dist[nd]>summer)\\n                {      \\n                    dist[nd]=summer;\\n                    \\n                    heap.push({dist[nd],nd});\\n                }\\n                \\n            }\\n        }\\n\\n        shortest_distance=dist[0];\\n        \\n        return dfs(adj,0,dist); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700475,
                "title": "c-priority-queue-o-v-e-time-o-v-e-space",
                "content": "# Intuition\\n[@indresh149](https://leetcode.com/indresh149/) proposed this [method](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/2671526/c-dijkstra-priority-queue-easy-to-understand/). I refactor the code and make it much faster.\\n\\n# Complexity\\n- Time complexity:\\n$$O(V+E)$$ ->\\n`V` is the number of nodes.\\n`E` is the number of edges.\\n\\n- Space complexity:\\n$$O(V+E)$$ ->\\n`V` is the number of nodes.\\n`E` is the number of edges.\\n\\n# Code\\n```\\nclass Solution {\\n    using i64 = long long;\\npublic:\\n    static int countPaths(const int n, const vector<vector<int>>& roads) {\\n        vector<vector<pair<i64, i64>>> adj(n);\\n        for (auto& i : roads) {\\n            adj[i[0]].emplace_back(i[1], i[2]);\\n            adj[i[1]].emplace_back(i[0], i[2]);\\n        }\\n        \\n        priority_queue<pair<i64, i64>, vector<pair<i64, i64>>, greater<>> pq;\\n        vector<i64> dist(n, LLONG_MAX);\\n        vector<i64> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        \\n        pq.emplace(0, 0);\\n        \\n        while (!pq.empty()) {\\n            auto [dis, node] = pq.top();\\n            pq.pop();\\n            if (dist[node] < dis)\\n                continue;\\n            for (auto [adjNode, edW] : adj[node])\\n                if (dis + edW < dist[adjNode]) {\\n                    dist[adjNode] = dis + edW;\\n                    ways[adjNode] = ways[node];\\n                    pq.emplace(dis + edW, adjNode);\\n                } else if (dis + edW == dist[adjNode]) {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % 1000000007;\\n                }\\n        }\\n        return int(ways.back());\\n    }\\n};\\n```\\n\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using i64 = long long;\\npublic:\\n    static int countPaths(const int n, const vector<vector<int>>& roads) {\\n        vector<vector<pair<i64, i64>>> adj(n);\\n        for (auto& i : roads) {\\n            adj[i[0]].emplace_back(i[1], i[2]);\\n            adj[i[1]].emplace_back(i[0], i[2]);\\n        }\\n        \\n        priority_queue<pair<i64, i64>, vector<pair<i64, i64>>, greater<>> pq;\\n        vector<i64> dist(n, LLONG_MAX);\\n        vector<i64> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        \\n        pq.emplace(0, 0);\\n        \\n        while (!pq.empty()) {\\n            auto [dis, node] = pq.top();\\n            pq.pop();\\n            if (dist[node] < dis)\\n                continue;\\n            for (auto [adjNode, edW] : adj[node])\\n                if (dis + edW < dist[adjNode]) {\\n                    dist[adjNode] = dis + edW;\\n                    ways[adjNode] = ways[node];\\n                    pq.emplace(dis + edW, adjNode);\\n                } else if (dis + edW == dist[adjNode]) {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % 1000000007;\\n                }\\n        }\\n        return int(ways.back());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668346,
                "title": "striver-c-number-to-ways-to-arrive-at-destination",
                "content": "int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        vector<pair<long long,long long>>adj[n];\\n        for(auto it :roads)\\n        {\\n          adj[it[0]].push_back({it[1],it[2]});\\n          adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>>pq;\\n        vector<long long>ways(n,0);\\n        vector<long long>dist(n,LONG_MAX);\\n        ways[0]=1;\\n        dist[0]=0;\\n        long long mod=(long long)(1e9+7);\\n        pq.push({0,0});\\n        while(!pq.empty())\\n        {\\n           auto it =pq.top();\\n            long long dis=it.first;\\n            long long node=it.second;\\n            pq.pop();\\n            \\n            for(auto it:adj[node])\\n            {\\n                long long adjnode=it.first;\\n                  long long ew=it.second;\\n                if(ew+dis<dist[adjnode])\\n                {\\n                   dist[adjnode]=ew+dis;\\n                    ways[adjnode]=ways[node];\\n                    pq.push({ew+dis,adjnode});\\n                }\\n                else if(ew+dis==dist[adjnode])\\n                {\\n                     ways[adjnode]=(ways[node]+ ways[adjnode])%mod;\\n                }\\n            }\\n        }\\n        return (ways[n-1])%mod;",
                "solutionTags": [],
                "code": "int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        vector<pair<long long,long long>>adj[n];\\n        for(auto it :roads)\\n        {\\n          adj[it[0]].push_back({it[1],it[2]});\\n          adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>>pq;\\n        vector<long long>ways(n,0);\\n        vector<long long>dist(n,LONG_MAX);\\n        ways[0]=1;\\n        dist[0]=0;\\n        long long mod=(long long)(1e9+7);\\n        pq.push({0,0});\\n        while(!pq.empty())\\n        {\\n           auto it =pq.top();\\n            long long dis=it.first;\\n            long long node=it.second;\\n            pq.pop();\\n            \\n            for(auto it:adj[node])\\n            {\\n                long long adjnode=it.first;\\n                  long long ew=it.second;\\n                if(ew+dis<dist[adjnode])\\n                {\\n                   dist[adjnode]=ew+dis;\\n                    ways[adjnode]=ways[node];\\n                    pq.push({ew+dis,adjnode});\\n                }\\n                else if(ew+dis==dist[adjnode])\\n                {\\n                     ways[adjnode]=(ways[node]+ ways[adjnode])%mod;\\n                }\\n            }\\n        }\\n        return (ways[n-1])%mod;",
                "codeTag": "Unknown"
            },
            {
                "id": 2351157,
                "title": "c-minheap-time-o-e-n-2-log-n-space-o-n-2",
                "content": "# Complexity\\n$$n$$ = # of nodes\\n$$e$$ = size of `roads` = # of edges\\nTime: $$O(e + n^2 * log(n))$$\\nSpace: $$O(n^2)$$\\n\\n```\\nclass Solution {\\npublic:\\n  int countPaths(int n, vector<vector<int>>& roads) {\\n    vector<vector<pair<int, int>>> graph (n); // node, time\\n    for (const auto& road : roads) {\\n      int node1 = road[0];\\n      int node2 = road[1];\\n      int time = road[2];\\n      graph[node1].emplace_back(node2, time);\\n      graph[node2].emplace_back(node1, time);\\n    }\\n    \\n    vector<long> ways (n, 1), costs (n, LONG_MAX);\\n    costs[0] = 0;\\n    \\n    priority_queue<pair<long, int>, vector<pair<long, int>>, greater<>> minHeap; // cost, node\\n    minHeap.emplace(0, 0);\\n    \\n    while (minHeap.size()) { // loop consumes O(n)\\n      auto [ cost, node ] = minHeap.top();\\n      minHeap.pop();\\n      \\n      if (cost > costs[node]) // do not consider any costly ways\\n        continue;\\n      \\n      for (const auto& [ neighbor, time ] : graph[node]) { // loop consumes O(n)\\n        long addedCost = cost + time;\\n        if (addedCost < costs[neighbor]) {\\n          costs[neighbor] = addedCost;\\n          ways[neighbor] = ways[node];\\n          minHeap.emplace(addedCost, neighbor); // priority queue insertion consumes O(log(n))\\n        }\\n        else if (addedCost == costs[neighbor]) {\\n          ways[neighbor] = (ways[neighbor] + ways[node]) % 1000000007;\\n        }\\n      }\\n    }\\n    \\n    return ways[n - 1];\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countPaths(int n, vector<vector<int>>& roads) {\\n    vector<vector<pair<int, int>>> graph (n); // node, time\\n    for (const auto& road : roads) {\\n      int node1 = road[0];\\n      int node2 = road[1];\\n      int time = road[2];\\n      graph[node1].emplace_back(node2, time);\\n      graph[node2].emplace_back(node1, time);\\n    }\\n    \\n    vector<long> ways (n, 1), costs (n, LONG_MAX);\\n    costs[0] = 0;\\n    \\n    priority_queue<pair<long, int>, vector<pair<long, int>>, greater<>> minHeap; // cost, node\\n    minHeap.emplace(0, 0);\\n    \\n    while (minHeap.size()) { // loop consumes O(n)\\n      auto [ cost, node ] = minHeap.top();\\n      minHeap.pop();\\n      \\n      if (cost > costs[node]) // do not consider any costly ways\\n        continue;\\n      \\n      for (const auto& [ neighbor, time ] : graph[node]) { // loop consumes O(n)\\n        long addedCost = cost + time;\\n        if (addedCost < costs[neighbor]) {\\n          costs[neighbor] = addedCost;\\n          ways[neighbor] = ways[node];\\n          minHeap.emplace(addedCost, neighbor); // priority queue insertion consumes O(log(n))\\n        }\\n        else if (addedCost == costs[neighbor]) {\\n          ways[neighbor] = (ways[neighbor] + ways[node]) % 1000000007;\\n        }\\n      }\\n    }\\n    \\n    return ways[n - 1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300002,
                "title": "easily-understandable-dijkstra-dijkstra-dp-c",
                "content": "\\n                                Time Complexity:  O(mlogn)\\nBoth the solutions have same time complexity and both passed all test cases.\\n\\nSolution i)\\n\\nApproach - Apply Dijkstra from n-1. Suppose waysToReachN1[i] denotes # of ways to reach n-1 from i. Our answer would be waysToReachN1[0].\\n\\nCases -\\ni) i==n-1 | waysToReachN1[i] = 1\\nii) If we find better distance for node i from node j then waysToReachN1[i]=waysToReachN1[j]\\niii) If we find equal distance for node i from node j then waysToReachN1[i]+=waysToReachN1[j]\\n```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const vector<long long> &left, const vector<long long> &right){\\n          return left[0] >= right[0];\\n        }\\n    };\\n\\n    long long dijkstra(int n, vector<vector<vector<long long>>> &adj) {\\n        vector<long long> distances(n, LONG_MAX);\\n        priority_queue<vector<long long>, vector<vector<long long>>, cmp> Q;\\n        distances[n-1] = 0;      \\n        vector<long long> waysToReachN1(n, 0);\\n        Q.push({distances[n-1], n-1});      \\n        waysToReachN1[n-1] = 1;\\n        while(!Q.empty()){\\n            vector<long long> vec = Q.top(); Q.pop();\\n            long long distanceSoFar = vec[0];\\n            int node = vec[1];        \\n\\t\\t\\tif(distanceSoFar > distances[node]) continue;\\n            for(vector<long long> vecNeigh: adj[node]){\\n                int node_neigh = vecNeigh[0];\\n                long long distanceBetweenTwo = vecNeigh[1];          \\n                if(distanceSoFar + distanceBetweenTwo < distances[node_neigh]){\\n                    distances[node_neigh] = distanceSoFar + distanceBetweenTwo;\\n                    Q.push({distances[node_neigh], node_neigh});        \\n                    // found new way\\n                    waysToReachN1[node_neigh] = waysToReachN1[node]; \\n                } else if(distanceSoFar + distanceBetweenTwo == distances[node_neigh]) {\\n                    waysToReachN1[node_neigh]=(waysToReachN1[node_neigh] + waysToReachN1[node])%(1000000007); \\n                }\\n            }                    \\n        }         \\n\\n        return waysToReachN1[0];            \\n    }  \\n  \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n      vector<vector<vector<long long>>> adj(n);\\n      for(vector<int> road:roads){\\n        long long u = road[0];\\n        long long v = road[1];\\n        long long time = road[2];\\n        adj[u].push_back({v, time});\\n        adj[v].push_back({u, time});\\n      }\\n      \\n      return dijkstra(n,adj);      \\n    }\\n};\\n```\\nSolution ii)\\n```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const vector<long long> &left, const vector<long long> &right){\\n          return left[0] >= right[0];\\n        }\\n    };\\n\\n    vector<long long> dijkstra(int n, vector<vector<vector<long long>>> &adj) {\\n        vector<long long> distances(n, LONG_MAX);\\n        priority_queue<vector<long long>, vector<vector<long long>>, cmp> Q;\\n        distances[n-1] = 0;      \\n        Q.push({distances[n-1], n-1});      \\n        while(!Q.empty()){\\n            vector<long long> vec = Q.top(); Q.pop();\\n            long long distanceSoFar = vec[0];\\t\\t\\t\\t\\t\\t\\n            int node = vec[1];        \\n\\t\\t\\tif(distanceSoFar > distances[node]) continue;\\n            for(vector<long long> vecNeigh: adj[node]){\\n                int node_neigh = vecNeigh[0];\\n                long long distanceBetweenTwo = vecNeigh[1];          \\n                if(distanceSoFar + distanceBetweenTwo < distances[node_neigh]){\\n                    distances[node_neigh] = distanceSoFar + distanceBetweenTwo;\\n                    Q.push({distances[node_neigh], node_neigh});                         \\n                }\\n            }                    \\n        }\\n\\n        return distances;            \\n    }\\n  \\n    int countWays(int u, vector<vector<vector<long long>>> &adj, vector<long long> &distances, long long toCoverMore, vector<long long> &dp){\\n        int n = adj.size();  \\n                            \\n        if(dp[u]!=-1) return dp[u];\\n      \\n        if(u==n-1){            \\n            if(toCoverMore == 0) return 1;\\n            return 0;\\n        }\\n      \\n        long long res = 0;\\n                      \\n        for(vector<long long> vecNeigh: adj[u]){\\n            int node_neigh = vecNeigh[0];\\n            long long distanceBetweenTwo = vecNeigh[1];\\n            if(toCoverMore-distanceBetweenTwo == distances[node_neigh]){\\n                res=(res + countWays(node_neigh,adj,distances,toCoverMore-distanceBetweenTwo,dp))%(1000000007);                   \\n            }                \\n        } \\n      \\n        return dp[u] = res;\\n    }\\n  \\n  \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n      vector<vector<vector<long long>>> adj(n);\\n      for(vector<int> road:roads){\\n        long long u = road[0];\\n        long long v = road[1];\\n        long long time = road[2];\\n        adj[u].push_back({v, time});\\n        adj[v].push_back({u, time});\\n      }\\n      \\n      vector<long long> distances = dijkstra(n,adj);      \\n      vector<long long> dp(n, -1);\\n      \\n      long long ways = countWays(0, adj, distances, distances[0], dp);      \\n      return ways;      \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const vector<long long> &left, const vector<long long> &right){\\n          return left[0] >= right[0];\\n        }\\n    };\\n\\n    long long dijkstra(int n, vector<vector<vector<long long>>> &adj) {\\n        vector<long long> distances(n, LONG_MAX);\\n        priority_queue<vector<long long>, vector<vector<long long>>, cmp> Q;\\n        distances[n-1] = 0;      \\n        vector<long long> waysToReachN1(n, 0);\\n        Q.push({distances[n-1], n-1});      \\n        waysToReachN1[n-1] = 1;\\n        while(!Q.empty()){\\n            vector<long long> vec = Q.top(); Q.pop();\\n            long long distanceSoFar = vec[0];\\n            int node = vec[1];        \\n\\t\\t\\tif(distanceSoFar > distances[node]) continue;\\n            for(vector<long long> vecNeigh: adj[node]){\\n                int node_neigh = vecNeigh[0];\\n                long long distanceBetweenTwo = vecNeigh[1];          \\n                if(distanceSoFar + distanceBetweenTwo < distances[node_neigh]){\\n                    distances[node_neigh] = distanceSoFar + distanceBetweenTwo;\\n                    Q.push({distances[node_neigh], node_neigh});        \\n                    // found new way\\n                    waysToReachN1[node_neigh] = waysToReachN1[node]; \\n                } else if(distanceSoFar + distanceBetweenTwo == distances[node_neigh]) {\\n                    waysToReachN1[node_neigh]=(waysToReachN1[node_neigh] + waysToReachN1[node])%(1000000007); \\n                }\\n            }                    \\n        }         \\n\\n        return waysToReachN1[0];            \\n    }  \\n  \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n      vector<vector<vector<long long>>> adj(n);\\n      for(vector<int> road:roads){\\n        long long u = road[0];\\n        long long v = road[1];\\n        long long time = road[2];\\n        adj[u].push_back({v, time});\\n        adj[v].push_back({u, time});\\n      }\\n      \\n      return dijkstra(n,adj);      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    struct cmp {\\n        bool operator()(const vector<long long> &left, const vector<long long> &right){\\n          return left[0] >= right[0];\\n        }\\n    };\\n\\n    vector<long long> dijkstra(int n, vector<vector<vector<long long>>> &adj) {\\n        vector<long long> distances(n, LONG_MAX);\\n        priority_queue<vector<long long>, vector<vector<long long>>, cmp> Q;\\n        distances[n-1] = 0;      \\n        Q.push({distances[n-1], n-1});      \\n        while(!Q.empty()){\\n            vector<long long> vec = Q.top(); Q.pop();\\n            long long distanceSoFar = vec[0];\\t\\t\\t\\t\\t\\t\\n            int node = vec[1];        \\n\\t\\t\\tif(distanceSoFar > distances[node]) continue;\\n            for(vector<long long> vecNeigh: adj[node]){\\n                int node_neigh = vecNeigh[0];\\n                long long distanceBetweenTwo = vecNeigh[1];          \\n                if(distanceSoFar + distanceBetweenTwo < distances[node_neigh]){\\n                    distances[node_neigh] = distanceSoFar + distanceBetweenTwo;\\n                    Q.push({distances[node_neigh], node_neigh});                         \\n                }\\n            }                    \\n        }\\n\\n        return distances;            \\n    }\\n  \\n    int countWays(int u, vector<vector<vector<long long>>> &adj, vector<long long> &distances, long long toCoverMore, vector<long long> &dp){\\n        int n = adj.size();  \\n                            \\n        if(dp[u]!=-1) return dp[u];\\n      \\n        if(u==n-1){            \\n            if(toCoverMore == 0) return 1;\\n            return 0;\\n        }\\n      \\n        long long res = 0;\\n                      \\n        for(vector<long long> vecNeigh: adj[u]){\\n            int node_neigh = vecNeigh[0];\\n            long long distanceBetweenTwo = vecNeigh[1];\\n            if(toCoverMore-distanceBetweenTwo == distances[node_neigh]){\\n                res=(res + countWays(node_neigh,adj,distances,toCoverMore-distanceBetweenTwo,dp))%(1000000007);                   \\n            }                \\n        } \\n      \\n        return dp[u] = res;\\n    }\\n  \\n  \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n      vector<vector<vector<long long>>> adj(n);\\n      for(vector<int> road:roads){\\n        long long u = road[0];\\n        long long v = road[1];\\n        long long time = road[2];\\n        adj[u].push_back({v, time});\\n        adj[v].push_back({u, time});\\n      }\\n      \\n      vector<long long> distances = dijkstra(n,adj);      \\n      vector<long long> dp(n, -1);\\n      \\n      long long ways = countWays(0, adj, distances, distances[0], dp);      \\n      return ways;      \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299163,
                "title": "stuck-for-1-hour-because-of-this",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n   \\n    priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n    \\n    \\n\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll,ll>> adj[n];\\n\\n        \\n        for(auto &v :  roads)\\n            adj[v[0]].push_back({v[1],v[2]}),adj[v[1]].push_back({v[0],v[2]});\\n        \\n        pq.push({0,0});\\n        \\n        vector<ll> distance(n,LONG_MAX);\\n        distance[0] = 0;\\n        vector<ll> dp(n,1);\\n        \\n        while(!pq.empty())\\n        {\\n            auto [dist,node] = pq.top();\\n            pq.pop();\\n        \\n            for(auto[child,count]  : adj[node])\\n            {\\n                \\n                if(dist + count < distance[child]){\\n                    distance[child] = dist + count;\\n                    pq.push({dist+count,child});   \\n                    dp[child] = dp[node];\\n                }\\n                else if(dist + count == distance[child])\\n                    dp[child] = (dp[child] + dp[node])%1000000007;\\n            }\\n        }\\n        \\n    \\n        \\n        return dp[n-1];\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\n\\nUSE LONG_MAX instead of INT_MAX",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n   \\n    priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n    \\n    \\n\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll,ll>> adj[n];\\n\\n        \\n        for(auto &v :  roads)\\n            adj[v[0]].push_back({v[1],v[2]}),adj[v[1]].push_back({v[0],v[2]});\\n        \\n        pq.push({0,0});\\n        \\n        vector<ll> distance(n,LONG_MAX);\\n        distance[0] = 0;\\n        vector<ll> dp(n,1);\\n        \\n        while(!pq.empty())\\n        {\\n            auto [dist,node] = pq.top();\\n            pq.pop();\\n        \\n            for(auto[child,count]  : adj[node])\\n            {\\n                \\n                if(dist + count < distance[child]){\\n                    distance[child] = dist + count;\\n                    pq.push({dist+count,child});   \\n                    dp[child] = dp[node];\\n                }\\n                else if(dist + count == distance[child])\\n                    dp[child] = (dp[child] + dp[node])%1000000007;\\n            }\\n        }\\n        \\n    \\n        \\n        return dp[n-1];\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288437,
                "title": "c-dijkstra-please-upvote-if-you-like",
                "content": "```\\nclass Solution {\\npublic:\\n  int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long >ways(n , 0); int mod = 1e9+7; \\n        vector<long > distv(n , LONG_MAX);\\n        vector<pair<long , long >> adj[n];\\n        for(auto it : roads){\\n            adj[it[0]].push_back({it[2] ,it[1]}); \\n            adj[it[1]].push_back({it[2] ,it[0]}); // dist , adj\\n        }\\n        distv[0]= 0; ways[0] = 1;\\n        priority_queue<pair<long ,long > , vector<pair<long ,long >> , greater<pair<long ,long > > > pq;\\n        pq.push({ 0 ,0 }); // dist , adj\\n        while(!pq.empty()){\\n            long time = pq.top().first;\\n            long node = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[node]){\\n                long ti = it.first; // time\\n                long i = it.second; // adj node\\n                if(ti + time < distv[i]){\\n                    distv[i] = ti + time; ways[i]= ways[node];\\n                    pq.push({ti + time,i });\\n                }\\n                else if(ti + time == distv[i]){\\n                    ways[i]= (ways[i] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        return ways[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long >ways(n , 0); int mod = 1e9+7; \\n        vector<long > distv(n , LONG_MAX);\\n        vector<pair<long , long >> adj[n];\\n        for(auto it : roads){\\n            adj[it[0]].push_back({it[2] ,it[1]}); \\n            adj[it[1]].push_back({it[2] ,it[0]}); // dist , adj\\n        }\\n        distv[0]= 0; ways[0] = 1;\\n        priority_queue<pair<long ,long > , vector<pair<long ,long >> , greater<pair<long ,long > > > pq;\\n        pq.push({ 0 ,0 }); // dist , adj\\n        while(!pq.empty()){\\n            long time = pq.top().first;\\n            long node = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[node]){\\n                long ti = it.first; // time\\n                long i = it.second; // adj node\\n                if(ti + time < distv[i]){\\n                    distv[i] = ti + time; ways[i]= ways[node];\\n                    pq.push({ti + time,i });\\n                }\\n                else if(ti + time == distv[i]){\\n                    ways[i]= (ways[i] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        return ways[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156232,
                "title": "java-floyd-warshall-dp",
                "content": "```\\n\\tprivate final int MOD = 1_000_000_000 + 7;\\n    public int countPaths(int n, int[][] roads) {\\n        if (n == 1) {\\n            return 1;\\n        }\\n        long[][] d = new long[n][n];\\n        int[][] c = new int[n][n];\\n        for (long[] dd: d) {\\n            Arrays.fill(dd, Long.MAX_VALUE);\\n        }\\n        for (int[] road: roads) {\\n            d[road[0]][road[1]] = d[road[1]][road[0]] = road[2];\\n            c[road[0]][road[1]] = c[road[1]][road[0]] = 1;\\n        }\\n        for (int k = 0; k < n; ++k) \\n            for (int i = 0; i < n; ++i) \\n                for (int j = 0; j < n; ++j) {\\n                    if (d[i][k] == Long.MAX_VALUE || d[k][j] == Long.MAX_VALUE) {\\n                        continue;\\n                    }\\n                    if (d[i][j] > d[i][k] + d[k][j]) {\\n                        d[i][j] = d[i][k] + d[k][j];\\n                        c[i][j] = c[i][k] * c[k][j] % MOD;\\n                    } else if (d[i][j] == d[i][k] + d[k][j]) {\\n                        c[i][j] = (c[i][j] + c[i][k] * c[k][j] % MOD) % MOD;\\n                    }\\n                }\\n        return c[0][n - 1];\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tprivate final int MOD = 1_000_000_000 + 7;\\n    public int countPaths(int n, int[][] roads) {\\n        if (n == 1) {\\n            return 1;\\n        }\\n        long[][] d = new long[n][n];\\n        int[][] c = new int[n][n];\\n        for (long[] dd: d) {\\n            Arrays.fill(dd, Long.MAX_VALUE);\\n        }\\n        for (int[] road: roads) {\\n            d[road[0]][road[1]] = d[road[1]][road[0]] = road[2];\\n            c[road[0]][road[1]] = c[road[1]][road[0]] = 1;\\n        }\\n        for (int k = 0; k < n; ++k) \\n            for (int i = 0; i < n; ++i) \\n                for (int j = 0; j < n; ++j) {\\n                    if (d[i][k] == Long.MAX_VALUE || d[k][j] == Long.MAX_VALUE) {\\n                        continue;\\n                    }\\n                    if (d[i][j] > d[i][k] + d[k][j]) {\\n                        d[i][j] = d[i][k] + d[k][j];\\n                        c[i][j] = c[i][k] * c[k][j] % MOD;\\n                    } else if (d[i][j] == d[i][k] + d[k][j]) {\\n                        c[i][j] = (c[i][j] + c[i][k] * c[k][j] % MOD) % MOD;\\n                    }\\n                }\\n        return c[0][n - 1];\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2118410,
                "title": "c-dijkstra-clean-code-explained-using-comments",
                "content": "**Time Complexity: O(N log N) + E, where N = number of nodes and E = no of edges**\\n**Space Complexity: O(N)**\\n\\n**Approach Intuition: The main intuition about the approach is that we have to use shortest path algorithm(dijkstra), as this accounts only the cost of shortest path from the source to the destination, so here in this variation we have implemented the ways array as well.**\\n\\n**as the distances can reach upto very high values so we have used long data type for distance and ways array.**\\n\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long>ways(n, 0);\\n        vector<long >dis(n, LONG_MAX);\\n        dis[0] = 0;\\n        ways[0] = 1;\\n\\t\\t\\n\\t\\t//{distance, node}\\n        priority_queue<pair<long ,long >, vector<pair<long ,long >>, greater<pair<long ,long >>>pq;\\n        pq.push({0,0});\\n\\n        //creating the graph\\n        //{node, distance}\\n        vector<pair<long ,long >>adj[n];\\n        \\n        for(auto r: roads){\\n            adj[r[0]].push_back({r[1], r[2]});\\n            adj[r[1]].push_back({r[0], r[2]});\\n        }\\n        \\n        while(pq.empty()==false){\\n            long  currnode = pq.top().second;\\n            long  currdis = pq.top().first;\\n            pq.pop();\\n            \\n            for(auto x: adj[currnode]){\\n                long no = x.first;\\n                long dist = x.second;\\n                //if we are reaching a node with a distance lower than the current available distance then we update the distance of the current node and also put the no of ways to reach the currnode into the adjacent node ways, because we can reach the adj node same no of time as no of times we were able to reach currnode.\\n                if(currdis+dist<dis[no]){\\n                    dis[no] = currdis+dist;\\n                    ways[no] = ways[currnode];\\n                    pq.push({dis[no], no});\\n                }\\n                \\n\\t\\t\\t\\t//if again we are able to reach a node with the same distance as available then we add the currnode ways into the adj node because now we can reach the adj node with the same smaller distance from some other paths as well. \\n                else if(currdis+dist == dis[no]){\\n                    ways[no] = (ways[no]+ways[currnode])%(1000000000+7);\\n                }\\n            }\\n        }\\n        \\n        return ways[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long>ways(n, 0);\\n        vector<long >dis(n, LONG_MAX);\\n        dis[0] = 0;\\n        ways[0] = 1;\\n\\t\\t\\n\\t\\t//{distance, node}\\n        priority_queue<pair<long ,long >, vector<pair<long ,long >>, greater<pair<long ,long >>>pq;\\n        pq.push({0,0});\\n\\n        //creating the graph\\n        //{node, distance}\\n        vector<pair<long ,long >>adj[n];\\n        \\n        for(auto r: roads){\\n            adj[r[0]].push_back({r[1], r[2]});\\n            adj[r[1]].push_back({r[0], r[2]});\\n        }\\n        \\n        while(pq.empty()==false){\\n            long  currnode = pq.top().second;\\n            long  currdis = pq.top().first;\\n            pq.pop();\\n            \\n            for(auto x: adj[currnode]){\\n                long no = x.first;\\n                long dist = x.second;\\n                //if we are reaching a node with a distance lower than the current available distance then we update the distance of the current node and also put the no of ways to reach the currnode into the adjacent node ways, because we can reach the adj node same no of time as no of times we were able to reach currnode.\\n                if(currdis+dist<dis[no]){\\n                    dis[no] = currdis+dist;\\n                    ways[no] = ways[currnode];\\n                    pq.push({dis[no], no});\\n                }\\n                \\n\\t\\t\\t\\t//if again we are able to reach a node with the same distance as available then we add the currnode ways into the adj node because now we can reach the adj node with the same smaller distance from some other paths as well. \\n                else if(currdis+dist == dis[no]){\\n                    ways[no] = (ways[no]+ways[currnode])%(1000000000+7);\\n                }\\n            }\\n        }\\n        \\n        return ways[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694490,
                "title": "dijikstra-algorithm-c",
                "content": "\\n# class Solution {\\n# public:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dis(n,1e12);\\n        long long  mod=1e9+7;\\n        vector<pair<long ,long>>graph[n];\\n        vector<long long>ways(n,0);\\n        ways[0]=1;\\n        \\n        for(auto it:roads){\\n            graph[it[0]].push_back({it[1],it[2]});\\n             graph[it[1]].push_back({it[0],it[2]});\\n        }\\n        dis[0]=0;\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>>pq;\\n\\t\\tpq.push({0,0});\\n        while(!pq.empty()){\\n            long long node=pq.top().second;\\n            long long dist=pq.top().first;\\n            pq.pop();\\n            for(auto it:graph[node]){\\n                long long wt=it.second;\\n               long long adjNode=it.first;\\n                if(wt+dist<dis[adjNode]){\\n                    dis[adjNode]=wt+dist;\\n                    pq.push({dis[adjNode],adjNode});\\n                    ways[adjNode]=ways[node];\\n                    \\n                }\\n                else if(wt+dist==dis[adjNode]){\\n                    ways[adjNode]=(ways[node]+ways[adjNode])%mod;\\n                }\\n                \\n            }\\n        }\\n        return ways[n-1];\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n# public:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dis(n,1e12);\\n        long long  mod=1e9+7;\\n        vector<pair<long ,long>>graph[n];\\n        vector<long long>ways(n,0);\\n        ways[0]=1;\\n        \\n        for(auto it:roads){\\n            graph[it[0]].push_back({it[1],it[2]}",
                "codeTag": "Java"
            },
            {
                "id": 1429614,
                "title": "using-dijkstra-technique-dp-to-solve-in-java",
                "content": "```\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n        ArrayList<ArrayList<Node>> list = new ArrayList<ArrayList<Node>>();\\n        for(int i=0;i<n;i++){\\n            list.add(new ArrayList());\\n        }\\n        for(int arr[] :roads){\\n            list.get(arr[0]).add(new Node(arr[1],arr[2]));\\n            list.get(arr[1]).add(new Node(arr[0],arr[2]));\\n        }\\n        int min = diskshtra(list,n,0);\\n        return min;  \\n        \\n    }\\n    public int diskshtra(ArrayList<ArrayList<Node>> adj,int n,int start){\\n        int mod = 1_000_000_007;\\n        long dis[]= new long[n];\\n        long ways[]= new long[n];\\n        ways[0]=1;\\n        Arrays.fill(dis,Long.MAX_VALUE);\\n        PriorityQueue<Node> pq = new PriorityQueue<Node>(n,new Node());\\n        dis[start]=0;\\n        pq.add(new Node(start,0));\\n        while(pq.size()>0){\\n            Node node = pq.poll();\\n            if(node.val>dis[node.dis]){\\n                continue;\\n            }\\n            for(Node nextnode:adj.get(node.dis)){\\n                if(dis[node.dis]+nextnode.val<dis[nextnode.dis]){\\n                    dis[nextnode.dis]= dis[node.dis]+nextnode.val;\\n                    ways[nextnode.dis]= ways[node.dis]%mod;\\n                    pq.add(new Node(nextnode.dis,dis[nextnode.dis]));\\n                }\\n                else if(dis[node.dis]+nextnode.val==dis[nextnode.dis]){\\n                    ways[nextnode.dis]= (ways[node.dis]+ways[nextnode.dis])%mod;\\n                }\\n                \\n            }\\n        }\\n        return (int)ways[n-1];\\n        \\n    }\\n    \\n}\\n\\nclass Node implements Comparator<Node>{\\n    int dis;\\n    long val;\\n    Node(){}\\n    public Node(int dis,long val){\\n        this.dis=dis;\\n        this.val=val;\\n    }\\n    public int compare(Node node1, Node node2) \\n    { \\n        if (node1.val < node2.val) \\n            return -1; \\n        if (node1.val > node2.val) \\n            return 1; \\n        return 0; \\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n        ArrayList<ArrayList<Node>> list = new ArrayList<ArrayList<Node>>();\\n        for(int i=0;i<n;i++){\\n            list.add(new ArrayList());\\n        }\\n        for(int arr[] :roads){\\n            list.get(arr[0]).add(new Node(arr[1],arr[2]));\\n            list.get(arr[1]).add(new Node(arr[0],arr[2]));\\n        }\\n        int min = diskshtra(list,n,0);\\n        return min;  \\n        \\n    }\\n    public int diskshtra(ArrayList<ArrayList<Node>> adj,int n,int start){\\n        int mod = 1_000_000_007;\\n        long dis[]= new long[n];\\n        long ways[]= new long[n];\\n        ways[0]=1;\\n        Arrays.fill(dis,Long.MAX_VALUE);\\n        PriorityQueue<Node> pq = new PriorityQueue<Node>(n,new Node());\\n        dis[start]=0;\\n        pq.add(new Node(start,0));\\n        while(pq.size()>0){\\n            Node node = pq.poll();\\n            if(node.val>dis[node.dis]){\\n                continue;\\n            }\\n            for(Node nextnode:adj.get(node.dis)){\\n                if(dis[node.dis]+nextnode.val<dis[nextnode.dis]){\\n                    dis[nextnode.dis]= dis[node.dis]+nextnode.val;\\n                    ways[nextnode.dis]= ways[node.dis]%mod;\\n                    pq.add(new Node(nextnode.dis,dis[nextnode.dis]));\\n                }\\n                else if(dis[node.dis]+nextnode.val==dis[nextnode.dis]){\\n                    ways[nextnode.dis]= (ways[node.dis]+ways[nextnode.dis])%mod;\\n                }\\n                \\n            }\\n        }\\n        return (int)ways[n-1];\\n        \\n    }\\n    \\n}\\n\\nclass Node implements Comparator<Node>{\\n    int dis;\\n    long val;\\n    Node(){}\\n    public Node(int dis,long val){\\n        this.dis=dis;\\n        this.val=val;\\n    }\\n    public int compare(Node node1, Node node2) \\n    { \\n        if (node1.val < node2.val) \\n            return -1; \\n        if (node1.val > node2.val) \\n            return 1; \\n        return 0; \\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417769,
                "title": "c-dijkstra",
                "content": "```\\nclass Solution {\\n    const int MOD = 1e9+7;\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> mat(n);\\n        for (vector<int> road : roads) {\\n            mat[road[0]].push_back(make_pair(road[1], road[2]));\\n            mat[road[1]].push_back(make_pair(road[0], road[2]));\\n        }\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        vector<long long> dist(n, LLONG_MAX), count(n);\\n        pq.push(make_pair(0, 0));\\n        dist[0] = 0; count[0] = 1;\\n        while (!pq.empty()) {\\n            int u = pq.top().second;\\n            if (u==n-1)\\n                break;\\n            pq.pop();\\n            for (pair<int, int> dest : mat[u]) {\\n                int v = dest.first;\\n                long long weight = dest.second;\\n                if (dist[v] == dist[u] + weight) {\\n                    count[v] = (count[v] + count[u]) % MOD;\\n                }\\n                else if (dist[v] > dist[u] + weight) {\\n                    dist[v] = dist[u] + weight;\\n                    pq.push(make_pair(dist[v], v));\\n                    count[v] = count[u];\\n                }\\n            }\\n        }\\n        return count[n-1] % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int MOD = 1e9+7;\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> mat(n);\\n        for (vector<int> road : roads) {\\n            mat[road[0]].push_back(make_pair(road[1], road[2]));\\n            mat[road[1]].push_back(make_pair(road[0], road[2]));\\n        }\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        vector<long long> dist(n, LLONG_MAX), count(n);\\n        pq.push(make_pair(0, 0));\\n        dist[0] = 0; count[0] = 1;\\n        while (!pq.empty()) {\\n            int u = pq.top().second;\\n            if (u==n-1)\\n                break;\\n            pq.pop();\\n            for (pair<int, int> dest : mat[u]) {\\n                int v = dest.first;\\n                long long weight = dest.second;\\n                if (dist[v] == dist[u] + weight) {\\n                    count[v] = (count[v] + count[u]) % MOD;\\n                }\\n                else if (dist[v] > dist[u] + weight) {\\n                    dist[v] = dist[u] + weight;\\n                    pq.push(make_pair(dist[v], v));\\n                    count[v] = count[u];\\n                }\\n            }\\n        }\\n        return count[n-1] % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417658,
                "title": "failing-last-test-case",
                "content": "I haveslightly modified dijikstra and tried to find the number of shortest path,but my last test case is failing and I am clueless,does anyone know why?\\n```\\nlong long mod = 1e9+7;\\nlong long maxn = 1e15;\\n\\ntypedef pair<long long,long long> myPair;\\nclass Graph{\\n    int V;\\n    list<myPair> *adj;\\npublic:\\n    Graph(int V);\\n    void addEdge(int u,int v,long long w);\\n    long long shortestPath(int src);\\n    ~Graph(){\\n        delete[] adj;\\n    }\\n};\\nGraph::Graph(int V){\\n    this->V = V;\\n    adj = new list<myPair>[this->V+1];\\n}\\nvoid Graph::addEdge(int u,int v,long long w){\\n    adj[u].push_back({v,w});\\n    adj[v].push_back({u,w});\\n}\\nlong long Graph::shortestPath(int src){\\n    priority_queue<myPair,vector<myPair>,greater<myPair> > pq;\\n    vector<long long> dist(this->V+1,maxn);\\n    vector<long long> ways(this->V+1,0);\\n    //cout<<\"dist[0] and V is \"<<dist[0]<<\" \"<<this->V<<endl;\\n    ways[src] = 1;\\n    dist[src] = 0;\\n    list<myPair>::iterator it;\\n    pq.push({0ll,src});\\n    while(!pq.empty()){\\n        int u = pq.top().second;\\n        pq.pop();\\n        for(it = adj[u].begin();it!=adj[u].end();++it){\\n            int v = it->first;\\n            long long w = it->second;\\n            if(dist[v] == dist[u] + w){\\n                ways[v] = (ways[u] + ways[v])%mod;\\n            }\\n            else if(dist[v] > dist[u] + w){\\n                dist[v] = dist[u] + w;\\n                pq.push({dist[v],v});\\n                ways[v] = ways[u];\\n            }\\n        }\\n    }\\n    return ways[this->V-1]%mod;\\n}\\n\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        Graph g(n);\\n        for(auto p:roads){\\n            //cout<<\"p[0] p[1] and p[2] is \"<<p[0]<<\" \"<<p[1]<<\" \"<<p[2]<<endl;\\n            g.addEdge(p[0],p[1],p[2]);\\n        }\\n        return g.shortestPath(0)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlong long mod = 1e9+7;\\nlong long maxn = 1e15;\\n\\ntypedef pair<long long,long long> myPair;\\nclass Graph{\\n    int V;\\n    list<myPair> *adj;\\npublic:\\n    Graph(int V);\\n    void addEdge(int u,int v,long long w);\\n    long long shortestPath(int src);\\n    ~Graph(){\\n        delete[] adj;\\n    }\\n};\\nGraph::Graph(int V){\\n    this->V = V;\\n    adj = new list<myPair>[this->V+1];\\n}\\nvoid Graph::addEdge(int u,int v,long long w){\\n    adj[u].push_back({v,w});\\n    adj[v].push_back({u,w});\\n}\\nlong long Graph::shortestPath(int src){\\n    priority_queue<myPair,vector<myPair>,greater<myPair> > pq;\\n    vector<long long> dist(this->V+1,maxn);\\n    vector<long long> ways(this->V+1,0);\\n    //cout<<\"dist[0] and V is \"<<dist[0]<<\" \"<<this->V<<endl;\\n    ways[src] = 1;\\n    dist[src] = 0;\\n    list<myPair>::iterator it;\\n    pq.push({0ll,src});\\n    while(!pq.empty()){\\n        int u = pq.top().second;\\n        pq.pop();\\n        for(it = adj[u].begin();it!=adj[u].end();++it){\\n            int v = it->first;\\n            long long w = it->second;\\n            if(dist[v] == dist[u] + w){\\n                ways[v] = (ways[u] + ways[v])%mod;\\n            }\\n            else if(dist[v] > dist[u] + w){\\n                dist[v] = dist[u] + w;\\n                pq.push({dist[v],v});\\n                ways[v] = ways[u];\\n            }\\n        }\\n    }\\n    return ways[this->V-1]%mod;\\n}\\n\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        Graph g(n);\\n        for(auto p:roads){\\n            //cout<<\"p[0] p[1] and p[2] is \"<<p[0]<<\" \"<<p[1]<<\" \"<<p[2]<<endl;\\n            g.addEdge(p[0],p[1],p[2]);\\n        }\\n        return g.shortestPath(0)%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3967751,
                "title": "kotlin-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    fun countPaths(n: Int, roads: Array<IntArray>): Int {\\n        val time = Array(n){Long.MAX_VALUE}\\n        val count = Array<Long>(n){0}\\n        val graph = Array(n){ArrayList<Pair<Int, Long>>()}\\n        for(edge in roads){\\n            graph[edge[0]].add(Pair(edge[1], edge[2].toLong()))\\n            graph[edge[1]].add(Pair(edge[0], edge[2].toLong()))\\n        }\\n        val mod = (1e9+7).toLong()\\n        val q = PriorityQueue<Pair<Long, Int>>(){a,b -> (a.first - b.first).toInt()}\\n        q.offer(Pair(0,0))\\n        time[0] = 0\\n        count[0] = 1\\n        while(q.isNotEmpty()){\\n            val p = q.poll()\\n            for(adjNode in graph[p.second]){\\n                val node = adjNode.first\\n                val t = adjNode.second\\n                if(t + p.first < time[node]){\\n                    time[node] = t + p.first\\n                    count[node] = count[p.second]\\n                    q.offer(Pair(time[node], node))\\n                }\\n                else if(t + p.first == time[node]){\\n                    count[node] = (count[node] + count[p.second]) % mod \\n                }\\n            }\\n        }\\n        return count[n-1].toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countPaths(n: Int, roads: Array<IntArray>): Int {\\n        val time = Array(n){Long.MAX_VALUE}\\n        val count = Array<Long>(n){0}\\n        val graph = Array(n){ArrayList<Pair<Int, Long>>()}\\n        for(edge in roads){\\n            graph[edge[0]].add(Pair(edge[1], edge[2].toLong()))\\n            graph[edge[1]].add(Pair(edge[0], edge[2].toLong()))\\n        }\\n        val mod = (1e9+7).toLong()\\n        val q = PriorityQueue<Pair<Long, Int>>(){a,b -> (a.first - b.first).toInt()}\\n        q.offer(Pair(0,0))\\n        time[0] = 0\\n        count[0] = 1\\n        while(q.isNotEmpty()){\\n            val p = q.poll()\\n            for(adjNode in graph[p.second]){\\n                val node = adjNode.first\\n                val t = adjNode.second\\n                if(t + p.first < time[node]){\\n                    time[node] = t + p.first\\n                    count[node] = count[p.second]\\n                    q.offer(Pair(time[node], node))\\n                }\\n                else if(t + p.first == time[node]){\\n                    count[node] = (count[node] + count[p.second]) % mod \\n                }\\n            }\\n        }\\n        return count[n-1].toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912447,
                "title": "all-test-cases-new-updated-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int MOD = (int)(1e9 +7);\\n    public int countPaths(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> list = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<roads.length;i++){\\n            list.get(roads[i][0]).add(new Pair(roads[i][1],(long) roads[i][2]));\\n            list.get(roads[i][1]).add(new Pair(roads[i][0], (long)roads[i][2]));\\n        }\\n        PriorityQueue<Pair> pq= new PriorityQueue<>((a,b)->Long.compare( a.d,b.d));\\n        pq.add(new Pair(0,0));\\n        long[] dist= new long[n];\\n        Arrays.fill(dist, Long.MAX_VALUE/2);\\n        dist[0]=0;\\n        int[] ways = new int[n];\\n        ways[0]=1;\\n       // int minD=Integer.MAX_VALUE;\\n        while(!pq.isEmpty()){\\n            Pair p = pq.peek();\\n            int node =p.node;\\n            long d=p.d;\\n            pq.poll();\\n            for(Pair np: list.get(node)){\\n                int newNode = np.node;\\n                long newD =np.d;\\n                if(d+newD<dist[newNode]){\\n                    ways[newNode]= ways[node];\\n                    dist[newNode]=d+newD;\\n                    pq.add(new Pair(newNode,d+newD));\\n                }\\n                else if(d+newD==dist[newNode]){\\n                   ways[newNode]=(ways[newNode]  + ways[node])%MOD;\\n                }    \\n            }\\n        }\\n        return ways[n-1]%MOD;\\n    }\\n}\\n        \\nclass Pair{\\n    int node;\\n    long d;\\n    Pair(){\\n\\n    }\\n    Pair(int node, long d){\\n        this.node=node;\\n        this.d=d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int MOD = (int)(1e9 +7);\\n    public int countPaths(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> list = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<roads.length;i++){\\n            list.get(roads[i][0]).add(new Pair(roads[i][1],(long) roads[i][2]));\\n            list.get(roads[i][1]).add(new Pair(roads[i][0], (long)roads[i][2]));\\n        }\\n        PriorityQueue<Pair> pq= new PriorityQueue<>((a,b)->Long.compare( a.d,b.d));\\n        pq.add(new Pair(0,0));\\n        long[] dist= new long[n];\\n        Arrays.fill(dist, Long.MAX_VALUE/2);\\n        dist[0]=0;\\n        int[] ways = new int[n];\\n        ways[0]=1;\\n       // int minD=Integer.MAX_VALUE;\\n        while(!pq.isEmpty()){\\n            Pair p = pq.peek();\\n            int node =p.node;\\n            long d=p.d;\\n            pq.poll();\\n            for(Pair np: list.get(node)){\\n                int newNode = np.node;\\n                long newD =np.d;\\n                if(d+newD<dist[newNode]){\\n                    ways[newNode]= ways[node];\\n                    dist[newNode]=d+newD;\\n                    pq.add(new Pair(newNode,d+newD));\\n                }\\n                else if(d+newD==dist[newNode]){\\n                   ways[newNode]=(ways[newNode]  + ways[node])%MOD;\\n                }    \\n            }\\n        }\\n        return ways[n-1]%MOD;\\n    }\\n}\\n        \\nclass Pair{\\n    int node;\\n    long d;\\n    Pair(){\\n\\n    }\\n    Pair(int node, long d){\\n        this.node=node;\\n        this.d=d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762931,
                "title": "application-of-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem Statement says paths to reach from ** source to destination**. These are the keywords of dijkstra algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApply dijkastra algorithm along with a modification since with dijkastra we can find the shortest time to reach from source to destination , hence  we have to use an array to keep track of no of ways to reach at every node. Total no of ways to reach from source to destination is sum of all ways it takes to reach destination thate is sum of all ways it takes to reach nodes of its path.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(ElogV)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(|V|+|E|)\\n\\n# Code\\n```\\nclass Solution {\\n    class pair{\\n        int a,b;\\n        pair(int a,int b){\\n            this.a=a;\\n            this.b=b;\\n        }\\n    }\\n    public int countPaths(int n, int[][] roads) \\n    {\\n        int dist[]=new int[n];\\n        ArrayList<ArrayList<pair>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n//making an adjacency list for undirected graph....\\n//as if we can reach from A to B via path C \\n//then we can also reach from B to A via same path C\\n        for(int i=0;i<roads.length;i++)\\n        {\\n          adj.get(roads[i][1]).add(new pair(roads[i][0],roads[i][2]));\\n          adj.get(roads[i][0]).add(new pair(roads[i][1],roads[i][2]));\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            dist[i]=Integer.MAX_VALUE;\\n        }\\n        dist[0]=0;\\n        PriorityQueue<pair>q=new PriorityQueue<>((x,y)->x.b-y.b);\\n        int ways[]=new int[n];\\n        ways[0]=1;\\n        q.offer(new pair(0,0));\\n        while(!q.isEmpty())\\n        {\\n            pair t=q.poll();\\n            for(int i=0;i<adj.get(t.a).size();i++)\\n            {\\n               if(dist[adj.get(t.a).get(i).a]>t.b+adj.get(t.a).get(i).b)\\n               {\\n                  dist[adj.get(t.a).get(i).a]=t.b+adj.get(t.a).get(i).b;\\n                  ways[adj.get(t.a).get(i).a]=ways[t.a];\\n                  q.offer(new pair(adj.get(t.a).get(i).a,dist[adj.get(t.a).get(i).a]));\\n                }\\n               else if(dist[adj.get(t.a).get(i).a]==t.b+adj.get(t.a).get(i).b)\\n               {\\n                 ways[adj.get(t.a).get(i).a]= (ways[adj.get(t.a).get(i).a]+ways[t.a])%1000000007;\\n               }\\n            }\\n        }\\n        return ways[n-1]%1000000007;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class pair{\\n        int a,b;\\n        pair(int a,int b){\\n            this.a=a;\\n            this.b=b;\\n        }\\n    }\\n    public int countPaths(int n, int[][] roads) \\n    {\\n        int dist[]=new int[n];\\n        ArrayList<ArrayList<pair>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n//making an adjacency list for undirected graph....\\n//as if we can reach from A to B via path C \\n//then we can also reach from B to A via same path C\\n        for(int i=0;i<roads.length;i++)\\n        {\\n          adj.get(roads[i][1]).add(new pair(roads[i][0],roads[i][2]));\\n          adj.get(roads[i][0]).add(new pair(roads[i][1],roads[i][2]));\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            dist[i]=Integer.MAX_VALUE;\\n        }\\n        dist[0]=0;\\n        PriorityQueue<pair>q=new PriorityQueue<>((x,y)->x.b-y.b);\\n        int ways[]=new int[n];\\n        ways[0]=1;\\n        q.offer(new pair(0,0));\\n        while(!q.isEmpty())\\n        {\\n            pair t=q.poll();\\n            for(int i=0;i<adj.get(t.a).size();i++)\\n            {\\n               if(dist[adj.get(t.a).get(i).a]>t.b+adj.get(t.a).get(i).b)\\n               {\\n                  dist[adj.get(t.a).get(i).a]=t.b+adj.get(t.a).get(i).b;\\n                  ways[adj.get(t.a).get(i).a]=ways[t.a];\\n                  q.offer(new pair(adj.get(t.a).get(i).a,dist[adj.get(t.a).get(i).a]));\\n                }\\n               else if(dist[adj.get(t.a).get(i).a]==t.b+adj.get(t.a).get(i).b)\\n               {\\n                 ways[adj.get(t.a).get(i).a]= (ways[adj.get(t.a).get(i).a]+ways[t.a])%1000000007;\\n               }\\n            }\\n        }\\n        return ways[n-1]%1000000007;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687605,
                "title": "straightforward-python-dijkstra-s",
                "content": "\\n\\n# Code\\n```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n\\n        adj = collections.defaultdict(list)\\n\\n        for r in roads:\\n            adj[r[0]].append((r[1], r[2]))\\n            adj[r[1]].append((r[0], r[2]))\\n        \\n        heap = []\\n\\n        heapify(heap)\\n        heappush(heap, (0, 0))\\n\\n        dist = [float(\\'inf\\')] * n\\n        dist [0] = 0\\n        ways = [0] * n\\n        ways[0] = 1 # ways to visit 0 is 1 by default\\n        MOD = 10**9 + 7\\n\\n        while heap:\\n            di, node = heappop(heap)\\n\\n            for nn in adj[node]:\\n                adj_node = nn[0]\\n                adj_dist = nn[1]\\n\\n                if di + adj_dist < dist[adj_node]:\\n                    ways[adj_node] = ways[node]\\n                    dist[adj_node] = di + adj_dist\\n                    heappush(heap, (di + adj_dist, adj_node))\\n                elif di + adj_dist == dist[adj_node]:\\n                    ways[adj_node] = (ways[adj_node] + ways[node])%MOD\\n    \\n        return ways[n-1] % MOD\\n\\n\\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n\\n        adj = collections.defaultdict(list)\\n\\n        for r in roads:\\n            adj[r[0]].append((r[1], r[2]))\\n            adj[r[1]].append((r[0], r[2]))\\n        \\n        heap = []\\n\\n        heapify(heap)\\n        heappush(heap, (0, 0))\\n\\n        dist = [float(\\'inf\\')] * n\\n        dist [0] = 0\\n        ways = [0] * n\\n        ways[0] = 1 # ways to visit 0 is 1 by default\\n        MOD = 10**9 + 7\\n\\n        while heap:\\n            di, node = heappop(heap)\\n\\n            for nn in adj[node]:\\n                adj_node = nn[0]\\n                adj_dist = nn[1]\\n\\n                if di + adj_dist < dist[adj_node]:\\n                    ways[adj_node] = ways[node]\\n                    dist[adj_node] = di + adj_dist\\n                    heappush(heap, (di + adj_dist, adj_node))\\n                elif di + adj_dist == dist[adj_node]:\\n                    ways[adj_node] = (ways[adj_node] + ways[node])%MOD\\n    \\n        return ways[n-1] % MOD\\n\\n\\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676168,
                "title": "simple-and-easy-c-solution-using-dijkstra",
                "content": "# Complexity\\n- Time complexity:O(ElogV)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n];\\n        for(auto it:roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,\\n        greater<pair<long long,long long>>>pq;\\n        int mod=(int)1e9+7;\\n        vector<long long>dist(n,1e18),ways(n,0);\\n        pq.push({0,0});\\n        dist[0]=0;\\n        ways[0]=1;\\n        while(!pq.empty())\\n        {\\n            long long dis=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[node])\\n            {\\n                int adjNode=it.first;\\n                long long edw=it.second;\\n                if(dis+edw<dist[adjNode])\\n                {\\n                    dist[adjNode]=dis+edw;\\n                    pq.push({dis+edw,adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if(dis+edw==dist[adjNode])\\n                {\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n];\\n        for(auto it:roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,\\n        greater<pair<long long,long long>>>pq;\\n        int mod=(int)1e9+7;\\n        vector<long long>dist(n,1e18),ways(n,0);\\n        pq.push({0,0});\\n        dist[0]=0;\\n        ways[0]=1;\\n        while(!pq.empty())\\n        {\\n            long long dis=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[node])\\n            {\\n                int adjNode=it.first;\\n                long long edw=it.second;\\n                if(dis+edw<dist[adjNode])\\n                {\\n                    dist[adjNode]=dis+edw;\\n                    pq.push({dis+edw,adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if(dis+edw==dist[adjNode])\\n                {\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428579,
                "title": "bellman-ford-map-c-slow-but-it-is-what-it-is",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nconst int mod = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n\\n        if(n == 1) return 1;\\n\\n        vector<long long> dist(n , LLONG_MAX);\\n\\n        vector<vector<long long>> cnt(n , vector<long long> (n + 1 , 0));\\n        unordered_map<long long , int> ans;\\n        cnt[0][0] = 1;\\n\\n        dist[0] = 0;\\n\\n        for(int i = 1 ; i <= n ; i++) {\\n            vector<long long> temp = dist;\\n\\n            int update = 0;\\n            for(auto road : roads) {\\n                int u = road[0] , v = road[1] , w = road[2];\\n\\n                if(dist[u] != LLONG_MAX && temp[v] >= dist[u] + w) {\\n                    if(temp[v] > dist[u] + w) {\\n                        cnt[v][i] = cnt[u][i - 1];\\n                        // update = 1;\\n                    }\\n                    else if(temp[v] == dist[u] + w) {\\n                        cnt[v][i] = (cnt[v][i] +  cnt[u][i - 1]) % mod;\\n                    }\\n                    temp[v] = dist[u] + w;\\n                }\\n\\n                else if(dist[v] != LLONG_MAX && temp[u] >= dist[v] + w) {\\n                    if(temp[u] > dist[v] + w) {\\n                        cnt[u][i] = cnt[v][i - 1];\\n                        // update = 1;\\n                    }\\n                    else if(temp[u] == dist[v] + w) {\\n                        cnt[u][i] += cnt[v][i - 1] % mod;\\n                        cnt[u][i] %= mod;\\n                    }\\n                    temp[u] = dist[v] + w;\\n                }\\n            }\\n\\n            dist = temp;\\n           \\n            ans[dist[n - 1]] = (ans[dist[n - 1]] +  cnt[n - 1][i]) % mod;\\n            \\n\\n        }\\n\\n        return ans[dist[n - 1]];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst int mod = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n\\n        if(n == 1) return 1;\\n\\n        vector<long long> dist(n , LLONG_MAX);\\n\\n        vector<vector<long long>> cnt(n , vector<long long> (n + 1 , 0));\\n        unordered_map<long long , int> ans;\\n        cnt[0][0] = 1;\\n\\n        dist[0] = 0;\\n\\n        for(int i = 1 ; i <= n ; i++) {\\n            vector<long long> temp = dist;\\n\\n            int update = 0;\\n            for(auto road : roads) {\\n                int u = road[0] , v = road[1] , w = road[2];\\n\\n                if(dist[u] != LLONG_MAX && temp[v] >= dist[u] + w) {\\n                    if(temp[v] > dist[u] + w) {\\n                        cnt[v][i] = cnt[u][i - 1];\\n                        // update = 1;\\n                    }\\n                    else if(temp[v] == dist[u] + w) {\\n                        cnt[v][i] = (cnt[v][i] +  cnt[u][i - 1]) % mod;\\n                    }\\n                    temp[v] = dist[u] + w;\\n                }\\n\\n                else if(dist[v] != LLONG_MAX && temp[u] >= dist[v] + w) {\\n                    if(temp[u] > dist[v] + w) {\\n                        cnt[u][i] = cnt[v][i - 1];\\n                        // update = 1;\\n                    }\\n                    else if(temp[u] == dist[v] + w) {\\n                        cnt[u][i] += cnt[v][i - 1] % mod;\\n                        cnt[u][i] %= mod;\\n                    }\\n                    temp[u] = dist[v] + w;\\n                }\\n            }\\n\\n            dist = temp;\\n           \\n            ans[dist[n - 1]] = (ans[dist[n - 1]] +  cnt[n - 1][i]) % mod;\\n            \\n\\n        }\\n\\n        return ans[dist[n - 1]];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293093,
                "title": "simple-c-bfs-solution-using-dijkstra-s-algorithm",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int countPaths(int n, vector<vector < int>> &roads)\\n        {\\n            int mod = 1e9 + 7;\\n            vector<pair<int, long long>> adj[n];\\n            for (int i = 0; i < roads.size(); i++)\\n            {\\n               \\tadj[roads[i][0]].push_back({ roads[i][1],roads[i][2] });\\n               \\tadj[roads[i][1]].push_back({ roads[i][0],roads[i][2] });\\n            }\\n            vector<long long> distance(n, LONG_MAX);\\n            vector<int> ways(n, 0);\\n            priority_queue<pair<long long, int>, vector< pair<long long, int>>, greater<pair<long long, int>>> heap;\\n           \\theap.push({ 0,0 });\\n            distance[0] = 0;\\n            ways[0] = 1;\\n            while (heap.size())\\n            {\\n                int v = heap.top().second;\\n                long long dist = heap.top().first;\\n                heap.pop();\\n                for (int i = 0; i < adj[v].size(); i++)\\n                {\\n                    int node = adj[v][i].first;\\n                    long long d = adj[v][i].second + dist;\\n                    if (d < distance[node])\\n                    {\\n                        ways[node] = ways[v];\\n                        distance[node] = d;\\n                       \\theap.push({ d,node });\\n                    }\\n                    else if (d == distance[node])\\n                        ways[node] = (ways[node] + ways[v]) % mod;\\n                }\\n            }\\n            return ways[n - 1];\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int countPaths(int n, vector<vector < int>> &roads)\\n        {\\n            int mod = 1e9 + 7;\\n            vector<pair<int, long long>> adj[n];\\n            for (int i = 0; i < roads.size(); i++)\\n            {\\n               \\tadj[roads[i][0]].push_back({ roads[i][1],roads[i][2] });\\n               \\tadj[roads[i][1]].push_back({ roads[i][0],roads[i][2] });\\n            }\\n            vector<long long> distance(n, LONG_MAX);\\n            vector<int> ways(n, 0);\\n            priority_queue<pair<long long, int>, vector< pair<long long, int>>, greater<pair<long long, int>>> heap;\\n           \\theap.push({ 0,0 });\\n            distance[0] = 0;\\n            ways[0] = 1;\\n            while (heap.size())\\n            {\\n                int v = heap.top().second;\\n                long long dist = heap.top().first;\\n                heap.pop();\\n                for (int i = 0; i < adj[v].size(); i++)\\n                {\\n                    int node = adj[v][i].first;\\n                    long long d = adj[v][i].second + dist;\\n                    if (d < distance[node])\\n                    {\\n                        ways[node] = ways[v];\\n                        distance[node] = d;\\n                       \\theap.push({ d,node });\\n                    }\\n                    else if (d == distance[node])\\n                        ways[node] = (ways[node] + ways[v]) % mod;\\n                }\\n            }\\n            return ways[n - 1];\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957076,
                "title": "java-simple-and-fast-approach",
                "content": "\\n    public class Pair{\\n        int node ;\\n        int wt ;\\n        \\n        public Pair(int node  , int wt){\\n            this.node = node ;\\n            this.wt = wt ;\\n        }\\n    }\\n    \\n    public int countPaths(int n, int[][] roads) {\\n        // Making Adjency list \\n        \\n        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();\\n        for(int i=0 ;i<n ;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int [] elem :roads){\\n            graph.get(elem[0]).add(new Pair(elem[1],elem[2]));\\n            graph.get(elem[1]).add(new Pair(elem[0],elem[2]));\\n        }\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>(\\n        (a,b)->{\\n            return a.wt - b.wt;\\n        });\\n        \\n        int [] visited = new int[n];\\n        int [] ways = new int [n];\\n        Arrays.fill(visited,Integer.MAX_VALUE);\\n        pq.add(new Pair(0,0));\\n        visited[0]= 0 ;\\n        ways[0]=1;\\n        \\n        \\n        int mod = (int)Math.pow(10,9)+7;\\n        while(!pq.isEmpty()){\\n            Pair pair = pq.remove();\\n            int node = pair.node ;\\n            int wt = pair.wt ;\\n            \\n            for(int i=0 ;i<graph.get(node).size();i++){\\n                int nn = graph.get(node).get(i).node ;\\n                int nw = graph.get(node).get(i).wt;\\n                \\n                if((wt+nw) < visited[nn]){\\n                     visited[nn] = wt+nw;\\n                    pq.add(new Pair(nn,visited[nn]));\\n                    ways[nn] = ways[node];\\n                }else if((wt+nw) ==visited[nn] ){\\n                    ways[nn] = (ways[nn]+ways[node])%mod ;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n    public class Pair{\\n        int node ;\\n        int wt ;\\n        \\n        public Pair(int node  , int wt){\\n            this.node = node ;\\n            this.wt = wt ;\\n        }\\n    }\\n    \\n    public int countPaths(int n, int[][] roads) {\\n        // Making Adjency list \\n        \\n        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();\\n        for(int i=0 ;i<n ;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int [] elem :roads){\\n            graph.get(elem[0]).add(new Pair(elem[1],elem[2]));\\n            graph.get(elem[1]).add(new Pair(elem[0],elem[2]));\\n        }\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>(\\n        (a,b)->{\\n            return a.wt - b.wt;\\n        });\\n        \\n        int [] visited = new int[n];\\n        int [] ways = new int [n];\\n        Arrays.fill(visited,Integer.MAX_VALUE);\\n        pq.add(new Pair(0,0));\\n        visited[0]= 0 ;\\n        ways[0]=1;\\n        \\n        \\n        int mod = (int)Math.pow(10,9)+7;\\n        while(!pq.isEmpty()){\\n            Pair pair = pq.remove();\\n            int node = pair.node ;\\n            int wt = pair.wt ;\\n            \\n            for(int i=0 ;i<graph.get(node).size();i++){\\n                int nn = graph.get(node).get(i).node ;\\n                int nw = graph.get(node).get(i).wt;\\n                \\n                if((wt+nw) < visited[nn]){\\n                     visited[nn] = wt+nw;\\n                    pq.add(new Pair(nn,visited[nn]));\\n                    ways[nn] = ways[node];\\n                }else if((wt+nw) ==visited[nn] ){\\n                    ways[nn] = (ways[nn]+ways[node])%mod ;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 2907982,
                "title": "dijkstra-easy-n-simple-solution-c",
                "content": "Steps:\\n1) we will make the adjacency list\\n2) After that we will declare an time array (vector) with a value of INT_MAX (same as we declare a distance[n] array in dijsktra algorithm) and a vector ways which will store the number of ways to reach a particular node.\\n3) Then just apply the direct dijsktra alogrithm and while traversing in adjList[node] we will store the shortest time and the number to ways to the same node with the same shortest distance and with the same shortest time possible.\\n\\n\\n```\\n#define ll long long\\nll mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll,ll>> adj[n];\\n        for(auto &i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        \\n        \\n        \\n        vector<ll> timevec(n,1e18);\\n        vector<ll> ways(n,0);\\n        timevec[0]=0;\\n        ways[0]=1;\\n\\t\\tpriority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>>> pq;\\n        pq.push({0,0}); // distance , node\\n        \\n        while(!pq.empty()){\\n            ll time = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto i:adj[node]){\\n                ll adjNode = i.first;\\n                ll weight = i.second;\\n                \\n                if(time+weight<timevec[adjNode]){\\n                    timevec[adjNode]=time+weight;\\n                    pq.push({timevec[adjNode],adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if((time+weight)<=timevec[adjNode]){\\n                    ways[adjNode] = (ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n\\n        return ways[n-1]%mod;\\n    }\\n};\\n```\\n\\nUpvote if you like the code and explanation    \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nll mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll,ll>> adj[n];\\n        for(auto &i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        \\n        \\n        \\n        vector<ll> timevec(n,1e18);\\n        vector<ll> ways(n,0);\\n        timevec[0]=0;\\n        ways[0]=1;\\n\\t\\tpriority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>>> pq;\\n        pq.push({0,0}); // distance , node\\n        \\n        while(!pq.empty()){\\n            ll time = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto i:adj[node]){\\n                ll adjNode = i.first;\\n                ll weight = i.second;\\n                \\n                if(time+weight<timevec[adjNode]){\\n                    timevec[adjNode]=time+weight;\\n                    pq.push({timevec[adjNode],adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if((time+weight)<=timevec[adjNode]){\\n                    ways[adjNode] = (ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799732,
                "title": "rust-solution-using-dfs",
                "content": "# Code\\n```\\nuse std::collections::*;\\n\\nconst MOD:usize = 1_000_000_007;\\nconst INF:usize = 1_000_000_000_000_000;\\nfn dfs(memo:&Vec<(usize,HashSet<usize>)>, dp:&mut Vec<usize>, i:usize) -> usize {\\n  if dp[i] == INF {\\n    let mut temp = 0;\\n    for &j in &memo[i].1 {\\n      temp += dfs(memo, dp, j);\\n      temp %= MOD;\\n    }\\n    dp[i] = temp;\\n  }\\n\\n  dp[i]\\n}\\n\\nimpl Solution {\\n  pub fn count_paths(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n    let n = n as usize;\\n    let mut g = vec![vec![];n];\\n    for arr in roads {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n      let c = arr[2] as usize;\\n      g[a].push((b,c));\\n      g[b].push((a,c));\\n    }\\n\\n    \\n    let mut memo = vec![(INF,HashSet::new());n];\\n    memo[0].0 = 0;\\n    let mut stack = vec![(0,0)];\\n    while !stack.is_empty() {\\n      let mut new_stack = vec![];\\n      while let Some((ci,cv)) = stack.pop() {\\n        for &(ni, v) in &g[ci] {\\n          let nv = cv + v;\\n          if nv < memo[ni].0 {\\n            memo[ni].1 = HashSet::new();\\n            memo[ni].1.insert(ci);\\n            memo[ni].0 = nv;\\n            new_stack.push((ni,nv));\\n          } else if nv == memo[ni].0 {\\n            memo[ni].1.insert(ci);\\n          }\\n        }\\n      }\\n      stack = new_stack;\\n    }\\n\\n    let mut result = vec![INF;n];\\n    result[0] = 1;\\n    \\n    dfs(&memo, &mut result, n-1) as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nconst MOD:usize = 1_000_000_007;\\nconst INF:usize = 1_000_000_000_000_000;\\nfn dfs(memo:&Vec<(usize,HashSet<usize>)>, dp:&mut Vec<usize>, i:usize) -> usize {\\n  if dp[i] == INF {\\n    let mut temp = 0;\\n    for &j in &memo[i].1 {\\n      temp += dfs(memo, dp, j);\\n      temp %= MOD;\\n    }\\n    dp[i] = temp;\\n  }\\n\\n  dp[i]\\n}\\n\\nimpl Solution {\\n  pub fn count_paths(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n    let n = n as usize;\\n    let mut g = vec![vec![];n];\\n    for arr in roads {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n      let c = arr[2] as usize;\\n      g[a].push((b,c));\\n      g[b].push((a,c));\\n    }\\n\\n    \\n    let mut memo = vec![(INF,HashSet::new());n];\\n    memo[0].0 = 0;\\n    let mut stack = vec![(0,0)];\\n    while !stack.is_empty() {\\n      let mut new_stack = vec![];\\n      while let Some((ci,cv)) = stack.pop() {\\n        for &(ni, v) in &g[ci] {\\n          let nv = cv + v;\\n          if nv < memo[ni].0 {\\n            memo[ni].1 = HashSet::new();\\n            memo[ni].1.insert(ci);\\n            memo[ni].0 = nv;\\n            new_stack.push((ni,nv));\\n          } else if nv == memo[ni].0 {\\n            memo[ni].1.insert(ci);\\n          }\\n        }\\n      }\\n      stack = new_stack;\\n    }\\n\\n    let mut result = vec![INF;n];\\n    result[0] = 1;\\n    \\n    dfs(&memo, &mut result, n-1) as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2725113,
                "title": "stiver-cpp-best-easiest-100",
                "content": "```\\nusing ll=long long;\\nclass Solution {\\npublic:\\n    \\n    ll m=(long long)1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // code here\\n        vector<pair<ll,ll>>adj[n];\\n        \\n        \\n        for(auto itr:roads)\\n        {\\n           adj[itr[0]].push_back({itr[1],itr[2]}); \\n           adj[itr[1]].push_back({itr[0],itr[2]}); \\n        }\\n        \\n        \\n       \\n        priority_queue<\\n        pair<ll,ll>,\\n        vector<pair<ll,ll>>,\\n        greater<pair<ll,ll>>>pq;\\n        \\n        \\n        // distance node\\n        pq.push({0,0});\\n        \\n        vector<ll>paths(n,0);\\n        paths[0]=1;\\n        vector<ll>distance(n,LONG_MAX);\\n        distance[0]=0;\\n        \\n        while(!pq.empty())\\n        {\\n            \\n            ll dis=pq.top().first;\\n            ll node=pq.top().second;\\n            \\n            pq.pop();\\n            \\n            for(auto ele:adj[node])\\n            {\\n                ll n_node=ele.first;\\n                ll n_dis=ele.second;\\n                if(dis+n_dis<distance[n_node])\\n                {\\n                    distance[n_node]=(dis+n_dis);\\n                    pq.push({(dis+n_dis),n_node});\\n                    paths[n_node]=paths[node];\\n                }\\n                else if(dis+n_dis==distance[n_node])\\n                {\\n                    paths[n_node]=(paths[node]+paths[n_node])%m;\\n                }\\n            }\\n            \\n        }\\n        \\n        return paths[n-1]%m;\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing ll=long long;\\nclass Solution {\\npublic:\\n    \\n    ll m=(long long)1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // code here\\n        vector<pair<ll,ll>>adj[n];\\n        \\n        \\n        for(auto itr:roads)\\n        {\\n           adj[itr[0]].push_back({itr[1],itr[2]}); \\n           adj[itr[1]].push_back({itr[0],itr[2]}); \\n        }\\n        \\n        \\n       \\n        priority_queue<\\n        pair<ll,ll>,\\n        vector<pair<ll,ll>>,\\n        greater<pair<ll,ll>>>pq;\\n        \\n        \\n        // distance node\\n        pq.push({0,0});\\n        \\n        vector<ll>paths(n,0);\\n        paths[0]=1;\\n        vector<ll>distance(n,LONG_MAX);\\n        distance[0]=0;\\n        \\n        while(!pq.empty())\\n        {\\n            \\n            ll dis=pq.top().first;\\n            ll node=pq.top().second;\\n            \\n            pq.pop();\\n            \\n            for(auto ele:adj[node])\\n            {\\n                ll n_node=ele.first;\\n                ll n_dis=ele.second;\\n                if(dis+n_dis<distance[n_node])\\n                {\\n                    distance[n_node]=(dis+n_dis);\\n                    pq.push({(dis+n_dis),n_node});\\n                    paths[n_node]=paths[node];\\n                }\\n                else if(dis+n_dis==distance[n_node])\\n                {\\n                    paths[n_node]=(paths[node]+paths[n_node])%m;\\n                }\\n            }\\n            \\n        }\\n        \\n        return paths[n-1]%m;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664807,
                "title": "c-dijkastra-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    ~Solution(){\\n        cout<<\"swapnil\";\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<long long, long long>> adj[n];\\n        for(auto i: roads){\\n            adj[i[0]].push_back({i[1], i[2]});\\n            adj[i[1]].push_back({i[0], i[2]});\\n        }\\n        \\n        vector<long long> dis(n, LONG_MAX);\\n        vector<long long> ways(n);\\n        \\n        dis[0] = 0;\\n        ways[0] = 1;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        long long mod = 1e9+ 7;\\n        \\n        while(!pq.empty()){\\n            \\n            long long nodeWt = pq.top().first;\\n            long long node = pq.top().second;\\n            pq.pop();\\n                \\n            // if(nodeWt > dis[node]) continue;\\n            \\n            for(auto i: adj[node]){\\n                \\n                long long child = i.first;\\n                long long childWt = i.second;\\n                \\n                if(childWt + nodeWt < dis[child]){\\n                    dis[child] = childWt + nodeWt;\\n                    pq.push({dis[child], child});\\n                    ways[child] = ways[node];\\n                }\\n                else if(childWt + nodeWt == dis[child]){\\n                    ways[child] = (ways[child] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n\\n        return ways[n-1]%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ~Solution(){\\n        cout<<\"swapnil\";\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<long long, long long>> adj[n];\\n        for(auto i: roads){\\n            adj[i[0]].push_back({i[1], i[2]});\\n            adj[i[1]].push_back({i[0], i[2]});\\n        }\\n        \\n        vector<long long> dis(n, LONG_MAX);\\n        vector<long long> ways(n);\\n        \\n        dis[0] = 0;\\n        ways[0] = 1;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        long long mod = 1e9+ 7;\\n        \\n        while(!pq.empty()){\\n            \\n            long long nodeWt = pq.top().first;\\n            long long node = pq.top().second;\\n            pq.pop();\\n                \\n            // if(nodeWt > dis[node]) continue;\\n            \\n            for(auto i: adj[node]){\\n                \\n                long long child = i.first;\\n                long long childWt = i.second;\\n                \\n                if(childWt + nodeWt < dis[child]){\\n                    dis[child] = childWt + nodeWt;\\n                    pq.push({dis[child], child});\\n                    ways[child] = ways[node];\\n                }\\n                else if(childWt + nodeWt == dis[child]){\\n                    ways[child] = (ways[child] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n\\n        return ways[n-1]%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2572972,
                "title": "java-dijkstra",
                "content": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    public int countPaths(int n, int[][] roads) {\\n        HashMap<Integer, ArrayList<int[]>> map = new HashMap<>();\\n        for(int[] road: roads) {\\n            map.putIfAbsent(road[0], new ArrayList<>());\\n            map.putIfAbsent(road[1], new ArrayList<>());\\n            map.get(road[0]).add(new int[]{road[1], road[2]});\\n            map.get(road[1]).add(new int[]{road[0], road[2]});\\n        }\\n        \\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        // dist, u;\\n        q.add(new int[]{0,0});\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[0] = 0;\\n        \\n        int[] ways = new int[n];\\n        ways[0] = 1;\\n        \\n        while(q.size()>0) {\\n            int[] rem = q.remove();\\n            int u = rem[1];\\n            int old_dist = rem[0];\\n            \\n            if(map.containsKey(u)) {\\n                for(int[] list : map.get(u)) {\\n                    int t = list[1];\\n                    int v = list[0];\\n                    \\n                    int new_dist = t + old_dist;\\n                    if(new_dist < dist[v]) {\\n                        q.add(new int[]{new_dist, v});\\n                        dist[v] = new_dist;\\n                        ways[v] = ways[u];\\n                    } else if(new_dist == dist[v]) {\\n                        ways[v] += ways[u];\\n                        ways[v] %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1]%MOD;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    public int countPaths(int n, int[][] roads) {\\n        HashMap<Integer, ArrayList<int[]>> map = new HashMap<>();\\n        for(int[] road: roads) {\\n            map.putIfAbsent(road[0], new ArrayList<>());\\n            map.putIfAbsent(road[1], new ArrayList<>());\\n            map.get(road[0]).add(new int[]{road[1], road[2]});\\n            map.get(road[1]).add(new int[]{road[0], road[2]});\\n        }\\n        \\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        // dist, u;\\n        q.add(new int[]{0,0});\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[0] = 0;\\n        \\n        int[] ways = new int[n];\\n        ways[0] = 1;\\n        \\n        while(q.size()>0) {\\n            int[] rem = q.remove();\\n            int u = rem[1];\\n            int old_dist = rem[0];\\n            \\n            if(map.containsKey(u)) {\\n                for(int[] list : map.get(u)) {\\n                    int t = list[1];\\n                    int v = list[0];\\n                    \\n                    int new_dist = t + old_dist;\\n                    if(new_dist < dist[v]) {\\n                        q.add(new int[]{new_dist, v});\\n                        dist[v] = new_dist;\\n                        ways[v] = ways[u];\\n                    } else if(new_dist == dist[v]) {\\n                        ways[v] += ways[u];\\n                        ways[v] %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1]%MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374631,
                "title": "python-solution-bfs",
                "content": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(lambda:[])\\n        for road in roads:\\n            graph[road[0]].append((road[2],road[1]))\\n            graph[road[1]].append((road[2],road[0]))\\n        \\n        queue = [(0,0)]\\n        \\n        min_time = float(\\'inf\\')\\n\\n        D = {} \\n        \\n        while queue:\\n            time, top = heappop(queue)\\n            \\n            if top == n-1:\\n                min_time = min(min_time,time) \\n                D[min_time] += 1 \\n            \\n            for child in graph[top]:\\n                heappush(queue,(child[0]+time,child[1]))\\n                \\n        return D[min_time] % 10000000007",
                "solutionTags": [],
                "code": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(lambda:[])\\n        for road in roads:\\n            graph[road[0]].append((road[2],road[1]))\\n            graph[road[1]].append((road[2],road[0]))\\n        \\n        queue = [(0,0)]\\n        \\n        min_time = float(\\'inf\\')\\n\\n        D = {}",
                "codeTag": "Java"
            },
            {
                "id": 2373933,
                "title": "c-dp-dijkstra-s-solution-clean-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t#define f first    \\n\\t\\t#define s second\\n\\t\\tusing ll = long long;   \\n\\t\\tusing p = pair<ll,ll>;\\n\\t\\tconst int mod = 1e9+7;\\n\\n\\t\\tint countPaths(int n, vector<vector<int>>& roads) {\\n\\n\\t\\t\\tvector<p> g[n];\\n\\t\\t\\tfor(auto& r : roads){\\n\\t\\t\\t\\tg[r[0]].push_back({r[1],r[2]});            \\n\\t\\t\\t\\tg[r[1]].push_back({r[0],r[2]});\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<ll> dis(n,LONG_MAX), way(n,0);\\n\\t\\t\\tdis[0]=0, way[0]=1;\\n\\n\\t\\t\\tpriority_queue<p,vector<p>,greater<p>> q;\\n\\t\\t\\tq.push({dis[0],0});\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tauto cur = q.top(); q.pop();\\n\\t\\t\\t\\tint u = cur.s;\\n\\t\\t\\t\\tif(cur.f > dis[u])continue;\\n\\t\\t\\t\\tfor(auto& nei : g[u]){\\n\\t\\t\\t\\t\\tint v = nei.f;\\n\\t\\t\\t\\t\\tint w = nei.s;\\n\\t\\t\\t\\t\\tif(dis[u]+w < dis[v]) {\\n\\t\\t\\t\\t\\t\\tway[v] = way[u];\\n\\t\\t\\t\\t\\t\\tdis[v] = dis[u]+w;\\n\\t\\t\\t\\t\\t\\tq.push({dis[v],v});\\n\\t\\t\\t\\t\\t}else if(dis[u]+w == dis[v]) {\\n\\t\\t\\t\\t\\t\\tway[v]  = (way[v] + way[u]) % mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// for(auto& d : dis)cout<<d<<\\' \\';\\n\\t\\t\\treturn way[n-1] % mod;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t#define f first    \\n\\t\\t#define s second\\n\\t\\tusing ll = long long;   \\n\\t\\tusing p = pair<ll,ll>;\\n\\t\\tconst int mod = 1e9+7;\\n\\n\\t\\tint countPaths(int n, vector<vector<int>>& roads) {\\n\\n\\t\\t\\tvector<p> g[n];\\n\\t\\t\\tfor(auto& r : roads){\\n\\t\\t\\t\\tg[r[0]].push_back({r[1],r[2]}",
                "codeTag": "Java"
            },
            {
                "id": 2347321,
                "title": "modified-dijkstra-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        using pi = pair<ll,ll>;\\n        ll min_dis = LONG_MAX;\\n        vector<vector<ll>> adj[n];\\n        for(vector<int> a:roads){\\n            ll u = a[0];\\n            ll v = a[1];\\n            ll wt = a[2];\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        \\n        vector<ll> dist(n,LONG_MAX);\\n        vector<ll> ways(n);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        priority_queue<pi,vector<pi>,greater<pi>> q;\\n        q.push({0,0});\\n        while(!q.empty()){\\n            pair<ll,ll> p = q.top();\\n            q.pop();\\n            ll cur_dis = p.first;\\n            ll cur_node = p.second;\\n        \\n            for(auto arr : adj[cur_node]){\\n                ll new_dis = cur_dis + arr[1];\\n                ll new_node = arr[0];\\n                \\n                if(new_dis < dist[new_node]){\\n                    dist[new_node] = new_dis;\\n                    q.push({new_dis,new_node});\\n                    ways[new_node] = ways[cur_node];\\n                }else if(new_dis == dist[new_node]){\\n                    ways[new_node] = (ways[cur_node]%mod + ways[new_node])%mod;\\n                }\\n            }\\n        }    \\n        return ways[n-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        using pi = pair<ll,ll>;\\n        ll min_dis = LONG_MAX;\\n        vector<vector<ll>> adj[n];\\n        for(vector<int> a:roads){\\n            ll u = a[0];\\n            ll v = a[1];\\n            ll wt = a[2];\\n            adj[u].push_back({v,wt}",
                "codeTag": "Java"
            },
            {
                "id": 2241913,
                "title": "c-easy-dfs-dijkstra-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define pi pair<ll, ll>\\n    const int mod = 1e9+7;\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pi> adj[n];\\n        for(auto &e : roads){\\n            adj[e[0]].push_back({e[1], e[2]});\\n            adj[e[1]].push_back({e[0], e[2]});\\n        }\\n        priority_queue<pi, vector<pi>, greater<pi>> minh;\\n        minh.push({0, 0});\\n        vector<ll> dist(n, LONG_MAX), way(n, 0);\\n        dist[0] = 0, way[0] = 1;\\n        while(!minh.empty()){\\n            auto node = minh.top(); minh.pop();\\n            ll u = node.second;\\n            if(node.first > dist[u]) continue;\\n            for(auto &e : adj[u]){\\n                ll v = e.first;\\n                ll w = e.second;\\n                if(dist[v] == w + dist[u]){\\n                    // cout<<way[u]<<\" \"<<endl;\\n                    way[v] = (way[v] + way[u]) % mod;\\n                }\\n                else if(dist[v] > w + dist[u]){\\n                    dist[v] = w + dist[u];\\n                    way[v] = way[u];\\n                    minh.push({dist[v], v});\\n                }\\n            }\\n        }\\n        // for(auto e : dist) cout<<e<<\" \";\\n        return way[n - 1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define pi pair<ll, ll>\\n    const int mod = 1e9+7;\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pi> adj[n];\\n        for(auto &e : roads){\\n            adj[e[0]].push_back({e[1], e[2]});\\n            adj[e[1]].push_back({e[0], e[2]});\\n        }\\n        priority_queue<pi, vector<pi>, greater<pi>> minh;\\n        minh.push({0, 0});\\n        vector<ll> dist(n, LONG_MAX), way(n, 0);\\n        dist[0] = 0, way[0] = 1;\\n        while(!minh.empty()){\\n            auto node = minh.top(); minh.pop();\\n            ll u = node.second;\\n            if(node.first > dist[u]) continue;\\n            for(auto &e : adj[u]){\\n                ll v = e.first;\\n                ll w = e.second;\\n                if(dist[v] == w + dist[u]){\\n                    // cout<<way[u]<<\" \"<<endl;\\n                    way[v] = (way[v] + way[u]) % mod;\\n                }\\n                else if(dist[v] > w + dist[u]){\\n                    dist[v] = w + dist[u];\\n                    way[v] = way[u];\\n                    minh.push({dist[v], v});\\n                }\\n            }\\n        }\\n        // for(auto e : dist) cout<<e<<\" \";\\n        return way[n - 1] % mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2220500,
                "title": "c-basically-the-same-as-1786-number-of-restricted-paths-from-first-to-last-node",
                "content": "```\\n//1. use priority_queue to find out shortest dist\\n//2. use Top-Down DP to calculate the count\\n\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,double>>> mat(n,vector<pair<int,double>>());\\n        for(auto&e:roads) mat[e[0]].push_back({e[1],e[2]}), mat[e[1]].push_back({e[0],e[2]});\\n        \\n        priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>>q;\\n        q.push( {0, n-1});\\n        \\n        vector<bool>visited(n,false);\\n        vector<double> dists(n,0);\\n        \\n        while(!q.empty()) {\\n            auto t=q.top();q.pop();\\n            if(visited[t.second]) continue;\\n            \\n            visited[t.second]=true;\\n            dists[t.second]= t.first;\\n            \\n            for(auto& next: mat[t.second])\\n                if(!visited[next.first])  q.push({t.first+next.second,next.first});\\n        }\\n\\n        visited.assign(n,false);\\n        vector<int>cache(n,-1);\\n        auto minDist = dists[0];\\n        return getCount(mat,n,dists,visited,0,minDist,cache);\\n    }\\n    \\n    int getCount(vector<vector<pair<int,double>>> &mat, int n, vector<double>& dists,vector<bool>&visited, int from,double minDist,vector<int>&cache) {\\n        if(from==n-1) return 1;\\n        \\n        if(cache[from]>=0) return cache[from];\\n        visited[from]=true;\\n        int r =0;\\n        for(auto& next: mat[from])\\n            if(!visited[next.first] && dists[next.first]==(minDist-next.second))\\n              r = (r+ getCount(mat,n,dists,visited,next.first,minDist-next.second,cache))%1000000007;\\n        \\n        visited[from]=false;\\n        cache[from] = r;\\n        return r;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n//1. use priority_queue to find out shortest dist\\n//2. use Top-Down DP to calculate the count\\n\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,double>>> mat(n,vector<pair<int,double>>());\\n        for(auto&e:roads) mat[e[0]].push_back({e[1],e[2]}), mat[e[1]].push_back({e[0],e[2]});\\n        \\n        priority_queue<pair<double,int>,vector<pair<double,int>>,greater<pair<double,int>>>q;\\n        q.push( {0, n-1});\\n        \\n        vector<bool>visited(n,false);\\n        vector<double> dists(n,0);\\n        \\n        while(!q.empty()) {\\n            auto t=q.top();q.pop();\\n            if(visited[t.second]) continue;\\n            \\n            visited[t.second]=true;\\n            dists[t.second]= t.first;\\n            \\n            for(auto& next: mat[t.second])\\n                if(!visited[next.first])  q.push({t.first+next.second,next.first});\\n        }\\n\\n        visited.assign(n,false);\\n        vector<int>cache(n,-1);\\n        auto minDist = dists[0];\\n        return getCount(mat,n,dists,visited,0,minDist,cache);\\n    }\\n    \\n    int getCount(vector<vector<pair<int,double>>> &mat, int n, vector<double>& dists,vector<bool>&visited, int from,double minDist,vector<int>&cache) {\\n        if(from==n-1) return 1;\\n        \\n        if(cache[from]>=0) return cache[from];\\n        visited[from]=true;\\n        int r =0;\\n        for(auto& next: mat[from])\\n            if(!visited[next.first] && dists[next.first]==(minDist-next.second))\\n              r = (r+ getCount(mat,n,dists,visited,next.first,minDist-next.second,cache))%1000000007;\\n        \\n        visited[from]=false;\\n        cache[from] = r;\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153670,
                "title": "c-dijkstra",
                "content": "```\\nclass Solution {\\npublic:\\n    int count = 0, MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& r) {\\n        vector<pair<long long, long long>> A[n];\\n        vector<long long> dist(n, LONG_MAX), ways(n);\\n        ways[0] = 1;\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        for(auto& a: r){\\n            A[a[0]].push_back({a[1], a[2]});\\n            A[a[1]].push_back({a[0], a[2]});\\n        }\\n        pq.push({0, 0});\\n        dist[0] = 0;\\n        while(!pq.empty()){\\n            auto [cost, node] = pq.top();\\n            pq.pop();\\n            if(cost > dist[node]) continue;\\n            for(auto& [to, time]: A[node]){\\n                if(dist[to] > time + dist[node]){\\n                    dist[to] = time + dist[node];\\n                    ways[to] = ways[node];\\n                    pq.push({dist[to], to});\\n                }\\n                else if(dist[to] == time + dist[node])\\n                    ways[to] += ways[node], ways[to] %= MOD;\\n            }\\n        }\\n        return max(1, (int)ways[n - 1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0, MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& r) {\\n        vector<pair<long long, long long>> A[n];\\n        vector<long long> dist(n, LONG_MAX), ways(n);\\n        ways[0] = 1;\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        for(auto& a: r){\\n            A[a[0]].push_back({a[1], a[2]});\\n            A[a[1]].push_back({a[0], a[2]});\\n        }\\n        pq.push({0, 0});\\n        dist[0] = 0;\\n        while(!pq.empty()){\\n            auto [cost, node] = pq.top();\\n            pq.pop();\\n            if(cost > dist[node]) continue;\\n            for(auto& [to, time]: A[node]){\\n                if(dist[to] > time + dist[node]){\\n                    dist[to] = time + dist[node];\\n                    ways[to] = ways[node];\\n                    pq.push({dist[to], to});\\n                }\\n                else if(dist[to] == time + dist[node])\\n                    ways[to] += ways[node], ways[to] %= MOD;\\n            }\\n        }\\n        return max(1, (int)ways[n - 1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148354,
                "title": "c-dijsktra",
                "content": "```cpp\\nusing ll=long long;\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<pair<ll,ll>>adj[201];\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        for(ll i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<ll>d(n,1e18);\\n        vector<ll>cnt(n,0);\\n        d[0]=0;\\n        cnt[0]=1;\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>q;\\n        q.push({d[0],0});\\n        while(!q.empty()){\\n            pair<ll,ll>curr=q.top();\\n            q.pop();\\n            ll v=curr.second;\\n            ll d_v=curr.first;\\n            if(d_v!=d[v]) continue;\\n            for(auto edge:adj[v]){\\n                ll to=edge.first;\\n                ll len=edge.second;\\n                if(d[v]+len<=d[to]){\\n                    if(d[v]+len==d[to]){\\n                        cnt[to]=(cnt[to]+cnt[v])%mod;\\n                    }\\n                    else{\\n                        d[to]=d[v]+len;\\n                        q.push({d[to],to});\\n                        cnt[to]=cnt[v]%mod;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt[n-1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<pair<ll,ll>>adj[201];\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        for(ll i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]}",
                "codeTag": "Java"
            },
            {
                "id": 2130043,
                "title": "dijkstra",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<long long,long long>>adj[n];\\n        for(auto &x:roads){\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n            //one bfs for doing the thing\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long ,long long>>>pq;\\n            pq.push({0,0});\\n            vector<long long>dist(n,LLONG_MAX);\\n            dist[0]=0;\\n            vector<long long>ways(n,0);\\n            ways[0]=1;\\n          \\n            while(!pq.empty()){\\n                pair<long long,long long>curr=pq.top();\\n                pq.pop();\\n                for(auto &x:adj[curr.second]){\\n                    if((long long)(x.second+curr.first)<(long long)dist[x.first]){\\n                        dist[x.first]=x.second+curr.first;\\n                        pq.push({dist[x.first],x.first});\\n                        ways[x.first]=ways[curr.second];\\n                    }\\n                    else if(x.second+curr.first==dist[x.first]){\\n                        ways[x.first]=(ways[x.first]+ways[curr.second])%mod;\\n                    }     \\n                } \\n            }\\n   return ways[n-1];  \\n                 \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<long long,long long>>adj[n];\\n        for(auto &x:roads){\\n            adj[x[0]].push_back({x[1],x[2]}",
                "codeTag": "Java"
            },
            {
                "id": 2106272,
                "title": "python-dijkstra-clean-short-explained",
                "content": "dist[i] denotes [least_time,total_ways] to reach ith node\\nstore time when we reach n-1 th node first time and break loop if time>shortest time to reach n-1 th node\\nThing of caution is don\\'t add path to deque when time+next_time==dist[nei], otherwise it will add extra ways by forming duplicate paths inside heap.\\n\\n```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        mod=int(1e9+7)\\n        for u,v,t in roads:\\n            graph[u].append((t,v))\\n            graph[v].append((t,u))\\n        heap=[]\\n        shortest=sys.maxsize\\n        heapq.heappush(heap,(0,0))\\n        dist=[[sys.maxsize,0]]*n\\n        dist[0]=[0,1]\\n        while heap:\\n            time,node=heapq.heappop(heap)\\n            if node==n-1:\\n                if shortest==sys.maxsize:\\n                    shortest=time\\n                continue\\n            if shortest!=sys.maxsize and time>shortest:\\n                break\\n            for next_time,nei in graph[node]:\\n                if time+next_time<=dist[nei][0]:\\n                    if time+next_time==dist[nei][0]:\\n                        dist[nei][1]+=dist[node][1]\\n                    else:\\n                        dist[nei]=[time+next_time,dist[node][1]]\\n                        heapq.heappush(heap,(time+next_time,nei))  #add path to heap only if new_path has less time\\n        return dist[n-1][1]%mod\\n            \\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        mod=int(1e9+7)\\n        for u,v,t in roads:\\n            graph[u].append((t,v))\\n            graph[v].append((t,u))\\n        heap=[]\\n        shortest=sys.maxsize\\n        heapq.heappush(heap,(0,0))\\n        dist=[[sys.maxsize,0]]*n\\n        dist[0]=[0,1]\\n        while heap:\\n            time,node=heapq.heappop(heap)\\n            if node==n-1:\\n                if shortest==sys.maxsize:\\n                    shortest=time\\n                continue\\n            if shortest!=sys.maxsize and time>shortest:\\n                break\\n            for next_time,nei in graph[node]:\\n                if time+next_time<=dist[nei][0]:\\n                    if time+next_time==dist[nei][0]:\\n                        dist[nei][1]+=dist[node][1]\\n                    else:\\n                        dist[nei]=[time+next_time,dist[node][1]]\\n                        heapq.heappush(heap,(time+next_time,nei))  #add path to heap only if new_path has less time\\n        return dist[n-1][1]%mod\\n            \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091174,
                "title": "python-dijkastras-algorithm",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        for val in roads:\\n            adj[val[0]].append([val[1],val[2]])\\n            adj[val[1]].append([val[0],val[2]])\\n        d = [[float(\"inf\"),0] for i in range(n)]\\n        d[0][0] = 0\\n        d[0][1] = 1\\n        q = []\\n        t2 = 10**9 + 7\\n        heappush(q,[0,0])\\n        while q:\\n            t = heappop(q)\\n            if t[0]>d[t[1]][0]:\\n                continue\\n            for val in adj[t[1]]:\\n                if d[t[1]][0]+val[1] < d[val[0]][0]:\\n                    d[val[0]][0] = d[t[1]][0]+val[1]\\n                    d[val[0]][1] = d[t[1]][1]%t2\\n                    heappush(q,[d[val[0]][0],val[0]])\\n                elif d[t[1]][0]+val[1] == d[val[0]][0]:\\n                    d[val[0]][1] += d[t[1]][1]%t2\\n        return d[n-1][1]%t2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        for val in roads:\\n            adj[val[0]].append([val[1],val[2]])\\n            adj[val[1]].append([val[0],val[2]])\\n        d = [[float(\"inf\"),0] for i in range(n)]\\n        d[0][0] = 0\\n        d[0][1] = 1\\n        q = []\\n        t2 = 10**9 + 7\\n        heappush(q,[0,0])\\n        while q:\\n            t = heappop(q)\\n            if t[0]>d[t[1]][0]:\\n                continue\\n            for val in adj[t[1]]:\\n                if d[t[1]][0]+val[1] < d[val[0]][0]:\\n                    d[val[0]][0] = d[t[1]][0]+val[1]\\n                    d[val[0]][1] = d[t[1]][1]%t2\\n                    heappush(q,[d[val[0]][0],val[0]])\\n                elif d[t[1]][0]+val[1] == d[val[0]][0]:\\n                    d[val[0]][1] += d[t[1]][1]%t2\\n        return d[n-1][1]%t2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992649,
                "title": "c-dijkstra-with-priority-queue",
                "content": "```\\npublic class Solution {\\n    private int dijkstra(List<int[]>[] graph, int start, int end, long[] distance){\\n        int MOD = 1000000007;\\n        int[] ways = new int[end];\\n        \\n        // set distance for source to 0\\n        distance[start] = 0;\\n        ways[start] = 1;\\n        \\n        // (src, d)\\n        var pq = new PriorityQueue<int, long>();\\n        pq.Enqueue(start, 0);\\n        \\n        while(pq.TryDequeue(out int u, out long u_d)){      \\n            \\n            foreach(var vertex in graph[u]){\\n                int v = vertex[0]; \\n                int v_t = vertex[1];\\n                \\n                if(u_d > distance[v]){\\n                    continue;\\n                }\\n                \\n                // update if distance is minimum\\n                if (distance[v] > u_d + v_t){\\n                    distance[v] = u_d + v_t;\\n                    ways[v] = ways[u];\\n                    \\n                    pq.Enqueue(v, distance[v]);\\n                }\\n                else if(distance[v] == u_d + v_t){\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }            \\n        }\\n        return ways[end - 1];\\n    }\\n    \\n    public int CountPaths(int n, int[][] roads) {\\n        int start = 0;\\n        int end = n;\\n        \\n        var graph = new List<int[]>[n];\\n        for(int i = 0; i < n; i++){\\n            graph[i] = new List<int[]>();\\n        }\\n        \\n        var distance = new long[n];\\n        // mark all distances to infinity.\\n        Array.Fill(distance, long.MaxValue);\\n        \\n        // adjacency list for un-directed graph\\n        foreach(var r in roads){\\n            int u = r[0];\\n            int v = r[1];\\n            int t = r[2];\\n            graph[u].Add(new int[]{ v, t });\\n            graph[v].Add(new int[]{ u, t });\\n        }\\n        \\n        return dijkstra(graph, start, end, distance);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    private int dijkstra(List<int[]>[] graph, int start, int end, long[] distance){\\n        int MOD = 1000000007;\\n        int[] ways = new int[end];\\n        \\n        // set distance for source to 0\\n        distance[start] = 0;\\n        ways[start] = 1;\\n        \\n        // (src, d)\\n        var pq = new PriorityQueue<int, long>();\\n        pq.Enqueue(start, 0);\\n        \\n        while(pq.TryDequeue(out int u, out long u_d)){      \\n            \\n            foreach(var vertex in graph[u]){\\n                int v = vertex[0]; \\n                int v_t = vertex[1];\\n                \\n                if(u_d > distance[v]){\\n                    continue;\\n                }\\n                \\n                // update if distance is minimum\\n                if (distance[v] > u_d + v_t){\\n                    distance[v] = u_d + v_t;\\n                    ways[v] = ways[u];\\n                    \\n                    pq.Enqueue(v, distance[v]);\\n                }\\n                else if(distance[v] == u_d + v_t){\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }            \\n        }\\n        return ways[end - 1];\\n    }\\n    \\n    public int CountPaths(int n, int[][] roads) {\\n        int start = 0;\\n        int end = n;\\n        \\n        var graph = new List<int[]>[n];\\n        for(int i = 0; i < n; i++){\\n            graph[i] = new List<int[]>();\\n        }\\n        \\n        var distance = new long[n];\\n        // mark all distances to infinity.\\n        Array.Fill(distance, long.MaxValue);\\n        \\n        // adjacency list for un-directed graph\\n        foreach(var r in roads){\\n            int u = r[0];\\n            int v = r[1];\\n            int t = r[2];\\n            graph[u].Add(new int[]{ v, t });\\n            graph[v].Add(new int[]{ u, t });\\n        }\\n        \\n        return dijkstra(graph, start, end, distance);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988020,
                "title": "c-dijstra-s-solution-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n    int N = 1e5 + 10;\\n    long long INF = 1e18;\\n    vector<pair<long, long>> g[N];\\n    vector<long long> dist(N, INF);\\n    vector<bool> vis(N, false);\\n    vector<long long> ways(N, 0);\\n        int e = roads.size(); // total edges in the graph\\n        for (int i = 0; i < e; i++)\\n        {\\n            int x, y, wt;\\n            x = roads[i][0], y = roads[i][1], wt = roads[i][2];\\n            g[x].push_back({y, wt});\\n            g[y].push_back({x, wt});\\n        }\\n    int mod = 1e9 + 7;\\n    set<pair<long, long>> pq; //{shortest_distance,to_node}\\n    pq.insert({0, 0});\\n    dist[0] = 0;\\n    ways[0] = 1;\\n    while (!pq.empty())\\n    {\\n        pair<long, long> node = *pq.begin(); // poping out node with least distance\\n        pq.erase(pq.begin());\\n        long long vertex = node.second, short_dist = node.first; // till yet short distance of a particular node\\n        if (vis[vertex] == true)\\n            continue;\\n        vis[vertex] = true;\\n        for (pair<long, long> child : g[vertex])\\n        {\\n            long long child_v = child.first, child_short_dist = child.second;\\n\\n            if ((dist[vertex] + child_short_dist) < dist[child_v])\\n            {\\n                dist[child_v] = dist[vertex] + child_short_dist;\\n                ways[child_v] = ways[vertex];\\n                pq.insert({dist[child_v], child_v});\\n            }\\n            else if ((dist[vertex] + child_short_dist) == dist[child_v])\\n            {\\n                ways[child_v] = (ways[child_v] + ways[vertex]) % mod;\\n            }\\n        }\\n    }\\n        return ways[n-1];\\n \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n    int N = 1e5 + 10;\\n    long long INF = 1e18;\\n    vector<pair<long, long>> g[N];\\n    vector<long long> dist(N, INF);\\n    vector<bool> vis(N, false);\\n    vector<long long> ways(N, 0);\\n        int e = roads.size(); // total edges in the graph\\n        for (int i = 0; i < e; i++)\\n        {\\n            int x, y, wt;\\n            x = roads[i][0], y = roads[i][1], wt = roads[i][2];\\n            g[x].push_back({y, wt});\\n            g[y].push_back({x, wt});\\n        }\\n    int mod = 1e9 + 7;\\n    set<pair<long, long>> pq; //{shortest_distance,to_node}\\n    pq.insert({0, 0});\\n    dist[0] = 0;\\n    ways[0] = 1;\\n    while (!pq.empty())\\n    {\\n        pair<long, long> node = *pq.begin(); // poping out node with least distance\\n        pq.erase(pq.begin());\\n        long long vertex = node.second, short_dist = node.first; // till yet short distance of a particular node\\n        if (vis[vertex] == true)\\n            continue;\\n        vis[vertex] = true;\\n        for (pair<long, long> child : g[vertex])\\n        {\\n            long long child_v = child.first, child_short_dist = child.second;\\n\\n            if ((dist[vertex] + child_short_dist) < dist[child_v])\\n            {\\n                dist[child_v] = dist[vertex] + child_short_dist;\\n                ways[child_v] = ways[vertex];\\n                pq.insert({dist[child_v], child_v});\\n            }\\n            else if ((dist[vertex] + child_short_dist) == dist[child_v])\\n            {\\n                ways[child_v] = (ways[child_v] + ways[vertex]) % mod;\\n            }\\n        }\\n    }\\n        return ways[n-1];\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960832,
                "title": "c-dijkstra-solution",
                "content": "```#define ll long long\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<ll,ll>>> graph(n);\\n        \\n        for(auto& road:roads){\\n            ll u = road[0];\\n            ll v = road[1];\\n            ll time = road[2];\\n            graph[u].push_back({v,time});\\n            graph[v].push_back({u,time});\\n        } \\n        return dijkstra(graph,n,0);\\n    }\\n    \\n    int dijkstra(vector<vector<pair<ll,ll>>>& graph, int n, int src){\\n        vector<ll> dist(n,LONG_MAX);//store distanceof ith vertex                   \\n        vector<ll>ways(n);//store no shortest path from source to ith vertex\\n        ways[src]=1;//intialize\\n        dist[src]=0;//intialize\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<>> minHeap;\\n        //creating min heap that store value in smaller value in parent format\\n        minHeap.push({0,0});\\n        while(!minHeap.empty()){\\n            //check top of heap and pop it\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; \\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {  //if cur node disance is not minimum\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    //push vertex distance and vertex namein heap\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % mod;\\n                }\\n            }\\n            \\n        }\\n        return ways[n-1];\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<ll,ll>>> graph(n);\\n        \\n        for(auto& road:roads){\\n            ll u = road[0];\\n            ll v = road[1];\\n            ll time = road[2];\\n            graph[u].push_back({v,time}",
                "codeTag": "Java"
            },
            {
                "id": 1872863,
                "title": "very-intuitive-and-easy-appraoch-djikstra-algo",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        int mod = (1e9+7);\\n        vector<pair<long,long>>adj[n];\\n        for(auto it: roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<long>ways(n,0);\\n        vector<long>dis(n,LONG_MAX);\\n        ways[0] = 1;\\n        dis[0]= 0;\\n        \\n        priority_queue<pair<long,long>,vector<pair<long,long>>,greater<pair<long,long>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty())\\n        {\\n            long node = pq.top().second;\\n            long dist = pq.top().first;\\n            pq.pop();\\n            \\n            for(auto it: adj[node])\\n            {\\n                long adjnode = it.first;\\n                long wt = it.second;\\n                \\n                if(dist+wt<dis[adjnode])\\n                {\\n                    dis[adjnode] = dist+wt;\\n                    ways[adjnode]=ways[node];\\n                    \\n                    pq.push({wt+dist,adjnode});\\n                }\\n                else if(dist+wt==dis[adjnode])\\n                {\\n                    ways[adjnode]=( ways[adjnode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        for(auto it: ways)\\n        {\\n            cout<<it<<\" \";\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        int mod = (1e9+7);\\n        vector<pair<long,long>>adj[n];\\n        for(auto it: roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<long>ways(n,0);\\n        vector<long>dis(n,LONG_MAX);\\n        ways[0] = 1;\\n        dis[0]= 0;\\n        \\n        priority_queue<pair<long,long>,vector<pair<long,long>>,greater<pair<long,long>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty())\\n        {\\n            long node = pq.top().second;\\n            long dist = pq.top().first;\\n            pq.pop();\\n            \\n            for(auto it: adj[node])\\n            {\\n                long adjnode = it.first;\\n                long wt = it.second;\\n                \\n                if(dist+wt<dis[adjnode])\\n                {\\n                    dis[adjnode] = dist+wt;\\n                    ways[adjnode]=ways[node];\\n                    \\n                    pq.push({wt+dist,adjnode});\\n                }\\n                else if(dist+wt==dis[adjnode])\\n                {\\n                    ways[adjnode]=( ways[adjnode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        for(auto it: ways)\\n        {\\n            cout<<it<<\" \";\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1861520,
                "title": "python-dijkstra-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef countPaths(self, n: int, roads: List[List[int]]) -> int:\\n\\t\\t\\t# using dijsktra algorithm-> minimum time/shortest path along a weighted graph\\n\\t\\t\\t# Time O(elogv), Space O(v)\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tfor u,v,t in roads:\\n\\t\\t\\t\\tgraph[u].append((v,t))\\n\\t\\t\\t\\tgraph[v].append((u,t))\\n\\n\\t\\t\\ttimes = [sys.maxsize] * n\\n\\t\\t\\tways = [0] *n\\n\\t\\t\\ttimes[0] = 0\\n\\t\\t\\tways[0] = 1\\n\\n\\t\\t\\thp = [[0,0]] #shortest time, node\\n\\n\\t\\t\\twhile hp:\\n\\t\\t\\t\\tcur_time, cur_node = heappop(hp)\\n\\n\\t\\t\\t\\tfor v,t in graph[cur_node]:\\n\\t\\t\\t\\t\\tif cur_time+t < times[v]:\\n\\t\\t\\t\\t\\t\\ttimes[v] = cur_time+t\\n\\t\\t\\t\\t\\t\\theappush(hp, [cur_time+t, v])\\n\\t\\t\\t\\t\\t\\tways[v] = ways[cur_node]\\n\\t\\t\\t\\t\\telif cur_time+t == times[v]:\\n\\t\\t\\t\\t\\t\\tways[v] += ways[cur_node]\\n\\n\\t\\t\\treturn ways[-1] % mod",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countPaths(self, n: int, roads: List[List[int]]) -> int:\\n\\t\\t\\t# using dijsktra algorithm-> minimum time/shortest path along a weighted graph\\n\\t\\t\\t# Time O(elogv), Space O(v)\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tfor u,v,t in roads:\\n\\t\\t\\t\\tgraph[u].append((v,t))\\n\\t\\t\\t\\tgraph[v].append((u,t))\\n\\n\\t\\t\\ttimes = [sys.maxsize] * n\\n\\t\\t\\tways = [0] *n\\n\\t\\t\\ttimes[0] = 0\\n\\t\\t\\tways[0] = 1\\n\\n\\t\\t\\thp = [[0,0]] #shortest time, node\\n\\n\\t\\t\\twhile hp:\\n\\t\\t\\t\\tcur_time, cur_node = heappop(hp)\\n\\n\\t\\t\\t\\tfor v,t in graph[cur_node]:\\n\\t\\t\\t\\t\\tif cur_time+t < times[v]:\\n\\t\\t\\t\\t\\t\\ttimes[v] = cur_time+t\\n\\t\\t\\t\\t\\t\\theappush(hp, [cur_time+t, v])\\n\\t\\t\\t\\t\\t\\tways[v] = ways[cur_node]\\n\\t\\t\\t\\t\\telif cur_time+t == times[v]:\\n\\t\\t\\t\\t\\t\\tways[v] += ways[cur_node]\\n\\n\\t\\t\\treturn ways[-1] % mod",
                "codeTag": "Java"
            },
            {
                "id": 1858854,
                "title": "c-modified-dijkstra",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<int , int>> adj[n] ; \\n        long long modu = 1000000007  ; \\n        \\n        for (auto &it: roads) {\\n            adj[it[0]].push_back({it[1] , it[2]}) ; \\n            adj[it[1]].push_back({it[0] , it[2]}) ; \\n        }\\n        \\n        vector<long long> distance(n, LONG_MAX) ; \\n        vector<long long> PossiblePaths(n) ; \\n        \\n        int source =  0; \\n        \\n        distance[source] = 0 ;\\n        \\n        PossiblePaths[0] = 1 ;  \\n        \\n        // Priority queue to always get minimum distance vertex at top\\n        priority_queue < pair<long long , long long> , vector<pair<long long , long long>> , greater<> > Q ; \\n        \\n        Q.push({distance[source] , source}) ; \\n        \\n       while (!Q.empty()) {\\n           \\n           auto [ u_cost , u ] = Q.top() ; \\n           Q.pop() ; \\n           \\n           for (auto &adjacent_vertice: adj[u]) {\\n               \\n               auto [ v , v_cost ] = adjacent_vertice ;\\n               \\n               // Relaxation \\n               if (distance[u] + v_cost < distance[v]) \\n               {\\n                   distance[v] = distance[u] + v_cost ; \\n                   Q.push ( { distance[v] , v } ) ;  \\n                   \\n                   PossiblePaths[v] = PossiblePaths[u] ;\\n               }\\n               else if ( distance[v] == u_cost + v_cost ) \\n               {\\n                   PossiblePaths[v] += PossiblePaths[u] ;\\n                   PossiblePaths[v] = PossiblePaths[v] % modu ; \\n               }\\n           }\\n           \\n       }\\n        \\n        return PossiblePaths[n-1] ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<int , int>> adj[n] ; \\n        long long modu = 1000000007  ; \\n        \\n        for (auto &it: roads) {\\n            adj[it[0]].push_back({it[1] , it[2]}) ; \\n            adj[it[1]].push_back({it[0] , it[2]}) ; \\n        }\\n        \\n        vector<long long> distance(n, LONG_MAX) ; \\n        vector<long long> PossiblePaths(n) ; \\n        \\n        int source =  0; \\n        \\n        distance[source] = 0 ;\\n        \\n        PossiblePaths[0] = 1 ;  \\n        \\n        // Priority queue to always get minimum distance vertex at top\\n        priority_queue < pair<long long , long long> , vector<pair<long long , long long>> , greater<> > Q ; \\n        \\n        Q.push({distance[source] , source}) ; \\n        \\n       while (!Q.empty()) {\\n           \\n           auto [ u_cost , u ] = Q.top() ; \\n           Q.pop() ; \\n           \\n           for (auto &adjacent_vertice: adj[u]) {\\n               \\n               auto [ v , v_cost ] = adjacent_vertice ;\\n               \\n               // Relaxation \\n               if (distance[u] + v_cost < distance[v]) \\n               {\\n                   distance[v] = distance[u] + v_cost ; \\n                   Q.push ( { distance[v] , v } ) ;  \\n                   \\n                   PossiblePaths[v] = PossiblePaths[u] ;\\n               }\\n               else if ( distance[v] == u_cost + v_cost ) \\n               {\\n                   PossiblePaths[v] += PossiblePaths[u] ;\\n                   PossiblePaths[v] = PossiblePaths[v] % modu ; \\n               }\\n           }\\n           \\n       }\\n        \\n        return PossiblePaths[n-1] ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771944,
                "title": "c-dijkstra-algo",
                "content": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    ll mn=0,c=0,md=1000000007;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<ll> paths(n,LONG_MAX),ways(n);\\n        vector<vector<pair<int,int>>>adj(n);\\n        for(auto&i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        paths[0]=0;\\n        ways[0]=1;\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n           auto [w,i]=pq.top();\\n           pq.pop();            \\n           for(auto& j:adj[i]){\\n               if(paths[j.first]>paths[i]+j.second){\\n                   paths[j.first]=paths[i]+j.second;\\n                   ways[j.first]=ways[i];\\n                   pq.push({paths[j.first],j.first});\\n               }\\n               else if(paths[j.first]==j.second+w){\\n                   ways[j.first]+=ways[i];\\n                   ways[j.first]%=md;\\n               }\\n           }\\n        } \\n        return ways[n-1];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    ll mn=0,c=0,md=1000000007;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<ll> paths(n,LONG_MAX),ways(n);\\n        vector<vector<pair<int,int>>>adj(n);\\n        for(auto&i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        paths[0]=0;\\n        ways[0]=1;\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n           auto [w,i]=pq.top();\\n           pq.pop();            \\n           for(auto& j:adj[i]){\\n               if(paths[j.first]>paths[i]+j.second){\\n                   paths[j.first]=paths[i]+j.second;\\n                   ways[j.first]=ways[i];\\n                   pq.push({paths[j.first],j.first});\\n               }\\n               else if(paths[j.first]==j.second+w){\\n                   ways[j.first]+=ways[i];\\n                   ways[j.first]%=md;\\n               }\\n           }\\n        } \\n        return ways[n-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758059,
                "title": "c-using-dijkstra-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n         long long mod = (1e9 + 7); \\n         vector<long long> ways(n, 0); \\n         long long maxi = 1e18; \\n         vector<long long> dist(n, maxi); \\n \\n         dist[0] =0; \\n         ways[0] =1;\\n \\n        vector<pair<long long,long long>> adj[n]; \\n        for(auto it : roads) {\\n            adj[it[0]].push_back({it[1], it[2]}); \\n            adj[it[1]].push_back({it[0], it[2]}); \\n        }\\n \\n         priority_queue<pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>>> pq;\\n        pq.push({0, 0}); \\n        while(!pq.empty()) {\\n            long long node = pq.top().second;\\n            long long dis = pq.top().first; \\n            pq.pop(); \\n \\n            for(auto it : adj[node]) {\\n                long long wt = it.second; \\n                long long adjNode = it.first; \\n                if(wt + dis < dist[adjNode]) {\\n                    dist[adjNode] = wt + dis; \\n                    ways[adjNode] = ways[node]; \\n                    pq.push({dist[adjNode], adjNode}); \\n                }\\n                else if(wt + dis == dist[adjNode]) {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod; \\n                }\\n            }\\n        }\\n        return ways[n-1]; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n         long long mod = (1e9 + 7); \\n         vector<long long> ways(n, 0); \\n         long long maxi = 1e18; \\n         vector<long long> dist(n, maxi); \\n \\n         dist[0] =0; \\n         ways[0] =1;\\n \\n        vector<pair<long long,long long>> adj[n]; \\n        for(auto it : roads) {\\n            adj[it[0]].push_back({it[1], it[2]}); \\n            adj[it[1]].push_back({it[0], it[2]}); \\n        }\\n \\n         priority_queue<pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>>> pq;\\n        pq.push({0, 0}); \\n        while(!pq.empty()) {\\n            long long node = pq.top().second;\\n            long long dis = pq.top().first; \\n            pq.pop(); \\n \\n            for(auto it : adj[node]) {\\n                long long wt = it.second; \\n                long long adjNode = it.first; \\n                if(wt + dis < dist[adjNode]) {\\n                    dist[adjNode] = wt + dis; \\n                    ways[adjNode] = ways[node]; \\n                    pq.push({dist[adjNode], adjNode}); \\n                }\\n                else if(wt + dis == dist[adjNode]) {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod; \\n                }\\n            }\\n        }\\n        return ways[n-1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727687,
                "title": "python-dijkstra-dp",
                "content": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        #build undirected graph by the roads, mapping the one city to the other city with times\\n        #use a heap to store (time, city)\\n        #use a dictionary to store the visited city\\n        #each time, pop out the top of the heap, expore the time to get to the next city\\n        #keep track of the ways to arrive each city\\n        #the number of ways to arrive current city depends on the number of ways to arrive previous city that leads to current city\\n        #if we neet the city before, but has greater time, skip it\\n        #if we meet the city before, but has the same time, add the number of previous ways to the current ways\\n        #if we meet the city before, but has the less time, update the number of ways as previous ways\\n        #O(nlogn) time and O(n) space\\n\\n        \\n        \\n        graph = defaultdict(dict)\\n        \\n        for a, b, time in roads:\\n            graph[a][b] = time\\n            graph[b][a] = time\\n        \\n        pq = [(0, 0)]\\n        seen = [float(\"inf\")]*n\\n        seen[0] = 0\\n        ways = [0]*n\\n        ways[0] = 1\\n        \\n        shortest = None\\n        while pq:\\n            time, city = heapq.heappop(pq)            \\n            for nxt in graph[city]:\\n                newTime = time + graph[city][nxt]\\n                if seen[nxt] >= newTime:\\n                    if seen[nxt] > newTime:\\n                        seen[nxt] = newTime\\n                        ways[nxt] = ways[city]\\n                        heapq.heappush(pq, (newTime, nxt))\\n                    elif seen[nxt] == newTime:\\n                        ways[nxt] += ways[city]\\n                    \\n        return ways[-1] % (10**9 + 7)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        #build undirected graph by the roads, mapping the one city to the other city with times\\n        #use a heap to store (time, city)\\n        #use a dictionary to store the visited city\\n        #each time, pop out the top of the heap, expore the time to get to the next city\\n        #keep track of the ways to arrive each city\\n        #the number of ways to arrive current city depends on the number of ways to arrive previous city that leads to current city\\n        #if we neet the city before, but has greater time, skip it\\n        #if we meet the city before, but has the same time, add the number of previous ways to the current ways\\n        #if we meet the city before, but has the less time, update the number of ways as previous ways\\n        #O(nlogn) time and O(n) space\\n\\n        \\n        \\n        graph = defaultdict(dict)\\n        \\n        for a, b, time in roads:\\n            graph[a][b] = time\\n            graph[b][a] = time\\n        \\n        pq = [(0, 0)]\\n        seen = [float(\"inf\")]*n\\n        seen[0] = 0\\n        ways = [0]*n\\n        ways[0] = 1\\n        \\n        shortest = None\\n        while pq:\\n            time, city = heapq.heappop(pq)            \\n            for nxt in graph[city]:\\n                newTime = time + graph[city][nxt]\\n                if seen[nxt] >= newTime:\\n                    if seen[nxt] > newTime:\\n                        seen[nxt] = newTime\\n                        ways[nxt] = ways[city]\\n                        heapq.heappush(pq, (newTime, nxt))\\n                    elif seen[nxt] == newTime:\\n                        ways[nxt] += ways[city]\\n                    \\n        return ways[-1] % (10**9 + 7)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643169,
                "title": "javascript-modified-dijkstra-s-algorithm-count-paths",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar countPaths = function(n, roads) {\\n    let adj = {}, dist = Array(n).fill(Infinity), minHeap = new MinHeap(), count = Array(n).fill(1);\\n    \\n    //CREATE ADJ MATRIX\\n    for(let [from, to , weight] of roads){\\n        adj[from] = adj[from] || []\\n        adj[from].push([to, weight]);\\n        adj[to] = adj[to] || []\\n        adj[to].push([from, weight]);\\n    }\\n    \\n    //PUT START IN QUEUE\\n    dist[n-1] = 0;\\n    minHeap.enqueue(n-1, 0);\\n    \\n    while(minHeap.getSize()){\\n        let [node, curDist] = minHeap.dequeue();\\n        let children = adj[node] || [];\\n        for(let [childNode, childWeight] of children){\\n\\t\\t\\n\\t\\t\\t//IF PATH ALREADY FOUND WITH THIS VALUE THEN ADD COUNT REACHED UNTIL NOW\\n            if(curDist + childWeight === dist[childNode]){\\n                count[childNode] = (count[childNode] +count[node])  % 1000000007;\\n            } //IF NOT PATH FOUND YET THEN ADD COUNT OF WAYS TO THE NODE WE CAME FROM\\n\\t\\t\\telse if(curDist + childWeight < dist[childNode]){\\n                count[childNode] = count[node];\\n                dist[childNode] = curDist + childWeight;\\n                minHeap.enqueue(childNode, dist[childNode]);\\n            }\\n        }\\n    }\\n    return count[0];\\n};\\n\\nclass MinHeap{\\n    constructor(list = []){\\n        this.tree = [null];\\n        this.list = list;\\n        this.build();\\n    }\\n    \\n    build(){\\n        for(let [val,priority] of this.list)\\n            this.enqueue(val,priority);\\n    }\\n    \\n    swap(pos1, pos2){\\n        [this.tree[pos1], this.tree[pos2]] = [this.tree[pos2],this.tree[pos1]]\\n    }\\n    \\n    enqueue(val, priority){\\n        this.tree[this.tree.length] = [val, priority];\\n        let i = this.tree.length - 1, parent = ~~(i/2);\\n        while(i > 1){\\n            if(this.tree[parent][1] > this.tree[i][1])\\n                this.swap(parent,i);\\n            i = parent;\\n            parent = ~~(i/2);\\n        }\\n    }\\n    \\n    dequeue(){\\n        let size = this.tree.length - 1, pos = 1;\\n        if(!size) return;\\n        let last = this.tree.pop(), deleted = this.tree[pos];\\n        if(!deleted && last) return last;\\n        this.tree[pos] = last;\\n        this.heapify(pos);\\n        return deleted;\\n    }\\n    \\n    heapify(pos){\\n    \\n        if(pos > this.tree.length) return;\\n        let leftPos = 2*pos, rightPos = 2*pos +1;\\n        let left = this.tree[leftPos] ? this.tree[leftPos][1] : Infinity;\\n        let right = this.tree[rightPos] ? this.tree[rightPos][1] : Infinity, minVal = null, minIndex = null;\\n        if(left < right){\\n            minVal = left;\\n            minIndex = leftPos;\\n        }else{\\n            minVal = right;\\n            minIndex = rightPos\\n        }\\n        if(this.tree[pos][1] > minVal){\\n            this.swap(pos,minIndex);\\n            this.heapify(minIndex);\\n        }\\n    }\\n    \\n    getTree(){\\n        console.log(this.tree.slice(1));\\n    }\\n    \\n    getSize(){\\n        return this.tree.length - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar countPaths = function(n, roads) {\\n    let adj = {}, dist = Array(n).fill(Infinity), minHeap = new MinHeap(), count = Array(n).fill(1);\\n    \\n    //CREATE ADJ MATRIX\\n    for(let [from, to , weight] of roads){\\n        adj[from] = adj[from] || []\\n        adj[from].push([to, weight]);\\n        adj[to] = adj[to] || []\\n        adj[to].push([from, weight]);\\n    }\\n    \\n    //PUT START IN QUEUE\\n    dist[n-1] = 0;\\n    minHeap.enqueue(n-1, 0);\\n    \\n    while(minHeap.getSize()){\\n        let [node, curDist] = minHeap.dequeue();\\n        let children = adj[node] || [];\\n        for(let [childNode, childWeight] of children){\\n\\t\\t\\n\\t\\t\\t//IF PATH ALREADY FOUND WITH THIS VALUE THEN ADD COUNT REACHED UNTIL NOW\\n            if(curDist + childWeight === dist[childNode]){\\n                count[childNode] = (count[childNode] +count[node])  % 1000000007;\\n            } //IF NOT PATH FOUND YET THEN ADD COUNT OF WAYS TO THE NODE WE CAME FROM\\n\\t\\t\\telse if(curDist + childWeight < dist[childNode]){\\n                count[childNode] = count[node];\\n                dist[childNode] = curDist + childWeight;\\n                minHeap.enqueue(childNode, dist[childNode]);\\n            }\\n        }\\n    }\\n    return count[0];\\n};\\n\\nclass MinHeap{\\n    constructor(list = []){\\n        this.tree = [null];\\n        this.list = list;\\n        this.build();\\n    }\\n    \\n    build(){\\n        for(let [val,priority] of this.list)\\n            this.enqueue(val,priority);\\n    }\\n    \\n    swap(pos1, pos2){\\n        [this.tree[pos1], this.tree[pos2]] = [this.tree[pos2],this.tree[pos1]]\\n    }\\n    \\n    enqueue(val, priority){\\n        this.tree[this.tree.length] = [val, priority];\\n        let i = this.tree.length - 1, parent = ~~(i/2);\\n        while(i > 1){\\n            if(this.tree[parent][1] > this.tree[i][1])\\n                this.swap(parent,i);\\n            i = parent;\\n            parent = ~~(i/2);\\n        }\\n    }\\n    \\n    dequeue(){\\n        let size = this.tree.length - 1, pos = 1;\\n        if(!size) return;\\n        let last = this.tree.pop(), deleted = this.tree[pos];\\n        if(!deleted && last) return last;\\n        this.tree[pos] = last;\\n        this.heapify(pos);\\n        return deleted;\\n    }\\n    \\n    heapify(pos){\\n    \\n        if(pos > this.tree.length) return;\\n        let leftPos = 2*pos, rightPos = 2*pos +1;\\n        let left = this.tree[leftPos] ? this.tree[leftPos][1] : Infinity;\\n        let right = this.tree[rightPos] ? this.tree[rightPos][1] : Infinity, minVal = null, minIndex = null;\\n        if(left < right){\\n            minVal = left;\\n            minIndex = leftPos;\\n        }else{\\n            minVal = right;\\n            minIndex = rightPos\\n        }\\n        if(this.tree[pos][1] > minVal){\\n            this.swap(pos,minIndex);\\n            this.heapify(minIndex);\\n        }\\n    }\\n    \\n    getTree(){\\n        console.log(this.tree.slice(1));\\n    }\\n    \\n    getSize(){\\n        return this.tree.length - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621448,
                "title": "dijkstra-dp-java-solution",
                "content": "**The idea is to apply dijkstra algorithm and find the shortest distance from source to every node and also keep a ```ways[]``` array to store the number of ways in which we can reach every node from the source node.**\\n\\n```\\nclass Solution {\\n    class Edge {\\n        int node;\\n        int wt;\\n        \\n        Edge(int node, int wt) {\\n            this.node = node;\\n            this.wt = wt;\\n        }\\n    }\\n    \\n    class Pair implements Comparable<Pair> {\\n        int node;\\n        int dist;\\n        \\n        Pair(int node, int dist) {\\n            this.node = node;\\n            this.dist = dist;\\n        }\\n        \\n        public int compareTo(Pair p) {\\n            return this.dist - p.dist;\\n        }\\n    }\\n    \\n    public int countPaths(int n, int[][] roads) {\\n        List<List<Edge>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            int w = road[2];\\n            \\n            graph.get(u).add(new Edge(v, w));\\n            graph.get(v).add(new Edge(u, w));\\n        }\\n        \\n        return numWays(graph, n);\\n    }\\n    \\n    private int numWays(List<List<Edge>> graph, int n) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.add(new Pair(0, 0));\\n        \\n        long[] ways = new long[n];\\n        ways[0] = 1;\\n        \\n        long[] dist = new long[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        \\n        dist[0] = 0;\\n        \\n        int MOD = 1000000007;\\n        \\n        while(!pq.isEmpty()) {\\n            Pair p = pq.remove();\\n            \\n            for(Edge e : graph.get(p.node)) {\\n                if(e.wt + p.dist < dist[e.node]) {\\n                    dist[e.node] = e.wt + p.dist;\\n                    ways[e.node] = ways[p.node];\\n                    \\n                    pq.add(new Pair(e.node, (int)dist[e.node]));\\n                }\\n                \\n                else if(e.wt + p.dist == dist[e.node])\\n                    ways[e.node] = (ways[e.node] + ways[p.node]) % MOD;\\n            }\\n        }\\n        \\n        return (int)ways[n - 1];\\n    }\\n}\\n```\\n\\n**Time complexity = O(V + E) = O(n^2)\\nSpace complexity = O(3n) -> for priority queue , dist array and ways array**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Graph",
                    "Memoization"
                ],
                "code": "```ways[]```\n```\\nclass Solution {\\n    class Edge {\\n        int node;\\n        int wt;\\n        \\n        Edge(int node, int wt) {\\n            this.node = node;\\n            this.wt = wt;\\n        }\\n    }\\n    \\n    class Pair implements Comparable<Pair> {\\n        int node;\\n        int dist;\\n        \\n        Pair(int node, int dist) {\\n            this.node = node;\\n            this.dist = dist;\\n        }\\n        \\n        public int compareTo(Pair p) {\\n            return this.dist - p.dist;\\n        }\\n    }\\n    \\n    public int countPaths(int n, int[][] roads) {\\n        List<List<Edge>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            int w = road[2];\\n            \\n            graph.get(u).add(new Edge(v, w));\\n            graph.get(v).add(new Edge(u, w));\\n        }\\n        \\n        return numWays(graph, n);\\n    }\\n    \\n    private int numWays(List<List<Edge>> graph, int n) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.add(new Pair(0, 0));\\n        \\n        long[] ways = new long[n];\\n        ways[0] = 1;\\n        \\n        long[] dist = new long[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        \\n        dist[0] = 0;\\n        \\n        int MOD = 1000000007;\\n        \\n        while(!pq.isEmpty()) {\\n            Pair p = pq.remove();\\n            \\n            for(Edge e : graph.get(p.node)) {\\n                if(e.wt + p.dist < dist[e.node]) {\\n                    dist[e.node] = e.wt + p.dist;\\n                    ways[e.node] = ways[p.node];\\n                    \\n                    pq.add(new Pair(e.node, (int)dist[e.node]));\\n                }\\n                \\n                else if(e.wt + p.dist == dist[e.node])\\n                    ways[e.node] = (ways[e.node] + ways[p.node]) % MOD;\\n            }\\n        }\\n        \\n        return (int)ways[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600182,
                "title": "why-does-this-get-tle-shouldn-t-it-be-quick-enough",
                "content": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        times = []\\n        shortest_time = float(\\'inf\\')\\n        \\n        for s, d, t in roads:\\n            graph[s].append([d, t])\\n            graph[d].append([s, t])\\n            \\n        to_explore = [[0, [0], 0]]\\n        \\n        while to_explore:\\n            v, path, time = to_explore.pop()\\n            if v == n-1:\\n                times.append(time)\\n                shortest_time = min(shortest_time, time)\\n            else:\\n                to_explore.extend([[i[0], path+[i[0]], time+i[1]] for i in graph[v] if i[0] not in path and time+i[1] <= shortest_time])\\n        return Counter(times)[min(times)]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        times = []\\n        shortest_time = float(\\'inf\\')\\n        \\n        for s, d, t in roads:\\n            graph[s].append([d, t])\\n            graph[d].append([s, t])\\n            \\n        to_explore = [[0, [0], 0]]\\n        \\n        while to_explore:\\n            v, path, time = to_explore.pop()\\n            if v == n-1:\\n                times.append(time)\\n                shortest_time = min(shortest_time, time)\\n            else:\\n                to_explore.extend([[i[0], path+[i[0]], time+i[1]] for i in graph[v] if i[0] not in path and time+i[1] <= shortest_time])\\n        return Counter(times)[min(times)]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516562,
                "title": "c-solution-using-dijkstra-list-and-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int v;\\n    list<pair<int,long int>>*ar;\\n    void addEdge(int p,int q,long int wt)\\n    {\\n        ar[p].push_back(make_pair(q,wt));\\n        ar[q].push_back(make_pair(p,wt));\\n    }\\n   int dijkstra(int src)\\n    {\\n        long int mod=1e9+7;\\n        priority_queue<pair<long int,int>,vector<pair<long int,int>>,greater<pair<long int,int>>>pq;\\n        vector<long int>dist(v,LONG_MAX);\\n        vector<bool>visited(v,false);\\n        pq.push(make_pair(0,src));\\n        dist[src]=0;\\n        \\n         vector<long>ways(v,0);      \\n        ways[0] = 1;\\n        \\n        while(!pq.empty())\\n        {\\n            int u=pq.top().second;\\n            pq.pop();\\n            if(visited[u]==true)\\n                continue;\\n            visited[u]=true;\\n           \\n            for(auto i=ar[u].begin();i!=ar[u].end();i++)\\n            {\\n                int wt=(*i).second;\\n                int s=(*i).first;\\n                if(dist[s]>wt+dist[u])\\n                {\\n                    dist[s]=wt+dist[u];\\n                   ways[s]=ways[u];\\n                    pq.push(make_pair(dist[s],s));\\n                }\\n                else if(dist[s]==wt+dist[u])\\n                {\\n                    ways[s]=(ways[s]+ways[u])%mod;\\n                }\\n                \\n            }\\n           \\n        }\\n       /*\\n        for(int i=0;i<ways.size();i++)        \\n            cout<<ways[i]<<\" \";        \\n       */\\n     return ways[v-1];\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        v=n;\\n        ar=new list<pair<int,long int>>[n];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            addEdge(roads[i][0],roads[i][1],roads[i][2]);\\n        }\\n      \\n        return   dijkstra(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int v;\\n    list<pair<int,long int>>*ar;\\n    void addEdge(int p,int q,long int wt)\\n    {\\n        ar[p].push_back(make_pair(q,wt));\\n        ar[q].push_back(make_pair(p,wt));\\n    }\\n   int dijkstra(int src)\\n    {\\n        long int mod=1e9+7;\\n        priority_queue<pair<long int,int>,vector<pair<long int,int>>,greater<pair<long int,int>>>pq;\\n        vector<long int>dist(v,LONG_MAX);\\n        vector<bool>visited(v,false);\\n        pq.push(make_pair(0,src));\\n        dist[src]=0;\\n        \\n         vector<long>ways(v,0);      \\n        ways[0] = 1;\\n        \\n        while(!pq.empty())\\n        {\\n            int u=pq.top().second;\\n            pq.pop();\\n            if(visited[u]==true)\\n                continue;\\n            visited[u]=true;\\n           \\n            for(auto i=ar[u].begin();i!=ar[u].end();i++)\\n            {\\n                int wt=(*i).second;\\n                int s=(*i).first;\\n                if(dist[s]>wt+dist[u])\\n                {\\n                    dist[s]=wt+dist[u];\\n                   ways[s]=ways[u];\\n                    pq.push(make_pair(dist[s],s));\\n                }\\n                else if(dist[s]==wt+dist[u])\\n                {\\n                    ways[s]=(ways[s]+ways[u])%mod;\\n                }\\n                \\n            }\\n           \\n        }\\n       /*\\n        for(int i=0;i<ways.size();i++)        \\n            cout<<ways[i]<<\" \";        \\n       */\\n     return ways[v-1];\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        v=n;\\n        ar=new list<pair<int,long int>>[n];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            addEdge(roads[i][0],roads[i][1],roads[i][2]);\\n        }\\n      \\n        return   dijkstra(0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1497898,
                "title": "clean-python-dijkstra",
                "content": "```\\nclass Solution:\\n    def countPaths(self, n, roads):\\n        \"\"\"\\n        Time: O(R + NlogN) where R is number of roads and N is number of nodes\\n        Space: O(R + N) where R is number of roads and N is number of nodes\\n        \"\"\"\\n        g = defaultdict(lambda: {})\\n        for u, v, w in roads:\\n            g[u][v] = g[v][u] = w\\n            \\n        minq, min_dist, paths = [(0, 0)], defaultdict(lambda: math.inf), [int(i == 0) for i in range(n)]\\n        while minq[0][1] != n - 1:\\n            dist, u = heapq.heappop(minq)\\n            if dist > min_dist[u]:\\n                continue\\n            for v, w in g[u].items():\\n                new_dist = dist + w\\n                if new_dist == min_dist[v]:\\n                    paths[v] = (paths[v] + paths[u]) % 1000000007\\n                elif new_dist < min_dist[v]:\\n                    heappush(minq, (new_dist, v))\\n                    paths[v], min_dist[v] = paths[u], new_dist\\n        return paths[n - 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n, roads):\\n        \"\"\"\\n        Time: O(R + NlogN) where R is number of roads and N is number of nodes\\n        Space: O(R + N) where R is number of roads and N is number of nodes\\n        \"\"\"\\n        g = defaultdict(lambda: {})\\n        for u, v, w in roads:\\n            g[u][v] = g[v][u] = w\\n            \\n        minq, min_dist, paths = [(0, 0)], defaultdict(lambda: math.inf), [int(i == 0) for i in range(n)]\\n        while minq[0][1] != n - 1:\\n            dist, u = heapq.heappop(minq)\\n            if dist > min_dist[u]:\\n                continue\\n            for v, w in g[u].items():\\n                new_dist = dist + w\\n                if new_dist == min_dist[v]:\\n                    paths[v] = (paths[v] + paths[u]) % 1000000007\\n                elif new_dist < min_dist[v]:\\n                    heappush(minq, (new_dist, v))\\n                    paths[v], min_dist[v] = paths[u], new_dist\\n        return paths[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488270,
                "title": "python-dp-djikstras-algorithm",
                "content": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        heap = [(0, 0, 0)]\\n        roadsDict = defaultdict(list)\\n        visited = defaultdict(int)\\n        numWaysDict = defaultdict(int)\\n        numWaysDict[0] = 0\\n\\n        for r1, r2, dist in roads:\\n            roadsDict[r1].append((r2, dist))\\n            roadsDict[r2].append((r1, dist))\\n        \\n        while heap:\\n            dist, road, prevRoad = heappop(heap)\\n            if road in visited and dist > visited[road]:\\n                continue\\n            \\n            numWaysDict[road] += max(1, numWaysDict[prevRoad])\\n            if road in visited:\\n                continue\\n            \\n            visited[road] = dist\\n            \\n            for nextRoad, travelDist in roadsDict[road]:\\n                heappush(heap, (dist + travelDist, nextRoad, road))\\n\\n        return numWaysDict[n-1] % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        heap = [(0, 0, 0)]\\n        roadsDict = defaultdict(list)\\n        visited = defaultdict(int)\\n        numWaysDict = defaultdict(int)\\n        numWaysDict[0] = 0\\n\\n        for r1, r2, dist in roads:\\n            roadsDict[r1].append((r2, dist))\\n            roadsDict[r2].append((r1, dist))\\n        \\n        while heap:\\n            dist, road, prevRoad = heappop(heap)\\n            if road in visited and dist > visited[road]:\\n                continue\\n            \\n            numWaysDict[road] += max(1, numWaysDict[prevRoad])\\n            if road in visited:\\n                continue\\n            \\n            visited[road] = dist\\n            \\n            for nextRoad, travelDist in roadsDict[road]:\\n                heappush(heap, (dist + travelDist, nextRoad, road))\\n\\n        return numWaysDict[n-1] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472800,
                "title": "c-with-explanation-in-comments",
                "content": "First thought\\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int dij(int n, vector<vector<pair<int,long long>>>&graph){\\n        vector<long long>distance(n,LONG_MAX); //this was INT_NAX, but as we are dealing with long it should be LONG_MAX\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> q;\\n        q.push({0,0}); //start node, initial distance\\n        distance[0]=0;\\n        vector<long long>ways(n,1);\\n        ways[0]=1;\\n        /*\\n        this here means, we will calculate number of ways to reach each node if that nodes\\' distance is updating,\\n        initially number od ways to reach first node i.e. 0 is always 1, now to reach 4 and 1 there is 1 ways as in intial\\n        run their distance will be updated to less distance hence it\\'s no. of way will be no. way of reaching to it\\'s\\n        parent, and if any distance is same for a node, that means it is reachable via ways++.\\n        */\\n        while(!q.empty()){\\n            int parent = q.top().second;\\n            int parentwei = q.top().first;\\n            q.pop();\\n            if(distance[parent]<parentwei) continue; //dont;take this node if shortest distance for this node has already\\n            // been encountered\\n            for(int i=0;i<graph[parent].size();i++){\\n                int child = graph[parent][i].first;\\n                long long childweight = graph[parent][i].second;\\n                if(distance[parent]+childweight < distance[child]){ // 0+5(in case of node 4) < INT_MAX\\n                    distance[child]=distance[parent]+childweight;\\n                    q.push({distance[child],child});\\n                    ways[child] = ways[parent]; //jo bhi kam se kam distance hai parent ka with no. of ways to be\\n                    //ways[parent], yeh carryforward hojayega child tak reach karne ke np. of ways ke\\n                } else if(distance[parent]+childweight == distance[child]){//if there are n nodes having same weight and\\n                    //reaching same child, then add those parent node\\'s ways of reach to child\\n                    // ways[child]+=ways[parent]%MOD; //this will give wrong resul, remember when using mod always use it \\n                    //seperately\\n                    ways[child]+=ways[parent];\\n                    ways[child]%=MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,long long>>> graph(n);\\n        for(int i=0;i<roads.size();i++){\\n            graph[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        return dij(n, graph);\\n    }\\n};\\n```\\nSecond thought\\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int dij(int n, vector<vector<pair<int,long long>>>&graph){\\n        vector<long long>distance(n,LONG_MAX); //this was INT_NAX, but as we are dealing with long it should be LONG_MAX\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> q;\\n        q.push({0,0}); //start node, initial distance\\n        distance[0]=0;\\n        vector<long long>ways(n,1);\\n        vector<int> visited(n,false);\\n        ways[0]=1;\\n        /*\\n        this here means, we will calculate number of ways to reach each node if that nodes\\' distance is updating,\\n        initially number od ways to reach first node i.e. 0 is always 1, now to reach 4 and 1 there is 1 ways as in intial\\n        run their distance will be updated to less distance hence it\\'s no. of way will be no. way of reaching to it\\'s\\n        parent, and if any distance is same for a node, that means it is reachable via ways++.\\n        */\\n        while(!q.empty()){\\n            int parent = q.top().second;\\n            int parentwei = q.top().first;\\n            q.pop();\\n            if(visited[parent]) continue; //dont;take this node if shortest distance for this node has already\\n            visited[parent]=true; //this is coming here instead of inside for loop because, firstly we are using\\n            //priority queue which means we will always get lower distance path, hence if i parent is already visited\\n            //then that means that it is already in it\\'s lower distant path\\n            //if we use this inside loop as visited[child], then that means we are stating that all children of that parent is visited which is not true.\\n            // been encountered\\n            for(int i=0;i<graph[parent].size();i++){\\n                int child = graph[parent][i].first;\\n                long long childweight = graph[parent][i].second;\\n                if(distance[parent]+childweight < distance[child]){ // 0+5(in case of node 4) < INT_MAX\\n                    distance[child]=distance[parent]+childweight;\\n                    q.push({distance[child],child});\\n                    ways[child] = ways[parent]; //jo bhi kam se kam distance hai parent ka with no. of ways to be\\n                    //ways[parent], yeh carryforward hojayega child tak reach karne ke np. of ways ke\\n                } else if(distance[parent]+childweight == distance[child]){//if there are n nodes having same weight and\\n                    //reaching same child, then add those parent node\\'s ways of reach to child\\n                    // ways[child]+=ways[parent]%MOD; //this will give wrong resul, remember when using mod always use it \\n                    //seperately\\n                    ways[child]+=ways[parent];\\n                    ways[child]%=MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,long long>>> graph(n);\\n        for(int i=0;i<roads.size();i++){\\n            graph[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        return dij(n, graph);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int dij(int n, vector<vector<pair<int,long long>>>&graph){\\n        vector<long long>distance(n,LONG_MAX); //this was INT_NAX, but as we are dealing with long it should be LONG_MAX\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> q;\\n        q.push({0,0}); //start node, initial distance\\n        distance[0]=0;\\n        vector<long long>ways(n,1);\\n        ways[0]=1;\\n        /*\\n        this here means, we will calculate number of ways to reach each node if that nodes\\' distance is updating,\\n        initially number od ways to reach first node i.e. 0 is always 1, now to reach 4 and 1 there is 1 ways as in intial\\n        run their distance will be updated to less distance hence it\\'s no. of way will be no. way of reaching to it\\'s\\n        parent, and if any distance is same for a node, that means it is reachable via ways++.\\n        */\\n        while(!q.empty()){\\n            int parent = q.top().second;\\n            int parentwei = q.top().first;\\n            q.pop();\\n            if(distance[parent]<parentwei) continue; //dont;take this node if shortest distance for this node has already\\n            // been encountered\\n            for(int i=0;i<graph[parent].size();i++){\\n                int child = graph[parent][i].first;\\n                long long childweight = graph[parent][i].second;\\n                if(distance[parent]+childweight < distance[child]){ // 0+5(in case of node 4) < INT_MAX\\n                    distance[child]=distance[parent]+childweight;\\n                    q.push({distance[child],child});\\n                    ways[child] = ways[parent]; //jo bhi kam se kam distance hai parent ka with no. of ways to be\\n                    //ways[parent], yeh carryforward hojayega child tak reach karne ke np. of ways ke\\n                } else if(distance[parent]+childweight == distance[child]){//if there are n nodes having same weight and\\n                    //reaching same child, then add those parent node\\'s ways of reach to child\\n                    // ways[child]+=ways[parent]%MOD; //this will give wrong resul, remember when using mod always use it \\n                    //seperately\\n                    ways[child]+=ways[parent];\\n                    ways[child]%=MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,long long>>> graph(n);\\n        for(int i=0;i<roads.size();i++){\\n            graph[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        return dij(n, graph);\\n    }\\n};\\n```\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int dij(int n, vector<vector<pair<int,long long>>>&graph){\\n        vector<long long>distance(n,LONG_MAX); //this was INT_NAX, but as we are dealing with long it should be LONG_MAX\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> q;\\n        q.push({0,0}); //start node, initial distance\\n        distance[0]=0;\\n        vector<long long>ways(n,1);\\n        vector<int> visited(n,false);\\n        ways[0]=1;\\n        /*\\n        this here means, we will calculate number of ways to reach each node if that nodes\\' distance is updating,\\n        initially number od ways to reach first node i.e. 0 is always 1, now to reach 4 and 1 there is 1 ways as in intial\\n        run their distance will be updated to less distance hence it\\'s no. of way will be no. way of reaching to it\\'s\\n        parent, and if any distance is same for a node, that means it is reachable via ways++.\\n        */\\n        while(!q.empty()){\\n            int parent = q.top().second;\\n            int parentwei = q.top().first;\\n            q.pop();\\n            if(visited[parent]) continue; //dont;take this node if shortest distance for this node has already\\n            visited[parent]=true; //this is coming here instead of inside for loop because, firstly we are using\\n            //priority queue which means we will always get lower distance path, hence if i parent is already visited\\n            //then that means that it is already in it\\'s lower distant path\\n            //if we use this inside loop as visited[child], then that means we are stating that all children of that parent is visited which is not true.\\n            // been encountered\\n            for(int i=0;i<graph[parent].size();i++){\\n                int child = graph[parent][i].first;\\n                long long childweight = graph[parent][i].second;\\n                if(distance[parent]+childweight < distance[child]){ // 0+5(in case of node 4) < INT_MAX\\n                    distance[child]=distance[parent]+childweight;\\n                    q.push({distance[child],child});\\n                    ways[child] = ways[parent]; //jo bhi kam se kam distance hai parent ka with no. of ways to be\\n                    //ways[parent], yeh carryforward hojayega child tak reach karne ke np. of ways ke\\n                } else if(distance[parent]+childweight == distance[child]){//if there are n nodes having same weight and\\n                    //reaching same child, then add those parent node\\'s ways of reach to child\\n                    // ways[child]+=ways[parent]%MOD; //this will give wrong resul, remember when using mod always use it \\n                    //seperately\\n                    ways[child]+=ways[parent];\\n                    ways[child]%=MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,long long>>> graph(n);\\n        for(int i=0;i<roads.size();i++){\\n            graph[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        return dij(n, graph);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471709,
                "title": "c-dijkstra-using-sortedset",
                "content": "```\\npublic class Solution {\\n    public int CountPaths(int n, int[][] roads) {\\n        \\n        int MOD = 1000000007;\\n        var graph = new List<int[]>[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new List<int[]>();\\n                \\n        foreach(var road in roads)\\n        {            \\n            graph[road[0]].Add(new int[] {road[1], road[2]});\\n            graph[road[1]].Add(new int[] {road[0], road[2]});\\n        }       \\n       \\n        var pq = new SortedSet<(long time, int src)>();\\n        pq.Add((0, 0));\\n        \\n        var time = new long[n]; //gotcha long time\\n        var ways = new int[n];\\n        for(int i = 0;  i < n; i++)\\n            time[i] = long.MaxValue;\\n        ways[0] = 1;\\n        time[0] = 0;\\n        \\n        while(pq.Count > 0)\\n        {\\n            var item = pq.Min;\\n            pq.Remove(pq.Min);\\n            var u = item.src;\\n            var time_u = item.time;\\n            \\n            if(time_u > time[u])\\n                continue;\\n            \\n            foreach(var node in graph[u])\\n            {\\n                var v = node[0];\\n                var time_uv = node[1];\\n                if(time[v] > time[u] + time_uv)\\n                {\\n                    time[v] = time[u] + time_uv;\\n                    ways[v] = ways[u];\\n                    pq.Add((time[v], v));\\n                }\\n                else if (time[v] == time[u] + time_uv)\\n                {                    \\n                    ways[v] = (ways[v] + ways[u])%MOD;\\n                }\\n            }            \\n        }\\n        return ways[n - 1];       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountPaths(int n, int[][] roads) {\\n        \\n        int MOD = 1000000007;\\n        var graph = new List<int[]>[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new List<int[]>();\\n                \\n        foreach(var road in roads)\\n        {            \\n            graph[road[0]].Add(new int[] {road[1], road[2]});\\n            graph[road[1]].Add(new int[] {road[0], road[2]});\\n        }       \\n       \\n        var pq = new SortedSet<(long time, int src)>();\\n        pq.Add((0, 0));\\n        \\n        var time = new long[n]; //gotcha long time\\n        var ways = new int[n];\\n        for(int i = 0;  i < n; i++)\\n            time[i] = long.MaxValue;\\n        ways[0] = 1;\\n        time[0] = 0;\\n        \\n        while(pq.Count > 0)\\n        {\\n            var item = pq.Min;\\n            pq.Remove(pq.Min);\\n            var u = item.src;\\n            var time_u = item.time;\\n            \\n            if(time_u > time[u])\\n                continue;\\n            \\n            foreach(var node in graph[u])\\n            {\\n                var v = node[0];\\n                var time_uv = node[1];\\n                if(time[v] > time[u] + time_uv)\\n                {\\n                    time[v] = time[u] + time_uv;\\n                    ways[v] = ways[u];\\n                    pq.Add((time[v], v));\\n                }\\n                else if (time[v] == time[u] + time_uv)\\n                {                    \\n                    ways[v] = (ways[v] + ways[u])%MOD;\\n                }\\n            }            \\n        }\\n        return ways[n - 1];       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461763,
                "title": "c-dijkstra-dp-t-c-o-v-elog-v",
                "content": "```\\nstruct cmp{\\n    bool operator()(pair<long long,long long> &a, pair<long long,long long> &b){\\n        return a.second > b.second;    \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long INF = 1e15;\\n    long long MOD = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<long long, long long>>> graph(n);\\n        for(auto &x : roads){\\n            graph[x[0]].push_back({x[1],x[2]});\\n            graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector<long long> distance(n,INF);\\n        distance[0]=0;\\n        \\n        priority_queue<pair<long long,long long>, vector<pair<long long,long long>>, cmp> q;\\n        q.push({0,0});\\n        \\n        vector<long long> dp(n,0);\\n        dp[0]=1;\\n        \\n        while(!q.empty()){\\n            long long curNode = q.top().first;\\n            long long curDis = q.top().second;\\n            q.pop();\\n            \\n            for(auto &child : graph[curNode]){\\n                if(curDis+child.second < distance[child.first]){\\n                    distance[child.first] = curDis+child.second;\\n                    q.push({child.first, distance[child.first]});\\n                    dp[child.first] = dp[curNode] % MOD;\\n                }else if(curDis+child.second == distance[child.first]){\\n                    dp[child.first] = (dp[child.first]+dp[curNode]) % MOD;\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstruct cmp{\\n    bool operator()(pair<long long,long long> &a, pair<long long,long long> &b){\\n        return a.second > b.second;    \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long INF = 1e15;\\n    long long MOD = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<long long, long long>>> graph(n);\\n        for(auto &x : roads){\\n            graph[x[0]].push_back({x[1],x[2]});\\n            graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector<long long> distance(n,INF);\\n        distance[0]=0;\\n        \\n        priority_queue<pair<long long,long long>, vector<pair<long long,long long>>, cmp> q;\\n        q.push({0,0});\\n        \\n        vector<long long> dp(n,0);\\n        dp[0]=1;\\n        \\n        while(!q.empty()){\\n            long long curNode = q.top().first;\\n            long long curDis = q.top().second;\\n            q.pop();\\n            \\n            for(auto &child : graph[curNode]){\\n                if(curDis+child.second < distance[child.first]){\\n                    distance[child.first] = curDis+child.second;\\n                    q.push({child.first, distance[child.first]});\\n                    dp[child.first] = dp[curNode] % MOD;\\n                }else if(curDis+child.second == distance[child.first]){\\n                    dp[child.first] = (dp[child.first]+dp[curNode]) % MOD;\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428865,
                "title": "java-solution-with-explanation-classic-dijkstra",
                "content": "```\\n/*\\n    Use normal Dijkstra algorithm\\n    -> Objective is to find number of paths leading to same destination cost\\n    -> conisder vertices -> u1, u2 and u3\\n    -> with costs for reaching there from source are as follows -> c1, c2, c3\\n    -> consider u1 is connected to v1 (directed or un-directed doesn\\'t really matters)\\n    -> similarly u2 and u3 are also connected to v1\\n    -> Now let us assume there are n1 ways for reaching u1 from source\\n    -> similarly assuming n2 and n3 ways for reaching u2 and u3 respectively\\n    -> Suppose cost to reach v1 from u1 is w1 ( i.e edge cost u1---v1 )\\n    -> similarly cost to reach v1 from u2 & u3 are w2 and w3 respectively\\n    -> Assume cost to reach v1 is W\\n    -> if c1+w1 < W\\n    ->  then we update the distance ( just like classic dijkstra), but now we know that there are also n1 ways to reach u1)\\n    ->  i.e to reach v1 from destination there will be n1 ways only.\\n    ->  let this new updated weight be W1\\n    -> if c2+w2==W1\\n    ->  then we found another path with same source to v1 cost, then there will be (n2+n1) different ways to reach v1\\n    ->  Since for reaching v1 from u2 there are n2 ways and we already know that there are also n1 different ways to reach v1\\n\\n*/\\nclass Solution {\\n    int count = 0;\\n    int MOD = (int)(1e9+7);\\n    public int shortestTimeToDest(int start, int dest, int n, Map<Integer, List<int[]>> graph){\\n        // dijkstra\\n        int[] distances = new int[n];\\n        Arrays.fill(distances, Integer.MAX_VALUE);\\n        int[] count = new int[n];\\n        // min heap\\n        // [vertex, cost]\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(a[1]-b[1]));\\n        distances[start] = 0;\\n        pq.add(new int[]{start, 0});\\n        count[start] = 1;\\n        while(!pq.isEmpty()){\\n            int[] obj = pq.poll();\\n            int u = obj[0];\\n            int cost_u = obj[1];\\n            if(cost_u > distances[u])\\n                continue;\\n            List<int[]> neighbors = graph.get(u);\\n            Iterator<int[]> it = neighbors.iterator();\\n            while(it.hasNext()){\\n                int[] edge = it.next();\\n                int v = edge[0];\\n                int cost_uv = edge[1];\\n                if(distances[u]+cost_uv < distances[v]){\\n                    distances[v] = distances[u] + cost_uv;\\n                    pq.add(new int[]{v, distances[v]});\\n                    count[v] = count[u]; // found a better way to reach v\\n                }else if(distances[u]+cost_uv == distances[v]){\\n                    count[v]= count[u]%MOD+count[v]%MOD; // found another same weight path\\n                }\\n            }\\n        }\\n        return count[n-1]%MOD;\\n    }\\n    public int countPaths(int n, int[][] roads) {\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            graph.put(i, new LinkedList<int[]>());\\n        }\\n        for(int[] road: roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int cost_uv = road[2];\\n            graph.get(u).add(new int[]{v, cost_uv});\\n            graph.get(v).add(new int[]{u, cost_uv});\\n        }\\n        return shortestTimeToDest(0, n-1, n, graph);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    Use normal Dijkstra algorithm\\n    -> Objective is to find number of paths leading to same destination cost\\n    -> conisder vertices -> u1, u2 and u3\\n    -> with costs for reaching there from source are as follows -> c1, c2, c3\\n    -> consider u1 is connected to v1 (directed or un-directed doesn\\'t really matters)\\n    -> similarly u2 and u3 are also connected to v1\\n    -> Now let us assume there are n1 ways for reaching u1 from source\\n    -> similarly assuming n2 and n3 ways for reaching u2 and u3 respectively\\n    -> Suppose cost to reach v1 from u1 is w1 ( i.e edge cost u1---v1 )\\n    -> similarly cost to reach v1 from u2 & u3 are w2 and w3 respectively\\n    -> Assume cost to reach v1 is W\\n    -> if c1+w1 < W\\n    ->  then we update the distance ( just like classic dijkstra), but now we know that there are also n1 ways to reach u1)\\n    ->  i.e to reach v1 from destination there will be n1 ways only.\\n    ->  let this new updated weight be W1\\n    -> if c2+w2==W1\\n    ->  then we found another path with same source to v1 cost, then there will be (n2+n1) different ways to reach v1\\n    ->  Since for reaching v1 from u2 there are n2 ways and we already know that there are also n1 different ways to reach v1\\n\\n*/\\nclass Solution {\\n    int count = 0;\\n    int MOD = (int)(1e9+7);\\n    public int shortestTimeToDest(int start, int dest, int n, Map<Integer, List<int[]>> graph){\\n        // dijkstra\\n        int[] distances = new int[n];\\n        Arrays.fill(distances, Integer.MAX_VALUE);\\n        int[] count = new int[n];\\n        // min heap\\n        // [vertex, cost]\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(a[1]-b[1]));\\n        distances[start] = 0;\\n        pq.add(new int[]{start, 0});\\n        count[start] = 1;\\n        while(!pq.isEmpty()){\\n            int[] obj = pq.poll();\\n            int u = obj[0];\\n            int cost_u = obj[1];\\n            if(cost_u > distances[u])\\n                continue;\\n            List<int[]> neighbors = graph.get(u);\\n            Iterator<int[]> it = neighbors.iterator();\\n            while(it.hasNext()){\\n                int[] edge = it.next();\\n                int v = edge[0];\\n                int cost_uv = edge[1];\\n                if(distances[u]+cost_uv < distances[v]){\\n                    distances[v] = distances[u] + cost_uv;\\n                    pq.add(new int[]{v, distances[v]});\\n                    count[v] = count[u]; // found a better way to reach v\\n                }else if(distances[u]+cost_uv == distances[v]){\\n                    count[v]= count[u]%MOD+count[v]%MOD; // found another same weight path\\n                }\\n            }\\n        }\\n        return count[n-1]%MOD;\\n    }\\n    public int countPaths(int n, int[][] roads) {\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            graph.put(i, new LinkedList<int[]>());\\n        }\\n        for(int[] road: roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int cost_uv = road[2];\\n            graph.get(u).add(new int[]{v, cost_uv});\\n            graph.get(v).add(new int[]{u, cost_uv});\\n        }\\n        return shortestTimeToDest(0, n-1, n, graph);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419494,
                "title": "c-dijkstra-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> dis ;\\n    vector<vector<pair<long long,long long>>> adj;\\n    map<pair<int,long long> , int>dp;\\n \\n    long long mod = 1e9+7;\\n    \\n   long long dfs(long long i , long long time , long long n )\\n    {  \\n       \\n        \\n        if(i==n-1)\\n        return 1 ;\\n        \\n        \\n        if(dis[i] > time)\\n            return 0 ; \\n\\n  \\n        if(dp.find({i,time})!=dp.end())\\n            return dp[{i,time}] ;\\n        \\n       \\n        long long ans = 0 ;\\n        \\n        for(auto x : adj[i])\\n        {  \\n            if(time - x.second >= 0)\\n            ans = (ans + dfs(x.first,time-x.second,n))%mod;\\n        }\\n        \\n        dp[{i,time}] = ans;\\n      \\n        \\n        return dp[{i,time}] ;\\n\\n    }\\n    \\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        adj.resize(n) ;\\n       \\n        for(auto x : roads)\\n        {\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        dis.resize(n,LLONG_MAX);\\n        \\n        dis[n-1] = 0 ;\\n        \\n        priority_queue< pair<long long ,long long> , vector<pair<long long ,long long>> , greater<pair<long long ,long long>> >pq;\\n        \\n        pq.push({0,n-1}) ;\\n        \\n        vector<int> vis(n,0) ;\\n        \\n        while(!pq.empty())\\n        {\\n           long long node = pq.top().second;\\n            long long d = pq.top().first ;\\n            \\n            pq.pop() ;\\n            \\n            if(vis[node])continue;\\n            \\n            vis[node]=1;\\n            \\n            for(auto x : adj[node])\\n            { \\n                long long d1 = d + x.second;\\n                \\n                if(dis[x.first] > d1)\\n                {\\n                    dis[x.first] = d1;\\n                    \\n                    pq.push({dis[x.first] , x.first});\\n                }\\n            }\\n        }\\n        \\n       \\n        long long time = dis[0];\\n     \\n   \\n        long long ans = dfs(0,time,n) ;\\n        \\n        return ans ;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<long long> dis ;\\n    vector<vector<pair<long long,long long>>> adj;\\n    map<pair<int,long long> , int>dp;\\n \\n    long long mod = 1e9+7;\\n    \\n   long long dfs(long long i , long long time , long long n )\\n    {  \\n       \\n        \\n        if(i==n-1)\\n        return 1 ;\\n        \\n        \\n        if(dis[i] > time)\\n            return 0 ; \\n\\n  \\n        if(dp.find({i,time}",
                "codeTag": "Java"
            },
            {
                "id": 1419083,
                "title": "c-solution-using-dijkstra",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>&nums) \\n    {\\n        using ll=long long;\\n        vector<vector<ll>>dp[n+10];\\n        for(auto it:nums)\\n        {\\n            ll x=it[0];\\n            ll y=it[1];\\n            ll wt=it[2];\\n            dp[x].push_back({y,wt});\\n            dp[y].push_back({x,wt});\\n        }\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        vector<ll>path(n,0);\\n        vector<ll>dis(n,1e17);\\n        path[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n        while(pq.size())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            ll wt=temp.first;\\n            ll node=temp.second;\\n            // if(node==n-1)\\n            // {\\n            //     break; \\n            // }\\n            for(auto it:dp[node])\\n            {\\n                ll node1=it[0];\\n                ll wt1=it[1];\\n                 if(dis[node1]>dis[node]+wt1)\\n                {\\n                    dis[node1]=dis[node]+wt1;\\n                    path[node1]=path[node];\\n                    pq.push({dis[node1],node1});\\n                }\\n                else  if(dis[node1]==wt+wt1)\\n                {\\n                    path[node1]=(path[node1]+path[node])%mod;\\n                }\\n            }\\n        }\\n        return path[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>&nums) \\n    {\\n        using ll=long long;\\n        vector<vector<ll>>dp[n+10];\\n        for(auto it:nums)\\n        {\\n            ll x=it[0];\\n            ll y=it[1];\\n            ll wt=it[2];\\n            dp[x].push_back({y,wt});\\n            dp[y].push_back({x,wt});\\n        }\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        vector<ll>path(n,0);\\n        vector<ll>dis(n,1e17);\\n        path[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n        while(pq.size())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            ll wt=temp.first;\\n            ll node=temp.second;\\n            // if(node==n-1)\\n            // {\\n            //     break; \\n            // }\\n            for(auto it:dp[node])\\n            {\\n                ll node1=it[0];\\n                ll wt1=it[1];\\n                 if(dis[node1]>dis[node]+wt1)\\n                {\\n                    dis[node1]=dis[node]+wt1;\\n                    path[node1]=path[node];\\n                    pq.push({dis[node1],node1});\\n                }\\n                else  if(dis[node1]==wt+wt1)\\n                {\\n                    path[node1]=(path[node1]+path[node])%mod;\\n                }\\n            }\\n        }\\n        return path[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417975,
                "title": "concise-solution-with-pq-implementation-of-dijkstra",
                "content": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        \\n        neighbours = defaultdict(set)\\n        graph = [[0]*n for _ in range(n)]\\n        \\n        for u,v,d in roads:\\n            neighbours[u].add(v)\\n            neighbours[v].add(u)\\n            graph[u][v] = d\\n            graph[v][u] = d\\n        \\n        paths = defaultdict(int)\\n        paths[0] = 1\\n        distances = {i:inf for i in range(n)}\\n        q = [(0,0)]\\n        visited = set()\\n        while q:\\n            d,src = heapq.heappop(q)\\n            for nei in neighbours[src]:\\n                if nei not in visited:\\n                    if d+graph[src][nei] < distances[nei]:\\n                        distances[nei] = d+graph[src][nei]\\n                        heapq.heappush(q,(distances[nei],nei))\\n                        paths[nei] = paths[src]\\n                    elif d+graph[src][nei] == distances[nei]:\\n                        paths[nei] = paths[src] + paths[nei]\\n            visited.add(src)\\n\\n\\n        return paths[n-1]%(10**9+7)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        \\n        neighbours = defaultdict(set)\\n        graph = [[0]*n for _ in range(n)]\\n        \\n        for u,v,d in roads:\\n            neighbours[u].add(v)\\n            neighbours[v].add(u)\\n            graph[u][v] = d\\n            graph[v][u] = d\\n        \\n        paths = defaultdict(int)\\n        paths[0] = 1\\n        distances = {i:inf for i in range(n)}\\n        q = [(0,0)]\\n        visited = set()\\n        while q:\\n            d,src = heapq.heappop(q)\\n            for nei in neighbours[src]:\\n                if nei not in visited:\\n                    if d+graph[src][nei] < distances[nei]:\\n                        distances[nei] = d+graph[src][nei]\\n                        heapq.heappush(q,(distances[nei],nei))\\n                        paths[nei] = paths[src]\\n                    elif d+graph[src][nei] == distances[nei]:\\n                        paths[nei] = paths[src] + paths[nei]\\n            visited.add(src)\\n\\n\\n        return paths[n-1]%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417828,
                "title": "c-dijkstra-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[201];\\n    bool visited[201];\\n    int time[201][201];\\n    #define ll long long int\\n    \\n    int countPaths(int a, vector<vector<int>>& roads) {\\n        \\n        for(ll j=0;j<roads.size();j++){\\n            adj[roads[j][0]].push_back(roads[j][1]);\\n            adj[roads[j][1]].push_back(roads[j][0]);\\n            time[roads[j][1]][roads[j][0]] = roads[j][2];\\n            time[roads[j][0]][roads[j][1]] = roads[j][2];\\n        }\\n        // dist[j] array stores the minimum time it takes for reaching jth node\\n\\t\\t\\n        ll dist[a+1];\\n        memset(dist,INT_MAX,sizeof(dist));\\n        \\n        dist[0] = 0;\\n        \\n\\t\\t// cnt[j] array stores the count of path which are ending at jth node with minimum time\\n\\t\\t\\n        ll cnt[a+1];\\n    \\tmemset(cnt,0,sizeof(cnt));\\n        \\n        priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>> > q;\\n        q.push({0,0});\\n        visited[0]=true;\\n        cnt[0] = 1;\\n        \\n        while(!q.empty()){\\n            pair<ll,ll>p;\\n            p=q.top();\\n            ll l = p.second;\\n            q.pop();\\n            \\n            for(ll j=0;j<adj[l].size();j++){\\n                if(!visited[adj[l][j]]){\\n                    q.push({p.first + time[l][adj[l][j]],adj[l][j]});\\n                    visited[adj[l][j]] = true;\\n                    dist[adj[l][j]] = p.first+time[l][adj[l][j]];\\n                    cnt[adj[l][j]] += cnt[l];\\n                    cnt[adj[l][j]] %= 1000000007;\\n                }\\n                else{\\n                    if(dist[adj[l][j]] == p.first + time[l][adj[l][j]]){\\n                        cnt[adj[l][j]] += cnt[l];\\n                        cnt[adj[l][j]] %= 1000000007;\\n                    }\\n                    else{\\n                        if(dist[adj[l][j]] > p.first + time[l][adj[l][j]]){\\n                            q.push({p.first + time[l][adj[l][j]],adj[l][j]});\\n                            dist[adj[l][j]] = p.first+time[l][adj[l][j]];\\n                            cnt[adj[l][j]] = cnt[l];\\n                            cnt[adj[l][j]] %= 1000000007;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt[a-1];\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[201];\\n    bool visited[201];\\n    int time[201][201];\\n    #define ll long long int\\n    \\n    int countPaths(int a, vector<vector<int>>& roads) {\\n        \\n        for(ll j=0;j<roads.size();j++){\\n            adj[roads[j][0]].push_back(roads[j][1]);\\n            adj[roads[j][1]].push_back(roads[j][0]);\\n            time[roads[j][1]][roads[j][0]] = roads[j][2];\\n            time[roads[j][0]][roads[j][1]] = roads[j][2];\\n        }\\n        // dist[j] array stores the minimum time it takes for reaching jth node\\n\\t\\t\\n        ll dist[a+1];\\n        memset(dist,INT_MAX,sizeof(dist));\\n        \\n        dist[0] = 0;\\n        \\n\\t\\t// cnt[j] array stores the count of path which are ending at jth node with minimum time\\n\\t\\t\\n        ll cnt[a+1];\\n    \\tmemset(cnt,0,sizeof(cnt));\\n        \\n        priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>> > q;\\n        q.push({0,0});\\n        visited[0]=true;\\n        cnt[0] = 1;\\n        \\n        while(!q.empty()){\\n            pair<ll,ll>p;\\n            p=q.top();\\n            ll l = p.second;\\n            q.pop();\\n            \\n            for(ll j=0;j<adj[l].size();j++){\\n                if(!visited[adj[l][j]]){\\n                    q.push({p.first + time[l][adj[l][j]],adj[l][j]});\\n                    visited[adj[l][j]] = true;\\n                    dist[adj[l][j]] = p.first+time[l][adj[l][j]];\\n                    cnt[adj[l][j]] += cnt[l];\\n                    cnt[adj[l][j]] %= 1000000007;\\n                }\\n                else{\\n                    if(dist[adj[l][j]] == p.first + time[l][adj[l][j]]){\\n                        cnt[adj[l][j]] += cnt[l];\\n                        cnt[adj[l][j]] %= 1000000007;\\n                    }\\n                    else{\\n                        if(dist[adj[l][j]] > p.first + time[l][adj[l][j]]){\\n                            q.push({p.first + time[l][adj[l][j]],adj[l][j]});\\n                            dist[adj[l][j]] = p.first+time[l][adj[l][j]];\\n                            cnt[adj[l][j]] = cnt[l];\\n                            cnt[adj[l][j]] %= 1000000007;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt[a-1];\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417721,
                "title": "c-dijkstra-dp-memoization",
                "content": "```\\n#define ll long long int\\n#define F first\\n#define S second\\nconst int M=1e9+7;\\nclass Solution {\\npublic:\\n      //cost[i] -> shortest time to reach destination from node i\\n      //dp[i] -> no of ways to reach destination from node i in shortest time\\n    ll cal(ll node,ll par,vector<ll> &dp,vector<ll> &cost,vector<vector<pair<ll,ll>>> &g,ll n){\\n        //If reached node \"n-1\" return 1\\n        if(node==n-1)\\n            return 1;\\n        if(dp[node]!=-1)\\n            return dp[node];\\n        ll ans=0;\\n        for(auto &nbr:g[node]){\\n            if(nbr.F == par)\\n                continue;\\n            //Calculate ans for only those nodes which are part of shortest path from \"node\"-> n-1 i.e shortest time to reach dest. from \"node\" == edge weight + shortest time to reach dest. from child node \\n            if(cost[node] == nbr.S + cost[nbr.F]){\\n                ans+=cal(nbr.F,node,dp,cost,g,n);\\n                ans%=M;\\n            }\\n        }\\n        return dp[node]=ans;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        //Instead of running dijkstra from source node , run it from destination node i.e n-1 and calculate shortest time to reach each and every node i from destination node\\n        vector<vector<pair<ll,ll>>> g(n+1);\\n        for(auto &i:roads){\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        priority_queue<vector<ll>,vector<vector<ll>>,greater<vector<ll>>> q;\\n        vector<ll> cost(n,-1),dp(n,-1),vis(n,0);\\n        \\n      //Dijkstra \\n        \\n        q.push({0,n-1});\\n        while(!q.empty()){\\n            auto curr=q.top();\\n            q.pop();\\n            ll node=curr[1];\\n            ll time=curr[0];\\n            \\n            if(vis[node])\\n                continue;\\n            cost[node]=time;\\n            vis[node]=1;\\n            for(auto &nbr:g[node]){\\n                if(!vis[nbr.F]){\\n                    q.push({nbr.S+ time ,nbr.F});\\n                }\\n            }\\n        }\\n        //If no path exists from target node to starting node return 0\\n        if(cost[0]==-1)\\n            return 0;\\n        //Calculate no of ways to reach destination from source node in shortest time\\n        return cal(0,-1,dp,cost,g,n);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n#define F first\\n#define S second\\nconst int M=1e9+7;\\nclass Solution {\\npublic:\\n      //cost[i] -> shortest time to reach destination from node i\\n      //dp[i] -> no of ways to reach destination from node i in shortest time\\n    ll cal(ll node,ll par,vector<ll> &dp,vector<ll> &cost,vector<vector<pair<ll,ll>>> &g,ll n){\\n        //If reached node \"n-1\" return 1\\n        if(node==n-1)\\n            return 1;\\n        if(dp[node]!=-1)\\n            return dp[node];\\n        ll ans=0;\\n        for(auto &nbr:g[node]){\\n            if(nbr.F == par)\\n                continue;\\n            //Calculate ans for only those nodes which are part of shortest path from \"node\"-> n-1 i.e shortest time to reach dest. from \"node\" == edge weight + shortest time to reach dest. from child node \\n            if(cost[node] == nbr.S + cost[nbr.F]){\\n                ans+=cal(nbr.F,node,dp,cost,g,n);\\n                ans%=M;\\n            }\\n        }\\n        return dp[node]=ans;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        //Instead of running dijkstra from source node , run it from destination node i.e n-1 and calculate shortest time to reach each and every node i from destination node\\n        vector<vector<pair<ll,ll>>> g(n+1);\\n        for(auto &i:roads){\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        priority_queue<vector<ll>,vector<vector<ll>>,greater<vector<ll>>> q;\\n        vector<ll> cost(n,-1),dp(n,-1),vis(n,0);\\n        \\n      //Dijkstra \\n        \\n        q.push({0,n-1});\\n        while(!q.empty()){\\n            auto curr=q.top();\\n            q.pop();\\n            ll node=curr[1];\\n            ll time=curr[0];\\n            \\n            if(vis[node])\\n                continue;\\n            cost[node]=time;\\n            vis[node]=1;\\n            for(auto &nbr:g[node]){\\n                if(!vis[nbr.F]){\\n                    q.push({nbr.S+ time ,nbr.F});\\n                }\\n            }\\n        }\\n        //If no path exists from target node to starting node return 0\\n        if(cost[0]==-1)\\n            return 0;\\n        //Calculate no of ways to reach destination from source node in shortest time\\n        return cal(0,-1,dp,cost,g,n);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417710,
                "title": "simple-dijkstra-algo-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    #define lli unsigned long long int\\n    #define pa pair<unsigned long long int,unsigned long long int>\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pa>adj[n];\\n    lli mod=1e9+7;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n             adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        priority_queue<pa,vector<pa>,greater<pa> >q;\\n         q.push({0,0});\\n        vector<pa> dist(n);\\n        for(int i=1;i<n;i++)dist[i]={1e15,0};\\n         dist[0]={0,1};\\n         lli vis[n];memset(vis,0,sizeof(vis));\\n          while(!q.empty())\\n           {   \\n\\t            lli src=q.top().second;\\n\\t            lli cost=q.top().first;\\n\\t             q.pop();\\n              \\n              if(vis[src]==1)continue;\\n               vis[src]=1;\\n\\t           for(int i=0;i<adj[src].size();i++)\\n\\t           {    pa temp=adj[src][i];\\n\\t\\t           if(dist[temp.first].first >=cost+temp.second)\\n                   {   lli sum;\\n                       if(dist[temp.first].first ==cost+temp.second)\\n                       {\\n                         sum=(dist[temp.first].second+dist[src].second)%mod;\\n                       }\\n                     else\\n                     {\\n                        sum=dist[src].second%mod;\\n                     }\\n                      dist[temp.first]={cost+temp.second,sum};\\n                      q.push({dist[temp.first].first,temp.first});\\n                   }\\n\\t           }\\n           }\\n        return dist[n-1].second%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define lli unsigned long long int\\n    #define pa pair<unsigned long long int,unsigned long long int>\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pa>adj[n];\\n    lli mod=1e9+7;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n             adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        priority_queue<pa,vector<pa>,greater<pa> >q;\\n         q.push({0,0});\\n        vector<pa> dist(n);\\n        for(int i=1;i<n;i++)dist[i]={1e15,0};\\n         dist[0]={0,1};\\n         lli vis[n];memset(vis,0,sizeof(vis));\\n          while(!q.empty())\\n           {   \\n\\t            lli src=q.top().second;\\n\\t            lli cost=q.top().first;\\n\\t             q.pop();\\n              \\n              if(vis[src]==1)continue;\\n               vis[src]=1;\\n\\t           for(int i=0;i<adj[src].size();i++)\\n\\t           {    pa temp=adj[src][i];\\n\\t\\t           if(dist[temp.first].first >=cost+temp.second)\\n                   {   lli sum;\\n                       if(dist[temp.first].first ==cost+temp.second)\\n                       {\\n                         sum=(dist[temp.first].second+dist[src].second)%mod;\\n                       }\\n                     else\\n                     {\\n                        sum=dist[src].second%mod;\\n                     }\\n                      dist[temp.first]={cost+temp.second,sum};\\n                      q.push({dist[temp.first].first,temp.first});\\n                   }\\n\\t           }\\n           }\\n        return dist[n-1].second%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417690,
                "title": "java-dijkstra",
                "content": "Modifier dijkstra based solution:\\n\\n```java\\nclass Solution {\\n    private final long inf = (1L<<62);\\n    private final int MOD = 1000000007;\\n    \\n    public int countPaths(int n, int[][] roads) {\\n        Map<Integer, List<Integer>> edges = new HashMap<>();\\n        Map<Integer, List<Integer>> costs = new HashMap<>();\\n        \\n        for(int i=0;i<n;i++){\\n            edges.putIfAbsent(i, new ArrayList<Integer>());\\n            costs.putIfAbsent(i, new ArrayList<Integer>());\\n        }\\n        \\n        for(int[] road : roads){\\n            edges.get(road[0]).add(road[1]);\\n            edges.get(road[1]).add(road[0]);\\n            costs.get(road[0]).add(road[2]);\\n            costs.get(road[1]).add(road[2]);\\n        }\\n        \\n        long dis[] = new long[n];\\n        Arrays.fill(dis, inf);\\n        dis[0]=0;\\n        \\n        int paths[] = new int[n];\\n        paths[0]=1;\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->{\\n            return (int)(dis[a]-dis[b]);\\n        });\\n        pq.add(0);\\n        \\n        while(!pq.isEmpty()){\\n            int u = pq.poll();\\n            // System.out.println(u);\\n            for(int vi=0;vi<edges.get(u).size();vi++){\\n                int v = edges.get(u).get(vi);\\n                int c = costs.get(u).get(vi);\\n                \\n                if(dis[u]+c<dis[v]){\\n                    dis[v]=dis[u]+c;\\n                    paths[v]=paths[u];\\n                    pq.remove(v); // I was getting WA because of not removing the older one\\n                    pq.add(v);\\n                }\\n                else if(dis[u]+c==dis[v]){\\n                    paths[v]=(paths[v]+paths[u])%MOD;\\n                }\\n            }\\n        }\\n        \\n        return paths[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    private final long inf = (1L<<62);\\n    private final int MOD = 1000000007;\\n    \\n    public int countPaths(int n, int[][] roads) {\\n        Map<Integer, List<Integer>> edges = new HashMap<>();\\n        Map<Integer, List<Integer>> costs = new HashMap<>();\\n        \\n        for(int i=0;i<n;i++){\\n            edges.putIfAbsent(i, new ArrayList<Integer>());\\n            costs.putIfAbsent(i, new ArrayList<Integer>());\\n        }\\n        \\n        for(int[] road : roads){\\n            edges.get(road[0]).add(road[1]);\\n            edges.get(road[1]).add(road[0]);\\n            costs.get(road[0]).add(road[2]);\\n            costs.get(road[1]).add(road[2]);\\n        }\\n        \\n        long dis[] = new long[n];\\n        Arrays.fill(dis, inf);\\n        dis[0]=0;\\n        \\n        int paths[] = new int[n];\\n        paths[0]=1;\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->{\\n            return (int)(dis[a]-dis[b]);\\n        });\\n        pq.add(0);\\n        \\n        while(!pq.isEmpty()){\\n            int u = pq.poll();\\n            // System.out.println(u);\\n            for(int vi=0;vi<edges.get(u).size();vi++){\\n                int v = edges.get(u).get(vi);\\n                int c = costs.get(u).get(vi);\\n                \\n                if(dis[u]+c<dis[v]){\\n                    dis[v]=dis[u]+c;\\n                    paths[v]=paths[u];\\n                    pq.remove(v); // I was getting WA because of not removing the older one\\n                    pq.add(v);\\n                }\\n                else if(dis[u]+c==dis[v]){\\n                    paths[v]=(paths[v]+paths[u])%MOD;\\n                }\\n            }\\n        }\\n        \\n        return paths[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417620,
                "title": "why-wrong-answer",
                "content": "I implemented dijstra solution in which i just took one extra num vector to store \\nnumber of ways to come at every node\\n\\n```\\nclass Solution {\\npublic:\\n   long long  int ans=0,mod=1e9 + 7;\\n long long int dij(long long int i,vector<pair<long long int,long long int>>ad[],long long int n)\\n    {\\n        vector<long long int>num(n,1);\\n        \\n        \\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>>pq;\\n        \\n        pq.push({0,0});\\n        \\n        vector<long long int>dis(n,INT_MAX);\\n        dis[0]=0;\\n        \\n        while(!pq.empty())\\n        {\\n            auto tp = pq.top();\\n            pq.pop();\\n           long long  int w = tp.first;\\n           long long  int u = tp.second;\\n            if(w>dis[u])continue;\\n            \\n            for(auto x:ad[u])\\n            {\\n               long long  int w    = x.second;\\n               long long  int node = x.first;\\n                \\n                if(dis[node]>w+dis[u])\\n                {\\n                    num[node]=num[u]%mod;\\n                    dis[node]=w+dis[u];\\n                    pq.push({dis[node],node});\\n                }\\n                else if(dis[node]==w+dis[u])\\n                {\\n                    num[node]=(num[node]+num[u])%mod;\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return num[n-1];\\n        \\n        \\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n\\n        vector<pair<long long int,long long int>>ad[201];\\n        \\n        for(auto x:roads)\\n        {\\n            ad[x[0]].push_back({x[1],x[2]});\\n            ad[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        return dij(0,ad,n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   long long  int ans=0,mod=1e9 + 7;\\n long long int dij(long long int i,vector<pair<long long int,long long int>>ad[],long long int n)\\n    {\\n        vector<long long int>num(n,1);\\n        \\n        \\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>>pq;\\n        \\n        pq.push({0,0});\\n        \\n        vector<long long int>dis(n,INT_MAX);\\n        dis[0]=0;\\n        \\n        while(!pq.empty())\\n        {\\n            auto tp = pq.top();\\n            pq.pop();\\n           long long  int w = tp.first;\\n           long long  int u = tp.second;\\n            if(w>dis[u])continue;\\n            \\n            for(auto x:ad[u])\\n            {\\n               long long  int w    = x.second;\\n               long long  int node = x.first;\\n                \\n                if(dis[node]>w+dis[u])\\n                {\\n                    num[node]=num[u]%mod;\\n                    dis[node]=w+dis[u];\\n                    pq.push({dis[node],node});\\n                }\\n                else if(dis[node]==w+dis[u])\\n                {\\n                    num[node]=(num[node]+num[u])%mod;\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return num[n-1];\\n        \\n        \\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n\\n        vector<pair<long long int,long long int>>ad[201];\\n        \\n        for(auto x:roads)\\n        {\\n            ad[x[0]].push_back({x[1],x[2]});\\n            ad[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        return dij(0,ad,n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4105840,
                "title": "intuition-explanation-simple-clean-dijkstra-and-dp-solution-passes-all-tests-c",
                "content": "# Intuition\\n\\nIn Dijkstra, once a node is dequeued in Dijkstra\\'s algorithm, you won\\'t find a shorter path to any node that can reach the dequeued node. The algorithm guarantees that the shortest path to every dequeued node has already been found.\\n\\nBased on this insight, we can calculate the num of shortest paths to each node (especially the dist node) by building on previously reached nodes, aka. Dynamic programming!\\n\\n\\n# Complexity\\n- Time complexity:\\nTotal: $$O(V + E log(E))$$\\nWe traverse all edges and vertices exactly once.\\nWe have $$|V|$$ possible state to calculate, i.e. we have to calculate the min paths count of each vertex exactly once, the calculation take $$O(1)$$ time.\\nEach dequeue and enqueue operation takes $$O(E log(E))$$\\n\\n- Space complexity:\\nTotal: $$O(|E| + |V|)$$.\\nAdjacency List: $$O(|E| + |V|)$$.\\nElements in the heap in worst case: $$O(|E|)$$.\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    private List<HashSet<Edge>> _adjacency;\\n    private int _dstNode;\\n    private long[] _minDistToNode;\\n    private long[] _numMinPathsToNode;\\n    private readonly int _modulo = (int)Math.Pow(10, 9) + 7;\\n\\n    public int CountPaths(int n, int[][] roads) {\\n        _dstNode = n-1;\\n\\n        _minDistToNode = new long[n];\\n        Array.Fill(_minDistToNode, Int64.MaxValue);\\n        _minDistToNode[0] = 0;\\n\\n        _numMinPathsToNode = new long[n];\\n        Array.Fill(_numMinPathsToNode, 0);\\n        _numMinPathsToNode[0] = 1;\\n\\n        InitializeAdjacency(n, roads);\\n\\n        var heap = new PriorityQueue<int, long>();\\n        heap.Enqueue(0, 0);\\n\\n        while (heap.TryDequeue(out var node, out var dist)) {\\n            if (node == _dstNode) {\\n                // Early termination\\n                return (int)_numMinPathsToNode[_dstNode];\\n            }\\n\\n            // This is equivalent to if(!visited[node]).\\n            // This is true because we enqueue nodes if we found a shorter path and update the array accordingly,\\n            // so if after enqueuing a node we found a shorter path, we will dequeue the shorter path first but \\n            // we are still gonna dequeue the longer path later, this if takes care of ignoring the legacy longer path.\\n            if (dist > _minDistToNode[node]) {\\n                continue;        \\n            }\\n\\n            RelaxEdges(heap, node);\\n        }\\n\\n        return (int)_numMinPathsToNode[_dstNode];\\n    }\\n\\n    private void RelaxEdges(PriorityQueue<int, long> heap, int node) {\\n        foreach (var adj in _adjacency[node]) {\\n            var newDist = _minDistToNode[node] + adj.Time;\\n            if (newDist < _minDistToNode[adj.To]) {\\n                _minDistToNode[adj.To] = newDist;\\n                _numMinPathsToNode[adj.To] = 0;\\n                heap.Enqueue(adj.To, newDist);\\n            }\\n            if (newDist == _minDistToNode[adj.To]) {\\n                _numMinPathsToNode[adj.To] += _numMinPathsToNode[node];\\n                _numMinPathsToNode[adj.To] %= _modulo;\\n            }\\n        }\\n    }\\n\\n    private void InitializeAdjacency(int n, int[][] roads) {\\n        _adjacency = new List<HashSet<Edge>>();\\n\\n        for (int i = 0; i < n; i++) {\\n            _adjacency.Add(new HashSet<Edge>());\\n        }\\n\\n        foreach (var road in roads) {\\n            _adjacency[road[0]].Add(new Edge() {To = road[1], Time = (long)road[2]});\\n            _adjacency[road[1]].Add(new Edge() {To = road[0], Time = (long)road[2]});\\n        }\\n    }\\n\\n    private class Edge {\\n        public int To {get; set;}\\n        public long Time {get; set;}\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    private List<HashSet<Edge>> _adjacency;\\n    private int _dstNode;\\n    private long[] _minDistToNode;\\n    private long[] _numMinPathsToNode;\\n    private readonly int _modulo = (int)Math.Pow(10, 9) + 7;\\n\\n    public int CountPaths(int n, int[][] roads) {\\n        _dstNode = n-1;\\n\\n        _minDistToNode = new long[n];\\n        Array.Fill(_minDistToNode, Int64.MaxValue);\\n        _minDistToNode[0] = 0;\\n\\n        _numMinPathsToNode = new long[n];\\n        Array.Fill(_numMinPathsToNode, 0);\\n        _numMinPathsToNode[0] = 1;\\n\\n        InitializeAdjacency(n, roads);\\n\\n        var heap = new PriorityQueue<int, long>();\\n        heap.Enqueue(0, 0);\\n\\n        while (heap.TryDequeue(out var node, out var dist)) {\\n            if (node == _dstNode) {\\n                // Early termination\\n                return (int)_numMinPathsToNode[_dstNode];\\n            }\\n\\n            // This is equivalent to if(!visited[node]).\\n            // This is true because we enqueue nodes if we found a shorter path and update the array accordingly,\\n            // so if after enqueuing a node we found a shorter path, we will dequeue the shorter path first but \\n            // we are still gonna dequeue the longer path later, this if takes care of ignoring the legacy longer path.\\n            if (dist > _minDistToNode[node]) {\\n                continue;        \\n            }\\n\\n            RelaxEdges(heap, node);\\n        }\\n\\n        return (int)_numMinPathsToNode[_dstNode];\\n    }\\n\\n    private void RelaxEdges(PriorityQueue<int, long> heap, int node) {\\n        foreach (var adj in _adjacency[node]) {\\n            var newDist = _minDistToNode[node] + adj.Time;\\n            if (newDist < _minDistToNode[adj.To]) {\\n                _minDistToNode[adj.To] = newDist;\\n                _numMinPathsToNode[adj.To] = 0;\\n                heap.Enqueue(adj.To, newDist);\\n            }\\n            if (newDist == _minDistToNode[adj.To]) {\\n                _numMinPathsToNode[adj.To] += _numMinPathsToNode[node];\\n                _numMinPathsToNode[adj.To] %= _modulo;\\n            }\\n        }\\n    }\\n\\n    private void InitializeAdjacency(int n, int[][] roads) {\\n        _adjacency = new List<HashSet<Edge>>();\\n\\n        for (int i = 0; i < n; i++) {\\n            _adjacency.Add(new HashSet<Edge>());\\n        }\\n\\n        foreach (var road in roads) {\\n            _adjacency[road[0]].Add(new Edge() {To = road[1], Time = (long)road[2]});\\n            _adjacency[road[1]].Add(new Edge() {To = road[0], Time = (long)road[2]});\\n        }\\n    }\\n\\n    private class Edge {\\n        public int To {get; set;}\\n        public long Time {get; set;}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100409,
                "title": "easy-approach-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int mod = 1e9+7;\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto &road: roads) {\\n            graph[road[0]].push_back({road[1], road[2]});\\n            graph[road[1]].push_back({road[0], road[2]});\\n        }\\n        \\n        vector<long long> distance(n, LONG_MAX);\\n        vector<int> path(n, 0);\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        distance[0] = 0;\\n        path[0] = 1;\\n        \\n        while(!pq.empty()) {\\n            pair<long long, int> t = pq.top();\\n            pq.pop();\\n            \\n            for(auto &i: graph[t.second]) {\\n                long long vert = i.first;\\n                long long edge = i.second;\\n                \\n                if(distance[vert] > distance[t.second] + edge) {\\n                    distance[vert] = distance[t.second] + edge;\\n                    pq.push({distance[vert], vert});\\n                    path[vert] = path[t.second] %mod;\\n                }\\n                else if(distance[vert] == t.first + edge) {\\n                    path[vert] += path[t.second];\\n                    path[vert] %= mod;\\n                }\\n            }\\n        }\\n        \\n        return path[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph",
                    "Topological Sort",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int mod = 1e9+7;\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto &road: roads) {\\n            graph[road[0]].push_back({road[1], road[2]});\\n            graph[road[1]].push_back({road[0], road[2]});\\n        }\\n        \\n        vector<long long> distance(n, LONG_MAX);\\n        vector<int> path(n, 0);\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        distance[0] = 0;\\n        path[0] = 1;\\n        \\n        while(!pq.empty()) {\\n            pair<long long, int> t = pq.top();\\n            pq.pop();\\n            \\n            for(auto &i: graph[t.second]) {\\n                long long vert = i.first;\\n                long long edge = i.second;\\n                \\n                if(distance[vert] > distance[t.second] + edge) {\\n                    distance[vert] = distance[t.second] + edge;\\n                    pq.push({distance[vert], vert});\\n                    path[vert] = path[t.second] %mod;\\n                }\\n                else if(distance[vert] == t.first + edge) {\\n                    path[vert] += path[t.second];\\n                    path[vert] %= mod;\\n                }\\n            }\\n        }\\n        \\n        return path[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094324,
                "title": "cpp-dijkstra",
                "content": "# Intuition\\n Anyone getting error on the striver\\'s code from his graph series ,just change the int into long long in the pair<> in the priority queue that stores the distance and take the dist vector (long long) (n,1e18)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n Same as dijkstra O(ElogV) \\n\\n- Space complexity:\\nSame as dijkstra + O(n) to store ways vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto it : roads){\\n            \\n            adj[it[0]].push_back({it[1] , it[2]});\\n            adj[it[1]].push_back({it[0] , it[2]});\\n        }\\n        \\n        priority_queue<pair<long long ,int> , vector<pair<long long,int>> , greater<pair<long long,int>> > pq; //{dist,node} min heap\\n        vector<long long> dist(n,1e18);\\n        vector<int> ways(n,0);\\n        \\n        dist[0] = 0;\\n        ways[0] = 1;\\n        \\n        int mod = (int)1e9+7;\\n        \\n        pq.push({0,0});\\n        \\n        while(!pq.empty()){\\n            \\n            long long dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto it : adj[node]){\\n                \\n                long long  edW = it.second;\\n                int adjNode = it.first;\\n                \\n                // this is the first time we r coming with this short distance\\n                \\n                if(dis + edW < dist[adjNode]){\\n                    \\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW , adjNode});\\n                    ways[adjNode] = ways[node] % mod;\\n                }\\n                // if the total dist already stored int dist[] i.e we have reached this node before with the shortest distance\\n                else if(dis + edW == dist[adjNode]){\\n                    \\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return (ways[n-1]) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto it : roads){\\n            \\n            adj[it[0]].push_back({it[1] , it[2]});\\n            adj[it[1]].push_back({it[0] , it[2]});\\n        }\\n        \\n        priority_queue<pair<long long ,int> , vector<pair<long long,int>> , greater<pair<long long,int>> > pq; //{dist,node} min heap\\n        vector<long long> dist(n,1e18);\\n        vector<int> ways(n,0);\\n        \\n        dist[0] = 0;\\n        ways[0] = 1;\\n        \\n        int mod = (int)1e9+7;\\n        \\n        pq.push({0,0});\\n        \\n        while(!pq.empty()){\\n            \\n            long long dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto it : adj[node]){\\n                \\n                long long  edW = it.second;\\n                int adjNode = it.first;\\n                \\n                // this is the first time we r coming with this short distance\\n                \\n                if(dis + edW < dist[adjNode]){\\n                    \\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW , adjNode});\\n                    ways[adjNode] = ways[node] % mod;\\n                }\\n                // if the total dist already stored int dist[] i.e we have reached this node before with the shortest distance\\n                else if(dis + edW == dist[adjNode]){\\n                    \\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return (ways[n-1]) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094313,
                "title": "c-dijkstra",
                "content": "# Intuition\\n<!-- Anyone getting error on the striver\\'s code from his graph series ,just change the int to long long int the pair<> that stores the distance and take the dist vector <long long> (n,1e18)-->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Same as dijkstra O(ElogV) -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto it : roads){\\n            \\n            adj[it[0]].push_back({it[1] , it[2]});\\n            adj[it[1]].push_back({it[0] , it[2]});\\n        }\\n        \\n        priority_queue<pair<long long ,int> , vector<pair<long long,int>> , greater<pair<long long,int>> > pq; //{dist,node} min heap\\n        vector<long long> dist(n,1e18);\\n        vector<int> ways(n,0);\\n        \\n        dist[0] = 0;\\n        ways[0] = 1;\\n        \\n        int mod = (int)1e9+7;\\n        \\n        pq.push({0,0});\\n        \\n        while(!pq.empty()){\\n            \\n            long long dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto it : adj[node]){\\n                \\n                long long  edW = it.second;\\n                int adjNode = it.first;\\n                \\n                // this is the first time we r coming with this short distance\\n                \\n                if(dis + edW < dist[adjNode]){\\n                    \\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW , adjNode});\\n                    ways[adjNode] = ways[node] % mod;\\n                }\\n                // if the total dist already stored int dist[] i.e we have reached this node before with the shortest distance\\n                else if(dis + edW == dist[adjNode]){\\n                    \\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return (ways[n-1]) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto it : roads){\\n            \\n            adj[it[0]].push_back({it[1] , it[2]});\\n            adj[it[1]].push_back({it[0] , it[2]});\\n        }\\n        \\n        priority_queue<pair<long long ,int> , vector<pair<long long,int>> , greater<pair<long long,int>> > pq; //{dist,node} min heap\\n        vector<long long> dist(n,1e18);\\n        vector<int> ways(n,0);\\n        \\n        dist[0] = 0;\\n        ways[0] = 1;\\n        \\n        int mod = (int)1e9+7;\\n        \\n        pq.push({0,0});\\n        \\n        while(!pq.empty()){\\n            \\n            long long dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto it : adj[node]){\\n                \\n                long long  edW = it.second;\\n                int adjNode = it.first;\\n                \\n                // this is the first time we r coming with this short distance\\n                \\n                if(dis + edW < dist[adjNode]){\\n                    \\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW , adjNode});\\n                    ways[adjNode] = ways[node] % mod;\\n                }\\n                // if the total dist already stored int dist[] i.e we have reached this node before with the shortest distance\\n                else if(dis + edW == dist[adjNode]){\\n                    \\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return (ways[n-1]) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071890,
                "title": "c-dijkstra-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // Create adjacency list\\n        vector<pair<int, int>> adj[n];\\n        for(auto i : roads){\\n            adj[i[0]].push_back({i[1], i[2]});\\n            adj[i[1]].push_back({i[0], i[2]});\\n        }\\n\\n        // Initialize Datastructures\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        vector<long long> dist(n, 1e18);\\n        dist[0] = 0;\\n        vector<long long> paths(n, 0);\\n        paths[0] = 1;\\n\\n        // Start BSF\\n        while(!pq.empty()){\\n            int currNode = pq.top().second;\\n            long long currDist = pq.top().first;\\n            pq.pop();\\n\\n            for(auto i : adj[currNode]){\\n                int adjNode = i.first;\\n                int weight = i.second;\\n                long long newDist = currDist + weight;\\n\\n                if(newDist < dist[adjNode]){\\n                    dist[adjNode] = newDist;\\n                    pq.push({newDist, adjNode});\\n                    paths[adjNode] = paths[currNode];\\n                } else if(newDist == dist[adjNode]){\\n                    paths[adjNode] = (paths[adjNode]+paths[currNode])%mod;\\n                }\\n            }\\n        }\\n\\n        return paths[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // Create adjacency list\\n        vector<pair<int, int>> adj[n];\\n        for(auto i : roads){\\n            adj[i[0]].push_back({i[1], i[2]});\\n            adj[i[1]].push_back({i[0], i[2]});\\n        }\\n\\n        // Initialize Datastructures\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        vector<long long> dist(n, 1e18);\\n        dist[0] = 0;\\n        vector<long long> paths(n, 0);\\n        paths[0] = 1;\\n\\n        // Start BSF\\n        while(!pq.empty()){\\n            int currNode = pq.top().second;\\n            long long currDist = pq.top().first;\\n            pq.pop();\\n\\n            for(auto i : adj[currNode]){\\n                int adjNode = i.first;\\n                int weight = i.second;\\n                long long newDist = currDist + weight;\\n\\n                if(newDist < dist[adjNode]){\\n                    dist[adjNode] = newDist;\\n                    pq.push({newDist, adjNode});\\n                    paths[adjNode] = paths[currNode];\\n                } else if(newDist == dist[adjNode]){\\n                    paths[adjNode] = (paths[adjNode]+paths[currNode])%mod;\\n                }\\n            }\\n        }\\n\\n        return paths[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060883,
                "title": "simple-dijkstra-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(ElogV) : For dijkstra algorithm.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  O(V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<int,int>> a[n];\\n        for(auto i:roads)\\n        {\\n            int u = i[0];\\n            int v = i[1];\\n            int d = i[2];\\n\\n            a[u].push_back({v,d});\\n            a[v].push_back({u,d});\\n        }\\n        \\n        vector<int> waysArr(n,0);\\n        vector<long long int> dist(n,(long long)LLONG_MAX);\\n\\n        waysArr[0] = 1;\\n        dist[0] = 0;\\n\\n        set<pair<long long int,int>> st;\\n        st.insert({0LL,0});\\n\\n        while(!st.empty())\\n        {\\n            int node = (*(st.begin())).second;\\n            long long int distance = (*(st.begin())).first;\\n            st.erase(st.begin());\\n\\n            for(auto i:a[node])\\n            {\\n                int currNode = i.first;\\n                long long int currDist = i.second;\\n\\n                if(currDist + distance <(long long int) dist[currNode])\\n                {\\n                    dist[currNode] = currDist + distance;\\n                    st.insert({currDist+distance,currNode});\\n                    waysArr[currNode] = waysArr[node];\\n                    waysArr[currNode]= waysArr[currNode]%(1000000007);\\n                }else if(currDist + distance == dist[currNode])\\n                {\\n                    waysArr[currNode] += waysArr[node];\\n                     waysArr[currNode]= waysArr[currNode]%(1000000007);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<waysArr.size();i++)\\n        {\\n            cout<<i<<\" \"<<waysArr[i]<<endl;\\n        }\\n        return waysArr[n-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<int,int>> a[n];\\n        for(auto i:roads)\\n        {\\n            int u = i[0];\\n            int v = i[1];\\n            int d = i[2];\\n\\n            a[u].push_back({v,d});\\n            a[v].push_back({u,d});\\n        }\\n        \\n        vector<int> waysArr(n,0);\\n        vector<long long int> dist(n,(long long)LLONG_MAX);\\n\\n        waysArr[0] = 1;\\n        dist[0] = 0;\\n\\n        set<pair<long long int,int>> st;\\n        st.insert({0LL,0});\\n\\n        while(!st.empty())\\n        {\\n            int node = (*(st.begin())).second;\\n            long long int distance = (*(st.begin())).first;\\n            st.erase(st.begin());\\n\\n            for(auto i:a[node])\\n            {\\n                int currNode = i.first;\\n                long long int currDist = i.second;\\n\\n                if(currDist + distance <(long long int) dist[currNode])\\n                {\\n                    dist[currNode] = currDist + distance;\\n                    st.insert({currDist+distance,currNode});\\n                    waysArr[currNode] = waysArr[node];\\n                    waysArr[currNode]= waysArr[currNode]%(1000000007);\\n                }else if(currDist + distance == dist[currNode])\\n                {\\n                    waysArr[currNode] += waysArr[node];\\n                     waysArr[currNode]= waysArr[currNode]%(1000000007);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<waysArr.size();i++)\\n        {\\n            cout<<i<<\" \"<<waysArr[i]<<endl;\\n        }\\n        return waysArr[n-1];\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4059327,
                "title": "c-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll, ll>> adj[n];\\n        for (auto it : roads)\\n        {\\n            adj[it[0]].push_back({(ll)it[1], (ll)it[2]});\\n            adj[it[1]].push_back({(ll)it[0], (ll)it[2]});\\n        }\\n        priority_queue<pair<ll, ll>,\\n                       vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n\\n        ll INF = 1e15;\\n        vector<ll> dist(n, INF), ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        ll mod = (1e9 + 7);\\n        while (!pq.empty())\\n        {\\n            ll dis = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n\\n            for (auto &it : adj[node])\\n            {\\n                int adjNode = it.first;\\n                ll edW = it.second;\\n                if (dis + edW < dist[adjNode])\\n                {\\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW, adjNode});\\n                    ways[adjNode] = ways[node];\\n                }\\n                else if (dis + edW == dist[adjNode])\\n                {\\n                    ways[adjNode] = ((ways[adjNode]% mod) + (ways[node]% mod)) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Graph",
                    "Topological Sort",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<ll, ll>> adj[n];\\n        for (auto it : roads)\\n        {\\n            adj[it[0]].push_back({(ll)it[1], (ll)it[2]});\\n            adj[it[1]].push_back({(ll)it[0], (ll)it[2]});\\n        }\\n        priority_queue<pair<ll, ll>,\\n                       vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n\\n        ll INF = 1e15;\\n        vector<ll> dist(n, INF), ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        ll mod = (1e9 + 7);\\n        while (!pq.empty())\\n        {\\n            ll dis = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n\\n            for (auto &it : adj[node])\\n            {\\n                int adjNode = it.first;\\n                ll edW = it.second;\\n                if (dis + edW < dist[adjNode])\\n                {\\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW, adjNode});\\n                    ways[adjNode] = ways[node];\\n                }\\n                else if (dis + edW == dist[adjNode])\\n                {\\n                    ways[adjNode] = ((ways[adjNode]% mod) + (ways[node]% mod)) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059099,
                "title": "simple-using-dijisktra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int mod=(int)(1e9+7);\\n        vector<pair<int,int>> adj[n];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});  \\n        }\\n        // code here\\n        vector<long long> dist(n,1e18);\\n        dist[0]=0;\\n        vector<long long> ways(n,0);\\n        ways[0]=1;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int> >,greater<pair<long long,int>>> pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            long dis=it.first;\\n            int node=it.second;\\n            for(auto z:adj[node]){\\n                int adjnode=z.first;\\n                long adjwt=z.second;\\n                if(adjwt+dis<dist[adjnode]){\\n                    dist[adjnode]=adjwt+dis;\\n                    pq.push({dis+adjwt,adjnode});\\n                    ways[adjnode]=ways[node];\\n                }\\n                else if(adjwt+dis==dist[adjnode]){\\n                    ways[adjnode]=(ways[adjnode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int mod=(int)(1e9+7);\\n        vector<pair<int,int>> adj[n];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});  \\n        }\\n        // code here\\n        vector<long long> dist(n,1e18);\\n        dist[0]=0;\\n        vector<long long> ways(n,0);\\n        ways[0]=1;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int> >,greater<pair<long long,int>>> pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            long dis=it.first;\\n            int node=it.second;\\n            for(auto z:adj[node]){\\n                int adjnode=z.first;\\n                long adjwt=z.second;\\n                if(adjwt+dis<dist[adjnode]){\\n                    dist[adjnode]=adjwt+dis;\\n                    pq.push({dis+adjwt,adjnode});\\n                    ways[adjnode]=ways[node];\\n                }\\n                else if(adjwt+dis==dist[adjnode]){\\n                    ways[adjnode]=(ways[adjnode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046790,
                "title": "easy-c-cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto it : roads)\\n        {\\n            int from = it[0];\\n            int to = it[1];\\n            int time = it[2];\\n            adj[from].push_back({to, time});\\n            adj[to].push_back({from, time});\\n        }\\n        long long mod = 1e9 + 7;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        vector<long long> dist(n, 1e15);\\n        vector<long long> count(n, 0);\\n        dist[0] = 0;\\n        count[0] = 1;\\n        while(pq.size())\\n        {\\n            long long timetaken = pq.top().first;\\n            int curr = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[curr])\\n            {\\n                int neigh = it.first;\\n                int traveltime = it.second;\\n                if(dist[neigh] == timetaken + traveltime)\\n                {\\n                    count[neigh] = (count[neigh] + count[curr]) % mod;\\n                }\\n                else if(dist[neigh] > timetaken + traveltime)\\n                {\\n                    dist[neigh] = timetaken + traveltime;\\n                    pq.push({dist[neigh], neigh});\\n                    count[neigh] = count[curr];\\n                }\\n            }\\n        }\\n        return count[n-1] % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto it : roads)\\n        {\\n            int from = it[0];\\n            int to = it[1];\\n            int time = it[2];\\n            adj[from].push_back({to, time});\\n            adj[to].push_back({from, time});\\n        }\\n        long long mod = 1e9 + 7;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n        vector<long long> dist(n, 1e15);\\n        vector<long long> count(n, 0);\\n        dist[0] = 0;\\n        count[0] = 1;\\n        while(pq.size())\\n        {\\n            long long timetaken = pq.top().first;\\n            int curr = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[curr])\\n            {\\n                int neigh = it.first;\\n                int traveltime = it.second;\\n                if(dist[neigh] == timetaken + traveltime)\\n                {\\n                    count[neigh] = (count[neigh] + count[curr]) % mod;\\n                }\\n                else if(dist[neigh] > timetaken + traveltime)\\n                {\\n                    dist[neigh] = timetaken + traveltime;\\n                    pq.push({dist[neigh], neigh});\\n                    count[neigh] = count[curr];\\n                }\\n            }\\n        }\\n        return count[n-1] % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040250,
                "title": "dijkastra-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs for Dijkastra\\'s algo require: \\n1.Distance array\\n2.Data structure like set or Priority_queue to store distance in ascending order\\n3.additional requirement is that as have to store number of ways to reach destination from source will take another data structure to store it\\'s path let take vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExcept for maintaining the seperate array/vector for number of shortest ways every thing is similar as Dijkstra\\'s shortest path algo.\\n**\\nSo, For maintaining the seperate array/vector for number of shortest ways follow below instructions**:\\n1).If the no of shortest paths for particulr node is empty or we are going to add for the first time directly add the number of shortest path from the parent node.\\nways[adjNode]=ways[node]\\n2).And if already there is already entry for shortest path for particualr node then add the number of shortest path from parent and the current number of the shortest path of the node.\\n** ways[adjNode]=(ways[adjNode]+ways[node])**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity=O(Elogn)  here E=no.of edge and n=no. of nodes in graph\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long>dist(n,LONG_MAX);\\n         int mod=1e9+7;\\n        //store undirected graph\\n        vector<pair<int,int>>adj[n];\\n        for(auto x:roads){\\n            int u=x[0];\\n            int v=x[1];\\n            int wt=x[2];\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        vector<long>path(n,0);\\n        priority_queue<pair<long,int>,vector<pair<long,int>>,greater<pair<long,int>>>q;\\n        q.push({0,0});\\n        dist[0]=0;\\n        path[0]=1;\\n        while(!q.empty()){\\n           long d=q.top().first;\\n             int node=q.top().second;\\n            q.pop();\\n            for(auto x:adj[node]){\\n                int v=x.first;\\n                int wt=x.second;\\n                //edge relaxation\\n                if(dist[v]>d+wt){\\n                    //update\\n                    dist[v]=d+wt;\\n                    q.push({dist[v],v});\\n                    //mark path as visited first time with it\\'s minimum reachability\\n                    path[v]=path[node];\\n                }\\n                else if(d+wt==dist[v]){\\n                    path[v]=(path[v]+path[node])%mod;\\n                }\\n            }\\n        }\\n        return path[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long>dist(n,LONG_MAX);\\n         int mod=1e9+7;\\n        //store undirected graph\\n        vector<pair<int,int>>adj[n];\\n        for(auto x:roads){\\n            int u=x[0];\\n            int v=x[1];\\n            int wt=x[2];\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        vector<long>path(n,0);\\n        priority_queue<pair<long,int>,vector<pair<long,int>>,greater<pair<long,int>>>q;\\n        q.push({0,0});\\n        dist[0]=0;\\n        path[0]=1;\\n        while(!q.empty()){\\n           long d=q.top().first;\\n             int node=q.top().second;\\n            q.pop();\\n            for(auto x:adj[node]){\\n                int v=x.first;\\n                int wt=x.second;\\n                //edge relaxation\\n                if(dist[v]>d+wt){\\n                    //update\\n                    dist[v]=d+wt;\\n                    q.push({dist[v],v});\\n                    //mark path as visited first time with it\\'s minimum reachability\\n                    path[v]=path[node];\\n                }\\n                else if(d+wt==dist[v]){\\n                    path[v]=(path[v]+path[node])%mod;\\n                }\\n            }\\n        }\\n        return path[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035425,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar countPaths = function(n, roads) {\\n    const MOD = 10 ** 9 + 7;\\n    const graph = buildGraph(roads, n);\\n    const times = new Array(n).fill(Infinity);\\n    const ways = new Array(n).fill(0);\\n\\n    times[0] = 0;\\n    ways[0] = 1;\\n    const priorityList = [[0, 0]]\\n\\n    while (priorityList.length) {\\n        let [node, t] = priorityList.pop();\\n\\n        for (let [neighbor, weight] of graph[node]) {\\n            const newTime = t + weight;\\n\\n            if (newTime < times[neighbor]) {\\n                times[neighbor] = newTime;\\n                priorityList.push([neighbor, newTime]);\\n                priorityList.sort((a, b) => b[1] - a[1]);\\n                ways[neighbor] = ways[node];\\n            } else if (newTime === times[neighbor]) {\\n                ways[neighbor] += ways[node] % MOD;\\n            }\\n        }\\n    }\\n\\n    return ways[n-1] % MOD;\\n};\\n\\nvar buildGraph = function (edges, n) {\\n    const graph = Array.from({length: n}, () => Array());\\n\\n    for (let [n1, n2, w] of edges) {\\n        graph[n1].push([n2, w]);\\n        graph[n2].push([n1, w]);\\n    }\\n\\n    return graph;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar countPaths = function(n, roads) {\\n    const MOD = 10 ** 9 + 7;\\n    const graph = buildGraph(roads, n);\\n    const times = new Array(n).fill(Infinity);\\n    const ways = new Array(n).fill(0);\\n\\n    times[0] = 0;\\n    ways[0] = 1;\\n    const priorityList = [[0, 0]]\\n\\n    while (priorityList.length) {\\n        let [node, t] = priorityList.pop();\\n\\n        for (let [neighbor, weight] of graph[node]) {\\n            const newTime = t + weight;\\n\\n            if (newTime < times[neighbor]) {\\n                times[neighbor] = newTime;\\n                priorityList.push([neighbor, newTime]);\\n                priorityList.sort((a, b) => b[1] - a[1]);\\n                ways[neighbor] = ways[node];\\n            } else if (newTime === times[neighbor]) {\\n                ways[neighbor] += ways[node] % MOD;\\n            }\\n        }\\n    }\\n\\n    return ways[n-1] % MOD;\\n};\\n\\nvar buildGraph = function (edges, n) {\\n    const graph = Array.from({length: n}, () => Array());\\n\\n    for (let [n1, n2, w] of edges) {\\n        graph[n1].push([n2, w]);\\n        graph[n2].push([n1, w]);\\n    }\\n\\n    return graph;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005968,
                "title": "dijistraalgo-dp-priority-queue-heap-graph-dp-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nshorstest path means -> dijistra \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n \\nanother parameter passing while traversing the nodes is ways array .\\n\\n# Complexity\\n- Time complexity:O(n+e)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote me 3.jpeg](https://assets.leetcode.com/users/images/2c08566c-019b-4293-b8d0-13bbfb3222f7_1693926020.7100172.jpeg)\\n\\n\\n\\uD83C\\uDF1A\\uD83C\\uDF1A \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<long long,long long >>adj[n];\\n        vector<long long   >dis(201, LONG_MAX),ways(201,0);\\n        priority_queue<pair<long long ,long long >,vector<pair<long long,long long>>,greater<pair<long long,long long>>>q;\\n        for(auto it:roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n             adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        q.push({0,0});\\n        dis[0]=0;\\n        ways[0]=1;\\n\\n        while(!q.empty())\\n        {\\n           \\n\\n                    \\n            long long  curN=q.top().second;\\n            long long  curD=q.top().first;\\n            \\n            q.pop();\\n            if(curD>dis[curN])\\n             continue;\\n             for(auto it:adj[curN])\\n            {\\n               if(dis[it.first] >curD+it.second  )\\n               {\\n                  \\n                 \\n                   dis[it.first]=(curD+it.second);\\n                     q.push({dis[it.first],it.first});\\n                    ways[it.first]=ways[curN] %mod;\\n               } \\n               else if(dis[it.first]==curD+it.second)\\n               {\\n                   ways[it.first]=(ways[it.first]+ways[curN])%mod;\\n                   \\n               }\\n\\n            \\n            }\\n        }\\n        return ways[n-1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<long long,long long >>adj[n];\\n        vector<long long   >dis(201, LONG_MAX),ways(201,0);\\n        priority_queue<pair<long long ,long long >,vector<pair<long long,long long>>,greater<pair<long long,long long>>>q;\\n        for(auto it:roads)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n             adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        q.push({0,0});\\n        dis[0]=0;\\n        ways[0]=1;\\n\\n        while(!q.empty())\\n        {\\n           \\n\\n                    \\n            long long  curN=q.top().second;\\n            long long  curD=q.top().first;\\n            \\n            q.pop();\\n            if(curD>dis[curN])\\n             continue;\\n             for(auto it:adj[curN])\\n            {\\n               if(dis[it.first] >curD+it.second  )\\n               {\\n                  \\n                 \\n                   dis[it.first]=(curD+it.second);\\n                     q.push({dis[it.first],it.first});\\n                    ways[it.first]=ways[curN] %mod;\\n               } \\n               else if(dis[it.first]==curD+it.second)\\n               {\\n                   ways[it.first]=(ways[it.first]+ways[curN])%mod;\\n                   \\n               }\\n\\n            \\n            }\\n        }\\n        return ways[n-1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998046,
                "title": "dijkstra-simple-c-solution-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,long long int>>>adj(n+1);\\n        for(int i = 0;i<roads.size();i++){\\n            int u =roads[i][0], v = roads[i][1];\\n            long long int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n\\n        }\\n        const int MOD = 1e9 + 7;\\n\\n        priority_queue<pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>>>pq;\\n        vector<long long int>dist(n+1,1e9+7);\\n        vector<int>ways(n+1,0);\\n        pq.push({0,0});\\n        ways[0]=1;\\n        dist[0] = 0;\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            long long int dis = it.first;\\n            int node = it.second;\\n            for(auto x : adj[node]){\\n                int adjNode = x.first;\\n                long long int edgW = x.second;\\n                if(dist[adjNode] > dis + edgW or (dist[adjNode]==(1e9+7)) ){\\n                    ways[adjNode] = ways[node];\\n                    ways[adjNode] %= MOD;\\n                    dist[adjNode] = dis + edgW;\\n                    pq.push({dist[adjNode],adjNode});\\n                }else if(dist[adjNode] == dis + edgW){\\n                    ways[adjNode] += ways[node];\\n                    ways[adjNode] %= MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,long long int>>>adj(n+1);\\n        for(int i = 0;i<roads.size();i++){\\n            int u =roads[i][0], v = roads[i][1];\\n            long long int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n\\n        }\\n        const int MOD = 1e9 + 7;\\n\\n        priority_queue<pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>>>pq;\\n        vector<long long int>dist(n+1,1e9+7);\\n        vector<int>ways(n+1,0);\\n        pq.push({0,0});\\n        ways[0]=1;\\n        dist[0] = 0;\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            long long int dis = it.first;\\n            int node = it.second;\\n            for(auto x : adj[node]){\\n                int adjNode = x.first;\\n                long long int edgW = x.second;\\n                if(dist[adjNode] > dis + edgW or (dist[adjNode]==(1e9+7)) ){\\n                    ways[adjNode] = ways[node];\\n                    ways[adjNode] %= MOD;\\n                    dist[adjNode] = dis + edgW;\\n                    pq.push({dist[adjNode],adjNode});\\n                }else if(dist[adjNode] == dis + edgW){\\n                    ways[adjNode] += ways[node];\\n                    ways[adjNode] %= MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995997,
                "title": "python-dijkstra-and-dp-solution-with-japanse-explanation",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- \\u554F\\u984C\\u6587\\u304B\\u3089\\u5358\\u4E00\\u59CB\\u70B9\\u6700\\u77ED\\u7D4C\\u8DEF\\u554F\\u984C\\u3068DP\\u3092\\u4F7F\\u3046\\u3067\\u3042\\u308D\\u3046\\u3053\\u3068\\u306F\\u6C17\\u3065\\u3051\\u308B\\u3002\\u5F8C\\u306F\\u3069\\u3046\\u305D\\u308C\\u305E\\u308C\\u3092\\u4F7F\\u3046\\u304B\\u304C\\u30DD\\u30A4\\u30F3\\u30C8\\u3002\\n- \\u300Cdp[i]: \\u30CE\\u30FC\\u30C90\\u304B\\u3089\\u30CE\\u30FC\\u30C9i\\u307E\\u3067\\u3067\\u6700\\u77ED\\u7D4C\\u8DEF\\u306E\\u901A\\u308A\\u300D\\u3067dp\\u304C\\u3046\\u307E\\u304F\\u3067\\u304D\\u308C\\u3070\\u5B09\\u3057\\u3044\\u3002\\n- \\u4E8B\\u524D\\u306B\\u6700\\u77ED\\u7D4C\\u8DEF\\u3092\\u6C42\\u3081\\u3066\\u304A\\u3051\\u3070\\u826F\\u3044\\u3002\\n- u\\u3068v\\u306F\\u96A3\\u63A5\\u3057\\u3066\\u3044\\u3066\\u30010->u->v\\u304Cv\\u3078\\u306E\\u6700\\u77ED\\u7D4C\\u8DEF\\u3068\\u306A\\u308B\\u306A\\u3089\\u3001dp[v] += dp[u]\\u3092\\u3059\\u308C\\u3070\\u826F\\u3044\\u3002\\n- \\u3064\\u307E\\u308A\\u30CE\\u30FC\\u30C90\\u304B\\u3089\\u8FD1\\u3044\\u9806\\u306B\\u914D\\u308BDP\\u3092\\u3057\\u3001\\u305D\\u308C\\u305E\\u308C\\u306E\\u30CE\\u30FC\\u30C9\\u3078\\u306E\\u6700\\u77ED\\u7D4C\\u8DEF\\u304C\\u4F55\\u901A\\u308A\\u3042\\u308B\\u304B\\u3092\\u8DB3\\u3057\\u3066\\u3044\\u3051\\u3070\\u3088\\u3044\\u3002\\n\\n# Complexity\\n$$N$$: \\u30CE\\u30FC\\u30C9\\u6570\\n\\u554F\\u984C\\u6587\\u3088\\u308A\\u30A8\\u30C3\\u30B8\\u306E\\u30AA\\u30FC\\u30C0\\u30FC\\u306F$$O(N^2)$$\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\u30D2\\u30FC\\u30D7\\u7121\\u3057\\u306E\\u30C0\\u30A4\\u30AF\\u30B9\\u30C8\\u30E9\\u3067\\u5358\\u4E00\\u59CB\\u70B9\\u6700\\u77ED\\u7D4C\\u8DEF\\u3092\\u6C42\\u3081\\u308B\\u306E\\u306B$$O(N^2)$$\\u3001\\u307E\\u305FDP\\u3067$$O(N^2)$$\\u3002\\n\\n- Space complexity: $$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```graph```\\u306B$$O(N^2)$$\\u3067\\u3053\\u308C\\u304C\\u30DC\\u30C8\\u30EB\\u30CD\\u30C3\\u30AF\\u3002\\n\\n\\n# Code\\n```\\nINF = float(\\'inf\\')\\nMOD = 10**9 + 7\\n\\nclass Solution:\\n    def countPaths(self, N: int, roads: List[List[int]]) -> int:\\n        graph = [[] for _ in range(N)]\\n        for road in roads:\\n            u, v, time = road\\n            graph[u].append((v, time))\\n            graph[v].append((u, time))\\n\\n        # \\u6700\\u77ED\\u8DDD\\u96E2\\n        dis = [INF for _ in range(N)]\\n        dis[0] = 0\\n\\n        # \\u6700\\u77ED\\u8DDD\\u96E2\\u672A\\u5B9A\\u30CE\\u30FC\\u30C9\\n        undecided = set([i for i in range(N)])\\n\\n        # \\u30CE\\u30FC\\u30C90\\u304B\\u3089\\u306E\\u6700\\u77ED\\u8DDD\\u96E2\\u304C\\u77ED\\u3044\\u9806\\n        min_path_order = []\\n\\n        while undecided:\\n            u = -1\\n            ud = INF\\n\\n            for i in undecided:\\n                if dis[i] < ud:\\n                    ud = dis[i]\\n                    u = i\\n\\n            min_path_order.append(u)\\n            undecided.remove(u)   \\n\\n            for edge in graph[u]:\\n                v, time = edge\\n                if dis[v] > dis[u] + time:\\n                    dis[v] = dis[u] + time\\n\\n\\n        # \\u30CE\\u30FC\\u30C90\\u304B\\u3089\\u6700\\u77ED\\u8DDD\\u96E2\\u3067\\u306E\\u7D4C\\u8DEF\\u306E\\u901A\\u308A\\n        dp = [0 for _ in range(N)]\\n        dp[0] = 1\\n\\n        for u in min_path_order:\\n            for edge in graph[u]:\\n                v, time = edge\\n\\n                # u\\u304B\\u3089v\\u3078\\u306Eedge\\u3092\\u901A\\u3063\\u3066v\\u3078\\u306E\\u6700\\u77ED\\u7D4C\\u8DEF\\u3068\\u306A\\u308B\\u304B\\u30C1\\u30A7\\u30C3\\u30AF\\n                if dis[u] + time == dis[v]:\\n                    dp[v] += dp[u]\\n                    dp[v] %= MOD\\n\\n        return dp[N-1]                    \\n\\n\\n\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```graph```\n```\\nINF = float(\\'inf\\')\\nMOD = 10**9 + 7\\n\\nclass Solution:\\n    def countPaths(self, N: int, roads: List[List[int]]) -> int:\\n        graph = [[] for _ in range(N)]\\n        for road in roads:\\n            u, v, time = road\\n            graph[u].append((v, time))\\n            graph[v].append((u, time))\\n\\n        # \\u6700\\u77ED\\u8DDD\\u96E2\\n        dis = [INF for _ in range(N)]\\n        dis[0] = 0\\n\\n        # \\u6700\\u77ED\\u8DDD\\u96E2\\u672A\\u5B9A\\u30CE\\u30FC\\u30C9\\n        undecided = set([i for i in range(N)])\\n\\n        # \\u30CE\\u30FC\\u30C90\\u304B\\u3089\\u306E\\u6700\\u77ED\\u8DDD\\u96E2\\u304C\\u77ED\\u3044\\u9806\\n        min_path_order = []\\n\\n        while undecided:\\n            u = -1\\n            ud = INF\\n\\n            for i in undecided:\\n                if dis[i] < ud:\\n                    ud = dis[i]\\n                    u = i\\n\\n            min_path_order.append(u)\\n            undecided.remove(u)   \\n\\n            for edge in graph[u]:\\n                v, time = edge\\n                if dis[v] > dis[u] + time:\\n                    dis[v] = dis[u] + time\\n\\n\\n        # \\u30CE\\u30FC\\u30C90\\u304B\\u3089\\u6700\\u77ED\\u8DDD\\u96E2\\u3067\\u306E\\u7D4C\\u8DEF\\u306E\\u901A\\u308A\\n        dp = [0 for _ in range(N)]\\n        dp[0] = 1\\n\\n        for u in min_path_order:\\n            for edge in graph[u]:\\n                v, time = edge\\n\\n                # u\\u304B\\u3089v\\u3078\\u306Eedge\\u3092\\u901A\\u3063\\u3066v\\u3078\\u306E\\u6700\\u77ED\\u7D4C\\u8DEF\\u3068\\u306A\\u308B\\u304B\\u30C1\\u30A7\\u30C3\\u30AF\\n                if dis[u] + time == dis[v]:\\n                    dp[v] += dp[u]\\n                    dp[v] %= MOD\\n\\n        return dp[N-1]                    \\n\\n\\n\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987181,
                "title": "dijkstra-recursion-memoization",
                "content": "***The intution behind is\\na.first we will find out minimum distance to reach the destination using Dijkstra Algorithm,\\nb.then we will use the dfs to reach the destination from different paths,\\nc.use those paths which have sum equal to minimum distance for that vertex,\\nd.then we will memoize the dfs to code not give the TLE,\\ne.everywhere we use long long data type to not give the overflow.***\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<long long> shortestPath(int &n,vector<vector<pair<long long,long long>>> &g){\\n        \\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> pq;\\n        vector<long long> dis(n,LLONG_MAX);\\n        dis[0]=0;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            long long node=pq.top().second;\\n            long long d=pq.top().first;pq.pop();\\n            for(pair<long long,long long> &p:g[node]){\\n                if(dis[p.first]>d+p.second){\\n                    dis[p.first]=d+p.second;\\n                    pq.push({d+p.second,p.first});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    \\n    vector<long long> t;\\n    \\n    int dfs(int node,int &n,vector<long long> &dist,vector<vector<pair<long long,long long>>> &g){\\n        if(node==n-1) return 1;\\n        if(t[node]!=-1) return t[node];\\n        \\n        long long ans=0;\\n        \\n        for(pair<long long,long long> &p:g[node]){\\n            long long wt=p.second;\\n            long long v=p.first;\\n            if(dist[node]+wt==dist[v]){\\n                ans=(ans%mod+dfs(v,n,dist,g)%mod)%mod;\\n            }\\n        }\\n        return t[node]=ans;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<long long,long long>>> g(n);\\n        for(vector<int>& e:roads){\\n            g[e[0]].push_back({e[1],e[2]});\\n            g[e[1]].push_back({e[0],e[2]});\\n        }\\n        vector<long long> dist=shortestPath(n,g);\\n        t.resize(n,-1);\\n        \\n        return dfs(0,n,dist,g);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<long long> shortestPath(int &n,vector<vector<pair<long long,long long>>> &g){\\n        \\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> pq;\\n        vector<long long> dis(n,LLONG_MAX);\\n        dis[0]=0;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            long long node=pq.top().second;\\n            long long d=pq.top().first;pq.pop();\\n            for(pair<long long,long long> &p:g[node]){\\n                if(dis[p.first]>d+p.second){\\n                    dis[p.first]=d+p.second;\\n                    pq.push({d+p.second,p.first});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    \\n    vector<long long> t;\\n    \\n    int dfs(int node,int &n,vector<long long> &dist,vector<vector<pair<long long,long long>>> &g){\\n        if(node==n-1) return 1;\\n        if(t[node]!=-1) return t[node];\\n        \\n        long long ans=0;\\n        \\n        for(pair<long long,long long> &p:g[node]){\\n            long long wt=p.second;\\n            long long v=p.first;\\n            if(dist[node]+wt==dist[v]){\\n                ans=(ans%mod+dfs(v,n,dist,g)%mod)%mod;\\n            }\\n        }\\n        return t[node]=ans;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<long long,long long>>> g(n);\\n        for(vector<int>& e:roads){\\n            g[e[0]].push_back({e[1],e[2]});\\n            g[e[1]].push_back({e[0],e[2]});\\n        }\\n        vector<long long> dist=shortestPath(n,g);\\n        t.resize(n,-1);\\n        \\n        return dfs(0,n,dist,g);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987147,
                "title": "simple-c-solution-using-dijkstra-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n];\\n        \\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>,\\n        greater<pair<long long, int>>> pq;\\n        vector<long long> dist(n, 1e18);\\n        vector<long long> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        int mod = (1e9 + 7);\\n        \\n        while(!pq.empty())\\n        {\\n            long long dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto it : adj[node])\\n            {\\n                long long edgeWeight = it.second;\\n                int adjNode = it.first;\\n                \\n                if(dis + edgeWeight < dist[adjNode])\\n                {\\n                    dist[adjNode] = dis + edgeWeight;\\n                    pq.push({dist[adjNode], adjNode});\\n                    ways[adjNode] = ways[node];\\n                }\\n                else if(dis + edgeWeight == dist[adjNode])\\n                {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n];\\n        \\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>,\\n        greater<pair<long long, int>>> pq;\\n        vector<long long> dist(n, 1e18);\\n        vector<long long> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        int mod = (1e9 + 7);\\n        \\n        while(!pq.empty())\\n        {\\n            long long dis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto it : adj[node])\\n            {\\n                long long edgeWeight = it.second;\\n                int adjNode = it.first;\\n                \\n                if(dis + edgeWeight < dist[adjNode])\\n                {\\n                    dist[adjNode] = dis + edgeWeight;\\n                    pq.push({dist[adjNode], adjNode});\\n                    ways[adjNode] = ways[node];\\n                }\\n                else if(dis + edgeWeight == dist[adjNode])\\n                {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981664,
                "title": "striver-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n       vector<pair<int,int>> adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0], i[2]});\\n        }\\n\\n        priority_queue<pair<long long,int> , vector<pair<long long,int > >, greater<pair<long long,int > > > pq;\\n        pq.push({0,0});\\n\\n        vector<long long > dist(n,1e15), ways(n,0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        while(!pq.empty()){\\n\\n            int node = pq.top().second;\\n            long long distance = pq.top().first;\\n            pq.pop();\\n\\n            for(auto i:adj[node]){\\n                long long weight = i.second;\\n                int adjNode = i.first;\\n\\n                if(weight+distance < dist[adjNode]){\\n                    dist[adjNode] = weight+distance;\\n                    ways[adjNode] = ways[node];\\n                    pq.push({weight+distance, adjNode});\\n                }else if(dist[adjNode]==weight+distance){\\n                    ways[adjNode] = (ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n};*/\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<pair<long long ,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        vector<long long >dis(n,1e15),ways(n,0);\\n        ways[0]=1;\\n        dis[0]=0;\\n        int mod=(int)1e9+7;\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            long long dist=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                long long adjW=it.second;\\n                if(dist+adjW < dis[adjNode]){\\n                    dis[adjNode]=dist+adjW;\\n                    pq.push({dist+adjW,adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if(dist + adjW ==dis[adjNode]){\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n\\n        return ways[n-1]%mod;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n       vector<pair<int,int>> adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0], i[2]});\\n        }\\n\\n        priority_queue<pair<long long,int> , vector<pair<long long,int > >, greater<pair<long long,int > > > pq;\\n        pq.push({0,0});\\n\\n        vector<long long > dist(n,1e15), ways(n,0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        while(!pq.empty()){\\n\\n            int node = pq.top().second;\\n            long long distance = pq.top().first;\\n            pq.pop();\\n\\n            for(auto i:adj[node]){\\n                long long weight = i.second;\\n                int adjNode = i.first;\\n\\n                if(weight+distance < dist[adjNode]){\\n                    dist[adjNode] = weight+distance;\\n                    ways[adjNode] = ways[node];\\n                    pq.push({weight+distance, adjNode});\\n                }else if(dist[adjNode]==weight+distance){\\n                    ways[adjNode] = (ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n};*/\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<pair<long long ,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        vector<long long >dis(n,1e15),ways(n,0);\\n        ways[0]=1;\\n        dis[0]=0;\\n        int mod=(int)1e9+7;\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            long long dist=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                long long adjW=it.second;\\n                if(dist+adjW < dis[adjNode]){\\n                    dis[adjNode]=dist+adjW;\\n                    pq.push({dist+adjW,adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if(dist + adjW ==dis[adjNode]){\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n\\n        return ways[n-1]%mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977177,
                "title": "dijkstras-algo-solution",
                "content": "\\n\\n# Code\\n```\\nclass pair{\\n    long first;\\n    long second;\\n    pair(long a,long b){\\n        this.first=a;\\n        this.second=b;\\n    }\\n}\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n        int len=roads.length;\\n\\n        ArrayList<ArrayList<pair>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<len;i++){\\n            adj.get(roads[i][0]).add(new pair(roads[i][1],roads[i][2]));\\n             adj.get(roads[i][1]).add(new pair(roads[i][0],roads[i][2]));\\n        }\\n\\n        PriorityQueue<pair> pq = new PriorityQueue<>((pair1, pair2) -> Long.compare(pair1.first, pair2.first));\\n        long []dist=new long[n];\\n        long []ways=new long [n];\\n        for(int i=0;i<n;i++){\\n            dist[i]=Long.MAX_VALUE;\\n            ways[i]=0;\\n        }\\n        long mod=(long)(1e9+7);\\n        dist[0]=0;\\n        ways[0]=1;\\n        pq.add(new pair(0,0));\\n        while(pq.size()!=0){\\n            long dis=pq.peek().first ;\\n            long node=pq.peek().second;\\n            pq.remove();\\n            for(pair it:adj.get((int)node)){\\n                long adj_node=it.first;\\n                long edj_dist=it.second;\\n                if(dis+edj_dist<dist[(int)adj_node]){\\n                    dist[(int)adj_node]=dis+edj_dist;\\n                    pq.add(new pair(dis+edj_dist,adj_node));\\n                    ways[(int)adj_node]=ways[(int)node];\\n                }else if(dist[(int)adj_node]==dis+edj_dist){\\n                    ways[(int)adj_node]=ways[(int)adj_node]+ways[(int)node] % mod;\\n                }\\n            }\\n\\n        }\\n        return (int)(ways[n-1] % mod);\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass pair{\\n    long first;\\n    long second;\\n    pair(long a,long b){\\n        this.first=a;\\n        this.second=b;\\n    }\\n}\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n        int len=roads.length;\\n\\n        ArrayList<ArrayList<pair>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<len;i++){\\n            adj.get(roads[i][0]).add(new pair(roads[i][1],roads[i][2]));\\n             adj.get(roads[i][1]).add(new pair(roads[i][0],roads[i][2]));\\n        }\\n\\n        PriorityQueue<pair> pq = new PriorityQueue<>((pair1, pair2) -> Long.compare(pair1.first, pair2.first));\\n        long []dist=new long[n];\\n        long []ways=new long [n];\\n        for(int i=0;i<n;i++){\\n            dist[i]=Long.MAX_VALUE;\\n            ways[i]=0;\\n        }\\n        long mod=(long)(1e9+7);\\n        dist[0]=0;\\n        ways[0]=1;\\n        pq.add(new pair(0,0));\\n        while(pq.size()!=0){\\n            long dis=pq.peek().first ;\\n            long node=pq.peek().second;\\n            pq.remove();\\n            for(pair it:adj.get((int)node)){\\n                long adj_node=it.first;\\n                long edj_dist=it.second;\\n                if(dis+edj_dist<dist[(int)adj_node]){\\n                    dist[(int)adj_node]=dis+edj_dist;\\n                    pq.add(new pair(dis+edj_dist,adj_node));\\n                    ways[(int)adj_node]=ways[(int)node];\\n                }else if(dist[(int)adj_node]==dis+edj_dist){\\n                    ways[(int)adj_node]=ways[(int)adj_node]+ways[(int)node] % mod;\\n                }\\n            }\\n\\n        }\\n        return (int)(ways[n-1] % mod);\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975992,
                "title": "cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        int mod = 1e9 + 7;\\n        set<pair<long long , long long>> store;\\n        vector<vector<pair<long long, long long>>>adj(n);\\n        vector<long long> ways(n , 0);\\n        vector<long long> dist(n , LONG_MAX);\\n        for(auto edge : roads)\\n        {\\n            adj[edge[0]].push_back({edge[1],edge[2]});\\n            adj[edge[1]].push_back({edge[0],edge[2]});\\n        }\\n        store.insert({0 , 0});\\n        ways[0] = 1;\\n        dist[0] = 0;\\n        while(!store.empty())\\n        {\\n            auto begin = *(store.begin());\\n            int node = begin.second;\\n            long long nodeDist = begin.first;\\n            store.erase(begin);\\n            for(auto edge : adj[node])\\n            {\\n                int adjNode = edge.first;\\n                long long wt = edge.second;\\n                long long newDist = nodeDist + wt ;\\n                if(dist[adjNode] > newDist)\\n                {\\n                    store.insert({newDist , edge.first});\\n                    ways[adjNode] = ways[node];\\n                    dist[adjNode] = newDist;\\n                }\\n                else if(dist[edge.first] == newDist)\\n                {\\n                    ways[adjNode] = (ways[adjNode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        int mod = 1e9 + 7;\\n        set<pair<long long , long long>> store;\\n        vector<vector<pair<long long, long long>>>adj(n);\\n        vector<long long> ways(n , 0);\\n        vector<long long> dist(n , LONG_MAX);\\n        for(auto edge : roads)\\n        {\\n            adj[edge[0]].push_back({edge[1],edge[2]});\\n            adj[edge[1]].push_back({edge[0],edge[2]});\\n        }\\n        store.insert({0 , 0});\\n        ways[0] = 1;\\n        dist[0] = 0;\\n        while(!store.empty())\\n        {\\n            auto begin = *(store.begin());\\n            int node = begin.second;\\n            long long nodeDist = begin.first;\\n            store.erase(begin);\\n            for(auto edge : adj[node])\\n            {\\n                int adjNode = edge.first;\\n                long long wt = edge.second;\\n                long long newDist = nodeDist + wt ;\\n                if(dist[adjNode] > newDist)\\n                {\\n                    store.insert({newDist , edge.first});\\n                    ways[adjNode] = ways[node];\\n                    dist[adjNode] = newDist;\\n                }\\n                else if(dist[edge.first] == newDist)\\n                {\\n                    ways[adjNode] = (ways[adjNode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964721,
                "title": "dijkstra-using-heap-clean-with-detailed-comments-each-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the shortest path and positive weights imply strong signal of using Dijkstra.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just need to keep a list of distance, not path but rather count paths in very specific conditions to count the number of ways.\\n\\n# Complexity\\n- Time complexity: O((E+V) log V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(E+V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countPaths(self, n, roads):\\n        \"\"\"\\n        :type n: int\\n        :type roads: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        import heapq\\n\\n        # adjacency list\\n        graph = [[] for _ in range(n)]\\n\\n        # bi-directional roads\\n        for u, v, time in roads:\\n            graph[u].append((v, time))\\n            graph[v].append((u, time)) \\n        \\n        dist = [float(\\'inf\\')] * n\\n        countPath = [0] * n\\n\\n        # starting intersection has distance 0 and 1 path to reach itself\\n        dist[0] = 0\\n        countPath[0] = 1\\n        priority_queue = [(0,0)] # starting intersection\\n\\n        # Dijkstra\\n        while len(priority_queue) > 0:\\n            smallest_distance, v = heapq.heappop(priority_queue)\\n            # guarantee the running time, since we may visit an idx repeatedly by pushing it onto the heap more than once.\\n            if smallest_distance > dist[v]:\\n                continue\\n            # loop through neighbors of v\\n            for u, time in graph[v]:\\n                # if a shorter path is found from v to u:\\n                if smallest_distance + time < dist[u]:\\n                    dist[u] = smallest_distance + time\\n                    # the way to reach u is essentially the way to reach v\\n                    countPath[u] = countPath[v]\\n                    heapq.heappush(priority_queue, (dist[u], u))\\n                # if another shortest path of same length is found from v to u\\n                elif smallest_distance + time == dist[u]:\\n                    countPath[u] = (countPath[u] + countPath[v]) % (10**9+7)\\n        return countPath[-1]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPaths(self, n, roads):\\n        \"\"\"\\n        :type n: int\\n        :type roads: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        import heapq\\n\\n        # adjacency list\\n        graph = [[] for _ in range(n)]\\n\\n        # bi-directional roads\\n        for u, v, time in roads:\\n            graph[u].append((v, time))\\n            graph[v].append((u, time)) \\n        \\n        dist = [float(\\'inf\\')] * n\\n        countPath = [0] * n\\n\\n        # starting intersection has distance 0 and 1 path to reach itself\\n        dist[0] = 0\\n        countPath[0] = 1\\n        priority_queue = [(0,0)] # starting intersection\\n\\n        # Dijkstra\\n        while len(priority_queue) > 0:\\n            smallest_distance, v = heapq.heappop(priority_queue)\\n            # guarantee the running time, since we may visit an idx repeatedly by pushing it onto the heap more than once.\\n            if smallest_distance > dist[v]:\\n                continue\\n            # loop through neighbors of v\\n            for u, time in graph[v]:\\n                # if a shorter path is found from v to u:\\n                if smallest_distance + time < dist[u]:\\n                    dist[u] = smallest_distance + time\\n                    # the way to reach u is essentially the way to reach v\\n                    countPath[u] = countPath[v]\\n                    heapq.heappush(priority_queue, (dist[u], u))\\n                # if another shortest path of same length is found from v to u\\n                elif smallest_distance + time == dist[u]:\\n                    countPath[u] = (countPath[u] + countPath[v]) % (10**9+7)\\n        return countPath[-1]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963824,
                "title": "cpp-using-dijkstra-algorithm-with-explanation",
                "content": "\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n   //using dijkstra algorithm\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<pair<ll, ll>> adj[n];\\n        for (auto it : roads)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n\\n        // Defining a priority queue (min heap). \\n        priority_queue<pair<ll, ll>,\\n                       vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n\\n        // Initializing the dist array and the ways array\\n        // along with their first indices.\\n        vector<ll> dist(n, LONG_MAX), ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n\\n        // Define modulo value\\n        ll mod = (ll)(1e9 + 7);\\n\\n        // Iterate through the graph with the help of priority queue\\n        // just as we do in Dijkstra\\'s Algorithm.\\n        while (!pq.empty())\\n        {\\n            ll dis = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n\\n            for (auto it : adj[node])\\n            {\\n                ll adjNode = it.first;\\n                ll edW = it.second;\\n\\n                // This \\u2018if\\u2019 condition signifies that this is the first\\n                // time we\\u2019re coming with this short distance, so we push\\n                // in PQ and keep the no. of ways the same.\\n                if (dis + edW < dist[adjNode])\\n                {\\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW, adjNode});\\n                    ways[adjNode] = ways[node];\\n                }\\n\\n                // If we again encounter a node with the same short distance\\n                // as before, we simply increment the no. of ways.\\n                else if (dis + edW == dist[adjNode])\\n                {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        // Finally, we return the no. of ways to reach\\n        // (n-1)th node modulo 10^9+7.\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort",
                    "Shortest Path"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n   //using dijkstra algorithm\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<pair<ll, ll>> adj[n];\\n        for (auto it : roads)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n\\n        // Defining a priority queue (min heap). \\n        priority_queue<pair<ll, ll>,\\n                       vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n\\n        // Initializing the dist array and the ways array\\n        // along with their first indices.\\n        vector<ll> dist(n, LONG_MAX), ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n\\n        // Define modulo value\\n        ll mod = (ll)(1e9 + 7);\\n\\n        // Iterate through the graph with the help of priority queue\\n        // just as we do in Dijkstra\\'s Algorithm.\\n        while (!pq.empty())\\n        {\\n            ll dis = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n\\n            for (auto it : adj[node])\\n            {\\n                ll adjNode = it.first;\\n                ll edW = it.second;\\n\\n                // This \\u2018if\\u2019 condition signifies that this is the first\\n                // time we\\u2019re coming with this short distance, so we push\\n                // in PQ and keep the no. of ways the same.\\n                if (dis + edW < dist[adjNode])\\n                {\\n                    dist[adjNode] = dis + edW;\\n                    pq.push({dis + edW, adjNode});\\n                    ways[adjNode] = ways[node];\\n                }\\n\\n                // If we again encounter a node with the same short distance\\n                // as before, we simply increment the no. of ways.\\n                else if (dis + edW == dist[adjNode])\\n                {\\n                    ways[adjNode] = (ways[adjNode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        // Finally, we return the no. of ways to reach\\n        // (n-1)th node modulo 10^9+7.\\n        return ways[n - 1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957247,
                "title": "c-dijkstra-s-solution-with-some-dp",
                "content": "# Intuition\\nThe intutuion is simply Dijkstra\\'s, but it might not be simply that alone, but we have to find the number of ways we can reach the source from destination in smallest path.\\n\\nTo do this we have have to simply add the number of possible ways we have in order to reach from source to destination. We can track this by simply having one more array which tells us how many times we have crossed this node with the smallest distance so far.\\n\\n# Complexity\\n- Time complexity:\\nO(ElogV)\\n\\n- Space complexity:\\nO(V^2) + 3*O(N) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int MOD = (int) 1e9+7;\\n        vector<pair<int, int>> adj[n];\\n        for(auto &it : roads) {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        priority_queue<pair<int long long, int>, vector<pair<int long long, int>>, greater<pair<int long long, int>>> pq;\\n        vector<int long long> dist(n, LONG_MAX);\\n        vector<int long long> ways(n, 0);\\n        ways[0] = 1;\\n        dist[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()) {\\n            auto node = pq.top();\\n            pq.pop();\\n            for(auto &it:adj[node.second]) {\\n                if(node.first + it.second < dist[it.first]) {\\n                    dist[it.first] = node.first+it.second;\\n                    ways[it.first] = ways[node.second];\\n                    pq.push({dist[it.first], it.first});\\n                }\\n                else if(node.first + it.second == dist[it.first]) {\\n                    // cout<<\"YES\\\\n\";\\n                    ways[it.first] = (ways[it.first] + ways[node.second])%MOD; \\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        int MOD = (int) 1e9+7;\\n        vector<pair<int, int>> adj[n];\\n        for(auto &it : roads) {\\n            adj[it[0]].push_back({it[1], it[2]});\\n            adj[it[1]].push_back({it[0], it[2]});\\n        }\\n        priority_queue<pair<int long long, int>, vector<pair<int long long, int>>, greater<pair<int long long, int>>> pq;\\n        vector<int long long> dist(n, LONG_MAX);\\n        vector<int long long> ways(n, 0);\\n        ways[0] = 1;\\n        dist[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()) {\\n            auto node = pq.top();\\n            pq.pop();\\n            for(auto &it:adj[node.second]) {\\n                if(node.first + it.second < dist[it.first]) {\\n                    dist[it.first] = node.first+it.second;\\n                    ways[it.first] = ways[node.second];\\n                    pq.push({dist[it.first], it.first});\\n                }\\n                else if(node.first + it.second == dist[it.first]) {\\n                    // cout<<\"YES\\\\n\";\\n                    ways[it.first] = (ways[it.first] + ways[node.second])%MOD; \\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3952496,
                "title": "c-90-beats-easy-to-understand-dijkstra-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever we have to calculate minimum path -> dijkastra comes in mind\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple dijkastra with storing count of path\\n# Complexity\\n- Time complexity: E(log(V))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N+M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int cntmin(vector<pair<int,int>> adj[],priority_queue<pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>>> &pq,vector<long long> &dis,int n){\\n        \\n        vector<long long> comingPath(n,0);\\n        \\n       int mod=(1e9+7); \\n        \\n        pq.push({0,0}); \\n        comingPath[0]=1;\\n        dis[0]=0;\\n        \\n        \\n        while(!pq.empty()){\\n            \\n            long d=pq.top().first;\\n            int node=pq.top().second; \\n            pq.pop(); \\n            \\n            for(auto &it:adj[node]){\\n                \\n                int u=it.first; \\n                long wt=it.second; \\n                \\n                if(d+wt<dis[u]){\\n                    dis[u]=d+wt; \\n                    pq.push({d+wt,u});\\n                    comingPath[u]=comingPath[node];\\n                }\\n                else if(d+wt==dis[u]){\\n                    comingPath[u]=(comingPath[u]+comingPath[node])%mod;\\n                }\\n                \\n            }\\n        }\\n        \\n        return int(comingPath[n-1]%mod);\\n    }\\n    \\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n         vector<long long> dis(n,1e18); \\n        dis[0]=0;\\n        priority_queue<pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>>> pq;\\n        \\n        vector<pair<int,int>> adj[n]; \\n        \\n        for(auto &it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        } \\n        \\n        return  cntmin(adj,pq,dis,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int cntmin(vector<pair<int,int>> adj[],priority_queue<pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>>> &pq,vector<long long> &dis,int n){\\n        \\n        vector<long long> comingPath(n,0);\\n        \\n       int mod=(1e9+7); \\n        \\n        pq.push({0,0}); \\n        comingPath[0]=1;\\n        dis[0]=0;\\n        \\n        \\n        while(!pq.empty()){\\n            \\n            long d=pq.top().first;\\n            int node=pq.top().second; \\n            pq.pop(); \\n            \\n            for(auto &it:adj[node]){\\n                \\n                int u=it.first; \\n                long wt=it.second; \\n                \\n                if(d+wt<dis[u]){\\n                    dis[u]=d+wt; \\n                    pq.push({d+wt,u});\\n                    comingPath[u]=comingPath[node];\\n                }\\n                else if(d+wt==dis[u]){\\n                    comingPath[u]=(comingPath[u]+comingPath[node])%mod;\\n                }\\n                \\n            }\\n        }\\n        \\n        return int(comingPath[n-1]%mod);\\n    }\\n    \\n    \\n    int countPaths(int n, vector<vector<int>>& roads) {\\n         vector<long long> dis(n,1e18); \\n        dis[0]=0;\\n        priority_queue<pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>>> pq;\\n        \\n        vector<pair<int,int>> adj[n]; \\n        \\n        for(auto &it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        } \\n        \\n        return  cntmin(adj,pq,dis,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951137,
                "title": "c-most-optimal-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(E logV)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<pair<long long ,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        vector<long long >dis(n,1e15),ways(n,0);\\n        ways[0]=1;\\n        dis[0]=0;\\n        int mod=(int)1e9+7;\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            long long dist=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                long long adjW=it.second;\\n                if(dist+adjW < dis[adjNode]){\\n                    dis[adjNode]=dist+adjW;\\n                    pq.push({dist+adjW,adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if(dist + adjW ==dis[adjNode]){\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        priority_queue<pair<long long ,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        vector<long long >dis(n,1e15),ways(n,0);\\n        ways[0]=1;\\n        dis[0]=0;\\n        int mod=(int)1e9+7;\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            long long dist=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                long long adjW=it.second;\\n                if(dist+adjW < dis[adjNode]){\\n                    dis[adjNode]=dist+adjW;\\n                    pq.push({dist+adjW,adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if(dist + adjW ==dis[adjNode]){\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%mod;\\n                }\\n            }\\n        }\\n\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941404,
                "title": "easy-to-understand-dijkstra-s-solution-explained",
                "content": "# Complexity\\n- Time complexity: $$O(V^2*log(V))$$ \\n\\n- Space complexity: $$O(V)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n];\\n        vector<long long> time(n,1e15);\\n        vector<int> paths(n,0);\\n        priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;\\n\\n        //Step 1: make a adjacency list\\n        for(auto r : roads)\\n        {\\n            adj[r[0]].push_back({r[1],r[2]});\\n            adj[r[1]].push_back({r[0],r[2]});\\n        }\\n\\n        pq.push({0,0});  //{time,node}\\n        time[0] = 0;\\n        paths[0] = 1;\\n\\n       //Step 2: apply dijkstra\\'s algorithm\\n        while(!pq.empty())\\n        {\\n            int node = pq.top().second;\\n            long long timeOfNode = pq.top().first;\\n            pq.pop();\\n\\n            for(auto next : adj[node])\\n            {\\n                int child = next.first;\\n                int wt = next.second;\\n                if(time[child] == timeOfNode + wt)\\n                {   //if we reach a node again from some other path in same time as earlier\\n                    paths[child] = (paths[child] + paths[node]) % 1000000007;    \\n                }  \\n                else if(time[child] > timeOfNode + wt)\\n                {   //if we find a new minimum time to reach a node\\n                    paths[child] = (paths[node]) % 1000000007;\\n                    time[child] = timeOfNode + wt;\\n                    pq.push({time[child],child});\\n                }\\n            }\\n        }\\n\\n    return paths[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n];\\n        vector<long long> time(n,1e15);\\n        vector<int> paths(n,0);\\n        priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;\\n\\n        //Step 1: make a adjacency list\\n        for(auto r : roads)\\n        {\\n            adj[r[0]].push_back({r[1],r[2]});\\n            adj[r[1]].push_back({r[0],r[2]});\\n        }\\n\\n        pq.push({0,0});  //{time,node}\\n        time[0] = 0;\\n        paths[0] = 1;\\n\\n       //Step 2: apply dijkstra\\'s algorithm\\n        while(!pq.empty())\\n        {\\n            int node = pq.top().second;\\n            long long timeOfNode = pq.top().first;\\n            pq.pop();\\n\\n            for(auto next : adj[node])\\n            {\\n                int child = next.first;\\n                int wt = next.second;\\n                if(time[child] == timeOfNode + wt)\\n                {   //if we reach a node again from some other path in same time as earlier\\n                    paths[child] = (paths[child] + paths[node]) % 1000000007;    \\n                }  \\n                else if(time[child] > timeOfNode + wt)\\n                {   //if we find a new minimum time to reach a node\\n                    paths[child] = (paths[node]) % 1000000007;\\n                    time[child] = timeOfNode + wt;\\n                    pq.push({time[child],child});\\n                }\\n            }\\n        }\\n\\n    return paths[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937873,
                "title": "c-solution-using-priority-queue-faster-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n//dijkstra\\'s algorithm is used\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n];\\n        for(vector<int> &v : roads){\\n            adj[v[0]].push_back({v[1],v[2]});\\n            adj[v[1]].push_back({v[0],v[2]});\\n        }\\n        \\n        int mod = 1e9 + 7;\\n        vector<long long> ways(n,0); // ways[i] => no of ways to reach at node i with shortest time\\n        vector<long long> dist(n,1e18); // dist[i] => minimum time taken to reach at node i\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> pq;//store {node,shortest distance}\\n\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            long long d = pq.top().first;\\n            int  node = pq.top().second;\\n            pq.pop();\\n\\n            for(pair<int,long long> p : adj[node]){\\n                int u = p.first;\\n                int udist=p.second;\\n                if(dist[u] > d + udist){\\n                    //means first time of arriving\\n                    dist[u] = d + udist;\\n                    ways[u] = ways[node];\\n                    pq.push({dist[u],u});\\n                }\\n                else if(dist[u] == d + udist){\\n                    ways[u] = (ways[u] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)(ways[n-1]%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph",
                    "Topological Sort",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//dijkstra\\'s algorithm is used\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n];\\n        for(vector<int> &v : roads){\\n            adj[v[0]].push_back({v[1],v[2]});\\n            adj[v[1]].push_back({v[0],v[2]});\\n        }\\n        \\n        int mod = 1e9 + 7;\\n        vector<long long> ways(n,0); // ways[i] => no of ways to reach at node i with shortest time\\n        vector<long long> dist(n,1e18); // dist[i] => minimum time taken to reach at node i\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> pq;//store {node,shortest distance}\\n\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            long long d = pq.top().first;\\n            int  node = pq.top().second;\\n            pq.pop();\\n\\n            for(pair<int,long long> p : adj[node]){\\n                int u = p.first;\\n                int udist=p.second;\\n                if(dist[u] > d + udist){\\n                    //means first time of arriving\\n                    dist[u] = d + udist;\\n                    ways[u] = ways[node];\\n                    pq.push({dist[u],u});\\n                }\\n                else if(dist[u] == d + udist){\\n                    ways[u] = (ways[u] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)(ways[n-1]%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932550,
                "title": "best-application-of-the-dijekstra-algorithm-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    using ll = long long;\\n    const int mod = 1e9 + 7;\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<ll> dis(n,1e15);\\n        dis[0] = 0;\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        pq.push({0,0});\\n        vector<pair<ll,ll>>adj[n];\\n        for(int i=0;i<roads.size();i++){\\n            int a = roads[i][0];\\n            int b = roads[i][1];\\n            ll wt = (ll)roads[i][2];\\n            adj[a].push_back({wt,b});\\n            adj[b].push_back({wt,a});\\n        }\\n        vector<int> ways(n,0);\\n        ways[0] = 1;\\n        while(pq.empty() == false){\\n            ll distance = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[node]){\\n                int adjnode = it.second;\\n                ll wt = (ll)it.first;\\n                if(dis[adjnode] > distance + wt){\\n                    dis[adjnode] = (ll)distance + wt;\\n                    ways[adjnode] = ways[node]%mod;//to the adjnode first time i came  via node \\n                    pq.push({dis[adjnode],adjnode});\\n                }\\n                else if(dis[adjnode] == distance + wt){\\n                    ways[adjnode] = (ways[adjnode]%mod + ways[node]%mod)%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using ll = long long;\\n    const int mod = 1e9 + 7;\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<ll> dis(n,1e15);\\n        dis[0] = 0;\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        pq.push({0,0});\\n        vector<pair<ll,ll>>adj[n];\\n        for(int i=0;i<roads.size();i++){\\n            int a = roads[i][0];\\n            int b = roads[i][1];\\n            ll wt = (ll)roads[i][2];\\n            adj[a].push_back({wt,b});\\n            adj[b].push_back({wt,a});\\n        }\\n        vector<int> ways(n,0);\\n        ways[0] = 1;\\n        while(pq.empty() == false){\\n            ll distance = pq.top().first;\\n            ll node = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[node]){\\n                int adjnode = it.second;\\n                ll wt = (ll)it.first;\\n                if(dis[adjnode] > distance + wt){\\n                    dis[adjnode] = (ll)distance + wt;\\n                    ways[adjnode] = ways[node]%mod;//to the adjnode first time i came  via node \\n                    pq.push({dis[adjnode],adjnode});\\n                }\\n                else if(dis[adjnode] == distance + wt){\\n                    ways[adjnode] = (ways[adjnode]%mod + ways[node]%mod)%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928574,
                "title": "just-use-longs",
                "content": "The constraints on this question are so stupid. I wasted so much time because I couldn\\'t figure out the issue in my code. \\n\\nPlease just use long array for distance and ways/steps count arrays. Below is my java solution for reference.\\n\\n```\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n        final long MOD = (long)(1e9 + 7);\\n        \\n        List<Pair>[] graph = new List[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        for (int[] el: roads) {\\n            int u = el[0];\\n            int v = el[1];\\n            int w = el[2];\\n            graph[u].add(new Pair(v, w));\\n            graph[v].add(new Pair(u, w));\\n        }\\n        \\n        long[] dist = new long[n];\\n        Arrays.fill(dist, Long.MAX_VALUE);\\n        dist[0] = 0;\\n        \\n        long[] ways = new long[n];\\n        ways[0] = 1;\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Long.compare(a.dist, b.dist));\\n        pq.offer(new Pair(0, 0));\\n        \\n        while (!pq.isEmpty()) {\\n            Pair top = pq.poll();\\n            int node = (int) top.node;\\n            long dis  = top.dist;\\n            \\n            for (Pair ng: graph[node]) {\\n                int adjNode = (int) ng.node;\\n                long edW = ng.dist;\\n                \\n                if (edW + dis < dist[adjNode]) {\\n                    dist[adjNode] = edW + dis;\\n                    pq.offer(new Pair(adjNode, edW + dis));\\n                    ways[adjNode] = ways[node];\\n                } else if (dis + edW == dist[adjNode]) \\n                    ways[adjNode] = (ways[adjNode]  % MOD + ways[node]  % MOD) % MOD;\\n                    \\n            }\\n        }\\n        \\n        return (int)(ways[n-1] % MOD);\\n    }\\n}\\n\\nclass Pair {\\n    long node;\\n    long dist;\\n    \\n    Pair(long node, long dist) {\\n        this.node = node;\\n        this.dist = dist;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n        final long MOD = (long)(1e9 + 7);\\n        \\n        List<Pair>[] graph = new List[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        for (int[] el: roads) {\\n            int u = el[0];\\n            int v = el[1];\\n            int w = el[2];\\n            graph[u].add(new Pair(v, w));\\n            graph[v].add(new Pair(u, w));\\n        }\\n        \\n        long[] dist = new long[n];\\n        Arrays.fill(dist, Long.MAX_VALUE);\\n        dist[0] = 0;\\n        \\n        long[] ways = new long[n];\\n        ways[0] = 1;\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Long.compare(a.dist, b.dist));\\n        pq.offer(new Pair(0, 0));\\n        \\n        while (!pq.isEmpty()) {\\n            Pair top = pq.poll();\\n            int node = (int) top.node;\\n            long dis  = top.dist;\\n            \\n            for (Pair ng: graph[node]) {\\n                int adjNode = (int) ng.node;\\n                long edW = ng.dist;\\n                \\n                if (edW + dis < dist[adjNode]) {\\n                    dist[adjNode] = edW + dis;\\n                    pq.offer(new Pair(adjNode, edW + dis));\\n                    ways[adjNode] = ways[node];\\n                } else if (dis + edW == dist[adjNode]) \\n                    ways[adjNode] = (ways[adjNode]  % MOD + ways[node]  % MOD) % MOD;\\n                    \\n            }\\n        }\\n        \\n        return (int)(ways[n-1] % MOD);\\n    }\\n}\\n\\nclass Pair {\\n    long node;\\n    long dist;\\n    \\n    Pair(long node, long dist) {\\n        this.node = node;\\n        this.dist = dist;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927311,
                "title": "c-dijkstra-clean-concise-and-detailed-solution",
                "content": "# Note: In case any image/dry run is not clear please refer to the video attached at the bottom. \\n\\n# Intuition: \\nSince there can be many paths to reach a destination node from the given source node, in this problem, we have to find all those paths that are the shortest in order to reach our destination. For an easier understanding of this particular problem, we can say that we can divide the problem into partitions such as illustrated below :\\n\\n\\nFrom the above picture, we may assume that there will be 3 shortest paths to the destination node. But that may not be the case every time. Let us understand how \\u2013 We assume the total number of ways in which the destination node is reachable by the shortest possible distance be ways[node] where \\u2018node\\u2019 depicts the destination node and node1, node2 and node3 are the three nodes which act as intermediate nodes that provide shortest paths to the destination. We can say :\\n\\nways[node] = ways[node1] + ways[node2] + ways[node3] \\nWhere, ways[node1], ways[node2], and ways[node3] are the number of shortest paths possible to node1, node2, and node3 respectively from the source node, the sum of which is the total possible shortest paths and that can be hence greater than 3.\\n\\n# Approach:\\n\\nThis problem is based on Dijkstra\\u2019s Algorithm where we count all the possible shortest paths from the source to the destination node.\\n\\nInitial configuration:\\n\\nPriority Queue: Define a Priority Queue which would contain pairs of the type {dist, node }, where \\u2018dist\\u2019 indicates the currently updated value of the shortest dist taken to reach from source to the current \\u2018node\\u2019.\\nDistance Array: Define a distance array that would contain the minimum distance from the start node to the current node. If a cell is marked as \\u2018infinity\\u2019 then it is treated as unreachable/ unvisited.\\nSource Node: Define the start node from where we have to calculate the total number of shortest paths.\\nWays Array: Define a ways array which would contain the number of possible shortest ways/paths for each node. Eventually, we would want to return ways[n-1] where n= Number of nodes.\\nThe Algorithm consists of the following steps :\\n\\nStart by creating an adjacency list, a priority queue that stores the dist-node pairs in the form {dist, node} and a dist array with each node initialized with a very large number ( to indicate that the nodes have not been visited initially). \\nIn addition to the standard configuration of Dijkstra\\u2019s algorithm, we have one more array in this problem by the name \\u2018ways\\u2019 which is initialized to \\u20180\\u2019 for every node when they\\u2019re unvisited (so the number of ways is 0).\\nNow, we push the start node to the queue along with its distance marked as \\u20180\\u2019 and ways marked as \\u20181\\u2019 initially because we\\u2019ve just started the algorithm.\\nPop the element from the front of the queue and look out for its adjacent nodes.\\nIf the current dist value for a number is better than the previous distance indicated by the distance array, we update the distance in the array and push it to the queue. Now, here side by side we also keep the number of ways to the \\u2018node\\u2019 the same as before.\\nIf the current dist value is the same as the previously stored dist value at the same index, increment the number of ways by 1 at that index.\\nWe repeat the above steps until the queue becomes empty or till we reach the destination.\\nReturn the ways[n-1] modulo 10^9+7 when the queue becomes empty.\\nHere\\u2019s a quick demonstration of the Algorithm\\u2019s 1st iteration for example 1 stated above ( all the further iterations would be done in a similar way ) :\\n![image.png](https://assets.leetcode.com/users/images/12d47501-cf84-4670-aab1-d583f83b7ebd_1692367867.8850803.png)\\n\\n# Complexity\\n- Time Complexity: \\n- O( E* log(V)) { As we are using simple Dijkstra\\u2019s algorithm here, the time complexity will be or the order E*log(V)}\\n\\nWhere E = Number of edges and V = No. of vertices.\\n\\n- Space Complexity :  \\n- O(N) { for dist array + ways array + approximate complexity for priority queue }\\n\\nWhere, N = Number of nodes.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7;\\n\\n    int countPaths(int n, vector<vector<int>>& roads)\\n    {\\n        vector<pair<int, int>> adj[n];\\n        for (auto x : roads) \\n        {\\n            int u = x[0];\\n            int v = x[1];\\n            int wt = x[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n\\n        vector<long long> dist(n, 1e18);\\n        vector<long long> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;  // There\\'s one way to reach the starting node\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n\\n        while (!pq.empty()) \\n        {\\n            auto it = pq.top();\\n            long long dis = it.first;\\n            int node = it.second;\\n            pq.pop();\\n\\n            if (dis > dist[node]) \\n            {\\n                continue; // Skip outdated entries in the priority queue\\n            }\\n\\n            for (auto x : adj[node]) \\n            {\\n                int adjnode = x.first;\\n                int time = x.second;\\n\\n                if (dis + time < dist[adjnode]) \\n                {\\n                    dist[adjnode] = dis + time;\\n                    ways[adjnode] = ways[node];\\n                    pq.push({dist[adjnode], adjnode});\\n                }\\n                else if (dis + time == dist[adjnode])\\n                {\\n                    ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9 + 7;\\n\\n    int countPaths(int n, vector<vector<int>>& roads)\\n    {\\n        vector<pair<int, int>> adj[n];\\n        for (auto x : roads) \\n        {\\n            int u = x[0];\\n            int v = x[1];\\n            int wt = x[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n\\n        vector<long long> dist(n, 1e18);\\n        vector<long long> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;  // There\\'s one way to reach the starting node\\n        \\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, 0});\\n\\n        while (!pq.empty()) \\n        {\\n            auto it = pq.top();\\n            long long dis = it.first;\\n            int node = it.second;\\n            pq.pop();\\n\\n            if (dis > dist[node]) \\n            {\\n                continue; // Skip outdated entries in the priority queue\\n            }\\n\\n            for (auto x : adj[node]) \\n            {\\n                int adjnode = x.first;\\n                int time = x.second;\\n\\n                if (dis + time < dist[adjnode]) \\n                {\\n                    dist[adjnode] = dis + time;\\n                    ways[adjnode] = ways[node];\\n                    pq.push({dist[adjnode], adjnode});\\n                }\\n                else if (dis + time == dist[adjnode])\\n                {\\n                    ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n                }\\n            }\\n        }\\n        return ways[n - 1] % mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923398,
                "title": "any-insights-on-deque-vs-heapq-for-this-problem",
                "content": "When I use pq:deque() for storing (curr_dist, curr_node), I get wrong answer and then I switched it to heapq, cause I guess that when multiple nodes with same curr_dist waiting to be popped, the order might matter and I think it does because heapq automatically pops the smallest second index if multiple elements with same first index value?\\ne.x.hq=[(0,2),(0,1),(1,2)]=> (0,1) popped first in heapq and I got the implementation correct.\\nQuestion: \\n* Plz share any insights on deque.popleft() vs heapq.heappop()? \\n* why popping order matters [has to be smallest node to largest] for this specific problem?\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "When I use pq:deque() for storing (curr_dist, curr_node), I get wrong answer and then I switched it to heapq, cause I guess that when multiple nodes with same curr_dist waiting to be popped, the order might matter and I think it does because heapq automatically pops the smallest second index if multiple elements with same first index value?\\ne.x.hq=[(0,2),(0,1),(1,2)]=> (0,1) popped first in heapq and I got the implementation correct.\\nQuestion: \\n* Plz share any insights on deque.popleft() vs heapq.heappop()? \\n* why popping order matters [has to be smallest node to largest] for this specific problem?\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3922521,
                "title": "dijkstra-s-algorithm-graph-bfs-updated",
                "content": "\\n\\n# Approach\\nDijkstra\\'s Algorithm :Graph\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n     // Creating an adjacency list for the given graph.\\n        ArrayList < ArrayList < Pair >> adj = new ArrayList < > ();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList < > ());\\n        }\\n        int m = roads.length;\\n        for (int i = 0; i < m; i++) {\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],(long) roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],(long) roads[i][2]));\\n        }\\n\\n        // Defining a priority queue (min heap). \\n        PriorityQueue < Pair > pq = new PriorityQueue < Pair > ((x, y) -> Long.compare(x.second ,y.second));\\n\\n        // Initializing the dist array and the ways array\\n        // along with their first indices.\\n       \\n        int[] ways = new int[n];\\n        long[] dist= new long[n];\\n        Arrays.fill(dist, Long.MAX_VALUE/2);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.add(new Pair(0, 0));\\n\\n        // Define modulo value\\n        int mod = (int)(1e9 + 7);  \\n\\n        while(pq.size()!=0){\\n\\n            int node = pq.peek().first;\\n             long weight= pq.peek().second; // time take to reach current node { min in heap}\\n             pq.remove();\\n\\n            for(Pair e : adj.get(node)){\\n\\n                int edjnode = e.first; //adjecent node\\n                long edjWeight= e.second;\\n            \\n\\n                if(weight + edjWeight < dist[edjnode]){ // if recorded weight is greater than current than change it , as we found new sortest distance to reach that adjecent node\\n                // this also tell us its first time with this distance so num of ways count is same as its parent node has\\n                //as it is possible that parent has more than 1 way to reach it , to its will indirectly become numbers of ways to reach this adjcent node\\n                    dist[edjnode] = weight + edjWeight;  \\n                    //add it to min. heap for future calls\\n                    pq.add(new Pair(edjnode,weight + edjWeight ));\\n                    ways[edjnode]= ways[node];\\n\\n                }\\n\\n\\n\\n                //now if its note a first time  with new shortest distanc e\\n                // we got new conditions , either new calculated weight becoms larger than previouslly recoded or equal\\n                //if its larger we don\\'t consider that path okay\\n\\n                //what if its equal \\n                    //means we reach again with same weight to same node \\n                    //so if its note first than we can say that \\n                    //it is a another way to reach this current adjecent node\\n                    //via a defferent parent node \\n                    //so add it to the ways of reach this adjecent node\\n\\n                  else if(weight + edjWeight == dist[edjnode]){\\n\\n                        ways[edjnode]= ( ways[edjnode] + ways[node]) % mod;\\n                  }\\n\\n            }\\n\\n        }\\n   // Finally, we return the no. of ways to reach\\n        // (n-1)th node modulo 10^9+7.\\n        return ways[n-1] % mod;\\n    }\\n}\\n\\nclass Pair {\\n    int first;\\n    long second;\\n    public Pair(int first, long second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int countPaths(int n, int[][] roads) {\\n     // Creating an adjacency list for the given graph.\\n        ArrayList < ArrayList < Pair >> adj = new ArrayList < > ();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList < > ());\\n        }\\n        int m = roads.length;\\n        for (int i = 0; i < m; i++) {\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],(long) roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],(long) roads[i][2]));\\n        }\\n\\n        // Defining a priority queue (min heap). \\n        PriorityQueue < Pair > pq = new PriorityQueue < Pair > ((x, y) -> Long.compare(x.second ,y.second));\\n\\n        // Initializing the dist array and the ways array\\n        // along with their first indices.\\n       \\n        int[] ways = new int[n];\\n        long[] dist= new long[n];\\n        Arrays.fill(dist, Long.MAX_VALUE/2);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.add(new Pair(0, 0));\\n\\n        // Define modulo value\\n        int mod = (int)(1e9 + 7);  \\n\\n        while(pq.size()!=0){\\n\\n            int node = pq.peek().first;\\n             long weight= pq.peek().second; // time take to reach current node { min in heap}\\n             pq.remove();\\n\\n            for(Pair e : adj.get(node)){\\n\\n                int edjnode = e.first; //adjecent node\\n                long edjWeight= e.second;\\n            \\n\\n                if(weight + edjWeight < dist[edjnode]){ // if recorded weight is greater than current than change it , as we found new sortest distance to reach that adjecent node\\n                // this also tell us its first time with this distance so num of ways count is same as its parent node has\\n                //as it is possible that parent has more than 1 way to reach it , to its will indirectly become numbers of ways to reach this adjcent node\\n                    dist[edjnode] = weight + edjWeight;  \\n                    //add it to min. heap for future calls\\n                    pq.add(new Pair(edjnode,weight + edjWeight ));\\n                    ways[edjnode]= ways[node];\\n\\n                }\\n\\n\\n\\n                //now if its note a first time  with new shortest distanc e\\n                // we got new conditions , either new calculated weight becoms larger than previouslly recoded or equal\\n                //if its larger we don\\'t consider that path okay\\n\\n                //what if its equal \\n                    //means we reach again with same weight to same node \\n                    //so if its note first than we can say that \\n                    //it is a another way to reach this current adjecent node\\n                    //via a defferent parent node \\n                    //so add it to the ways of reach this adjecent node\\n\\n                  else if(weight + edjWeight == dist[edjnode]){\\n\\n                        ways[edjnode]= ( ways[edjnode] + ways[node]) % mod;\\n                  }\\n\\n            }\\n\\n        }\\n   // Finally, we return the no. of ways to reach\\n        // (n-1)th node modulo 10^9+7.\\n        return ways[n-1] % mod;\\n    }\\n}\\n\\nclass Pair {\\n    int first;\\n    long second;\\n    public Pair(int first, long second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922284,
                "title": "c-no-of-ways-to-reach-destination-in-least-time",
                "content": "# Intuition\\nUse same Dijkastra but with little modification.\\nwe\\'ll use ways[] array to mark the times we visit a node using some other paths but the distance in all paths were same.\\n\\n# Approach\\n1. If distance[itr] > wt + prev_wt , simply update the distance array as it is being viisted for first time, and the ways will be ways[itr] = ways[node]: (no of ways to visite prev node.). and finally put the distance and node in the priority queue.\\n2. If distance[itr] == wt + prev_wt, simply add the ways[node] + ways[itr]. but don\\'t put the distance, and node in priority queue, (time complexity will increase)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // shortest path:: dijkastra:: min_heap_priority queue:: cnt all ways::\\n        // adjacency list of (u->v, wts)\\n        vector<vector<pair<int,int>>>adj(n);\\n        for(int i=0;i<roads.size();i++){\\n          int u = roads[i][0];\\n          int v = roads[i][1];\\n          int wt = roads[i][2];\\n          adj[u].push_back({v, wt});\\n          adj[v].push_back({u, wt});\\n        }\\n        // min heap priority queue.\\n        priority_queue< pair<long , long>, vector<pair<long , long>>, greater<pair<long , long>>  > pq;\\n        pq.push({0, 0}); // starting distance and node \\n        vector<long >distance(n, 1e18); \\n        vector<int>ways(n,0);\\n        ways[0] = 1;\\n        int mod = 1e9+7;\\n        distance[0] = 0;\\n        int cnt = 0;\\n        // int shortest_path = 1e9+1;\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int node = it.second;\\n            long  dist = it.first;\\n            // if we visited the target: keep getting the shortest distance guy.\\n            if(node == n-1){\\n               return ways[node]%mod;\\n                // shortest_path = dist;\\n                \\n            }\\n\\n            // visiting all the adjacent neighbours of node.\\n            for(auto itr: adj[node]){\\n                long  wt = itr.second;\\n                int target = itr.first;\\n                // if we got better path to reach target.\\n                if(distance[target] == wt+dist){\\n                    ways[target] = (ways[target]%mod + ways[node]%mod)%mod;\\n                }\\n                else if(distance[target] > wt+dist) {\\n                    ways[target] = ways[node];\\n                    distance[target] = wt+dist;\\n                    pq.push({wt+dist, target});\\n\\n                }\\n\\n            }\\n        }\\n            return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // shortest path:: dijkastra:: min_heap_priority queue:: cnt all ways::\\n        // adjacency list of (u->v, wts)\\n        vector<vector<pair<int,int>>>adj(n);\\n        for(int i=0;i<roads.size();i++){\\n          int u = roads[i][0];\\n          int v = roads[i][1];\\n          int wt = roads[i][2];\\n          adj[u].push_back({v, wt});\\n          adj[v].push_back({u, wt});\\n        }\\n        // min heap priority queue.\\n        priority_queue< pair<long , long>, vector<pair<long , long>>, greater<pair<long , long>>  > pq;\\n        pq.push({0, 0}); // starting distance and node \\n        vector<long >distance(n, 1e18); \\n        vector<int>ways(n,0);\\n        ways[0] = 1;\\n        int mod = 1e9+7;\\n        distance[0] = 0;\\n        int cnt = 0;\\n        // int shortest_path = 1e9+1;\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int node = it.second;\\n            long  dist = it.first;\\n            // if we visited the target: keep getting the shortest distance guy.\\n            if(node == n-1){\\n               return ways[node]%mod;\\n                // shortest_path = dist;\\n                \\n            }\\n\\n            // visiting all the adjacent neighbours of node.\\n            for(auto itr: adj[node]){\\n                long  wt = itr.second;\\n                int target = itr.first;\\n                // if we got better path to reach target.\\n                if(distance[target] == wt+dist){\\n                    ways[target] = (ways[target]%mod + ways[node]%mod)%mod;\\n                }\\n                else if(distance[target] > wt+dist) {\\n                    ways[target] = ways[node];\\n                    distance[target] = wt+dist;\\n                    pq.push({wt+dist, target});\\n\\n                }\\n\\n            }\\n        }\\n            return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908519,
                "title": "beats-98-67-using-dijkstra-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Dijkstra with a ways array.\\n\\n# Complexity\\n- Time complexity: O(ElogV)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int m = 1e9+7;\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<long, long>> adj[n];\\n\\t\\tfor(int i = 0; i<roads.size(); i++){\\n\\t        adj[(roads[i][0])].push_back({(roads[i][1]), (roads[i][2])});\\n            adj[(roads[i][1])].push_back({(roads[i][0]), (roads[i][2])});\\n\\t    }\\npriority_queue <pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> pq;\\n        vector<long> dist(n, LONG_MAX);\\n        vector<long> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto a = pq.top().first;\\n            auto b = pq.top().second;\\n            pq.pop();\\n            for(auto it: adj[b]){\\n                if((a+it.second)<dist[it.first]){\\n                    dist[it.first] = (it.second + a);\\n                    ways[it.first] = ways[b];\\n                    pq.push({ (it.second + a),it.first});\\n                }else if((a+it.second)==dist[it.first]){\\n                    ways[it.first] = (ways[b]+ways[it.first])%m;\\n                }   \\n            }\\n        }\\n        return ways[n-1]%m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int m = 1e9+7;\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<long, long>> adj[n];\\n\\t\\tfor(int i = 0; i<roads.size(); i++){\\n\\t        adj[(roads[i][0])].push_back({(roads[i][1]), (roads[i][2])});\\n            adj[(roads[i][1])].push_back({(roads[i][0]), (roads[i][2])});\\n\\t    }\\npriority_queue <pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> pq;\\n        vector<long> dist(n, LONG_MAX);\\n        vector<long> ways(n, 0);\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto a = pq.top().first;\\n            auto b = pq.top().second;\\n            pq.pop();\\n            for(auto it: adj[b]){\\n                if((a+it.second)<dist[it.first]){\\n                    dist[it.first] = (it.second + a);\\n                    ways[it.first] = ways[b];\\n                    pq.push({ (it.second + a),it.first});\\n                }else if((a+it.second)==dist[it.first]){\\n                    ways[it.first] = (ways[b]+ways[it.first])%m;\\n                }   \\n            }\\n        }\\n        return ways[n-1]%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897617,
                "title": "simple-python-solution-using-dijkstra-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPaths(self, n: int, road: List[List[int]]) -> int:\\n        graph={}\\n        for i in range(n+1):\\n            graph[i]=[]\\n        for i,j,k in road:\\n            graph[i].append((j,k))\\n            graph[j].append((i,k))  \\n        dist=[float(\\'inf\\')]*n\\n        ways=[0]*n\\n        dist[0]=0 \\n        ways[0]=1\\n        mod=int(10**9 + 7)\\n        pq=[(0,0)]\\n        heapify(pq)\\n        while pq:\\n            wt,node=heappop(pq)\\n            for u,v in graph[node]:\\n                # we are visiting for 1st time\\n                if dist[u]>wt+v:\\n                    dist[u]=wt+v\\n                    heappush(pq,(dist[u],u)) \\n                    ways[u]=ways[node] \\n                elif dist[u]==wt+v:\\n                    ways[u]=(ways[node]+ways[u] )% mod\\n        return ways[n-1]%mod               \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, road: List[List[int]]) -> int:\\n        graph={}\\n        for i in range(n+1):\\n            graph[i]=[]\\n        for i,j,k in road:\\n            graph[i].append((j,k))\\n            graph[j].append((i,k))  \\n        dist=[float(\\'inf\\')]*n\\n        ways=[0]*n\\n        dist[0]=0 \\n        ways[0]=1\\n        mod=int(10**9 + 7)\\n        pq=[(0,0)]\\n        heapify(pq)\\n        while pq:\\n            wt,node=heappop(pq)\\n            for u,v in graph[node]:\\n                # we are visiting for 1st time\\n                if dist[u]>wt+v:\\n                    dist[u]=wt+v\\n                    heappush(pq,(dist[u],u)) \\n                    ways[u]=ways[node] \\n                elif dist[u]==wt+v:\\n                    ways[u]=(ways[node]+ways[u] )% mod\\n        return ways[n-1]%mod               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896419,
                "title": "c-solution-dijkstra-s-algorithm-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>graph(n);\\n        for(auto it : roads){\\n          graph[it[0]].push_back({it[1],it[2]});\\n          graph[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<long long>time(n,LLONG_MAX);\\n        vector<int>ways(n,0);\\n        time[0]=0;\\n        ways[0]=1;\\n        priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>>pq;\\n        pq.push({time[0],0});\\n        int mod = (int)(1e9 + 7);\\n        while(!pq.empty()){\\n          long long tm = pq.top().first, node = pq.top().second;\\n          pq.pop();\\n          for(auto it : graph[node]){\\n            long newTime = tm + it.second, nxtnode = it.first;\\n            if(newTime < time[nxtnode]){\\n              time[nxtnode] = newTime;\\n              pq.push({time[nxtnode],nxtnode});\\n              ways[nxtnode] = ways[node];\\n            }\\n            else if(newTime == time[nxtnode]){\\n              ways[nxtnode] = (ways[nxtnode] + ways[node])%mod;\\n            }\\n          }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>graph(n);\\n        for(auto it : roads){\\n          graph[it[0]].push_back({it[1],it[2]});\\n          graph[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<long long>time(n,LLONG_MAX);\\n        vector<int>ways(n,0);\\n        time[0]=0;\\n        ways[0]=1;\\n        priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>>pq;\\n        pq.push({time[0],0});\\n        int mod = (int)(1e9 + 7);\\n        while(!pq.empty()){\\n          long long tm = pq.top().first, node = pq.top().second;\\n          pq.pop();\\n          for(auto it : graph[node]){\\n            long newTime = tm + it.second, nxtnode = it.first;\\n            if(newTime < time[nxtnode]){\\n              time[nxtnode] = newTime;\\n              pq.push({time[nxtnode],nxtnode});\\n              ways[nxtnode] = ways[node];\\n            }\\n            else if(newTime == time[nxtnode]){\\n              ways[nxtnode] = (ways[nxtnode] + ways[node])%mod;\\n            }\\n          }\\n        }\\n        return ways[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877067,
                "title": "easy-sol-cpp",
                "content": "vector<pair<long long int,long long int>> g[n];\\n        for(auto it: roads)\\n        {\\n            g[it[0]].push_back({it[1],it[2]});\\n            g[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<long long int> dis(n,1e18),ways(n,0);\\n        dis[0]=0;\\n        ways[0]=1;\\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>> q;//{weight,node}\\n        q.push({0,0});\\n        long long int M=1e9+7;\\n        while(!q.empty())\\n        {\\n            long long int dist = q.top().first;\\n            long long int node = q.top().second;\\n            q.pop();\\n            cout<<node<<\" \"<<dist<<\"\\\\n\";\\n            for(auto it:g[node])\\n            {\\n                long long int adjNode = it.first;\\n                long long int edw = it.second;\\n                if(dis[adjNode]>dist+edw)\\n                {\\n                    dis[adjNode]=dist+edw;\\n                    q.push({dist+edw,adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if(dis[adjNode]==dist+edw)\\n                {\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%M;\\n                }\\n            }\\n        }\\n\\t\\treturn ways[n-1];",
                "solutionTags": [],
                "code": "vector<pair<long long int,long long int>> g[n];\\n        for(auto it: roads)\\n        {\\n            g[it[0]].push_back({it[1],it[2]});\\n            g[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<long long int> dis(n,1e18),ways(n,0);\\n        dis[0]=0;\\n        ways[0]=1;\\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>> q;//{weight,node}\\n        q.push({0,0});\\n        long long int M=1e9+7;\\n        while(!q.empty())\\n        {\\n            long long int dist = q.top().first;\\n            long long int node = q.top().second;\\n            q.pop();\\n            cout<<node<<\" \"<<dist<<\"\\\\n\";\\n            for(auto it:g[node])\\n            {\\n                long long int adjNode = it.first;\\n                long long int edw = it.second;\\n                if(dis[adjNode]>dist+edw)\\n                {\\n                    dis[adjNode]=dist+edw;\\n                    q.push({dist+edw,adjNode});\\n                    ways[adjNode]=ways[node];\\n                }\\n                else if(dis[adjNode]==dist+edw)\\n                {\\n                    ways[adjNode]=(ways[adjNode]+ways[node])%M;\\n                }\\n            }\\n        }\\n\\t\\treturn ways[n-1];",
                "codeTag": "C++"
            },
            {
                "id": 3869482,
                "title": "beats-99-78-python-dijkstra-s-algorithm-visit-set-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        # initialize\\n        graph = defaultdict(dict)\\n        \\n        for road in roads:\\n            u, v, minutes = road\\n            graph[u][v] = minutes\\n            graph[v][u] = minutes\\n        \\n        spend = [float(\\'inf\\') for _ in range(n)]\\n        ways = defaultdict(int)\\n        spend[0] = 0\\n        ways[0] = 1\\n        \\n        # normal Dijkstra \\n        heap = []\\n        heapq.heappush(heap, (0, 0))\\n        visited = set()\\n        \\n        while heap:\\n            time, current = heapq.heappop(heap)\\n            if current in visited:\\n                continue\\n            \\n            if current == n - 1:\\n                return ways[current] % 1000000007\\n            visited.add(current)\\n            for nei in graph[current]:\\n                if nei not in visited:\\n                    if time + graph[current][nei] < spend[nei]:\\n                        spend[nei] = time + graph[current][nei]\\n                        # update from current ways as shorter\\n                        ways[nei] = ways[current]\\n                        heapq.heappush(heap, (spend[nei], nei))\\n                    elif time + graph[current][nei] == spend[nei]:\\n                        # add from current ways as same time\\n                        ways[nei] += ways[current]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        # initialize\\n        graph = defaultdict(dict)\\n        \\n        for road in roads:\\n            u, v, minutes = road\\n            graph[u][v] = minutes\\n            graph[v][u] = minutes\\n        \\n        spend = [float(\\'inf\\') for _ in range(n)]\\n        ways = defaultdict(int)\\n        spend[0] = 0\\n        ways[0] = 1\\n        \\n        # normal Dijkstra \\n        heap = []\\n        heapq.heappush(heap, (0, 0))\\n        visited = set()\\n        \\n        while heap:\\n            time, current = heapq.heappop(heap)\\n            if current in visited:\\n                continue\\n            \\n            if current == n - 1:\\n                return ways[current] % 1000000007\\n            visited.add(current)\\n            for nei in graph[current]:\\n                if nei not in visited:\\n                    if time + graph[current][nei] < spend[nei]:\\n                        spend[nei] = time + graph[current][nei]\\n                        # update from current ways as shorter\\n                        ways[nei] = ways[current]\\n                        heapq.heappush(heap, (spend[nei], nei))\\n                    elif time + graph[current][nei] == spend[nei]:\\n                        # add from current ways as same time\\n                        ways[nei] += ways[current]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1798517,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1576273,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1969760,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1981086,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1914545,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1772965,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1735234,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1575841,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 2076688,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 2064297,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1798517,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1576273,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1969760,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1981086,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1914545,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1772965,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1735234,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 1575841,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 2076688,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 2064297,
                "content": [
                    {
                        "username": "harsh_negi_07",
                        "content": "For those who are getting WA for tc-52\nActually cost given is very high for every path that it is exceeding ```1e9``` threshold\nso you have to take ```1e12``` \n[my solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/submissions/896709605/)"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "Thanks a lottttttttttttttt.    i was just stuck  for 1.5 hours"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Try using Long.MAX_VALUE , for java\\n"
                    },
                    {
                        "username": "aglakshya02",
                        "content": "Thank You.."
                    },
                    {
                        "username": "iffthen",
                        "content": "Thanks man!! I was stuck at this...."
                    },
                    {
                        "username": "the_living_tribunal",
                        "content": "When pure dijkstra with continued iteration incrementing ways until dist breaks is \"brute force\" and times out, you know the problem should be a hard..."
                    },
                    {
                        "username": "SG-C",
                        "content": "Too frustrating test cases I failed At 53 Last TC . Leetcode should avoid these types of Test cases."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "+1 bruh :(\\n\\n"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "finally all test cases passed. Just analyze why it comes wrong for 53rd test case.  The reason is the distance array cant be int if the time values are huge. Check out my solution --> [My solution](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/3800689/traditional-dijkstra-s-algo-all-test-cases-passed-beats-95/)"
                    },
                    {
                        "username": "Prajju22",
                        "content": "why dijKStra with normal queue is not working here ANYONE?"
                    },
                    {
                        "username": "prerak13",
                        "content": "I wrote coment for myself to refer in future. hope itll also help you:\\n\\nQUEUE WONT WORK HERE USE PQ\\nconsider- \\na,b,10\\na,d,1\\nb,c,20\\nd,c,2\\nc,e,1\\nsorce=a and dest=b\\nhere if we simply use queue, (a), (b,d), (c,c) here c will output twice\\nusing priority queue ensures that we pop elements distance wise. ie, when a,b,10 and a,d,1  is added, a,d is popped. all paths in the link whose total weight sums less than 10 will be explored first before poping a,b,10"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "Have similar doubt. I hope some hero in the future will help explain to us :)"
                    },
                    {
                        "username": "anantnipunge",
                        "content": "[@HimsHims](/HimsHims)  edge weights are not same."
                    },
                    {
                        "username": "HimsHims",
                        "content": "Stuck on the same doubt.\\n"
                    },
                    {
                        "username": "iffthen",
                        "content": "Dijkstra Always uses a priority queue or any data structure which can store the values in an order, if the edge weights are not same.... if edge weights are same you can use the queue as well.   if im not getting your que.. can you clarify your que?"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "```\\n#define ll long long\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<vector<pll>> graph(n);\\n        for(auto& road: roads) {\\n            ll u = road[0], v = road[1], time = road[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        return dijkstra(graph, n, 0);\\n    }\\n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\\n        vector<ll> dist(n, LONG_MAX);\\n        vector<ll> ways(n);\\n        ways[src] = 1;\\n        dist[src] = 0;\\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\\n        minHeap.push({0, 0}); // dist, src\\n        while (!minHeap.empty()) {\\n            auto[d, u] = minHeap.top(); minHeap.pop();\\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\\n            for(auto [v, time] : graph[u]) {\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    ways[v] = ways[u];\\n                    minHeap.push({dist[v], v});\\n                } else if (dist[v] == d + time) {\\n                    ways[v] = (ways[v] + ways[u]) % MOD;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nwhy this code is working and my code is giving TLE.\\n```\\nclass Compare {\\n    public:\\n       bool operator()(pair<int, int> a, pair<int, int> b){\\n           if(a.first > b.first){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    const long mod = 1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n+1];\\n        for(auto road : roads){\\n            int u = road[0];\\n            int v = road[1];\\n            int time = road[2];\\n            adj[u].push_back({v, time});\\n            adj[v].push_back({u, time});\\n        }\\n        int dist[n];\\n        int ways[n];\\n        for(int i = 0; i < n; i++){\\n            dist[i] = INT_MAX;\\n            ways[i] = 0;\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            int dis = curr.first;\\n            int node = curr.second;\\n            for(auto it : adj[node]){\\n                int ch = it.first;\\n                int time = it.second;\\n                int total_time = (time%mod+dis%mod)%mod;\\n                if(total_time <= dist[ch]){\\n                    if(total_time == dist[ch]){\\n                        ways[ch] = (ways[ch]%mod + ways[node]%mod)%mod;\\n                    }else{\\n                        dist[ch] = total_time;\\n                        ways[ch] = ways[node]%mod;\\n                        pq.push({dist[ch], ch});\\n                    }\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\n```\\nthis is my code what wrong with it it is giving TLE"
                    },
                    {
                        "username": "ANSHAB45",
                        "content": "what part of no solutions in discussion do you not understand"
                    },
                    {
                        "username": "under_dog259",
                        "content": "Only one last TC is giving WA. can someone please help?\\n ```class Solution {\\npublic:\\ntypedef long long ll;\\ntypedef pair<ll, int> pp;\\n    int help(vector<vector<pair<int,int>>> &arr, int n){\\n        vector<int> visit(n, 0);\\n        vector<ll> way(n, 0);\\n        way[0] = 1;\\n        priority_queue<pp, vector<pp>, greater<pp> > pq;\\n        vector<ll> d(n, LONG_MAX);\\n        d[0] = 0;\\n        pq.push({0, 0});\\n        while(!pq.empty()){\\n            pp p = pq.top();\\n            pq.pop();\\n            int node = p.second;\\n            ll dist = p.first;\\n            visit[node] = 1;\\n            for(int i = 0; i < arr[node].size(); i++){                  \\n                if(d[arr[node][i].first] > dist + arr[node][i].second){\\n                d[arr[node][i].first] = (dist + arr[node][i].second) % 1000000007;\\n                pq.push({d[arr[node][i].first], arr[node][i].first});\\n                way[arr[node][i].first] = way[node] % 1000000007;\\n            }\\n                else if(d[arr[node][i].first] == dist + arr[node][i].second){\\n                    way[arr[node][i].first] = (way[arr[node][i].first] + way[node]) % 1000000007;\\n                        }                               \\n            }\\n        }      \\n        return way[n - 1] % 1000000007;\\n    }\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>> adj(n);\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n            adj[u].push_back({v,w});\\n            adj[v].push_back({u,w});\\n        }\\n        int t = help(adj, n);\\n        return t;       \\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    },
                    {
                        "username": "yazary",
                        "content": "Try changing the array / variables adding up the distance to long from int. That should fix the failing test case."
                    },
                    {
                        "username": "PVR_THE_KING",
                        "content": "Did you figure out why last test case is alone failing?"
                    },
                    {
                        "username": "ayush052sharma",
                        "content": "have you sorted out what was the problem?"
                    },
                    {
                        "username": "rajput9189",
                        "content": "![image](https://assets.leetcode.com/users/images/f5bbe355-7fe5-4bf8-b6e6-00fbe2a3cf53_1633895109.5492995.png)\\n"
                    },
                    {
                        "username": "user4902t",
                        "content": "solution solution tab me dena hota bro\\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Even after memoization I am getting TLE \\nAm I super stupid or smth ??"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "I got stuck with the modulo operation thing and eventually gave up and look at the solution :)"
                    }
                ]
            },
            {
                "id": 2059915,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            },
            {
                "id": 2039897,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            },
            {
                "id": 2027151,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            },
            {
                "id": 2017875,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            },
            {
                "id": 2009794,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            },
            {
                "id": 1941983,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            },
            {
                "id": 1919267,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            },
            {
                "id": 1900746,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            },
            {
                "id": 1809235,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            },
            {
                "id": 1779853,
                "content": [
                    {
                        "username": "sourav_maz",
                        "content": "A DFS AND HASHMAP\nOR\nA BFS TO FIND THE SHORTEST WEIGHTED PATH TO DESTINATION AND THEN DFS TO FIND HOW MANY PATHS WITH THAT WEIGHT.\nWILL THIS WORK?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Should be labelled as hard."
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Did anyone try to solve this using dfs and caching?"
                    },
                    {
                        "username": "user3513uL",
                        "content": "int mod = 1e9 ;\\n\\n    int getans( int min , vector<pair<int , int>> adj[] , vector<bool> &visited , int src , int dest , vector<vector<int>> &dp )\\n    {\\n        if( min == 0 && src == dest )\\n        {\\n            return 1 ; \\n        }\\n        if( min == 0 || src == dest )\\n        {\\n            return 0 ; \\n        }\\n        if( min < 0 )\\n        {\\n            return 0 ;\\n        }\\n\\n        if( dp[min][src] != -1 )\\n        {\\n            return dp[min][src] ;\\n        }\\n\\n        visited[src] = 1 ;\\n        int a = 0 ;\\n        for( auto it : adj[src] )\\n        {\\n            if( visited[it.first] == 0 )\\n            {\\n                a = ( a + getans( min - it.second , adj , visited , it.first  , dest , dp ) ) % mod ;\\n            }\\n        }\\n        visited[src] = 0 ;\\n        return dp[min][src] = a % mod ;\\n    }\\n    \\n    int countPaths(int n, vector<vector<int>>& roads) \\n    {\\n        //Graph \\n        vector<pair<int , int>> adj[n] ;\\n        for( int i = 0 ; i < roads.size() ; i++ )\\n        {\\n            adj[roads[i][0]].push_back({ roads[i][1] , roads[i][2] }) ;\\n            adj[roads[i][1]].push_back({ roads[i][0] , roads[i][2] }) ;\\n        }\\n\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater <pair<int,int>>> pq ;\\n        int k = 0 ;\\n        vector<int> dist(n+1, 1e9) ;\\n        dist[k] = 0;\\n        pq.push({0,k}) ;\\n\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int dis = it.first;\\n            int node = it.second ;\\n\\n            for( auto it : adj[node]){\\n                int adjnode = it.first;\\n                int wt = it.second ;\\n\\n                if(dist[adjnode] > dis +wt)\\n                {\\n                    dist[adjnode] = wt+dis;\\n                    pq.push({dis+wt, adjnode});\\n                }\\n            }\\n        }\\n\\n        int min = dist[n-1] ;\\n        int count = 0 ;\\n        vector<bool> visited ( n , 0 ) ;\\n        int src = 0 ;\\n        int dest = n - 1 ;\\n        vector<vector<int>> dp( min + 3 , vector<int>( n + 2 , - 1 ) ) ;\\n        return getans( min , adj , visited , src , dest , dp ) ; \\n    }\\n\\ncan someone please explain me why am I getting wrong answer in test case 36 .. first I had used dijkstra\\'s algorithm to get the min value to reach source to destination and then I had used DP to get the number of ways so that we can reach the destination in the specified minimum cost . \\n  "
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I have written a code using djikstra without a visited array and it is working fine till 45 test cases, unfortunately, I am never able to understand where to use the %mod, only at the end or even when updating the ways array? Some please tell me where do i have to add them in the following code\n\n`class Solution {\n    public int countPaths(int n, int[][] roads) {\n        int[] ways= new int[n];\n        ways[0]=1;\n        int dist[] = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0]=0;\n        PriorityQueue<Pair> pq= new PriorityQueue<>();\n        pq.add(new Pair(0, 0));\n        while(!pq.isEmpty()){\n            Pair p= pq.poll();\n            for(int[] road: roads){\n                int s1= road[0];\n                int s2= road[1];\n                int w= road[2];\n                if(s1==p.i){\n                    if(dist[s2]>dist[s1]+w){\n                        dist[s2]=dist[s1]+w;\n                        ways[s2]= ways[s1];\n                        pq.add(new Pair(s2, dist[s2]));\n                    }\n                    else if(dist[s2]==dist[s1]+w){\n                        ways[s2] += ways[s1];\n                    }\n                    \n                }\n                else if(s2==p.i){\n                    if(dist[s1]>dist[s2]+w){\n                        dist[s1]=dist[s2]+w;\n                        ways[s1]= ways[s2];\n                        pq.add(new Pair(s1, dist[s1]));\n                    }\n                    else if(dist[s1]==dist[s2]+w){\n                        ways[s1] += ways[s2];\n                    } } } }\n\n        return ways[n-1];\n    }\n}\nclass Pair implements Comparable<Pair>{\n    int i; int d;\n    Pair(int i, int d){\n        this.i=i; this.d=d;\n    }\n    public int compareTo(Pair p){\n        return this.d- p.d;\n    }\n} `"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "class Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        vector<long long>dist(n,LLONG_MAX);\\n        vector<pair<int,int>>adj[n];\\n        vector<int>ways(n,0);\\n        for(int i = 0;i<roads.size();i++){\\n            long long u = roads[i][0];\\n            long long v = roads[i][1];\\n            long long cost = roads[i][2];\\n            adj[u].push_back({v,cost});\\n            adj[v].push_back({u,cost});\\n        }\\n        dist[0] = 0;\\n        ways[0] = 1;\\n        int mod = (int)1e9+7;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({0,0});\\n        while(!pq.empty()){\\n            pair<long long,int> temp = pq.top();\\n            long long distance = temp.first;\\n            long long node = temp.second;\\n            pq.pop();\\n            for(auto i:adj[node]){\\n                long long adjnode = i.first;\\n                long long cost = i.second;\\n                if(cost + distance < dist[adjnode]){\\n                    dist[adjnode] = (cost + distance)%mod;\\n                    pq.push({dist[adjnode],adjnode});\\n                    ways[adjnode] = (ways[node])%mod;\\n                }\\n                else if(cost + distance == dist[adjnode]){\\n                        ways[adjnode] = (ways[adjnode] + ways[node])%mod;\\n                }\\n            }\\n        }\\n        return ways[n-1];\\n    }\\n};\\ncan anyone find error in typecasting tc->48 not wroking"
                    },
                    {
                        "username": "heytejaswi",
                        "content": "return ways[n-1]%mod;"
                    },
                    {
                        "username": "user3699Tu",
                        "content": "class Solution {\\npublic:\\n\\nint dfs(int i,int cur_time,unordered_map<int,vector<pair<int,int>>>&adj,int n,vector<vector<int>>&dp)\\n{\\n    int m=1e9+7;\\n    int ans=0;\\n    if(dp[i][cur_time]!=-1)\\n    return(dp[i][cur_time]);\\n    if(i==n-1 && cur_time==0)\\n       return(dp[i][cur_time]=1);\\n       if(i==n-1 || cur_time==0)\\n          return(dp[i][cur_time]=0);\\n       for(auto e:adj[i])\\n       {\\n           if(e.second<=cur_time)\\n           ans=(ans+dfs(e.first,cur_time-e.second,adj,n,dp))%m;\\n       }\\n       return(dp[i][cur_time]=ans);\\n}\\nint min_time(int n,unordered_map<int,vector<pair<int,int>>>&adj)\\n{\\n    vector<int>dis(n,INT_MAX);\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n    q.push({0,0});\\n    dis[0]=0;\\n    while(!q.empty())\\n    {\\n        int edgedis=q.top().first;\\n        int node=q.top().second;\\n        q.pop();\\n        for(auto e:adj[node])\\n        {\\n            int edgeweight=e.second;\\n            int adjnode=e.first;\\n            if(dis[adjnode]>edgeweight+edgedis)\\n            {\\n               dis[adjnode]=edgeweight+edgedis;\\n               q.push({dis[adjnode],adjnode});\\n            }\\n        }\\n    }\\n   \\n    return(dis[n-1]);\\n\\n\\n}\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n     unordered_map<int,vector<pair<int,int>>>adj;\\n     for(auto e:roads)\\n     {\\n         adj[e[0]].push_back({e[1],e[2]});\\n         adj[e[1]].push_back({e[0],e[2]});\\n     }\\n     int d=min_time(n,adj);\\n     if(d==INT_MAX)\\n     return(0);\\n    vector<vector<int>>dp(n+1,vector<int>(d+1,-1));\\n     return(dfs(0,d,adj,n,dp));\\n    }\\n};\\n\\n\\nwhy this is giving TLE? won\\'t o(N^2) satisfy time constraints?"
                    },
                    {
                        "username": "Usman_047",
                        "content": "why is this not working for n=200\\nclass Solution {\\npublic:\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        \\n     //create adj[]\\n     \\n\\n     // {node,time}\\n         vector<pair<int,int>> adj [n];\\n    \\n    for(auto it : roads){\\n        int u = it[0];\\n        int v= it[1];\\n        int time= it[2];\\n        //unordered graph so pushback u in v and v in u\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\n   //time,adjnode\\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n    \\n    vector<int> dis(n,INT_MAX);\\n    vector<int> ways(n,0);\\n    dis[0]=0;\\n\\n    ways[0]=1;\\n\\n    q.push({0,0});\\n    int mod= (int)(1e9+7);\\n\\n    while(!q.empty()){\\n        int node = q.top().second;\\n        int time = q.top().first;\\n        q.pop();\\n         \\n         for(auto it : adj[node]){\\n             int edgetime = it.second;\\n             int adjnode = it.first;\\n             if(time + edgetime < dis[adjnode]){\\n                 dis[adjnode] = time + edgetime;\\n                 q.push({time+edgetime , adjnode});\\n                 ways[adjnode] = ways[node];\\n             }\\n             else if( time+ edgetime == dis[adjnode]){\\n                 ways[adjnode] = (ways[adjnode] + ways[node]) % mod;\\n             }\\n         }\\n\\n    }\\n    return ways[n-1] % mod;\\n\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "nikhilverma_",
                        "content": "instead of int max use 1e12"
                    },
                    {
                        "username": "ashokbabug",
                        "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        graph = {i:[] for i in range(n)}\\n        for u,v,wt in roads:\\n            graph[u].append([v,wt])\\n            graph[v].append([u,wt])\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        dist[0]=0\\n        heap = [[0,0]]\\n        d = defaultdict(int)\\n        while heap:\\n            dis,u = heapq.heappop(heap)\\n            for v,time in graph[u]:\\n                if dis+time<=dist[v]:\\n                    dist[v] = dis+time\\n                    heapq.heappush(heap,(dist[v],v))\\n                    if v==n-1:\\n                        d[dist[v]]+=1\\n        return d[dist[n-1]]\\n       why the above code giving Time limit exceeded? any idea I am just running dijkstras algorithm.if it not correct it should give wrong answer?        "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "my following code is giving after passing 52 testcases unable to figure out where to why ?\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countPaths(int n, vector<vector<int>>& roads) {\\n        // pq ways dist\\n        vector<pair<long long,int>>adj[n];\\n        for(auto i:roads){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>dis(n,1e9),ways(n,0);\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n\\n        ways[0]=1;\\n        dis[0]=0;\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int node=pq.top().second;\\n            pq.pop();\\n            for(auto adjacent:adj[node]){\\n                if(dist+adjacent.second<dis[adjacent.first]){\\n                    dis[adjacent.first]=dist+adjacent.second;\\n                    pq.push({dist+adjacent.second,adjacent.first});\\n                    ways[adjacent.first]=ways[node]%mod;\\n                }\\n                else if(dist+adjacent.second==dis[adjacent.first]){\\n                    ways[adjacent.first]=((long long)ways[adjacent.first]+(long long)ways[node])%mod;\\n                }\\n            }\\n           \\n        }\\n\\n         return ways[n-1]%mod;\\n    }\\n};"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "initialize the array with 1e15"
                    }
                ]
            }
        ]
    }
]