[
    {
        "title": "Last Stone Weight",
        "question_content": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\n\n\tIf x == y, both stones are destroyed, and\n\tIf x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\n\nAt the end of the game, there is at most one stone left.\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\n&nbsp;\nExample 1:\n\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\n\nExample 2:\n\nInput: stones = [1]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= stones.length <= 30\n\t1 <= stones[i] <= 1000",
        "solutions": [
            {
                "id": 294956,
                "title": "java-c-python-priority-queue",
                "content": "# **Explanation**\\nPut all elements into a priority queue.\\nPop out the two biggest, push back the difference,\\nuntil there are no more two elements left.\\n<br>\\n\\n# **Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`\\n<br>\\n\\n**Java, PriorityQueue**\\n```java\\n    public int lastStoneWeight(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)-> b - a);\\n        for (int a : A)\\n            pq.offer(a);\\n        while (pq.size() > 1)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n    }\\n```\\n\\n**C++, priority_queue**\\n```cpp\\n    int lastStoneWeight(vector<int>& A) {\\n        priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n```\\n**Python, using heap, O(NlogN) time**\\n```py\\n    def lastStoneWeight(self, A):\\n        h = [-x for x in A]\\n        heapq.heapify(h)\\n        while len(h) > 1 and h[0] != 0:\\n            heapq.heappush(h, heapq.heappop(h) - heapq.heappop(h))\\n        return -h[0]\\n```\\n\\n**Python, using binary insort, O(N^2) time**\\n```py\\n    def lastStoneWeight(self, A):\\n        A.sort()\\n        while len(A) > 1:\\n            bisect.insort(A, A.pop() - A.pop())\\n        return A[0]\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int lastStoneWeight(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)-> b - a);\\n        for (int a : A)\\n            pq.offer(a);\\n        while (pq.size() > 1)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n    }\\n```\n```cpp\\n    int lastStoneWeight(vector<int>& A) {\\n        priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n```\n```py\\n    def lastStoneWeight(self, A):\\n        h = [-x for x in A]\\n        heapq.heapify(h)\\n        while len(h) > 1 and h[0] != 0:\\n            heapq.heappush(h, heapq.heappop(h) - heapq.heappop(h))\\n        return -h[0]\\n```\n```py\\n    def lastStoneWeight(self, A):\\n        A.sort()\\n        while len(A) > 1:\\n            bisect.insort(A, A.pop() - A.pop())\\n        return A[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1921100,
                "title": "simple-easy-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/fc5f29d9-7e2e-4f5b-a3d9-2c5654652b76_1649292145.9654834.png)\\n\\n```\\n int lastStoneWeight(vector<int>& stones) \\n    {\\n        priority_queue<int> pq(stones.begin(),stones.end());\\n        while(pq.size()>1)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x!=y) pq.push(y-x);\\n        }\\n        return pq.empty()? 0 : pq.top();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int lastStoneWeight(vector<int>& stones) \\n    {\\n        priority_queue<int> pq(stones.begin(),stones.end());\\n        while(pq.size()>1)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x!=y) pq.push(y-x);\\n        }\\n        return pq.empty()? 0 : pq.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921241,
                "title": "python-beginner-friendly-optimisation-process-with-explanation",
                "content": "### Introduction\\n\\nGiven an array of stones `stones`, we repeatedly \"smash\" (i.e., compare) the two heaviest stones together until there is at most one stone left. If the two heaviest stones are of the same weight, both stones are \"destroyed\" (i.e., both weights become 0), otherwise, a stone with the absolute weight difference of both stones will remain.\\n\\nNote that the order in which the stones are \"smashed\" needs to be followed strictly. Otherwise, we will not end up with the correct weight of the remaining stone, if any.\\n\\n```text\\narr = [2, 7, 4, 1, 8, 1]\\n\\nCORRECT METHOD\\n1) Smash 8 and 7 -> arr = [2, 4, 1, 1, 1]\\n2) Smash 4 and 2 -> arr = [2, 1, 1, 1]\\n3) Smash 2 and 1 -> arr = [1, 1, 1]\\n4) Smash 1 and 1 -> arr = [1]\\n\\nWRONG METHOD #1 (according to index ordering)\\n1) Smash 2 and 7 -> arr = [5, 4, 1, 8, 1]\\n2) Smash 5 and 4 -> arr = [1, 1, 8, 1]\\n3) Smash 1 and 1 -> arr = [8, 1]\\n4) Smash 8 and 1 -> arr = [7]\\n\\nWRONG METHOD #2 (in ascending order)\\n1) Smash 1 and 1 -> arr = [2, 7, 4, 8]\\n2) Smash 2 and 4 -> arr = [2, 7, 8]\\n3) Smash 2 and 7 -> arr = [5, 8]\\n4) Smash 5 and 8 -> arr = [3]\\n```\\n\\n---\\n\\n### Base Approach - Sort and Insert\\n\\nSince we are required to \"smash\" the two heaviest stones, we need to know which two stones are the heaviest, and for all iterations. As such, we will first have to sort the stones in order by weight in order to compare the two heaviest stones.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # we need to insert the remaining stone (s1-s2) into the list\\n                pass\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\nAll that remains now is how we can insert the stone from the \"smashing\" of the two heaviest stones back into `stones`. The simplest method is to loop through `stones` and insert the stone in the correct index.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # loop through stones to find the index to insert the stone\\n                for i in range(len(stones)+1):\\n                    if i == len(stones) or stones[i] >= s1-s2:\\n                        stones.insert(i, s1-s2)\\n                        break\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\n**TC: O(n<sup>2</sup>)**, where `n` is the length of `stones`, due to the nested inserts.\\n**SC: O(1)**, no additonal data structures are used.\\n\\n---\\n\\n### Slight Optimisation - Binary Search Insert\\n\\nAn \"optimisation\" from the above method to find the index to insert the remaining stone is to binary search for the index to insert to instead of looping through `stones` manually. This involves Python\\'s [bisect library](https://docs.python.org/3/library/bisect.html) which has a pre-written function to help us do just that.\\n\\nNote that we only need to change one portion of the code; the remaining code logic is the same.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # binary-insert the remaining stone into stones\\n                insort_left(stones, s1-s2)\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\n**TC: O(n<sup>2</sup>)**. Even though binary searching for the index to insert to takes O(logn) time, the insert function alone takes O(n) time because it needs to shift all the elements after the index to the right by 1. As such, the overall time complexity for `insort_left()` is O(n).\\n**SC: O(1)**, as discussed above.\\n\\n---\\n\\n### Data Structure - Heap Implementation\\n\\nUnfortunately, due to the implementation of the list data structure, even the binary search optimisation cannot break free of the O(n) insert. If only there was a data structure that could help us sort and insert automatically without having to rely on a heavier insert function...\\n\\nPython has an in-built [heap library](https://docs.python.org/3/library/heapq.html) that is perfect for this task. Essentially, all we need to do is insert the elements, and the heap will settle the sorting order for us. Unfortunately, Python\\'s heap library implements a min-heap instead of a max-heap, whereby popping will give us the lightest stone instead of the heaviest stone.\\n\\nA standard (very common!) workaround is to **negate all the weight values of the stones**. This way, the heaviest stone has the most negative value, and hence becomes the smallest value in the heap. Then, all we have to do after obtaining the value from the heap is to un-negate the value to use it in our calculations.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # first, negate all weight values in-place\\n        for i, s in enumerate(stones):\\n            stones[i] = -s\\n        heapify(stones)  # pass all negated values into the min-heap\\n        while stones:\\n            s1 = -heappop(stones)  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = -heappop(stones)  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                heappush(stones, s2-s1)  # push the NEGATED value of s1-s2; i.e., s2-s1\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\n**TC: O(nlogn)**; `heappush()` and `heappop()` both have O(logn) time complexity, and are both nested in the while loop. Note: `heapify()` runs in O(n) time, hence the time complexity is not affected.\\n**SC: O(1)**; both the negation and the heapify are done in-place.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```text\\narr = [2, 7, 4, 1, 8, 1]\\n\\nCORRECT METHOD\\n1) Smash 8 and 7 -> arr = [2, 4, 1, 1, 1]\\n2) Smash 4 and 2 -> arr = [2, 1, 1, 1]\\n3) Smash 2 and 1 -> arr = [1, 1, 1]\\n4) Smash 1 and 1 -> arr = [1]\\n\\nWRONG METHOD #1 (according to index ordering)\\n1) Smash 2 and 7 -> arr = [5, 4, 1, 8, 1]\\n2) Smash 5 and 4 -> arr = [1, 1, 8, 1]\\n3) Smash 1 and 1 -> arr = [8, 1]\\n4) Smash 8 and 1 -> arr = [7]\\n\\nWRONG METHOD #2 (in ascending order)\\n1) Smash 1 and 1 -> arr = [2, 7, 4, 8]\\n2) Smash 2 and 4 -> arr = [2, 7, 8]\\n3) Smash 2 and 7 -> arr = [5, 8]\\n4) Smash 5 and 8 -> arr = [3]\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # we need to insert the remaining stone (s1-s2) into the list\\n                pass\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # loop through stones to find the index to insert the stone\\n                for i in range(len(stones)+1):\\n                    if i == len(stones) or stones[i] >= s1-s2:\\n                        stones.insert(i, s1-s2)\\n                        break\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # binary-insert the remaining stone into stones\\n                insort_left(stones, s1-s2)\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # first, negate all weight values in-place\\n        for i, s in enumerate(stones):\\n            stones[i] = -s\\n        heapify(stones)  # pass all negated values into the min-heap\\n        while stones:\\n            s1 = -heappop(stones)  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = -heappop(stones)  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                heappush(stones, s2-s1)  # push the NEGATED value of s1-s2; i.e., s2-s1\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448875,
                "title": "c-explained-easy-solution-priority-queue",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Intuition\\n- #### To solve this problem, we can use a priority queue to keep track of the heaviest stones. \\n- #### At each turn, we can pop the two heaviest stones from the heap, smash them together according to the given rules, and then push the resulting stone (if any) back onto the heap. \\n- #### We repeat this process until there is at most one stone left in the heap.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- #### In this code, we first create the priority queue by negating the values of the stones. \\n- #### We then loop until there is at most one stone left in the heap. Inside the loop, we pop the two heaviest stones from the queue and check whether they are equal or not.\\n    1. #### If they are not equal, we calculate the weight of the resulting stone and push it back onto the Queue (priority queue heapify itself after every push operation).\\n- #### Finally, we return the weight of the last remaining stone (or 0 if there are no stones left).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        priority_queue<int>pq(a.begin(),a.end());\\n\\n        while(pq.size() > 1)\\n        {\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n\\n            if(a != b)\\n                pq.push(abs(a-b));\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/8044a3f7-5e30-4954-bb50-1485656ecab5_1682302010.1464121.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        priority_queue<int>pq(a.begin(),a.end());\\n\\n        while(pq.size() > 1)\\n        {\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n\\n            if(a != b)\\n                pq.push(abs(a-b));\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575674,
                "title": "java-simple-to-complex-solutions-explained-0-ms-top-100-time-100-memory-2-lines-of-code-only",
                "content": "At every step of the algorithm, we need to know the top heaviest stone.\\nThe most efficient way to retrieve the max for large input sizes is to use a max heap, which in Java is a PriorityQueue (min heap) with a reverse comparator:\\n\\nO(n log (n)) time O(n) space \\n1 ms time 37.5 MB space\\n91% time 100% space\\n\\n```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i : stones) {\\n            queue.add(i);\\n        }\\n        int x;\\n        int y;\\n        while(queue.size() > 1) {\\n            y = queue.poll();\\n            x = queue.poll();\\n            if(y > x) {\\n                queue.offer(y-x);   \\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n```\\n\\nBut we can do better, right? If you have done a few of these problems you might know to use BucketSort with has constant access and no typical \"sorting\", we can do O(n) time. \\n\\nHowever, it is more accurate to say the time would be O(n + maxStoneWeight) because we will build a bucket for every possible weight. And usually a O(n + 1000) would be a great solution, but the test cases here have a very short input size. the number of stones goes only from 0 to 30, so this solution actually performs worse than O(n) since n is at most 30! O(30) == O(1030) but 30 < 1030. Both have the same complexity, but the first runs faster, and you might have not noticed why unless you check the inputs given in the tests.\\n\\n```\\n    int[] buckets = new int[1001];\\n    for(int stone: stones)\\n      buckets[stone]++;\\n    int i = 1000;\\n    int j;\\n    while(i > 0) {\\n      if(buckets[i] == 0) {\\n        i--;\\n      } else {\\n        buckets[i] = buckets[i] % 2;\\n        if(buckets[i] != 0) {\\n          j = i-1;\\n          while(j > 0 && buckets[j] == 0)\\n            j--;\\n          if(j == 0)\\n            return i;\\n          buckets[i - j]++;\\n          buckets[j]--;\\n          i--;\\n        }\\n      }\\n    }\\n    return 0;\\n```\\n\\nRuns even slower! Remember to not always apply a solution that seems faster because you didn\\'t consider your context or use cases. here the number of stones is much smaller than the weight of the stones.\\n\\nSo if we know that the number of stones is quite small, can we do even better than the PriorityQueue? What is a very fast sorting algorithm for small sets, better than building a heap? Sort in place in the array! Don\\'t waste time building new objects or copies of the input.\\n\\nO( n^2 log(n) ) because for every stone n, we sort the array O(nlog(n))\\nO(1) space, no extra space, sort in place\\n**0 ms time 36.9 MB\\tspace\\nfaster than 100% and less space used than 100% of other solutions**\\n\\n```\\n  public static int lastStoneWeight(int[] stones) {\\n    Arrays.sort(stones);\\n    for(int i=stones.length-1; i>0; i--) {\\n      stones[i-1] = stones[i] - stones[i-1];\\n      Arrays.sort(stones);\\n    }\\n    return stones[0];\\n  }\\n```\\n\\nAnd just for fun, let\\'s mangle it into **2 lines**:\\n```\\n    for(int i=stones.length; i>0; stones[i-1] = i==stones.length? stones[i-1] : stones[i] - stones[i-1], Arrays.sort(stones), i--);\\n    return stones[0];\\n```\\n\\nEDIT: \\nTo be completely clear, if the input size was unrestricted and not less than 30 stones, BucketSort would be the best solution because it runs in O(maxStoneWeight). If the stones weight is not unrestricted, then BucketSort cannot work as you would need 2,147,483,647 buckets. In that case, PriorityQueue would be the best solution.\\n\\n**In an interview, you should only discuss either BucketSort or PriorityQueue (max head) solutions**. The only reason I mentioned the sorting solution, which is much worse than the two other solutions, is because the input size in the tests of this challenge are so small that this solution is faster.",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i : stones) {\\n            queue.add(i);\\n        }\\n        int x;\\n        int y;\\n        while(queue.size() > 1) {\\n            y = queue.poll();\\n            x = queue.poll();\\n            if(y > x) {\\n                queue.offer(y-x);   \\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n```\n```\\n    int[] buckets = new int[1001];\\n    for(int stone: stones)\\n      buckets[stone]++;\\n    int i = 1000;\\n    int j;\\n    while(i > 0) {\\n      if(buckets[i] == 0) {\\n        i--;\\n      } else {\\n        buckets[i] = buckets[i] % 2;\\n        if(buckets[i] != 0) {\\n          j = i-1;\\n          while(j > 0 && buckets[j] == 0)\\n            j--;\\n          if(j == 0)\\n            return i;\\n          buckets[i - j]++;\\n          buckets[j]--;\\n          i--;\\n        }\\n      }\\n    }\\n    return 0;\\n```\n```\\n  public static int lastStoneWeight(int[] stones) {\\n    Arrays.sort(stones);\\n    for(int i=stones.length-1; i>0; i--) {\\n      stones[i-1] = stones[i] - stones[i-1];\\n      Arrays.sort(stones);\\n    }\\n    return stones[0];\\n  }\\n```\n```\\n    for(int i=stones.length; i>0; stones[i-1] = i==stones.length? stones[i-1] : stones[i] - stones[i-1], Arrays.sort(stones), i--);\\n    return stones[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921254,
                "title": "a-solid-explanation",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Last Stone Weight** \\n\\nOkay, so first of all let\\'s understand the problem\\n\\n**We have 2 stones x & y**\\n\\n![image](https://assets.leetcode.com/users/images/e062b588-f311-49ea-9aa0-c19e720eb38a_1649295151.330421.png)\\n\\nAnd There could be 2 Possiblities :\\n* If both the stones x & y have same weight, then **` x == y, both stones are destroyed`**\\n\\n\\n* If they are not equal, then stone y always be greater then stone x, therefore **`x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.`** \\n\\n```\\nAt the end of the game, there is at most one stone left.\\n\\nReturn the smallest possible weight of the left stone. If there are no stones left, return 0.\\n```\\n\\nI hope problem statement is absolute clear, now let\\'s talk about how we gonna solve this problem.\\n\\n**Let\\'s take an example,**\\n\\n**Input**: stones = [2,7,4,1,8,1]\\n**Output**: 1\\n\\nThe very Brute force Idea came in our mind is, why don;t we just sort that array, such that we will have bigger values in the end, and to maintain that highest value in the end, we always gonna sort them once both of the stones will collide. \\n\\nWhat I mean is, let\\'s take our input array:\\n```\\n[2,7,4,1,8,1]\\n\\nLet\\'s sort it:\\n\\n[1,1,2,4,7,8]\\n```\\n\\nNow what we gonna do is, collide the 2 stones and get their difference i.e. `y - x`\\n```\\n[1,1,2,4,7,8]  -->  y = 8      &      x = 7\\n\\nThus,\\ny - x    -->  8 - 7 = 1\\n```\\nNow we gonna put that one in our array & maintain the order by sorting it back again\\n```\\n[1,1,2,4]          add => 1   in our array\\n\\n[1,1,2,4,1]          now again sort it,\\n\\n[1,1,1,2,4]\\n```\\nSo, we gonna perform the same step for all. Well it\\'s not a great approach to go with, as our Time Complexity will be much higher.\\n\\nLet\\'s code it up, then we gonna analysis it\\'s space & time complexity:-\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        \\n        for(int i = stones.length - 1; i > 0; i--){\\n            stones[i - 1] = stones[i] - stones[i - 1];\\n            Arrays.sort(stones);\\n        }\\n        return stones[0];\\n    }\\n}\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(NlogN) * BigO(N) => BigO(N^2logN)\\n\\n* **Space Complexity :-** BigO(1)\\n\\nWell, now you say. Dude, let;s optimise it. \\nYes, we just goona do that stuff now!!\\n```\\nFor Optimising it, we gonna use the help of Heap\\n```\\n\\nOkay, so we gonna take the same example & now you\\'ll ask which heap do we have to use??\\n**minHeap OR maxHeap??**\\n\\nAs, you can see we want highest value at the first & lowest value in the last. So, we gonna use **maxHeap**\\n\\nLet\\'s create our maxHeap and use the same example i.e. **`[2,7,4,1,8,1]`** to fill our heap.\\n\\nSo, our first job is, let\\'s fill our heap.\\n```\\n                Array           [2,7,4,1,8,1]\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|     |\\n--------\\nmaxHeap\\n```\\n\\nNow let\\'s fill our heap,\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                 ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|  2  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                   ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|  7  |\\n|  2  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                     ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|  7  |\\n|  4  |\\n|  2  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                       ^\\n|     |\\n|\\t  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                         ^\\n|     |\\n|  8  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           ^\\n|  8  |\\n|  7  |\\t\\t\\n|  4  |  \\n|  2  |\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\n\\nNow it\\'s time to get the stone x & y using our heap & after calculating **`y - x`** put the new difference in our stack\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 8\\n|     |\\t\\t    x = 7\\n|  4  |      \\n|  2  |         and their result will be y - x => 8 - 7 = 1\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\nNow put that **1** into our heap & again calculate the result of stone x & y\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 4\\n|     |\\t\\t    x = 2\\n|     |      \\n|  1  |         and their result will be y - x => 4 - 2 = 2\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\nSo, we gonna perform the same step until & unless only 1 elemnent left in our stack.\\n\\nI hope so, ladies - n - gentlemen, approach is absolute clear, **then let\\'s code it up:**\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int v : stones){\\n            maxHeap.offer(v);\\n        }\\n        int x;\\n        int y;\\n        while(maxHeap.size() > 1){\\n            y = maxHeap.poll();\\n            x = maxHeap.poll();\\n            if(y > x){\\n                maxHeap.offer(y - x);\\n            }\\n        }\\n        if(maxHeap.size() == 0) return 0;\\n        return maxHeap.poll();\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(NlogN)\\n\\n* **Space Complexity :-** BigO(N)\\n```\\nTime Complexity Explanation\\'s may be still if I\\'m wrong, correct me then, THANKS <^^>\\n```\\n\\n*Heap is a specialized tree-based data structure* that is essentially almost *complete binary tree.* There are so many operations possible with **max and min heaps like -**\\n\\n`insert(), delete(), update(), findMinElement(), findMaxElement(), etc`\\n\\nAnd time complexity depends on the operation you perform on the heap.\\n\\n**`Heap Sort has O(nlog n) time complexities for all the cases ( best case, average case, and worst case).`**\\n\\n**Let us understand the reason why.** The height of a complete binary tree containing n elements is **log n**\\n\\nIn the worst case scenario, we will need to move an element from the root to the leaf node making a multiple of **log(n)** comparisons and swaps.\\n\\nDuring the `build_max_heap` stage, we do that for **n/2** elements so the worst case complexity of the `build_heap` step is **n/2xlog n ~ nlog n**.\\n\\nDuring the sorting step, we exchange the root element with the last element and heapify the root element. For each element, this again takes **log n** worst time because we might have to bring the element all the way from the root to the leaf. Since we repeat this n times, the `heap_sort` step is also **nlog n.**\\n\\nAlso since the `build_max_heap` and `heap_sort` steps are executed one after another, the algorithmic complexity is not multiplied and it remains in the order of **nlog n**.",
                "solutionTags": [],
                "code": "```\\nAt the end of the game, there is at most one stone left.\\n\\nReturn the smallest possible weight of the left stone. If there are no stones left, return 0.\\n```\n```\\n[2,7,4,1,8,1]\\n\\nLet\\'s sort it:\\n\\n[1,1,2,4,7,8]\\n```\n```\\n[1,1,2,4,7,8]  -->  y = 8      &      x = 7\\n\\nThus,\\ny - x    -->  8 - 7 = 1\\n```\n```\\n[1,1,2,4]          add => 1   in our array\\n\\n[1,1,2,4,1]          now again sort it,\\n\\n[1,1,1,2,4]\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        \\n        for(int i = stones.length - 1; i > 0; i--){\\n            stones[i - 1] = stones[i] - stones[i - 1];\\n            Arrays.sort(stones);\\n        }\\n        return stones[0];\\n    }\\n}\\n```\n```\\nFor Optimising it, we gonna use the help of Heap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|     |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                 ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|  2  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                   ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|  7  |\\n|  2  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                     ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|  7  |\\n|  4  |\\n|  2  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                       ^\\n|     |\\n|\\t  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                         ^\\n|     |\\n|  8  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           ^\\n|  8  |\\n|  7  |\\t\\t\\n|  4  |  \\n|  2  |\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 8\\n|     |\\t\\t    x = 7\\n|  4  |      \\n|  2  |         and their result will be y - x => 8 - 7 = 1\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 4\\n|     |\\t\\t    x = 2\\n|     |      \\n|  1  |         and their result will be y - x => 4 - 2 = 2\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int v : stones){\\n            maxHeap.offer(v);\\n        }\\n        int x;\\n        int y;\\n        while(maxHeap.size() > 1){\\n            y = maxHeap.poll();\\n            x = maxHeap.poll();\\n            if(y > x){\\n                maxHeap.offer(y - x);\\n            }\\n        }\\n        if(maxHeap.size() == 0) return 0;\\n        return maxHeap.poll();\\n    }\\n}\\n```\n```\\nTime Complexity Explanation\\'s may be still if I\\'m wrong, correct me then, THANKS <^^>\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294993,
                "title": "java-python-3-easy-code-using-priorityqueue-heapq-w-brief-explanation-and-analysis",
                "content": "Sort stones descendingly in PriorityQueue, then pop out pair by pair, compute the difference between them and add back to PriorityQueue.\\n\\nNote: since we already know the first poped out is not smaller, it is not necessary to use Math.abs().\\n\\n```java\\n    public int lastStoneWeight(int[] stones) {\\n    //  PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        var q = new PriorityQueue<Integer>(stones.length, Comparator.reverseOrder());  // Credit to @YaoFrankie.\\n        for (int st : stones) { \\n            q.offer(st); \\n        }\\n        while (q.size() > 1) {\\n            q.offer(q.poll() - q.poll());\\n        }\\n        return q.peek();\\n    }\\n```\\n```\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        q = [-stone for stone in stones]\\n        heapq.heapify(q)\\n        while (len(q)) > 1:\\n            heapq.heappush(q, heapq.heappop(q) - heapq.heappop(q))\\n        return -q[0]\\n```\\n\\nIn case you want to optimize the time performance, refer to the following version, which does NOT put `0` into the PriorityQueue:\\n```java\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        IntStream.of(stones).forEach(pq::offer);\\n        while (pq.size() > 1) {\\n            int diff = pq.poll() - pq.poll();\\n            if (diff > 0) {\\n                pq.offer(diff);\\n            }\\n        }\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n```\\n```python\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(hp := [-s for s in stones])\\n        while len(hp) > 1:\\n            if (diff := heappop(hp) - heappop(hp)) != 0:\\n                heappush(hp, diff)\\n        return -heappop(hp) if hp else 0\\n```\\n\\n**Analysis:**\\n\\nTime: O(nlogn), space: O(n), where n = stones.length.\\n\\n----\\n\\n**Q & A:**\\n\\nQ: If not adding zeroes in the queue when polling out two elements are equal, is the result same as the above code?\\n\\nA: Yes. 0s are always at the end of the PriorityQueue. No matter a positive deduct 0 or 0 deduct 0, the result is same as NOT adding 0s into the PriorityQueue.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\n    public int lastStoneWeight(int[] stones) {\\n    //  PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        var q = new PriorityQueue<Integer>(stones.length, Comparator.reverseOrder());  // Credit to @YaoFrankie.\\n        for (int st : stones) { \\n            q.offer(st); \\n        }\\n        while (q.size() > 1) {\\n            q.offer(q.poll() - q.poll());\\n        }\\n        return q.peek();\\n    }\\n```\n```\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        q = [-stone for stone in stones]\\n        heapq.heapify(q)\\n        while (len(q)) > 1:\\n            heapq.heappush(q, heapq.heappop(q) - heapq.heappop(q))\\n        return -q[0]\\n```\n```java\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        IntStream.of(stones).forEach(pq::offer);\\n        while (pq.size() > 1) {\\n            int diff = pq.poll() - pq.poll();\\n            if (diff > 0) {\\n                pq.offer(diff);\\n            }\\n        }\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n```\n```python\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(hp := [-s for s in stones])\\n        while len(hp) > 1:\\n            if (diff := heappop(hp) - heappop(hp)) != 0:\\n                heappush(hp, diff)\\n        return -heappop(hp) if hp else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 294925,
                "title": "c-multiset-and-priority-queue",
                "content": "#### Approach 1: Multiset\\n```\\nint lastStoneWeight(vector<int>& st) {\\n  multiset<int> s(begin(st), end(st));\\n  while (s.size() > 1) {\\n    auto w1 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    auto w2 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    if (w1 - w2 > 0) s.insert(w1 - w2);\\n  }\\n  return s.empty() ? 0 : *s.begin();\\n}\\n```\\n#### Approach 2: Priority Queue\\n```\\nint lastStoneWeight(vector<int>& st) {\\n  priority_queue<int> q(begin(st), end(st));\\n  while (q.size() > 1) {\\n    auto w1 = q.top(); q.pop();\\n    auto w2 = q.top(); q.pop();\\n    if (w1 - w2 > 0) q.push(w1 - w2);\\n  }\\n  return q.empty() ? 0 : q.top();\\n}\\n```\\n#### Complexity Analysys\\n- Time: O(n log n) to sort stones.\\n- Memory: O(n) for the multiset/queue.",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& st) {\\n  multiset<int> s(begin(st), end(st));\\n  while (s.size() > 1) {\\n    auto w1 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    auto w2 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    if (w1 - w2 > 0) s.insert(w1 - w2);\\n  }\\n  return s.empty() ? 0 : *s.begin();\\n}\\n```\n```\\nint lastStoneWeight(vector<int>& st) {\\n  priority_queue<int> q(begin(st), end(st));\\n  while (q.size() > 1) {\\n    auto w1 = q.top(); q.pop();\\n    auto w2 = q.top(); q.pop();\\n    if (w1 - w2 > 0) q.push(w1 - w2);\\n  }\\n  return q.empty() ? 0 : q.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360047,
                "title": "super-simple-o-n-java-solution-using-bucket-sort-and-two-pointers",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int[] buckets = new int[1001];\\n        for (int i = 0; i < stones.length; i++) {\\n            buckets[stones[i]]++;\\n        }\\n\\n        int slow = buckets.length - 1;   //start from the big to small\\n        while (slow > 0) {\\n\\t\\t// If the number of stones with the same size is even or zero, \\n\\t\\t// these stones can be totally destroyed pair by pair or there is no such size stone existing, \\n\\t\\t// we can just ignore this situation.\\n\\t\\t\\n        // When the number of stones with the same size is odd, \\n\\t\\t// there should leave one stone which is to smash with the smaller size one.\\n            if (buckets[slow]%2 != 0) {\\n                int fast = slow - 1;\\n                while (fast > 0 && buckets[fast] == 0) {\\n                    fast--;\\n                }\\n                if (fast == 0) break;\\n                buckets[fast]--;\\n                buckets[slow - fast]++;\\n            }\\n            slow--;\\n        }\\n        return slow;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int[] buckets = new int[1001];\\n        for (int i = 0; i < stones.length; i++) {\\n            buckets[stones[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1923171,
                "title": "javascript-faster-than-95-easy-to-understand-with-comments",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length>1){\\n        stones.sort((a,b)=>b-a); //sort the remaining stones in decending order;\\n        stones[1]=stones[0]-stones[1]; //smash the first and second stones ie the stones with largest weight ans assign the remaining stone weight to 1st index\\n        stones.shift();//shift the array to get rid of the 0 index\\n    }\\n    return stones[0] //return the 0 index value ie the resultl\\n};\\n```\\n\\nIts okay if you did not get the solution in the first try, don\\'t give up!\\nPlease do UPVOTE if you find it helpfull.... I know this is not the best solution to this problem but this is what I came up with.\\nHappy C0d1ng!! Cheers!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length>1){\\n        stones.sort((a,b)=>b-a); //sort the remaining stones in decending order;\\n        stones[1]=stones[0]-stones[1]; //smash the first and second stones ie the stones with largest weight ans assign the remaining stone weight to 1st index\\n        stones.shift();//shift the array to get rid of the 0 index\\n    }\\n    return stones[0] //return the 0 index value ie the resultl\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922652,
                "title": "c-java-python-6-line-approach-question-clarifications-heap-cheatsheet",
                "content": "If you are already familiar with priority_queue in C++ skip to the Approach section at the end\\n### C++ Heap Guide/Cheatsheet\\nIn C++ [priority_queue](https://www.cplusplus.com/reference/queue/priority_queue/) is the implementation for heaps. If you have never used priority_queue before, you can get started by reading this cheatsheet and solving this problem. However, you still should read about [heaps](https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/resources/lecture-4-heaps-and-heap-sort/) and how they work so that you know when and where to use them.\\n\\n1. **Introduction**\\n* Why heaps?\\nHeap as a container gives you fast insertion of any element as well as reads and deletion of either the minimum-most or maximum-most element. Also it does not provide random access to any other element in the heap\\n* Where to use?\\nBased on this advantage, some major use cases for heaps are BFS, Djikstra, Current median of stream of elements\\n\\n2. **Initialising**\\n\\t```cpp\\n\\t// 1. max heap -> for popping largest element\\n\\t\\tpriority_queue<int> pq;     // replace int with any other type or a struct based on need\\n\\t// 2. min heap -> for popping minimum element\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\t// 3. custom heaps in case of custom ordering (here we are creating min heap based on second property)\\n\\t\\tstruct comp {\\n\\t\\t\\tbool operator()(pair<int, int> a, pair<int, int> b) {\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tpriority_queue<int, vector<int>, comp> pq;\\n\\t// 4. If you already have an array and want to initialise using it\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq(a.begin(), a.end());\\n\\t```\\n\\tThis last operation takes O(n) time where n is size of array a.\\n\\n3. **Important operations**\\n\\t```cpp\\n\\tpq.push(10);           // adds element to heap\\n\\tint cur = pq.top();    // returns top element, does NOT pop though\\n\\tpq.pop()               // pops top element, does NOT return the value of top element though\\n\\tpq.size()              // return size of heap\\n\\tpq.empty()             // returns true if heap is empty else false\\n\\t```\\n - Always make sure that heap is not empty prior to top() and pop() methods\\n - *Time* - push() and pop() takes O(logn) time, the other three require O(1) time.\\n___\\n</br>\\n\\n### Question Clarifications\\nSome people have misinterpreted the question a bit, for example [here](https://leetcode.com/problems/last-stone-weight/discuss/1922217)\\nNote, the question states that you always have to pick the two largest stones and then find the minimum-most stone. Its however not necessary that if you had the freedom to pick any two stones, that picking the largest would give you smallest stone at the end. It actually wont, consider the following example -\\n> [25, 23, 16, 16, 16]\\n\\n* If you picked the largest two every time you would end up with 14.\\n* However with freedom to pick any stone you can end with 0. By picking following stones at each step -\\n\\t```text\\n\\t(25, 16) -> (23, 16) -> (16, 9)  -> (7, 7)\\n\\tleaves 9 -> leaves 7 -> leaves 7 -> leaves 0\\n\\t```\\n\\nAnother clarification, is the question states find the minimum most possible stone after only one stone remains. Since there can be only one pair of largest stones possible at each step and you do not have the element of choice, you can only have one way of smashing the stones and hence only one possibility of last stone remaining, which being the only candidate for being the minimum-most will also be the answer.\\n___\\n</br>\\n\\n### Approach\\nOnce we are aware of how to use the priority queue and the above facts the approach is straightforward as the question instructs us what to do. We need the two largest elements at each step for our operation, since heaps give the fastest access to the extremes its our go to here. The pseudo-code is as follows -\\n```text\\n\\tInitialise heap using the array (use 4th option above)\\n\\tKeep smashing as long as there is 2 or more stones (use size() method)\\n\\t\\tPick the two largest and remove them from heap (use top() and pop())\\n\\t\\tif their difference is positive add new stone to our heap (use push())\\n\\t\\n\\tIf there is a stone remaining in heap return it or else return 0 (use empty() and top())\\n```\\n\\nC++/Java/Python code based on above pseudo code\\n\\n<iframe src=\"https://leetcode.com/playground/kocCUYy5/shared\" frameBorder=\"0\" width=\"800\" height=\"370\"></iframe>\\n\\nComplexity - Time: O(nlogn), Space: O(n)\\n\\nWould also like to add the common heap operations and code for Java and Python along with complexity to this cheatsheet, please mention them if you are familiar with them.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\n\\t// 1. max heap -> for popping largest element\\n\\t\\tpriority_queue<int> pq;     // replace int with any other type or a struct based on need\\n\\t// 2. min heap -> for popping minimum element\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\t// 3. custom heaps in case of custom ordering (here we are creating min heap based on second property)\\n\\t\\tstruct comp {\\n\\t\\t\\tbool operator()(pair<int, int> a, pair<int, int> b) {\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tpriority_queue<int, vector<int>, comp> pq;\\n\\t// 4. If you already have an array and want to initialise using it\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq(a.begin(), a.end());\\n\\t```\n```cpp\\n\\tpq.push(10);           // adds element to heap\\n\\tint cur = pq.top();    // returns top element, does NOT pop though\\n\\tpq.pop()               // pops top element, does NOT return the value of top element though\\n\\tpq.size()              // return size of heap\\n\\tpq.empty()             // returns true if heap is empty else false\\n\\t```\n```text\\n\\t(25, 16) -> (23, 16) -> (16, 9)  -> (7, 7)\\n\\tleaves 9 -> leaves 7 -> leaves 7 -> leaves 0\\n\\t```\n```text\\n\\tInitialise heap using the array (use 4th option above)\\n\\tKeep smashing as long as there is 2 or more stones (use size() method)\\n\\t\\tPick the two largest and remove them from heap (use top() and pop())\\n\\t\\tif their difference is positive add new stone to our heap (use push())\\n\\t\\n\\tIf there is a stone remaining in heap return it or else return 0 (use empty() and top())\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575360,
                "title": "python3-heapq-priority-queue",
                "content": "Since we want the two largest stones each time, and heapq.pop() gives us the smallest each time, we just need to make every value of stones negative at the beginning.\\n```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-val for val in stones]\\n        heapq.heapify(stones)\\n        while len(stones) > 1:\\n            x1 = heapq.heappop(stones)\\n            x2 = heapq.heappop(stones)\\n            if x1 != x2:\\n                heapq.heappush(stones,x1-x2)\\n        if len(stones) == 0:\\n            return 0\\n        return -stones[0]\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-val for val in stones]\\n        heapq.heapify(stones)\\n        while len(stones) > 1:\\n            x1 = heapq.heappop(stones)\\n            x2 = heapq.heappop(stones)\\n            if x1 != x2:\\n                heapq.heappush(stones,x1-x2)\\n        if len(stones) == 0:\\n            return 0\\n        return -stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449430,
                "title": "java-easy-solution-explained-similar-questions-beginner-friendly",
                "content": "# Intuition\\nSince we need to choose heaviest two stones everytime, this is a clear hint to go for heap data structure. In java we implement heap via priority queue.\\n\\nSimilar questions for heap i faced in interviews.\\nLC 347[ Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)\\nLC 215[ Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)\\nLC 23 [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\\n\\n\\n---\\n# Approach\\n1) Make a heap via priority queue, we need to make a max heap as we need heaviest stone collision first.\\n2) Add stones[] to heap\\n3) Now run a while loop till there are two elements remaining in the hea[] i.e ```while(heap.size()>1)``` Two elements because each collision needs two stones atleast. \\n- pick top 2 stones and calculate their difference\\n- if difference!=0 we need back to heap other both stones are destroyed.\\n4) Once outside the loop, check for size!=0 i.e once stone remains return that or return zero.\\n\\n---\\n# Complexity\\n- Time complexity:\\nO(nlogn) : Building of heap intially nlogn, Then since we poll and push again to the heap, it needs to rebuild which takes logn(heapify) everytime.\\n\\n- Space complexity:\\nO(n) at max we will have n elements in heap.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //setting decreasing order of the heap or max heap\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a,b) -> b-a);\\n        for(int each: stones)\\n            heap.add(each);\\n\\n        while(heap.size()>1){\\n            int top1 = heap.poll();\\n            int top2 = heap.poll();\\n            int diff = Math.abs(top1-top2);\\n\\n            if(diff!=0){\\n                heap.add(diff);\\n            }\\n        }\\n\\n        if(heap.size()!=0){\\n            return heap.poll();\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```while(heap.size()>1)```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //setting decreasing order of the heap or max heap\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a,b) -> b-a);\\n        for(int each: stones)\\n            heap.add(each);\\n\\n        while(heap.size()>1){\\n            int top1 = heap.poll();\\n            int top2 = heap.poll();\\n            int diff = Math.abs(top1-top2);\\n\\n            if(diff!=0){\\n                heap.add(diff);\\n            }\\n        }\\n\\n        if(heap.size()!=0){\\n            return heap.poll();\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921223,
                "title": "c-simulation-100-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nTo solve this problem, we can conduct an actual simulation of the described process. Since we always need to use the heaviest stones, we can use a heap data structure for easy access to max elements.\\n\\nTime: **O(nlogn)** - for the heap\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 0 ms, faster than **100.00%** of C++ online submissions for Last Stone Weight.\\nMemory Usage: 7.6 MB, less than **34.27%** of C++ online submissions for Last Stone Weight.\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& s) {\\n         make_heap(s.begin(), s.end());\\n        \\n         while (s.size() > 1) {\\n            int x = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            int y = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            if (x == y) continue;\\n            \\n            s.push_back(x - y);\\n            push_heap(s.begin(), s.end());\\n        }\\n        \\n        return s.size() ? s.front() : 0;\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& s) {\\n         make_heap(s.begin(), s.end());\\n        \\n         while (s.size() > 1) {\\n            int x = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            int y = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            if (x == y) continue;\\n            \\n            s.push_back(x - y);\\n            push_heap(s.begin(), s.end());\\n        }\\n        \\n        return s.size() ? s.front() : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921769,
                "title": "java-best-intuitive-solution-priority-queue-1ms-99-faster",
                "content": "**Code**\\n```java\\npublic int lastStoneWeight(int[] stones) {\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor(int st: stones)\\n\\t\\tpq.offer(st);\\n\\n\\twhile(pq.size() > 1) {\\n\\t\\tint f = pq.poll();\\n\\t\\tint s = pq.poll();\\n\\t\\tif(f != s) \\n\\t\\t\\tpq.offer(f-s);\\n\\t}\\n\\n\\treturn pq.isEmpty() ? 0 : pq.peek();\\n}\\n```\\n\\n**Explanation**\\nWe were required to do operations each time on largest elements, and for that we can use max heap which can use used by reverting the order of priority queue available in Collections framework in java.\\n- Push all elements in priority queue.\\n- Iterate while the size of priority queue becomes equal to or less than 1.\\n- Pop two largest element from top and perform following checks\\n\\t- if both are equal then we don\\'t need to do anything.\\n\\t- else we add the difference of `f` and `s` to the priority queue.\\n- Now return 0 if size of `pq` is 0 otherwise return top element.\\n\\nHere\\'s how it works:-\\n\\n![image](https://assets.leetcode.com/users/images/89bb3992-f3ba-410e-a071-62c44831876a_1649307957.4194489.png)\\n\\n\\nHope it helps,\\nIf it does do upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\npublic int lastStoneWeight(int[] stones) {\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor(int st: stones)\\n\\t\\tpq.offer(st);\\n\\n\\twhile(pq.size() > 1) {\\n\\t\\tint f = pq.poll();\\n\\t\\tint s = pq.poll();\\n\\t\\tif(f != s) \\n\\t\\t\\tpq.offer(f-s);\\n\\t}\\n\\n\\treturn pq.isEmpty() ? 0 : pq.peek();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563863,
                "title": "easy-to-understand-heap-based-faster-simple-python-solution",
                "content": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-i for i in stones]\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            first = abs(heapq.heappop(stones))\\n            second = abs(heapq.heappop(stones))\\n            if first != second:\\n                heapq.heappush(stones, -abs(first - second))\\n                \\n        # this compact return statement way is great ^_^\\n        return abs(stones[0]) if len(stones) else 0\\n                \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-i for i in stones]\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            first = abs(heapq.heappop(stones))\\n            second = abs(heapq.heappop(stones))\\n            if first != second:\\n                heapq.heappush(stones, -abs(first - second))\\n                \\n        # this compact return statement way is great ^_^\\n        return abs(stones[0]) if len(stones) else 0\\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1470255,
                "title": "simple-javascript-soluton-recursion",
                "content": "```\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    stones.sort((a,b) => a-b);\\n    let a = stones.pop();\\n    let b = stones.pop();\\n    stones.push(Math.abs(a-b));\\n    return lastStoneWeight(stones);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    stones.sort((a,b) => a-b);\\n    let a = stones.pop();\\n    let b = stones.pop();\\n    stones.push(Math.abs(a-b));\\n    return lastStoneWeight(stones);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222221,
                "title": "java-solution-let-s-learn-when-to-use-heap-priority-queue",
                "content": "# Intuition\\nAs soon as we understand that we need to repeatedly get a maximum/minimum value from an array, we can use Heap (Priority Queue).\\n\\nYou can use Minimum Heap like this:\\n***PriorityQueue<Integer> minHeap = new PriorityQueue<>();***\\n\\nOr you can use Maximum Heap this way:\\n***PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());***\\n\\nAs you can see, if you want to change your heap from min to max you can simply reverse it by adding ***Comparator.reverseOrder()***;\\n\\nGiven this knowledge we can start implementing our solution.\\n\\n# Approach\\n1. Initialize max heap, because we need the biggest stones.\\n2. Add all stones from our initial array to the heap.\\n3. While size of our heap is not equal to one we need to remove two stones and confirm if they are equal (then we will add 0 to our heap) or x != y (then we will add y - x to the heap (the biggest stone minus second one)).\\n4. The last element from the heap will be our answer.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\text{ }log \\\\text{ } n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            maxHeap.add(stone);\\n        }\\n        while (maxHeap.size() != 1) {\\n            int y = maxHeap.remove();\\n            int x = maxHeap.remove();\\n            if (x == y) maxHeap.add(0);\\n            if (x != y) maxHeap.add(y - x);\\n        }\\n        return maxHeap.peek();\\n    }\\n}\\n```\\n![4x5hdv.jpeg](https://assets.leetcode.com/users/images/d8917be9-a9ce-4b97-a3ee-8b99901cf5af_1677435627.74426.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            maxHeap.add(stone);\\n        }\\n        while (maxHeap.size() != 1) {\\n            int y = maxHeap.remove();\\n            int x = maxHeap.remove();\\n            if (x == y) maxHeap.add(0);\\n            if (x != y) maxHeap.add(y - x);\\n        }\\n        return maxHeap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448738,
                "title": "easy-solution-of-java-c-beginner-friendly-arraylist",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n   public int lastStoneWeight(int[] stones)\\n{\\n\\t\\tArrayList<Integer> listStones = new ArrayList<>();\\n\\t\\tfor (int a : stones)\\n\\t\\t\\tlistStones.add(a);\\n\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\tint len = listStones.size();\\n\\n\\t\\t\\tif (len == 1 || len == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tCollections.sort(listStones);\\n\\t\\t\\tmin = listStones.get(len - 2);\\n\\t\\t\\tmax = listStones.get(len - 1);\\n\\n\\t\\t\\tif (min < max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmax = max - min;\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.add(max);\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (min == max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        if(listStones.size()==1)\\n            return listStones.get(0);\\n        return 0;\\n\\t}\\n}\\n```\\nC++\\n```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n   public int lastStoneWeight(int[] stones)\\n{\\n\\t\\tArrayList<Integer> listStones = new ArrayList<>();\\n\\t\\tfor (int a : stones)\\n\\t\\t\\tlistStones.add(a);\\n\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\tint len = listStones.size();\\n\\n\\t\\t\\tif (len == 1 || len == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tCollections.sort(listStones);\\n\\t\\t\\tmin = listStones.get(len - 2);\\n\\t\\t\\tmax = listStones.get(len - 1);\\n\\n\\t\\t\\tif (min < max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmax = max - min;\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.add(max);\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (min == max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        if(listStones.size()==1)\\n            return listStones.get(0);\\n        return 0;\\n\\t}\\n}\\n```\n```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922257,
                "title": "2-approaches-sorting-max-heap-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- ***Brute force solution*** //not recommended.\\n- Here every iteration we\\u2019re sorting the array & changing the last 2 values.\\n- As the last 2 are the max elements, so ***x=stones[n-2]*** & ***y=stones[n-1].***\\n- We\\u2019ll replace x with 0 (as all elements will be greater than 0), and y with y-x.\\n- Return the last element after n iteration.\\n- **Time complexity:** O(n^2logn).\\n\\n### Solution 02\\n\\n- Using ***Max Heap.***\\n- Max heap keeps the maximum element on top.\\n- First, we\\u2019ll push all the elements of stones to our max heap.\\n- Now until the size of our heap won\\u2019t became 1 we\\u2019ll continue this operation:\\n    - Take the top element to y & pop that element. `y = q.top(); q.pop();`\\n    - Similarly, put the next element to x & pop it. `x = q.top(); q.pop();`\\n    - Now smallest element will destroy & we\\u2019ll push y-x to our heap again. In the case of same weight elements, it will automatically push 0. `q.push(y-x);`\\n    - When the size of the heap became 1 we\\u2019ll break the loop and return top element.\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size(), ans, count = 0;\\n        \\n        if(n == 1) return stones[0];\\n        \\n        while(count != n-1){\\n            sort(stones.begin(), stones.end());\\n            stones[n-1] = stones[n-1] - stones[n-2];\\n            stones[n-2] = 0;\\n            count++;\\n        }\\n        return stones[n-1];\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> q;\\n        int x, y;\\n        \\n        for(auto x:stones)\\n            q.push(x);\\n        \\n        while(q.size() != 1){\\n            y = q.top();\\n            q.pop();\\n            x = q.top();\\n            q.pop();\\n\\n            q.push(y-x);\\n        }\\n        \\n        return q.top();\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size(), ans, count = 0;\\n        \\n        if(n == 1) return stones[0];\\n        \\n        while(count != n-1){\\n            sort(stones.begin(), stones.end());\\n            stones[n-1] = stones[n-1] - stones[n-2];\\n            stones[n-2] = 0;\\n            count++;\\n        }\\n        return stones[n-1];\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> q;\\n        int x, y;\\n        \\n        for(auto x:stones)\\n            q.push(x);\\n        \\n        while(q.size() != 1){\\n            y = q.top();\\n            q.pop();\\n            x = q.top();\\n            q.pop();\\n\\n            q.push(y-x);\\n        }\\n        \\n        return q.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922285,
                "title": "shortest-solution-using-min-heap-priorityqueue",
                "content": "**Step 1:** Put the array into a min heap. To avoid creating a custom comparer, let\\'s just revert priorities (`-x`).\\n**Step 2:** Get the two \"heaviest\" stones from the heap and smash them together. If there is something left, put it back into the heap.\\n\\n```csharp\\npublic int LastStoneWeight(int[] stones)\\n{\\n    var q = new PriorityQueue<int, int>(stones.Select(x => (x, -x)));\\n    \\n    while (q.Count > 1)\\n    {\\n        int a = q.Dequeue() - q.Dequeue();\\n        if (a != 0) q.Enqueue(a, -a);\\n    }\\n        \\n    return (q.Count == 0) ? 0 : q.Peek();\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```csharp\\npublic int LastStoneWeight(int[] stones)\\n{\\n    var q = new PriorityQueue<int, int>(stones.Select(x => (x, -x)));\\n    \\n    while (q.Count > 1)\\n    {\\n        int a = q.Dequeue() - q.Dequeue();\\n        if (a != 0) q.Enqueue(a, -a);\\n    }\\n        \\n    return (q.Count == 0) ? 0 : q.Peek();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494003,
                "title": "java-100-time-100-space",
                "content": "````\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        Arrays.sort(stones);\\n        int y = stones.length-1;\\n        int x = stones.length-2;\\n        while(x>=0){\\n            if(stones[x]==stones[y]){\\n                stones[x] = 0;\\n                stones[y] = 0;\\n            }else{\\n                stones[y] -= stones[x];\\n                stones[x] = 0;\\n            }\\n            Arrays.sort(stones);\\n            if(stones[x]==0)break;\\n        }\\n        return stones[y];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        Arrays.sort(stones);\\n        int y = stones.length-1;\\n        int x = stones.length-2;\\n        while(x>=0){\\n            if(stones[x]==stones[y]){\\n                stones[x] = 0;\\n                stones[y] = 0;\\n            }else{\\n                stones[y] -= stones[x];\\n                stones[x] = 0;\\n            }\\n            Arrays.sort(stones);\\n            if(stones[x]==0)break;\\n        }\\n        return stones[y];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1921204,
                "title": "python-6-lines-sortedlist-clean",
                "content": "**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        sl = SortedList(stones)\\n        while len(sl) >= 2:\\n            y = sl.pop()\\n            x = sl.pop()\\n            if y > x: sl.add(y - x)  # Note that sl is a SortedList\\n        return sl.pop() if len(sl) else 0\\n```\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        sl = SortedList(stones)\\n        while len(sl) >= 2:\\n            y = sl.pop()\\n            x = sl.pop()\\n            if y > x: sl.add(y - x)  # Note that sl is a SortedList\\n        return sl.pop() if len(sl) else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365807,
                "title": "c-priority-queue-100-time-short-easy-to-understand",
                "content": "```\\npriority_queue<int> pq(v.begin(),v.end());\\n        \\n        while(true)\\n        {\\n            if(pq.size() ==0)   return 0;\\n            if(pq.size() ==1)   return pq.top();\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n            if(a!=b)    pq.push(abs(a-b));\\n        }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npriority_queue<int> pq(v.begin(),v.end());\\n        \\n        while(true)\\n        {\\n            if(pq.size() ==0)   return 0;\\n            if(pq.size() ==1)   return pq.top();\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n            if(a!=b)    pq.push(abs(a-b));\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854146,
                "title": "python-heap-explained-with-easy-code",
                "content": "# Naive Approach\\nThe naive approach to solve the question, would be:\\n\\n1. Sort the array in decreasing order\\n2. Pop the first two elements, subtract them.\\n3. If the difference is 0, then do nothing. Else, append the difference in the array\\n4. Repeat the step 1, 2 and 3 until there is only one item left in the array\\n5. The only item left in the array is the answer\\n\\nHowever, the time complexity would be high because sorting is performed (N-1) times. The time complexity would be O(N<sup>2</sup>).\\n\\n---\\n\\n\\n# Optimal Approach\\nThe optimal approach uses a very important Data Structure, Heap. Heap is a Complete Binary Tree.\\nFirst, let\\'s understand what is a <b>Complete Binary Tree</b>. \\n*[Skip if you know that already]*\\n\\n### Complete Binary Tree\\n1. <b>Definition 1</b>\\nA complete binary tree is a binary tree where all the levels, except the last level must be completely filled. The last level may or may not be filled completely. The last level MUST be filled from left to right.\\n2. <b>Definition 2</b>\\nA Complete Binary Tree is a Tree, where every level in the tree is required to be filled with maximum nodes, except the last level. The last level may not be completely filled but all the nodes in the last level must be towards the left of the tree.\\n\\n## Heap\\nHeap Data Strucutre, is a Complete Binary Tree, which satisfies the <b>Heap Property</b>. We are going to discuss the heap properties in a moment. There are two types of Heaps: <b>MaxHeap</b> and <b>MinHeap</b>.\\n\\n## MaxHeap\\nProperty for a MaxHeap is \"<b>The value of every node is less than or equal to its parent</b>\". Therefore, in a MaxHeap, the maximum value resides as the root node. Here is a valid MaxHeap:\\n<table width = \"100%\">\\n<tr>\\n<td><img src = \"https://assets.leetcode.com/users/images/22cb76cb-8d54-4e4a-8947-d500f0c7c0f3_1669561918.8131528.png\" style =\"text-align: center; margin: 0; width: 100%;\" /></td>\\n</tr>\\n<tr>\\n<td>This is a valid MaxHeap Tree because:\\n<ol>\\n<li>It is a complete binary tree. Every level is completely filled except the last level which is completely left aligned.</li>\\n<li>Every Node is less than or equal to its parent node.</li>\\n</ol>\\n</td>\\n</tr>\\n</table>\\n\\n## MinHeap\\nMinHeap is just opposite of MaxHeap. The Heap Property for a MinHeap is \"<b>The value of every node is greater than or equal to its parent</b>\". Therefore, in a MinHeap, the minimum value resides as the root node.\\n\\n---\\n\\n# Why Heap?\\n\\nAs you just saw, in a MaxHeap, the maximum element is guaranteed to be on the top of the tree, or in a MinHeap, the minimum element is guaranteed to be on the top of the tree. In an sorted array, each time, we inserted, removed or updated an element in the array, the whole array needs to be sorted again to keep the array in order. It was a very time costly operation. In heaps, we can remove, insert or update an element in the heap in `log N`.\\n\\n### How is it so fast?\\nThis high performace is achieved because a Heap Tree can be written in an array (list) in such a way that, the traversals are easy as compared to that in a normal array. \\nFor example, let\\'s write the above mentioned MaxHeap in the array.:\\n<table>\\n<tr>\\n<td>100</td>\\n<td>17</td>\\n<td>39</td>\\n<td>15</td>\\n<td>13</td>\\n<td>36</td>\\n<td>25</td>\\n<td>14</td>\\n<td>9</td>\\n</tr>\\n</table>\\n\\nLet the indices be 1, 2, 3, 4... and so on. If, I ask you to look at the array and tell me the parent of 36 in the Heap, how would you do it?\\nWell, there\\'s a simple trick. Get the index of 36, which is 6. Floored Division of the index by 2 would give the index of its parent. Hence, its parent is at index 3, i.e. 39. You can try that for other elements as well.... You can also do the opposite, i.e. multiply and index by 2 to get the index of left child, and add 1 to it to get the index of right child.\\nThis holds true, as long as the tree is a Complete Binary Tree.\\n\\nNow, how things work is... say you want to insert an element 19 in the array (or heap). The algorithm goes like:\\n1. Add 19 to the next available position in the heap, i.e. 19 would be added as the left child of 13 (Consider the tree diagram above). \\n**Important:** Note that, in the array notation of the heap, the element would be added to the last of the array. Actually, there is no data structure like Complete Binary Tree getting involved here, it\\'s just for visualisation. All the operations we do are on the array.\\n2. Find the parent of 19 and compare both the numbers. Here, the parent is 13 and 13 < 19. Since, it is a Max Heap, larger number remains on top. So, we swap 13 with 19.\\n3. Now, again we find the parent of 19, which would be 17 this time. Again, 17 < 19. So, 17 and 19 are swapped.\\n4. Again the parent of 19 is 100, but 100 > 19, so no more swapping is done, and we have our element inserted.\\n\\nSimilarily there are deletion operations, which can also be performed in `log N` time. But, we are not going deeper into this.\\n\\n---\\n\\n# Heap in Python\\nPython provides an inbuilt module for dealing with heap data structure, namely \\'heapq\\'. It has various functions which are going to help us throughout the program. Thus, we need to import it to use it. The library can be used to create MinHeap. But, we can use the properties of MaxHeap if we multiply every value in the MinHeap with -1. Then, the negative value of every node acts as a MaxHeap.\\nLet\\'s code:\\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        \\n\\t\\t#    First, import the heapq module. Specifically the functions heapify, heappop and heappush\\n        from heapq import heapify, heappop, heappush\\n        \\n\\t\\t#    Initialize an empty array, which we would use as heap\\n        heap = []\\n        for stone in stones:\\n\\t\\t\\n\\t\\t#    We would add the negative values of the given list in the Heap\\n            heap.append(-stone)\\n        \\n\\t\\t#    heapify function from the heapq module, takes an array as parameter, arranges the contents\\n\\t\\t#    of the array in such a way that the array becomes a minheap\\n        heapify(heap)\\n        \\n        while len(heap) > 1:\\n\\t\\t\\n\\t\\t#    heappop function from the heapq module, takes an array (heap) as parameter, and removes\\n\\t\\t#    the root of the minheap, returns the value, and then makes the necessary arrangement so\\n\\t\\t#    that the heap does not lose its properties.\\n            x = heappop(heap)\\n            y = heappop(heap)\\n            \\n\\t\\t#    if the two minimum values from the heap are not equal, then subtract the larger value (smaller\\n\\t\\t#    magnitude) from the smaller value (larger magnitude). Add the difference back to the heap\\n            if x != y:\\n\\t\\t\\t\\n\\t\\t#    heappush function, from the heapq module, takes an array (heap) as parameter, and adds\\n\\t\\t#    the second parameter to the array, maintaining the heap properties of the array.\\n                heappush(heap, x - y)\\n        \\n\\t\\t#    if heap is not empty then, return the first item in the heap multiplied by -1\\n        if heap:\\n            return -heap[0]\\n\\t\\t\\t\\n\\t\\t#    if heap was empty, then return 0\\n        return 0\\n```\\n\\nIt took sweats to create this post. Please upvote, if you found it helpful. Happy Leetcoding!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        \\n\\t\\t#    First, import the heapq module. Specifically the functions heapify, heappop and heappush\\n        from heapq import heapify, heappop, heappush\\n        \\n\\t\\t#    Initialize an empty array, which we would use as heap\\n        heap = []\\n        for stone in stones:\\n\\t\\t\\n\\t\\t#    We would add the negative values of the given list in the Heap\\n            heap.append(-stone)\\n        \\n\\t\\t#    heapify function from the heapq module, takes an array as parameter, arranges the contents\\n\\t\\t#    of the array in such a way that the array becomes a minheap\\n        heapify(heap)\\n        \\n        while len(heap) > 1:\\n\\t\\t\\n\\t\\t#    heappop function from the heapq module, takes an array (heap) as parameter, and removes\\n\\t\\t#    the root of the minheap, returns the value, and then makes the necessary arrangement so\\n\\t\\t#    that the heap does not lose its properties.\\n            x = heappop(heap)\\n            y = heappop(heap)\\n            \\n\\t\\t#    if the two minimum values from the heap are not equal, then subtract the larger value (smaller\\n\\t\\t#    magnitude) from the smaller value (larger magnitude). Add the difference back to the heap\\n            if x != y:\\n\\t\\t\\t\\n\\t\\t#    heappush function, from the heapq module, takes an array (heap) as parameter, and adds\\n\\t\\t#    the second parameter to the array, maintaining the heap properties of the array.\\n                heappush(heap, x - y)\\n        \\n\\t\\t#    if heap is not empty then, return the first item in the heap multiplied by -1\\n        if heap:\\n            return -heap[0]\\n\\t\\t\\t\\n\\t\\t#    if heap was empty, then return 0\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448720,
                "title": "priority-queue-max-heap-clean-code-easy-explaination",
                "content": "# Intuition\\nIf you reached here it\\'s for sure you not able to get to the solution in the first place dont worry I did the same mistake. \\n\\nJust read the question nicely, It says every time you have to pick the stones with largest weight, so for sure you might have sorted the Array and applied a greedy approach,but you\\'ll have to perform sort operation everytime you perform a operation. \\n\\nSo priority queue uses a Data structure called Max heap for the implemenation where the top node is always the maximum and we can get it in 0(1) time.\\n\\nYou can see the code we just pop two top stones with heigest weight and put a stone again in it.\\n\\n# Approach\\nSimple thinking, Heap Data structure greedy.\\n\\n# Complexity\\n- Time complexity:\\nCreation of priority-0(nlogn)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++) pq.push(stones[i]);\\n        while(pq.size()>=2)\\n        {\\n           int x = pq.top(); pq.pop();\\n           int y = pq.top(); pq.pop();\\n           if(x!=y) pq.push(abs(x-y));\\n\\n        }if(pq.size()==0) return 0;\\n        return pq.top();\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++) pq.push(stones[i]);\\n        while(pq.size()>=2)\\n        {\\n           int x = pq.top(); pq.pop();\\n           int y = pq.top(); pq.pop();\\n           if(x!=y) pq.push(abs(x-y));\\n\\n        }if(pq.size()==0) return 0;\\n        return pq.top();\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123710,
                "title": "javascript-simple-priority-queue",
                "content": "```\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575358,
                "title": "easy-c-solution-using-priority-queue",
                "content": "1. Create a Priority queue (pq)\\n2. as long as size of pq > 1:\\n* every time pop two elements \\n* subtract second from first\\n* if res of subtractions is non-zero push this result back into pq\\nCODE:\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n     priority_queue<int> pq;\\n      for(auto i : stones)        pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top(); pq.pop();\\n          int b = pq.top(); pq.pop();\\n          if(a  - b > 0)\\n              pq.push(a-b);\\n      }\\n      return pq.empty()?0:pq.top();  \\n    }\\n",
                "solutionTags": [],
                "code": "1. Create a Priority queue (pq)\\n2. as long as size of pq > 1:\\n* every time pop two elements \\n* subtract second from first\\n* if res of subtractions is non-zero push this result back into pq\\nCODE:\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n     priority_queue<int> pq;\\n      for(auto i : stones)        pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top(); pq.pop();\\n          int b = pq.top(); pq.pop();\\n          if(a  - b > 0)\\n              pq.push(a-b);\\n      }\\n      return pq.empty()?0:pq.top();  \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1921745,
                "title": "rust-heap-and-matching",
                "content": "Code is short thanks to Rust\\'s pattern matching:\\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        loop {\\n            match (heap.pop(), heap.pop()) {\\n                (Some(a), Some(b)) => if a > b {\\n                    heap.push(a - b);\\n                }\\n                (Some(a), None) => return a,\\n                (None, _) => return 0,\\n            };\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        loop {\\n            match (heap.pop(), heap.pop()) {\\n                (Some(a), Some(b)) => if a > b {\\n                    heap.push(a - b);\\n                }\\n                (Some(a), None) => return a,\\n                (None, _) => return 0,\\n            };\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 576384,
                "title": "python-solution-simplest-2-line",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) > 1: stones.append(stones.pop(stones.index(max(stones))) - stones.pop(stones.index(max(stones))))\\n        return stones[0]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) > 1: stones.append(stones.pop(stones.index(max(stones))) - stones.pop(stones.index(max(stones))))\\n        return stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354141,
                "title": "java-4-liner-explained",
                "content": "**Idea:**\\n* Push all stones in a max-heap\\n* Poll two stones, and push their difference back into the heap\\n* Do this till there\\'s only 1 stone left\\n\\n>**T/S:** O(n lg n)/O(n), where n = size(stones)\\n```\\npublic int lastStoneWeight(int[] stones) {\\n\\tvar maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\t\\n\\tfor (var stone : stones)\\n\\t\\tmaxHeap.add(stone);\\n\\n\\twhile (maxHeap.size() > 1)\\n\\t\\tmaxHeap.offer(maxHeap.poll() - maxHeap.poll());\\n\\t\\t\\n\\treturn maxHeap.poll();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n\\tvar maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\t\\n\\tfor (var stone : stones)\\n\\t\\tmaxHeap.add(stone);\\n\\n\\twhile (maxHeap.size() > 1)\\n\\t\\tmaxHeap.offer(maxHeap.poll() - maxHeap.poll());\\n\\t\\t\\n\\treturn maxHeap.poll();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449074,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "We can see that after two stones break we need to replace them back in the array. Where depends on how much they broke down, and it isn\\'t always guaranteed to be the end. This points toward a data structure that allows us to restructure efficiently, and that would be a Max Heap.\\n\\nA max heap is a tree structure that keeps the largest value on top, and for each child the same holds true. When we pop from a heap, the heap will restructure itself to maintain the same dynamics. So 2 pops from a max heap will result in us receiving the 2 largest stones. Pushing back on the heap will place the stones in their correct spot.\\n\\nNote: A lot of built-in heaps are min heap implementations, to utilize them, we must push the negative weights of the stones on the heap to maintain a max heap structure.\\n\\nTime Complexity: $$O(nlogn)$$. Where $$n$$ is the size of the heap/stones array. It will take $$n*log(n)$$ time to create the initial heap, then up to $$log(n)$$ time to place the broken-down stones back into the heap.\\n\\nSpace Complexity: $$O(n)$$. Where $$n$$ is the size of the stones array, to maintain our heap data structure with up to $$n$$ stones inside.\\n\\n\\n```py\\n# written by ColeB2\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # initialize an empty array to hold our heap, python uses\\n        # arrays, and the heapq module to handle min Heaps. We will\\n        # use negative values of the stones to convert to a max heap.\\n        heap = []\\n        # loop through each stone in our stones array\\n        for stone in stones:\\n            # push the negative value of the stone onto the heap.\\n            # heappush takes the heap array, and the value to push\\n            # onto the heap. -stone will allow the min heap to act\\n            # as a max heap instead.\\n            heapq.heappush(heap, -stone)\\n        # We need at least 2 stones to smash together, so we loop while\\n        # our heap has at least 2 stones inside.\\n        while len(heap) >= 2:\\n            # pop both stones off, the 1st is the largest stone.\\n            stone1 = heapq.heappop(heap)\\n            stone2 = heapq.heappop(heap)\\n            # if the second stone is bigger, since we are using negative\\n            # values, the second being bigger, means they are not\\n            # the same size, and the first is larger. This means\\n            # the stone won\\'t be completely destroyed, so we need\\n            # co calculate the difference to add onto the heap.\\n            if stone2 > stone1:\\n                # Add onto the heap the difference of stones 1 and 2.\\n                heapq.heappush(heap, stone1 - stone2)\\n        # remembering that we used negative values of the stones, we \\n        # must return the absolute value of the remaining stone if it\\n        # exists, else 0 as the question asks.\\n        return abs(heap[0]) if heap else 0\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        // initialize a priority_queue in c++\\n        priority_queue<int> pq;\\n        // push the positive value of the stone onto the priority_queue\\n        for (int x : stones) pq.push(x); \\n        // We need at least 2 stones to smash together, so we loop while\\n        // our heap has at least 2 stones inside.\\n        while (pq.size() >= 2) {\\n            // pop both stones off, the 1st is the largest stone.\\n            int y = pq.top(); pq.pop();\\n            int x = pq.top(); pq.pop();\\n            // if the stones are not same, then the stone of weight x is detroyed\\n            // and the stone of weight y has new weight y - x.\\n            if (x != y) pq.push(y - x);\\n        }\\n        // if there are no stones left, return 0\\n        if (pq.size() == 0) return 0;\\n        // return the weight of the last remaining stone\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```py\\n# written by ColeB2\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # initialize an empty array to hold our heap, python uses\\n        # arrays, and the heapq module to handle min Heaps. We will\\n        # use negative values of the stones to convert to a max heap.\\n        heap = []\\n        # loop through each stone in our stones array\\n        for stone in stones:\\n            # push the negative value of the stone onto the heap.\\n            # heappush takes the heap array, and the value to push\\n            # onto the heap. -stone will allow the min heap to act\\n            # as a max heap instead.\\n            heapq.heappush(heap, -stone)\\n        # We need at least 2 stones to smash together, so we loop while\\n        # our heap has at least 2 stones inside.\\n        while len(heap) >= 2:\\n            # pop both stones off, the 1st is the largest stone.\\n            stone1 = heapq.heappop(heap)\\n            stone2 = heapq.heappop(heap)\\n            # if the second stone is bigger, since we are using negative\\n            # values, the second being bigger, means they are not\\n            # the same size, and the first is larger. This means\\n            # the stone won\\'t be completely destroyed, so we need\\n            # co calculate the difference to add onto the heap.\\n            if stone2 > stone1:\\n                # Add onto the heap the difference of stones 1 and 2.\\n                heapq.heappush(heap, stone1 - stone2)\\n        # remembering that we used negative values of the stones, we \\n        # must return the absolute value of the remaining stone if it\\n        # exists, else 0 as the question asks.\\n        return abs(heap[0]) if heap else 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        // initialize a priority_queue in c++\\n        priority_queue<int> pq;\\n        // push the positive value of the stone onto the priority_queue\\n        for (int x : stones) pq.push(x); \\n        // We need at least 2 stones to smash together, so we loop while\\n        // our heap has at least 2 stones inside.\\n        while (pq.size() >= 2) {\\n            // pop both stones off, the 1st is the largest stone.\\n            int y = pq.top(); pq.pop();\\n            int x = pq.top(); pq.pop();\\n            // if the stones are not same, then the stone of weight x is detroyed\\n            // and the stone of weight y has new weight y - x.\\n            if (x != y) pq.push(y - x);\\n        }\\n        // if there are no stones left, return 0\\n        if (pq.size() == 0) return 0;\\n        // return the weight of the last remaining stone\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575369,
                "title": "python-solution-4-lines",
                "content": "```\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            stones.append(stones.pop() - stones.pop()) \\n        return stones[0]\\n\\t\\t\\n\\t\\t\\n\\t\\tFollow me for more intresting programming questions :\\n\\t\\t\\t\\t\\t\\t\\thttps://www.github.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.instagaram.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.linkedin.com/in/shubhamsagar\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n#Another Possible approch [If you don\\'t want to decrease the length of loop every time]\\n\\n```\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #stones=[2,7,4,1,8,1]\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            temp=stones[-1] - stones[-2]\\n            stones[-2]=-1\\n            stones[-1]=temp\\n        return (stones[-1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            stones.append(stones.pop() - stones.pop()) \\n        return stones[0]\\n\\t\\t\\n\\t\\t\\n\\t\\tFollow me for more intresting programming questions :\\n\\t\\t\\t\\t\\t\\t\\thttps://www.github.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.instagaram.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.linkedin.com/in/shubhamsagar\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n#Another Possible approch [If you don\\'t want to decrease the length of loop every time]\\n\\n```\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #stones=[2,7,4,1,8,1]\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            temp=stones[-1] - stones[-2]\\n            stones[-2]=-1\\n            stones[-1]=temp\\n        return (stones[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921692,
                "title": "simple-solution-using-arraylist-java-self-explanatory",
                "content": "class Solution {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        ArrayList<Integer> ar = new ArrayList<>();\\n        \\n        for(int i=0;i<stones.length;i++){\\n            ar.add(stones[i]);\\n        }\\n        \\n       \\n       \\n        while(ar.size()>1){\\n             \\n        Collections.sort(ar);\\n            \\n            int y = ar.get(ar.size()-1);\\n            ar.remove(new Integer(y));\\n            \\n            int x = ar.get(ar.size()-1);\\n            ar.remove(new Integer(x));\\n            \\n            if(x!=y){\\n                ar.add(y-x);\\n            }\\n           \\n            \\n        }\\n        \\n        if(ar.isEmpty()){\\n            return 0;\\n        }else{\\n            return ar.get(0);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        ArrayList<Integer> ar = new ArrayList<>();\\n        \\n        for(int i=0;i<stones.length;i++){\\n            ar.add(stones[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 714283,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while (stones.length > 1) {\\n        let max1 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max1),1);\\n        let max2 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max2),1);\\n        if (max1 !== max2) stones.push(Math.abs(max1-max2));       \\n    }\\n    return stones[0] || 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while (stones.length > 1) {\\n        let max1 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max1),1);\\n        let max2 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max2),1);\\n        if (max1 !== max2) stones.push(Math.abs(max1-max2));       \\n    }\\n    return stones[0] || 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575519,
                "title": "c-countsort-bucketsort-solution",
                "content": "Since range of the elements is limited to integers between 1 and 1000, we can easily extend a bucket sort / count sort technique to this problem.\\n\\n1. Keep count of elements (in say array `arr`) against the indexes derived from their values. So, if we see a value `x`, we increment `arr[x]`. Thus each index is marking the bucket of the index value.\\n2. Start from the highest index 1000 and gradually come down to the lowest index 1, smashing rocks along the way. I use two pointers `lo` and `hi` to point to the two rocks that will be smashed in the current iteration. If there are multiple occurrences of a rock, `lo` and `hi` might point to the same index / bucket.\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int arr[1010] = {0};\\n        \\n        for(auto num: stones)\\n            arr[num]++;\\n        \\n        int hi = 1000, lo = hi;\\n        while(lo > 0 && hi > 0) {\\n            while(hi > 0 && arr[hi] < 1)\\n                hi--;\\n            \\n            if(hi < 1)\\n                break;\\n            \\n            lo = arr[hi] > 1 ? hi : hi-1;\\n            while(lo > 0 && arr[lo] < 1)\\n                    lo--;\\n            \\n            if(lo < 1)\\n                break;\\n            \\n            // smash!\\n            arr[hi-lo]++;\\n            arr[hi]--;\\n            arr[lo]--;\\n        }\\n        \\n        return hi * (arr[hi] > 0);\\n    }\\n};\\n```\\n\\n+ Uses extra linear space in the order of the range of elements.\\n+ Runs in linear time in the order of the number of elements.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int arr[1010] = {0};\\n        \\n        for(auto num: stones)\\n            arr[num]++;\\n        \\n        int hi = 1000, lo = hi;\\n        while(lo > 0 && hi > 0) {\\n            while(hi > 0 && arr[hi] < 1)\\n                hi--;\\n            \\n            if(hi < 1)\\n                break;\\n            \\n            lo = arr[hi] > 1 ? hi : hi-1;\\n            while(lo > 0 && arr[lo] < 1)\\n                    lo--;\\n            \\n            if(lo < 1)\\n                break;\\n            \\n            // smash!\\n            arr[hi-lo]++;\\n            arr[hi]--;\\n            arr[lo]--;\\n        }\\n        \\n        return hi * (arr[hi] > 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498199,
                "title": "1046-javascript-recursive-one-liner",
                "content": "> Runtime: **64 ms**, faster than *52.83%* of JavaScript online submissions\\n> Memory Usage: **35.2 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```\\nconst lastStoneWeight = s =>\\n  1 === s.length\\n    ? s[0]\\n    : lastStoneWeight(s.sort((a, b) => a - b).concat(s.pop() - s.pop()));\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst lastStoneWeight = s =>\\n  1 === s.length\\n    ? s[0]\\n    : lastStoneWeight(s.sort((a, b) => a - b).concat(s.pop() - s.pop()));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448997,
                "title": "python3-easy-solution-with-explanation-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #first sort the list\\n        stones.sort()\\n\\n        while stones:\\n            #most heaviest stone\\n            s1 = stones.pop()\\n\\n            #if list is empty after removing one stone i.e s1 then \\n            #return s1\\n            if not stones: return s1\\n\\n            #second heaviest stone s2 where s2 <= s1\\n            s2 = stones.pop()\\n\\n            #if s1 > s2 then element to be inserted is s1-s2 as given in the \\n            #problem statement\\n            if s1 > s2:\\n\\n                #using Insort_left Function Of Bisect Module\\n                #we will insert s1-s2 at correct position \\n                insort_left(stones, s1-s2)\\n\\n            #else s1 == s2 and as we are continously popping elements \\n            #both the stones are destroyed if they are same\\n\\n        #if no more stones remaining return 0 \\n        return 0 \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #first sort the list\\n        stones.sort()\\n\\n        while stones:\\n            #most heaviest stone\\n            s1 = stones.pop()\\n\\n            #if list is empty after removing one stone i.e s1 then \\n            #return s1\\n            if not stones: return s1\\n\\n            #second heaviest stone s2 where s2 <= s1\\n            s2 = stones.pop()\\n\\n            #if s1 > s2 then element to be inserted is s1-s2 as given in the \\n            #problem statement\\n            if s1 > s2:\\n\\n                #using Insort_left Function Of Bisect Module\\n                #we will insert s1-s2 at correct position \\n                insort_left(stones, s1-s2)\\n\\n            #else s1 == s2 and as we are continously popping elements \\n            #both the stones are destroyed if they are same\\n\\n        #if no more stones remaining return 0 \\n        return 0 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921076,
                "title": "java-easy-and-fast-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int count = stones.length-1;\\n        while(count!=0)\\n        {\\n            if(stones[stones.length-1]==stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=0;\\n                stones[stones.length-2]=0;\\n            }\\n            if(stones[stones.length-1]!=stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=stones[stones.length-1] - stones[stones.length-2];\\n                stones[stones.length-2]=0;\\n            }\\n            Arrays.sort(stones);\\n            count--;\\n        }\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n \\xA0 \\xA0return stones[stones.length-1]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int count = stones.length-1;\\n        while(count!=0)\\n        {\\n            if(stones[stones.length-1]==stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=0;\\n                stones[stones.length-2]=0;\\n            }\\n            if(stones[stones.length-1]!=stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=stones[stones.length-1] - stones[stones.length-2];\\n                stones[stones.length-2]=0;\\n            }\\n            Arrays.sort(stones);\\n            count--;\\n        }\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n \\xA0 \\xA0return stones[stones.length-1]\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772788,
                "title": "go-heap-solution",
                "content": "Cause all I do is dance.\\n```\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int {return len(h)}\\nfunc (h IntHeap) Less(i, j int) bool {return h[i] > h[j]}\\nfunc (h IntHeap) Swap(i, j int) {h[i], h[j] = h[j], h[i]}\\nfunc (h *IntHeap) Push(x interface{}) {*h = append(*h, x.(int))}\\nfunc (h *IntHeap) Pop() interface{} {\\n    n := len(*h)\\n    x := (*h)[n-1]\\n    *h = (*h)[0:n-1]\\n    return x\\n}\\n\\nfunc lastStoneWeight(stones []int) int {\\n    pq := IntHeap(stones)\\n    heap.Init(&pq)\\n    for pq.Len() > 1 {\\n        x, y := heap.Pop(&pq).(int), heap.Pop(&pq).(int)\\n        if x != y {\\n            heap.Push(&pq, x-y)\\n        }\\n    }\\n    \\n    if pq.Len() == 0 {\\n        return 0\\n    }\\n    \\n    return heap.Pop(&pq).(int)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int {return len(h)}\\nfunc (h IntHeap) Less(i, j int) bool {return h[i] > h[j]}\\nfunc (h IntHeap) Swap(i, j int) {h[i], h[j] = h[j], h[i]}\\nfunc (h *IntHeap) Push(x interface{}) {*h = append(*h, x.(int))}\\nfunc (h *IntHeap) Pop() interface{} {\\n    n := len(*h)\\n    x := (*h)[n-1]\\n    *h = (*h)[0:n-1]\\n    return x\\n}\\n\\nfunc lastStoneWeight(stones []int) int {\\n    pq := IntHeap(stones)\\n    heap.Init(&pq)\\n    for pq.Len() > 1 {\\n        x, y := heap.Pop(&pq).(int), heap.Pop(&pq).(int)\\n        if x != y {\\n            heap.Push(&pq, x-y)\\n        }\\n    }\\n    \\n    if pq.Len() == 0 {\\n        return 0\\n    }\\n    \\n    return heap.Pop(&pq).(int)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450508,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while len(stones)>1:\\n            y=stones.pop(-1)\\n            x=stones.pop(-1)\\n            if x!=y:\\n                stones.append(y-x)\\n            stones.sort()\\n        return stones[0] if len(stones)>=1 else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while len(stones)>1:\\n            y=stones.pop(-1)\\n            x=stones.pop(-1)\\n            if x!=y:\\n                stones.append(y-x)\\n            stones.sort()\\n        return stones[0] if len(stones)>=1 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449734,
                "title": "python-elegant-short-max-heap",
                "content": "# Complexity\\n- Time complexity: $$O(n * \\\\log_2 {n})$$\\n- Space complexity: $$O(n)$$\\n\\n# Maximum heap code\\n```\\nclass MaxHeap:\\n    def __init__(self, data: List[int]):\\n        self.data = [-num for num in data]\\n        heapq.heapify(self.data)\\n\\n    def push(self, item: int):\\n        heapq.heappush(self.data, -item)\\n\\n    def pop(self) -> int:\\n        return -heapq.heappop(self.data)\\n\\n    def __len__(self) -> int:\\n        return len(self.data)\\n\\n    def __bool__(self) -> bool:\\n        return len(self) != 0\\n```\\n\\n# Solution code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heap = MaxHeap(stones)\\n\\n        while len(heap) > 1:\\n            first, second = heap.pop(), heap.pop()\\n            if first != second:\\n                heap.push(abs(first - second))\\n\\n        return heap.pop() if heap else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MaxHeap:\\n    def __init__(self, data: List[int]):\\n        self.data = [-num for num in data]\\n        heapq.heapify(self.data)\\n\\n    def push(self, item: int):\\n        heapq.heappush(self.data, -item)\\n\\n    def pop(self) -> int:\\n        return -heapq.heappop(self.data)\\n\\n    def __len__(self) -> int:\\n        return len(self.data)\\n\\n    def __bool__(self) -> bool:\\n        return len(self) != 0\\n```\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heap = MaxHeap(stones)\\n\\n        while len(heap) > 1:\\n            first, second = heap.pop(), heap.pop()\\n            if first != second:\\n                heap.push(abs(first - second))\\n\\n        return heap.pop() if heap else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449269,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while True:\\n            stones = sorted(stones,reverse = True)\\n            if len(stones) == 1:\\n                return stones[0]\\n            elif len(stones) == 0:\\n                return 0\\n            first = stones.pop(0)\\n            sec = stones.pop(0)\\n            if first == sec:\\n                continue\\n            else:\\n                stones.append(first-sec)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while True:\\n            stones = sorted(stones,reverse = True)\\n            if len(stones) == 1:\\n                return stones[0]\\n            elif len(stones) == 0:\\n                return 0\\n            first = stones.pop(0)\\n            sec = stones.pop(0)\\n            if first == sec:\\n                continue\\n            else:\\n                stones.append(first-sec)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593690,
                "title": "js-heap-easy-understanding",
                "content": "Solution 1 - O(n^2*logn)\\n\\n```\\nvar lastStoneWeight = function(stones) {\\n\\n    while(stones.length > 1) {\\n        stones.sort((a, b) => a - b);\\n        let x = stones.pop();\\n        let y = stones.pop();\\n        \\n        if(x === y) continue;\\n        else stones.push(Math.abs(x - y));\\n    }\\n    \\n    return stones;\\n}\\n```\\n\\nSolution 2 - O(n*logn)\\n\\n```\\nclass Heap {\\n    constructor(stones) {\\n        this.heap = stones;\\n        this.size = stones.length;\\n        this.heapify(0);\\n    }\\n    right(pos) {\\n        return 2 * pos + 2;\\n    }\\n    left(pos) {\\n        return 2 * pos + 1;\\n    }\\n    isleaf(pos) {\\n        if (2 * pos + 1 >= this.size) return true;\\n        return false;\\n    }\\n    swap(a, b) {\\n        let temp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = temp;\\n    }\\n    fix(pos) {\\n        if (this.isleaf(pos)) return;\\n        let left = this.left(pos);\\n        let right = this.right(pos);\\n        let bigger = left;\\n        if (right < this.size)\\n            bigger = this.heap[left] > this.heap[right] ? left : right;\\n        if (this.heap[pos] < this.heap[bigger]) {\\n            this.swap(pos, bigger);\\n            this.fix(bigger);\\n        }\\n    }\\n    heapify(pos) {\\n        if (this.isleaf(pos)) return;\\n        this.heapify(this.left(pos));\\n        this.heapify(this.right(pos));\\n        this.fix(pos);\\n    }\\n    delete() {\\n        this.swap(0, --this.size);\\n        this.fix(0);\\n        return this.heap[0];\\n    }\\n    insert(val) {\\n        this.size++;\\n        this.heap[this.size - 1] = val;\\n        this.heapify(0);\\n    }\\n    peek() {\\n        return this.heap[0];\\n    }\\n}\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function (stones) {\\n    const heap = new Heap(stones);\\n    while (heap.size > 1) {\\n        let x = heap.peek();\\n        heap.delete();\\n        let y = heap.peek();\\n        heap.delete();\\n        const res = x - y;\\n        if (res > 0) heap.insert(res);\\n    }\\n    if (heap.size) return heap.peek();\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n\\n    while(stones.length > 1) {\\n        stones.sort((a, b) => a - b);\\n        let x = stones.pop();\\n        let y = stones.pop();\\n        \\n        if(x === y) continue;\\n        else stones.push(Math.abs(x - y));\\n    }\\n    \\n    return stones;\\n}\\n```\n```\\nclass Heap {\\n    constructor(stones) {\\n        this.heap = stones;\\n        this.size = stones.length;\\n        this.heapify(0);\\n    }\\n    right(pos) {\\n        return 2 * pos + 2;\\n    }\\n    left(pos) {\\n        return 2 * pos + 1;\\n    }\\n    isleaf(pos) {\\n        if (2 * pos + 1 >= this.size) return true;\\n        return false;\\n    }\\n    swap(a, b) {\\n        let temp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = temp;\\n    }\\n    fix(pos) {\\n        if (this.isleaf(pos)) return;\\n        let left = this.left(pos);\\n        let right = this.right(pos);\\n        let bigger = left;\\n        if (right < this.size)\\n            bigger = this.heap[left] > this.heap[right] ? left : right;\\n        if (this.heap[pos] < this.heap[bigger]) {\\n            this.swap(pos, bigger);\\n            this.fix(bigger);\\n        }\\n    }\\n    heapify(pos) {\\n        if (this.isleaf(pos)) return;\\n        this.heapify(this.left(pos));\\n        this.heapify(this.right(pos));\\n        this.fix(pos);\\n    }\\n    delete() {\\n        this.swap(0, --this.size);\\n        this.fix(0);\\n        return this.heap[0];\\n    }\\n    insert(val) {\\n        this.size++;\\n        this.heap[this.size - 1] = val;\\n        this.heapify(0);\\n    }\\n    peek() {\\n        return this.heap[0];\\n    }\\n}\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function (stones) {\\n    const heap = new Heap(stones);\\n    while (heap.size > 1) {\\n        let x = heap.peek();\\n        heap.delete();\\n        let y = heap.peek();\\n        heap.delete();\\n        const res = x - y;\\n        if (res > 0) heap.insert(res);\\n    }\\n    if (heap.size) return heap.peek();\\n    return 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921399,
                "title": "c-100-shortest-and-easiest-without-using-any-data-structure",
                "content": "```\\n\\u2714without using priority_queue\\n\\u2714all you need to do is sorting the array each time you modify it.\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>&s) {\\n        sort(s.begin(),s.end());\\n        while(s.size()>1){\\n            int i=s.size()-1;\\n            int x=s[i],y=s[i-1];\\n            s.pop_back();\\n            s.pop_back();\\n            if(x!=y)s.push_back(x-y);\\n            sort(s.begin(),s.end());\\n        }\\n        if(s.size()==0)return 0;\\n        return s[0];\\n    }\\n};\\n```\\nUPVOTE IF YOU LIKE IT!!\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n\\u2714without using priority_queue\\n\\u2714all you need to do is sorting the array each time you modify it.\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>&s) {\\n        sort(s.begin(),s.end());\\n        while(s.size()>1){\\n            int i=s.size()-1;\\n            int x=s[i],y=s[i-1];\\n            s.pop_back();\\n            s.pop_back();\\n            if(x!=y)s.push_back(x-y);\\n            sort(s.begin(),s.end());\\n        }\\n        if(s.size()==0)return 0;\\n        return s[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576377,
                "title": "python-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, nums: List[int]) -> int:        \\n        if not nums:\\n            return 0\\n        \\n        elif len(nums) == 1:\\n            return nums[0]\\n        \\n        elif len(nums) == 2:\\n            return abs(nums[0] - nums[1])\\n        \\n        else:\\n            max1 = max(nums)\\n            nums.remove(max1)\\n            max2 = max(nums)\\n            nums.remove(max2)\\n        \\n            if max1 != max2:\\n                val = abs(max1-max2)\\n                nums.append(val)\\n\\n        val = self.lastStoneWeight(nums)\\n        return val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, nums: List[int]) -> int:        \\n        if not nums:\\n            return 0\\n        \\n        elif len(nums) == 1:\\n            return nums[0]\\n        \\n        elif len(nums) == 2:\\n            return abs(nums[0] - nums[1])\\n        \\n        else:\\n            max1 = max(nums)\\n            nums.remove(max1)\\n            max2 = max(nums)\\n            nums.remove(max2)\\n        \\n            if max1 != max2:\\n                val = abs(max1-max2)\\n                nums.append(val)\\n\\n        val = self.lastStoneWeight(nums)\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360024,
                "title": "o-nlogn-and-o-n-algo",
                "content": "O(n*log(n)) Using Priority Queue\\nO(n) bucket sort\\n * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n\\n\\nPriorith Queue:\\n```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightPriorityQueue {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        System.out.println(Printer.toString(stones));\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for (int i = 0; i < stones.length; i++)\\n            pq.offer(stones[i]);\\n\\n        while (pq.size() >= 2) {\\n\\n            int s1 = pq.poll();\\n            int s2 = pq.poll();\\n\\n            if (s1 != s2)\\n                pq.offer(s1 - s2);\\n\\n        }\\n\\n        /*\\n        for (int i = 0; i < stones.length - 1; ++i)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n         */\\n\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```\\n\\nBucket Sort: O(n)\\n\\n\\n```\\n\\n/**\\n * We can apply bucket sort to make it work in linear time.\\n * Since\\n * 1 <= stones.length <= 30\\n * 1 <= stones[i] <= 1000\\n * Algorithm:\\n * 1. Find the maximum value in the stones array.\\n * 2. Create that many buckets; bucket[max]\\n * 3. Count the frequency of each bucket\\n * 4. Run backward from bucket for each element from max to 0\\n * <p>\\n * a. if this bucket has even frequency; then they will destroy each other; move back\\n * b. If this bucket has odd frequency[i]; then we need to find another bucket[j] and then update the bucket whose value is [i-j]+1\\n * As well decrease the frequency of this buckets as we used both of the stones.\\n * <p>\\n * Keep doing this, at the end the bucket which has frequency > 0 and its odd is your value.\\n * <p>\\n *\\n * <p>\\n * Complexity:\\n * Space: O(max) ; since 1 <= stones[i] <= 1000 then O(1000) is constant => O(1)\\n * <p>\\n * Time: O(n) {bucket frequency} + the maximum value of stones= 1000 and the max length of stones is 30 [1 <= stones.length <= 30[.\\n * In wost scenario; all stones are duplicate Or unique or flatten like [1,1,1,1,1000]\\n * <p>\\n * at max the loop will run 1000 time. Hence constant\\n * <p>\\n * Space: O(1)\\n * Time: O(n+1000) => O(n)\\n * <p>\\n * * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightBucketSort {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        /**\\n         * Find Max\\n         */\\n        int max = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            max = Math.max(max, stones[i]);\\n\\n        /**\\n         * Create \\'max\\' number of buckets; max+1 since array has max as value\\n         */\\n        int buckets[] = new int[max + 1];\\n\\n        /**\\n         * Count frequency\\n         */\\n        for (int i = 0; i < stones.length; i++)\\n            buckets[stones[i]]++;\\n\\n\\n        int i = max;\\n        int lastJ = max;\\n\\n        /**\\n         * Run backward\\n         */\\n        while (i > 0) {\\n\\n            /**\\n             * If this weight store is present\\n             */\\n            if (buckets[i] > 0) {\\n\\n                /**\\n                 * if frequency = even, they will destroy each other\\n                 */\\n                if (buckets[i] % 2 == 0) {\\n                    buckets[i] = 0;\\n                    i--;\\n                    continue;\\n                } else {\\n                    /**\\n                     * Otherwise find a stone whose frequency is not 0\\n                     */\\n                    int j = i - 1 > lastJ ? lastJ : i - 1;\\n                    while (j > 0 && buckets[j] == 0) j--;\\n\\n                    /**\\n                     * If no bucket left, then [i] is last stone\\n                     */\\n                    if (j == 0) {\\n                        return i;\\n//                        break;\\n                    } else {\\n                        lastJ = j;\\n\\n                        /**\\n                         * Utilize both of the stones\\n                         */\\n                        buckets[j]--;\\n                        buckets[i]--;\\n\\n                        /**\\n                         * create a new stone of i-j difference\\n                         */\\n                        buckets[i - j]++;\\n\\n\\n                        if (i - j > j) {\\n                            i = i - j;\\n                        } else {\\n                            i = j;\\n                        }\\n\\n                    }\\n                }\\n            } else\\n                i--;\\n        }\\n\\n\\n//        for (int x = 0; x < buckets.length; x++)\\n//            if (buckets[x] > 0 && buckets[x] % 2 != 0)\\n//                return x;\\n\\n        return 0;\\n    }\\n}\\n```\\n\\nworst case like \\n[1,1,1,1,1,1000] in this case the while(i>0) will run 1000^2 times if we don\\'t cache lastJ otherwise 1000 times and if (j==0) then i will be surely that last element where >0 frequency is there \\n",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightPriorityQueue {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        System.out.println(Printer.toString(stones));\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for (int i = 0; i < stones.length; i++)\\n            pq.offer(stones[i]);\\n\\n        while (pq.size() >= 2) {\\n\\n            int s1 = pq.poll();\\n            int s2 = pq.poll();\\n\\n            if (s1 != s2)\\n                pq.offer(s1 - s2);\\n\\n        }\\n\\n        /*\\n        for (int i = 0; i < stones.length - 1; ++i)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n         */\\n\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```\n```\\n\\n/**\\n * We can apply bucket sort to make it work in linear time.\\n * Since\\n * 1 <= stones.length <= 30\\n * 1 <= stones[i] <= 1000\\n * Algorithm:\\n * 1. Find the maximum value in the stones array.\\n * 2. Create that many buckets; bucket[max]\\n * 3. Count the frequency of each bucket\\n * 4. Run backward from bucket for each element from max to 0\\n * <p>\\n * a. if this bucket has even frequency; then they will destroy each other; move back\\n * b. If this bucket has odd frequency[i]; then we need to find another bucket[j] and then update the bucket whose value is [i-j]+1\\n * As well decrease the frequency of this buckets as we used both of the stones.\\n * <p>\\n * Keep doing this, at the end the bucket which has frequency > 0 and its odd is your value.\\n * <p>\\n *\\n * <p>\\n * Complexity:\\n * Space: O(max) ; since 1 <= stones[i] <= 1000 then O(1000) is constant => O(1)\\n * <p>\\n * Time: O(n) {bucket frequency} + the maximum value of stones= 1000 and the max length of stones is 30 [1 <= stones.length <= 30[.\\n * In wost scenario; all stones are duplicate Or unique or flatten like [1,1,1,1,1000]\\n * <p>\\n * at max the loop will run 1000 time. Hence constant\\n * <p>\\n * Space: O(1)\\n * Time: O(n+1000) => O(n)\\n * <p>\\n * * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightBucketSort {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        /**\\n         * Find Max\\n         */\\n        int max = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            max = Math.max(max, stones[i]);\\n\\n        /**\\n         * Create \\'max\\' number of buckets; max+1 since array has max as value\\n         */\\n        int buckets[] = new int[max + 1];\\n\\n        /**\\n         * Count frequency\\n         */\\n        for (int i = 0; i < stones.length; i++)\\n            buckets[stones[i]]++;\\n\\n\\n        int i = max;\\n        int lastJ = max;\\n\\n        /**\\n         * Run backward\\n         */\\n        while (i > 0) {\\n\\n            /**\\n             * If this weight store is present\\n             */\\n            if (buckets[i] > 0) {\\n\\n                /**\\n                 * if frequency = even, they will destroy each other\\n                 */\\n                if (buckets[i] % 2 == 0) {\\n                    buckets[i] = 0;\\n                    i--;\\n                    continue;\\n                } else {\\n                    /**\\n                     * Otherwise find a stone whose frequency is not 0\\n                     */\\n                    int j = i - 1 > lastJ ? lastJ : i - 1;\\n                    while (j > 0 && buckets[j] == 0) j--;\\n\\n                    /**\\n                     * If no bucket left, then [i] is last stone\\n                     */\\n                    if (j == 0) {\\n                        return i;\\n//                        break;\\n                    } else {\\n                        lastJ = j;\\n\\n                        /**\\n                         * Utilize both of the stones\\n                         */\\n                        buckets[j]--;\\n                        buckets[i]--;\\n\\n                        /**\\n                         * create a new stone of i-j difference\\n                         */\\n                        buckets[i - j]++;\\n\\n\\n                        if (i - j > j) {\\n                            i = i - j;\\n                        } else {\\n                            i = j;\\n                        }\\n\\n                    }\\n                }\\n            } else\\n                i--;\\n        }\\n\\n\\n//        for (int x = 0; x < buckets.length; x++)\\n//            if (buckets[x] > 0 && buckets[x] % 2 != 0)\\n//                return x;\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450031,
                "title": "two-appraoches-heapq-and-sorting",
                "content": "# Heap  Approach : TC : (NLogN)\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        list1=[-x for x in stones]\\n        while len(list1)>1:\\n            heapq.heapify(list1)\\n            a,b=heapq.heappop(list1),heapq.heappop(list1)\\n            heapq.heappush(list1,-(abs(a-b)))\\n        return abs(list1[0])\\n```\\n# Sorting Approach ,TC:---->N*(N*LogN)\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones)>1:\\n            stones.sort()\\n            a,b=stones.pop(),stones.pop()\\n            stones.append(abs(a-b))\\n        return stones[0]\\n````\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        list1=[-x for x in stones]\\n        while len(list1)>1:\\n            heapq.heapify(list1)\\n            a,b=heapq.heappop(list1),heapq.heappop(list1)\\n            heapq.heappush(list1,-(abs(a-b)))\\n        return abs(list1[0])\\n```\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones)>1:\\n            stones.sort()\\n            a,b=stones.pop(),stones.pop()\\n            stones.append(abs(a-b))\\n        return stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449192,
                "title": "100-beats-easy-c-solution-just-see-for-yourself",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort in descending order and going through the first two elements and repeating the process.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple. Follow the following steps to understand the approach.\\n\\n1)Sort the stones vector in descending order.\\n2)store the difference of first two numbers(stones[0] and stones[1]) in res.\\n3)If res is 0 then remove stones[0] and stones[1]. If res is not equal to zero which is a positve integer, then remove the front element in the vector and replace the res value with front element in the vector. (Since we need to remove 1st two elements and push the positve integer, instead of that am removing one element and replacing the other).\\n4)Repeat the steps until stones vector is having atleast 2 elements.\\n5)If there is an element in the stones vector, then that is our answer else return 0.\\n\\n# Complexity\\n- Time complexity: O(N*NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(), stones.end(), greater<int>());\\n        int i = 0;\\n        while (i<stones.size() && (i+1)<stones.size()){\\n            int res = stones[i] - stones[i+1];\\n            if (res != 0){\\n                stones.erase(stones.begin());\\n                stones[0] = res;\\n                sort(stones.begin(), stones.end(), greater<int>());\\n            }\\n            else{\\n                stones.erase(stones.begin(), stones.begin()+2);\\n            }\\n        }\\n        if (stones.size()){\\n            return stones[0];\\n        }\\n        return 0;\\n    }\\n};\\n\\n//                         (sorted)         (updated vector)\\n//[2, 7, 4, 1, 8, 1] = [8, 7, 4, 2, 1, 1] -> [1, 4, 2, 1, 1] = [4, 2, 1, 1, 1] ->\\n// [2, 1, 1, 1] -> [1, 1, 1] -> \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(), stones.end(), greater<int>());\\n        int i = 0;\\n        while (i<stones.size() && (i+1)<stones.size()){\\n            int res = stones[i] - stones[i+1];\\n            if (res != 0){\\n                stones.erase(stones.begin());\\n                stones[0] = res;\\n                sort(stones.begin(), stones.end(), greater<int>());\\n            }\\n            else{\\n                stones.erase(stones.begin(), stones.begin()+2);\\n            }\\n        }\\n        if (stones.size()){\\n            return stones[0];\\n        }\\n        return 0;\\n    }\\n};\\n\\n//                         (sorted)         (updated vector)\\n//[2, 7, 4, 1, 8, 1] = [8, 7, 4, 2, 1, 1] -> [1, 4, 2, 1, 1] = [4, 2, 1, 1, 1] ->\\n// [2, 1, 1, 1] -> [1, 1, 1] -> \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448759,
                "title": "easy-java-soluton-using-priorityqueue-with-explanation-intuition",
                "content": "# PLEASE UPVOTE\\n\\n![Screenshot 2023-04-24 at 06.29.54.png](https://assets.leetcode.com/users/images/877f6529-7103-45dc-a713-d2c71c40566d_1682298023.9539728.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Priority Queue to sort at every operation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Inserting the whole array to Priorty Queue,\\n2. Popping the first two elements from the pq (MAX and second MAX),\\n3. adding the difference back to pq,\\n4. repeating 2 & 3.\\n5. return max when loop completes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n*sorting at every input and operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<stones.length;i++){\\n            pq.add(stones[i]);\\n        }\\n        int p,q;\\n        while(pq.size()>1){\\n            p=pq.poll();\\n            q=pq.poll();\\n            // System.out.println(\\xF7p+\" \"+q);\\n            pq.add(p-q);\\n        }\\n        return pq.poll();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<stones.length;i++){\\n            pq.add(stones[i]);\\n        }\\n        int p,q;\\n        while(pq.size()>1){\\n            p=pq.poll();\\n            q=pq.poll();\\n            // System.out.println(\\xF7p+\" \"+q);\\n            pq.add(p-q);\\n        }\\n        return pq.poll();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314775,
                "title": "c-priorityqueue-net6",
                "content": "Use c# PriorityQueue\\n\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        PriorityQueue<int, int> queue = new();\\n        foreach(int s in stones)\\n        {\\n            queue.Enqueue(s,-s);\\n        }\\n        while(queue.Count >1)\\n        {\\n            int stone1 = queue.Dequeue();\\n            int stone2 = queue.Dequeue();\\n            if(stone1 != stone2)\\n            {\\n                int newStone = stone1 - stone2;\\n                newStone = newStone > 0 ? newStone : newStone * -1;\\n                queue.Enqueue(newStone, -newStone);\\n            }\\n        }\\n        if(queue.Count ==0)\\n        {\\n            return 0;\\n        }\\n        return queue.Dequeue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        PriorityQueue<int, int> queue = new();\\n        foreach(int s in stones)\\n        {\\n            queue.Enqueue(s,-s);\\n        }\\n        while(queue.Count >1)\\n        {\\n            int stone1 = queue.Dequeue();\\n            int stone2 = queue.Dequeue();\\n            if(stone1 != stone2)\\n            {\\n                int newStone = stone1 - stone2;\\n                newStone = newStone > 0 ? newStone : newStone * -1;\\n                queue.Enqueue(newStone, -newStone);\\n            }\\n        }\\n        if(queue.Count ==0)\\n        {\\n            return 0;\\n        }\\n        return queue.Dequeue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661271,
                "title": "c-88",
                "content": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> stoneList = new List<int>(stones);\\n        return stoneHelper(stoneList);\\n    }\\n    \\n    public int stoneHelper(List<int> stones) {\\n        \\n        if(stones.Count == 0 )\\n            return 0;\\n        else if (stones.Count == 1)\\n            return stones[0];\\n        else  {\\n            int max = stones.Max();\\n            stones.Remove(max);\\n            \\n            int sMax = stones.Max();\\n            stones.Remove(sMax);\\n\\n            if (sMax < max) {\\n                stones.Add(max-sMax);\\n            }\\n            return stoneHelper(stones); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> stoneList = new List<int>(stones);\\n        return stoneHelper(stoneList);\\n    }\\n    \\n    public int stoneHelper(List<int> stones) {\\n        \\n        if(stones.Count == 0 )\\n            return 0;\\n        else if (stones.Count == 1)\\n            return stones[0];\\n        else  {\\n            int max = stones.Max();\\n            stones.Remove(max);\\n            \\n            int sMax = stones.Max();\\n            stones.Remove(sMax);\\n\\n            if (sMax < max) {\\n                stones.Add(max-sMax);\\n            }\\n            return stoneHelper(stones); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518940,
                "title": "javascript-priority-queue-solution-o-n",
                "content": "```javascript\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n  const heap = new MaxHeap(stones);\\n  while (heap.size() > 1) {\\n    const max1 = heap.poll();\\n    const max2 = heap.poll();\\n    if (max1 > max2) heap.offer(max1 - max2);\\n  }\\n  return heap.size() === 1 ? heap.poll() : 0;\\n};\\n\\nclass MaxHeap {\\n  constructor(data = []) {\\n    this.data = data;\\n    this.comparator = (a, b) => b - a;\\n    this.heapify();\\n  }\\n\\n  // O(nlog(n)). In fact, O(n)\\n  heapify() {\\n    if (this.size() < 2) return;\\n    for (let i = 1; i < this.size(); i++) {\\n      this.bubbleUp(i);\\n    }\\n  }\\n\\n  // O(1)\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  // O(log(n))\\n  offer(value) {\\n    this.data.push(value);\\n    this.bubbleUp(this.size() - 1);\\n  }\\n\\n  // O(log(n))\\n  poll() {\\n    if (this.size() === 0) return null;\\n    const result = this.data[0];\\n    const last = this.data.pop();\\n    if (this.size() !== 0) {\\n      this.data[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return result;\\n  }\\n\\n  // O(log(n))\\n  bubbleUp(index) {\\n    while (index > 0) {\\n      const parentIndex = (index - 1) >> 1;\\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(log(n))\\n  bubbleDown(index) {\\n    const lastIndex = this.size() - 1;\\n    while (true) {\\n      const leftIndex = index * 2 + 1;\\n      const rightIndex = index * 2 + 2;\\n      let findIndex = index;\\n      if (\\n        leftIndex <= lastIndex &&\\n        this.comparator(this.data[leftIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = leftIndex;\\n      }\\n      if (\\n        rightIndex <= lastIndex &&\\n        this.comparator(this.data[rightIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = rightIndex;\\n      }\\n      if (index !== findIndex) {\\n        this.swap(index, findIndex);\\n        index = findIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(1)\\n  swap(index1, index2) {\\n    [this.data[index1], this.data[index2]] = [\\n      this.data[index2],\\n      this.data[index1]\\n    ];\\n  }\\n\\n  // O(1)\\n  size() {\\n    return this.data.length;\\n  }\\n}\\n```\\n\\n* 70/70 cases passed (56 ms)\\n* Your runtime beats 84.25 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n  const heap = new MaxHeap(stones);\\n  while (heap.size() > 1) {\\n    const max1 = heap.poll();\\n    const max2 = heap.poll();\\n    if (max1 > max2) heap.offer(max1 - max2);\\n  }\\n  return heap.size() === 1 ? heap.poll() : 0;\\n};\\n\\nclass MaxHeap {\\n  constructor(data = []) {\\n    this.data = data;\\n    this.comparator = (a, b) => b - a;\\n    this.heapify();\\n  }\\n\\n  // O(nlog(n)). In fact, O(n)\\n  heapify() {\\n    if (this.size() < 2) return;\\n    for (let i = 1; i < this.size(); i++) {\\n      this.bubbleUp(i);\\n    }\\n  }\\n\\n  // O(1)\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  // O(log(n))\\n  offer(value) {\\n    this.data.push(value);\\n    this.bubbleUp(this.size() - 1);\\n  }\\n\\n  // O(log(n))\\n  poll() {\\n    if (this.size() === 0) return null;\\n    const result = this.data[0];\\n    const last = this.data.pop();\\n    if (this.size() !== 0) {\\n      this.data[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return result;\\n  }\\n\\n  // O(log(n))\\n  bubbleUp(index) {\\n    while (index > 0) {\\n      const parentIndex = (index - 1) >> 1;\\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(log(n))\\n  bubbleDown(index) {\\n    const lastIndex = this.size() - 1;\\n    while (true) {\\n      const leftIndex = index * 2 + 1;\\n      const rightIndex = index * 2 + 2;\\n      let findIndex = index;\\n      if (\\n        leftIndex <= lastIndex &&\\n        this.comparator(this.data[leftIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = leftIndex;\\n      }\\n      if (\\n        rightIndex <= lastIndex &&\\n        this.comparator(this.data[rightIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = rightIndex;\\n      }\\n      if (index !== findIndex) {\\n        this.swap(index, findIndex);\\n        index = findIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(1)\\n  swap(index1, index2) {\\n    [this.data[index1], this.data[index2]] = [\\n      this.data[index2],\\n      this.data[index1]\\n    ];\\n  }\\n\\n  // O(1)\\n  size() {\\n    return this.data.length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494982,
                "title": "rust-binary-heap",
                "content": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        while let Some(stone) = heap.pop() {\\n            match heap.pop() {\\n                Some(val)   => heap.push(stone - val),\\n                None        => return stone,\\n            }       \\n        }\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        while let Some(stone) = heap.pop() {\\n            match heap.pop() {\\n                Some(val)   => heap.push(stone - val),\\n                None        => return stone,\\n            }       \\n        }\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3036497,
                "title": "java-don-t-worry-my-solution-is-best-100-92-39-6-mb",
                "content": "\\t*   class Solution {\\n\\t\\t\\tpublic  int lastStoneWeight(int[] stones) {\\n\\t\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tfor (int a : stones) {\\n\\t\\t\\t\\t\\tlist.add(a);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tCollections.sort(list);\\n\\t\\t\\t\\twhile (list.size() > 1) {\\n\\t\\t\\t\\t\\tint a = list.size();\\n\\t\\t\\t\\t\\tif (list.get(a - 1) > list.get(a - 2)) {\\n\\t\\t\\t\\t\\t\\tlist.add(( list.get(a - 1) -list.get(a - 2)));\\n\\t\\t\\t\\t\\t\\tlist.remove(a-2);\\n\\t\\t\\t\\t\\t\\tlist.remove(a-2);\\n\\t\\t\\t\\t\\t\\tCollections.sort(list);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tlist.remove(a - 1);\\n\\t\\t\\t\\t\\t\\tlist.remove(a -2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (list.size()==1){\\n\\t\\t\\t\\t\\treturn list.get(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic  int lastStoneWeight(int[] stones) {\\n\\t\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tfor (int a : stones) {\\n\\t\\t\\t\\t\\tlist.add(a);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2825881,
                "title": "java-runtime-1ms-faster-than-99-49-queue-and-iterative-solutions",
                "content": "PriorityQueue solution:\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Queue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int i : stones) queue.offer(i);\\n\\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int next = queue.poll();\\n            if (first != next) {\\n                queue.offer(first - next);\\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n}\\n```\\n\\nWithout extra space solution:\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if (stones.length == 1) return stones[0];\\n        Arrays.sort(stones);\\n        int last = stones.length - 1;\\n        int prev = stones.length - 2;\\n        while (stones[last] != 0) {\\n            if (stones[prev] == 0) return stones[last];\\n            stones[last] = stones[last] - stones[prev];\\n            stones[prev] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c808e6a5-e57b-427e-98eb-31b4ffa029bb_1668743243.4978485.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Queue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int i : stones) queue.offer(i);\\n\\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int next = queue.poll();\\n            if (first != next) {\\n                queue.offer(first - next);\\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if (stones.length == 1) return stones[0];\\n        Arrays.sort(stones);\\n        int last = stones.length - 1;\\n        int prev = stones.length - 2;\\n        while (stones[last] != 0) {\\n            if (stones[prev] == 0) return stones[last];\\n            stones[last] = stones[last] - stones[prev];\\n            stones[prev] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596771,
                "title": "c-easy-priority-queue-solution-100-time",
                "content": "```\\nint lastStoneWeight(vector<int>& stones) {\\n\\n\\tpriority_queue<int>pq;\\n\\tfor(auto x: stones)\\n\\t{\\n\\t\\tpq.push(x);\\n\\t}\\n\\n\\twhile(!p.empty())\\n\\t{\\n\\t\\tint y = pq.top();\\n\\t\\tif(pq.size()==1)return y;\\n\\t\\tpq.pop();\\n\\t\\tint rem = abs(y - pq.top());\\n\\t\\tpq.pop();\\n\\t\\tpq.push(rem);\\n\\n        }\\n        return 0;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n\\n\\tpriority_queue<int>pq;\\n\\tfor(auto x: stones)\\n\\t{\\n\\t\\tpq.push(x);\\n\\t}\\n\\n\\twhile(!p.empty())\\n\\t{\\n\\t\\tint y = pq.top();\\n\\t\\tif(pq.size()==1)return y;\\n\\t\\tpq.pop();\\n\\t\\tint rem = abs(y - pq.top());\\n\\t\\tpq.pop();\\n\\t\\tpq.push(rem);\\n\\n        }\\n        return 0;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524599,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut h = BinaryHeap::from(stones);\\n        while h.len() > 1 {\\n            let s1 = h.pop().unwrap();\\n            let s2 = h.pop().unwrap();\\n            h.push(s1 - s2)\\n        }\\n        h.pop().unwrap_or(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut h = BinaryHeap::from(stones);\\n        while h.len() > 1 {\\n            let s1 = h.pop().unwrap();\\n            let s2 = h.pop().unwrap();\\n            h.push(s1 - s2)\\n        }\\n        h.pop().unwrap_or(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833091,
                "title": "python-heapq",
                "content": "```\\n\"\"\"\\nChoose two heaviest stones and smash them together\\n\\nx==y: destroyed\\nx != y, new weight is difference, return weight of stome\\n\\nApproach:\\nuse max heap, get difference\\n\"\"\"\\nimport heapq\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-x for x in stones]\\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            stone1 = -(heapq.heappop(stones))\\n            stone2 = -(heapq.heappop(stones))\\n            \\n            if stone1 == stone2: continue\\n            heapq.heappush(stones,-(abs(stone1-stone2)))\\n            \\n        if len(stones) == 0: return 0\\n        return -(heapq.heappop(stones))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\"\"\"\\nChoose two heaviest stones and smash them together\\n\\nx==y: destroyed\\nx != y, new weight is difference, return weight of stome\\n\\nApproach:\\nuse max heap, get difference\\n\"\"\"\\nimport heapq\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-x for x in stones]\\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            stone1 = -(heapq.heappop(stones))\\n            stone2 = -(heapq.heappop(stones))\\n            \\n            if stone1 == stone2: continue\\n            heapq.heappush(stones,-(abs(stone1-stone2)))\\n            \\n        if len(stones) == 0: return 0\\n        return -(heapq.heappop(stones))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488945,
                "title": "c-vector-100-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1){\\n            sort(stones.begin(),stones.end(),greater<int>());\\n            if(stones[0] == stones[1])\\n                stones.erase(stones.begin(),stones.begin()+2);\\n            else{\\n                stones.push_back(abs(stones[0] - stones[1]));\\n                stones.erase(stones.begin(),stones.begin()+2);         \\n            }\\n        }\\n        if(!stones.empty())\\n            return stones[0];\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1){\\n            sort(stones.begin(),stones.end(),greater<int>());\\n            if(stones[0] == stones[1])\\n                stones.erase(stones.begin(),stones.begin()+2);\\n            else{\\n                stones.push_back(abs(stones[0] - stones[1]));\\n                stones.erase(stones.begin(),stones.begin()+2);         \\n            }\\n        }\\n        if(!stones.empty())\\n            return stones[0];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649893,
                "title": "c-easy-short-faster-than-100-priority-queue",
                "content": "![image](https://assets.leetcode.com/users/images/e3870a6c-2992-4394-80e6-0251c9344bc1_1664696002.4909544.png)\\n\\n**T->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint lastStoneWeight(vector<int>& st) {\\n\\t\\t\\t\\tint n=st.size();\\n\\t\\t\\t\\tpriority_queue<int>q;\\n\\t\\t\\t\\tfor(auto i: st) q.push(i);\\n\\t\\t\\t\\twhile(q.size()!=1){\\n\\t\\t\\t\\t\\tint x=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tint y=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tq.push(max(x,y)-min(x,y));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn q.top();\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint lastStoneWeight(vector<int>& st) {\\n\\t\\t\\t\\tint n=st.size();\\n\\t\\t\\t\\tpriority_queue<int>q;\\n\\t\\t\\t\\tfor(auto i: st) q.push(i);\\n\\t\\t\\t\\twhile(q.size()!=1){\\n\\t\\t\\t\\t\\tint x=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tint y=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tq.push(max(x,y)-min(x,y));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1922870,
                "title": "c-naive-solution",
                "content": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(),stones.end());\\n        int a=stones.size()-1;\\n        if(a==0){\\n            return stones[a];\\n        }\\n        for(int i=0;i<stones.size();i++){\\n            sort(stones.begin(),stones.end());\\n            if(stones[a]>0 && stones[a-1]>0){\\n                stones[a]=stones[a]-stones[a-1];\\n                stones[a-1]=0;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return stones[a];\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(),stones.end());\\n        int a=stones.size()-1;\\n        if(a==0){\\n            return stones[a];\\n        }\\n        for(int i=0;i<stones.size();i++){\\n            sort(stones.begin(),stones.end());\\n            if(stones[a]>0 && stones[a-1]>0){\\n                stones[a]=stones[a]-stones[a-1];\\n                stones[a-1]=0;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return stones[a];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922210,
                "title": "java-priority-queue",
                "content": "```\\npublic int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n\\n        while (queue.size() > 1) {\\n            queue.offer(queue.poll() - queue.poll());\\n        }\\n\\n        return queue.isEmpty() ? 0 : queue.peek();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n\\n        while (queue.size() > 1) {\\n            queue.offer(queue.poll() - queue.poll());\\n        }\\n\\n        return queue.isEmpty() ? 0 : queue.peek();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921123,
                "title": "very-easy-code-with-explanation",
                "content": "**step 1  create a priority queue\\nstep 2 Put all elements into a priority queue.\\nstep 3 take two bigest element \\npush the difference into queue until\\ntwo more element left.**\\n\\n**Complexity\\nTime O(NlogN)\\nSpace O(N)**\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& nums) {\\n       priority_queue<int> pq;\\n      for(auto i : nums)      \\n          pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top();\\n          pq.pop();\\n          int b = pq.top(); \\n          pq.pop();\\n       if(a>b)\\n              pq.push(a-b);\\n      }\\n      return pq.empty()?0:pq.top();  \\n        \\n    }\\n};\\n\\nif(ishelpfull)\\n(upvote);\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& nums) {\\n       priority_queue<int> pq;\\n      for(auto i : nums)      \\n          pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top();\\n          pq.pop();\\n          int b = pq.top(); \\n          pq.pop();\\n       if(a>b)\\n              pq.push(a-b);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1921120,
                "title": "last-stone-weight-python-easy-48-ms",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while(len(stones)>1):\\n            p = max(stones)\\n            pi= stones.index(p)\\n            stones.pop(pi)\\n            q = max(stones)\\n            qi = stones.index(q)\\n            stones.pop(qi)\\n            stones.append(p-q)\\n        return stones[0]    \\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while(len(stones)>1):\\n            p = max(stones)\\n            pi= stones.index(p)\\n            stones.pop(pi)\\n            q = max(stones)\\n            qi = stones.index(q)\\n            stones.pop(qi)\\n            stones.append(p-q)\\n        return stones[0]    \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1378654,
                "title": "java-easy-solution-o-nlogn-time-complexity-priority-queue",
                "content": "The efficient way to retrieve the max from array is to use a max heap, which in Java is a PriorityQueue (min heap) with a reverse comparator.\\n\\n Follow 4 Easy steps-\\n**Step1** : Create a max priority queue.\\n**Step2** : Add all the elements to queue.\\n**Step3** : Remove two max element at a time, find the difference and then add into the queue.\\n**Step4** : Check if queue is empty return 0, else return the element\\n\\n\\n```\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        // Create a max priority queue         \\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        // Add all the elements to queue        \\n        for(int i : stones) {\\n        \\tqueue.add(i);\\n        }\\n        \\n        // Remove two max element at a time, find the difference and then add into the queue         \\n        while(queue.size() > 1) {\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            int num = num1 - num2;\\n            queue.add(num);\\n        }\\n        \\n        // Check if queue is empty return 0, else return the element         \\n        if(queue.isEmpty()) {\\n        \\treturn 0;\\n        }\\n        return queue.poll();\\n    }\\n```\\n\\nTime Complexity - ```o(nlogn)```\\nSpace Complexity - ```o(n)```",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        // Create a max priority queue         \\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        // Add all the elements to queue        \\n        for(int i : stones) {\\n        \\tqueue.add(i);\\n        }\\n        \\n        // Remove two max element at a time, find the difference and then add into the queue         \\n        while(queue.size() > 1) {\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            int num = num1 - num2;\\n            queue.add(num);\\n        }\\n        \\n        // Check if queue is empty return 0, else return the element         \\n        if(queue.isEmpty()) {\\n        \\treturn 0;\\n        }\\n        return queue.poll();\\n    }\\n```\n```o(nlogn)```\n```o(n)```",
                "codeTag": "Unknown"
            },
            {
                "id": 594316,
                "title": "javascript-99-time",
                "content": "It\\'s not optimal but it\\'s efficient without using a priority queue. Just array manipulation \\n\\n```/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    let size = stones.length;\\n     \\n    while(size >= 2){\\n        stones.sort((a,b)=> { return a-b })\\n        \\n        x = stones.pop(); \\n        y = stones.pop();\\n        \\n        if(x == y){\\n            size -= 2;\\n        }else{\\n            size -= 1; \\n            stones.unshift(x - y); \\n        }\\n    }\\n    \\n    return stones;\\n};\\n",
                "solutionTags": [],
                "code": "It\\'s not optimal but it\\'s efficient without using a priority queue. Just array manipulation \\n\\n```/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    let size = stones.length;\\n     \\n    while(size >= 2){\\n        stones.sort((a,b)=> { return a-b })\\n        \\n        x = stones.pop(); \\n        y = stones.pop();\\n        \\n        if(x == y){\\n            size -= 2;\\n        }else{\\n            size -= 1; \\n            stones.unshift(x - y); \\n        }\\n    }\\n    \\n    return stones;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 575384,
                "title": "c-solution-with-explanation",
                "content": "**Priority Queue Implementation**\\n* Make  a priority queue(binary max heap) which automatically arrange the element in sorted order.\\n* Then pick the first element (which is maximum) and 2nd element(2nd max) , if both are equal  we dont have to push anything , if not equal push difference of both in queue.\\n* Do the above steps till queue size is equal to 1, then return last element. If queue becomes empty before reaching size==1 then return 0.\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            pq.push(stones[i]);\\n        }\\n        int m1,m2;\\n        while(!pq.empty())\\n        {\\n            if(pq.size()==1)\\n                return pq.top();\\n            m1=pq.top();\\n            pq.pop();\\n            m2=pq.top();\\n            pq.pop();\\n            \\n            if(m1!=m2)\\n                pq.push(m1-m2);\\n        }\\n            return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            pq.push(stones[i]);\\n        }\\n        int m1,m2;\\n        while(!pq.empty())\\n        {\\n            if(pq.size()==1)\\n                return pq.top();\\n            m1=pq.top();\\n            pq.pop();\\n            m2=pq.top();\\n            pq.pop();\\n            \\n            if(m1!=m2)\\n                pq.push(m1-m2);\\n        }\\n            return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549801,
                "title": "golang-using-container-heap",
                "content": "```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\nfunc lastStoneWeight(stones []int) int {\\n\\tpq := IntHeap(stones)\\n\\theap.Init(&pq)\\n\\tfor pq.Len() > 1 {\\n\\t\\theap.Push(&pq, heap.Pop(&pq).(int)-heap.Pop(&pq).(int))\\n\\n\\t}\\n\\treturn heap.Pop(&pq).(int)\\n}\\n\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\nfunc lastStoneWeight(stones []int) int {\\n\\tpq := IntHeap(stones)\\n\\theap.Init(&pq)\\n\\tfor pq.Len() > 1 {\\n\\t\\theap.Push(&pq, heap.Pop(&pq).(int)-heap.Pop(&pq).(int))\\n\\n\\t}\\n\\treturn heap.Pop(&pq).(int)\\n}\\n\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 467505,
                "title": "python-very-simple-solution-95-fast",
                "content": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        while len(stones) > 1:\\n            stones.sort()\\n            x, y = stones[-2], stones[-1]\\n            stones = stones[:-2]\\n       \\n            if x != y:\\n                stones.append(y - x)\\n                \\n        return stones[0] if stones else 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        while len(stones) > 1:\\n            stones.sort()\\n            x, y = stones[-2], stones[-1]\\n            stones = stones[:-2]\\n       \\n            if x != y:\\n                stones.append(y - x)\\n                \\n        return stones[0] if stones else 0",
                "codeTag": "Java"
            },
            {
                "id": 437380,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\t\\t\\tstones.sort()\\n\\t\\t\\twhile len(stones)>1:\\n\\t\\t\\t\\tt = stones.pop()\\n\\t\\t\\t\\tu = stones.pop()\\n\\t\\t\\t\\tif t==u:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.append(t-u)\\n\\t\\t\\t\\t\\tstones.sort()\\n\\t\\t\\treturn stones[0] if stones else 0\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\t\\t\\tstones.sort()\\n\\t\\t\\twhile len(stones)>1:\\n\\t\\t\\t\\tt = stones.pop()\\n\\t\\t\\t\\tu = stones.pop()\\n\\t\\t\\t\\tif t==u:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.append(t-u)\\n\\t\\t\\t\\t\\tstones.sort()\\n\\t\\t\\treturn stones[0] if stones else 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 3449828,
                "title": "better-than-100-in-runtime-simple-c-approach",
                "content": "# Approach\\nAlright, in this I am using Priority Queue. In this first I am adding all elements of the vector \"stones\" in the priority queue called \"pq\". Now I am initializing a while loop, setting the condition that, the size of \"pq\" must be greater than 1. I am simply checking the top 2 elements and doing the required manipulations in the question. In the end, if size of \"pq\" is 0, return 0; else we should return the top element of the same.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n=stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(stones[i]);\\n        }    \\n        while(pq.size()>1)\\n        {\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            if(a!=b)\\n            {\\n                int c=a-b;\\n                pq.push(c);\\n            }\\n        }\\n        if(pq.size()==0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int l=pq.top();\\n            return l;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n=stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(stones[i]);\\n        }    \\n        while(pq.size()>1)\\n        {\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            if(a!=b)\\n            {\\n                int c=a-b;\\n                pq.push(c);\\n            }\\n        }\\n        if(pq.size()==0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int l=pq.top();\\n            return l;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449596,
                "title": "java-easy-solution-lbeginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //creating a heap to store elements in descending order\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i = 0 ; i < stones.length; i ++){\\n            q.add(stones[i]);\\n        }\\n        while(q.size() > 1){\\n            int x = q.poll();\\n            int y = q.poll();\\n            if(x == y){\\n                continue;\\n            }else{\\n                q.add(Math.abs(y - x));\\n            }\\n        }\\n        if(q.size() == 1){\\n            return q.poll();\\n        }\\n        return 0;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //creating a heap to store elements in descending order\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i = 0 ; i < stones.length; i ++){\\n            q.add(stones[i]);\\n        }\\n        while(q.size() > 1){\\n            int x = q.poll();\\n            int y = q.poll();\\n            if(x == y){\\n                continue;\\n            }else{\\n                q.add(Math.abs(y - x));\\n            }\\n        }\\n        if(q.size() == 1){\\n            return q.poll();\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448701,
                "title": "easy-java-solution-using-maxheap-beginner-friendly",
                "content": "# Intuition\\nNeed to maitain a DS to get top-2 stone, PriorityQueue is best for this\\n\\n# Approach\\n1. Push all elments in prioriyQueue as MaxHeap.\\n2. Pick top 2 elements form maxHeap, if there is only one element left then that is answer.\\n3. If both element are same, no action needed and continue the process.\\n4. If both element are different, push the differece again.\\n5. Answer will be if only one stone is left or no stone is left, **In case of only one stone is left, that is the answer, if no stoner are left, 0 is the answer.**\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((stone1, stone2) -> stone2 - stone1);\\n\\n        for(int stone: stones) {\\n            maxHeap.add(stone);\\n        }\\n\\n        while(!maxHeap.isEmpty()) {\\n            // take haviest stone\\n            int y = maxHeap.poll();\\n            if(maxHeap.isEmpty()) {\\n                // if the was only one stone left, so that is answer\\n                return y;\\n            } else {\\n                // take second haviest stone\\n                int x = maxHeap.poll();\\n                // if both are no equal then push the difference, no action needed for equal\\n                if(x != y) {\\n                    maxHeap.add(y - x);\\n                }\\n            }\\n        }\\n\\n        // if no stone left in heap\\n        return 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((stone1, stone2) -> stone2 - stone1);\\n\\n        for(int stone: stones) {\\n            maxHeap.add(stone);\\n        }\\n\\n        while(!maxHeap.isEmpty()) {\\n            // take haviest stone\\n            int y = maxHeap.poll();\\n            if(maxHeap.isEmpty()) {\\n                // if the was only one stone left, so that is answer\\n                return y;\\n            } else {\\n                // take second haviest stone\\n                int x = maxHeap.poll();\\n                // if both are no equal then push the difference, no action needed for equal\\n                if(x != y) {\\n                    maxHeap.add(y - x);\\n                }\\n            }\\n        }\\n\\n        // if no stone left in heap\\n        return 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448681,
                "title": "daily-leetcoding-challenge-april-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3425201,
                "title": "c-simple-solution-with-priorityqueue",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n\\n        var heap = new PriorityQueue<int, int>();\\n        \\n        foreach (var stone in stones)\\n            heap.Enqueue(stone, 0 - stone);\\n\\n        while (heap.Count > 1)\\n        {\\n            var newStone = heap.Dequeue() - heap.Dequeue();\\n            if (newStone > 0)\\n                heap.Enqueue(newStone, 0 - newStone);\\n        }\\n        \\n        return heap.Count > 0 ? heap.Dequeue() : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n\\n        var heap = new PriorityQueue<int, int>();\\n        \\n        foreach (var stone in stones)\\n            heap.Enqueue(stone, 0 - stone);\\n\\n        while (heap.Count > 1)\\n        {\\n            var newStone = heap.Dequeue() - heap.Dequeue();\\n            if (newStone > 0)\\n                heap.Enqueue(newStone, 0 - newStone);\\n        }\\n        \\n        return heap.Count > 0 ? heap.Dequeue() : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375538,
                "title": "java-heap-fight-of-the-stones",
                "content": "\\n```\\nclass Heap\\n{\\n    int [] heap;\\n    int size;\\n    Heap(int[] stones)\\n    {\\n        heap = new int[stones.length];\\n        size = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            addStone(stones[i]);\\n    }\\n    public int removeMax() //size--\\n    {\\n        int answ = heap[0];\\n        if (size > 0) {\\n            heap[0] = heap[size - 1];\\n            size--;\\n        }\\n        siftDown();\\n        return answ;\\n    }\\n    public void addStone(int stone) //size++\\n    {\\n        size++;\\n        heap[size - 1] = stone;\\n        siftUp();\\n    }\\n\\n    public int[] changePlace(int child, int[] start)\\n    {\\n        int tmp;\\n\\n        tmp = heap[child];\\n        heap[child] = heap[start[0]];\\n        heap[start[0]] = tmp;\\n        start[0] = child;\\n        return new int[]{getLeftChild(start[0]), getRightChild(start[0])};\\n    }\\n\\n    public void siftDown()\\n    {\\n        int []start = new int[]{0};\\n        int []leftAndRight = new int[2];\\n        leftAndRight[0] = getLeftChild(start[0]);\\n        leftAndRight[1] = getRightChild(start[0]);\\n        int tmp;\\n        while (true)\\n        {\\n            if (leftAndRight[0] < size && leftAndRight[1] < size)\\n            {\\n                if(heap[leftAndRight[0]] >= heap[leftAndRight[1]] && heap[start[0]] <= heap[leftAndRight[0]])\\n                    leftAndRight = changePlace(leftAndRight[0], start);\\n                else if(heap[leftAndRight[1]] > heap[leftAndRight[0]] && heap[start[0]] <= heap[leftAndRight[1]])\\n                    leftAndRight = changePlace(leftAndRight[1], start);\\n                else\\n                    break;\\n            }\\n            else if (leftAndRight[0] < size && heap[start[0]] <= heap[leftAndRight[0]])\\n                leftAndRight = changePlace(leftAndRight[0], start);\\n            else if (leftAndRight[1] < size && heap[start[0]] <= heap[leftAndRight[1]])\\n                leftAndRight = changePlace(leftAndRight[1], start);\\n            else\\n                break;\\n        }\\n    }\\n\\n    public void siftUp()\\n    {\\n        int child = size - 1;\\n        int parent = getParent(child);\\n        int tmp;\\n        while (parent > -1 && heap[parent] < heap[child])\\n        {\\n            tmp = heap[child];\\n            heap[child] = heap[parent];\\n            heap[parent] = tmp;\\n            child = parent;\\n            parent = getParent(child);\\n        }\\n    }\\n\\n    public int getParent(int child)\\n    {\\n        return (child - 1) / 2;\\n    }\\n\\n    public int getLeftChild(int parent)\\n    {\\n        return parent * 2 + 1;\\n    }\\n\\n    public int getRightChild(int parent)\\n    {\\n        return parent * 2 + 2;\\n    }\\n}\\n\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Heap heap = new Heap(stones);\\n        int diff;\\n        while (heap.size > 1)\\n        {\\n            diff = Math.abs(heap.removeMax() - heap.removeMax());\\n            if (diff != 0)\\n                heap.addStone(diff);\\n        }\\n        if (heap.size > 0)\\n            return heap.removeMax();\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Heap\\n{\\n    int [] heap;\\n    int size;\\n    Heap(int[] stones)\\n    {\\n        heap = new int[stones.length];\\n        size = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            addStone(stones[i]);\\n    }\\n    public int removeMax() //size--\\n    {\\n        int answ = heap[0];\\n        if (size > 0) {\\n            heap[0] = heap[size - 1];\\n            size--;\\n        }\\n        siftDown();\\n        return answ;\\n    }\\n    public void addStone(int stone) //size++\\n    {\\n        size++;\\n        heap[size - 1] = stone;\\n        siftUp();\\n    }\\n\\n    public int[] changePlace(int child, int[] start)\\n    {\\n        int tmp;\\n\\n        tmp = heap[child];\\n        heap[child] = heap[start[0]];\\n        heap[start[0]] = tmp;\\n        start[0] = child;\\n        return new int[]{getLeftChild(start[0]), getRightChild(start[0])};\\n    }\\n\\n    public void siftDown()\\n    {\\n        int []start = new int[]{0};\\n        int []leftAndRight = new int[2];\\n        leftAndRight[0] = getLeftChild(start[0]);\\n        leftAndRight[1] = getRightChild(start[0]);\\n        int tmp;\\n        while (true)\\n        {\\n            if (leftAndRight[0] < size && leftAndRight[1] < size)\\n            {\\n                if(heap[leftAndRight[0]] >= heap[leftAndRight[1]] && heap[start[0]] <= heap[leftAndRight[0]])\\n                    leftAndRight = changePlace(leftAndRight[0], start);\\n                else if(heap[leftAndRight[1]] > heap[leftAndRight[0]] && heap[start[0]] <= heap[leftAndRight[1]])\\n                    leftAndRight = changePlace(leftAndRight[1], start);\\n                else\\n                    break;\\n            }\\n            else if (leftAndRight[0] < size && heap[start[0]] <= heap[leftAndRight[0]])\\n                leftAndRight = changePlace(leftAndRight[0], start);\\n            else if (leftAndRight[1] < size && heap[start[0]] <= heap[leftAndRight[1]])\\n                leftAndRight = changePlace(leftAndRight[1], start);\\n            else\\n                break;\\n        }\\n    }\\n\\n    public void siftUp()\\n    {\\n        int child = size - 1;\\n        int parent = getParent(child);\\n        int tmp;\\n        while (parent > -1 && heap[parent] < heap[child])\\n        {\\n            tmp = heap[child];\\n            heap[child] = heap[parent];\\n            heap[parent] = tmp;\\n            child = parent;\\n            parent = getParent(child);\\n        }\\n    }\\n\\n    public int getParent(int child)\\n    {\\n        return (child - 1) / 2;\\n    }\\n\\n    public int getLeftChild(int parent)\\n    {\\n        return parent * 2 + 1;\\n    }\\n\\n    public int getRightChild(int parent)\\n    {\\n        return parent * 2 + 2;\\n    }\\n}\\n\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Heap heap = new Heap(stones);\\n        int diff;\\n        while (heap.size > 1)\\n        {\\n            diff = Math.abs(heap.removeMax() - heap.removeMax());\\n            if (diff != 0)\\n                heap.addStone(diff);\\n        }\\n        if (heap.size > 0)\\n            return heap.removeMax();\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224561,
                "title": "using-heap-1ms-java-beat",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:stones)\\n            pq.add(i);\\n\\n        int x;\\n        int y;\\n\\n        while(pq.size()>1){\\n\\n             x=pq.poll();\\n             y=pq.poll();\\n\\n            if(x>y)\\n                pq.add(x-y);\\n\\n            }\\n            \\n        return pq.isEmpty()?0:pq.poll();\\n    }\\n}\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/1296130b-2e6f-4f1a-b8dc-344f9b151589_1677230001.423075.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:stones)\\n            pq.add(i);\\n\\n        int x;\\n        int y;\\n\\n        while(pq.size()>1){\\n\\n             x=pq.poll();\\n             y=pq.poll();\\n\\n            if(x>y)\\n                pq.add(x-y);\\n\\n            }\\n            \\n        return pq.isEmpty()?0:pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188840,
                "title": "golang-maxheap",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc lastStoneWeight(stones []int) int {\\n    maxHeap := &MaxHeap{}\\n\\n    for _, stone := range stones {\\n        heap.Push(maxHeap, stone)\\n    }\\n\\n    for maxHeap.Len() > 1 {\\n        stone1 := heap.Pop(maxHeap).(int)\\n        stone2 := heap.Pop(maxHeap).(int)\\n\\n        if stone1 != stone2 {\\n            heap.Push(maxHeap, stone1 - stone2)\\n        }\\n    }\\n\\n    res := 0\\n    if maxHeap.Len() == 1 {\\n        res = (*maxHeap)[0]\\n    }\\n    return res\\n}\\n\\ntype MaxHeap []int\\n\\nfunc (h MaxHeap) Len() int           { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxHeap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *MaxHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc lastStoneWeight(stones []int) int {\\n    maxHeap := &MaxHeap{}\\n\\n    for _, stone := range stones {\\n        heap.Push(maxHeap, stone)\\n    }\\n\\n    for maxHeap.Len() > 1 {\\n        stone1 := heap.Pop(maxHeap).(int)\\n        stone2 := heap.Pop(maxHeap).(int)\\n\\n        if stone1 != stone2 {\\n            heap.Push(maxHeap, stone1 - stone2)\\n        }\\n    }\\n\\n    res := 0\\n    if maxHeap.Len() == 1 {\\n        res = (*maxHeap)[0]\\n    }\\n    return res\\n}\\n\\ntype MaxHeap []int\\n\\nfunc (h MaxHeap) Len() int           { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxHeap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *MaxHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027670,
                "title": "python-heapq-min-with-negative-values-equivalent-to-heap-max",
                "content": "https://leetcode.com/submissions/detail/875123729/  \\nRuntime: **29 ms**, faster than 94.25% of Python3 online submissions for Last Stone Weight.  \\nMemory Usage: 13.8 MB, less than 61.08% of Python3 online submissions for Last Stone Weight.  \\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = [-s for s in stones]\\n        heapify(s)\\n        while len(s)>1:\\n            heapq.heappush(s, -abs(heappop(s) - heappop(s)))\\n        return -s[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = [-s for s in stones]\\n        heapify(s)\\n        while len(s)>1:\\n            heapq.heappush(s, -abs(heappop(s) - heappop(s)))\\n        return -s[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907947,
                "title": "kotlin-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\n    fun lastStoneWeight(stones: IntArray): Int {\\n        val h = PriorityQueue<Int> { a, b -> b.compareTo(a) }\\n        stones.forEach { h.add(it) }\\n\\n        while (h.size > 1) { \\n            h.add(h.poll() - h.poll())\\n        }\\n \\n        return h.poll()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    fun lastStoneWeight(stones: IntArray): Int {\\n        val h = PriorityQueue<Int> { a, b -> b.compareTo(a) }\\n        stones.forEach { h.add(it) }\\n\\n        while (h.size > 1) { \\n            h.add(h.poll() - h.poll())\\n        }\\n \\n        return h.poll()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168036,
                "title": "javascript-using-maxpriorityqueue",
                "content": "Finally, there\\'s a Max/MinPriorityQueue for JavaScript!\\n\\nadd -> enqueue( )\\nremove -> dequeue( )\\nhighest number (peek) -> front( )\\n.element -> actual value\\n\\n```\\nvar lastStoneWeight = function(stones) {\\n    const m = new MaxPriorityQueue()\\n    for(const w of stones) m.enqueue(w)\\n    \\n    while(m.size() > 1){\\n        const diff = m.dequeue().element - m.dequeue().element\\n        if(diff > 0) m.enqueue(diff)\\n    }\\n \\n    return m.size() === 0 ? 0 : m.front().element\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n    const m = new MaxPriorityQueue()\\n    for(const w of stones) m.enqueue(w)\\n    \\n    while(m.size() > 1){\\n        const diff = m.dequeue().element - m.dequeue().element\\n        if(diff > 0) m.enqueue(diff)\\n    }\\n \\n    return m.size() === 0 ? 0 : m.front().element\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922969,
                "title": "c-solution-with-image-explanation-no-extra-space",
                "content": "![image](https://assets.leetcode.com/users/images/2926ac92-fc16-4e57-ba90-57edfee68604_1649334079.7444394.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1) {\\n            sort(stones.begin(), stones.end());\\n            int n = stones.size();\\n            \\n            if(stones[n - 2] == stones[n - 1]) {\\n                stones.pop_back();\\n                stones.pop_back();\\n            }\\n            else {\\n                stones[n - 2] = stones[n - 1] - stones[n - 2];\\n                stones.pop_back();\\n            }\\n        }\\n        return stones.empty() ? 0:stones[0];\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1) {\\n            sort(stones.begin(), stones.end());\\n            int n = stones.size();\\n            \\n            if(stones[n - 2] == stones[n - 1]) {\\n                stones.pop_back();\\n                stones.pop_back();\\n            }\\n            else {\\n                stones[n - 2] = stones[n - 1] - stones[n - 2];\\n                stones.pop_back();\\n            }\\n        }\\n        return stones.empty() ? 0:stones[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922677,
                "title": "python-simple-python-solution-using-three-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Apporach 1 Using Priority Queue :-\\n# Runtime: 39 ms, faster than 55.89% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.1 MB, less than 13.28% of Python3 online submissions for Last Stone Weight.\\n\\n\\tfrom queue import PriorityQueue\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tpq = PriorityQueue()\\n\\n\\t\\t\\tfor stone in stones:\\n\\t\\t\\t\\tpq.put(-stone)\\n\\n\\t\\t\\twhile pq.qsize() >= 2:\\n\\t\\t\\t\\tfirst_heavy = -(pq.get())\\n\\t\\t\\t\\tsecond_heavy = -(pq.get())\\n\\n\\t\\t\\t\\tif first_heavy == second_heavy:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpq.put(-(first_heavy - second_heavy))\\n\\n\\t\\t\\tif pq.qsize() == 1:\\n\\t\\t\\t\\treturn -pq.get()\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 2 Using Sorting :-\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\twhile len(stones)>1:\\n\\n\\t\\t\\t\\tsort_stones = sorted(stones)\\n\\n\\t\\t\\t\\tsmall_num, large_num = sort_stones[-2], sort_stones[-1]\\n\\n\\t\\t\\t\\tif small_num == large_num :\\n\\n\\t\\t\\t\\t\\tstones = sort_stones[:-2]\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(small_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(large_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.append(large_num - small_num)\\n\\n\\t\\t\\t\\t\\tstones = sort_stones\\n\\n\\t\\t\\tif len(stones)==1:\\n\\n\\t\\t\\t\\treturn stones[0]\\n\\n\\t\\t\\telse:\\n\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 3 Using SortedList:\\n# Runtime: 47 ms, faster than 7.84% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.2 MB, less than 8.03% of Python3 online submissions for Last Stone Weight.\\nfrom sortedcontainers import SortedList\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tstones = SortedList(stones)\\n\\n\\t\\t\\twhile len(stones) > 1:\\n\\n\\t\\t\\t\\tlast = stones.pop(-1)\\n\\t\\t\\t\\tsecond_last = stones.pop(-1)\\n\\n\\t\\t\\t\\tif last == second_last:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.add(last - second_last)\\n\\n\\t\\t\\tif len(stones) > 0:\\n\\t\\t\\t\\treturn stones[0]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Apporach 1 Using Priority Queue :-\\n# Runtime: 39 ms, faster than 55.89% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.1 MB, less than 13.28% of Python3 online submissions for Last Stone Weight.\\n\\n\\tfrom queue import PriorityQueue\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tpq = PriorityQueue()\\n\\n\\t\\t\\tfor stone in stones:\\n\\t\\t\\t\\tpq.put(-stone)\\n\\n\\t\\t\\twhile pq.qsize() >= 2:\\n\\t\\t\\t\\tfirst_heavy = -(pq.get())\\n\\t\\t\\t\\tsecond_heavy = -(pq.get())\\n\\n\\t\\t\\t\\tif first_heavy == second_heavy:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpq.put(-(first_heavy - second_heavy))\\n\\n\\t\\t\\tif pq.qsize() == 1:\\n\\t\\t\\t\\treturn -pq.get()\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 2 Using Sorting :-\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\twhile len(stones)>1:\\n\\n\\t\\t\\t\\tsort_stones = sorted(stones)\\n\\n\\t\\t\\t\\tsmall_num, large_num = sort_stones[-2], sort_stones[-1]\\n\\n\\t\\t\\t\\tif small_num == large_num :\\n\\n\\t\\t\\t\\t\\tstones = sort_stones[:-2]\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(small_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(large_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.append(large_num - small_num)\\n\\n\\t\\t\\t\\t\\tstones = sort_stones\\n\\n\\t\\t\\tif len(stones)==1:\\n\\n\\t\\t\\t\\treturn stones[0]\\n\\n\\t\\t\\telse:\\n\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 3 Using SortedList:\\n# Runtime: 47 ms, faster than 7.84% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.2 MB, less than 8.03% of Python3 online submissions for Last Stone Weight.\\nfrom sortedcontainers import SortedList\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tstones = SortedList(stones)\\n\\n\\t\\t\\twhile len(stones) > 1:\\n\\n\\t\\t\\t\\tlast = stones.pop(-1)\\n\\t\\t\\t\\tsecond_last = stones.pop(-1)\\n\\n\\t\\t\\t\\tif last == second_last:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.add(last - second_last)\\n\\n\\t\\t\\tif len(stones) > 0:\\n\\t\\t\\t\\treturn stones[0]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 1922512,
                "title": "simplest-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;  //create max heap having maximum element at top\\n        for(int x:stones)               //insert all elements into priority queue \\n            pq.push(x);\\n        while(pq.size()>1){        //iterate until size is equal to 1\\n            int fval=pq.top();      //fval is first max val\\n            pq.pop();\\n            int sval=pq.top();     //sval is second max val\\n            pq.pop();\\n            if(fval==sval){          //if both equal simply push 0 since both stones destroyed\\n                pq.push(0);\\n            }\\n            else if(fval>sval){         //if both not equal substract small val to larger  one and insert \\n                pq.push(fval-sval);\\n            }\\n        }\\n        return pq.top();       //finally return top value\\n    }\\n};\\n```\\nTC : O(nlogn)     \\nSC : O(N)\\nIf you like the solution please upvote. :)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;  //create max heap having maximum element at top\\n        for(int x:stones)               //insert all elements into priority queue \\n            pq.push(x);\\n        while(pq.size()>1){        //iterate until size is equal to 1\\n            int fval=pq.top();      //fval is first max val\\n            pq.pop();\\n            int sval=pq.top();     //sval is second max val\\n            pq.pop();\\n            if(fval==sval){          //if both equal simply push 0 since both stones destroyed\\n                pq.push(0);\\n            }\\n            else if(fval>sval){         //if both not equal substract small val to larger  one and insert \\n                pq.push(fval-sval);\\n            }\\n        }\\n        return pq.top();       //finally return top value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357203,
                "title": "easy-python-solution-99-91",
                "content": "Runtime: 16 ms, faster than 99.91% of Python3 online submissions for Last Stone Weight.\\nMemory Usage: 14.1 MB, less than 78.97% of Python3 online submissions for Last Stone Weight.\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) != 1:\\n            stones.sort()\\n            if len(stones)>2:\\n                if stones[-1]==stones[-2]:\\n                    del stones[-1]\\n                    del stones[-1]\\n                elif stones[-1]>stones[-2]:\\n                    stones[-1]-=stones[-2]\\n                    del stones[-2]\\n            else:\\n                return stones[-1]-stones[-2]        \\n        return stones[0]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 16 ms, faster than 99.91% of Python3 online submissions for Last Stone Weight.\\nMemory Usage: 14.1 MB, less than 78.97% of Python3 online submissions for Last Stone Weight.\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) != 1:\\n            stones.sort()\\n            if len(stones)>2:\\n                if stones[-1]==stones[-2]:\\n                    del stones[-1]\\n                    del stones[-1]\\n                elif stones[-1]>stones[-2]:\\n                    stones[-1]-=stones[-2]\\n                    del stones[-2]\\n            else:\\n                return stones[-1]-stones[-2]        \\n        return stones[0]",
                "codeTag": "Java"
            },
            {
                "id": 709185,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length > 1) {\\n        stones.sort((a,b) => b-a);\\n\\n        let first = stones.shift();\\n        let second = stones.shift();\\n\\n        if(first !== second) {\\n            stones.push(Math.abs(first-second));\\n        }\\n    }\\n\\n    if(stones.length == 0) {\\n        return 0;\\n    }\\n\\n    return stones[0];\\n};\\n\\n// Runtime (64ms) - Faster than 65.95% of Javascript submissions\\n// Memory Usage ( 34.1 MB ) - Less than 79% of Javascript submissions\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length > 1) {\\n        stones.sort((a,b) => b-a);\\n\\n        let first = stones.shift();\\n        let second = stones.shift();\\n\\n        if(first !== second) {\\n            stones.push(Math.abs(first-second));\\n        }\\n    }\\n\\n    if(stones.length == 0) {\\n        return 0;\\n    }\\n\\n    return stones[0];\\n};\\n\\n// Runtime (64ms) - Faster than 65.95% of Javascript submissions\\n// Memory Usage ( 34.1 MB ) - Less than 79% of Javascript submissions\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674125,
                "title": "java-heap",
                "content": "```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int st : stones) {\\n            pq.offer(st);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll(), y = pq.poll();\\n            int rem = x - y;\\n            if (rem > 0) pq.offer(rem);\\n        }\\n        \\n        return pq.size() > 0 ? pq.poll() : 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int st : stones) {\\n            pq.offer(st);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll(), y = pq.poll();\\n            int rem = x - y;\\n            if (rem > 0) pq.offer(rem);\\n        }\\n        \\n        return pq.size() > 0 ? pq.poll() : 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 464917,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    while(stones.length > 1){\\n        let index1 = stones.indexOf(Math.max(...stones));\\n        let stone1 = stones.splice(index1,1);\\n        let index2 = stones.indexOf(Math.max(...stones));\\n        let stone2 = stones.splice(index2,1);\\n        stones.push(stone1-stone2);        \\n    }\\n    return stones;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    while(stones.length > 1){\\n        let index1 = stones.indexOf(Math.max(...stones));\\n        let stone1 = stones.splice(index1,1);\\n        let index2 = stones.indexOf(Math.max(...stones));\\n        let stone2 = stones.splice(index2,1);\\n        stones.push(stone1-stone2);        \\n    }\\n    return stones;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398322,
                "title": "c-minimum-heap-using-c-sorteddictionary",
                "content": "The algorithm can be solved using minimum heap. To convert maximum two numbers to minimum two numbers, negative value is used instead. \\n\\nHere are highlights:\\n1. Understand C# SortedDictionary can be used to impelement minimum heap first; \\n2. Apply all ement value to negative one, so maximum heap turns into a minimum heap problem;\\n3. Get familiar with IEnumberable First API and it can be used to get the minimum one from the heap. \\n\\n```\\npublic class Solution {\\n    /// <summary>\\n        /// Oct.4, 2019\\n        /// Implement a maximum heap - \\n        /// what I can do is to use negative value \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public int LastStoneWeight(int[] stones)\\n        {\\n            var sorted = new SortedDictionary<int, int>();\\n\\n            // put all numbers into minimum heap - default - negative value\\n            foreach (var number in stones)\\n            {\\n                var key = number * (-1);\\n                if (!sorted.ContainsKey(key))\\n                {\\n                    sorted.Add(key, 0);\\n                }\\n\\n                sorted[key]++; \\n            }\\n\\n            while (!((sorted.Keys.Count == 1 && sorted[sorted.Keys.ToList()[0]] == 1) || sorted.Keys.Count == 0))\\n            {\\n                // get minimum two values from minimum heap\\n                var key = sorted.Keys.First();\\n                var hasAtLeastTwo = sorted[key] > 1;\\n                if (hasAtLeastTwo)\\n                {\\n                    sorted[key] -= 2;\\n                    if(sorted[key] == 0)\\n                    {\\n                        sorted.Remove(key);\\n                    }\\n                }\\n                else \\n                {\\n                    var minimum = key;\\n                    sorted.Remove(key);\\n                    var next = sorted.Keys.First();\\n                    sorted[next]--;\\n\\n                    if (sorted[next] == 0)\\n                    {\\n                        sorted.Remove(next);\\n                    }\\n\\n                    var diff = Math.Abs(minimum - next);\\n                    var newKey = diff * (-1);\\n\\n                    if (newKey == 0)\\n                        continue;\\n\\n                    if (!sorted.ContainsKey(newKey))\\n                    {\\n                        sorted.Add(newKey, 0);\\n                    }\\n\\n                    sorted[newKey]++;\\n                }                \\n            }\\n\\n            if (sorted.Keys.Count == 0)\\n                return 0;\\n\\n            return sorted.Keys.ToList()[0] * (-1);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /// <summary>\\n        /// Oct.4, 2019\\n        /// Implement a maximum heap - \\n        /// what I can do is to use negative value \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public int LastStoneWeight(int[] stones)\\n        {\\n            var sorted = new SortedDictionary<int, int>();\\n\\n            // put all numbers into minimum heap - default - negative value\\n            foreach (var number in stones)\\n            {\\n                var key = number * (-1);\\n                if (!sorted.ContainsKey(key))\\n                {\\n                    sorted.Add(key, 0);\\n                }\\n\\n                sorted[key]++; \\n            }\\n\\n            while (!((sorted.Keys.Count == 1 && sorted[sorted.Keys.ToList()[0]] == 1) || sorted.Keys.Count == 0))\\n            {\\n                // get minimum two values from minimum heap\\n                var key = sorted.Keys.First();\\n                var hasAtLeastTwo = sorted[key] > 1;\\n                if (hasAtLeastTwo)\\n                {\\n                    sorted[key] -= 2;\\n                    if(sorted[key] == 0)\\n                    {\\n                        sorted.Remove(key);\\n                    }\\n                }\\n                else \\n                {\\n                    var minimum = key;\\n                    sorted.Remove(key);\\n                    var next = sorted.Keys.First();\\n                    sorted[next]--;\\n\\n                    if (sorted[next] == 0)\\n                    {\\n                        sorted.Remove(next);\\n                    }\\n\\n                    var diff = Math.Abs(minimum - next);\\n                    var newKey = diff * (-1);\\n\\n                    if (newKey == 0)\\n                        continue;\\n\\n                    if (!sorted.ContainsKey(newKey))\\n                    {\\n                        sorted.Add(newKey, 0);\\n                    }\\n\\n                    sorted[newKey]++;\\n                }                \\n            }\\n\\n            if (sorted.Keys.Count == 0)\\n                return 0;\\n\\n            return sorted.Keys.ToList()[0] * (-1);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294929,
                "title": "simple-binary-search-based-solution-o-nlogn",
                "content": "``` csharp\\npublic class Solution {\\n  public int LastStoneWeight(int[] stones)\\n        {\\n            if (stones.Length == 2)\\n            {\\n                return Math.Abs(stones[1] - stones[0]);\\n            }\\n\\n            Array.Sort(stones);\\n            List<int> s = new List<int>(stones);\\n\\n            while (s.Count > 1)\\n            {\\n                int first = s.ElementAt(s.Count - 1);\\n                int second = s.ElementAt(s.Count - 2);\\n                int smash = first - second;\\n                s.RemoveAt(s.Count - 1);\\n                s.RemoveAt(s.Count - 1);\\n\\n                if (smash != 0)\\n                {\\n                    int index = s.BinarySearch(smash);\\n                    if (index < 0)\\n                    {\\n                        index = ~index;\\n                    }\\n                    s.Insert(index, smash);\\n                }\\n            }\\n\\n            return s.FirstOrDefault();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "``` csharp\\npublic class Solution {\\n  public int LastStoneWeight(int[] stones)\\n        {\\n            if (stones.Length == 2)\\n            {\\n                return Math.Abs(stones[1] - stones[0]);\\n            }\\n\\n            Array.Sort(stones);\\n            List<int> s = new List<int>(stones);\\n\\n            while (s.Count > 1)\\n            {\\n                int first = s.ElementAt(s.Count - 1);\\n                int second = s.ElementAt(s.Count - 2);\\n                int smash = first - second;\\n                s.RemoveAt(s.Count - 1);\\n                s.RemoveAt(s.Count - 1);\\n\\n                if (smash != 0)\\n                {\\n                    int index = s.BinarySearch(smash);\\n                    if (index < 0)\\n                    {\\n                        index = ~index;\\n                    }\\n                    s.Insert(index, smash);\\n                }\\n            }\\n\\n            return s.FirstOrDefault();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294884,
                "title": "java-priorityqueue-solution",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        \\n        for (int stone : stones) {\\n            pq.offer(stone);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll();\\n            int y = pq.poll();\\n            if (x != y) {\\n                pq.offer(x - y);\\n            }\\n        }\\n        \\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        \\n        for (int stone : stones) {\\n            pq.offer(stone);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll();\\n            int y = pq.poll();\\n            if (x != y) {\\n                pq.offer(x - y);\\n            }\\n        }\\n        \\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451705,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used concept of priorityQueue(But this question also we can slove the help of Arraylist)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n     PriorityQueue<Integer> queue=new PriorityQueue<>(Collections.reverseOrder()) ;\\n     for(int i=0;i<stones.length;i++)  {\\n         queue.add(stones[i]);\\n     }\\n     while(queue.size()>1){\\n         int val2=queue.poll();\\n         int val1=queue.poll();\\n         if(val2>val1){\\n             queue.offer(val2-val1);\\n         }\\n     }\\n     if(queue.size()==0) return 0;\\n     return queue.poll();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n     PriorityQueue<Integer> queue=new PriorityQueue<>(Collections.reverseOrder()) ;\\n     for(int i=0;i<stones.length;i++)  {\\n         queue.add(stones[i]);\\n     }\\n     while(queue.size()>1){\\n         int val2=queue.poll();\\n         int val1=queue.poll();\\n         if(val2>val1){\\n             queue.offer(val2-val1);\\n         }\\n     }\\n     if(queue.size()==0) return 0;\\n     return queue.poll();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451178,
                "title": "java-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In this code we first sort the stones to get the 2 heaviest stones at the end of the array.\\n- Now we repetedly smashes(calculates the diff of the two heaviest stones,then setting the heaviest stone with that diff and second heaviest stone with 0) the two heaviest stones until there is only one stone left.\\n- Again sort the stones after the smash.\\n- This loop ends when the weigth of the second heaviest stone is 0.\\n- This indicates that there is only one stone left.\\n# Complexity\\n- Time complexity: O(n^2 log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        if(stones.length == 1) return stones[0];\\n        int n = stones.length;\\n        while(stones[n - 2] > 0){\\n            int diff = stones[n - 1] - stones[n - 2];\\n            stones[n - 2] = 0;\\n            stones[n - 1] = diff;\\n            Arrays.sort(stones);\\n        }\\n        return stones[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        if(stones.length == 1) return stones[0];\\n        int n = stones.length;\\n        while(stones[n - 2] > 0){\\n            int diff = stones[n - 1] - stones[n - 2];\\n            stones[n - 2] = 0;\\n            stones[n - 1] = diff;\\n            Arrays.sort(stones);\\n        }\\n        return stones[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449600,
                "title": "c-priority-queue",
                "content": "````\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(auto &i: stones){\\n            pq.push(i);\\n        }\\n        int a,b;\\n        while(pq.size()>1){\\n            a  = pq.top();pq.pop();\\n            b  = pq.top();pq.pop();\\n            if(a!=b){\\n                pq.push(abs(a-b));\\n            }\\n        }\\n        if(pq.empty())return 0;\\n        return pq.top();\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(auto &i: stones){\\n            pq.push(i);\\n        }\\n        int a,b;\\n        while(pq.size()>1){\\n            a  = pq.top();pq.pop();\\n            b  = pq.top();pq.pop();\\n            if(a!=b){\\n                pq.push(abs(a-b));\\n            }\\n        }\\n        if(pq.empty())return 0;\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449106,
                "title": "c-solution-heap-easy-and-explained",
                "content": "# Explanation\\n- At any point of time we need largest 2 stones that\\'s why I used priority queue.\\n- If the diffrence of these two stones is > 0, the we push it in the queue.\\n- And if diffrence is 0, i.e. both stones are destroyed\\n- At the end of the loop is the queue is empty, i.e. all the stones were destroyed during the game, that means we have to return 0\\n- Else we just return the last stone that\\'s left in the queue.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq(stones.begin(),stones.end());    \\n        while(pq.size()>1){\\n            int s1=pq.top();\\n            pq.pop();\\n            int s2=pq.top();\\n            pq.pop();\\n            if(s1-s2){\\n                pq.push(s1-s2);\\n            }            \\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/c2726930-6086-475f-aea7-648d6c6f15c6_1682309289.295028.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq(stones.begin(),stones.end());    \\n        while(pq.size()>1){\\n            int s1=pq.top();\\n            pq.pop();\\n            int s2=pq.top();\\n            pq.pop();\\n            if(s1-s2){\\n                pq.push(s1-s2);\\n            }            \\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448970,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 155 videos for leetcode questions as of April 24, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\nhttps://leetcode.com/niits/\\n\\n![aaaaaaa.webp](https://assets.leetcode.com/users/images/d6a4c7b9-262c-497c-b943-a950c6ebdb9f_1682305218.8948395.webp)\\n\\n\\n# Intuition\\nUse heap to store stones.\\n\\n# Approach\\n- This is Python algorithm. Other languages might be different.\\n\\n1. Initialize a variable stones as a heap of negative values of the input stones list using list comprehension. This is done to create a min heap where the most negative value (i.e., the largest absolute value) will be at the root of the heap.\\n\\n2. Convert the stones list into a heap using the heapify function from the heapq module.\\n\\n3. While the length of stones is greater than 1, perform the following steps in a loop:\\n\\n    - Pop the two smallest (most negative) values from the heap and store them in variables s1 and s2.\\n    - Check if s1 and s2 are not equal. If they are not equal, calculate the difference between s1 and s2 and negate it (to maintain the negative value) before pushing it back to the heap using the heappush function.\\n\\n4. After the loop, if the stones heap is not empty, return the negation of the root value (the only remaining value in the heap), which represents the last stone weight. Otherwise, return 0 to indicate that all stones have been destroyed.\\n\\n---\\n\\n\\n**If you don\\'t understand the algorithm, let\\'s check my video solution.\\nThere is my channel link under picture in LeetCode profile.**\\nhttps://leetcode.com/niits/\\n\\n\\n---\\n\\n# Complexity\\n- Time complexity: O(n log n)\\nn is the number of elements in the input stones list. This is because the heapify function has a time complexity of O(n) and the while loop iterates n/2 times at most (since two elements are popped from the heap in each iteration), and each iteration involves push and pop operations on the heap which take O(log n) time. Therefore, the overall time complexity is dominated by the heapify function, resulting in O(n log n) time complexity.\\n\\n- Space complexity: O(n)\\nThe stones list is modified in place by converting it into a heap using heapify. No additional data structures are used, and the variables used in the code have constant space requirements. Therefore, the space complexity is proportional to the size of the input stones list, i.e., O(n).\\n\\n# Python\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        if len(stones) == 1:\\n            return stones[0]\\n        \\n        stones = [-s for s in stones]\\n        heapq.heapify(stones)\\n\\n        while len(stones) > 1:\\n            s1 = -(heapq.heappop(stones))\\n            s2 = -(heapq.heappop(stones))\\n\\n            if s1 != s2:\\n                heapq.heappush(stones, -(s1-s2))\\n        \\n        return -(stones[0]) if stones else 0\\n```\\n# JavaScript\\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element   \\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        \\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n        \\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int second = queue.poll();\\n            \\n            if (first != second) {\\n                queue.offer(first - second);\\n            }\\n        }\\n        \\n        return queue.size() == 0 ? 0 : queue.peek();\\n    }\\n}\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> queue;\\n        int s1, s2;\\n        \\n        for(auto s1:stones)\\n            queue.push(s1);\\n        \\n        while(queue.size() != 1){\\n            s2 = queue.top();\\n            queue.pop();\\n            s1 = queue.top();\\n            queue.pop();\\n\\n            queue.push(s2-s1);\\n        }\\n        \\n        return queue.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        if len(stones) == 1:\\n            return stones[0]\\n        \\n        stones = [-s for s in stones]\\n        heapq.heapify(stones)\\n\\n        while len(stones) > 1:\\n            s1 = -(heapq.heappop(stones))\\n            s2 = -(heapq.heappop(stones))\\n\\n            if s1 != s2:\\n                heapq.heappush(stones, -(s1-s2))\\n        \\n        return -(stones[0]) if stones else 0\\n```\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element   \\n};\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        \\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n        \\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int second = queue.poll();\\n            \\n            if (first != second) {\\n                queue.offer(first - second);\\n            }\\n        }\\n        \\n        return queue.size() == 0 ? 0 : queue.peek();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> queue;\\n        int s1, s2;\\n        \\n        for(auto s1:stones)\\n            queue.push(s1);\\n        \\n        while(queue.size() != 1){\\n            s2 = queue.top();\\n            queue.pop();\\n            s1 = queue.top();\\n            queue.pop();\\n\\n            queue.push(s2-s1);\\n        }\\n        \\n        return queue.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448700,
                "title": "java-priority-queue-beats-98-10-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int lastStoneWeight(int[] stones) {\\n    int x = 0, y = 0;\\n    var queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\n    for (var stone : stones)\\n      queue.offer(stone);\\n    \\n    while (!queue.isEmpty()) {\\n      y = queue.poll();\\n      if (queue.isEmpty()) return y;\\n\\n      x = queue.poll();\\n      if (x != y) queue.offer(y - x);\\n    }\\n    return 0;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  public int lastStoneWeight(int[] stones) {\\n    int x = 0, y = 0;\\n    var queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\n    for (var stone : stones)\\n      queue.offer(stone);\\n    \\n    while (!queue.isEmpty()) {\\n      y = queue.poll();\\n      if (queue.isEmpty()) return y;\\n\\n      x = queue.poll();\\n      if (x != y) queue.offer(y - x);\\n    }\\n    return 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448500,
                "title": "c-easy-and-readable-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/8deee7e3-6578-4e6c-98c0-c9b2ceadefe8_1682281633.5742104.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> ls = stones.ToList();\\n        while (ls.Count > 1)\\n        {\\n            ls = ls.OrderByDescending(s => s).ToList();\\n            int a = ls[0];\\n            int b = ls[1];\\n            if (a == b)\\n            {\\n                ls.RemoveAt(1);\\n                ls.RemoveAt(0);\\n            }\\n            else\\n            {\\n                ls[1] = a - b;\\n                ls.RemoveAt(0);\\n            }\\n        }\\n        return ls.Count > 0 ? ls.First() : 0;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> ls = stones.ToList();\\n        while (ls.Count > 1)\\n        {\\n            ls = ls.OrderByDescending(s => s).ToList();\\n            int a = ls[0];\\n            int b = ls[1];\\n            if (a == b)\\n            {\\n                ls.RemoveAt(1);\\n                ls.RemoveAt(0);\\n            }\\n            else\\n            {\\n                ls[1] = a - b;\\n                ls.RemoveAt(0);\\n            }\\n        }\\n        return ls.Count > 0 ? ls.First() : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376991,
                "title": "simple-solution-with-priority-queue",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n= stones.length;\\n        if(n==1) return stones[0];\\n        Queue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.offer(stones[i]);\\n        }\\n        while(pq.size()>1)\\n        {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            int diff = Math.max(a,b) - Math.min(a,b);\\n            if(diff>0)\\n                pq.offer(diff);\\n        }\\n        int weight = 0;\\n        if(!pq.isEmpty())\\n        {\\n            weight= pq.poll();\\n        }\\n        return weight;\\n    }\\n}\\n```\\n\\n![87473a41-9c53-4e65-967e-15f92ebc9310_1677233624.267395.jpeg](https://assets.leetcode.com/users/images/00e56b65-7f40-4a62-9ee2-6d272278b5b0_1680578844.8665698.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n= stones.length;\\n        if(n==1) return stones[0];\\n        Queue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.offer(stones[i]);\\n        }\\n        while(pq.size()>1)\\n        {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            int diff = Math.max(a,b) - Math.min(a,b);\\n            if(diff>0)\\n                pq.offer(diff);\\n        }\\n        int weight = 0;\\n        if(!pq.isEmpty())\\n        {\\n            weight= pq.poll();\\n        }\\n        return weight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233363,
                "title": "c-priority-queue",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int>pq (stones.begin(),stones.end());\\n        while(pq.size()>=2)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x==y)\\n            {\\n                \\n            }\\n            else\\n            {\\n                pq.push(y-x);\\n            }\\n        }\\n        if(!pq.empty()) return pq.top();\\n        return 0;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int>pq (stones.begin(),stones.end());\\n        while(pq.size()>=2)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x==y)\\n            {\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3135101,
                "title": "0ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n=stones.length;\\n        while(n>1){\\n            Arrays.sort(stones);\\n            int x=stones[n-1]-stones[n-2];\\n            n--;\\n            stones[n-1]=x;\\n        }\\n        return stones[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n=stones.length;\\n        while(n>1){\\n            Arrays.sort(stones);\\n            int x=stones[n-1]-stones[n-2];\\n            n--;\\n            stones[n-1]=x;\\n        }\\n        return stones[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094838,
                "title": "java-0ms",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue=new PriorityQueue<Integer>(Collections.reverseOrder()); \\n\\n        for(int i :stones){\\n            queue.add(i);\\n        } \\n\\n        while(!queue.isEmpty()){\\n            int x=queue.poll();\\n            if(queue.isEmpty()){\\n                return x;\\n            }\\n            int y=queue.poll();\\n\\n            queue.add(x-y);\\n        }\\n        return queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue=new PriorityQueue<Integer>(Collections.reverseOrder()); \\n\\n        for(int i :stones){\\n            queue.add(i);\\n        } \\n\\n        while(!queue.isEmpty()){\\n            int x=queue.poll();\\n            if(queue.isEmpty()){\\n                return x;\\n            }\\n            int y=queue.poll();\\n\\n            queue.add(x-y);\\n        }\\n        return queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868752,
                "title": "beats-98-heapq-python",
                "content": "\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [ -n for n in stones]\\n        heapq.heapify(stones)\\n        while len(stones) >=2:\\n            diff = heapq.heappop(stones) - heapq.heappop(stones)\\n            print(diff)\\n            if diff != 0:\\n                heapq.heappush(stones,diff)\\n        return -stones[0] if len(stones) == 1 else 0\\n```\\n\\n**Upvote if you like the solution.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [ -n for n in stones]\\n        heapq.heapify(stones)\\n        while len(stones) >=2:\\n            diff = heapq.heappop(stones) - heapq.heappop(stones)\\n            print(diff)\\n            if diff != 0:\\n                heapq.heappush(stones,diff)\\n        return -stones[0] if len(stones) == 1 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543347,
                "title": "simple-c-solution-while-loop-accepted",
                "content": "In the following code ...we are using a while loop when the size of array /vector is greater than 1..and sorting the vector at each itetation and then storing the value of the last two maximum elements in variable \\' a \\'. then we pop the last two elements of that array ..and append that value .and again in while loop we sort again and repeat the process\\nat last we return the only value in the vector which is the LAST STONE WEIGHT\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones)\\n   {while(stones.size()>1){\\n       sort(stones.begin(),stones.end());\\n          int a=stones[stones.size()-1]-stones[stones.size()-2];\\n           stones.pop_back();\\n           stones.pop_back();\\n           stones.push_back(a);\\n       }\\n        return stones[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones)\\n   {while(stones.size()>1){\\n       sort(stones.begin(),stones.end());\\n          int a=stones[stones.size()-1]-stones[stones.size()-2];\\n           stones.pop_back();\\n           stones.pop_back();\\n           stones.push_back(a);\\n       }\\n        return stones[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447318,
                "title": "python-easy-tc-o-n-sc-o-1-without-heap",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) >= 2:\\n            stones.sort(reverse = True)\\n            first = stones.pop(0)\\n            second = stones.pop(0)\\n            if first == second:\\n                continue\\n            else:\\n                stones.append(first-second)\\n        if stones:\\n            return stones[0]\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) >= 2:\\n            stones.sort(reverse = True)\\n            first = stones.pop(0)\\n            second = stones.pop(0)\\n            if first == second:\\n                continue\\n            else:\\n                stones.append(first-second)\\n        if stones:\\n            return stones[0]\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433222,
                "title": "java-easiest-solution-3ms-runtime-beginner-friendly-approach-high-runtime-easy-approch",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i: stones){\\n            arr.add(i);\\n        }\\n        while(arr.size() > 1){\\n            Collections.sort(arr);   \\n            int size = arr.size();\\n            int max = arr.get(size-1);\\n            int min = arr.get(size-2);\\n            arr.remove(size-1);\\n            arr.remove(size-2);\\n            if(min != max){\\n                max = max - min;\\n                arr.add(max);\\n            }\\n        }\\n        return arr.size()==1?arr.get(0):0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i: stones){\\n            arr.add(i);\\n        }\\n        while(arr.size() > 1){\\n            Collections.sort(arr);   \\n            int size = arr.size();\\n            int max = arr.get(size-1);\\n            int min = arr.get(size-2);\\n            arr.remove(size-1);\\n            arr.remove(size-2);\\n            if(min != max){\\n                max = max - min;\\n                arr.add(max);\\n            }\\n        }\\n        return arr.size()==1?arr.get(0):0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922172,
                "title": "easiest-simplest-explained-solution",
                "content": "**Priority Queue Implementation**\\n\\nMake a priority queue(binary max heap) which automatically arrange the element in sorted order.\\nThen pick the first element (which is maximum) and 2nd element(2nd max) , if both are equal we dont have to push anything , if not equal push difference of both in queue.\\nDo the above steps till queue size is equal to 1, then return last element. If queue becomes empty before reaching size==1 then return 0.\\n```\\n// Please upvote , if u like my solution :)\\nint lastStoneWeight(vector<int>& nums) {\\n        priority_queue<int> q;\\n        int ans = 0;\\n        for(auto it:nums){\\n            q.push(it);\\n        }\\n        while(true){\\n            if(q.size()==1 || q.size()==0) break;\\n            int v1 = q.top(); q.pop();\\n            int v2 = q.top(); q.pop();\\n            if(v1 != v2){\\n                q.push(v1-v2);\\n            }\\n        }\\n        if(q.size()) ans = q.top();\\n        return ans;\\n    }\\n// Please upvote , if u like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Please upvote , if u like my solution :)\\nint lastStoneWeight(vector<int>& nums) {\\n        priority_queue<int> q;\\n        int ans = 0;\\n        for(auto it:nums){\\n            q.push(it);\\n        }\\n        while(true){\\n            if(q.size()==1 || q.size()==0) break;\\n            int v1 = q.top(); q.pop();\\n            int v2 = q.top(); q.pop();\\n            if(v1 != v2){\\n                q.push(v1-v2);\\n            }\\n        }\\n        if(q.size()) ans = q.top();\\n        return ans;\\n    }\\n// Please upvote , if u like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921987,
                "title": "simple-java-solution-using-priority-queue",
                "content": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        if(stones.length==2)return Math.abs(stones[0]-stones[1]);\\n        PriorityQueue<Integer> q=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int s:stones){\\n            q.add(s);\\n        }\\n        while(!q.isEmpty()){\\n            int x=q.poll();\\n            int y=q.poll();\\n            if(x!=y){\\n                q.add(Math.abs(x-y));\\n            }\\n            if(q.size()==1){\\n                return q.poll();\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        if(stones.length==2)return Math.abs(stones[0]-stones[1]);\\n        PriorityQueue<Integer> q=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int s:stones){\\n            q.add(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1921944,
                "title": "java-basic-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++){\\n\\t\\t//Add elements to the priority queue\\n            q.add(stones[i]);\\n        }\\n        int i = q.peek();\\n        int j = i;\\n        while(!q.isEmpty()){\\n            //Get max element\\n            i = q.poll();\\n            if(q.isEmpty()){\\n                break;\\n            }else{\\n                // get second max element\\n                j = q.poll();\\n            }\\n            // check if x != y\\n            if(i != j){\\n                // y = y - x\\n                i = i-j;\\n                q.add(i);\\n            }else if(i == j && q.isEmpty()){\\n                return 0;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++){\\n\\t\\t//Add elements to the priority queue\\n            q.add(stones[i]);\\n        }\\n        int i = q.peek();\\n        int j = i;\\n        while(!q.isEmpty()){\\n            //Get max element\\n            i = q.poll();\\n            if(q.isEmpty()){\\n                break;\\n            }else{\\n                // get second max element\\n                j = q.poll();\\n            }\\n            // check if x != y\\n            if(i != j){\\n                // y = y - x\\n                i = i-j;\\n                q.add(i);\\n            }else if(i == j && q.isEmpty()){\\n                return 0;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921911,
                "title": "priority-queue-understandable-c-easy-solution",
                "content": "int lastStoneWeight(vector<int>& stones) {\\n        \\n         priority_queue<int>pd(stones.begin(),stones.end());\\n        \\n        while(1){\\n            \\n            if(pd.size()==0)\\n                return 0;\\n            \\n            if(pd.size()==1){ \\n                return pd.top();\\n            \\n            \\n                pd.pop();}\\n            \\n            int t=pd.top();\\n              pd.pop();\\n            int m=pd.top();\\n               pd.pop();\\n            \\n            if(t!=m){ \\n                pd.push(abs(t-m));}\\n               \\n            \\n        }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "int lastStoneWeight(vector<int>& stones) {\\n        \\n         priority_queue<int>pd(stones.begin(),stones.end());\\n        \\n        while(1){\\n            \\n            if(pd.size()==0)\\n                return 0;\\n            \\n            if(pd.size()==1){ \\n                return pd.top();\\n            \\n            \\n                pd.pop();}\\n            \\n            int t=pd.top();\\n              pd.pop();\\n            int m=pd.top();\\n               pd.pop();\\n            \\n            if(t!=m){ \\n                pd.push(abs(t-m));}\\n               \\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1921822,
                "title": "simple-easy-to-understand-beats-100-c-submissions",
                "content": "```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921283,
                "title": "c-faster-than-100-00",
                "content": "Runtime: 68 ms, faster than 100.00% of C# online submissions for Last Stone Weight.\\nMemory Usage: 39.3 MB, less than 5.42% of C# online submissions for Last Stone Weight.\\n\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {        \\n        var list = stones.ToList();\\n        \\n        while(list.Count() >  1)\\n        {\\n            list = list.OrderByDescending(x=>x).ToList();\\n            int f = list[0], s = list[1];\\n            if(f == s)\\n            {\\n                list.RemoveAt(0);\\n                list.RemoveAt(0);\\n            }\\n            else\\n            {\\n                list[1] = f-s;\\n                list.RemoveAt(0);\\n            }\\n        }\\n        return list.Count() > 0 ? list.First() : 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int LastStoneWeight(int[] stones) {        \\n        var list = stones.ToList();\\n        \\n        while(list.Count() >  1)\\n        {\\n            list = list.OrderByDescending(x=>x).ToList();\\n            int f = list[0], s = list[1];\\n            if(f == s)\\n            {\\n                list.RemoveAt(0);\\n                list.RemoveAt(0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1921069,
                "title": "python-heap",
                "content": "```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(max_heap := [-s for s in stones])\\n        \\n        while len(max_heap) > 1:\\n            x = -heappop(max_heap)\\n            y = -heappop(max_heap)\\n            z = x - y\\n            heappush(max_heap, -z) if z else None\\n        \\n        return 0 if not max_heap else -max_heap[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(max_heap := [-s for s in stones])\\n        \\n        while len(max_heap) > 1:\\n            x = -heappop(max_heap)\\n            y = -heappop(max_heap)\\n            z = x - y\\n            heappush(max_heap, -z) if z else None\\n        \\n        return 0 if not max_heap else -max_heap[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792538,
                "title": "java-not-the-best-solution-but-easy-to-understand-1ms-beats-98-48",
                "content": "Disclaimer: This is NOT the most efficient or best way to solve this problem, but in my opinion, it is the easiest way to understand. \\n\\nBasically, if the array is sorted, you want to compare the last two elements until the second to last element becomes zero (because the problem states that at most, there is one stone left).\\n\\nThen, you can just keep iterating through the array using a while loop, while comparing the last two values and changing them accordingly. You need to sort it each time so that the new largest values keep shifting to the right as the smaller stones are being \"destroyed\" aka set to zero. Then, when only one stone remains, you can return that value!\\n\\n```\\npublic int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int len = stones.length;\\n        \\n        if (len == 1)\\n            return stones[0];\\n        \\n        while (stones[len-2] != 0)\\n        {\\n            int x = stones[len-2];\\n            int y = stones[len-1];\\n            \\n            if (x == y)\\n            {\\n                stones[len-1] = 0;\\n                stones[len-2] = 0;\\n            }\\n            else\\n            {\\n                stones[len-1] = y - x;\\n                stones[len-2] = 0;\\n            }\\n\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[len-1];\\n    }\\n\\t\\n```\\n\\t\\nThis runs in 1ms and beats 98.48% of the people.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int len = stones.length;\\n        \\n        if (len == 1)\\n            return stones[0];\\n        \\n        while (stones[len-2] != 0)\\n        {\\n            int x = stones[len-2];\\n            int y = stones[len-1];\\n            \\n            if (x == y)\\n            {\\n                stones[len-1] = 0;\\n                stones[len-2] = 0;\\n            }\\n            else\\n            {\\n                stones[len-1] = y - x;\\n                stones[len-2] = 0;\\n            }\\n\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[len-1];\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171395,
                "title": "c-detailed-explanation-easy-solution",
                "content": "Firstly,we will maintain a priority_queue(max-heap);\\nWHY?\\nBecause the max-heap will keep the heaviest stone by weight on top,as we are allowed to pick the two heaviest elements.\\nNow everytime we need to pick two largest stones,operate on them and then push the result(if non-zero i.e when the stones have unequal weights,we will have to insert the absolute value of the differences into the array).Hmm,so lets think of the data structure which will continuously keep the heaviest stone by weight on top,even after we insert something in the array???Did u guess it??\\nYes,thats a priority-queue,a max-heap by default in C++.\\nSo we will pick the top two elements,pop them out of the queue,if they are equal in weights,they will destroy themselves,so no need to insert a new element into the queue,\\nelse    we will insert the absolute difference of the two into the queue and still end up with the heaviest stone on top due to the nature of priority-queue.\\nTill when do we need to do this,till the priority-queue\\'s size is greater than 1.\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++){\\n            pq.push(stones[i]);\\n        }\\n        while(pq.size()>1){\\n            int curr=pq.top();\\n            pq.pop();\\n            int curr2=pq.top();\\n            pq.pop();\\n            if(curr!=curr2){\\n                pq.push(abs(curr-curr2));\\n            }\\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++){\\n            pq.push(stones[i]);\\n        }\\n        while(pq.size()>1){\\n            int curr=pq.top();\\n            pq.pop();\\n            int curr2=pq.top();\\n            pq.pop();\\n            if(curr!=curr2){\\n                pq.push(abs(curr-curr2));\\n            }\\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115372,
                "title": "java-simple-and-easy-to-understand-solution-using-maxheap-1-ms-faster-than-91-16-with-comments",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        /*\\n          Intituation\\n          Here we are using maxHeap,\\n          property of maxHeao:- \\n           The root node has the maximum value.\\n        */\\n        \\n        //maxHeap\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        \\n        //store all stones, maxHeap\\n        for(int stone : stones) maxHeap.add(stone);\\n        \\n        //iterate till it size is greater than 1\\n        while(maxHeap.size() > 1){\\n            //get first two maximum stone\\n            int stone1 = maxHeap.remove();\\n            int stone2 = maxHeap.remove();\\n            \\n            //add the resultant smashed stone in maxHeap\\n            maxHeap.add(Math.abs(stone1 - stone2));\\n        }\\n        \\n        //last left stone\\n        return maxHeap.remove();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        /*\\n          Intituation\\n          Here we are using maxHeap,\\n          property of maxHeao:- \\n           The root node has the maximum value.\\n        */\\n        \\n        //maxHeap\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        \\n        //store all stones, maxHeap\\n        for(int stone : stones) maxHeap.add(stone);\\n        \\n        //iterate till it size is greater than 1\\n        while(maxHeap.size() > 1){\\n            //get first two maximum stone\\n            int stone1 = maxHeap.remove();\\n            int stone2 = maxHeap.remove();\\n            \\n            //add the resultant smashed stone in maxHeap\\n            maxHeap.add(Math.abs(stone1 - stone2));\\n        }\\n        \\n        //last left stone\\n        return maxHeap.remove();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841406,
                "title": "go-sorted-array-solution-0ms",
                "content": "We use two standard library functions:\\n\\n**sort.Ints():** sorts an integer slice\\n**sort.SearchInts():** returns the index in which the integer value should be inserted in a sorted slice. \\n\\nhttps://github.com/phea/leetcode-go\\n\\n```go\\nfunc lastStoneWeight(stones []int) int {\\n\\tsort.Ints(stones)\\n\\n\\tfor len(stones) >= 2 {\\n\\t\\tstone := stones[len(stones)-1] - stones[len(stones)-2]\\n\\t\\tstones = stones[:len(stones)-2]\\n\\t\\tif stone > 0 {\\n\\t\\t\\t// push stone in sorted list\\n\\t\\t\\tidx := sort.SearchInts(stones, stone)\\n\\t\\t\\tif idx >= len(stones) {\\n\\t\\t\\t\\tstones = append(stones, stone)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstones = append(stones[:idx], append([]int{stone}, stones[idx:]...)...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif len(stones) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\treturn stones[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc lastStoneWeight(stones []int) int {\\n\\tsort.Ints(stones)\\n\\n\\tfor len(stones) >= 2 {\\n\\t\\tstone := stones[len(stones)-1] - stones[len(stones)-2]\\n\\t\\tstones = stones[:len(stones)-2]\\n\\t\\tif stone > 0 {\\n\\t\\t\\t// push stone in sorted list\\n\\t\\t\\tidx := sort.SearchInts(stones, stone)\\n\\t\\t\\tif idx >= len(stones) {\\n\\t\\t\\t\\tstones = append(stones, stone)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstones = append(stones[:idx], append([]int{stone}, stones[idx:]...)...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif len(stones) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\treturn stones[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638675,
                "title": "most-efficient-c-solution-using-multiset-0-ms-7-8-mb-100-100",
                "content": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        multiset<int, greater<int>> s;\\n        for(auto val: stones) s.insert(val);\\n        while(s.size()>=2){\\n            auto itr = s.begin();\\n            itr++;\\n            int temp = *s.begin()-*itr;\\n\\n            s.erase(s.begin());\\n            s.erase(s.begin());\\n            if(temp>0) s.insert(temp);\\n        }\\n        return *s.begin();\\n    }\\n\\t\\n\\t\\n\\tThe algorithm uses multiset which keeps the values sorted in descending order.\\n\\tThe substraction of first two values is kept in temp which is inserted if its value > 0.\\n\\tThe only value left at last is the answer.",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        multiset<int, greater<int>> s;\\n        for(auto val: stones) s.insert(val);\\n        while(s.size()>=2){\\n            auto itr = s.begin();\\n            itr++;\\n            int temp = *s.begin()-*itr;\\n\\n            s.erase(s.begin());\\n            s.erase(s.begin());\\n            if(temp>0) s.insert(temp);\\n        }\\n        return *s.begin();\\n    }\\n\\t\\n\\t\\n\\tThe algorithm uses multiset which keeps the values sorted in descending order.\\n\\tThe substraction of first two values is kept in temp which is inserted if its value > 0.\\n\\tThe only value left at last is the answer.",
                "codeTag": "Unknown"
            },
            {
                "id": 622601,
                "title": "python-3-heap-max-heap",
                "content": "##### as the question it self said pick the largest 2 elements ,by changing the signs +ve to -ve a min heap will behave as a max heap and performing the operations \\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones=list(stones[i]*(-1) for i in range(len(stones)))\\n        heapq.heapify(stones)\\n        while len(stones)>1 :\\n            x=heapq.heappop(stones)\\n            y=heapq.heappop(stones)\\n            if x!=y :\\n                heapq.heappush(stones,x-y)\\n            print(stones)\\n        if len(stones)==0 :\\n            return 0\\n        return -(stones[0])\\n```\\n**hope who ever watches understand it :)**",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones=list(stones[i]*(-1) for i in range(len(stones)))\\n        heapq.heapify(stones)\\n        while len(stones)>1 :\\n            x=heapq.heappop(stones)\\n            y=heapq.heappop(stones)\\n            if x!=y :\\n                heapq.heappush(stones,x-y)\\n            print(stones)\\n        if len(stones)==0 :\\n            return 0\\n        return -(stones[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576555,
                "title": "java-solution-with-o-1-space-and-using-arrays-sort",
                "content": "Idea is to keep the max elements at the end all the time, and keep smashing the stones, till we are left with one at stones[stones.length - 1].\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length < 1) {\\n            return 0;\\n        }\\n        if(stones.length == 1) {\\n            return stones[0];\\n        }\\n        Arrays.sort(stones);\\n        int i = stones.length - 2;\\n        int j = stones.length - 1;\\n        while(i >= 0 && j >= 0 && stones[i] != 0) {\\n            stones[i] = stones[j] - stones[i];\\n            stones[j] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return stones[j];\\n    }\\n}\\n```\\n\\nAny feedback is appreciated :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length < 1) {\\n            return 0;\\n        }\\n        if(stones.length == 1) {\\n            return stones[0];\\n        }\\n        Arrays.sort(stones);\\n        int i = stones.length - 2;\\n        int j = stones.length - 1;\\n        while(i >= 0 && j >= 0 && stones[i] != 0) {\\n            stones[i] = stones[j] - stones[i];\\n            stones[j] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return stones[j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576350,
                "title": "java-simple-and-clean-in-place-solution-beats-100-time",
                "content": "Since input constraints are certain and we only change values of 2 items in an already sorted array , there is no need to worry about sorting the array again in each iteration. \\n\\nThe main logic is that when you smash 2 stones both will lose weight at the amount of the lighter one. If 2 has the same weight, they both will become 0 weight as called destroyed. Here is the code \\n\\n```\\npublic static int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n\\n        if (stones.length == 0){\\n            return 0;\\n        }\\n\\n        if(stones.length == 1){\\n            return stones[0];\\n        }\\n\\t\\t\\n\\t\\t//Smash until all stones smashed and there is no pair to smash (There will be only 1 stone or none)\\n        while (stones[stones.length - 2] > 0) {\\n            stones[stones.length - 1] -= stones[stones.length - 2];\\n            stones[stones.length - 2] -= stones[stones.length - 2];\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[stones.length - 1];\\n    }\\n```\\n\\nRuntime: 0 ms\\nMemory Usage: 37 MB",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n\\n        if (stones.length == 0){\\n            return 0;\\n        }\\n\\n        if(stones.length == 1){\\n            return stones[0];\\n        }\\n\\t\\t\\n\\t\\t//Smash until all stones smashed and there is no pair to smash (There will be only 1 stone or none)\\n        while (stones[stones.length - 2] > 0) {\\n            stones[stones.length - 1] -= stones[stones.length - 2];\\n            stones[stones.length - 2] -= stones[stones.length - 2];\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[stones.length - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575344,
                "title": "java-priority-queue-heap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0){\\n            return 0;\\n        }\\n        \\n        Comparator<Integer> comparator = (o1, o2) -> o2-o1;\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(comparator);\\n        for(int stone : stones){\\n            queue.offer(stone);\\n        }\\n        \\n        while(queue.size() > 1){\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            if(num1!= num2){\\n                queue.offer(num1-num2);\\n            }\\n        }\\n        \\n        return queue.isEmpty()?0: queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0){\\n            return 0;\\n        }\\n        \\n        Comparator<Integer> comparator = (o1, o2) -> o2-o1;\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(comparator);\\n        for(int stone : stones){\\n            queue.offer(stone);\\n        }\\n        \\n        while(queue.size() > 1){\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            if(num1!= num2){\\n                queue.offer(num1-num2);\\n            }\\n        }\\n        \\n        return queue.isEmpty()?0: queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465787,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer>queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int item : stones)queue.add(item);\\n        while (queue.size()>1){\\n            int i1 = queue.poll();\\n            int i2 = queue.poll();\\n            if (i1!=i2)queue.add(Math.abs(i1-i2));\\n        }\\n        return queue.isEmpty()?0:queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer>queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int item : stones)queue.add(item);\\n        while (queue.size()>1){\\n            int i1 = queue.poll();\\n            int i2 = queue.poll();\\n            if (i1!=i2)queue.add(Math.abs(i1-i2));\\n        }\\n        return queue.isEmpty()?0:queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426273,
                "title": "python-beginner-99-81-fast-100-memo-simple-sort-loop-explained",
                "content": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n\\tfor i in range(len(stones)-1):                # loop till the lastone remain\\n\\t\\tstones.sort()                             # smash the heaviest, the heaviest to end of the list\\n\\t\\tstones[-2] = abs(stones[-2] - stones[-1]) # y-x / 0 doent matter which one is bigger\\n\\t\\tstones.pop()                              # Destroy the stone \\n\\treturn stones[0]                              # return the only element in the list\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n\\tfor i in range(len(stones)-1):                # loop till the lastone remain\\n\\t\\tstones.sort()                             # smash the heaviest, the heaviest to end of the list\\n\\t\\tstones[-2] = abs(stones[-2] - stones[-1]) # y-x / 0 doent matter which one is bigger\\n\\t\\tstones.pop()                              # Destroy the stone \\n\\treturn stones[0]                              # return the only element in the list\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 423312,
                "title": "python-100-100-simple-6-liner-with-max-heapq-o-nlogn",
                "content": "```\\nimport heapq as h\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones)):stones[i]*=-1\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            a, b = abs(h.heappop(stones)), abs(h.heappop(stones))\\n            if a!=b:    h.heappush(stones, b-a)\\n        return abs(stones[0]) if stones else 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq as h\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones)):stones[i]*=-1\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            a, b = abs(h.heappop(stones)), abs(h.heappop(stones))\\n            if a!=b:    h.heappush(stones, b-a)\\n        return abs(stones[0]) if stones else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419535,
                "title": "java-implementation-using-max-heap-priority-queue-with-explanation",
                "content": "basic idea is to sort the array using a max heap(Priority Queue). Then we pop the largest two values and subtract(smash) them, then push the result back to the heap \\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n    \\n    //max heap using priority queue    \\n    PriorityQueue<Integer> queue = new PriorityQueue<>((o1,o2) -> o2-o1);\\n    \\n    //sorting using max heap    \\n    for(int stone : stones)\\n    queue.offer(stone);   \\n    \\n    // remove the largest two values and subtract them. Add the result back to the heap\\n    while(queue.size()>1)\\n    queue.offer(queue.poll()-queue.poll());\\n        \\n    return queue.poll();    \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n    \\n    //max heap using priority queue    \\n    PriorityQueue<Integer> queue = new PriorityQueue<>((o1,o2) -> o2-o1);\\n    \\n    //sorting using max heap    \\n    for(int stone : stones)\\n    queue.offer(stone);   \\n    \\n    // remove the largest two values and subtract them. Add the result back to the heap\\n    while(queue.size()>1)\\n    queue.offer(queue.poll()-queue.poll());\\n        \\n    return queue.poll();    \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 396108,
                "title": "easy-c-solution-0ms-beats-100-using-priority-queue",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Last Stone Weight.\\nMemory Usage: 8.3 MB, less than 100.00% of C++ online submissions for Last Stone Weight.\\n\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n        \\n        priority_queue<int> pq;\\n        int n = stones.size();\\n        \\n        for(int i=0; i<n; i++)\\n            pq.push(stones[i]);\\n        \\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n                return pq.top();\\n            \\n            int y = pq.top();\\n            pq.pop();\\n            \\n            int x = pq.top();\\n            pq.pop();\\n            \\n            if(x != y)\\n                pq.push(y - x);\\n        }\\n        \\n        if(pq.size() == 0)\\n            return 0;\\n        return pq.top();\\n    }",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Last Stone Weight.\\nMemory Usage: 8.3 MB, less than 100.00% of C++ online submissions for Last Stone Weight.\\n\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n        \\n        priority_queue<int> pq;\\n        int n = stones.size();\\n        \\n        for(int i=0; i<n; i++)\\n            pq.push(stones[i]);\\n        \\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n                return pq.top();\\n            \\n            int y = pq.top();\\n            pq.pop();\\n            \\n            int x = pq.top();\\n            pq.pop();\\n            \\n            if(x != y)\\n                pq.push(y - x);\\n        }\\n        \\n        if(pq.size() == 0)\\n            return 0;\\n        return pq.top();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 382436,
                "title": "priority-queue-with-javascript",
                "content": "\\tfunction PriorityQueue() {\\n\\t\\tthis.heap = [null];\\n\\t\\tthis.insert = function(value) {\\n\\t\\t\\tthis.heap.push(value);\\n\\t\\t\\tlet currentNodeIdx = this.heap.length - 1;\\n\\t\\t\\tlet currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\twhile (\\n\\t\\t\\t  this.heap[currentNodeParentIdx] &&\\n\\t\\t\\t  value > this.heap[currentNodeParentIdx]\\n\\t\\t\\t) {\\n\\t\\t\\t  let parent = this.heap[currentNodeParentIdx];\\n\\t\\t\\t  this.heap[currentNodeParentIdx] = value;\\n\\t\\t\\t  this.heap[currentNodeIdx] = parent;\\n\\t\\t\\t  currentNodeIdx = currentNodeParentIdx;\\n\\t\\t\\t  currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t\\tthis.remove = function() {\\n\\t\\t  if (this.heap.length < 3) {\\n\\t\\t\\tconst toReturn = this.heap.pop();\\n\\t\\t\\tthis.heap[0] = null;\\n\\t\\t\\treturn toReturn;\\n\\t\\t  }\\n\\t\\t  const toRemove = this.heap[1];\\n\\t\\t  this.heap[1] = this.heap.pop();\\n\\t\\t  let currentIdx = 1;\\n\\t\\t  let [left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t  let currentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  while (this.heap[currentChildIdx] && this.heap[currentIdx] < this.heap[currentChildIdx]) {\\n\\t\\t\\tlet currentNode = this.heap[currentIdx]\\n\\t\\t\\tlet currentChildNode = this.heap[currentChildIdx];\\n\\t\\t\\tthis.heap[currentChildIdx] = currentNode;\\n\\t\\t\\tthis.heap[currentIdx] = currentChildNode;\\n\\t\\t\\t currentIdx = currentChildIdx;\\n\\t\\t\\t[left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t\\tcurrentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  }\\n\\t\\t  return toRemove;\\n\\t\\t}\\n\\t}\\n\\n\\tvar lastStoneWeight = function(stones) {\\n\\t\\tconst pq = new PriorityQueue();\\n\\t\\tfor(let i=0; i<stones.length; i++){\\n\\t\\t\\tpq.insert(stones[i]);\\n\\t\\t}\\n\\t\\twhile(pq.heap.length > 2){\\n\\t\\t\\tlet x = pq.remove();\\n\\t\\t\\tlet y = pq.remove();\\n\\t\\t\\tif(x != y){\\n\\t\\t\\t\\tlet max = Math.max(x, y);\\n\\t\\t\\t\\tlet min = Math.min(x, y);\\n\\t\\t\\t\\tlet z = max - min;\\n\\t\\t\\t\\tpq.insert(z);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn pq.remove();\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "\\tfunction PriorityQueue() {\\n\\t\\tthis.heap = [null];\\n\\t\\tthis.insert = function(value) {\\n\\t\\t\\tthis.heap.push(value);\\n\\t\\t\\tlet currentNodeIdx = this.heap.length - 1;\\n\\t\\t\\tlet currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\twhile (\\n\\t\\t\\t  this.heap[currentNodeParentIdx] &&\\n\\t\\t\\t  value > this.heap[currentNodeParentIdx]\\n\\t\\t\\t) {\\n\\t\\t\\t  let parent = this.heap[currentNodeParentIdx];\\n\\t\\t\\t  this.heap[currentNodeParentIdx] = value;\\n\\t\\t\\t  this.heap[currentNodeIdx] = parent;\\n\\t\\t\\t  currentNodeIdx = currentNodeParentIdx;\\n\\t\\t\\t  currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t\\tthis.remove = function() {\\n\\t\\t  if (this.heap.length < 3) {\\n\\t\\t\\tconst toReturn = this.heap.pop();\\n\\t\\t\\tthis.heap[0] = null;\\n\\t\\t\\treturn toReturn;\\n\\t\\t  }\\n\\t\\t  const toRemove = this.heap[1];\\n\\t\\t  this.heap[1] = this.heap.pop();\\n\\t\\t  let currentIdx = 1;\\n\\t\\t  let [left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t  let currentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  while (this.heap[currentChildIdx] && this.heap[currentIdx] < this.heap[currentChildIdx]) {\\n\\t\\t\\tlet currentNode = this.heap[currentIdx]\\n\\t\\t\\tlet currentChildNode = this.heap[currentChildIdx];\\n\\t\\t\\tthis.heap[currentChildIdx] = currentNode;\\n\\t\\t\\tthis.heap[currentIdx] = currentChildNode;\\n\\t\\t\\t currentIdx = currentChildIdx;\\n\\t\\t\\t[left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t\\tcurrentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  }\\n\\t\\t  return toRemove;\\n\\t\\t}\\n\\t}\\n\\n\\tvar lastStoneWeight = function(stones) {\\n\\t\\tconst pq = new PriorityQueue();\\n\\t\\tfor(let i=0; i<stones.length; i++){\\n\\t\\t\\tpq.insert(stones[i]);\\n\\t\\t}\\n\\t\\twhile(pq.heap.length > 2){\\n\\t\\t\\tlet x = pq.remove();\\n\\t\\t\\tlet y = pq.remove();\\n\\t\\t\\tif(x != y){\\n\\t\\t\\t\\tlet max = Math.max(x, y);\\n\\t\\t\\t\\tlet min = Math.min(x, y);\\n\\t\\t\\t\\tlet z = max - min;\\n\\t\\t\\t\\tpq.insert(z);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn pq.remove();\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 305460,
                "title": "python-use-heapq",
                "content": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        stones = [-1*i for i in stones]\\n        while len(stones)>1:\\n            heapq.heapify(stones)\\n            s1 = heapq.heappop(stones)\\n            s2 = heapq.heappop(stones)\\n            dlt = s1-s2\\n            if dlt != 0:\\n                heapq.heappush(stones,dlt)\\n        return -1*stones[0] if stones else 0\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        stones = [-1*i for i in stones]\\n        while len(stones)>1:\\n            heapq.heapify(stones)\\n            s1 = heapq.heappop(stones)\\n            s2 = heapq.heappop(stones)\\n            dlt = s1-s2\\n            if dlt != 0:\\n                heapq.heappush(stones,dlt)\\n        return -1*stones[0] if stones else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 300230,
                "title": "intuitive-c-solution-100-run-time-100-memory",
                "content": "```class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {        \\n        while(stones.size() > 1)\\n        {\\n            sort(stones.begin(),stones.end());\\n            int y = stones[stones.size()-1];\\n            int x = stones[stones.size()-2];\\n            \\n            if(x == y)\\n            {\\n                stones.erase(stones.begin() + stones.size()-1);\\n                stones.erase(stones.begin() + stones.size()-1); // removes the two biggest numbers.\\n            }\\n            else\\n            {\\n                stones[stones.size()-2] = stones[stones.size()-1] - stones[stones.size()-2];\\n                \\n                stones.erase(stones.begin() + stones.size()-1);                \\n            }\\n        }\\n        \\n        if(stones.size() == 1)\\n            return stones[0];\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {        \\n        while(stones.size() > 1)\\n        {\\n            sort(stones.begin(),stones.end());\\n            int y = stones[stones.size()-1];\\n            int x = stones[stones.size()-2];\\n            \\n            if(x == y)\\n            {\\n                stones.erase(stones.begin() + stones.size()-1);\\n                stones.erase(stones.begin() + stones.size()-1); // removes the two biggest numbers.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 297053,
                "title": "c-0ms-faster-than-100-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> qu(stones.begin(),stones.end());\\n        \\n        while(qu.size() != 0 && qu.size() != 1){\\n            int temp1 = qu.top();\\n            qu.pop();\\n            int temp2 = qu.top();\\n            qu.pop();\\n            \\n            if(temp2 != temp1) qu.push(temp1 - temp2); \\n        }\\n        \\n        if(!qu.size()) return 0;\\n        else return qu.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> qu(stones.begin(),stones.end());\\n        \\n        while(qu.size() != 0 && qu.size() != 1){\\n            int temp1 = qu.top();\\n            qu.pop();\\n            int temp2 = qu.top();\\n            qu.pop();\\n            \\n            if(temp2 != temp1) qu.push(temp1 - temp2); \\n        }\\n        \\n        if(!qu.size()) return 0;\\n        else return qu.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296057,
                "title": "1046-php-solutions-using-sort-and-priority-queue",
                "content": "The two solutions seem to be pretty equivalent speed-wise.\\n\\nHere\\'s a sort-based solution.\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        while (1 < count($stones)) {\\n            rsort($stones, SORT_NUMERIC);\\n            $outcome = array_shift($stones) - array_shift($stones);\\n            if (0 < $outcome) array_push($stones, $outcome);\\n        }\\n        return $stones[0] ?? 0;\\n    }\\n}\\n```\\n\\nAnd here\\'s a priority queue-based solution.\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        $pq = new SplPriorityQueue();\\n        $pq->setExtractFlags(SplPriorityQueue::EXTR_DATA);\\n        foreach ($stones as $stone) $pq->insert($stone, $stone);\\n        while (1 < $pq->count()) {\\n            $outcome = $pq->extract() - $pq->extract();\\n            if (0 < $outcome) $pq->insert($outcome, $outcome);\\n        }\\n        return $pq->current() ?? 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        while (1 < count($stones)) {\\n            rsort($stones, SORT_NUMERIC);\\n            $outcome = array_shift($stones) - array_shift($stones);\\n            if (0 < $outcome) array_push($stones, $outcome);\\n        }\\n        return $stones[0] ?? 0;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        $pq = new SplPriorityQueue();\\n        $pq->setExtractFlags(SplPriorityQueue::EXTR_DATA);\\n        foreach ($stones as $stone) $pq->insert($stone, $stone);\\n        while (1 < $pq->count()) {\\n            $outcome = $pq->extract() - $pq->extract();\\n            if (0 < $outcome) $pq->insert($outcome, $outcome);\\n        }\\n        return $pq->current() ?? 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295468,
                "title": "simple-c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) \\n    {\\n        for(int i=stones.size()-1; i>=1;)\\n        { \\n            sort(stones.begin(),stones.end());\\n            \\n            auto iNum           = stones[i];\\n            auto iM1Num         = stones[i-1];\\n            auto temp           = iNum - iM1Num;\\n\\n            stones.pop_back();\\n            stones.pop_back();\\n\\n             if(iNum  != iM1Num)\\n                stones.push_back(temp);\\n\\n            i = stones.size()-1;\\n        }\\n        return stones.size() > 0 ? stones[0] : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) \\n    {\\n        for(int i=stones.size()-1; i>=1;)\\n        { \\n            sort(stones.begin(),stones.end());\\n            \\n            auto iNum           = stones[i];\\n            auto iM1Num         = stones[i-1];\\n            auto temp           = iNum - iM1Num;\\n\\n            stones.pop_back();\\n            stones.pop_back();\\n\\n             if(iNum  != iM1Num)\\n                stones.push_back(temp);\\n\\n            i = stones.size()-1;\\n        }\\n        return stones.size() > 0 ? stones[0] : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295449,
                "title": "python-solution-heapq-beats-100-time-and-memory-20-ms",
                "content": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            largest = heapq.nlargest(2, stones)\\n            diff = abs(largest[0] - largest[1])\\n    \\n            for item in largest:\\n                stones.remove(item)\\n                \\n            if diff > 0:\\n                heapq.heappush(stones, diff)\\n            \\n        if stones:\\n            return stones[0]\\n        return 0\\n\\t",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            largest = heapq.nlargest(2, stones)\\n            diff = abs(largest[0] - largest[1])\\n    \\n            for item in largest:\\n                stones.remove(item)\\n                \\n            if diff > 0:\\n                heapq.heappush(stones, diff)\\n            \\n        if stones:\\n            return stones[0]\\n        return 0\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 295107,
                "title": "java-solution-using-priorityqueue",
                "content": "* Store all elements in the Priority Queue in decreasing order.\\n* Each time, poll 2 elements from the Priority Queue until its size is 1 and add the absolute difference between the 2 elements back to the queue.\\n* Return 0 if the PriorityQueue is empty or return the last element remaining in the PriorityQueue\\n```\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0)\\n            return 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++)\\n            pq.add(stones[i]);\\n        while(pq.size() > 1) {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            if(a - b != 0)\\n                pq.add(Math.abs(a - b));\\n        }\\n        if(pq.size() == 1)\\n            return pq.poll();\\n        else\\n            return 0;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0)\\n            return 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++)\\n            pq.add(stones[i]);\\n        while(pq.size() > 1) {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            if(a - b != 0)\\n                pq.add(Math.abs(a - b));\\n        }\\n        if(pq.size() == 1)\\n            return pq.poll();\\n        else\\n            return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295005,
                "title": "java-simplest-easiest-priority-queue",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int s : stones) {\\n            queue.add(s);\\n        }\\n        while (queue.size() > 1) {\\n            int weight1 = queue.poll();\\n            int weight2 = queue.poll();\\n            queue.add(weight1 - weight2);\\n        }\\n        return queue.size() == 0? 0 : queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int s : stones) {\\n            queue.add(s);\\n        }\\n        while (queue.size() > 1) {\\n            int weight1 = queue.poll();\\n            int weight2 = queue.poll();\\n            queue.add(weight1 - weight2);\\n        }\\n        return queue.size() == 0? 0 : queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294959,
                "title": "python-4-liner",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        for _ in range(len(stones) - 1):\\n            bisect.insort(stones, stones.pop() - stones.pop())\\n        return stones[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        for _ in range(len(stones) - 1):\\n            bisect.insort(stones, stones.pop() - stones.pop())\\n        return stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294949,
                "title": "easy-and-concise-c",
                "content": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        \\n        if(!a.size())\\n            return 0;\\n        int i,j = a[0];\\n        int n = a.size();\\n        \\n        while(a.size()>1)\\n        {\\n            sort(a.begin(),a.end(),greater<int>());\\n            a[1]=a[0]-a[1];\\n            a.erase(a.begin());\\n        }\\n        return a[0];\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        \\n        if(!a.size())\\n            return 0;\\n        int i,j = a[0];\\n        int n = a.size();\\n        \\n        while(a.size()>1)\\n        {\\n            sort(a.begin(),a.end(),greater<int>());\\n            a[1]=a[0]-a[1];\\n            a.erase(a.begin());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4105275,
                "title": "beats-100-of-c-users",
                "content": "![image.png](https://assets.leetcode.com/users/images/606b6310-cfdc-4d82-9375-496a448765e6_1695990050.8100019.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Simple application on priority queues. \\n* All we just need to get the biggest two elements in the priority queue, and then check if both are equal, get rid of both of them, else, insert the new stone with the new value. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Create a priority queue of integers. \\n* insert all elements in it. \\n* while there are still some stones :\\n    * get the top element with biggest value. \\n    * remove it from the queue\\n    * if there are no more stones, return that stone. \\n    * else get the second stone. \\n    * check if both are equal, then just continue. \\n    * else check which is smaller, then subtract it from the bigger, then insert the result in the queue again.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n* O(n + m), where n is the number of node, and m is the largest possible value. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n* O(n) for the priority queue. \\n# Code\\n```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base ::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n\\nint lastStoneWeight(vector<int> &stones)\\n{\\n    DPSolver;\\n    priority_queue<int> pq;\\n    for (auto stone : stones)\\n        pq.push(stone);\\n\\n    while (pq.size())\\n    {\\n        int top1 = pq.top();\\n        pq.pop();\\n        if (pq.empty())\\n            return top1;\\n        int top2 = pq.top();\\n        pq.pop();\\n        if (top1 <= top2)\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top2 -= top1;\\n                pq.push(top2);\\n            }\\n        }\\n        else\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top1 -= top2;\\n                pq.push(top1);\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base ::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n\\nint lastStoneWeight(vector<int> &stones)\\n{\\n    DPSolver;\\n    priority_queue<int> pq;\\n    for (auto stone : stones)\\n        pq.push(stone);\\n\\n    while (pq.size())\\n    {\\n        int top1 = pq.top();\\n        pq.pop();\\n        if (pq.empty())\\n            return top1;\\n        int top2 = pq.top();\\n        pq.pop();\\n        if (top1 <= top2)\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top2 -= top1;\\n                pq.push(top2);\\n            }\\n        }\\n        else\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top1 -= top2;\\n                pq.push(top1);\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3996347,
                "title": "c-solution-using-maxheap-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nput all the elements in a maxheap and keep comparing the top two elements until the heap is empty or only one element is left in heap.\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int x: stones){\\n            pq.push(x);\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            int m = pq.top();\\n            pq.pop();\\n            if(pq.empty()) ans = m;\\n            if(!pq.empty()){\\n                if(m == pq.top()){\\n                    pq.pop();\\n                }\\n                else if(pq.top() < m){\\n                    m = m - pq.top();\\n                    pq.pop();\\n                    pq.push(m);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int x: stones){\\n            pq.push(x);\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            int m = pq.top();\\n            pq.pop();\\n            if(pq.empty()) ans = m;\\n            if(!pq.empty()){\\n                if(m == pq.top()){\\n                    pq.pop();\\n                }\\n                else if(pq.top() < m){\\n                    m = m - pq.top();\\n                    pq.pop();\\n                    pq.push(m);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935461,
                "title": "0ms-solution-c-maxheap",
                "content": "# Intuition\\nThe problem asks us to repeatedly smash the two largest stones until there is either one stone left or no stones left. To do this efficiently, we can use a max-heap (priority_queue) to always select the two largest stones for smashing.\\n\\n# Approach\\n1. Initialize a max-heap (priority_queue) called maxheap.\\n2. Add all the stones to the maxheap.\\n3. Continue the following steps until there is either one stone or no stones left:\\n   a. Check if the size of maxheap is 1. If so, return the value of the last remaining stone as it is the final result.\\n   b. Check if the size of maxheap is 0. If so, return 0 because all stones have been smashed and there are no stones left.\\n   c. Pop the first largest stone (maxheap.top()) from maxheap and store it in the variable \\'first\\'.\\n   d. Pop the second largest stone (maxheap.top()) from maxheap and store it in the variable \\'second\\'.\\n   e. Check if \\'first\\' is not equal to \\'second\\'. If they are not equal, it means they can be smashed into a smaller stone.\\n   f. Push the difference between \\'first\\' and \\'second\\' back into maxheap to represent the smashed stone.\\n4. Return the result obtained from step 3a.\\n\\n# Complexity\\n- Time complexity:\\n  - Inserting all n stones into the maxheap initially takes O(n * log(n)) time.\\n  - In each iteration, we perform constant time operations until the size of maxheap reduces to 1 or 0. Therefore, the overall time complexity is O(n * log(n)) where n is the number of stones.\\n- Space complexity:\\n  - The space complexity is O(n) to store the maxheap, where n is the number of stones.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> maxheap;\\n        for(auto elm: stones)\\n        {\\n            maxheap.push(elm);\\n        }\\n        while(true)\\n        {\\n            if(maxheap.size()==1)\\n            return maxheap.top();\\n            if(maxheap.size()==0)\\n            return 0;\\n            int first=maxheap.top();\\n            maxheap.pop();\\n            int second= maxheap.top();\\n            maxheap.pop();\\n            if(first!=second)\\n            {\\n                maxheap.push((first-second));\\n                \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> maxheap;\\n        for(auto elm: stones)\\n        {\\n            maxheap.push(elm);\\n        }\\n        while(true)\\n        {\\n            if(maxheap.size()==1)\\n            return maxheap.top();\\n            if(maxheap.size()==0)\\n            return 0;\\n            int first=maxheap.top();\\n            maxheap.pop();\\n            int second= maxheap.top();\\n            maxheap.pop();\\n            if(first!=second)\\n            {\\n                maxheap.push((first-second));\\n                \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478482,
                "title": "python-simple-clean-solution-using-python-library",
                "content": "# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = SortedList(stones)\\n        while len(s) > 1:\\n            y = s.pop()\\n            x = s.pop()\\n\\n            if x != y:\\n                y -= x\\n                s.add(y)\\n        if s:\\n            return s[0]\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = SortedList(stones)\\n        while len(s) > 1:\\n            y = s.pop()\\n            x = s.pop()\\n\\n            if x != y:\\n                y -= x\\n                s.add(y)\\n        if s:\\n            return s[0]\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478283,
                "title": "0ms-runtime-c-easy-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& A) {\\n          priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& A) {\\n          priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451681,
                "title": "easy-c-solution-beats-100-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n            /* please upvote if found solution helpful \\uD83D\\uDE04*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       priority_queue<int>sequence(stones.begin(),stones.end());\\n\\n       //using priority queue to get access to heighest weight values direcly\\n\\n       while(sequence.size()>1){\\n           int a=sequence.top();\\n           sequence.pop();\\n           int b=sequence.top();\\n           sequence.pop();\\n\\n           //now we have got the top two values\\n           //now we want to reduce their weight if they are not equal\\n           if(a!=b){\\n               sequence.push(abs(a-b));\\n           }\\n       }\\n       return sequence.empty() ?  0 :  sequence.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n            /* please upvote if found solution helpful \\uD83D\\uDE04*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       priority_queue<int>sequence(stones.begin(),stones.end());\\n\\n       //using priority queue to get access to heighest weight values direcly\\n\\n       while(sequence.size()>1){\\n           int a=sequence.top();\\n           sequence.pop();\\n           int b=sequence.top();\\n           sequence.pop();\\n\\n           //now we have got the top two values\\n           //now we want to reduce their weight if they are not equal\\n           if(a!=b){\\n               sequence.push(abs(a-b));\\n           }\\n       }\\n       return sequence.empty() ?  0 :  sequence.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451440,
                "title": "easy-solution-in-c-simple-using-loop-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n5 5\\n[1 1 2 4 7 8] \\n[1 1 2 4 0 1]  \\n\\n4 5\\n[0 1 1 1 2 4] \\n[0 1 1 1 0 2]\\n\\n3 5\\n[0 0 1 1 1 2]\\n[0 0 1 1 0 1]  \\n\\n2 5\\n[0 0 0 1 1 1 ]\\n[0 0 0 1 0 0]\\n\\n1 5\\n[0 0 0 0 0 1]\\n[0 0 0 0 0 1]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       int i=stones.size()-1;\\n       int j=stones.size()-1;\\n       while(j>0){\\n            sort(stones.begin(),stones.end());\\n            if(stones[i]==stones[i-1]){\\n                stones[i]=0;\\n                stones[i-1]=0;\\n            }\\n            else{\\n                stones[i]=stones[i]-stones[i-1];\\n                stones[i-1]=0;\\n            }\\n            j--;\\n       }\\n        int k=stones.size()-1;\\n        return stones[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       int i=stones.size()-1;\\n       int j=stones.size()-1;\\n       while(j>0){\\n            sort(stones.begin(),stones.end());\\n            if(stones[i]==stones[i-1]){\\n                stones[i]=0;\\n                stones[i-1]=0;\\n            }\\n            else{\\n                stones[i]=stones[i]-stones[i-1];\\n                stones[i-1]=0;\\n            }\\n            j--;\\n       }\\n        int k=stones.size()-1;\\n        return stones[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451266,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < stones.length; i++) {\\n            list.add(stones[i]);\\n        }\\n\\n        while (list.size() > 1) {\\n            Collections.sort(list);\\n            int x = list.get(list.size() - 2);\\n            int y = list.get(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            if (x != y) {\\n                list.add(y - x);\\n            }\\n        }\\n\\n        return list.isEmpty() ? 0 : list.get(0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < stones.length; i++) {\\n            list.add(stones[i]);\\n        }\\n\\n        while (list.size() > 1) {\\n            Collections.sort(list);\\n            int x = list.get(list.size() - 2);\\n            int y = list.get(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            if (x != y) {\\n                list.add(y - x);\\n            }\\n        }\\n\\n        return list.isEmpty() ? 0 : list.get(0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450669,
                "title": "java-priorityqueue-1-ms",
                "content": "\\n# Complexity\\n- Time complexity:\\nO ( nlog(n) )\\n\\n- Space complexity:\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int res=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i: stones){\\n            pq.add(i);\\n        }\\n        while(!pq.isEmpty()){\\n            if(pq.size()==1){\\n                return pq.poll();\\n            }\\n            int f=pq.poll();\\n            int s=pq.poll();\\n            if(Math.abs(f-s)!=0){\\n                pq.add(Math.abs(f-s));\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int res=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i: stones){\\n            pq.add(i);\\n        }\\n        while(!pq.isEmpty()){\\n            if(pq.size()==1){\\n                return pq.poll();\\n            }\\n            int f=pq.poll();\\n            int s=pq.poll();\\n            if(Math.abs(f-s)!=0){\\n                pq.add(Math.abs(f-s));\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449920,
                "title": "most-optimised-solution-with-detailed-explanation-clean-code",
                "content": "\\n\\n# Approach\\nWe are given an array of integers stones where stones[i] is the weight of the ith stone. We need to play a game with the stones, where on each turn, we choose the heaviest two stones and smash them together. The result of this smash is:\\n\\n- If x == y, both stones are destroyed.\\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\\nThe game continues until there is at most one stone left, and we need to return the weight of the last remaining stone. If there are no stones left, we need to return 0.\\n\\nTo solve this problem, we can simulate the game using a priority queue (heap) in C++. The priority queue can be used to keep track of the heaviest stones.\\n\\nWe can start by inserting all the stones into the priority queue. The priority queue will automatically sort the stones in descending order based on their weight. Therefore, the heaviest stone will be at the front of the queue.\\n\\nIn each turn of the game, we can remove the two heaviest stones from the priority queue using the top() method. We can then smash the stones together according to the rules of the game and insert the resulting stone (if any) back into the priority queue using the push() method.\\n\\nWe can continue this process until there is only one stone left in the priority queue, which will be the result of the game. We can then return the weight of this stone using the top() method.\\n\\nIf there are no stones left in the priority queue, we need to return 0.\\n\\nHere is the step-by-step process of the algorithm:\\n\\n1. Create a priority queue pq and insert all the stones into it.\\n2. While pq has more than 1 stone:\\n- Remove the two heaviest stones y and x from pq.\\n- If x != y, calculate the difference y - x and insert it back into pq.\\n3. Return the weight of the last remaining stone in pq (using the top() method) if there is one, otherwise return 0.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(std::vector<int>& stones) {\\n        std::sort(stones.rbegin(), stones.rend());\\n        while (stones.size() > 1) {\\n            int y = stones[0]; \\n            int x = stones[1];\\n            stones.erase(stones.begin(), stones.begin()+2);\\n            if (x != y) {\\n                stones.insert(std::upper_bound(stones.begin(), stones.end(), y-x, std::greater<int>()), y-x);\\n            }\\n        }\\n        return stones.empty() ? 0 : stones[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(std::vector<int>& stones) {\\n        std::sort(stones.rbegin(), stones.rend());\\n        while (stones.size() > 1) {\\n            int y = stones[0]; \\n            int x = stones[1];\\n            stones.erase(stones.begin(), stones.begin()+2);\\n            if (x != y) {\\n                stones.insert(std::upper_bound(stones.begin(), stones.end(), y-x, std::greater<int>()), y-x);\\n            }\\n        }\\n        return stones.empty() ? 0 : stones[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449625,
                "title": "simple-priorityqueue-question-java-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++) q.offer(stones[i]);\\n        while(q.size() > 1) {\\n            int a = q.poll();\\n            int b = q.poll();\\n            q.offer(a-b);\\n        }\\n        if(q.isEmpty()) return 0;\\n        else return q.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++) q.offer(stones[i]);\\n        while(q.size() > 1) {\\n            int a = q.poll();\\n            int b = q.poll();\\n            q.offer(a-b);\\n        }\\n        if(q.isEmpty()) return 0;\\n        else return q.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1872390,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1828053,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872557,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1566055,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872394,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1576558,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1575436,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872441,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872758,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872432,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872390,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1828053,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872557,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1566055,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872394,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1576558,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1575436,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872441,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872758,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872432,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1576588,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1992059,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1940250,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872810,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872776,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872771,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872765,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872538,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872524,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872450,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Swaps to Arrange a Binary Grid",
        "question_content": "<p>Given an <code>n x n</code> binary <code>grid</code>, in one step you can choose two <strong>adjacent rows</strong> of the grid and swap them.</p>\n\n<p>A grid is said to be <strong>valid</strong> if all the cells above the main diagonal are <strong>zeros</strong>.</p>\n\n<p>Return <em>the minimum number of steps</em> needed to make the grid valid, or <strong>-1</strong> if the grid cannot be valid.</p>\n\n<p>The main diagonal of a grid is the diagonal that starts at cell <code>(1, 1)</code> and ends at cell <code>(n, n)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/28/fw.jpg\" style=\"width: 750px; height: 141px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,1],[1,1,0],[1,0,0]]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/16/e2.jpg\" style=\"width: 270px; height: 270px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> All rows are similar, swaps have no effect on the grid.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/16/e3.jpg\" style=\"width: 200px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,0],[1,1,0],[1,1,1]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code> <code>== grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 767912,
                "title": "java-16-lines-bubble-sort-with-line-by-line-explanation-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/62ae8e60-d867-4e7d-8b37-06e5b5a15cc9_1596343724.4730008.png)\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, res=0;\\n        List<Integer> row = new LinkedList<>();\\n        for (int i=0; i<n; i++){\\n            int trailingZeroCnt=0;\\n            for (int j=n-1; j>-1 && grid[i][j]==0; j--) trailingZeroCnt++;\\n            row.add(trailingZeroCnt);\\n        }\\n        for (int curRowIdx=0, minTrailingZeros=n-1; curRowIdx<n; curRowIdx++, minTrailingZeros--){\\n            int satisfiedRowIdx =curRowIdx;\\n            while (satisfiedRowIdx <n && row.get(satisfiedRowIdx)<minTrailingZeros) satisfiedRowIdx++;\\n            if (satisfiedRowIdx ==n) return -1;\\n            int toRemove = row.remove(satisfiedRowIdx);\\n            row.add(curRowIdx, toRemove);\\n            res+=satisfiedRowIdx -curRowIdx;\\n        }\\n        return res;\\n    }\\n}\\n```\\nHappy Coding!\\n\\nPS: I\\'m glad that someone thinks this solution is from a textbook, but I just wrote this down after solving it in contest :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, res=0;\\n        List<Integer> row = new LinkedList<>();\\n        for (int i=0; i<n; i++){\\n            int trailingZeroCnt=0;\\n            for (int j=n-1; j>-1 && grid[i][j]==0; j--) trailingZeroCnt++;\\n            row.add(trailingZeroCnt);\\n        }\\n        for (int curRowIdx=0, minTrailingZeros=n-1; curRowIdx<n; curRowIdx++, minTrailingZeros--){\\n            int satisfiedRowIdx =curRowIdx;\\n            while (satisfiedRowIdx <n && row.get(satisfiedRowIdx)<minTrailingZeros) satisfiedRowIdx++;\\n            if (satisfiedRowIdx ==n) return -1;\\n            int toRemove = row.remove(satisfiedRowIdx);\\n            row.add(curRowIdx, toRemove);\\n            res+=satisfiedRowIdx -curRowIdx;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768020,
                "title": "c-easy-solution-greedy-prove-example",
                "content": "Observation:\\nLet\\'s use Example 1 for illustration:\\n[[0,0,1],[1,1,0],[1,0,0]]\\ntailing zero counts are:   [0, 1, 2]  (starting status)\\nThe desired final goal is: [2,1, 0]   (ending status)\\n\\nSo, the problems is converted to find the minimal ajacent swaping from starting status to ending status:\\n\\nComment: If you think this post is helpful, please help upvote.\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        vector<int> t(n); //t[i]: tailing zero count for i-th row        \\n        for(int i=0;i<n;i++){\\n            int count = 0;\\n            for(int j = n;--j>=0 && !grid[i][j]; )  count++;                \\n            t[i] = count;\\n        }\\n        int ans = 0;        \\n        for(int i=0;i< n;i++){\\n            int k = i;\\n            int req = n-1 - i; // desired tailing zero count\\n            while(k<n && t[k]<req) k++; // greedily find first swaping candidate and log the result into k. Note1\\n            if(k==n) return -1; // k is out of range. Fail in searching\\n\\n            //Core part of the question: moving up k-th row up, moving down [i, k-1\\n            //Part 1: move k-th row up to i-th row\\n            ans += k-i; // accumulate the operation cost of moving k to i\\n            \\n            //Part 2: move the rest involved row downward by offset 1\\n            while(k>i){ // simulate swaping operation of two adjacent rows in range of [i, k-1 ]\\n                t[k] = t[k-1];\\n                k--;\\n            }\\n        }    \\n        \\n        return ans;\\n    }\\n};\\n/*Note 1: why dose greedy approach work? \\nRecall the row scanning is performed one by one from row 0, which ask most tailing 0; \\nSuppose, current row (i-th row) asks for a row with at least 4 zeros, and the neaerst downward row (j-th) has 5 tailing zeros. You can greedily but aslo safely choose it as candidate. any rows after than i-th row will ask for less than 4 tailing rows. So you greedy approach will cause no trouble at all.\\n*/\\n```\\nreference:\\n[1] https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/767974/C%2B%2B-Solution",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        vector<int> t(n); //t[i]: tailing zero count for i-th row        \\n        for(int i=0;i<n;i++){\\n            int count = 0;\\n            for(int j = n;--j>=0 && !grid[i][j]; )  count++;                \\n            t[i] = count;\\n        }\\n        int ans = 0;        \\n        for(int i=0;i< n;i++){\\n            int k = i;\\n            int req = n-1 - i; // desired tailing zero count\\n            while(k<n && t[k]<req) k++; // greedily find first swaping candidate and log the result into k. Note1\\n            if(k==n) return -1; // k is out of range. Fail in searching\\n\\n            //Core part of the question: moving up k-th row up, moving down [i, k-1\\n            //Part 1: move k-th row up to i-th row\\n            ans += k-i; // accumulate the operation cost of moving k to i\\n            \\n            //Part 2: move the rest involved row downward by offset 1\\n            while(k>i){ // simulate swaping operation of two adjacent rows in range of [i, k-1 ]\\n                t[k] = t[k-1];\\n                k--;\\n            }\\n        }    \\n        \\n        return ans;\\n    }\\n};\\n/*Note 1: why dose greedy approach work? \\nRecall the row scanning is performed one by one from row 0, which ask most tailing 0; \\nSuppose, current row (i-th row) asks for a row with at least 4 zeros, and the neaerst downward row (j-th) has 5 tailing zeros. You can greedily but aslo safely choose it as candidate. any rows after than i-th row will ask for less than 4 tailing rows. So you greedy approach will cause no trouble at all.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768010,
                "title": "python-clean-greedy-solution-with-detailed-explanation-o-n-2",
                "content": "**Explaination**\\n\\nFirst we count the number of trailing zeroes in each row and store the numbers in `arr`.\\n\\nFor `grid = [[0,0,1],[1,1,0],[1,0,0]]`, we have `arr = [0,1,2]`.\\n\\nWe are hoping to rearrange `arr` so that `arr[i] >= n - i - 1`. In this case, `arr` will become `[2,1,0]` after rearrangement.\\n\\nWe can use greedy approach to do the rearrangement: \\n1. find the smallest `j` such that `j >= i` and `arr[j] >= n - i - 1`\\n2. do `j - i` swaps to bring `arr[j]` to index `i`\\n\\nThe reason why greedy approach works is that `arr` will be in \"descending\" order after rearragement, so it\\'s fine to push smaller numbers downwards. \\n\\nHere the \"descending\" order is not strict. `arr` is good as long as `arr[i] >= n - i - 1`. For example, `arr = [4,3,4,4]` is valid.\\n\\n<br />\\n\\n**Complexity**\\n\\nTime complexity: `O(N^2)`\\nSpace complexity: `O(N)`\\n\\n<br />\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def count(arr):\\n            ans = 0\\n            for i in range(n-1, -1, -1):\\n                if arr[i] == 0:\\n                    ans += 1\\n                else:\\n                    break\\n            return ans\\n            \\n        arr = [count(row) for row in grid]\\n        ans = 0\\n        for i in range(n):\\n            target = n - i - 1\\n            if arr[i] >= target:\\n                continue\\n            flag = False\\n            for j in range(i+1, n):\\n                if arr[j] >= target:\\n                    flag = True\\n                    ans += (j - i)\\n                    arr[i+1:j+1] = arr[i:j]\\n                    break\\n            if not flag:\\n                return -1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def count(arr):\\n            ans = 0\\n            for i in range(n-1, -1, -1):\\n                if arr[i] == 0:\\n                    ans += 1\\n                else:\\n                    break\\n            return ans\\n            \\n        arr = [count(row) for row in grid]\\n        ans = 0\\n        for i in range(n):\\n            target = n - i - 1\\n            if arr[i] >= target:\\n                continue\\n            flag = False\\n            for j in range(i+1, n):\\n                if arr[j] >= target:\\n                    flag = True\\n                    ans += (j - i)\\n                    arr[i+1:j+1] = arr[i:j]\\n                    break\\n            if not flag:\\n                return -1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769090,
                "title": "java-count-trailing-zeros-greedy-solution-with-visualization",
                "content": "Since we want all zeros above the diagonal lines, We only care about the trailing zeros of each row. So the matrix can be simplified into a 1D array containing the trailing zeros of each row. \\n\\nThen we want to satisfy the trailing zero requirements for each row to make all zeros above diagonal. For example if it was a 4 * 4 Matrix we want \\n```\\ntrailing zeros >= 3 for row 1\\ntrailing zeros >= 2 for row 2\\ntrailing zeros >= 1 for row 3\\nno requirement for row 4\\n```\\n![image](https://assets.leetcode.com/users/images/7244744f-839b-4ae5-8ad3-88490b54a95d_1596378127.094143.png)\\n\\nThe greedy approach is here: For each row from top to bottom we want to go down to subsequent rows to find the closest row that satisfy the requirement for this row and perform the swaps. Notice that since we want minimum number of swaps we don\\'t necessarily want the biggest trailing zero number, since it might be too far away and cost more steps. We simply want the closest one that meet the requirement. \\n\\nHere is an example: \\n![image](https://assets.leetcode.com/users/images/ad36f0ca-0076-4900-a2fb-27ccf584e17e_1596378351.518053.png)\\nWe can see that for the first row we directly use the row with 5 zeros because it was two steps away. For the second row since it is already satisfied, we don\\'t need to pull the row with 4 trailing zeros up. Then the 1D array is not completly sorted in the end but we meet all the requirements. \\n\\nIf at any stage we can\\'t find any more qualifying numbers, then we return -1. \\n\\nHere is my code: \\n```Java\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] conseq0 = new int[n]; // Count trailing zeros for all rows\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int counter = 0;\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                if (grid[i][j] != 0)\\n                    break;\\n                counter++;\\n            }\\n            conseq0[i] = counter;\\n        }\\n        int numNeeded = n - 1;\\n        int ans = 0;\\n        while (numNeeded > 0)\\n        {\\n            boolean flag = false;\\n            for (int i = n - numNeeded - 1; i < n; ++i)\\n            {\\n                if (conseq0[i] >= numNeeded)\\n                {\\n                    //Perform the swaps\\n                    int temp = conseq0[i];\\n                    for (int k = i; k > n - numNeeded - 1; --k)\\n                        conseq0[k] = conseq0[k - 1];\\n                    conseq0[n - numNeeded - 1] = temp;\\n                    flag = true;\\n                    //Calculate the number of swaps\\n                    ans += i - (n - numNeeded - 1);\\n                    break;\\n                }\\n            }\\n            if (!flag)\\n                return -1;\\n            numNeeded--;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\ntrailing zeros >= 3 for row 1\\ntrailing zeros >= 2 for row 2\\ntrailing zeros >= 1 for row 3\\nno requirement for row 4\\n```\n```Java\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] conseq0 = new int[n]; // Count trailing zeros for all rows\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int counter = 0;\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                if (grid[i][j] != 0)\\n                    break;\\n                counter++;\\n            }\\n            conseq0[i] = counter;\\n        }\\n        int numNeeded = n - 1;\\n        int ans = 0;\\n        while (numNeeded > 0)\\n        {\\n            boolean flag = false;\\n            for (int i = n - numNeeded - 1; i < n; ++i)\\n            {\\n                if (conseq0[i] >= numNeeded)\\n                {\\n                    //Perform the swaps\\n                    int temp = conseq0[i];\\n                    for (int k = i; k > n - numNeeded - 1; --k)\\n                        conseq0[k] = conseq0[k - 1];\\n                    conseq0[n - numNeeded - 1] = temp;\\n                    flag = true;\\n                    //Calculate the number of swaps\\n                    ans += i - (n - numNeeded - 1);\\n                    break;\\n                }\\n            }\\n            if (!flag)\\n                return -1;\\n            numNeeded--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768003,
                "title": "java-bubble-sort",
                "content": "The idea is for each row, we count the number of zeros from the end and try to assign a target row for it. For example, if row 1 has 0 zeros, then it should goes to row n-1. If a row has 1 ending zero, it should goes to row n-2.\\nOnce we found the target indexes, we just need to do a bubble sort to count how many time we want to swap.\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        HashSet<Integer> found = new HashSet();\\n        int steps = 0;\\n        \\n        int[] arr = new int[n];        \\n        for(int i=0; i<n; i++){\\n            int count = 0;\\n            int j = n-1;\\n            while(j>=0 && grid[i][j]==0) {\\n                count++;\\n                j--;\\n            }            \\n            for(int k=n-1; k>=0; k--){\\n                if(count>=k && !found.contains(k)){ //move from row i to row n-1-k\\n                    found.add(k);               \\n                    arr[i] = n-1-k;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(found.size()!=n) return -1;\\n        \\n        return bubblesort(arr);\\n    }\\n    private int bubblesort(int[] arr){\\n        int k=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length-i-1; j++){\\n                if(arr[j]>arr[j+1]){\\n                    int tmp = arr[j];\\n                    arr[j] = arr[j+1];\\n                    arr[j+1] = tmp;\\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        HashSet<Integer> found = new HashSet();\\n        int steps = 0;\\n        \\n        int[] arr = new int[n];        \\n        for(int i=0; i<n; i++){\\n            int count = 0;\\n            int j = n-1;\\n            while(j>=0 && grid[i][j]==0) {\\n                count++;\\n                j--;\\n            }            \\n            for(int k=n-1; k>=0; k--){\\n                if(count>=k && !found.contains(k)){ //move from row i to row n-1-k\\n                    found.add(k);               \\n                    arr[i] = n-1-k;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(found.size()!=n) return -1;\\n        \\n        return bubblesort(arr);\\n    }\\n    private int bubblesort(int[] arr){\\n        int k=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length-i-1; j++){\\n                if(arr[j]>arr[j+1]){\\n                    int tmp = arr[j];\\n                    arr[j] = arr[j+1];\\n                    arr[j+1] = tmp;\\n                    k++;\\n                }\\n            }\\n        }\\n        \\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769651,
                "title": "c-solution-with-steps-explained-beats-100",
                "content": "**Approach :** **In the grid in 1st row we need n-1 0s at the end, 2nd row n-2 0s, 3rd row n-3 0s and so on.**\\nProblem reduces to finding the zeroes at the end of each row and sorting it in decreasing order by **using operation :- swapping any two adjacent elements**\\nso we first find the number of 0s at the end of each row.\\n1. let\\'s say the grid is ```[[0,0,1],[1,1,0],[1,0,0]]```.\\n2. so the number of zeroes at the end in each row comes out to be ```[0,1,2]``` let\\'s call it array a.\\n3. now first row should have n-1 i.e 2 0s at the end so we have to bring 2 from 3rd position to 1st position in array a.\\n4. this can be done in 2 swaps and the array becomes ```[2,0,1]```. now first index is done since we have got the answer here.\\n5. repeat these steps for all the index and update the swaps count which will be the answer.\\n\\nPls Upvote if you like it.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size(),res=0;\\n        vector<int>a(n);\\n        for(int i=0 ; i<n ; i++)              //finding the zeroes at the end of each row.\\n        {\\n            int j=n-1,cnt=0;\\n            while(j>=0 and grid[i][j]==0) {cnt++;j--;}\\n            a[i]=cnt;\\n        }\\n        for(int i=0 ; i<n ; i++)               //for calculating the swaps count or sorting the array decreasing.\\n        {\\n            if(a[i]<n-1-i)\\n            {\\n                int j=i;\\n                while(j<n and a[j]<n-1-i) j++;\\n                if(j==n) return -1;\\n                while(i<j)\\n                {\\n                    swap(a[j],a[j-1]);\\n                    res++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```[[0,0,1],[1,1,0],[1,0,0]]```\n```[0,1,2]```\n```[2,0,1]```\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size(),res=0;\\n        vector<int>a(n);\\n        for(int i=0 ; i<n ; i++)              //finding the zeroes at the end of each row.\\n        {\\n            int j=n-1,cnt=0;\\n            while(j>=0 and grid[i][j]==0) {cnt++;j--;}\\n            a[i]=cnt;\\n        }\\n        for(int i=0 ; i<n ; i++)               //for calculating the swaps count or sorting the array decreasing.\\n        {\\n            if(a[i]<n-1-i)\\n            {\\n                int j=i;\\n                while(j<n and a[j]<n-1-i) j++;\\n                if(j==n) return -1;\\n                while(i<j)\\n                {\\n                    swap(a[j],a[j-1]);\\n                    res++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768030,
                "title": "python3-bubble-ish-sort",
                "content": "Algo \\nBasic idea is bubble sort. Here, we transform each row into a number which the location of last index of 1. Then, we use a modified bubble sort algo to compute the `ans`. For each row, we find the first value which can be moved to this position via swaps, and update the `ans`. \\n\\nEdit: added comments to aid understanding. \\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        #summarizing row into number \\n        row = [0]*m \\n        for i in range(m):\\n            row[i] = next((j for j in reversed(range(n)) if grid[i][j]), 0)\\n        \\n        ans = 0\\n        #sequentially looking for row to fill in \\n        for k in range(m): \\n            for i, v in enumerate(row): \\n                if v <= k: #enough trailing zeros \\n                    ans += i\\n                    row.pop(i) #value used \\n                    break \\n            else: return -1 #cannot find such row \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        #summarizing row into number \\n        row = [0]*m \\n        for i in range(m):\\n            row[i] = next((j for j in reversed(range(n)) if grid[i][j]), 0)\\n        \\n        ans = 0\\n        #sequentially looking for row to fill in \\n        for k in range(m): \\n            for i, v in enumerate(row): \\n                if v <= k: #enough trailing zeros \\n                    ans += i\\n                    row.pop(i) #value used \\n                    break \\n            else: return -1 #cannot find such row \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 768292,
                "title": "java-solution-with-explanation-for-each-step",
                "content": "The Idea :\\nIf we can swap the rows such that we can get a `Binary Grid`\\n\\n1. For i\\'th row to be fulfilled, there should be a row with (n - i - 1) trailing zeros \\n2. If we can\\'t find a candidate row then we can\\'t get a \\'Binary Grid\\'\\n3. If we found a candidate row, then we need to bubble it to the i\\'th index, since we can ONLY SWAP ADJECENT ROWS, we need |candidateIndex - i| swaps. And need to actually swap the items so that the subsequent steps can operate on the resulted array\\n\\n\\n```\\npublic int minSwaps(int[][] grid) {\\n        int[] numberOfTrailingZerosAtEachRow = new int[grid.length];\\n\\n        // below is to fill up the numberOfTrailingZerosAtEachRow array\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = grid.length - 1; j >= 0; --j) {\\n                if (grid[i][j] == 0) {\\n                    numberOfTrailingZerosAtEachRow[i]++;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int n = numberOfTrailingZerosAtEachRow.length;\\n        int count = 0;\\n\\n        // we need to change the numberOfTrailingZerosAtEachRow such that\\n        // each index `i` has at least (n - i - 1) trailing zeros\\n\\n        // iterate through the numberOfTrailingZerosAtEachRow\\n        for (int i = 0; i < n; ++i) {\\n            // the candidate row should have at least `requiredZerosAtThisIndex` trailing zeros\\n            int requiredZerosAtThisIndex = n - i - 1;\\n            \\n            //  let\\'s find a candidate row to be the i\\'th row, no need to start from beginning, we should have fixed each previous rows, so no need to consider prevous ones \\n            for (int j = i; j < n; ++j) {\\n                // this is the condition to be a candidate for i\\'th row\\n                if (numberOfTrailingZerosAtEachRow[j] >= requiredZerosAtThisIndex) {\\n                    // since we found the candidate row, bubble-up the candidate row to the i\\'th position\\n                    for (int k = j; k > i; --k) {\\n                        int temp = numberOfTrailingZerosAtEachRow[k];\\n                        numberOfTrailingZerosAtEachRow[k] = numberOfTrailingZerosAtEachRow[k - 1];\\n                        numberOfTrailingZerosAtEachRow[k - 1] = temp;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// let\\'s count how many steps it took to bubble up, ultimately this is the answer we want right !!!\\n                        count++;\\n                    }\\n                    \\n                    // we filled the i\\'th position, let\\'s continue with the next position\\n                    break;\\n                }\\n                \\n                // if this is true, okay we have reached the end of the array, and we didn\\'t find a candidate for the i\\'th row\\n                if (j == n - 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        // return the swap count\\n        return count;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "The Idea :\\nIf we can swap the rows such that we can get a `Binary Grid`\\n\\n1. For i\\'th row to be fulfilled, there should be a row with (n - i - 1) trailing zeros \\n2. If we can\\'t find a candidate row then we can\\'t get a \\'Binary Grid\\'\\n3. If we found a candidate row, then we need to bubble it to the i\\'th index, since we can ONLY SWAP ADJECENT ROWS, we need |candidateIndex - i| swaps. And need to actually swap the items so that the subsequent steps can operate on the resulted array\\n\\n\\n```\\npublic int minSwaps(int[][] grid) {\\n        int[] numberOfTrailingZerosAtEachRow = new int[grid.length];\\n\\n        // below is to fill up the numberOfTrailingZerosAtEachRow array\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = grid.length - 1; j >= 0; --j) {\\n                if (grid[i][j] == 0) {\\n                    numberOfTrailingZerosAtEachRow[i]++;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int n = numberOfTrailingZerosAtEachRow.length;\\n        int count = 0;\\n\\n        // we need to change the numberOfTrailingZerosAtEachRow such that\\n        // each index `i` has at least (n - i - 1) trailing zeros\\n\\n        // iterate through the numberOfTrailingZerosAtEachRow\\n        for (int i = 0; i < n; ++i) {\\n            // the candidate row should have at least `requiredZerosAtThisIndex` trailing zeros\\n            int requiredZerosAtThisIndex = n - i - 1;\\n            \\n            //  let\\'s find a candidate row to be the i\\'th row, no need to start from beginning, we should have fixed each previous rows, so no need to consider prevous ones \\n            for (int j = i; j < n; ++j) {\\n                // this is the condition to be a candidate for i\\'th row\\n                if (numberOfTrailingZerosAtEachRow[j] >= requiredZerosAtThisIndex) {\\n                    // since we found the candidate row, bubble-up the candidate row to the i\\'th position\\n                    for (int k = j; k > i; --k) {\\n                        int temp = numberOfTrailingZerosAtEachRow[k];\\n                        numberOfTrailingZerosAtEachRow[k] = numberOfTrailingZerosAtEachRow[k - 1];\\n                        numberOfTrailingZerosAtEachRow[k - 1] = temp;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t// let\\'s count how many steps it took to bubble up, ultimately this is the answer we want right !!!\\n                        count++;\\n                    }\\n                    \\n                    // we filled the i\\'th position, let\\'s continue with the next position\\n                    break;\\n                }\\n                \\n                // if this is true, okay we have reached the end of the array, and we didn\\'t find a candidate for the i\\'th row\\n                if (j == n - 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        // return the swap count\\n        return count;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1724605,
                "title": "only-7-steps-c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int ans = 0;\\n        vector<int> t; // vector to keep track of trailing zeroes\\n        \\n        //Step 1 : Find all trailing zeroes\\n        for(int i=0;i<n;i++){\\n            int zero = 0;\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]) break;\\n                zero++;\\n            }\\n            t.push_back(zero);\\n        }\\n        \\n        //Step 2 : Apply greedy method and solve problem row by row\\n        for(int i=0;i<n;i++){\\n            \\n            int curr = i;\\n            int req = n - 1 - i; // how many zeroes we want at this particular row \\n            \\n            // Step 4 : find nearest row which fullfill our zeroes requirement\\n            while(curr < n and t[curr] < req) curr++;\\n            \\n            // Step 5 : If we are not able to find any such rows --> return -1\\n            if(curr == n) return -1;\\n            \\n            // Step 6 : If we able to find such row then add cost to swap it\\n            ans += curr - i;\\n            \\n            // Step 7 : move all such rows 1 step ahead which are in b/w the source row and dest row\\n            while(curr > 0){\\n                t[curr] = t[curr - 1];\\n                curr--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int ans = 0;\\n        vector<int> t; // vector to keep track of trailing zeroes\\n        \\n        //Step 1 : Find all trailing zeroes\\n        for(int i=0;i<n;i++){\\n            int zero = 0;\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]) break;\\n                zero++;\\n            }\\n            t.push_back(zero);\\n        }\\n        \\n        //Step 2 : Apply greedy method and solve problem row by row\\n        for(int i=0;i<n;i++){\\n            \\n            int curr = i;\\n            int req = n - 1 - i; // how many zeroes we want at this particular row \\n            \\n            // Step 4 : find nearest row which fullfill our zeroes requirement\\n            while(curr < n and t[curr] < req) curr++;\\n            \\n            // Step 5 : If we are not able to find any such rows --> return -1\\n            if(curr == n) return -1;\\n            \\n            // Step 6 : If we able to find such row then add cost to swap it\\n            ans += curr - i;\\n            \\n            // Step 7 : move all such rows 1 step ahead which are in b/w the source row and dest row\\n            while(curr > 0){\\n                t[curr] = t[curr - 1];\\n                curr--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398625,
                "title": "detailed-explanation-c-greedy-bubble",
                "content": "**Intution :**\\n\\n* This problem seem to be really difficult at first sight. But believe me, it is not that Hard once you start observing patterns in it. \\n\\n* Pattern that we need is : for lets say n = 6\\n\\t\\n\\ti=0  : #  0  0  0  0  0\\n\\ti=1  : #  #  0  0  0  0\\n\\ti=2  : #  #  #  0  0  0     \\n\\ti=3  : #  #  #  #  0  0         \\n\\ti=4  : #  #  #  #  #  0\\n \\ti=5  : #  #  #  #  #  #\\n\\t\\n\\t-> Here, for every i, there should be atleast (n-1-i) number of trailing zeros.\\n\\t-> If it is less then, we need to do swaps\\n\\n* Lets try to first find some important patterns : \\n\\t\\n\\t[0,0,1]  : 0 trailing zero < 2  (do swapping)                     [1,0,0] : 2 trailing zero\\n\\t[1,1,0]  : 1 trailing zero  >= 1               after all swaps -> [1,1,0] : 1 trailing zero \\n\\t[1,0,0]  : 2 trailing zero  >= 2                                  [0,0,1] : 0 trailing zero\\n\\t\\n\\t-> Now we can observe here that first row should have at least (n-1) trailing zeros before rightmost 1.\\n\\t-> Also, for ith row, number of trailing zeros should be always greater than [(n-1)-i]\\n\\t-> If there are less number of trailing zeros, then we need to do adjacent swaps from row i till the closest row j(>i) \\n\\t\\t-> such that numbers of trailing zeros is >= (n-1-i)\\n\\t-> Continue this process untill we get no. of trailing zeros >= (n-1-i) for all {i = 0 .... n-1}\\n\\t\\t\\n* If you got this pattern and observation, rest of the problem becomes a calkwalk.\\n* Now, that you have observerd the pattern and the approach lets do a dry run : \\n\\n\\t\\t[0,0,1]\\n\\t\\t[1,1,0]  => array of number of trailing zeros = [0,1,2]\\n\\t\\t[1,0,0]\\n\\t\\t\\n\\t\\t1. for i=0 , trailing zeros = 0 < (n-1-i) = (3-1-0) = 2 \\n\\t\\t\\t-> need to do adjacent swaps with the next closest j such that no. of trailing zeros >= 2\\n\\t\\t\\t-> j = 2 , swaps : [0,2,1] -> [2,0,1] \\n\\t\\t\\t-> final array = [2,0,1], swaps = 2\\n\\t\\t\\n\\t\\t2. for i=1, trailing zeros = 0 < (n-1-i) = (3-1-1) = 1\\n\\t\\t\\t-> need to do adjacent swaps with the next closest j such that no. of trailing zeros >= 1\\n\\t\\t\\t-> j = 2 , swaps : [0,1] -> [1,0] \\n\\t\\t\\t-> final array = [2,0,1], swaps = 1, totalSwaps = 2+1 = 3\\n\\t\\t\\t\\n\\t\\t3. for i=2, trailing zeros = 0 == (n-1-i) = (3-1-2) = 0\\n\\t\\t\\t-> since it is already in correct position, no need to do swaps\\n\\t\\t\\t-> final array = [2,0,1], swaps = 0, totalSwaps = 3+0 = 3\\n\\n# Code : \\n\\n```\\n int minSwaps(vector<vector<int>>& grid) {\\n        \\n\\tint n = grid.size();\\n\\tvector<int> trailingZeros(n, -1);\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tint j = n-1;\\n\\t\\tint zeros = 0;\\n\\t\\twhile(j >= 0 && grid[i][j] == 0)\\n\\t\\t{\\n\\t\\t\\tj--;\\n\\t\\t\\tzeros++;\\n\\t\\t}\\n\\t\\ttrailingZeros[i] = zeros;\\n\\t}\\n\\n\\t// for(auto& i : trailingZeros) cout << i << \" \";\\n\\tint swaps = 0;\\n\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tif(trailingZeros[i] < n-1-i) \\n\\t\\t{\\n\\t\\t\\tint j = i+1;\\n\\t\\t\\twhile(j<n && trailingZeros[j] < n-1-i) j++;\\n\\t\\t\\tif(j == n) return -1;\\n\\n\\t\\t\\twhile(j > i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswap(trailingZeros[j], trailingZeros[j-1]);\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t\\tswaps++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn swaps;\\n}\\n```\\n\\n**Time : O(N^N) in worst case**\\n**Space : O(N)**\\n\\n***Hope you understood the explanation. In case of any query feel free to ask.\\nAlso do upvote !!\\n***",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\n int minSwaps(vector<vector<int>>& grid) {\\n        \\n\\tint n = grid.size();\\n\\tvector<int> trailingZeros(n, -1);\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tint j = n-1;\\n\\t\\tint zeros = 0;\\n\\t\\twhile(j >= 0 && grid[i][j] == 0)\\n\\t\\t{\\n\\t\\t\\tj--;\\n\\t\\t\\tzeros++;\\n\\t\\t}\\n\\t\\ttrailingZeros[i] = zeros;\\n\\t}\\n\\n\\t// for(auto& i : trailingZeros) cout << i << \" \";\\n\\tint swaps = 0;\\n\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\tif(trailingZeros[i] < n-1-i) \\n\\t\\t{\\n\\t\\t\\tint j = i+1;\\n\\t\\t\\twhile(j<n && trailingZeros[j] < n-1-i) j++;\\n\\t\\t\\tif(j == n) return -1;\\n\\n\\t\\t\\twhile(j > i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tswap(trailingZeros[j], trailingZeros[j-1]);\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t\\tswaps++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn swaps;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 767919,
                "title": "python-reduction-to-1d-case-commented-code",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def mv(x): #find the index of largest 1 entry in each row\\n            if sum(x):\\n                return max((i for i in range(len(x)) if x[i]==1))\\n            return 0\\n        line = [mv(e) for e in grid] #reduced to 1D array\\n            \\n        #return -1 if infeasible\\n        for i, e in enumerate(sorted(line)):\\n            if i < e:\\n                return -1\\n\\n        #at this point we know it\\'s feasible\\n        ret = 0\\n        i = 0\\n        while i < len(line):\\n            if line[i] > i: #this means the entry at i-th position is violating\\n                #now find the minimum possible value of j which would satisfy line[j] <= i\\n                #we can now swap this until the reach position i\\n                j = i+1\\n                while line[j] > i: \\n                    j += 1\\n                ret += j-i #the number of swaps needed, minimal at this step\\n                line[i:j+1] = [line[j]] + line[i:j] #rearrange the array based on swap order\\n            i += 1    \\n        return ret #ret equals to minimum number of swaps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def mv(x): #find the index of largest 1 entry in each row\\n            if sum(x):\\n                return max((i for i in range(len(x)) if x[i]==1))\\n            return 0\\n        line = [mv(e) for e in grid] #reduced to 1D array\\n            \\n        #return -1 if infeasible\\n        for i, e in enumerate(sorted(line)):\\n            if i < e:\\n                return -1\\n\\n        #at this point we know it\\'s feasible\\n        ret = 0\\n        i = 0\\n        while i < len(line):\\n            if line[i] > i: #this means the entry at i-th position is violating\\n                #now find the minimum possible value of j which would satisfy line[j] <= i\\n                #we can now swap this until the reach position i\\n                j = i+1\\n                while line[j] > i: \\n                    j += 1\\n                ret += j-i #the number of swaps needed, minimal at this step\\n                line[i:j+1] = [line[j]] + line[i:j] #rearrange the array based on swap order\\n            i += 1    \\n        return ret #ret equals to minimum number of swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768012,
                "title": "clean-python-3-straightforward",
                "content": "Just a straightforward approach with reversed way.\\nTime: `O(N^2)`\\nSpace: `O(N^2)` for input `grid`\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n, step = len(grid), 0\\n        grid = list(reversed(grid))\\n        for target in reversed(range(1, n)):\\n            r = target\\n            while r >= 0:\\n                row = grid[r]\\n                if sum(row[-target:]) == 0: break\\n                r -= 1\\n            else:\\n                return -1\\n            while r != target:\\n                grid[r], grid[r+1] = grid[r+1], grid[r]\\n                step += 1\\n                r += 1\\n        return step\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n, step = len(grid), 0\\n        grid = list(reversed(grid))\\n        for target in reversed(range(1, n)):\\n            r = target\\n            while r >= 0:\\n                row = grid[r]\\n                if sum(row[-target:]) == 0: break\\n                r -= 1\\n            else:\\n                return -1\\n            while r != target:\\n                grid[r], grid[r+1] = grid[r+1], grid[r]\\n                step += 1\\n                r += 1\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769759,
                "title": "python-clean-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation:\\nhttps://youtu.be/88Tg3mWXvVM\\n\\nThis question is pretty tough for me. Tried my best to explain it as clear as possible.\\n\\nIntuition: Greedy Algorithm\\n\\nCode:\\nInspired by: https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/768010/Python-Clean-greedy-solution-with-detailed-explanation-O(N2)\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        def countZeros(arr):\\n            n_zero = 0\\n            for i in range(n-1, -1, -1):\\n                if arr[i] == 0:\\n                    n_zero += 1\\n                else:\\n                    break\\n            return n_zero\\n\\n        zeros = [countZeros(row) for row in grid]\\n        res = 0\\n        \\n        for i in range(n):\\n            target = n - i - 1\\n            if zeros[i] >= target: continue\\n            possible = False\\n            for j in range(i+1, n):\\n                if zeros[j] >= target:\\n                    possible = True\\n                    res += (j - i)\\n                    zeros[i+1:j+1] = zeros[i:j]\\n                    break\\n            if not possible: return -1\\n\\n        return res\\n```\\n\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        def countZeros(arr):\\n            n_zero = 0\\n            for i in range(n-1, -1, -1):\\n                if arr[i] == 0:\\n                    n_zero += 1\\n                else:\\n                    break\\n            return n_zero\\n\\n        zeros = [countZeros(row) for row in grid]\\n        res = 0\\n        \\n        for i in range(n):\\n            target = n - i - 1\\n            if zeros[i] >= target: continue\\n            possible = False\\n            for j in range(i+1, n):\\n                if zeros[j] >= target:\\n                    possible = True\\n                    res += (j - i)\\n                    zeros[i+1:j+1] = zeros[i:j]\\n                    break\\n            if not possible: return -1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769131,
                "title": "c-simple-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), swaps = 0, k;\\n        bool swaps_performed = false;\\n        vector<int> rightmost(n);\\n        for (int i=0; i<n; ++i) {\\n            for (int j=0; j<n; ++j)\\n                if (grid[i][j] == 1)\\n                    rightmost[i] = j;\\n        }\\n        for (int i=0; i<n; ++i) {\\n            k = i + 1;\\n            while (rightmost[i] > i) {\\n                if (k >= n)\\n                    return -1;\\n                swap(rightmost[i], rightmost[k++]);\\n                ++swaps;\\n            }\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), swaps = 0, k;\\n        bool swaps_performed = false;\\n        vector<int> rightmost(n);\\n        for (int i=0; i<n; ++i) {\\n            for (int j=0; j<n; ++j)\\n                if (grid[i][j] == 1)\\n                    rightmost[i] = j;\\n        }\\n        for (int i=0; i<n; ++i) {\\n            k = i + 1;\\n            while (rightmost[i] > i) {\\n                if (k >= n)\\n                    return -1;\\n                swap(rightmost[i], rightmost[k++]);\\n                ++swaps;\\n            }\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767974,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int>t;\\n        for(int i=0;i<grid.size();i++){\\n            int count = 0;\\n            for(int j = grid[i].size()-1;j>=0;j--){\\n                if(grid[i][j] == 0) count++;\\n                else break;\\n            }\\n            t.push_back(count);\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0;i<t.size();i++){\\n            int k = i;\\n            int req = grid.size()-i-1;\\n            while(k<grid.size() && t[k]<req){\\n                k++;\\n            }\\n            if(k==grid.size()) return -1;\\n            ans = ans + k-i;\\n            \\n            while(k>i){\\n                t[k] = t[k-1];\\n                k--;\\n            }\\n        }    \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int>t;\\n        for(int i=0;i<grid.size();i++){\\n            int count = 0;\\n            for(int j = grid[i].size()-1;j>=0;j--){\\n                if(grid[i][j] == 0) count++;\\n                else break;\\n            }\\n            t.push_back(count);\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0;i<t.size();i++){\\n            int k = i;\\n            int req = grid.size()-i-1;\\n            while(k<grid.size() && t[k]<req){\\n                k++;\\n            }\\n            if(k==grid.size()) return -1;\\n            ans = ans + k-i;\\n            \\n            while(k>i){\\n                t[k] = t[k-1];\\n                k--;\\n            }\\n        }    \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040130,
                "title": "java-1ms-100-fast-solution-with-explanation",
                "content": "Explanation: \\n   nothing implementation in this question just convert your thought into simple code.\\nSTEPS:\\n   1. convert 2d grid into 1-d array of size n\\n   2. sort 1-d array into reverse order such that only adjacents data swaps are allowed.\\n   3. swaps should be minimum\\n   4. to minimize the swaps solve greedily\\n\\nJAVA CODE IS:\\n\\n```\\nclass Solution {\\n    int find(int arr[],int low,int high,int val){\\n        for(int i=low;i<=high;i++){\\n            if(arr[i]>=val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public int minSwaps(int[][] grid) {\\n     int n=grid.length;\\n     int arr[]=new int[n];\\n        int i=0;\\n        for(int g[] : grid){\\n            int count=0,j=n-1;\\n            while(j>=0 && g[j--]==0)\\n                count++;\\n            arr[i++]=count;\\n        }\\n        int  swaps=0;\\n        for(i=0;i<n;i++){\\n            int index=find(arr,i,n-1,n-i-1);\\n            if(index==-1)\\n                return -1;\\n            swaps+=(index-i);\\n            //swap the data\\n            for(int j=index;j>i;j--){\\n                int temp=arr[j];\\n                arr[j]=arr[j-1];\\n                arr[j-1]=temp;\\n            }\\n        }\\n        return swaps;\\n    }\\n}\\n```\\nTime : O(n^2)+2*O(n^2)=O(n^2)\\nSpace : O(n).\\n**PLEASE,UPVOTE IF THIS IS REALLY HELPFUL FOR YOU**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int find(int arr[],int low,int high,int val){\\n        for(int i=low;i<=high;i++){\\n            if(arr[i]>=val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public int minSwaps(int[][] grid) {\\n     int n=grid.length;\\n     int arr[]=new int[n];\\n        int i=0;\\n        for(int g[] : grid){\\n            int count=0,j=n-1;\\n            while(j>=0 && g[j--]==0)\\n                count++;\\n            arr[i++]=count;\\n        }\\n        int  swaps=0;\\n        for(i=0;i<n;i++){\\n            int index=find(arr,i,n-1,n-i-1);\\n            if(index==-1)\\n                return -1;\\n            swaps+=(index-i);\\n            //swap the data\\n            for(int j=index;j>i;j--){\\n                int temp=arr[j];\\n                arr[j]=arr[j-1];\\n                arr[j-1]=temp;\\n            }\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789981,
                "title": "simplest-c-with-explanation-100-fast-minimum-swaps-to-arrange-a-binary-grid",
                "content": "The basic funda is, boil down your grid to a one dimensional array.\\nAnd then find the min swaps to make it ordered.\\n\\nWhat is the order here?\\nIts kind of a sorting but not comparing the numbers inside the array, but the number and the array index.\\n\\nWhy this greedy works? (Leave this if you don\\'t want to think much)\\n1. Cause for a certain index(i) if you have found the nearest matching value down in a later index(j), no matter what, you have to perform j-i swaps to make the array ordered.\\n2. When you bring a value in an array up, all the middle values goes down also, improving the condition index<= (value in that index). So this is also an optimal approach.\\n\\nGive a cheer up if you ike this :)\\n\"\"\"\\n\\n\\t\\tpublic int MinSwaps(int[][] grid)\\n        {\\n            if (grid.Length <= 1) return 0;\\n            int n = grid.GetLength(0);\\n        \\n            //Creating an array repeseneting the total number of zeroes(right to left) for each row\\n            int[] ranks = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                int j = n-1;\\n                while(j>=0 && grid[i][j]!=1) j--;\\n                ranks[i]=j;\\n            }\\n                        \\n            int ans=0,temp;\\n            for(int i=0; i<n; i++)\\n            {\\n\\t\\t\\t\\t//if the value is not suitable for the index go down and and find one\\n                if(ranks[i] >i)\\n                {\\n                    int j=i;\\n                    while(j<n && ranks[j]>i) j++;\\n                    \\n                    //return if a matching value is not there\\n                    if(j>=n) return -1;\\n                    \\n\\t\\t\\t\\t\\t//swap if a valid match is found\\n                    while(j!=i)\\n                    {\\n                        temp= ranks[j];\\n                        ranks[j] = ranks[j-1];\\n                        ranks[j-1]=temp;\\n                        j--;\\n                        ans++;\\n                    }\\n                }\\n            }\\n        return ans;\\n        }\\n\"\"\"",
                "solutionTags": [],
                "code": "The basic funda is, boil down your grid to a one dimensional array.\\nAnd then find the min swaps to make it ordered.\\n\\nWhat is the order here?\\nIts kind of a sorting but not comparing the numbers inside the array, but the number and the array index.\\n\\nWhy this greedy works? (Leave this if you don\\'t want to think much)\\n1. Cause for a certain index(i) if you have found the nearest matching value down in a later index(j), no matter what, you have to perform j-i swaps to make the array ordered.\\n2. When you bring a value in an array up, all the middle values goes down also, improving the condition index<= (value in that index). So this is also an optimal approach.\\n\\nGive a cheer up if you ike this :)\\n\"\"\"\\n\\n\\t\\tpublic int MinSwaps(int[][] grid)\\n        {\\n            if (grid.Length <= 1) return 0;\\n            int n = grid.GetLength(0);\\n        \\n            //Creating an array repeseneting the total number of zeroes(right to left) for each row\\n            int[] ranks = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                int j = n-1;\\n                while(j>=0 && grid[i][j]!=1) j--;\\n                ranks[i]=j;\\n            }\\n                        \\n            int ans=0,temp;\\n            for(int i=0; i<n; i++)\\n            {\\n\\t\\t\\t\\t//if the value is not suitable for the index go down and and find one\\n                if(ranks[i] >i)\\n                {\\n                    int j=i;\\n                    while(j<n && ranks[j]>i) j++;\\n                    \\n                    //return if a matching value is not there\\n                    if(j>=n) return -1;\\n                    \\n\\t\\t\\t\\t\\t//swap if a valid match is found\\n                    while(j!=i)\\n                    {\\n                        temp= ranks[j];\\n                        ranks[j] = ranks[j-1];\\n                        ranks[j-1]=temp;\\n                        j--;\\n                        ans++;\\n                    }\\n                }\\n            }\\n        return ans;\\n        }\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 777254,
                "title": "java-100-faster-using-bubble-sort-with-code-comments",
                "content": "Reference : https://www.youtube.com/watch?v=OLA5Qwt4NKw\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        \\n        // first count the trailing zeroes in each row in grid\\n        int n = grid.length;\\n        \\n        int trailingZeroes [] = new int [n];\\n        for(int i = 0 ; i < grid.length; i++)\\n        {\\n            int count = 0;\\n            int j = n-1;\\n            while(j >= 0 && grid[i][j] == 0)\\n            {\\n                count += 1;\\n                j--;\\n            }\\n            // The row i has count trailing zeroes\\n            trailingZeroes[i] = count;\\n        }\\n        \\n        int minSwaps = 0;\\n        // Do a bubble sort \\n        for(int i = 0 ; i < trailingZeroes.length; i++ )\\n        {\\n            // No of trailing zeroes required for this row\\n            int target = n-i-1;\\n            \\n            int k = i;\\n            \\n            // Find the row index which has the target number of trailing zeroes to swap with i\\n            while(k < n && trailingZeroes[k] < target)\\n            {\\n\\n                k += 1;\\n            }\\n            \\n            // if k has reached end return -1\\n            if(k == n) return -1;\\n            \\n            // Increment count by number of swaps (from k to i)\\n            minSwaps += k-i;\\n            \\n            // bubble from k to i since we can only swap adjacent pairs\\n            while(k > i)\\n            {\\n                int temp = trailingZeroes[k];\\n                trailingZeroes[k] = trailingZeroes[k-1];\\n                trailingZeroes[k-1] = temp;\\n                k--;\\n            }\\n            \\n            \\n        }\\n        \\n        return minSwaps;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        \\n        // first count the trailing zeroes in each row in grid\\n        int n = grid.length;\\n        \\n        int trailingZeroes [] = new int [n];\\n        for(int i = 0 ; i < grid.length; i++)\\n        {\\n            int count = 0;\\n            int j = n-1;\\n            while(j >= 0 && grid[i][j] == 0)\\n            {\\n                count += 1;\\n                j--;\\n            }\\n            // The row i has count trailing zeroes\\n            trailingZeroes[i] = count;\\n        }\\n        \\n        int minSwaps = 0;\\n        // Do a bubble sort \\n        for(int i = 0 ; i < trailingZeroes.length; i++ )\\n        {\\n            // No of trailing zeroes required for this row\\n            int target = n-i-1;\\n            \\n            int k = i;\\n            \\n            // Find the row index which has the target number of trailing zeroes to swap with i\\n            while(k < n && trailingZeroes[k] < target)\\n            {\\n\\n                k += 1;\\n            }\\n            \\n            // if k has reached end return -1\\n            if(k == n) return -1;\\n            \\n            // Increment count by number of swaps (from k to i)\\n            minSwaps += k-i;\\n            \\n            // bubble from k to i since we can only swap adjacent pairs\\n            while(k > i)\\n            {\\n                int temp = trailingZeroes[k];\\n                trailingZeroes[k] = trailingZeroes[k-1];\\n                trailingZeroes[k-1] = temp;\\n                k--;\\n            }\\n            \\n            \\n        }\\n        \\n        return minSwaps;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775169,
                "title": "javascript-clean-intuitive-solution",
                "content": "```javascript\\nvar minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    function swap(i, j) {\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n        count++;\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        // if num <= i pass b/c it\\'s its correct spot\\n        if(arr[i] <= i) continue;\\n        let j = i;\\n        \\n        // scan forward looking for a num <= i\\n        while(arr[j] > i) {\\n            j++;\\n            if(j >= arr.length) return -1;\\n        }\\n        \\n        // swap as you move back to the right spot\\n        for(let k = j; k > i; k--) {\\n            swap(k, k-1);\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    function swap(i, j) {\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n        count++;\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        // if num <= i pass b/c it\\'s its correct spot\\n        if(arr[i] <= i) continue;\\n        let j = i;\\n        \\n        // scan forward looking for a num <= i\\n        while(arr[j] > i) {\\n            j++;\\n            if(j >= arr.length) return -1;\\n        }\\n        \\n        // swap as you move back to the right spot\\n        for(let k = j; k > i; k--) {\\n            swap(k, k-1);\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774139,
                "title": "python-bubble-sort-approach-easy-to-read-beats-100-both-space-time",
                "content": "Bubble sort approach inspired by @FunBam\\nhttps://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/767912/Java-16-lines-bubble-sort-with-line-by-line-explanation-easy-to-understand\\n\\n```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def count_trailing_zero(arr):\\n            idx = len(arr) - 1\\n            while idx >= 0 and arr[idx] == 0:\\n                idx -= 1\\n            return len(arr) - 1 - idx\\n\\n        ranks = [count_trailing_zero(grid[i]) for i in range(len(grid))]\\n        swaps = 0\\n\\t\\t\\n\\t\\t# bubble sort\\n        for i in range(len(ranks)):\\n            j = i\\n            while j < len(ranks) and ranks[j] < len(ranks) - 1 - i:\\n                j += 1\\n\\n\\t\\t\\t# grid is invalid because appropriate row replacement not found\\n            if j == len(ranks):\\n                return -1\\n\\n            tmp = ranks.pop(j)\\n            ranks.insert(i, tmp)\\n            swaps += j - i\\n\\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def count_trailing_zero(arr):\\n            idx = len(arr) - 1\\n            while idx >= 0 and arr[idx] == 0:\\n                idx -= 1\\n            return len(arr) - 1 - idx\\n\\n        ranks = [count_trailing_zero(grid[i]) for i in range(len(grid))]\\n        swaps = 0\\n\\t\\t\\n\\t\\t# bubble sort\\n        for i in range(len(ranks)):\\n            j = i\\n            while j < len(ranks) and ranks[j] < len(ranks) - 1 - i:\\n                j += 1\\n\\n\\t\\t\\t# grid is invalid because appropriate row replacement not found\\n            if j == len(ranks):\\n                return -1\\n\\n            tmp = ranks.pop(j)\\n            ranks.insert(i, tmp)\\n            swaps += j - i\\n\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771923,
                "title": "java-easy-solution-3ms-faster-than-100-00",
                "content": "**Runtime: 3 ms, faster than 100.00%, Memory Usage: 41.7 MB, less than 100.00% of Java online submissions**\\n\\n```\\n// O(N^2)time\\n// O(N)space\\npublic int minSwaps(int[][] grid) {\\n    //use linkedlist to save the continuous zero count from right to left\\n    LinkedList<Integer> list = new LinkedList<>();\\n    int r = grid.length, c = grid[0].length;\\n    for (int i = 0; i < r; i++) {\\n        int count = 0;\\n        for (int j = c - 1; j >= 0; j--) {\\n            if (grid[i][j] != 0) break;\\n            count++;\\n        }\\n        list.add(count);\\n    }\\n    int res = 0;\\n    for (int i = 0; i < r; i++) {\\n        int t = -1;\\n        //find the first zero count which is >= (r - 1 - i)\\n        //the index is the step\\n        for (int j = 0; j < list.size(); j++) {\\n            if (list.get(j) >= (r - 1 - i)) {\\n                t = list.remove(j);\\n                res += j;\\n                break;\\n            }\\n        }\\n        if (t == -1) return -1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n// O(N^2)time\\n// O(N)space\\npublic int minSwaps(int[][] grid) {\\n    //use linkedlist to save the continuous zero count from right to left\\n    LinkedList<Integer> list = new LinkedList<>();\\n    int r = grid.length, c = grid[0].length;\\n    for (int i = 0; i < r; i++) {\\n        int count = 0;\\n        for (int j = c - 1; j >= 0; j--) {\\n            if (grid[i][j] != 0) break;\\n            count++;\\n        }\\n        list.add(count);\\n    }\\n    int res = 0;\\n    for (int i = 0; i < r; i++) {\\n        int t = -1;\\n        //find the first zero count which is >= (r - 1 - i)\\n        //the index is the step\\n        for (int j = 0; j < list.size(); j++) {\\n            if (list.get(j) >= (r - 1 - i)) {\\n                t = list.remove(j);\\n                res += j;\\n                break;\\n            }\\n        }\\n        if (t == -1) return -1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 770135,
                "title": "java-bubble-sort-solution-with-explanation-beats-100",
                "content": "**Intuition:**\\n1. The questions itself suggests us that this is a variation of bubble sort. In bubble sort we swap the current number with its adjacent number and bubble it up(swap) if its greater than the next element(ascending order sort). \\n1. Using that concept, we can formulate our solution in such a way that we can bubble up the row containing the required number of zeroes to top. \\n\\n**Approach**\\n1. In every row, count the number of zeroes in the suffix. \\n  Eg: \\n        ```[1,1,0,0]: contains 2```\\n        ```[1.0.0.0]: contains 3```  \\n1. Once we have a list of the above values, each value representing number of zeroes from the end in each row we can use the bubble sort kind of logic to bubble up the required row to the top. \\n1. A small tricky thing to consider here. To maintain minimum number of swaps, we need to only bubble up the row containing required number of zeroes. For example for the below array: The numZeroes list looks like [0, 3, 4,5,5]. For row number 0, we need 4 zeroes, So we just need to swap 4 to top. No need to swap 5. That will increase number of swaps more than required. \\n  ```\\n    [[0,0,0,0,1]\\n\\t[1,1,0,0,0]\\n\\t[1,0,0,0,0]\\n\\t[0,0,0,0,0]\\n\\t[0,0,0,0,0]]\\n```\\t\\n \\n  \\n\\n\\n```\\n    public int minSwaps(int[][] nums) {        \\n        int result = 0;        \\n        int requiredZeroes = nums.length - 1;\\n        List<Integer> numZeroes = new ArrayList<>();   \\n        int index = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int count = 0;\\n            for (int j = nums.length - 1; j >= 0 && nums[i][j] == 0; j--) {\\n                count++;\\n            }\\n            numZeroes.add(count);\\n        }\\n        \\n        \\n        for (int i = 0; i < nums.length ; i++) {  \\n            int tempIndex = index;                        \\n            while (tempIndex < numZeroes.size() && numZeroes.get(tempIndex) < requiredZeroes) {\\n                tempIndex++;\\n            }\\n            if (tempIndex == nums.length) {\\n                return -1; \\n            }            \\n            result += tempIndex - index;                        \\n            numZeroes.add(i, numZeroes.remove(tempIndex));                \\n            requiredZeroes--;\\n            index++;\\n        }\\n                       \\n        return result;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```[1,1,0,0]: contains 2```\n```[1.0.0.0]: contains 3```\n```\\n    [[0,0,0,0,1]\\n\\t[1,1,0,0,0]\\n\\t[1,0,0,0,0]\\n\\t[0,0,0,0,0]\\n\\t[0,0,0,0,0]]\\n```\n```\\n    public int minSwaps(int[][] nums) {        \\n        int result = 0;        \\n        int requiredZeroes = nums.length - 1;\\n        List<Integer> numZeroes = new ArrayList<>();   \\n        int index = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int count = 0;\\n            for (int j = nums.length - 1; j >= 0 && nums[i][j] == 0; j--) {\\n                count++;\\n            }\\n            numZeroes.add(count);\\n        }\\n        \\n        \\n        for (int i = 0; i < nums.length ; i++) {  \\n            int tempIndex = index;                        \\n            while (tempIndex < numZeroes.size() && numZeroes.get(tempIndex) < requiredZeroes) {\\n                tempIndex++;\\n            }\\n            if (tempIndex == nums.length) {\\n                return -1; \\n            }            \\n            result += tempIndex - index;                        \\n            numZeroes.add(i, numZeroes.remove(tempIndex));                \\n            requiredZeroes--;\\n            index++;\\n        }\\n                       \\n        return result;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 768339,
                "title": "c-greedy-min-adj-swap-to-sort-an-array",
                "content": "class Solution {\\npublic:\\n\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> v;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(!grid[i][j])\\n                    c++;\\n                else\\n                    break;\\n            }\\n            v.push_back(c);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n && v[i]<m-i-1;j++){\\n                swap(v[i],v[j]);\\n                ans++;\\n            }\\n            if(v[i]<m-i-1)\\n                return -1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> v;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(!grid[i][j])\\n                    c++;\\n                else\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 768285,
                "title": "c-greedily-find-the-final-position-of-each-row-and-bubble-sort",
                "content": "**Main idea:**\\n1. Find the rightmost index of \"1\" in each row and convert the original grid to a 1D array. These indices also represent the \"topmost\" location of each row in the grid.\\n2. Figure out the final position of each row with a greedy approach: Try placing each row in its \"topmost\" location. If that location is already filled by another row, move the location down by 1 (increment the index).\\n3. Count the number of swaps required from original arrangement [0, 1, 2, ..., n-1] to the final arrangement using Bubble Sort.\\n\\nSpecial thanks to @xinyu95 for the clarification!\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n        // Find the location of rightmost \"1\", which is also its topmost location in grid\\n        vector<int> ones(n, n-1);\\n        for (int i=0; i<n; ++i) {\\n            for (int j=n-1; j>0; --j) {\\n                if (grid[i][j] != 1) {\\n                    --ones[i];\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        // This array greedily records the final position of each row.\\n        // In other words, pos[i] = j means that the jth row in the original grid should finally be placed\\n        // in the ith row to meet the standard.\\n        vector<int> pos(n, -1);\\n        for (int i=0; i<ones.size(); ++i) {\\n            // First find the topmost row position based on the location of rightmost \"1\"\\n            int f_pos = ones[i];\\n            // If that position is already filled by another row, increment the index\\n            while (pos[f_pos] != -1) {\\n                ++f_pos;\\n                // If index is out of range, this means we cannot find a valid position for the current row\\n                // so just return -1\\n                if (f_pos >= n) {\\n                    return -1;\\n                }\\n            }\\n            pos[f_pos] = i;\\n        }\\n        // The initial position is just [0, 1, 2, ..., n-1].\\n        // This means we need to transform \"pos\" to [0, 1, 2, ..., n-1] by only swapping adjacent rows.\\n        // Therefore we can use bubble sort.\\n        int swaps = INT_MAX;\\n        while (swaps > 0) {\\n            int tmp = 0;\\n            for (int i=0; i<n-1; ++i) {\\n                if (pos[i] > pos[i+1]) {\\n                    swap(pos[i], pos[i+1]);\\n                    ++tmp;\\n                }\\n            }\\n            res += tmp; swaps = tmp;\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n        // Find the location of rightmost \"1\", which is also its topmost location in grid\\n        vector<int> ones(n, n-1);\\n        for (int i=0; i<n; ++i) {\\n            for (int j=n-1; j>0; --j) {\\n                if (grid[i][j] != 1) {\\n                    --ones[i];\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        // This array greedily records the final position of each row.\\n        // In other words, pos[i] = j means that the jth row in the original grid should finally be placed\\n        // in the ith row to meet the standard.\\n        vector<int> pos(n, -1);\\n        for (int i=0; i<ones.size(); ++i) {\\n            // First find the topmost row position based on the location of rightmost \"1\"\\n            int f_pos = ones[i];\\n            // If that position is already filled by another row, increment the index\\n            while (pos[f_pos] != -1) {\\n                ++f_pos;\\n                // If index is out of range, this means we cannot find a valid position for the current row\\n                // so just return -1\\n                if (f_pos >= n) {\\n                    return -1;\\n                }\\n            }\\n            pos[f_pos] = i;\\n        }\\n        // The initial position is just [0, 1, 2, ..., n-1].\\n        // This means we need to transform \"pos\" to [0, 1, 2, ..., n-1] by only swapping adjacent rows.\\n        // Therefore we can use bubble sort.\\n        int swaps = INT_MAX;\\n        while (swaps > 0) {\\n            int tmp = 0;\\n            for (int i=0; i<n-1; ++i) {\\n                if (pos[i] > pos[i+1]) {\\n                    swap(pos[i], pos[i+1]);\\n                    ++tmp;\\n                }\\n            }\\n            res += tmp; swaps = tmp;\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768147,
                "title": "simple-java-solution-bubble-sort",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n      \\n        int n=grid.length;\\n        int arr[]=new int[n];\\n        int check[]=new int[n];\\n        int k=0;\\n        for(int row[]:grid){\\n            int i=n-1;\\n            while(i>=0 && row[i]==0)\\n                i--;\\n            int val=n-i-1;\\n            for(int j=n-1;j>=0;j--){\\n                if(check[j]!=-1 && val>=j){\\n                    check[j]=-1;\\n                    arr[k++]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(check[i]==0)\\n                return -1;\\n        }\\n        int count=0;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<n-i-1;j++){\\n                if(arr[j]<arr[j+1]){\\n                    int temp=arr[j];\\n                    arr[j]=arr[j+1];\\n                    arr[j+1]=temp;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n      \\n        int n=grid.length;\\n        int arr[]=new int[n];\\n        int check[]=new int[n];\\n        int k=0;\\n        for(int row[]:grid){\\n            int i=n-1;\\n            while(i>=0 && row[i]==0)\\n                i--;\\n            int val=n-i-1;\\n            for(int j=n-1;j>=0;j--){\\n                if(check[j]!=-1 && val>=j){\\n                    check[j]=-1;\\n                    arr[k++]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(check[i]==0)\\n                return -1;\\n        }\\n        int count=0;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<n-i-1;j++){\\n                if(arr[j]<arr[j+1]){\\n                    int temp=arr[j];\\n                    arr[j]=arr[j+1];\\n                    arr[j+1]=temp;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768119,
                "title": "c-count-zeros-from-right-side",
                "content": "Runtime: 376 ms\\nMemory Usage: 31.4 MB\\n\\nIdea: \\n* Count the number of zeros for each line of the grid (stored in \"rightZeros\" array)\\n\\n* Traverse the grid starting at row 0. If the row has the proper number of zeros keep going; else find the closest row (A) after it that has the right number of zeros. \\n\\n* Instead of swapping the rows  I just mark the row (A), by adding it to \"ignorePos\" so we ignore it in the future. I could have used a list instead of an array for \"rightZeros\" and I could have easily removed it but didn\\'t think of it in the contest until to late. Because I am using a HashSet, I need to calculate the \"swapAdds\" value instead of using the difference between the row positions.  \\n\\nI could have done this in an iterative way instead of recursion, that would have been more efficient.\\n\\n```\\n    public int MinSwaps(int[][] grid) {\\n       int[] rightZeros = GetZeroCounts(grid);\\n       int result = int.MaxValue;\\n       HashSet<int> ignorePos = new HashSet<int>();\\n        \\n       Traverse(rightZeros, grid.Length-1, 0, ref result, 0, ignorePos);\\n        \\n       return (result == int.MaxValue)? -1: result;\\n    }\\n    \\n    public void Traverse(int[] rightZeros, int needed, int start, ref int result, int swaps, HashSet<int> ignorePos)\\n    {\\n        if (start == rightZeros.Length)\\n        {\\n            if (swaps < result) { result = swaps; }\\n            return;\\n        }\\n        \\n        if (ignorePos.Contains(start)) // row was moved to the top\\n        {\\n            Traverse(rightZeros, needed, start+1, ref result, swaps, ignorePos); \\n        }\\n        else if (rightZeros[start] >= needed) \\n        {\\n            Traverse(rightZeros, needed-1, start+1, ref result, swaps, ignorePos);\\n        }\\n        else\\n        {\\n            //find posible swaps \\n            int pos = GetPossibleSwapRow(rightZeros, needed, start+1, ignorePos);\\n            int swapAdds = 0;\\n            \\n            if (pos != -1) \\n            {\\n                ignorePos.Add(pos);\\n                \\n                for(int j = start; j < pos; j++)\\n                {\\n                    if (!ignorePos.Contains(j)) { swapAdds++; }\\n                }\\n                \\n                Traverse(rightZeros, needed-1, start, ref result, swaps + swapAdds, ignorePos);\\n                \\n                ignorePos.Remove(pos);\\n            }\\n        }\\n    }\\n    \\n    private int GetPossibleSwapRow(int[] rightZeros, int needed, int start, HashSet<int> ignorePos)\\n    {\\n       \\n        for(int i=start; i< rightZeros.Length; i++)\\n        {\\n            if (!ignorePos.Contains(i) && rightZeros[i] >= needed) { return i; }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public int[] GetZeroCounts(int[][] grid)\\n    {\\n        int[] rightZeros = new int[grid.Length];\\n        \\n        int count;\\n        \\n        for(int i=0; i< grid.Length; i++)\\n        {\\n            count = 0;\\n            for(int j= grid.Length - 1; j>=0; j--)\\n            {\\n                if (grid[i][j] != 0) { break; }\\n                count++;\\n            }\\n            rightZeros[i] = count;\\n        }\\n        \\n        return rightZeros;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 376 ms\\nMemory Usage: 31.4 MB\\n\\nIdea: \\n* Count the number of zeros for each line of the grid (stored in \"rightZeros\" array)\\n\\n* Traverse the grid starting at row 0. If the row has the proper number of zeros keep going; else find the closest row (A) after it that has the right number of zeros. \\n\\n* Instead of swapping the rows  I just mark the row (A), by adding it to \"ignorePos\" so we ignore it in the future. I could have used a list instead of an array for \"rightZeros\" and I could have easily removed it but didn\\'t think of it in the contest until to late. Because I am using a HashSet, I need to calculate the \"swapAdds\" value instead of using the difference between the row positions.  \\n\\nI could have done this in an iterative way instead of recursion, that would have been more efficient.\\n\\n```\\n    public int MinSwaps(int[][] grid) {\\n       int[] rightZeros = GetZeroCounts(grid);\\n       int result = int.MaxValue;\\n       HashSet<int> ignorePos = new HashSet<int>();\\n        \\n       Traverse(rightZeros, grid.Length-1, 0, ref result, 0, ignorePos);\\n        \\n       return (result == int.MaxValue)? -1: result;\\n    }\\n    \\n    public void Traverse(int[] rightZeros, int needed, int start, ref int result, int swaps, HashSet<int> ignorePos)\\n    {\\n        if (start == rightZeros.Length)\\n        {\\n            if (swaps < result) { result = swaps; }\\n            return;\\n        }\\n        \\n        if (ignorePos.Contains(start)) // row was moved to the top\\n        {\\n            Traverse(rightZeros, needed, start+1, ref result, swaps, ignorePos); \\n        }\\n        else if (rightZeros[start] >= needed) \\n        {\\n            Traverse(rightZeros, needed-1, start+1, ref result, swaps, ignorePos);\\n        }\\n        else\\n        {\\n            //find posible swaps \\n            int pos = GetPossibleSwapRow(rightZeros, needed, start+1, ignorePos);\\n            int swapAdds = 0;\\n            \\n            if (pos != -1) \\n            {\\n                ignorePos.Add(pos);\\n                \\n                for(int j = start; j < pos; j++)\\n                {\\n                    if (!ignorePos.Contains(j)) { swapAdds++; }\\n                }\\n                \\n                Traverse(rightZeros, needed-1, start, ref result, swaps + swapAdds, ignorePos);\\n                \\n                ignorePos.Remove(pos);\\n            }\\n        }\\n    }\\n    \\n    private int GetPossibleSwapRow(int[] rightZeros, int needed, int start, HashSet<int> ignorePos)\\n    {\\n       \\n        for(int i=start; i< rightZeros.Length; i++)\\n        {\\n            if (!ignorePos.Contains(i) && rightZeros[i] >= needed) { return i; }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    public int[] GetZeroCounts(int[][] grid)\\n    {\\n        int[] rightZeros = new int[grid.Length];\\n        \\n        int count;\\n        \\n        for(int i=0; i< grid.Length; i++)\\n        {\\n            count = 0;\\n            for(int j= grid.Length - 1; j>=0; j--)\\n            {\\n                if (grid[i][j] != 0) { break; }\\n                count++;\\n            }\\n            rightZeros[i] = count;\\n        }\\n        \\n        return rightZeros;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 768106,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& g) {\\n        int n = g.size();\\n        vector<int> v(n,0);\\n        for(int i = 0;i < n;i++){\\n            int j = n - 1;\\n            while(j >= 0 && g[i][j] == 0)  // we are calculating number of zeros at end of each raw\\n                v[i]++,j--;\\n        }\\n        int sum = 0;\\n        for(int i = 0;i < n;i++){\\n            if(v[i] >= n - 1 - i) continue;   // if perticular raw have required zeros then continue \\n                                              //else check any other raw has required zeros or not \\n                                              //if not then return -1 else swap raws\\n            int f = 0;\\n            int k = -1;\\n            for(int j = i + 1;j < n;j++){\\n                if(v[j] >= n - 1 - i){\\n                    f = 1;\\n                    k = j;\\n                    break;\\n                }\\n            }\\n            if(!f) return -1;\\n            for(int j = k;j  > i;j--)\\n                swap(v[j],v[j-1]) , sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& g) {\\n        int n = g.size();\\n        vector<int> v(n,0);\\n        for(int i = 0;i < n;i++){\\n            int j = n - 1;\\n            while(j >= 0 && g[i][j] == 0)  // we are calculating number of zeros at end of each raw\\n                v[i]++,j--;\\n        }\\n        int sum = 0;\\n        for(int i = 0;i < n;i++){\\n            if(v[i] >= n - 1 - i) continue;   // if perticular raw have required zeros then continue \\n                                              //else check any other raw has required zeros or not \\n                                              //if not then return -1 else swap raws\\n            int f = 0;\\n            int k = -1;\\n            for(int j = i + 1;j < n;j++){\\n                if(v[j] >= n - 1 - i){\\n                    f = 1;\\n                    k = j;\\n                    break;\\n                }\\n            }\\n            if(!f) return -1;\\n            for(int j = k;j  > i;j--)\\n                swap(v[j],v[j-1]) , sum++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704602,
                "title": "c-95-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int ans = 0;\\n        vector<int> t; \\n        for(int i=0;i<n;i++){\\n            int zero = 0;\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]) break;\\n                zero++;\\n            }\\n            t.push_back(zero);\\n        }\\n        for(int i=0;i<n;i++){\\n            \\n            int curr = i;\\n            int req = n - 1 - i; \\n            while(curr < n and t[curr] < req) curr++;\\n            \\n            if(curr == n) return -1;\\n            ans += curr - i;\\n            while(curr > 0){\\n                t[curr] = t[curr - 1];\\n                curr--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int ans = 0;\\n        vector<int> t; \\n        for(int i=0;i<n;i++){\\n            int zero = 0;\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]) break;\\n                zero++;\\n            }\\n            t.push_back(zero);\\n        }\\n        for(int i=0;i<n;i++){\\n            \\n            int curr = i;\\n            int req = n - 1 - i; \\n            while(curr < n and t[curr] < req) curr++;\\n            \\n            if(curr == n) return -1;\\n            ans += curr - i;\\n            while(curr > 0){\\n                t[curr] = t[curr - 1];\\n                curr--;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576538,
                "title": "c-brute-force-greedy-observation-cleanest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        //brute force\\n        int res=0;\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            //first row must have n-1 zeroes from the back;\\n            int counter=n-i-1;\\n            int j=n-1;\\n            int ctz=0;\\n            for(int k=j;k>i;k--){\\n                if(grid[i][k]==0){\\n                    ctz++;\\n                }\\n            }\\n            if(ctz==counter){\\n                continue;//this row is okay\\n            }\\n            //but if not we need to find the row which has counter number of zeroes\\n            int row=-1;\\n            for(int q=i+1;q<n;q++){\\n                int ctz1=0;\\n                for(int j=n-1;j>i;j--){\\n                    if(grid[q][j]==0){\\n                        ctz1++;\\n                    }\\n                }\\n                if(ctz1==counter){\\n                    row=q;\\n                    break;\\n                }\\n            }\\n            //cout<<row<<endl;\\n            if(row==-1){res=-1;break;}\\n            //else we have to bring this row i.e the qth row from the bottom to the top\\n            int swaps=row-i;\\n            while(swaps>0){\\n                for(int oo=n-1;oo>=0;oo--){\\n                    swap(grid[row][oo],grid[row-1][oo]);\\n                }\\n                row=row-1;\\n                swaps--;\\n                res++;\\n            }   \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        //brute force\\n        int res=0;\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            //first row must have n-1 zeroes from the back;\\n            int counter=n-i-1;\\n            int j=n-1;\\n            int ctz=0;\\n            for(int k=j;k>i;k--){\\n                if(grid[i][k]==0){\\n                    ctz++;\\n                }\\n            }\\n            if(ctz==counter){\\n                continue;//this row is okay\\n            }\\n            //but if not we need to find the row which has counter number of zeroes\\n            int row=-1;\\n            for(int q=i+1;q<n;q++){\\n                int ctz1=0;\\n                for(int j=n-1;j>i;j--){\\n                    if(grid[q][j]==0){\\n                        ctz1++;\\n                    }\\n                }\\n                if(ctz1==counter){\\n                    row=q;\\n                    break;\\n                }\\n            }\\n            //cout<<row<<endl;\\n            if(row==-1){res=-1;break;}\\n            //else we have to bring this row i.e the qth row from the bottom to the top\\n            int swaps=row-i;\\n            while(swaps>0){\\n                for(int oo=n-1;oo>=0;oo--){\\n                    swap(grid[row][oo],grid[row-1][oo]);\\n                }\\n                row=row-1;\\n                swaps--;\\n                res++;\\n            }   \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2352475,
                "title": "bubble-sort",
                "content": "First I tried to do using some logic of counting inversion points using the concepts of MERGE SORT [as  I was practicing \"minimum adjacent swaps to make an array sorted\" , but later found that , I had to manipulate  the array in a more complex way  ] \\nThen  thought about greedly making the  swaps , and came up with the BUBBLE SORT technique\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        multiset<int> st; // to reject -1 case \\n        vector<int> main; //for correct order , to later apply bubble sort \\n        \\n        for( int i =0 ; i<n ; i++){\\n            \\n            int cnt =0;\\n            for( int j =n-1 ; j>=0 ; j--){\\n                if(grid[i][j] ==1 ) break;\\n                else if(grid[i][j] == 0 ) cnt++;\\n            }\\n            st.insert(cnt);\\n            main.push_back(cnt);\\n        }\\n        \\n        vector<int> tmp(n, 0);\\n        iota(tmp.begin() , tmp.end(), 0);  // to match the required order \\n        \\n        int k =0;\\n        \\n        \\n        for( auto c:st){\\n            if(c < tmp[k++]) return -1;\\n        }\\n        \\n        k = n-1;\\n        int cnt =0;\\n        for( int i =0 ; i<n-1 ; i++){\\n            \\n            if( main[i] >= k){   \\n                k--;\\n                continue;\\n            }\\n            else{\\n                int j = i+1;\\n                while(j < n  and main[j] < k){    \\n                    j++;\\n                }\\n                cnt += (j-i);\\n                while(j != i){\\n                    swap(main[j] , main[j-1]);  \\n                    j--;\\n                }\\n                k--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};**********\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        multiset<int> st; // to reject -1 case \\n        vector<int> main; //for correct order , to later apply bubble sort \\n        \\n        for( int i =0 ; i<n ; i++){\\n            \\n            int cnt =0;\\n            for( int j =n-1 ; j>=0 ; j--){\\n                if(grid[i][j] ==1 ) break;\\n                else if(grid[i][j] == 0 ) cnt++;\\n            }\\n            st.insert(cnt);\\n            main.push_back(cnt);\\n        }\\n        \\n        vector<int> tmp(n, 0);\\n        iota(tmp.begin() , tmp.end(), 0);  // to match the required order \\n        \\n        int k =0;\\n        \\n        \\n        for( auto c:st){\\n            if(c < tmp[k++]) return -1;\\n        }\\n        \\n        k = n-1;\\n        int cnt =0;\\n        for( int i =0 ; i<n-1 ; i++){\\n            \\n            if( main[i] >= k){   \\n                k--;\\n                continue;\\n            }\\n            else{\\n                int j = i+1;\\n                while(j < n  and main[j] < k){    \\n                    j++;\\n                }\\n                cnt += (j-i);\\n                while(j != i){\\n                    swap(main[j] , main[j-1]);  \\n                    j--;\\n                }\\n                k--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};**********\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688807,
                "title": "min-adjacent-swaps-to-sort-array-explained",
                "content": "from first rorw to last, count number of trailing zeroes. Record only the highest number not shown yet. For example, at row 0, trailing zeroes = 10, set it to 10. Row 1, trailing zeroes = 10 as well, because 10 already shown, set it to 9. One row to be 10 is ALREADY enough. (This will be explained later). \\n\\nWhen all number is recorded, this creates an array with unique integers. If array size is less than n, in other words, array is not 0, 1, 2, ..., n-1, then it\\'s impossible to form a VALID matrix. \\n\\nIf array size is n, we now calculate min adjacent swaps to sort the array. Notice for a correct swap of adjacent number i, j (i < j) to j, i, it reduces total number of inversion of the array by exactly 1. This means for a sorted array of inversion = 0, minimum number of swaps needed is exactly number of inversions. So we just calculate inversions. \\n\\nNow why we need to record highest different trailing zeroes? To avoid ambiguity for counting inversions. For an counter-example, for array  a1, a2, ..., a10, if a1 = 8, a2=9, a3=9, we only need to count a2 as an inversion, because a3 only needs 7 zeroes and stay at row 2 and matrix is still valid. Why take higest different  trailing zeroes starting from first row? It creates an array that needs minimum adacent  swaps.\\n\\n```python\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        arr = []\\n        S = set()\\n        for row in grid:\\n            c = 0\\n            for i in row[::-1]:\\n                if i:\\n                    break\\n                c += 1\\n            while c in S:\\n                c -= 1\\n            if c >= 0:\\n                S.add(c)\\n                arr += c,\\n            \\n        if len(arr) < n:\\n            return -1\\n        \\n        res = 0\\n        for i, v in enumerate(arr):\\n            for v2 in arr[i+1:]:\\n                if v2 > v:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        arr = []\\n        S = set()\\n        for row in grid:\\n            c = 0\\n            for i in row[::-1]:\\n                if i:\\n                    break\\n                c += 1\\n            while c in S:\\n                c -= 1\\n            if c >= 0:\\n                S.add(c)\\n                arr += c,\\n            \\n        if len(arr) < n:\\n            return -1\\n        \\n        res = 0\\n        for i, v in enumerate(arr):\\n            for v2 in arr[i+1:]:\\n                if v2 > v:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1399909,
                "title": "c-solution-easy-to-understand-image-explaination",
                "content": "The idea is to get the number of zeros in the suffix of each array. We will count the number of zeros on the right end of each row anf when we encounter one we break from that row, moreover we store the number of zeros in the right side of that row in a array.\\n\\nnow, ![image](https://assets.leetcode.com/users/images/2e732818-c6a7-4fe6-84e0-29a952997268_1628787555.2624369.png)\\n\\nKnowing the aboe logic the problem is being melt down to find the minimum number of adjecent swaps to sort the array in increasing order.\\n\\t\\n\\tint minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        //store the continous zeros in right side of each row\\n        vector<int> zeros(n, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=n-1; j>=1; j--){\\n                if(grid[i][j] == 0){\\n\\t\\t\\t\\t//if zeros is found the increment\\n                    zeros[i]++;\\n                } \\n\\t\\t\\t\\t//else break\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n\\t\\t//the required number of zeros in the corresponding row\\n            int req = n-i-1;\\n            int k=i;\\n            while(k < n && min(req, zeros[k]) != req){\\n                k++;\\n            }\\n            //if we are unable to find such then return -1 (not possible)\\n            if(k == n){\\n                return -1;\\n            }\\n            //else add hte number of swaps in the answer\\n            ans += (k - i);\\n\\t\\t\\t//drag the required number of zeros to the current index by swapping it with its previous elements.\\n            while(k > i){\\n                swap(zeros[k], zeros[k-1]);\\n                k--;\\n            }\\n        }\\n        //retrun the number of swaps\\n        return ans;\\n    }\\n\\t\\n**Hope it helped!**",
                "solutionTags": [
                    "C"
                ],
                "code": "The idea is to get the number of zeros in the suffix of each array. We will count the number of zeros on the right end of each row anf when we encounter one we break from that row, moreover we store the number of zeros in the right side of that row in a array.\\n\\nnow, ![image](https://assets.leetcode.com/users/images/2e732818-c6a7-4fe6-84e0-29a952997268_1628787555.2624369.png)\\n\\nKnowing the aboe logic the problem is being melt down to find the minimum number of adjecent swaps to sort the array in increasing order.\\n\\t\\n\\tint minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        //store the continous zeros in right side of each row\\n        vector<int> zeros(n, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=n-1; j>=1; j--){\\n                if(grid[i][j] == 0){\\n\\t\\t\\t\\t//if zeros is found the increment\\n                    zeros[i]++;\\n                } \\n\\t\\t\\t\\t//else break\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n\\t\\t//the required number of zeros in the corresponding row\\n            int req = n-i-1;\\n            int k=i;\\n            while(k < n && min(req, zeros[k]) != req){\\n                k++;\\n            }\\n            //if we are unable to find such then return -1 (not possible)\\n            if(k == n){\\n                return -1;\\n            }\\n            //else add hte number of swaps in the answer\\n            ans += (k - i);\\n\\t\\t\\t//drag the required number of zeros to the current index by swapping it with its previous elements.\\n            while(k > i){\\n                swap(zeros[k], zeros[k-1]);\\n                k--;\\n            }\\n        }\\n        //retrun the number of swaps\\n        return ans;\\n    }\\n\\t\\n**Hope it helped!**",
                "codeTag": "Unknown"
            },
            {
                "id": 1299896,
                "title": "c-easy-solution-greedy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int ar[n+1];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int num=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    num++;\\n                }\\n                else\\n                {\\n                    break ;\\n                }\\n            }\\n            ar[i]=num;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ar[i]>=n-i-1)\\n            {\\n                continue ;\\n            }\\n            int j=i+1;\\n            bool temp=false;\\n            for(;j<n;j++)\\n            {\\n                if(ar[j]>=n-i-1)\\n                {\\n                    temp=true;\\n                    break ;\\n                }\\n            }\\n            if(!temp)\\n            {\\n                return -1;\\n            }\\n            while(j!=i)\\n            {\\n                swap(ar[j],ar[j-1]);\\n                ans++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int ar[n+1];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int num=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    num++;\\n                }\\n                else\\n                {\\n                    break ;\\n                }\\n            }\\n            ar[i]=num;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ar[i]>=n-i-1)\\n            {\\n                continue ;\\n            }\\n            int j=i+1;\\n            bool temp=false;\\n            for(;j<n;j++)\\n            {\\n                if(ar[j]>=n-i-1)\\n                {\\n                    temp=true;\\n                    break ;\\n                }\\n            }\\n            if(!temp)\\n            {\\n                return -1;\\n            }\\n            while(j!=i)\\n            {\\n                swap(ar[j],ar[j-1]);\\n                ans++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185469,
                "title": "c-c-n-2",
                "content": "```\\nclass Solution {\\n   \\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int res = 0;    \\n        int n = grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=n-1;\\n            while(j>=0 && grid[i][j]==0)\\n                j--;\\n            grid[i][0] = n-j-1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for( int j=0; j<n; j++)\\n            {\\n                if (grid[j][0]>=n-i-1)\\n                {\\n                    res += c;\\n                    grid[j][0] = -1;\\n                    break;\\n                }\\n                if (grid[j][0]!=-1)\\n                    c++;\\n            }\\n            if(j==n)\\n                return -1;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int res = 0;    \\n        int n = grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=n-1;\\n            while(j>=0 && grid[i][j]==0)\\n                j--;\\n            grid[i][0] = n-j-1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for( int j=0; j<n; j++)\\n            {\\n                if (grid[j][0]>=n-i-1)\\n                {\\n                    res += c;\\n                    grid[j][0] = -1;\\n                    break;\\n                }\\n                if (grid[j][0]!=-1)\\n                    c++;\\n            }\\n            if(j==n)\\n                return -1;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074051,
                "title": "clear-o-n-2-python-solution",
                "content": "Happy to clarify if any of this is unclear -- let me know.\\n\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        # For each row, we just need to make sure the column of the last 1\\n        # is <= the row\\'s position in the grid (row at index 0 can have a 1\\n        # at its 0th column, row at index 1 can have a 1 at its 1th column, etc.).\\n        # So we store the information about the column of the last 1.\\n        must_be_gte = [\\n            max([i for i in range(len(row)) if row[i] == 1], default=-1)\\n            for row in grid\\n        ]\\n        \\n        # Now at each index of the grid, we try to keep the current row.\\n        # If we can\\'t (b/c its last 1 is > the index of the row), we find\\n        # the next available row which does fit the condition, and swap it\\n        # bubble sort style leftwards all the way to the current index.\\n        swaps = 0\\n        for index in range(len(grid)):\\n            if must_be_gte[index] > index:\\n                found = False\\n                for swap_index in range(index + 1, len(grid)):\\n                    if must_be_gte[swap_index] <= index:\\n                        must_be_gte.insert(index, must_be_gte.pop(swap_index))\\n                        swaps += swap_index - index\\n                        found = True\\n                        break\\n                if not found:\\n                    return -1\\n        return swaps",
                "solutionTags": [],
                "code": "Happy to clarify if any of this is unclear -- let me know.\\n\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        # For each row, we just need to make sure the column of the last 1\\n        # is <= the row\\'s position in the grid (row at index 0 can have a 1\\n        # at its 0th column, row at index 1 can have a 1 at its 1th column, etc.).\\n        # So we store the information about the column of the last 1.\\n        must_be_gte = [\\n            max([i for i in range(len(row)) if row[i] == 1], default=-1)\\n            for row in grid\\n        ]\\n        \\n        # Now at each index of the grid, we try to keep the current row.\\n        # If we can\\'t (b/c its last 1 is > the index of the row), we find\\n        # the next available row which does fit the condition, and swap it\\n        # bubble sort style leftwards all the way to the current index.\\n        swaps = 0\\n        for index in range(len(grid)):\\n            if must_be_gte[index] > index:\\n                found = False\\n                for swap_index in range(index + 1, len(grid)):\\n                    if must_be_gte[swap_index] <= index:\\n                        must_be_gte.insert(index, must_be_gte.pop(swap_index))\\n                        swaps += swap_index - index\\n                        found = True\\n                        break\\n                if not found:\\n                    return -1\\n        return swaps",
                "codeTag": "Python3"
            },
            {
                "id": 1039987,
                "title": "brute-force-bubble-sort",
                "content": "```\\npublic int minSwaps(int[][] grid) {\\n        int m = grid.length, start = 1, ans = 0;\\n        int[] r = new int[m];\\n        for (int i = 1; i < m; i++){\\n            r[i] = i;\\n        }\\n        for (int i = 0; i < m; i++){\\n            if (isValid(grid,start,r[i])){\\n                start+=1;\\n                continue;\\n            }\\n            boolean flag = true;                // brute force\\n            for (int j = i+1; j < m; j++){\\n                if (isValid(grid,start,r[j])){\\n                    flag = false;\\n                    ans += swap(r,i,j);\\n                    break;\\n                }\\n            }\\n            if (flag) return -1;\\n            start++;\\n        }\\n        return ans; \\n    }\\n    boolean isValid(int[][] grid, int start, int row){\\n        for (int i = start; i < grid[0].length; i++){\\n            if (grid[row][i] == 1) return false;\\n        }\\n        return true;\\n    }\\n    int swap(int[] r, int start, int end){\\n        int cnt = 0;\\n        for (int i = end; i >= start+1; i--){\\n            int tmp = r[i];\\n            r[i] = r[i-1];\\n            r[i-1] = tmp;\\n            cnt +=1;\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSwaps(int[][] grid) {\\n        int m = grid.length, start = 1, ans = 0;\\n        int[] r = new int[m];\\n        for (int i = 1; i < m; i++){\\n            r[i] = i;\\n        }\\n        for (int i = 0; i < m; i++){\\n            if (isValid(grid,start,r[i])){\\n                start+=1;\\n                continue;\\n            }\\n            boolean flag = true;                // brute force\\n            for (int j = i+1; j < m; j++){\\n                if (isValid(grid,start,r[j])){\\n                    flag = false;\\n                    ans += swap(r,i,j);\\n                    break;\\n                }\\n            }\\n            if (flag) return -1;\\n            start++;\\n        }\\n        return ans; \\n    }\\n    boolean isValid(int[][] grid, int start, int row){\\n        for (int i = start; i < grid[0].length; i++){\\n            if (grid[row][i] == 1) return false;\\n        }\\n        return true;\\n    }\\n    int swap(int[] r, int start, int end){\\n        int cnt = 0;\\n        for (int i = end; i >= start+1; i--){\\n            int tmp = r[i];\\n            r[i] = r[i-1];\\n            r[i-1] = tmp;\\n            cnt +=1;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023517,
                "title": "c-beat-100",
                "content": "```\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        list<int> cnt0;\\n        for(const auto& v:grid) \\n            cnt0.push_back(find(v.rbegin(), v.rend(), 1) - v.rbegin());\\n        \\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            for(auto it = cnt0.begin(); it !=cnt0.end(); ++it, ++j){\\n                if(*it >= n-i-1){\\n                    res += j;\\n                    cnt0.erase(it);\\n                    break;\\n                }\\n            }\\n            if(j==n-i) return -1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        list<int> cnt0;\\n        for(const auto& v:grid) \\n            cnt0.push_back(find(v.rbegin(), v.rend(), 1) - v.rbegin());\\n        \\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            for(auto it = cnt0.begin(); it !=cnt0.end(); ++it, ++j){\\n                if(*it >= n-i-1){\\n                    res += j;\\n                    cnt0.erase(it);\\n                    break;\\n                }\\n            }\\n            if(j==n-i) return -1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 836042,
                "title": "cpp-just-like-bubble-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> zero_count;\\n        for (const auto &each : grid) {\\n            int count = 0;\\n            for (int i = n - 1; i >= 0; --i) {\\n                if (each[i]) break;\\n                count += 1;\\n            }\\n            zero_count.push_back(count);\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (zero_count[i] < n - 1 - i) {\\n                int end = i;\\n                while (end < n && zero_count[end] < n - 1 - i) {\\n                    ++end;\\n                }\\n                if (end == n) return -1;\\n                while (end > i) {\\n                    swap(zero_count[end], zero_count[end-1]);\\n                    --end;\\n                    ++moves;\\n                }\\n            }\\n        }\\n        return moves;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> zero_count;\\n        for (const auto &each : grid) {\\n            int count = 0;\\n            for (int i = n - 1; i >= 0; --i) {\\n                if (each[i]) break;\\n                count += 1;\\n            }\\n            zero_count.push_back(count);\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (zero_count[i] < n - 1 - i) {\\n                int end = i;\\n                while (end < n && zero_count[end] < n - 1 - i) {\\n                    ++end;\\n                }\\n                if (end == n) return -1;\\n                while (end > i) {\\n                    swap(zero_count[end], zero_count[end-1]);\\n                    --end;\\n                    ++moves;\\n                }\\n            }\\n        }\\n        return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817254,
                "title": "java-simple-bubble-sort",
                "content": "Ref: https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/767912/Java-16-lines-bubble-sort-with-line-by-line-explanation-easy-to-understand\\n```\\n    public int minSwaps(int[][] g) {\\n        List<Integer> l = new LinkedList<>();\\n        int m = g.length, n = g[0].length, res = 0;\\n        for (int i = 0, z = 0; i < m; i++, z = 0) {// z trailing zeros\\n            for (int j = n - 1; j >= 0 && g[i][j] == 0; j--) z++;\\n            l.add(z);\\n        }\\n        for (int i = 0, j = 0, z = m - 1; i < m; i++, z--, j = i) {\\n            while (l.get(j) < z) if (++j >= n) return -1;\\n            l.remove(j);\\n            l.add(i, z);\\n            res += j - i;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSwaps(int[][] g) {\\n        List<Integer> l = new LinkedList<>();\\n        int m = g.length, n = g[0].length, res = 0;\\n        for (int i = 0, z = 0; i < m; i++, z = 0) {// z trailing zeros\\n            for (int j = n - 1; j >= 0 && g[i][j] == 0; j--) z++;\\n            l.add(z);\\n        }\\n        for (int i = 0, j = 0, z = m - 1; i < m; i++, z--, j = i) {\\n            while (l.get(j) < z) if (++j >= n) return -1;\\n            l.remove(j);\\n            l.add(i, z);\\n            res += j - i;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776729,
                "title": "java-greedy-count-tailing-zeros-beats-100",
                "content": "1. Count tailing zeroes.\\n2. For each row find the first a row that fits\\n3. Reorder records from the current row to the one needed.\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] rows = new int[grid.length];\\n\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = grid.length-1; j>=0; j--) {\\n                if (grid[i][j] == 1)\\n                    break;\\n                \\n                rows[i]++;\\n            }\\n\\n        }\\n        \\n        return sort(rows);\\n    }\\n    \\n    private int sort(int[] a){\\n        int steps = 0;\\n        int n = a.length-1;\\n        \\n        for (int i=0; i<=n; i++) {\\n            int j = i;\\n            while (j <= n && a[j] < n-i) {\\n                j++;\\n            }\\n            \\n            if (j == n+1) return -1;\\n            \\n            if (i<j && i<n) {\\n                int tmp = a[i];\\n                for(int k=i+1; k<=j; k++){\\n                    int tt = a[k];\\n                    a[k] = tmp;\\n                    tmp = tt;\\n                }\\n                \\n                a[i] = tmp;\\n            }\\n            \\n            steps += j-i;\\n        }\\n        return steps;\\n    }\\n}\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] rows = new int[grid.length];\\n\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = grid.length-1; j>=0; j--) {\\n                if (grid[i][j] == 1)\\n                    break;\\n                \\n                rows[i]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 775934,
                "title": "c-insertion-sort-idea-100-faster",
                "content": "The idea here is we need atleast n-1 zeros at the end in zeroth row and n-2 in first row and atleast (n-1-i) zeros in ith row. So, we can maintain a count of zeros on the right in some array/vector and then check if we have enough zeros according to the condition above to check whether there exists any answer or not.\\nAnd if there exists some answer then we can simulate swaps like we do in insertion sort to sort the array on the vector containing count of zeros on the right.\\n\\n```\\nclass Solution {\\npublic:\\n\\t// Function to simulate swaps like insertion sort\\n    int SWAP(vector<int>& rightzero,int idx){   \\n        int n=rightzero.size(),ans=0;\\n        int x=rightzero[idx];\\n        for(int i=idx+1;i<n;i++){\\n            if(rightzero[i]>=n-1-idx){\\n                ans+=i-idx;   // The number of swaps would be the difference in these indices\\n                for(int j=i;j>idx;j--)  // Do swaps\\n                    swap(rightzero[j],rightzero[j-1]);\\n                break;\\n            }\\n        }    \\n        return ans;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0)\\n            return 0;\\n        vector<int> rightzero(n,0);\\n\\t\\t// Creating the rightzero vector\\n        for(int i=0;i<n;i++){\\n            for(auto j=n-1;j>=0 && grid[i][j]!=1;j--)\\n                rightzero[i]++;\\n        }\\n        vector<int> temp=rightzero;\\n\\t\\t\\n\\t\\t// We can easily check after sorting that whether there exists some answer or not.\\n\\t\\t// We can swap in descending order also, here consider the matrix is turned upside down so last row is at the top.\\n\\t\\t//so number of zeros there should be >=0\\n        sort(temp.begin(),temp.end());\\n        for(int i=0;i<n;i++)\\n            if(temp[i]<i)\\n                return -1;\\n        int ans=0;\\n\\t\\t\\n\\t\\t// Insertion Sort Function\\n        for(int i=0;i<n;i++){\\n            if(rightzero[i]>=n-1-i)\\n                continue;\\n            ans+=SWAP(rightzero,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Function to simulate swaps like insertion sort\\n    int SWAP(vector<int>& rightzero,int idx){   \\n        int n=rightzero.size(),ans=0;\\n        int x=rightzero[idx];\\n        for(int i=idx+1;i<n;i++){\\n            if(rightzero[i]>=n-1-idx){\\n                ans+=i-idx;   // The number of swaps would be the difference in these indices\\n                for(int j=i;j>idx;j--)  // Do swaps\\n                    swap(rightzero[j],rightzero[j-1]);\\n                break;\\n            }\\n        }    \\n        return ans;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0)\\n            return 0;\\n        vector<int> rightzero(n,0);\\n\\t\\t// Creating the rightzero vector\\n        for(int i=0;i<n;i++){\\n            for(auto j=n-1;j>=0 && grid[i][j]!=1;j--)\\n                rightzero[i]++;\\n        }\\n        vector<int> temp=rightzero;\\n\\t\\t\\n\\t\\t// We can easily check after sorting that whether there exists some answer or not.\\n\\t\\t// We can swap in descending order also, here consider the matrix is turned upside down so last row is at the top.\\n\\t\\t//so number of zeros there should be >=0\\n        sort(temp.begin(),temp.end());\\n        for(int i=0;i<n;i++)\\n            if(temp[i]<i)\\n                return -1;\\n        int ans=0;\\n\\t\\t\\n\\t\\t// Insertion Sort Function\\n        for(int i=0;i<n;i++){\\n            if(rightzero[i]>=n-1-i)\\n                continue;\\n            ans+=SWAP(rightzero,i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774371,
                "title": "c-100-100",
                "content": "```\\npublic int MinSwaps(int[][] grid) {\\n\\tvar search = grid.Select((_, i) => grid.Length - i - 1).ToArray();\\n\\tvar zeroes = grid.Select((r, i) => r.Reverse().TakeWhile(x => x == 0).Count()).ToArray();\\n\\tvar swaps = 0;\\n\\n\\tfor (var i = 0; i < grid.Length; i++) {\\n\\t\\tvar swap = (src: -1, dest: -1);\\n\\n\\t\\tfor (var j = i; j < grid.Length; j++) {\\n\\t\\t\\tif (zeroes[j] >= search[i]) {\\n\\t\\t\\t\\tswap = (src: j, dest: i);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (swap == (-1, -1)) return -1;\\n\\n\\t\\tswaps += swap.src - swap.dest;\\n\\t\\tfor (var k = swap.src; k > swap.dest; k--)\\n\\t\\t\\t(zeroes[k], zeroes[k - 1]) = (zeroes[k - 1], zeroes[k]);\\n\\t}\\n\\n\\treturn swaps;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MinSwaps(int[][] grid) {\\n\\tvar search = grid.Select((_, i) => grid.Length - i - 1).ToArray();\\n\\tvar zeroes = grid.Select((r, i) => r.Reverse().TakeWhile(x => x == 0).Count()).ToArray();\\n\\tvar swaps = 0;\\n\\n\\tfor (var i = 0; i < grid.Length; i++) {\\n\\t\\tvar swap = (src: -1, dest: -1);\\n\\n\\t\\tfor (var j = i; j < grid.Length; j++) {\\n\\t\\t\\tif (zeroes[j] >= search[i]) {\\n\\t\\t\\t\\tswap = (src: j, dest: i);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (swap == (-1, -1)) return -1;\\n\\n\\t\\tswaps += swap.src - swap.dest;\\n\\t\\tfor (var k = swap.src; k > swap.dest; k--)\\n\\t\\t\\t(zeroes[k], zeroes[k - 1]) = (zeroes[k - 1], zeroes[k]);\\n\\t}\\n\\n\\treturn swaps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 771357,
                "title": "java-1ms-100-fastest-solution-100-memory-efficient",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int arr[] = new int[grid.length];\\n        for(int i=0;i<grid.length;i++){\\n            int count=0;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[i][j]==0)count++;\\n                else{\\n                    arr[i]=count;\\n                    break;\\n                }\\n            }\\n                \\n        }\\n        int swaps=0;\\n        int ref =arr.length-1;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>=ref){\\n                ref--;\\n                continue;\\n            } \\n            int j=i+1;\\n            while(j<arr.length&&arr[j]<ref)\\n            {\\n                int temp = arr[i];\\n                arr[i]=arr[j];\\n                arr[j]= temp;\\n                j++;\\n                swaps++;\\n            }\\n            if(j<arr.length){\\n            int temp = arr[i];\\n            arr[i]=arr[j];\\n            arr[j]= temp;\\n            swaps++;\\n            ref--;}\\n            else\\n                return -1;\\n\\n            \\n        }\\n        return swaps;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int arr[] = new int[grid.length];\\n        for(int i=0;i<grid.length;i++){\\n            int count=0;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[i][j]==0)count++;\\n                else{\\n                    arr[i]=count;\\n                    break;\\n                }\\n            }\\n                \\n        }\\n        int swaps=0;\\n        int ref =arr.length-1;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>=ref){\\n                ref--;\\n                continue;\\n            } \\n            int j=i+1;\\n            while(j<arr.length&&arr[j]<ref)\\n            {\\n                int temp = arr[i];\\n                arr[i]=arr[j];\\n                arr[j]= temp;\\n                j++;\\n                swaps++;\\n            }\\n            if(j<arr.length){\\n            int temp = arr[i];\\n            arr[i]=arr[j];\\n            arr[j]= temp;\\n            swaps++;\\n            ref--;}\\n            else\\n                return -1;\\n\\n            \\n        }\\n        return swaps;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770909,
                "title": "python3-580ms-greedy-o-n-2",
                "content": "For each row find the target row and do \"insert\" the target row to the destination greedily.\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for i, x in enumerate(grid):\\n            found = False\\n            for j in range(i, len(grid)):\\n                ok = True\\n                for k in range(i+1, len(grid[j])):\\n                    if grid[j][k] == 1:\\n                        ok = False\\n                        break\\n                if ok:\\n                    found = True\\n                    while j > i:\\n                        res += 1\\n                        grid[j], grid[j-1] = grid[j-1], grid[j]\\n                        j -= 1\\n                    break\\n            if not found: return -1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for i, x in enumerate(grid):\\n            found = False\\n            for j in range(i, len(grid)):\\n                ok = True\\n                for k in range(i+1, len(grid[j])):\\n                    if grid[j][k] == 1:\\n                        ok = False\\n                        break\\n                if ok:\\n                    found = True\\n                    while j > i:\\n                        res += 1\\n                        grid[j], grid[j-1] = grid[j-1], grid[j]\\n                        j -= 1\\n                    break\\n            if not found: return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770756,
                "title": "java-bubble-sort-with-comments",
                "content": "````\\n\\tpublic int minSwaps(int[][] grid) {\\n        int n = grid.length, A[] = new int[n], res = 0;\\n        \\n        // A[i] - number of zeros at end of ith row = grid[i]\\n        for (int i = 0; i < n; i++) \\n            for (int j = n-1; j >= 0 && grid[i][j] == 0; j--) \\n                A[i]++;                \\n        \\n        // sort by descending the number of zeros\\n        // to be above the main diagonal are zeros: A[i] >= n-i-1;\\n        for (int i = 0; i < n; i++) {\\n            \\n            // above diagonal itself\\n            if (A[i] >= n-i-1) continue;\\n            \\n            // under diagonal we search j: A[j] >= n-i-1\\n            int j = i+1;\\n            while (j < n && A[j] < n-i-1) j++;\\n            \\n            // if not found\\n            if (j == n) return -1;\\n            \\n            // if found j: swap 2 adjacent rows\\n            while (j > i) {\\n                swap(A, j-1, j--);\\n                res++;\\n            }\\n        } \\n                        \\n        return res;                \\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int tmp = A[i]; A[i] = A[j]; A[j] = tmp;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic int minSwaps(int[][] grid) {\\n        int n = grid.length, A[] = new int[n], res = 0;\\n        \\n        // A[i] - number of zeros at end of ith row = grid[i]\\n        for (int i = 0; i < n; i++) \\n            for (int j = n-1; j >= 0 && grid[i][j] == 0; j--) \\n                A[i]++;                \\n        \\n        // sort by descending the number of zeros\\n        // to be above the main diagonal are zeros: A[i] >= n-i-1;\\n        for (int i = 0; i < n; i++) {\\n            \\n            // above diagonal itself\\n            if (A[i] >= n-i-1) continue;\\n            \\n            // under diagonal we search j: A[j] >= n-i-1\\n            int j = i+1;\\n            while (j < n && A[j] < n-i-1) j++;\\n            \\n            // if not found\\n            if (j == n) return -1;\\n            \\n            // if found j: swap 2 adjacent rows\\n            while (j > i) {\\n                swap(A, j-1, j--);\\n                res++;\\n            }\\n        } \\n                        \\n        return res;                \\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int tmp = A[i]; A[i] = A[j]; A[j] = tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 769619,
                "title": "python-greedy-solution-100-time-and-space",
                "content": "Same greedy idea as other posts. Both time and space achieves 100. It is provable by contradiction that greedy is always best solution. \\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        status = []\\n        def gettrailzeros(row):\\n            for j in range(n-1, -1, -1):\\n                if grid[row][j] != 0:\\n                    return n-1-j\\n            return n\\n        for i in range(n):\\n            status.append(gettrailzeros(i))\\n        target = [n-i for i in range(1,n+1)]\\n        # greedy\\n        step = 0\\n        for i in range(n):\\n            if status[i] >= target[i]:\\n                continue\\n            for j in range(i+1, n):\\n                if status[j] >= target[i]:\\n                    for pos in range(j, i,-1):\\n                        status[pos], status[pos-1] = status[pos-1], status[pos]\\n                        step += 1\\n                    break\\n            else:\\n                return -1\\n        return step\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        status = []\\n        def gettrailzeros(row):\\n            for j in range(n-1, -1, -1):\\n                if grid[row][j] != 0:\\n                    return n-1-j\\n            return n\\n        for i in range(n):\\n            status.append(gettrailzeros(i))\\n        target = [n-i for i in range(1,n+1)]\\n        # greedy\\n        step = 0\\n        for i in range(n):\\n            if status[i] >= target[i]:\\n                continue\\n            for j in range(i+1, n):\\n                if status[j] >= target[i]:\\n                    for pos in range(j, i,-1):\\n                        status[pos], status[pos-1] = status[pos-1], status[pos]\\n                        step += 1\\n                    break\\n            else:\\n                return -1\\n        return step\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 768931,
                "title": "intuitive-approach-in-c-with-explanation",
                "content": "My idea is  based on an important observation/fact that i th row requires (n-i-1) zeroes. You can see it yourself with an example e.g. Matrix of size 4 * 4 - first row requires 3 zeroes -  i.e. (n-(rownumber)) = n-1 = 3. Similarly 2nd row requires 4-2=2 zeroes and 4th row requires 4-4=0 zeroes. Since we have 0 based indexing so n-(i+1)= n-i-1.\\n\\nStep 1: Find number of zeroes present in each row from right. \\nStep 2: If number of zeroes in a row is sufficient for the row i..e >= n-i-1 then we don;t do anything. \\n            Else we target to swap the row with its next nearest row which has sufficient zeroes. And in this  \\n\\t\\t\\tway our starting rows are getting their sufficient zeroes ( kind of bubble sort )\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int>rowzero(n,0);\\n        \\n        //counting the number of zeroes in each row from right\\n        for(int i=0;i<n;++i)\\n        {   \\n            for(int j=n-1;j>=0;--j)\\n            {\\n                if(grid[i][j]==1)\\n                    break;\\n                else\\n                    rowzero[i]++;\\n                   }\\n        }\\n        \\n        int ans=0;\\n        \\n      // finding the correct and nearest row to swap with  \\n       for(int i=0;i<n;++i)\\n       {\\n           if(rowzero[i]>=(n-i-1))\\n               continue;\\n           else{\\n              \\n               int ans1=INT_MAX;\\n               \\n               int j=i+1;   \\n           for( j=i+1;j<n;++j)\\n           {\\n               if(rowzero[j]>=(n-i-1))\\n               {\\n                   ans1=j-i;\\n                   break;\\n               }\\n           }\\n               \\n               if(j==n && ans1==INT_MAX)\\n                   return -1;\\n               \\n                 while(j-1>=i)\\n                 {\\n                     swap(rowzero[j], rowzero[j-1]);\\n                     j--;\\n                 }\\n                 \\n                  ans+=ans1;\\n                }\\n       }\\n      \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\nIf you still have any doubt in approach or code, feel free to comment and ask.\\n\\nThank You for reading.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int>rowzero(n,0);\\n        \\n        //counting the number of zeroes in each row from right\\n        for(int i=0;i<n;++i)\\n        {   \\n            for(int j=n-1;j>=0;--j)\\n            {\\n                if(grid[i][j]==1)\\n                    break;\\n                else\\n                    rowzero[i]++;\\n                   }\\n        }\\n        \\n        int ans=0;\\n        \\n      // finding the correct and nearest row to swap with  \\n       for(int i=0;i<n;++i)\\n       {\\n           if(rowzero[i]>=(n-i-1))\\n               continue;\\n           else{\\n              \\n               int ans1=INT_MAX;\\n               \\n               int j=i+1;   \\n           for( j=i+1;j<n;++j)\\n           {\\n               if(rowzero[j]>=(n-i-1))\\n               {\\n                   ans1=j-i;\\n                   break;\\n               }\\n           }\\n               \\n               if(j==n && ans1==INT_MAX)\\n                   return -1;\\n               \\n                 while(j-1>=i)\\n                 {\\n                     swap(rowzero[j], rowzero[j-1]);\\n                     j--;\\n                 }\\n                 \\n                  ans+=ans1;\\n                }\\n       }\\n      \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768601,
                "title": "explained-greedy-n-2-prefix-sum-cpp-solution-commented-beats-100",
                "content": "**APPROACH**\\nWe want zeros on upper triange of the matrix so for every row we need to find if there exist a row in required format.Like \\nsay **n=4** the required formats are\\nRow 1  **x000**\\nRow 2  **xx00**\\nRow 3  **xxx0**\\nRow 4  **xxxx**\\n\\n**Here if our answer exist it will be in above format with rows distorted like instead of R1234 it can be R3214 or R1423 so we need to just find the required row position.** Now say at ith row we start seeking the row which fits with ith format and we get that at xth position then we can reach there by swapping every row above x consequently till we reach i that is (x-i) swaps. \\nWe\\'ll do it for every row and count number of swaps. \\nSince there can be multiple rows fitting in a format (like for xxx0 it can be 1010 or 1000) we\\'ll take the one which is nearer because we need to minimize the swaps.\\n..\\n**Wait.... how will you check the format??\\nIts simple use prefix sum from right.\\nLike for R = xx00 if a row satisfies the format then at index 1 sum will be either (0 or 1 if R[1]==1)**\\n\\n**Walk through the Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<vector<int>> v=grid;\\n        int n=grid.size();\\n        if(n==1) return grid[0][0]==1?0:-1;\\n        for(int i=0;i<n;i++){\\n            for(int j=n-2;j>=0;j--){\\n                v[i][j]+=v[i][j+1];                  // Building prefix sum array from right  end\\n            }\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<n-1;i++){\\n            if(v[i][i]>1 || (grid[i][i]==0 && v[i][i]==1)){             //If row doesn\\'t satisfies the format\\n                int idx=-1;                                               \\n                for(int x=i+1;x<n;x++){                                      // Start searching from below\\n                    if(v[x][i]==0 || (v[x][i]==1 && grid[x][i]==1)){\\n                        idx=x;                                                         //Stop immediately as you get the format\\n                        break;\\n                    }\\n                }\\n                if(idx==-1) return -1;                                    //If we can\\'t find the format return -1\\n                c+=(idx-i);\\n                \\n                v.insert(v.begin()+i,v[idx]);                            //Insert the (idx)th to ith position and remove it from prev position \\n                grid.insert(grid.begin()+i,grid[idx]);\\n                v.erase(v.begin()+idx+1);                               //Do the same insertion and deletion to both original and prefix arrays\\n                grid.erase(grid.begin()+idx+1);\\n                \\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```\\n**STATS**\\n**Runtime: 196 ms, faster than 100.00%** of C++ online submissions for Minimum Swaps to Arrange a Binary Grid.\\n**Memory Usage: 31.2 MB, less than 100.00%** of C++ online submissions for Minimum Swaps to Arrange a Binary Grid.\\nAs on 02/08/2020\\n\\n//Don\\'t know whether v.insert() or v.erase() will cause it to go N^3 please correct me if soln is N^3",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<vector<int>> v=grid;\\n        int n=grid.size();\\n        if(n==1) return grid[0][0]==1?0:-1;\\n        for(int i=0;i<n;i++){\\n            for(int j=n-2;j>=0;j--){\\n                v[i][j]+=v[i][j+1];                  // Building prefix sum array from right  end\\n            }\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<n-1;i++){\\n            if(v[i][i]>1 || (grid[i][i]==0 && v[i][i]==1)){             //If row doesn\\'t satisfies the format\\n                int idx=-1;                                               \\n                for(int x=i+1;x<n;x++){                                      // Start searching from below\\n                    if(v[x][i]==0 || (v[x][i]==1 && grid[x][i]==1)){\\n                        idx=x;                                                         //Stop immediately as you get the format\\n                        break;\\n                    }\\n                }\\n                if(idx==-1) return -1;                                    //If we can\\'t find the format return -1\\n                c+=(idx-i);\\n                \\n                v.insert(v.begin()+i,v[idx]);                            //Insert the (idx)th to ith position and remove it from prev position \\n                grid.insert(grid.begin()+i,grid[idx]);\\n                v.erase(v.begin()+idx+1);                               //Do the same insertion and deletion to both original and prefix arrays\\n                grid.erase(grid.begin()+idx+1);\\n                \\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768536,
                "title": "python-clear-straight-detail-explanation",
                "content": "```\\nclass Solution:\\n    def count_trailing_zero(self,array,n):\\n        # takes an array and returns number of trailing zeros in that array\\n\\n        count = 0\\n        # traversing array from end to start \\n        for i in range(n-1,-1,-1):\\n            if array[i] == 0:\\n                count += 1\\n            else:       # break as soon we found a non zero element\\n                break\\n        return count    # return count\\n    \\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        # initialize empty array to store count of trailing zeros at each row\\n        trail_zeros = [0]*n\\n        \\n        # getting trailing zeros for all rows\\n        for i in range(n):\\n            trail_zeros[i] = self.count_trailing_zero( grid[i], n ) \\n            \\n        \\n        swaps = 0\\n        for i in range(n-1):\\n            # target = number of zeros we required at row i, when i = 0 we requires n-1 trailing zeros\\n            target = n-1-i\\n            \\n            # if condition already meet than continue\\n            if target <= trail_zeros[i]:\\n                continue\\n            \\n            # else search for required target in row below current row\\n            found_target = False\\n            for j in range(i+1,n):\\n                if trail_zeros[j] >= target:\\n                    found_target = True\\n                    swaps += (j-i)\\n                    # save j th element in t (target value)\\n                    t = trail_zeros[j]\\n                    # shift right all element by 1 in index range i to j\\n                    trail_zeros[i+1:j+1] = trail_zeros[i:j]\\n                    # replace target value at required position\\n                    trail_zeros[i] = t\\n                    break\\n                \\n            if not found_target:\\n                return -1\\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def count_trailing_zero(self,array,n):\\n        # takes an array and returns number of trailing zeros in that array\\n\\n        count = 0\\n        # traversing array from end to start \\n        for i in range(n-1,-1,-1):\\n            if array[i] == 0:\\n                count += 1\\n            else:       # break as soon we found a non zero element\\n                break\\n        return count    # return count\\n    \\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        # initialize empty array to store count of trailing zeros at each row\\n        trail_zeros = [0]*n\\n        \\n        # getting trailing zeros for all rows\\n        for i in range(n):\\n            trail_zeros[i] = self.count_trailing_zero( grid[i], n ) \\n            \\n        \\n        swaps = 0\\n        for i in range(n-1):\\n            # target = number of zeros we required at row i, when i = 0 we requires n-1 trailing zeros\\n            target = n-1-i\\n            \\n            # if condition already meet than continue\\n            if target <= trail_zeros[i]:\\n                continue\\n            \\n            # else search for required target in row below current row\\n            found_target = False\\n            for j in range(i+1,n):\\n                if trail_zeros[j] >= target:\\n                    found_target = True\\n                    swaps += (j-i)\\n                    # save j th element in t (target value)\\n                    t = trail_zeros[j]\\n                    # shift right all element by 1 in index range i to j\\n                    trail_zeros[i+1:j+1] = trail_zeros[i:j]\\n                    # replace target value at required position\\n                    trail_zeros[i] = t\\n                    break\\n                \\n            if not found_target:\\n                return -1\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768534,
                "title": "python-easy-solution-with-full-explanation-why-sorting",
                "content": "\\n\\t\\n\\tUsing count inversions we can easily solve this problem.\\n\\t.Just by selecting the first most satisfying position of\\n\\trequired value we can create the list by storing it.\\n\\tAnd then easily counting inversions in it.\\n\\t\\n\\tEveryone might have doubt that why sorting?\\n\\tHere is the answer:\\n\\tsuppose the position list to satisfy is:\\n\\t(4*4 matrix)\\n\\t1 0 0 1\\n\\t1 0 0 0\\n\\t1 1 1 0\\n\\t1 1 0 0 \\n\\tposition array is:--     [4,3,1]   (0 based indexing)\\n\\tunrequired row:--    0 so swap req to send it to end = (n-1-miss)=(3-0)=3\\n\\tnow position array should become:---    [2,1,0]\\n\\tand it will require same inversions as required to sort array([4,3,1] )\\n\\t\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n=len(grid);d=[-1]*(n-1)\\n        if(n==1 and grid[0][0]==1):return 0\\n        for i in range(n):\\n            cnt=0\\n            for j in grid[i][::-1]:\\n                if(j==0):cnt+=1\\n                else:break\\n            for j in range(n-2,-1,-1):\\n                if(d[j]==-1 and j+1<=cnt):       #storing all the first most satisfying position\\n                    d[j]=i\\n                    break     \\n        for i in d:\\n            if(i==-1):return -1     #some row remain unsatisfied\\n        miss=(n*(n-1))//2-sum(d)                            #finding the unrequired row\\n        d=d[::-1];\\n\\t\\tinv=n-1-miss                                              #sending the unrequired value to end.\\n        n=len(d)\\n        for i in range(n): \\n            for j in range(i + 1, n): \\n                if (d[i] > d[j]): \\n                    inv += 1                                  #counting all inversions to sort it.\\n        return inv",
                "solutionTags": [],
                "code": "\\n\\t\\n\\tUsing count inversions we can easily solve this problem.\\n\\t.Just by selecting the first most satisfying position of\\n\\trequired value we can create the list by storing it.\\n\\tAnd then easily counting inversions in it.\\n\\t\\n\\tEveryone might have doubt that why sorting?\\n\\tHere is the answer:\\n\\tsuppose the position list to satisfy is:\\n\\t(4*4 matrix)\\n\\t1 0 0 1\\n\\t1 0 0 0\\n\\t1 1 1 0\\n\\t1 1 0 0 \\n\\tposition array is:--     [4,3,1]   (0 based indexing)\\n\\tunrequired row:--    0 so swap req to send it to end = (n-1-miss)=(3-0)=3\\n\\tnow position array should become:---    [2,1,0]\\n\\tand it will require same inversions as required to sort array([4,3,1] )\\n\\t\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n=len(grid);d=[-1]*(n-1)\\n        if(n==1 and grid[0][0]==1):return 0\\n        for i in range(n):\\n            cnt=0\\n            for j in grid[i][::-1]:\\n                if(j==0):cnt+=1\\n                else:break\\n            for j in range(n-2,-1,-1):\\n                if(d[j]==-1 and j+1<=cnt):       #storing all the first most satisfying position\\n                    d[j]=i\\n                    break     \\n        for i in d:\\n            if(i==-1):return -1     #some row remain unsatisfied\\n        miss=(n*(n-1))//2-sum(d)                            #finding the unrequired row\\n        d=d[::-1];\\n\\t\\tinv=n-1-miss                                              #sending the unrequired value to end.\\n        n=len(d)\\n        for i in range(n): \\n            for j in range(i + 1, n): \\n                if (d[i] > d[j]): \\n                    inv += 1                                  #counting all inversions to sort it.\\n        return inv",
                "codeTag": "Java"
            },
            {
                "id": 768422,
                "title": "java-python-detailed-explanation-of-how-to-construct-the-greedy-bubble",
                "content": "**First, let\\'s transfer the problem to a 1d array problem.**\\n\\nFor each row, we can count from the right for consecutive 0s. We record the place of the **first 0** of these consecutive ending zeros. For example, in the first test case\\n```[[0,0,1],[1,1,0],[1,0,0]]```\\nThat\\'s basically a \\n```[3, 2, 1]```\\nAll we need to do is actually sort it to be [1, 2, 3]\\n\\nNote that, we do not need to fully sort the array. Because the requirement is only to make it all zero above diagonal. So for some numbers they don\\'t need to be fully sorted, they only need to be at position\\n```arr[i] >= i+1 ```\\nFor example a matrix of all 0 can have a arr of [3,3,3], which satisfy the requirement.\\n\\n**Now, how to tackle the problem.**\\nYou could read from other answers that what we need to do is to perform a bubble. But how to construct the bubble requires thinking.\\n\\nTo further simplify the arr for understanding, I did another transformation: I changed the number arr[i] to \\n``` right[i] = arr[i] - (i+1)```\\nwhich means the number of steps it needs to go right.\\nSo our test case 1 becomes\\n```[2, 0, -2]```\\nwhich means the first number **must** to go right 2 steps, and the last number **can** go left for 2 steps.\\nIn the end, we need the right[i] array to be all smaller or equal to zero.\\n\\nSo, how to construct the bubble? I will share my step by step thinking here.\\n1) A straight forward thinking is, if we meet with a positive number (means it must go right), we then move it to right, let it bubble up. \\nHowever, this could be wrong, because in the bubbling process, it could be swapping with other positive numbers, and this causes extra swaps.\\n```Think of  [4, 3, 0, 0, -5, -5], when move 4 first and swap with 3``` \\n2) Now, a revised version of bubble could be, we start from right to the left, and move the rightmost positive number first.\\n\\tSadly it turned out this does not work either. You could solve the problem of positive numbers swapping, but cannot solve the problem of negative number swapping. \\n\\t```For example for case [...,5,-1,0,0,-8,...], you cannot decide -1 or -8, which to move first. If there are positive numbers to the left of 5, it might be correct to bubble -8 down, not bubble 5 up ```\\n\\t\\n**The final answer**: We need to take a step back: The right bubbling strategy comes from bubble for **POSITION**, rather than for number. \\nWhen we meet a positive number `right[i]`, it is certain that this position must be switched to another number. And we can find the candidate by going step by step to the right of this position one.\\nIf we can find a `right[j]`, s.t.\\n```|right[j]| > steps between i and j```\\nthen we can definitely bubble the `right[j]` to `right[i]`.\\nNow, since `right[j]` is the FIRST candidate we meet, this can guarantee that moving j to i is using the smallest number of swaps. And since we are securing the position i one by one. All the swaps we have are optimal. This could be an explanation to why the \\'greedy-like\\' bubble choice works.\\nLast, when we cannot find a `right[j]`, definately the position i cannot be filled by anyone properly, we can return -1.\\n\\n**And by this we can construct our bubble strategy**: \\nTo secure the position i from left to right. Each time find the smallest candidate j, which can bubble down to position i. And by our analysis above we know, this approach is optimal.\\n\\nA sample Java Code here:\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] arr = calc(grid);\\n        int[] right = new int[arr.length];//right[i] -> the steps this number needs to go right\\n        for (int i = 0; i < arr.length; i++) {\\n            right[i] = arr[i] - i-1;\\n        }\\n\\t\\t\\n\\t\\t//perform bubble\\n        int count = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (right[i] <= 0) {\\n                continue;\\n            }\\n            //find the next one can fit this position\\n\\t\\t\\t//the toMove is the \\'j\\' in the explanation above\\n            int toMove = i+1;\\n            while(toMove < arr.length) {\\n                if (-right[toMove] >= toMove - i) {\\n                    break;\\n                }\\n                toMove++;\\n            }\\n            if (toMove == arr.length) {\\n                return -1;\\n            }\\n            \\n            //bubble toMove to i\\n            int prev = right[toMove];\\n            for (int j = toMove-1; j >= i; j--) {\\n                right[j+1] = right[j] -1;\\n                count++;\\n            }\\n            right[i] = prev + (toMove - i);\\n        }\\n        return count;\\n        \\n    }\\n    \\n\\t//calculate the position of first 0 in the ending zero sequence\\n    private int[] calc(int[][] grid) {\\n        int[] arr = new int[grid.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            int count = 0;\\n            for (int j = grid[0].length-1; j>=0; j--) {\\n                if (grid[i][j] != 0) {\\n                    break;\\n                }\\n                count++;\\n            }\\n            arr[i] = grid.length - count;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n\\nPython Code:\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr = self.calc(grid)\\n        n = len(arr)\\n\\t\\t#right[i] -> the steps this number needs to go right\\n        right = [0 for x in range(n)]\\n        for i in range(n):\\n            right[i] = arr[i] - i - 1\\n        \\n\\t\\t#bubble\\n        count = 0\\n        for i in range(n):\\n            if (right[i] <= 0):\\n                continue\\n            \\n\\t\\t\\t#find the j (toMove)\\n            toMove = i+1\\n            while(toMove < n):\\n                if (-right[toMove] >= toMove - i):\\n                    break\\n                toMove += 1\\n                \\n            if (toMove == n):\\n                return -1\\n            \\n            prev = right[toMove]\\n            for j in range(toMove-1, i-1, -1):\\n                right[j+1] = right[j] - 1\\n                count += 1\\n            right[i] = prev + (toMove - i)\\n            \\n        return count\\n        \\n\\t#calculate the position of first 0 in the ending zero sequence\\n    def calc(self, grid):\\n        arr = [0 for x in range(len(grid))]\\n        for i in range(len(arr)):\\n            count = 0\\n            j = len(grid[0])-1\\n            while(j >= 0):\\n                if (grid[i][j] != 0):\\n                    break\\n                j -= 1\\n                count += 1\\n            arr[i] = len(grid[0]) - count\\n        return arr\\n   \\n```",
                "solutionTags": [],
                "code": "```[[0,0,1],[1,1,0],[1,0,0]]```\n```[3, 2, 1]```\n```arr[i] >= i+1 ```\n``` right[i] = arr[i] - (i+1)```\n```[2, 0, -2]```\n```Think of  [4, 3, 0, 0, -5, -5], when move 4 first and swap with 3```\n```For example for case [...,5,-1,0,0,-8,...], you cannot decide -1 or -8, which to move first. If there are positive numbers to the left of 5, it might be correct to bubble -8 down, not bubble 5 up ```\n```|right[j]| > steps between i and j```\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] arr = calc(grid);\\n        int[] right = new int[arr.length];//right[i] -> the steps this number needs to go right\\n        for (int i = 0; i < arr.length; i++) {\\n            right[i] = arr[i] - i-1;\\n        }\\n\\t\\t\\n\\t\\t//perform bubble\\n        int count = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (right[i] <= 0) {\\n                continue;\\n            }\\n            //find the next one can fit this position\\n\\t\\t\\t//the toMove is the \\'j\\' in the explanation above\\n            int toMove = i+1;\\n            while(toMove < arr.length) {\\n                if (-right[toMove] >= toMove - i) {\\n                    break;\\n                }\\n                toMove++;\\n            }\\n            if (toMove == arr.length) {\\n                return -1;\\n            }\\n            \\n            //bubble toMove to i\\n            int prev = right[toMove];\\n            for (int j = toMove-1; j >= i; j--) {\\n                right[j+1] = right[j] -1;\\n                count++;\\n            }\\n            right[i] = prev + (toMove - i);\\n        }\\n        return count;\\n        \\n    }\\n    \\n\\t//calculate the position of first 0 in the ending zero sequence\\n    private int[] calc(int[][] grid) {\\n        int[] arr = new int[grid.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            int count = 0;\\n            for (int j = grid[0].length-1; j>=0; j--) {\\n                if (grid[i][j] != 0) {\\n                    break;\\n                }\\n                count++;\\n            }\\n            arr[i] = grid.length - count;\\n        }\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr = self.calc(grid)\\n        n = len(arr)\\n\\t\\t#right[i] -> the steps this number needs to go right\\n        right = [0 for x in range(n)]\\n        for i in range(n):\\n            right[i] = arr[i] - i - 1\\n        \\n\\t\\t#bubble\\n        count = 0\\n        for i in range(n):\\n            if (right[i] <= 0):\\n                continue\\n            \\n\\t\\t\\t#find the j (toMove)\\n            toMove = i+1\\n            while(toMove < n):\\n                if (-right[toMove] >= toMove - i):\\n                    break\\n                toMove += 1\\n                \\n            if (toMove == n):\\n                return -1\\n            \\n            prev = right[toMove]\\n            for j in range(toMove-1, i-1, -1):\\n                right[j+1] = right[j] - 1\\n                count += 1\\n            right[i] = prev + (toMove - i)\\n            \\n        return count\\n        \\n\\t#calculate the position of first 0 in the ending zero sequence\\n    def calc(self, grid):\\n        arr = [0 for x in range(len(grid))]\\n        for i in range(len(arr)):\\n            count = 0\\n            j = len(grid[0])-1\\n            while(j >= 0):\\n                if (grid[i][j] != 0):\\n                    break\\n                j -= 1\\n                count += 1\\n            arr[i] = len(grid[0]) - count\\n        return arr\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 768352,
                "title": "converting-matrix-to-array-to-keep-count-last-0-s-in-each-row-greedy",
                "content": "E.g. Grid:\\n011\\n110\\n100\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n\\t\\t\\n\\t\\t//Keeps count of consecutive zeros from end\\n\\t\\t// For given eg. [0,1,2]\\n        int[] zeroCount = new int[n];\\n        int largest = 0;\\n        for(int i=0; i<n;i++){\\n            int count =0;\\n            for(int j=n-1; j>=0;j--){\\n                if(grid[i][j] ==0) count++;\\n                if(grid[i][j] == 1) break;\\n            }\\n            zeroCount[i] = count;\\n            largest = Math.max(largest, count);\\n        }\\n\\t\\t//If there is no row with sufficient 0s to replace first row, return -1\\n        if(largest < n-1) return -1;\\n\\t\\t\\n\\t\\t//To keep track of used values from zeroCount[] arr\\n        int[] isUsed = new int[n];\\n\\t\\t\\n\\t\\t//New order of rows\\n        int[] arr = new int[n];\\n        int ans = 0;\\n        \\n\\t\\t//We are basically trying to sort zeroCount array in descending order\\n\\t\\t//This is more like selection sort\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t   //Minumum number of trailing 0s required\\n            int reqmt = n - i -1;\\n\\t\\t\\t//This keeps track of how many consecutive rows we need to swap to reach i\\n            int countRows = 0;\\n\\t\\t\\t\\n            for(int j=0; j<n;j++)\\n            {   \\n\\t\\t\\t\\t//FInd the first non-used row to fulfill this condition. - Greedy\\n                if(isUsed[j] == 1) continue;\\n                if(zeroCount[j] >= reqmt)\\n                {\\n                      ans+=countRows; \\n\\t\\t\\t\\t\\t\\tisUsed[j] = 1;\\n                    reqmt = -1;\\n                    arr[i] = zeroCount[j];\\n                    break;\\n                }    \\n                else countRows++;\\n            }\\n\\t\\t\\t//If we don\\'t find any row satisfying reqmt\\n            if(reqmt > -1) return -1;\\n\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n\\t\\t\\n\\t\\t//Keeps count of consecutive zeros from end\\n\\t\\t// For given eg. [0,1,2]\\n        int[] zeroCount = new int[n];\\n        int largest = 0;\\n        for(int i=0; i<n;i++){\\n            int count =0;\\n            for(int j=n-1; j>=0;j--){\\n                if(grid[i][j] ==0) count++;\\n                if(grid[i][j] == 1) break;\\n            }\\n            zeroCount[i] = count;\\n            largest = Math.max(largest, count);\\n        }\\n\\t\\t//If there is no row with sufficient 0s to replace first row, return -1\\n        if(largest < n-1) return -1;\\n\\t\\t\\n\\t\\t//To keep track of used values from zeroCount[] arr\\n        int[] isUsed = new int[n];\\n\\t\\t\\n\\t\\t//New order of rows\\n        int[] arr = new int[n];\\n        int ans = 0;\\n        \\n\\t\\t//We are basically trying to sort zeroCount array in descending order\\n\\t\\t//This is more like selection sort\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t   //Minumum number of trailing 0s required\\n            int reqmt = n - i -1;\\n\\t\\t\\t//This keeps track of how many consecutive rows we need to swap to reach i\\n            int countRows = 0;\\n\\t\\t\\t\\n            for(int j=0; j<n;j++)\\n            {   \\n\\t\\t\\t\\t//FInd the first non-used row to fulfill this condition. - Greedy\\n                if(isUsed[j] == 1) continue;\\n                if(zeroCount[j] >= reqmt)\\n                {\\n                      ans+=countRows; \\n\\t\\t\\t\\t\\t\\tisUsed[j] = 1;\\n                    reqmt = -1;\\n                    arr[i] = zeroCount[j];\\n                    break;\\n                }    \\n                else countRows++;\\n            }\\n\\t\\t\\t//If we don\\'t find any row satisfying reqmt\\n            if(reqmt > -1) return -1;\\n\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768271,
                "title": "c-o-1-memory-solution-faster-than-100-less-memory-than-100",
                "content": "Just use the first column instead of allocating a vector:\\n\\n```\\n    static int minSwaps(vector<vector<int>>& grid) noexcept {\\n        const int n = static_cast<int>(grid.size());\\n\\n        for (int i = 0; i < n; ++i) {\\n            grid[i][0] = 0; //Use first column as the rowSize vector.\\n            for (int j = n - 1; j >= 1; --j) {\\n                if (grid[i][j] == 1) break;\\n                ++grid[i][0];\\n            }\\n        }\\n        \\n        int steps = 0;\\n        for (int i = 0; i < n - 1; ++i) {\\n            const int expectedSize = n - 1 - i;\\n            for (int j = i; j < n; ++j) {\\n                if (grid[j][0] >= expectedSize) {\\n                    while (j > i) swap(grid[j--][0], grid[j][0]);\\n                    break;\\n                }\\n                ++steps;\\n            }\\n            \\n            if (grid[i][0] < expectedSize) return -1;\\n        }\\n        return steps;\\n    }",
                "solutionTags": [],
                "code": "Just use the first column instead of allocating a vector:\\n\\n```\\n    static int minSwaps(vector<vector<int>>& grid) noexcept {\\n        const int n = static_cast<int>(grid.size());\\n\\n        for (int i = 0; i < n; ++i) {\\n            grid[i][0] = 0; //Use first column as the rowSize vector.\\n            for (int j = n - 1; j >= 1; --j) {\\n                if (grid[i][j] == 1) break;\\n                ++grid[i][0];\\n            }\\n        }\\n        \\n        int steps = 0;\\n        for (int i = 0; i < n - 1; ++i) {\\n            const int expectedSize = n - 1 - i;\\n            for (int j = i; j < n; ++j) {\\n                if (grid[j][0] >= expectedSize) {\\n                    while (j > i) swap(grid[j--][0], grid[j][0]);\\n                    break;\\n                }\\n                ++steps;\\n            }\\n            \\n            if (grid[i][0] < expectedSize) return -1;\\n        }\\n        return steps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 768204,
                "title": "c-easy-greedy-idea-o-n-2",
                "content": "Let\\'s say we have 4 X 4 matrix,\\nO O X X\\nO O O O\\nO X X X\\nX O O X\\nwe can make an array to present the consecutive `X` count from back to front:  src = `[2, 0, 3, 1]`\\n\\nThen we want the new matrix to be:\\nO X X X\\nO O X X\\nX O O X\\nO O O O\\nwe can convert this to a target array: target `[3, 2, 1]`. And we can come up with a greedy solution, we can iterate the target array( i-th), and try to find the the most close element in src(`j-th`) which is equal or large than the target element, then we insert this element to the  i-th index of src and remove the original one. then we can calculate the steps: `ans += j - i`.\\n\\nfor this example, target is [3,2,1], first element is 3,  we try to find the most closed elemetn in src which is equal or larger than 3, it will be `[2, 0, 3, 1]` ==> `[3, 2, 0 ,1]` and the move step should be `2 - 0 = 0`, we keep doing this steps, unitl we finish all the target element. if we can\\'t find an element which should be equal or larger than the target element, then we return `-1`.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> src;\\n        for(int j = 0; j < grid.size(); ++j) {\\n            auto &v = grid[j];\\n            int cnt = 0;\\n            for(int i = v.size() - 1; i > 0; --i) {\\n                if(v[i] == 0) ++cnt;\\n                else break;\\n            }\\n            src.push_back(cnt);\\n        }\\n        vector<int> t;\\n        int ans = 0;\\n        for(int i = grid.size() - 1; i > 0; --i) t.push_back(i);\\n        for(int i = 0; i < t.size(); ++i) {\\n            int a = t[i];\\n            bool f = false;\\n            for(int j = i; j < src.size(); ++j) {\\n                if(src[j] >= a) {\\n                    src.erase(src.begin() + j);\\n                    src.insert(src.begin() + i, a);\\n                    ans += j - i;\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if(!f) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> src;\\n        for(int j = 0; j < grid.size(); ++j) {\\n            auto &v = grid[j];\\n            int cnt = 0;\\n            for(int i = v.size() - 1; i > 0; --i) {\\n                if(v[i] == 0) ++cnt;\\n                else break;\\n            }\\n            src.push_back(cnt);\\n        }\\n        vector<int> t;\\n        int ans = 0;\\n        for(int i = grid.size() - 1; i > 0; --i) t.push_back(i);\\n        for(int i = 0; i < t.size(); ++i) {\\n            int a = t[i];\\n            bool f = false;\\n            for(int j = i; j < src.size(); ++j) {\\n                if(src[j] >= a) {\\n                    src.erase(src.begin() + j);\\n                    src.insert(src.begin() + i, a);\\n                    ans += j - i;\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if(!f) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768151,
                "title": "python3-mimic-bubble-sort",
                "content": "1. Find the number of zeros per row.\\n2. From the first row, find the first row with enough zeros, and swap all the way\\n\\n```Python3\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        zero_count = [0] * n  # the number of zeros per row\\n        for i, row in enumerate(grid):\\n            j = n - 1\\n            while j >= 0 and row[j] == 0:\\n                j -= 1\\n            zero_count[i] = n - 1 - j\\n\\n        res = 0\\n        for i in range(n - 1):\\n            # find the row that has n - i - 1 zero\\n            j = 0\\n            zeros = n - i - 1\\n            while j < len(zero_count) and zero_count[j] < zeros:  # find the first row with enough zeros\\n                j += 1\\n            if j == len(zero_count):\\n                return -1\\n            zero_count.pop(j)\\n            res += j\\n        return res\\n```",
                "solutionTags": [],
                "code": "```Python3\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        zero_count = [0] * n  # the number of zeros per row\\n        for i, row in enumerate(grid):\\n            j = n - 1\\n            while j >= 0 and row[j] == 0:\\n                j -= 1\\n            zero_count[i] = n - 1 - j\\n\\n        res = 0\\n        for i in range(n - 1):\\n            # find the row that has n - i - 1 zero\\n            j = 0\\n            zeros = n - i - 1\\n            while j < len(zero_count) and zero_count[j] < zeros:  # find the first row with enough zeros\\n                j += 1\\n            if j == len(zero_count):\\n                return -1\\n            zero_count.pop(j)\\n            res += j\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768130,
                "title": "java-2ms-greedy-with-comment-both-100",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] cnt = new int[n];     // Counter for trailing 0s\\n        for(int i = 0; i < n; i++)\\n            for(int j = n - 1; j >= 0 && grid[i][j] == 0; j--)\\n                cnt[i] += 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            // If current row doesn\\'t have enough 0\\n            if(cnt[i] < n - 1 - i){\\n                // Try to find a row below which has enough 0s with minimum times of swap\\n                for(int j = i + 1; j < n; j++){\\n                    // If find one row with enough 0s\\n                    if(cnt[j] >= n - 1 - i){\\n                        ans += j - i;\\n                        int tmp = cnt[i];\\n                        // swap it to cnt[i]\\n                        cnt[i] = cnt[j];\\n                        // push cnt[i, j - 1] one position forward\\n                        for(int k = j; k > i + 1; k--)\\n                            cnt[k] = cnt[k - 1];\\n                        cnt[i + 1] = tmp;\\n                        break;\\n                    }\\n                    // Can\\'t find a row with enough 0s, return -1\\n                    if(j >= n - 1)\\n                        return -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] cnt = new int[n];     // Counter for trailing 0s\\n        for(int i = 0; i < n; i++)\\n            for(int j = n - 1; j >= 0 && grid[i][j] == 0; j--)\\n                cnt[i] += 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            // If current row doesn\\'t have enough 0\\n            if(cnt[i] < n - 1 - i){\\n                // Try to find a row below which has enough 0s with minimum times of swap\\n                for(int j = i + 1; j < n; j++){\\n                    // If find one row with enough 0s\\n                    if(cnt[j] >= n - 1 - i){\\n                        ans += j - i;\\n                        int tmp = cnt[i];\\n                        // swap it to cnt[i]\\n                        cnt[i] = cnt[j];\\n                        // push cnt[i, j - 1] one position forward\\n                        for(int k = j; k > i + 1; k--)\\n                            cnt[k] = cnt[k - 1];\\n                        cnt[i + 1] = tmp;\\n                        break;\\n                    }\\n                    // Can\\'t find a row with enough 0s, return -1\\n                    if(j >= n - 1)\\n                        return -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768089,
                "title": "python-using-linked-list-time-100-space-100",
                "content": "- Count the number of straight-up zeros from the right side of each row (`zero_count`), then store each row\\'s `zero_count` to a linked list node.\\n- Call `looking`, a variable that represents the number of `zero_count` needed for the current row (starting from **row length - 1** to **1**). \\n- For each `looking`, we will have to loop through the linked list to find the row with the `zero_count` greater than that.  For each node we traverse, increament `curr_move` which will be the number of moves we need to add to the total `move` if we find *the row*. In case we cannot find it (when reaching the of the linked list), return -1\\n \\nTime: 100%\\nSpace: 100%\\n\\n```python\\nclass LLNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        \\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n,m = len(grid), len(grid[0])\\n        head, curr = None, None\\n        \\n        # Count the number of straight-up zeros from the right side of each row (zero_count)\\n        # Store each row\\'s zero_count to a linked list node \\n        for i in range(n):\\n            zero_count = 0\\n            for j in range(m-1,-1,-1):\\n                if grid[i][j] != 0: break\\n                zero_count += 1    \\n            if not head:\\n                head = LLNode(zero_count)    \\n                curr = head\\n            else:    \\n                curr.next = LLNode(zero_count)\\n                curr = curr.next\\n        \\n        # \"looking\" is the number of zero we are looking for the current row\\n        # Starting at length of row - 1 to 1\\n        move = 0\\n        for looking in range(m-1,0,-1): \\n            # Go through the linked list to find a row with zero count greater than the looking\\n            curr_move = 0\\n            curr = head\\n            prev = None\\n            while curr and curr.val < looking:\\n                prev = curr\\n                curr = curr.next\\n                curr_move += 1\\n                \\n            # - If cannot find any node with the value greater than looking, then return -1 \\n            if not curr: return -1    \\n            \\n            # - If we find it:\\n            # -- Add the number of moves\\n            move += curr_move \\n            # -- Remove it out of the linked list\\n            if prev:\\n                prev.next = curr.next\\n            else:    \\n                head = head.next\\n            \\n        return move    \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass LLNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n        \\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n,m = len(grid), len(grid[0])\\n        head, curr = None, None\\n        \\n        # Count the number of straight-up zeros from the right side of each row (zero_count)\\n        # Store each row\\'s zero_count to a linked list node \\n        for i in range(n):\\n            zero_count = 0\\n            for j in range(m-1,-1,-1):\\n                if grid[i][j] != 0: break\\n                zero_count += 1    \\n            if not head:\\n                head = LLNode(zero_count)    \\n                curr = head\\n            else:    \\n                curr.next = LLNode(zero_count)\\n                curr = curr.next\\n        \\n        # \"looking\" is the number of zero we are looking for the current row\\n        # Starting at length of row - 1 to 1\\n        move = 0\\n        for looking in range(m-1,0,-1): \\n            # Go through the linked list to find a row with zero count greater than the looking\\n            curr_move = 0\\n            curr = head\\n            prev = None\\n            while curr and curr.val < looking:\\n                prev = curr\\n                curr = curr.next\\n                curr_move += 1\\n                \\n            # - If cannot find any node with the value greater than looking, then return -1 \\n            if not curr: return -1    \\n            \\n            # - If we find it:\\n            # -- Add the number of moves\\n            move += curr_move \\n            # -- Remove it out of the linked list\\n            if prev:\\n                prev.next = curr.next\\n            else:    \\n                head = head.next\\n            \\n        return move    \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 768055,
                "title": "c-greedy",
                "content": "```\\n// 0 1 2\\n// 2 1 0\\n// 1 0 2\\n// \\nclass Solution {\\npublic:\\nint minSwaps(vector<vector<int>>& grid)\\n{\\n\\tvector<int> cnt(grid.size());\\n\\tfor (int i = 0; i < grid.size(); i++)\\n\\t{\\n\\t\\tfor (int j = grid.size() - 1; j >= 0; j--)\\n\\t\\t{\\n\\t\\t\\tif (grid[i][j] == 0)\\n\\t\\t\\t\\tcnt[i]++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\tint i = 0;\\n\\twhile(i < cnt.size())\\n\\t{\\n\\t\\tif (cnt[i] < grid.size() - 1 - i)\\n\\t\\t{\\n\\t\\t\\tint j = i;\\n\\t\\t\\twhile (j < grid.size() && cnt[j] < grid.size() - 1 - i) ++j;\\n\\t\\t\\tres += j - i;\\n            \\n            if(j == grid.size())\\n                return -1;\\n            \\n\\t\\t\\twhile (j > i)\\n            {\\n                swap(cnt[j], cnt[j - 1]);\\n                --j;\\n            }\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\t++i;\\n\\t}\\n\\n\\treturn res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// 0 1 2\\n// 2 1 0\\n// 1 0 2\\n// \\nclass Solution {\\npublic:\\nint minSwaps(vector<vector<int>>& grid)\\n{\\n\\tvector<int> cnt(grid.size());\\n\\tfor (int i = 0; i < grid.size(); i++)\\n\\t{\\n\\t\\tfor (int j = grid.size() - 1; j >= 0; j--)\\n\\t\\t{\\n\\t\\t\\tif (grid[i][j] == 0)\\n\\t\\t\\t\\tcnt[i]++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\tint i = 0;\\n\\twhile(i < cnt.size())\\n\\t{\\n\\t\\tif (cnt[i] < grid.size() - 1 - i)\\n\\t\\t{\\n\\t\\t\\tint j = i;\\n\\t\\t\\twhile (j < grid.size() && cnt[j] < grid.size() - 1 - i) ++j;\\n\\t\\t\\tres += j - i;\\n            \\n            if(j == grid.size())\\n                return -1;\\n            \\n\\t\\t\\twhile (j > i)\\n            {\\n                swap(cnt[j], cnt[j - 1]);\\n                --j;\\n            }\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\t++i;\\n\\t}\\n\\n\\treturn res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768049,
                "title": "clean-python",
                "content": "```\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        swaps = 0\\n        zeroesNeeded = len(grid)-1 \\n        start = 1\\n        \\n        for i in range(len(grid)):\\n            temp = i\\n            while temp < len(grid) and grid[temp][start:] != [0]*zeroesNeeded:\\n                temp += 1\\n                \\n            if temp >= len(grid):\\n                return -1\\n            \\n            start += 1\\n            zeroesNeeded -= 1\\n            \\n            while temp > i:\\n                grid[temp], grid[temp-1] = grid[temp-1], grid[temp]\\n                temp -= 1\\n                swaps += 1\\n                \\n        return swaps\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        swaps = 0\\n        zeroesNeeded = len(grid)-1 \\n        start = 1\\n        \\n        for i in range(len(grid)):\\n            temp = i\\n            while temp < len(grid) and grid[temp][start:] != [0]*zeroesNeeded:\\n                temp += 1\\n                \\n            if temp >= len(grid):\\n                return -1\\n            \\n            start += 1\\n            zeroesNeeded -= 1\\n            \\n            while temp > i:\\n                grid[temp], grid[temp-1] = grid[temp-1], grid[temp]\\n                temp -= 1\\n                swaps += 1\\n                \\n        return swaps\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 768013,
                "title": "c-simple-and-greedy-solution",
                "content": "```\\n\\tvoid countSwaps(vector<int>& v, int p, int q)\\n    {\\n        if(p==q)\\n            return;\\n        for(int i=q-1; i>=p; i--)\\n            swap(v[i], v[i+1]);\\n        return;\\n    }\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        vector<int> v;\\n        for(int i=0; i<n; i++)\\n        {\\n            int count = 0;\\n            for(int j=grid[i].size()-1; j>=0; j--)\\n            {\\n                if(grid[i][j]==0)\\n                    count++;\\n                else\\n                    break;\\n            }\\n            v.push_back(count);\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            bool flag = false;\\n            for(int j=i; j<n; j++)\\n            {\\n                if(v[j] >= n-1-i)\\n                {\\n                    flag = true;\\n                    countSwaps(v, i, j);\\n                    ans += (j-i);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                return -1;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvoid countSwaps(vector<int>& v, int p, int q)\\n    {\\n        if(p==q)\\n            return;\\n        for(int i=q-1; i>=p; i--)\\n            swap(v[i], v[i+1]);\\n        return;\\n    }\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        vector<int> v;\\n        for(int i=0; i<n; i++)\\n        {\\n            int count = 0;\\n            for(int j=grid[i].size()-1; j>=0; j--)\\n            {\\n                if(grid[i][j]==0)\\n                    count++;\\n                else\\n                    break;\\n            }\\n            v.push_back(count);\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            bool flag = false;\\n            for(int j=i; j<n; j++)\\n            {\\n                if(v[j] >= n-1-i)\\n                {\\n                    flag = true;\\n                    countSwaps(v, i, j);\\n                    ans += (j-i);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                return -1;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 768008,
                "title": "java-simple-clean-code-with-explanation",
                "content": "Key Point:\\nEverytime, which row do we want most?\\n\\nAfter drawing several pictures, we can find that, in the final valid state, the first row, can only have one 1 in the first column position, the second row, can only have two 1 in the first two columns.....\\n\\nIn a word, for row i, its last 1 must be in column i or before. Thus, we can first record every row\\'s last 1\\'s position, then choose valid row from top to bottom (last second row).\\n\\n**lastOne:** store every row\\'s last 1\\'s position. Here we use a list for convenience.\\n\\nAnd, then choose the valid row by using minimum steps.\\n\\n\\n**If you find this helpful, please upvote, thanks!**\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        List<Integer> lastOne = new ArrayList<>(row + 1);\\n        for (int i = 0; i < row; i++) {\\n            lastOne.add(i, -1);\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    lastOne.set(i, j);\\n                    break;\\n                }\\n            }\\n        }\\n        int step = 0;\\n        for (int i = 0; i < row - 1; i++) {\\n            if (lastOne.get(i) <= i) {\\n                continue;\\n            }\\n            boolean flag = false;\\n            for (int j = i + 1; j < row; j++) {\\n                if (lastOne.get(j) <= i) {\\n                    flag = true;\\n                    step += j - i;\\n                    int curFind = lastOne.get(j);\\n                    lastOne.remove(j);\\n                    lastOne.add(i, curFind);\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// if there is no valid row left, return -1 directly\\n            if (!flag) {\\n                return -1;\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        List<Integer> lastOne = new ArrayList<>(row + 1);\\n        for (int i = 0; i < row; i++) {\\n            lastOne.add(i, -1);\\n            for (int j = col - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    lastOne.set(i, j);\\n                    break;\\n                }\\n            }\\n        }\\n        int step = 0;\\n        for (int i = 0; i < row - 1; i++) {\\n            if (lastOne.get(i) <= i) {\\n                continue;\\n            }\\n            boolean flag = false;\\n            for (int j = i + 1; j < row; j++) {\\n                if (lastOne.get(j) <= i) {\\n                    flag = true;\\n                    step += j - i;\\n                    int curFind = lastOne.get(j);\\n                    lastOne.remove(j);\\n                    lastOne.add(i, curFind);\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// if there is no valid row left, return -1 directly\\n            if (!flag) {\\n                return -1;\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767981,
                "title": "python-best-soln-with-code",
                "content": "BRUTEFORCE\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        ans=0\\n        n=len(grid)\\n        for i in range(n-1):\\n            flag=0\\n            for j in range(i,n):\\n                f=1\\n                for k in range(i+1,n):\\n                    if grid[j][k]==1:\\n                        f=0\\n                        break\\n                if f==1:\\n                    flag=1\\n                    for k in range(j,i,-1):\\n                        grid[k],grid[k-1]=grid[k-1],grid[k]\\n                    break\\n            \\n            ans+=j-i\\n            if flag==0:\\n                return -1\\n            \\n        return ans\\n                \\n            \\n        \\n                \\n            ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        ans=0\\n        n=len(grid)\\n        for i in range(n-1):\\n            flag=0\\n            for j in range(i,n):\\n                f=1\\n                for k in range(i+1,n):\\n                    if grid[j][k]==1:\\n                        f=0\\n                        break\\n                if f==1:\\n                    flag=1\\n                    for k in range(j,i,-1):\\n                        grid[k],grid[k-1]=grid[k-1],grid[k]\\n                    break\\n            \\n            ans+=j-i\\n            if flag==0:\\n                return -1\\n            \\n        return ans\\n                \\n            \\n        \\n                \\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 767943,
                "title": "java-reduce-to-1d-greedy-o-n-2",
                "content": "```\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] zeros = new int[n];\\n        for(int i=0; i<n; i++){\\n            for(int j=n-1; j>=0; j--){\\n                if(grid[i][j]!=0){\\n                    break;\\n                }\\n                zeros[i]++;\\n            }\\n        }\\n        boolean[] checked = new boolean[n];\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            int req = n-i-1;\\n            int count = 0;\\n            boolean isFeasible = false;\\n            for(int j=0; j<n; j++){\\n                if(checked[j]){\\n                    continue;\\n                }\\n                \\n                if(zeros[j]<req){\\n                    count++;\\n                }\\n                else{\\n                    isFeasible = true;\\n                    checked[j] = true;\\n                    break;\\n                }\\n            }\\n            if(!isFeasible){\\n                return -1;\\n            }\\n            res += count;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] zeros = new int[n];\\n        for(int i=0; i<n; i++){\\n            for(int j=n-1; j>=0; j--){\\n                if(grid[i][j]!=0){\\n                    break;\\n                }\\n                zeros[i]++;\\n            }\\n        }\\n        boolean[] checked = new boolean[n];\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            int req = n-i-1;\\n            int count = 0;\\n            boolean isFeasible = false;\\n            for(int j=0; j<n; j++){\\n                if(checked[j]){\\n                    continue;\\n                }\\n                \\n                if(zeros[j]<req){\\n                    count++;\\n                }\\n                else{\\n                    isFeasible = true;\\n                    checked[j] = true;\\n                    break;\\n                }\\n            }\\n            if(!isFeasible){\\n                return -1;\\n            }\\n            res += count;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990227,
                "title": "java-count-swaps-clean",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                }\\n                arr[i]++;\\n            }\\n        }\\n\\n        int swaps = 0;\\n        int i = 0;\\n        for (int search = n-1; search >= 0; search--) {\\n            int j = i;\\n            while (arr[j] < search) {\\n                j++;\\n                if (j == n) {\\n                    return -1;\\n                }\\n            }\\n            while (j > i) {\\n                int tmp = arr[j];\\n                arr[j] = arr[j-1];\\n                arr[j-1] = tmp;\\n                swaps++;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                }\\n                arr[i]++;\\n            }\\n        }\\n\\n        int swaps = 0;\\n        int i = 0;\\n        for (int search = n-1; search >= 0; search--) {\\n            int j = i;\\n            while (arr[j] < search) {\\n                j++;\\n                if (j == n) {\\n                    return -1;\\n                }\\n            }\\n            while (j > i) {\\n                int tmp = arr[j];\\n                arr[j] = arr[j-1];\\n                arr[j-1] = tmp;\\n                swaps++;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953404,
                "title": "best-short-solution-to-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n       \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> maxRight(n,-1);\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    maxRight[i]=j;\\n                    \\n                }\\n            }\\n           \\n        }\\n        vector<int> s=maxRight;\\n        sort(s.begin(),s.end());\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<s[i])return -1;\\n            \\n        }\\n        \\n\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(maxRight[i]<=i){i++;continue;}\\n           \\n            int j;\\n            for(j=i+1;j<n;j++)\\n            {\\n                if(maxRight[j]<=i)\\n                {\\n                    break;\\n                }\\n            }\\n           \\n            while(j>i)\\n            {\\n                swap(maxRight[j-1],maxRight[j]);\\n                j--;\\n               count++;\\n           }\\n        \\n         i++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n       \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> maxRight(n,-1);\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    maxRight[i]=j;\\n                    \\n                }\\n            }\\n           \\n        }\\n        vector<int> s=maxRight;\\n        sort(s.begin(),s.end());\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<s[i])return -1;\\n            \\n        }\\n        \\n\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(maxRight[i]<=i){i++;continue;}\\n           \\n            int j;\\n            for(j=i+1;j<n;j++)\\n            {\\n                if(maxRight[j]<=i)\\n                {\\n                    break;\\n                }\\n            }\\n           \\n            while(j>i)\\n            {\\n                swap(maxRight[j-1],maxRight[j]);\\n                j--;\\n               count++;\\n           }\\n        \\n         i++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902946,
                "title": "easy-to-understand-javascript-solution-bubble-sort",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar minSwaps = function(grid) {\\n    const zeros = [];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let result = 0;\\n\\n    for (let row = 0; row < m; row++) {\\n        let count = 0;\\n        for (let col = n - 1; col >= 0; col--) {\\n            const value = grid[row][col];\\n\\n            if (value) break;\\n            count += 1;\\n        }\\n        zeros.push(count);\\n    }\\n    for (let row = 0; row < m; row++) {\\n        const target = m - row - 1;\\n        let swapRow = row;\\n\\n        while (swapRow < m && zeros[swapRow] < target) swapRow += 1;\\n        if (swapRow === m) return -1;\\n\\n        for (let index = swapRow; index > row; index--) {\\n            [zeros[index], zeros[index - 1]] = [zeros[index - 1], zeros[index]];\\n            result += 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSwaps = function(grid) {\\n    const zeros = [];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let result = 0;\\n\\n    for (let row = 0; row < m; row++) {\\n        let count = 0;\\n        for (let col = n - 1; col >= 0; col--) {\\n            const value = grid[row][col];\\n\\n            if (value) break;\\n            count += 1;\\n        }\\n        zeros.push(count);\\n    }\\n    for (let row = 0; row < m; row++) {\\n        const target = m - row - 1;\\n        let swapRow = row;\\n\\n        while (swapRow < m && zeros[swapRow] < target) swapRow += 1;\\n        if (swapRow === m) return -1;\\n\\n        for (let index = swapRow; index > row; index--) {\\n            [zeros[index], zeros[index - 1]] = [zeros[index - 1], zeros[index]];\\n            result += 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593626,
                "title": "javascript-1536-minimum-swaps-to-arrange-a-binary-grid",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nconst minSwaps = function (g) {\\n  const m = g.length\\n  const n = g[0].length\\n\\n  function swapRows(r1,r2) {\\n    for (let C = 0; C < n; C++)\\n      [g[r1][C],g[r2][C]] = [g[r2][C],g[r1][C]]\\n  }\\n\\n  function rowWithEnoughZerosAfterMainDiagonal(R2) {\\n    const zNeeded = n - (R2 + 1)\\n    for (let R = R2; R < m; R++) {\\n      const zc = g[R].slice(R2 + 1)\\n        .join(\\'\\')\\n        .replaceAll(\\'1\\',\\'\\')\\n      if (zc.length >= zNeeded)\\n        return R\\n    }\\n    return -1\\n  }\\n\\n  let cc = 0\\n  for (let R = 0; R < m; R++) {\\n    const rNeededToSwapTo = rowWithEnoughZerosAfterMainDiagonal(R)\\n    if (rNeededToSwapTo === -1)\\n      return -1\\n    if (R !== rNeededToSwapTo)\\n      for (let R2 = rNeededToSwapTo; R2 > R; R2--) {\\n        swapRows(R2,R2 - 1)\\n        cc += 1\\n      }\\n  }\\n  return cc\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst minSwaps = function (g) {\\n  const m = g.length\\n  const n = g[0].length\\n\\n  function swapRows(r1,r2) {\\n    for (let C = 0; C < n; C++)\\n      [g[r1][C],g[r2][C]] = [g[r2][C],g[r1][C]]\\n  }\\n\\n  function rowWithEnoughZerosAfterMainDiagonal(R2) {\\n    const zNeeded = n - (R2 + 1)\\n    for (let R = R2; R < m; R++) {\\n      const zc = g[R].slice(R2 + 1)\\n        .join(\\'\\')\\n        .replaceAll(\\'1\\',\\'\\')\\n      if (zc.length >= zNeeded)\\n        return R\\n    }\\n    return -1\\n  }\\n\\n  let cc = 0\\n  for (let R = 0; R < m; R++) {\\n    const rNeededToSwapTo = rowWithEnoughZerosAfterMainDiagonal(R)\\n    if (rNeededToSwapTo === -1)\\n      return -1\\n    if (R !== rNeededToSwapTo)\\n      for (let R2 = rNeededToSwapTo; R2 > R; R2--) {\\n        swapRows(R2,R2 - 1)\\n        cc += 1\\n      }\\n  }\\n  return cc\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584818,
                "title": "easy-to-understand-python-solution-with-comments",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n^2)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n\\n        # Time  : O(n^2)\\n        # Space : O(n)\\n\\n        n = len(grid)\\n        zeroesArr = []\\n\\n        # Calculate trailing zeroes for each row \\n        for i in range(n):\\n            trailingZeroes = 0\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    break\\n                trailingZeroes += 1\\n            zeroesArr.append(trailingZeroes)\\n\\n        # Min number of trailing zeroes expected in 1st row\\n        minZeroesExpected = n - 1\\n        res = 0\\n\\n        for i in range(n):\\n            currMax = -1\\n            currMaxIndex = -1\\n\\n            # Find closest row with trailing zeroes >= minZeroesExpected\\n            for j in range(i, n):\\n                if zeroesArr[j] >= minZeroesExpected:\\n                    currMax = zeroesArr[j]\\n                    currMaxIndex = j\\n                    break\\n\\n            # We couldn\\'t find any row with minZeroesExpected\\n            if currMax < minZeroesExpected:\\n                return - 1\\n            \\n            # Simulate stable swapping of rows \\n            # Stability in sorting means preserving the relative order between keys with same values\\n            # we need to maintain relative order of rows since we can only swap two adjacent rows.\\n            # Bubble Sort is preferred as it\\'s a stable sorting algorithm\\n            while currMaxIndex > i:\\n                temp = zeroesArr[currMaxIndex]\\n                zeroesArr[currMaxIndex] = zeroesArr[currMaxIndex - 1]\\n                zeroesArr[currMaxIndex - 1] = temp\\n                res += 1\\n                currMaxIndex -= 1\\n\\n            # Decrease minZeroesExpected for next row by 1\\n            minZeroesExpected -= 1\\n\\n        return res\\n\\n\\n             \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n\\n        # Time  : O(n^2)\\n        # Space : O(n)\\n\\n        n = len(grid)\\n        zeroesArr = []\\n\\n        # Calculate trailing zeroes for each row \\n        for i in range(n):\\n            trailingZeroes = 0\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    break\\n                trailingZeroes += 1\\n            zeroesArr.append(trailingZeroes)\\n\\n        # Min number of trailing zeroes expected in 1st row\\n        minZeroesExpected = n - 1\\n        res = 0\\n\\n        for i in range(n):\\n            currMax = -1\\n            currMaxIndex = -1\\n\\n            # Find closest row with trailing zeroes >= minZeroesExpected\\n            for j in range(i, n):\\n                if zeroesArr[j] >= minZeroesExpected:\\n                    currMax = zeroesArr[j]\\n                    currMaxIndex = j\\n                    break\\n\\n            # We couldn\\'t find any row with minZeroesExpected\\n            if currMax < minZeroesExpected:\\n                return - 1\\n            \\n            # Simulate stable swapping of rows \\n            # Stability in sorting means preserving the relative order between keys with same values\\n            # we need to maintain relative order of rows since we can only swap two adjacent rows.\\n            # Bubble Sort is preferred as it\\'s a stable sorting algorithm\\n            while currMaxIndex > i:\\n                temp = zeroesArr[currMaxIndex]\\n                zeroesArr[currMaxIndex] = zeroesArr[currMaxIndex - 1]\\n                zeroesArr[currMaxIndex - 1] = temp\\n                res += 1\\n                currMaxIndex -= 1\\n\\n            # Decrease minZeroesExpected for next row by 1\\n            minZeroesExpected -= 1\\n\\n        return res\\n\\n\\n             \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193676,
                "title": "naive-solution",
                "content": "# Approach\\nIf we look from top row to bottom we can see that every valid row has at leat n-1-i zeroes on the left (n - len of grid, i - row number). We make a slice couting zeroes (e.g. [0,1,2]). Now we can just \"bubble sort\" it from the top. For example, for upper level we need to move last row up and it will take 2 swaps ([0,1,2] -> [2,1,0]). We just count those swaps.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n\\n# Code\\n```\\nfunc minSwaps(grid [][]int) int {\\n    zero := make([]int, len(grid))\\n    for j, row := range grid {\\n        zeros := 0\\n        for i:=len(row)-1; i>=0; i-- {\\n            if row[i] == 0 {\\n                zeros++\\n                continue\\n            }\\n            break\\n        }\\n        zero[j] = zeros\\n    }\\n    swaps := 0\\n    for i:=0; i<len(grid); i++{\\n        num := len(grid)-1-i\\n        rowNum := -1\\n        for j:=i; j<len(grid); j++ {\\n            if zero[j]>=num {\\n                rowNum = j\\n                break\\n            }\\n        }\\n        if rowNum == -1 {\\n            return -1\\n        }\\n        swaps += rowNum-i\\n        if rowNum>i {\\n            // rearranging slice, j-row to i-place\\n            tempz := []int{}\\n            tempz = append(tempz, zero[:i]...)\\n            tempz = append(tempz, zero[rowNum])\\n            tempz = append(tempz, zero[i:rowNum]...)\\n            tempz = append(tempz, zero[rowNum+1:]...)\\n            zero = tempz\\n        }\\n    }\\n    return swaps\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minSwaps(grid [][]int) int {\\n    zero := make([]int, len(grid))\\n    for j, row := range grid {\\n        zeros := 0\\n        for i:=len(row)-1; i>=0; i-- {\\n            if row[i] == 0 {\\n                zeros++\\n                continue\\n            }\\n            break\\n        }\\n        zero[j] = zeros\\n    }\\n    swaps := 0\\n    for i:=0; i<len(grid); i++{\\n        num := len(grid)-1-i\\n        rowNum := -1\\n        for j:=i; j<len(grid); j++ {\\n            if zero[j]>=num {\\n                rowNum = j\\n                break\\n            }\\n        }\\n        if rowNum == -1 {\\n            return -1\\n        }\\n        swaps += rowNum-i\\n        if rowNum>i {\\n            // rearranging slice, j-row to i-place\\n            tempz := []int{}\\n            tempz = append(tempz, zero[:i]...)\\n            tempz = append(tempz, zero[rowNum])\\n            tempz = append(tempz, zero[i:rowNum]...)\\n            tempz = append(tempz, zero[rowNum+1:]...)\\n            zero = tempz\\n        }\\n    }\\n    return swaps\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167441,
                "title": "python-greedy-solution-92-faster",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr = []\\n        for row in grid:\\n            total = 0\\n            for i in range(len(row)-1,-1,-1):\\n                if row[i] == 1: break\\n                total += 1\\n            \\n            arr.append(total)\\n\\n        left = []\\n        res = 0\\n\\n        for i in range(len(grid)-1):\\n            target = len(grid)-1-i\\n            index = float(\"inf\")\\n            temp = []\\n            \\n            for j in range(len(arr)):\\n                if arr[j] >= target:\\n                    index = j\\n                    break\\n            \\n            if index == float(\"inf\"):return -1\\n\\n            for j in range(len(arr)):\\n                if j != index:\\n                    temp.append(arr[j])\\n            \\n            left.append(arr[index])\\n            arr = temp\\n            res += index\\n        \\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr = []\\n        for row in grid:\\n            total = 0\\n            for i in range(len(row)-1,-1,-1):\\n                if row[i] == 1: break\\n                total += 1\\n            \\n            arr.append(total)\\n\\n        left = []\\n        res = 0\\n\\n        for i in range(len(grid)-1):\\n            target = len(grid)-1-i\\n            index = float(\"inf\")\\n            temp = []\\n            \\n            for j in range(len(arr)):\\n                if arr[j] >= target:\\n                    index = j\\n                    break\\n            \\n            if index == float(\"inf\"):return -1\\n\\n            for j in range(len(arr)):\\n                if j != index:\\n                    temp.append(arr[j])\\n            \\n            left.append(arr[index])\\n            arr = temp\\n            res += index\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167180,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_swaps(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut zeros = vec![0; grid.len()];\\n        for (i, row) in grid.iter().enumerate() {\\n            zeros[i] = row.iter().rev().take_while(|&&x| x == 0).count() as i32;\\n        }\\n        let mut swaps = 0;\\n        for i in 0..zeros.len() {\\n            if zeros[i] < (zeros.len() - i - 1) as i32 {\\n                let mut j = i + 1;\\n                while j < zeros.len() && zeros[j] < (zeros.len() - i - 1) as i32 {\\n                    j += 1;\\n                }\\n                if j == zeros.len() {\\n                    return -1;\\n                }\\n                while j > i {\\n                    zeros.swap(j, j - 1);\\n                    swaps += 1;\\n                    j -= 1;\\n                }\\n            }\\n        }\\n        swaps\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_swaps(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut zeros = vec![0; grid.len()];\\n        for (i, row) in grid.iter().enumerate() {\\n            zeros[i] = row.iter().rev().take_while(|&&x| x == 0).count() as i32;\\n        }\\n        let mut swaps = 0;\\n        for i in 0..zeros.len() {\\n            if zeros[i] < (zeros.len() - i - 1) as i32 {\\n                let mut j = i + 1;\\n                while j < zeros.len() && zeros[j] < (zeros.len() - i - 1) as i32 {\\n                    j += 1;\\n                }\\n                if j == zeros.len() {\\n                    return -1;\\n                }\\n                while j > i {\\n                    zeros.swap(j, j - 1);\\n                    swaps += 1;\\n                    j -= 1;\\n                }\\n            }\\n        }\\n        swaps\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3013309,
                "title": "python-10-line-solution-time-o-n-2",
                "content": "```\\ndef minSwaps(self, grid: List[List[int]]) -> int:\\n\\tm, n, ans = len(grid), len(grid[0]), 0\\n\\tnums = [max([i for i in range(m) if r[i]==1] or [0]) for r in grid]\\n\\tif any(i<x for i, x in enumerate(sorted(nums))):\\n\\t\\treturn -1\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i]>i:\\n\\t\\t\\tj = min(k for k in range(i+1, n) if nums[k]<=i)\\n\\t\\t\\tnums[i:j+1] = [nums[j]]+nums[i:j]\\n\\t\\t\\tans += j-i\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minSwaps(self, grid: List[List[int]]) -> int:\\n\\tm, n, ans = len(grid), len(grid[0]), 0\\n\\tnums = [max([i for i in range(m) if r[i]==1] or [0]) for r in grid]\\n\\tif any(i<x for i, x in enumerate(sorted(nums))):\\n\\t\\treturn -1\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i]>i:\\n\\t\\t\\tj = min(k for k in range(i+1, n) if nums[k]<=i)\\n\\t\\t\\tnums[i:j+1] = [nums[j]]+nums[i:j]\\n\\t\\t\\tans += j-i\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2933324,
                "title": "sorting-c-easy-solution-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n       \\n        vector<int> vec;  //find order of zero:\\n        for(int i=0;i<grid.size();i++){\\n            int counter=0;\\n            for(int j=grid[0].size()-1;j>=0;j--){\\n               if(grid[i][j]==0){\\n                   counter++;\\n               }\\n               else if(grid[i][j]==1){\\n                   break;\\n               }\\n            }\\n            vec.push_back(counter);\\n        }\\n \\n        int ans=0;\\n        for(int i=0;i<n;i++){    \\n            int curr = i;\\n            int req = n - 1 - i; \\n            while(curr < n and vec[curr] < req){\\n                 curr++;\\n            }\\n            if(curr == n) return -1;\\n            ans+=curr - i;\\n            while(curr > 0){\\n                vec[curr] = vec[curr - 1];\\n                curr--;\\n            }\\n        }\\n        return ans;\\n       \\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n          \\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n       \\n        vector<int> vec;  //find order of zero:\\n        for(int i=0;i<grid.size();i++){\\n            int counter=0;\\n            for(int j=grid[0].size()-1;j>=0;j--){\\n               if(grid[i][j]==0){\\n                   counter++;\\n               }\\n               else if(grid[i][j]==1){\\n                   break;\\n               }\\n            }\\n            vec.push_back(counter);\\n        }\\n \\n        int ans=0;\\n        for(int i=0;i<n;i++){    \\n            int curr = i;\\n            int req = n - 1 - i; \\n            while(curr < n and vec[curr] < req){\\n                 curr++;\\n            }\\n            if(curr == n) return -1;\\n            ans+=curr - i;\\n            while(curr > 0){\\n                vec[curr] = vec[curr - 1];\\n                curr--;\\n            }\\n        }\\n        return ans;\\n       \\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918203,
                "title": "just-do-bubble-sort-and-count-number-of-swap-to-sort-the-array",
                "content": "Solution from Hint: \\n        \\n        n = len(grid)\\n        a = [0]*n\\n        res = 0\\n        \\n        for i in range(n):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j]:\\n                    a[i] = j\\n                    break \\n        \\n        b = a.copy()\\n        b.sort()\\n        for i in range(len(b)):\\n            if b[i]>i:  \\n                return -1 \\n            \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if a[i]>i:\\n                    a[i],a[j] = a[j],a[i]\\n                    res+=1   \\n\\n        return res",
                "solutionTags": [],
                "code": "Solution from Hint: \\n        \\n        n = len(grid)\\n        a = [0]*n\\n        res = 0\\n        \\n        for i in range(n):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j]:\\n                    a[i] = j\\n                    break \\n        \\n        b = a.copy()\\n        b.sort()\\n        for i in range(len(b)):\\n            if b[i]>i:  \\n                return -1 \\n            \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if a[i]>i:\\n                    a[i],a[j] = a[j],a[i]\\n                    res+=1   \\n\\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 2880627,
                "title": "python3-easy-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int: \\n        n = len(grid)\\n        # count trailing zeros \\n        count = []\\n        for i in range(n):\\n            cnt = 0 \\n            for j in range(n -1 , -1 , -1 ):\\n                if grid[i][j] != 0 : \\n                    break \\n                cnt += 1\\n            count.append(cnt)\\n        # Perforn Swapping \\n        req = n - 1 \\n        ans = 0 \\n        for i in range(n):\\n            check = False \\n            for j in range(i, n):\\n                if count[j] >= req:\\n                    while j !=  i : \\n                        count[j], count[j- 1] = count[j - 1] , count[j]\\n                        j -= 1 \\n                        ans += 1\\n                    req -= 1 \\n                    check  = True\\n                    break \\n            if check == False : \\n                return - 1 \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int: \\n        n = len(grid)\\n        # count trailing zeros \\n        count = []\\n        for i in range(n):\\n            cnt = 0 \\n            for j in range(n -1 , -1 , -1 ):\\n                if grid[i][j] != 0 : \\n                    break \\n                cnt += 1\\n            count.append(cnt)\\n        # Perforn Swapping \\n        req = n - 1 \\n        ans = 0 \\n        for i in range(n):\\n            check = False \\n            for j in range(i, n):\\n                if count[j] >= req:\\n                    while j !=  i : \\n                        count[j], count[j- 1] = count[j - 1] , count[j]\\n                        j -= 1 \\n                        ans += 1\\n                    req -= 1 \\n                    check  = True\\n                    break \\n            if check == False : \\n                return - 1 \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843246,
                "title": "linked-list-solution-fully-explained-python",
                "content": "For each row we count the number of consecutive zeros from the end.\\nWe then store that count in some sequential data structure (in this case linked list)\\n\\nthe count list might look something like this:\\n`[3,4,4,5,2], if n = 5`\\nwe want to turn this list into something like this:\\n```\\nfor general n\\n[a[0]>=n-1, a[1]>=n-2, a[2]>=n-3,.....a[n-1]>=1, a[n] >= whatever]\\n0th row must have atleast n-1 0s, thats why a[0] >= n-1,\\n...\\nn-1th row must have atleast 1 0s\\n```\\nso for 0th row we look for the first value in the list that is >=n-1, we then keep swapping that value until we reach 0th index. Instead of actually swapping you just find the index of that \"first value\" because thats the number of swaps needed.\\nYou also must remove that \"first value\" from the list because we can not use it again.\\n\\nIf we never find that \"first value\", then we return -1 because no solution exists\\n\\nYou can remove an element in O(1) using a linked list thats why I decided to use that instead of a list. \\n**Time: O(n^2)\\nSpace: O(n)**\\n```\\nclass Node:\\n    def __init__(self, val, nex=None):\\n        self.val = val\\n        self.nex = None\\n\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        head = c_tail = Node(-1) #dummy node\\n        for row in grid:\\n            c = 0\\n            for v in reversed(row):\\n                if v: break\\n                c += 1\\n            newNode = Node(c)\\n            c_tail.nex = newNode\\n            c_tail = newNode\\n\\n        moves = 0\\n        for c in range(n-1, 0, -1):\\n            \\n            i = 0\\n            c_node = head\\n            while c_node.nex:\\n                if c_node.nex.val >= c:\\n                    moves += i\\n                    c_node.nex = c_node.nex.nex\\n                    break\\n                i += 1\\n                c_node = c_node.nex\\n            else:\\n                return -1\\n\\n        return moves\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Greedy"
                ],
                "code": "```\\nfor general n\\n[a[0]>=n-1, a[1]>=n-2, a[2]>=n-3,.....a[n-1]>=1, a[n] >= whatever]\\n0th row must have atleast n-1 0s, thats why a[0] >= n-1,\\n...\\nn-1th row must have atleast 1 0s\\n```\n```\\nclass Node:\\n    def __init__(self, val, nex=None):\\n        self.val = val\\n        self.nex = None\\n\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        head = c_tail = Node(-1) #dummy node\\n        for row in grid:\\n            c = 0\\n            for v in reversed(row):\\n                if v: break\\n                c += 1\\n            newNode = Node(c)\\n            c_tail.nex = newNode\\n            c_tail = newNode\\n\\n        moves = 0\\n        for c in range(n-1, 0, -1):\\n            \\n            i = 0\\n            c_node = head\\n            while c_node.nex:\\n                if c_node.nex.val >= c:\\n                    moves += i\\n                    c_node.nex = c_node.nex.nex\\n                    break\\n                i += 1\\n                c_node = c_node.nex\\n            else:\\n                return -1\\n\\n        return moves\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811787,
                "title": "python-leverage-syntactic-sugar",
                "content": "# Approach\\nThe same idea as others. Counting the tail zeros and bubble sort.\\n\\n# Complexity\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        A = [sum(int(x == 0) for x in accumulate(row[::-1])) for row in grid]\\n        n = len(grid)\\n\\n        res = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if A[j] >= n - 1 - i:\\n                    A = A[:i] + A[j:j+1] + A[i:j] + A[j+1:]\\n                    res += j - i\\n                    break\\n            else:\\n                return -1\\n        \\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        A = [sum(int(x == 0) for x in accumulate(row[::-1])) for row in grid]\\n        n = len(grid)\\n\\n        res = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if A[j] >= n - 1 - i:\\n                    A = A[:i] + A[j:j+1] + A[i:j] + A[j+1:]\\n                    res += j - i\\n                    break\\n            else:\\n                return -1\\n        \\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795839,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        //store the number of zeroes in every row of grid\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<int> arr;\\n        for(int i=0;i<rows;i++)\\n        {\\n            int cnt=0;\\n            int j=cols-1;\\n            while(j>=0 && grid[i][j]==0)\\n                cnt++,j--;\\n            arr.push_back(cnt);\\n        }\\n       \\n        \\n        int req=cols-1;\\n        int swaps=0;\\n        //now try to swap the rows\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int j;\\n            for(j=i;j<arr.size();j++)\\n            {\\n               if(arr[j]>=req)\\n                  break;\\n            }\\n            if(j==arr.size())\\n                return -1;\\n            swaps+=j-i;\\n            //now swap the values\\n            while(j>i){\\n                swap(arr[j],arr[j-1]);j--;\\n            }\\n            req--;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        //store the number of zeroes in every row of grid\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<int> arr;\\n        for(int i=0;i<rows;i++)\\n        {\\n            int cnt=0;\\n            int j=cols-1;\\n            while(j>=0 && grid[i][j]==0)\\n                cnt++,j--;\\n            arr.push_back(cnt);\\n        }\\n       \\n        \\n        int req=cols-1;\\n        int swaps=0;\\n        //now try to swap the rows\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int j;\\n            for(j=i;j<arr.size();j++)\\n            {\\n               if(arr[j]>=req)\\n                  break;\\n            }\\n            if(j==arr.size())\\n                return -1;\\n            swaps+=j-i;\\n            //now swap the values\\n            while(j>i){\\n                swap(arr[j],arr[j-1]);j--;\\n            }\\n            req--;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789597,
                "title": "greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    void swap(vector<vector<int>> &grid, int i1, int i2){\\n        for(int i=0; i<n; i++){\\n            int t=grid[i1][i];\\n            grid[i1][i]=grid[i2][i];\\n            grid[i2][i]=t;\\n        }\\n    }\\n    \\n    bool isValid(vector<vector<int>> &grid){\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(grid[i][j]==1) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        n=grid[0].size();\\n        int ans=0;\\n        int n=grid.size();\\n        if(isValid(grid)) return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int counter=n-i-1;\\n            int ctz=0;\\n            for(int k=n-1;k>i;k--){\\n                if(grid[i][k]==0){\\n                    ctz++;\\n                }\\n            }\\n            \\n            if(ctz==counter) continue;\\n            \\n            int row=-1;\\n            for(int q=i+1; q<n; q++){\\n                int ctz1=0;\\n                for(int j=n-1;j>i;j--){\\n                    if(grid[q][j]==0){\\n                        ctz1++;\\n                    }\\n                }\\n                \\n                if(ctz1==counter){\\n                    row=q;\\n                    break;\\n                }\\n            }\\n            \\n            //cout<<row<<endl;\\n            if(row==-1){\\n                ans=-1;\\n                break;\\n            }\\n            \\n            int swaps=row-i;\\n            while(swaps>0){\\n                swap(grid, row, row-1);\\n                row=row-1;\\n                swaps--;\\n                ans++;\\n            }   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    void swap(vector<vector<int>> &grid, int i1, int i2){\\n        for(int i=0; i<n; i++){\\n            int t=grid[i1][i];\\n            grid[i1][i]=grid[i2][i];\\n            grid[i2][i]=t;\\n        }\\n    }\\n    \\n    bool isValid(vector<vector<int>> &grid){\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(grid[i][j]==1) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        n=grid[0].size();\\n        int ans=0;\\n        int n=grid.size();\\n        if(isValid(grid)) return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int counter=n-i-1;\\n            int ctz=0;\\n            for(int k=n-1;k>i;k--){\\n                if(grid[i][k]==0){\\n                    ctz++;\\n                }\\n            }\\n            \\n            if(ctz==counter) continue;\\n            \\n            int row=-1;\\n            for(int q=i+1; q<n; q++){\\n                int ctz1=0;\\n                for(int j=n-1;j>i;j--){\\n                    if(grid[q][j]==0){\\n                        ctz1++;\\n                    }\\n                }\\n                \\n                if(ctz1==counter){\\n                    row=q;\\n                    break;\\n                }\\n            }\\n            \\n            //cout<<row<<endl;\\n            if(row==-1){\\n                ans=-1;\\n                break;\\n            }\\n            \\n            int swaps=row-i;\\n            while(swaps>0){\\n                swap(grid, row, row-1);\\n                row=row-1;\\n                swaps--;\\n                ans++;\\n            }   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2784644,
                "title": "c",
                "content": "Runtime: 116 ms, faster than 100.00% of C online submissions for Minimum Swaps to Arrange a Binary Grid.\\nMemory Usage: 10 MB, less than 33.33% of C online submissions for Minimum Swaps to Arrange a Binary Grid.\\n```\\nint minSwaps(int** grid, int gridSize, int* gridColSize){\\n    int n = gridSize;\\n    int* TailZero = malloc(n * sizeof(int));\\n    for(int i = 0; i < n; i++){\\n        int cn = 0;\\n        for(int j = n-1; j >= 0; j--){\\n            if(grid[i][j] == 1)\\n                break;\\n            cn++;\\n        }\\n        TailZero[i] = cn;\\n    }\\n\\n    int step = 0;\\n    for(int i = 0; i < n ; i ++){\\n        for(int j = i;  j < n; j++){\\n            if(TailZero[j] >= (n-1-i)){\\n                step += (j - i);\\n                if(j == i)\\n                    break;\\n                for(int k = j; k > i; k--){\\n                    TailZero[k] = TailZero[k-1];   \\n                }\\n                TailZero[i] = i;\\n                break;\\n            }\\n            if(j == n-1)\\n                return -1;\\n        }\\n    }\\n    return step;   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSwaps(int** grid, int gridSize, int* gridColSize){\\n    int n = gridSize;\\n    int* TailZero = malloc(n * sizeof(int));\\n    for(int i = 0; i < n; i++){\\n        int cn = 0;\\n        for(int j = n-1; j >= 0; j--){\\n            if(grid[i][j] == 1)\\n                break;\\n            cn++;\\n        }\\n        TailZero[i] = cn;\\n    }\\n\\n    int step = 0;\\n    for(int i = 0; i < n ; i ++){\\n        for(int j = i;  j < n; j++){\\n            if(TailZero[j] >= (n-1-i)){\\n                step += (j - i);\\n                if(j == i)\\n                    break;\\n                for(int k = j; k > i; k--){\\n                    TailZero[k] = TailZero[k-1];   \\n                }\\n                TailZero[i] = i;\\n                break;\\n            }\\n            if(j == n-1)\\n                return -1;\\n        }\\n    }\\n    return step;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515729,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        vector<int>t(n,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]==0)\\n                    t[i]++;\\n                else break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int req=n-i-1;\\n            int pos=i;\\n            while(pos<n && t[pos]<req)\\n                pos++;\\n            if(pos==n)\\n                return -1;\\n            ans+=pos-i;\\n            for(int k=pos-1;k>=i;k--)\\n                t[k+1]=t[k];\\n            t[i]=t[pos];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        vector<int>t(n,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=n-1;j>=0;j--){\\n                if(grid[i][j]==0)\\n                    t[i]++;\\n                else break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int req=n-i-1;\\n            int pos=i;\\n            while(pos<n && t[pos]<req)\\n                pos++;\\n            if(pos==n)\\n                return -1;\\n            ans+=pos-i;\\n            for(int k=pos-1;k>=i;k--)\\n                t[k+1]=t[k];\\n            t[i]=t[pos];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492404,
                "title": "python-to-1d-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        # grid --> back-lead zero needed\\n        back_zero_rows = [0] * n\\n        for i in range(n):\\n            back_zero_count = 0\\n            for x in reversed(grid[i]):\\n                if x == 0:\\n                    back_zero_count += 1\\n                else:\\n                    break\\n            back_zero_rows[i] = back_zero_count\\n\\n        # count the step\\n        counter = 0\\n        for i in range(n):\\n            zero_needed = n-1-i\\n            # if need no enough zero, u need to find a line to swap\\n            if back_zero_rows[i] < zero_needed:\\n                for j in range(i + 1, n):\\n                    if back_zero_rows[j] >= zero_needed:\\n                        # NOTION: not swap (counter)\\n                        # back_zero_rows[i], back_zero_rows[j] = back_zero_rows[j], back_zero_rows[i]\\n                        # difference: remove + insert\\n                        line = back_zero_rows.pop(j)\\n                        back_zero_rows.insert(i, line)\\n                        counter += j - i\\n                        break\\n                else:\\n                    return -1\\n        return counter\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        # grid --> back-lead zero needed\\n        back_zero_rows = [0] * n\\n        for i in range(n):\\n            back_zero_count = 0\\n            for x in reversed(grid[i]):\\n                if x == 0:\\n                    back_zero_count += 1\\n                else:\\n                    break\\n            back_zero_rows[i] = back_zero_count\\n\\n        # count the step\\n        counter = 0\\n        for i in range(n):\\n            zero_needed = n-1-i\\n            # if need no enough zero, u need to find a line to swap\\n            if back_zero_rows[i] < zero_needed:\\n                for j in range(i + 1, n):\\n                    if back_zero_rows[j] >= zero_needed:\\n                        # NOTION: not swap (counter)\\n                        # back_zero_rows[i], back_zero_rows[j] = back_zero_rows[j], back_zero_rows[i]\\n                        # difference: remove + insert\\n                        line = back_zero_rows.pop(j)\\n                        back_zero_rows.insert(i, line)\\n                        counter += j - i\\n                        break\\n                else:\\n                    return -1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475416,
                "title": "swap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void swaps(int from, int need, vector<int> &len) {\\n        for (int i = need - 1; i >= 0; i--) {\\n            int temp = len[from + i];\\n            len[from + i] = len[from + i + 1];\\n            len[from + i + 1] = temp;\\n        }\\n    }\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> len(grid.size());\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int k = grid[i].size() - 1; k > 0 && grid[i][k] == 0; k--) {\\n                \\n                len[i]++;\\n            }\\n        }\\n        int size = len.size();\\n        priority_queue<int> pq;\\n        int res = 0;\\n        for (int i = 0; i < size; i++) {\\n            int need = 0;\\n            if (!pq.empty() && pq.top() >= size - i - 1) {\\n                pq.pop();\\n                continue;\\n            }\\n            for (int j = i; j < size && !(len[j] >= size - i - 1); j++) {\\n                need++;\\n            }\\n            if (need > size - i - 1) {\\n                return - 1;\\n            }\\n            swaps(i, need, len);\\n            cout << endl;\\n            res += need;\\n        }\\n        return res;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void swaps(int from, int need, vector<int> &len) {\\n        for (int i = need - 1; i >= 0; i--) {\\n            int temp = len[from + i];\\n            len[from + i] = len[from + i + 1];\\n            len[from + i + 1] = temp;\\n        }\\n    }\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> len(grid.size());\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int k = grid[i].size() - 1; k > 0 && grid[i][k] == 0; k--) {\\n                \\n                len[i]++;\\n            }\\n        }\\n        int size = len.size();\\n        priority_queue<int> pq;\\n        int res = 0;\\n        for (int i = 0; i < size; i++) {\\n            int need = 0;\\n            if (!pq.empty() && pq.top() >= size - i - 1) {\\n                pq.pop();\\n                continue;\\n            }\\n            for (int j = i; j < size && !(len[j] >= size - i - 1); j++) {\\n                need++;\\n            }\\n            if (need > size - i - 1) {\\n                return - 1;\\n            }\\n            swaps(i, need, len);\\n            cout << endl;\\n            res += need;\\n        }\\n        return res;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 2410212,
                "title": "python-count-and-swap",
                "content": "**Solution**:\\n    Start by counting consecutive zeros in each row starting from the end of the column. Store (row, zero count) in an ordered dictionary. We will use this like a stack but we can remove any item in O(1).  \\n\\nNext, iterate through all rows and calculate how many zeros is needed in such row. Then, find the first row in the ordered dictionary that contains at least that much zeros. The index of such first row will be the amount of steps we need to swap to move such row to the correct position. Delete used row.  \\n\\n    ie. Given grid = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]]\\n\\n    1. Count zeroes\\n        orderedDict = {0:3, 1:0, 2:3, 3:3}\\n\\n    2. Calculate steps\\n        row     zerosNeeded     orderedDict           firstRow    firstRowIndex    swaps\\n        0       3               {0:3, 1:0, 2:3, 3:3}  0           0                0\\n        1       2               {1:0, 2:3, 3:3}       2           1                1\\n        2       1               {1:0, 3:3}            3           1                2\\n        3       0               {1:0}                 1           0                2\\n\\n**Complexity**:\\n    Time: O(n ** 2)\\n    Space: O(n)\\n\\t\\n```\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def minSwaps(self, grid: list[list[int]]) -> int:\\n\\n        # Get the number of rows and cols\\n        n = len(grid)\\n\\n        # Calcualte zeros for each row\\n        # Initialize the ordered dict to store rows and their zeros\\n        zeroCounts = OrderedDict()\\n\\n        # Iterate through all rows\\n        for row in range(n):\\n\\n            count = 0\\n\\n            # Count the number of consecutive zeros\\n            for col in range(n - 1, -1, -1):\\n\\n                # End the count when we see the first one\\n                if grid[row][col] == 1:\\n                    break\\n\\n                # Increment the zeros count\\n                count += 1\\n\\n            # Save the row and its zeros count to the dict\\n            zeroCounts[row] = count\\n\\n\\n        # Calculate the number of swaps \\n        # Intialize the swap to 0\\n        swaps = 0\\n\\n        # Iterate through all rows\\n        for row in range(n):\\n\\n            # Find the first row that has the required zeros\\n            for i, (col, count) in enumerate(zeroCounts.items()):\\n\\n                # If we found one\\n                if count >= n - row - 1:\\n\\n                    # Increment the swap based on the row index in the dict\\n                    swaps += i\\n\\n                    # Remove such row\\n                    zeroCounts.pop(col)\\n\\n                    # Continue to the next row\\n                    break\\n\\n                # Else, if we couldn\\'t find one, return -1\\n                if i == len(zeroCounts) - 1:\\n                    return -1\\n\\n        return swaps\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def minSwaps(self, grid: list[list[int]]) -> int:\\n\\n        # Get the number of rows and cols\\n        n = len(grid)\\n\\n        # Calcualte zeros for each row\\n        # Initialize the ordered dict to store rows and their zeros\\n        zeroCounts = OrderedDict()\\n\\n        # Iterate through all rows\\n        for row in range(n):\\n\\n            count = 0\\n\\n            # Count the number of consecutive zeros\\n            for col in range(n - 1, -1, -1):\\n\\n                # End the count when we see the first one\\n                if grid[row][col] == 1:\\n                    break\\n\\n                # Increment the zeros count\\n                count += 1\\n\\n            # Save the row and its zeros count to the dict\\n            zeroCounts[row] = count\\n\\n\\n        # Calculate the number of swaps \\n        # Intialize the swap to 0\\n        swaps = 0\\n\\n        # Iterate through all rows\\n        for row in range(n):\\n\\n            # Find the first row that has the required zeros\\n            for i, (col, count) in enumerate(zeroCounts.items()):\\n\\n                # If we found one\\n                if count >= n - row - 1:\\n\\n                    # Increment the swap based on the row index in the dict\\n                    swaps += i\\n\\n                    # Remove such row\\n                    zeroCounts.pop(col)\\n\\n                    # Continue to the next row\\n                    break\\n\\n                # Else, if we couldn\\'t find one, return -1\\n                if i == len(zeroCounts) - 1:\\n                    return -1\\n\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340223,
                "title": "intuitive-do-as-hints-say-reduce-problem-to-number-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> max_right;\\n        for (auto g : grid) {\\n            int right = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (g[i])\\n                    right = max(right, i);\\n            }\\n            max_right.push_back(right);\\n        }\\n        \\n        auto check = max_right;\\n        sort(check.begin(), check.end());\\n        for (int i = 0; i < n; ++i) {\\n            if (check[i] > i)\\n                return -1;\\n        }\\n        \\n        int swaps = 0;\\n        for (int i = 0; i < n; ++i) {\\n\\n            int idx = -1;\\n            for (int j = i; j < n; ++j) {\\n                if (max_right[j] <= i) {\\n                    idx = j;\\n                    break;\\n                }\\n            }\\n            for (int j = idx; j > i; --j) {\\n                max_right[j] = max_right[j - 1];\\n                ++swaps;\\n            }\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> max_right;\\n        for (auto g : grid) {\\n            int right = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (g[i])\\n                    right = max(right, i);\\n            }\\n            max_right.push_back(right);\\n        }\\n        \\n        auto check = max_right;\\n        sort(check.begin(), check.end());\\n        for (int i = 0; i < n; ++i) {\\n            if (check[i] > i)\\n                return -1;\\n        }\\n        \\n        int swaps = 0;\\n        for (int i = 0; i < n; ++i) {\\n\\n            int idx = -1;\\n            for (int j = i; j < n; ++j) {\\n                if (max_right[j] <= i) {\\n                    idx = j;\\n                    break;\\n                }\\n            }\\n            for (int j = idx; j > i; --j) {\\n                max_right[j] = max_right[j - 1];\\n                ++swaps;\\n            }\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289175,
                "title": "c-detailed-explanation-greedy-basic-sorting-technique-used",
                "content": "## *****INTUITION-:\\n\\n## ****  suppose n=6\\n    \\n /*    no . of zeros from end consecutively at each rows is [ 2 , 3 , 5 , 2 , 5 , 2]\\n    \\n     after first iteration we need at least 5 zeros at 0th index\\n    \\n     array will be [ 5 , 2 , 3 , 2 , 5 , 2] -> swap=2\\n    \\n     firstly 2 goes to 1st index , then 3 goes to 2nd index , we found our answer 5\\n    \\n     5 comes to required position 0th index \\n    \\n     [ 5 , 2 , 3 , 2 , 5 , 2] -> now we are at 1st index value is 2 , but \\n    \\n     we require at least 4 zeros \\n    \\n    go on same way the array will be [5 , 5 , 2 , 3 , 2 , 2] swaps =3 \\n    \\n    now we need at least 3 zeros , [5 , 5 , 3 , 2 , 2 , 2] swaps=1\\n    \\n    now no more swappings are required as no of required zeros is fulfilling */\\n\\t\\n\\t\\n\\n```\\n \\n\\n\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int> nums(n , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            nums[i]=count;\\n        }\\n        \\n        // now we have to make tha nums array sorting acccording to values \\n        \\n        // lets say nums array is [ 1, 2 , 3 , 4]\\n        \\n        // requirement is at least 3 zeros at 0th index\\n        \\n        // at least 2 zeros at 1st index\\n        \\n        //  at least 1 zeros at 2nd index \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            int required_zero=n-i-1;\\n            \\n            if(nums[i]>=required_zero)\\n            {\\n                continue;\\n            }\\n            \\n            int curr_val=nums[i];\\n            bool f=false;\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]>=(required_zero))\\n                {\\n                    nums[i]=nums[j];\\n                    nums[j]=curr_val; \\n                    ans++;\\n                    f=true;\\n                    break;\\n                }\\n                else\\n                {\\n                    int temp=nums[j];\\n                    nums[j]=curr_val;\\n                    curr_val=temp;\\n                    ans++;\\n                }\\n            }\\n            if(f==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n``` \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int> nums(n , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            nums[i]=count;\\n        }\\n        \\n        // now we have to make tha nums array sorting acccording to values \\n        \\n        // lets say nums array is [ 1, 2 , 3 , 4]\\n        \\n        // requirement is at least 3 zeros at 0th index\\n        \\n        // at least 2 zeros at 1st index\\n        \\n        //  at least 1 zeros at 2nd index \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            int required_zero=n-i-1;\\n            \\n            if(nums[i]>=required_zero)\\n            {\\n                continue;\\n            }\\n            \\n            int curr_val=nums[i];\\n            bool f=false;\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]>=(required_zero))\\n                {\\n                    nums[i]=nums[j];\\n                    nums[j]=curr_val; \\n                    ans++;\\n                    f=true;\\n                    break;\\n                }\\n                else\\n                {\\n                    int temp=nums[j];\\n                    nums[j]=curr_val;\\n                    curr_val=temp;\\n                    ans++;\\n                }\\n            }\\n            if(f==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n \\n\\n\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        vector<int> nums(n , 0);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            nums[i]=count;\\n        }\\n        \\n        // now we have to make tha nums array sorting acccording to values \\n        \\n        // lets say nums array is [ 1, 2 , 3 , 4]\\n        \\n        // requirement is at least 3 zeros at 0th index\\n        \\n        // at least 2 zeros at 1st index\\n        \\n        //  at least 1 zeros at 2nd index \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            int required_zero=n-i-1;\\n            \\n            if(nums[i]>=required_zero)\\n            {\\n                continue;\\n            }\\n            \\n            int curr_val=nums[i];\\n            bool f=false;\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]>=(required_zero))\\n                {\\n                    nums[i]=nums[j];\\n                    nums[j]=curr_val; \\n                    ans++;\\n                    f=true;\\n                    break;\\n                }\\n                else\\n                {\\n                    int temp=nums[j];\\n                    nums[j]=curr_val;\\n                    curr_val=temp;\\n                    ans++;\\n                }\\n            }\\n            if(f==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2207558,
                "title": "bubble-sort-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<int> mr(n,0);\\n        vector<int> br(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    mr[i] = j;\\n            }\\n        }\\n        br = mr;\\n        sort(mr.begin(),mr.end());\\n        for(int i=0;i<n;i++)\\n            if(mr[i]>i)\\n                return -1;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(br[i]>i){\\n                    swap(br[i],br[j]);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<int> mr(n,0);\\n        vector<int> br(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    mr[i] = j;\\n            }\\n        }\\n        br = mr;\\n        sort(mr.begin(),mr.end());\\n        for(int i=0;i<n;i++)\\n            if(mr[i]>i)\\n                return -1;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(br[i]>i){\\n                    swap(br[i],br[j]);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191159,
                "title": "c-greedy-solution-bubble-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<int> mr(n,0);\\n        vector<int> br(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    mr[i] = j;\\n            }\\n        }\\n        br = mr;\\n        sort(mr.begin(),mr.end());\\n        for(int i=0;i<n;i++)\\n            if(mr[i]>i)\\n                return -1;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(br[i]>i){\\n                    swap(br[i],br[j]);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<int> mr(n,0);\\n        vector<int> br(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                    mr[i] = j;\\n            }\\n        }\\n        br = mr;\\n        sort(mr.begin(),mr.end());\\n        for(int i=0;i<n;i++)\\n            if(mr[i]>i)\\n                return -1;\\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(br[i]>i){\\n                    swap(br[i],br[j]);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081294,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& g) {\\n        int r=g.size(),s=0;\\n        vector<int>z(r);\\n        for(int i=0;i<r;i++)\\n            for(int j=r-1;j>=0;j--){\\n                if(g[i][j])break;\\n                z[i]++;\\n            }\\n        for(int i=0;i<r;i++){\\n            int cur=i,req=r-1-i;\\n            if(z[cur]>=req)continue;\\n            while(cur<r && z[cur]<req)cur++;\\n            if(cur==r) return -1;\\n            s+=cur-i;\\n            while(cur>i){\\n                z[cur]=z[cur-1];\\n                --cur;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& g) {\\n        int r=g.size(),s=0;\\n        vector<int>z(r);\\n        for(int i=0;i<r;i++)\\n            for(int j=r-1;j>=0;j--){\\n                if(g[i][j])break;\\n                z[i]++;\\n            }\\n        for(int i=0;i<r;i++){\\n            int cur=i,req=r-1-i;\\n            if(z[cur]>=req)continue;\\n            while(cur<r && z[cur]<req)cur++;\\n            if(cur==r) return -1;\\n            s+=cur-i;\\n            while(cur>i){\\n                z[cur]=z[cur-1];\\n                --cur;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066690,
                "title": "c-simply-try-fit-every-row",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<int> zeroCounts(n, 0);                  //calc ending zero count of each row\\n        for (int i = 0; i < n; ++i)\\n            for (int j =n - 1; j >= 0 && grid[i][j] == 0; --j, ++zeroCounts[i]);\\n\\n        int steps = 0,i=0,j=0;\\n        for ( ; i < n; ++i) {                           //try to match each row (ending zero count euqal to i-1)\\n            if (zeroCounts[i] >= n - i - 1) continue;   //already matched\\n            \\n            for ( j = i + 1; j < n; ++j)                //find out a correct row to switch with current row\\n                if (zeroCounts[j] >= n - i - 1) \\n                {\\n                    for (int k = j; k > i; --k) { \\n                        swap(grid[k], grid[k - 1]);\\n                        swap(zeroCounts[k], zeroCounts[k - 1]);\\n                    }\\n\\n                    steps += j - i;\\n                    break;\\n                }\\n\\n            if (j == n) return -1;\\n        }\\n\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<int> zeroCounts(n, 0);                  //calc ending zero count of each row\\n        for (int i = 0; i < n; ++i)\\n            for (int j =n - 1; j >= 0 && grid[i][j] == 0; --j, ++zeroCounts[i]);\\n\\n        int steps = 0,i=0,j=0;\\n        for ( ; i < n; ++i) {                           //try to match each row (ending zero count euqal to i-1)\\n            if (zeroCounts[i] >= n - i - 1) continue;   //already matched\\n            \\n            for ( j = i + 1; j < n; ++j)                //find out a correct row to switch with current row\\n                if (zeroCounts[j] >= n - i - 1) \\n                {\\n                    for (int k = j; k > i; --k) { \\n                        swap(grid[k], grid[k - 1]);\\n                        swap(zeroCounts[k], zeroCounts[k - 1]);\\n                    }\\n\\n                    steps += j - i;\\n                    break;\\n                }\\n\\n            if (j == n) return -1;\\n        }\\n\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036684,
                "title": "simple-c-o-n-3-solution",
                "content": "Time complexity : O(N^3)\\nSpace Complexity : O(1)\\n```\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define vvi vector<vi>\\n    \\n    void printGrid(vvi grid){\\n        cout<<\"Grid : \\\\n\";\\n        for(auto ele:grid){\\n            for(auto every:ele){\\n                cout<<every<<\" \";\\n            }\\n            cout<<endl;\\n            \\n        }\\n        \\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int i=0;\\n        \\n        int R = grid.size();\\n        int C = grid[0].size();\\n        \\n        int ans=0;\\n        \\n        // iterate over each row to find best possible row for any index i\\n        // NOTE: best possible row is row with max suffix zeros >= (C-i-1) and with minimum index (I)\\n        while(i<R){\\n            \\n            int I =i;\\n            int ind = INT_MAX;\\n            \\n            // iterate throw all rows >=i to count suffix 0\\'s following above stated criteria\\n            while(I<R){\\n                \\n                int J = C-1;\\n                int count = 0;\\n                \\n                // count suffix 0s    \\n                while(J>=0&&grid[I][J]==0){\\n                    count++;    \\n                    J--;\\n                }\\n                \\n                // take ind to be that I where suffix 0\\'s count >= (C-i-1)\\n                if(count>=C-i-1){\\n                    ind = min(ind,I);\\n                }\\n                I++;\\n            }\\n            \\n            if(ind!=INT_MAX){\\n                \\n                // perform swapping of of every j & j+1 rows till j reaches i\\n                int j = ind-1;\\n                while(j>=i){\\n\\n                    int l = 0;\\n                    while(l<C){\\n                        int t = grid[j][l];\\n                        grid[j][l] = grid[j+1][l];\\n                        grid[j+1][l]=t;\\n                        l++;\\n                    }\\n\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n            else return -1; // this is edge case where best possible row to be swapped for row i is never found in grid so return -1\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define vvi vector<vi>\\n    \\n    void printGrid(vvi grid){\\n        cout<<\"Grid : \\\\n\";\\n        for(auto ele:grid){\\n            for(auto every:ele){\\n                cout<<every<<\" \";\\n            }\\n            cout<<endl;\\n            \\n        }\\n        \\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        \\n        int i=0;\\n        \\n        int R = grid.size();\\n        int C = grid[0].size();\\n        \\n        int ans=0;\\n        \\n        // iterate over each row to find best possible row for any index i\\n        // NOTE: best possible row is row with max suffix zeros >= (C-i-1) and with minimum index (I)\\n        while(i<R){\\n            \\n            int I =i;\\n            int ind = INT_MAX;\\n            \\n            // iterate throw all rows >=i to count suffix 0\\'s following above stated criteria\\n            while(I<R){\\n                \\n                int J = C-1;\\n                int count = 0;\\n                \\n                // count suffix 0s    \\n                while(J>=0&&grid[I][J]==0){\\n                    count++;    \\n                    J--;\\n                }\\n                \\n                // take ind to be that I where suffix 0\\'s count >= (C-i-1)\\n                if(count>=C-i-1){\\n                    ind = min(ind,I);\\n                }\\n                I++;\\n            }\\n            \\n            if(ind!=INT_MAX){\\n                \\n                // perform swapping of of every j & j+1 rows till j reaches i\\n                int j = ind-1;\\n                while(j>=i){\\n\\n                    int l = 0;\\n                    while(l<C){\\n                        int t = grid[j][l];\\n                        grid[j][l] = grid[j+1][l];\\n                        grid[j+1][l]=t;\\n                        l++;\\n                    }\\n\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n            else return -1; // this is edge case where best possible row to be swapped for row i is never found in grid so return -1\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1999181,
                "title": "java-from-top-to-bottom-comments",
                "content": "**Idea**\\n1. Treat each row and a number and we can swap it directly. No need to do any transformation.\\n\\n2. We should always sort it from the top and work our way downward. It is because during this process, the smaller (later ones) can be pushed closer to its fitting row as a side effect. If we had start from anything other than the top row, while we are swapping into the top row, it will also mess up all the previous ones that we\\'ve sorted. Intuitively speaking, it only makes sense to start from the top.\\n```Java\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, ans = 0, cur = 0;\\n        for (int k = 0; k < n - 1; k++){ // looking for the fitting row for row k\\n            for (int i = k; i < n; i++){ // start from row k looking downward\\n                for (int j = k + 1; j < n; j++){ // all cell after and at k + 1 must be 0\\n                    if (grid[i][j] == 1)\\n                        break;\\n                    if (j < n - 1)\\n                        continue;\\n                    for (int m = i; m > k; m--){ // j == n - 1 here, so we found a valid row\\n                        int[] tmp = grid[m - 1];  // swap it into the correct row - row k\\n                        grid[m - 1] = grid[m];\\n                        grid[m] = tmp;\\n                        ans++;\\n                    }\\n                    i = n;\\n                }\\n                if (i == n - 1) // i reaches the end and did not find a fitting row, return -1\\n                    return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, ans = 0, cur = 0;\\n        for (int k = 0; k < n - 1; k++){ // looking for the fitting row for row k\\n            for (int i = k; i < n; i++){ // start from row k looking downward\\n                for (int j = k + 1; j < n; j++){ // all cell after and at k + 1 must be 0\\n                    if (grid[i][j] == 1)\\n                        break;\\n                    if (j < n - 1)\\n                        continue;\\n                    for (int m = i; m > k; m--){ // j == n - 1 here, so we found a valid row\\n                        int[] tmp = grid[m - 1];  // swap it into the correct row - row k\\n                        grid[m - 1] = grid[m];\\n                        grid[m] = tmp;\\n                        ans++;\\n                    }\\n                    i = n;\\n                }\\n                if (i == n - 1) // i reaches the end and did not find a fitting row, return -1\\n                    return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859085,
                "title": "python-count-swaps-by-reducing-array-of-right-most-ones",
                "content": "For any grid, we want the right-most 1 to be at most 0, 1, 2, ... n for the respective rows\\n\\n0000\\n?000\\n??00\\n???0\\n\\n1. For each row check the rightmost 1\\n2. Validate that a solution is possible by sorting array and verifying that the right-most one is at most at pos n for row n\\n3. Simulate the swaps by reducing the array of right-most ones\\n\\nFor step 3 - if our grid is `[[0, 0, 1], [1, 1, 0], [1, 0, 0]]` so our array of right-most ones is `[2, 1, 0]` we get the following\\n\\n1. Find 0 (or less) at position 2 - it will take **2 steps** to get the 0 to position 0 - Reduce array to `[2, 1]` - we have 2 rows left to position\\n2. Find 1 (or less) at position 1 - it will take **1 step** to get the 1 to position 0 - Reduce array to `[2]` - we have 1 row left to position\\n3. Find 2 (or less) at position 0 - it will take **0 steps** to get the 2 to position 0 - Reduce array to `[]` - DONE! \\n\\nThe result is 2 + 1 + 0 steps\\n\\n```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        def get_rightmost_one(row):\\n            for i in range(n - 1, -1, -1):\\n                if row[i] == 1:\\n                    return i\\n            return -1\\n\\n        def solution_is_possible(max_right):\\n            sorted_right = list(sorted(max_right))\\n\\n            for pos, val in enumerate(sorted_right):\\n                if val > pos:\\n                    return False\\n            return True\\n\\n        max_right = [get_rightmost_one(row) for row in grid]\\n        if not solution_is_possible(max_right):\\n            return -1\\n\\n        swaps = 0\\n        for pos in range(n):\\n            idx = 0\\n            while max_right[idx] > pos:\\n                idx += 1\\n\\n            max_right = max_right[:idx] + max_right[idx + 1:]\\n            swaps += idx\\n\\n        return swaps\\n\\n\\nsolution = Solution()\\nassert solution.minSwaps([[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0]]) == -1\\nassert solution.minSwaps([[0, 0, 1], [1, 1, 0], [1, 0, 0]]) == 3\\nassert solution.minSwaps([[1, 0, 0], [1, 1, 0], [1, 1, 1]]) == 0\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        def get_rightmost_one(row):\\n            for i in range(n - 1, -1, -1):\\n                if row[i] == 1:\\n                    return i\\n            return -1\\n\\n        def solution_is_possible(max_right):\\n            sorted_right = list(sorted(max_right))\\n\\n            for pos, val in enumerate(sorted_right):\\n                if val > pos:\\n                    return False\\n            return True\\n\\n        max_right = [get_rightmost_one(row) for row in grid]\\n        if not solution_is_possible(max_right):\\n            return -1\\n\\n        swaps = 0\\n        for pos in range(n):\\n            idx = 0\\n            while max_right[idx] > pos:\\n                idx += 1\\n\\n            max_right = max_right[:idx] + max_right[idx + 1:]\\n            swaps += idx\\n\\n        return swaps\\n\\n\\nsolution = Solution()\\nassert solution.minSwaps([[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0]]) == -1\\nassert solution.minSwaps([[0, 0, 1], [1, 1, 0], [1, 0, 0]]) == 3\\nassert solution.minSwaps([[1, 0, 0], [1, 1, 0], [1, 1, 1]]) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729993,
                "title": "java-greedy-solution",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            if (valid(grid[i], i)) continue;\\n            boolean found = false;\\n            for (int j = i+1; j<n; j++) {\\n                if (valid(grid[j], i)) {\\n                    // swap row i and j\\n                    grid = swap(grid, i, j);\\n                    ans += j-i;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) return -1;\\n        }\\n        return ans;\\n    }\\n    public int[][] swap(int[][] grid, int i, int j) {\\n        int [] j_row = grid[j].clone();\\n        for (int k = j-1; k>=i; k--) {\\n            grid[k+1] = grid[k];\\n        }\\n        grid[i] = j_row;\\n        //System.out.println(Arrays.deepToString(grid));\\n        return grid;\\n    }\\n    public boolean valid(int[] r, int idx) {\\n        for (int i = idx+1; i<r.length; i++) {\\n            if (r[i]==1) return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length, ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            if (valid(grid[i], i)) continue;\\n            boolean found = false;\\n            for (int j = i+1; j<n; j++) {\\n                if (valid(grid[j], i)) {\\n                    // swap row i and j\\n                    grid = swap(grid, i, j);\\n                    ans += j-i;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) return -1;\\n        }\\n        return ans;\\n    }\\n    public int[][] swap(int[][] grid, int i, int j) {\\n        int [] j_row = grid[j].clone();\\n        for (int k = j-1; k>=i; k--) {\\n            grid[k+1] = grid[k];\\n        }\\n        grid[i] = j_row;\\n        //System.out.println(Arrays.deepToString(grid));\\n        return grid;\\n    }\\n    public boolean valid(int[] r, int idx) {\\n        for (int i = idx+1; i<r.length; i++) {\\n            if (r[i]==1) return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649269,
                "title": "convert-grid-swap-to-list-swap",
                "content": "```\\nr\\'\\'\\'\\n1536. Minimum Swaps to Arrange a Binary Grid\\n\\n0: 001 2\\n1: 110 1\\n2: 100 0\\n\\nthe problem becomese making 210 to 012 by swaping adjacent elements\\n\\nif there are same rows, for example 0320\\n\\n0320 -> 0023 : 3\\n0320 >(2) 0032 > 0023\\n\\n1210 -> 0112 : 4\\n1210 >(3) 0121 > 0112\\n\\ni: 0123\\nr: 1210\\n\\nfor each i\\n   find the j from i where r[j]<=i\\n   if not found return -1\\n   swaps += j-i\\n   push i..j-1 one step right\\n\\ntime complexity\\n. get r: O(n^2)\\n. get swaps: O(n^2)\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minSwaps(self, grid):\\n        # convert grid to r\\n        n, r = len(grid), []\\n        for i in range(n):\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    r.append(j)\\n                    break\\n            else: r.append(-1)\\n\\n        # swap r\\n        swaps = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if r[j] <= i:\\n                    swaps += (j-i)\\n                    for k in range(j-1, i-1, -1): r[k+1] = r[k]\\n                    break\\n            else: return -1\\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```\\nr\\'\\'\\'\\n1536. Minimum Swaps to Arrange a Binary Grid\\n\\n0: 001 2\\n1: 110 1\\n2: 100 0\\n\\nthe problem becomese making 210 to 012 by swaping adjacent elements\\n\\nif there are same rows, for example 0320\\n\\n0320 -> 0023 : 3\\n0320 >(2) 0032 > 0023\\n\\n1210 -> 0112 : 4\\n1210 >(3) 0121 > 0112\\n\\ni: 0123\\nr: 1210\\n\\nfor each i\\n   find the j from i where r[j]<=i\\n   if not found return -1\\n   swaps += j-i\\n   push i..j-1 one step right\\n\\ntime complexity\\n. get r: O(n^2)\\n. get swaps: O(n^2)\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minSwaps(self, grid):\\n        # convert grid to r\\n        n, r = len(grid), []\\n        for i in range(n):\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    r.append(j)\\n                    break\\n            else: r.append(-1)\\n\\n        # swap r\\n        swaps = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if r[j] <= i:\\n                    swaps += (j-i)\\n                    for k in range(j-1, i-1, -1): r[k+1] = r[k]\\n                    break\\n            else: return -1\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635751,
                "title": "java-swap-o-n2-time-o-n-space-solution",
                "content": "Explanation -\\n1. A valid solution matrix is such that for a row at index i, this row should contain **atleast** n - index - 1 continuos zeros from right side after swaps. There can be multiple such valid matrix and we need to find one with min number of swaps\\n2. Preprocessing Step - As mentioned above we only care about number of continous zeros from right side for each row. In this pre-processing step we compute this - Time complexity - O(n2) . Space Complexity - O(n)\\n3. Once we have this preprocessed array we need to swap entries in this array such that we have an array where entry at index i >= (n - i - 1). For this we can use a greedy approach (closest valid entry for a index) to find correct entry for a particular index and swap all values between current value & required value.\\n4. Answer is sum of all the swaps required for all index\\n\\n```\\nclass Solution \\n{\\n    public int minSwaps(int[][] grid) \\n    {\\n        int len = grid.length;\\n        int swap = 0;\\n        int[] preProcess = new int[len];\\n        for(int i = 0; i < len; i++)\\n        {\\n            preProcess[i] = countRightZeros(grid[i]);\\n        }\\n        for(int i = 0; i < len; i++)\\n        {\\n            int minValueRequired = len - i - 1;\\n            \\n            int j = i;\\n            while(j < len && preProcess[j] < minValueRequired)\\n            {\\n                j++;\\n            }\\n            \\n            if(j == len)\\n                return -1;\\n            \\n            while(j != i)\\n            {\\n                swap++;\\n                int temp = preProcess[j];\\n                preProcess[j] = preProcess[j-1];\\n                preProcess[j-1] = temp;\\n                j--;\\n            }\\n        }\\n        \\n        return swap;\\n    }\\n    \\n    private int countRightZeros(int[] row)\\n    {\\n        int cnt = 0;\\n        for(int i = row.length - 1; i >= 0; i--)\\n        {\\n            if(row[i] != 0)\\n                break;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minSwaps(int[][] grid) \\n    {\\n        int len = grid.length;\\n        int swap = 0;\\n        int[] preProcess = new int[len];\\n        for(int i = 0; i < len; i++)\\n        {\\n            preProcess[i] = countRightZeros(grid[i]);\\n        }\\n        for(int i = 0; i < len; i++)\\n        {\\n            int minValueRequired = len - i - 1;\\n            \\n            int j = i;\\n            while(j < len && preProcess[j] < minValueRequired)\\n            {\\n                j++;\\n            }\\n            \\n            if(j == len)\\n                return -1;\\n            \\n            while(j != i)\\n            {\\n                swap++;\\n                int temp = preProcess[j];\\n                preProcess[j] = preProcess[j-1];\\n                preProcess[j-1] = temp;\\n                j--;\\n            }\\n        }\\n        \\n        return swap;\\n    }\\n    \\n    private int countRightZeros(int[] row)\\n    {\\n        int cnt = 0;\\n        for(int i = row.length - 1; i >= 0; i--)\\n        {\\n            if(row[i] != 0)\\n                break;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556882,
                "title": "go",
                "content": "```\\nfunc minSwaps(grid [][]int) int {\\n    n := len(grid)\\n    var list []int\\n    for i := 0; i < n; i++ {\\n        cnt := 0\\n        for j := n - 1; j >= 0; j-- {\\n            if grid[i][j] == 0 {\\n                cnt++\\n            } else {\\n                break\\n            }\\n        }\\n        list = append(list, cnt)\\n    }\\n    res := 0\\n    LOOP:\\n    for i := 0; i < n; i++ {\\n        if list[i] >= n - 1 - i {\\n            continue\\n        } else {\\n            for j := i + 1; j < n; j++ {\\n                if list[j] >= n - 1 - i {\\n                    for k := j - 1; k >= i; k-- {\\n                        list[k], list[k + 1] = list[k + 1], list[k]\\n                        res++\\n                    }\\n                    continue LOOP\\n                }\\n            }\\n            return -1\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minSwaps(grid [][]int) int {\\n    n := len(grid)\\n    var list []int\\n    for i := 0; i < n; i++ {\\n        cnt := 0\\n        for j := n - 1; j >= 0; j-- {\\n            if grid[i][j] == 0 {\\n                cnt++\\n            } else {\\n                break\\n            }\\n        }\\n        list = append(list, cnt)\\n    }\\n    res := 0\\n    LOOP:\\n    for i := 0; i < n; i++ {\\n        if list[i] >= n - 1 - i {\\n            continue\\n        } else {\\n            for j := i + 1; j < n; j++ {\\n                if list[j] >= n - 1 - i {\\n                    for k := j - 1; k >= i; k-- {\\n                        list[k], list[k + 1] = list[k + 1], list[k]\\n                        res++\\n                    }\\n                    continue LOOP\\n                }\\n            }\\n            return -1\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1508193,
                "title": "c-o-n-2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void swap(vector<int>&index, int i, int j){\\n        int temp = index[i];\\n        index[i] = index[j];\\n        index[j] = temp;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int>index(n);\\n        int i, j, k, l;\\n        for(i = 0; i < n; i++){\\n            k = 0;\\n            for(j = n - 1; j >= 0; j--){\\n                if(grid[i][j] == 0){\\n                    k++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            index[i] = k;\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            j = n - 1 - i;\\n            for(k = i; k < n; k++){\\n                if(index[k] >= j){\\n                    break;\\n                }\\n            }\\n            if(k == n){\\n                return -1;\\n            }\\n            else{\\n                for(l = k; l > i; l--){\\n                    swap(index, l, l - 1);\\n                }\\n                ans += k - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void swap(vector<int>&index, int i, int j){\\n        int temp = index[i];\\n        index[i] = index[j];\\n        index[j] = temp;\\n    }\\n    \\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int>index(n);\\n        int i, j, k, l;\\n        for(i = 0; i < n; i++){\\n            k = 0;\\n            for(j = n - 1; j >= 0; j--){\\n                if(grid[i][j] == 0){\\n                    k++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            index[i] = k;\\n        }\\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            j = n - 1 - i;\\n            for(k = i; k < n; k++){\\n                if(index[k] >= j){\\n                    break;\\n                }\\n            }\\n            if(k == n){\\n                return -1;\\n            }\\n            else{\\n                for(l = k; l > i; l--){\\n                    swap(index, l, l - 1);\\n                }\\n                ans += k - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483615,
                "title": "short-c-solution-by-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), res;\\n        if(n<=1) return 0;   // Base Case\\n\\t\\t\\n        int m = grid[0].size();\\n        bool flag=true;\\n\\t\\t\\n        for(int i=0; i<n; i++)\\n\\t\\t{\\n            for(int j=m-1; j>m-n; j--)\\n                if(grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n                    flag=false;\\n                    break;\\n                }\\n            if(flag==true)\\n\\t\\t\\t{\\n                grid.erase(grid.begin()+i);\\n                res = minSwaps(grid);\\n                return (res+i>=i) ? i+res : -1;\\n            }\\n            flag=true;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size(), res;\\n        if(n<=1) return 0;   // Base Case\\n\\t\\t\\n        int m = grid[0].size();\\n        bool flag=true;\\n\\t\\t\\n        for(int i=0; i<n; i++)\\n\\t\\t{\\n            for(int j=m-1; j>m-n; j--)\\n                if(grid[i][j] == 1)\\n\\t\\t\\t\\t{\\n                    flag=false;\\n                    break;\\n                }\\n            if(flag==true)\\n\\t\\t\\t{\\n                grid.erase(grid.begin()+i);\\n                res = minSwaps(grid);\\n                return (res+i>=i) ? i+res : -1;\\n            }\\n            flag=true;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473577,
                "title": "python-greedy-without-actually-swap-the-array",
                "content": "Count trailing zeros for each row and build an array. For each element in the array, if it doesn\\'t satisfy its requirements, find the nearest element on its right which is good, and swap them. At the same time, plus the cost of swaps to the result. If no good element can\\'t be found, then return \"-1\".\\n\\nBy marking swapped element in the array as \"-1\" and tracking a variable \"shift\" ,we can avoid the cost of actually rearranging the element in the array after swapping. \\n\\nHere is my code:\\n\\'\\'\\'\\nclass Solution:\\n\\n\\tdef minSwaps(self, grid: List[List[int]]) -> int:\\t\\n        N = len(grid)\\n        def count_zeros(row):\\n            i = len(row) - 1\\n            while i >= 0 and not row[i]:\\n                i -= 1\\n            return len(row) - 1 - i\\n        \\n        # zeors[i] == -1 means it has been swapped\\n        zeros = [count_zeros(row) for row in grid]\\n        def find_nearest_alter(i, demand):\\n            cost = 0\\n            j = i\\n            while j < N and (zeros[j] < demand):\\n                # only count the number of elements which haven\\'t been swapped as a cost\\n                cost += (zeros[j] >= 0)\\n                j += 1\\n            return j, cost\\n        \\n        i = res = shift = 0\\n        while i + shift < N:\\n            # the ith element has been swapped.\\n            if zeros[i] < 0:\\n                i += 1\\n                shift -= 1\\n                continue\\n            \\n            # uses shift to calculate the actual number of cur row: (i + shift) and get the demand of it\\n            demand = N - (i + shift) - 1\\n            if zeros[i] < demand:\\n                j, cost = find_nearest_alter(i, demand)\\n                \\n                # return if the next good element can\\'t be found\\n                if j == N:\\n                    return -1\\n                \\n                # mark the jth element as swapped by changing its value to -1\\n                zeros[j] = -1\\n                res += cost\\n                shift += 1\\n            else:\\n                i += 1\\n        return res\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Count trailing zeros for each row and build an array. For each element in the array, if it doesn\\'t satisfy its requirements, find the nearest element on its right which is good, and swap them. At the same time, plus the cost of swaps to the result. If no good element can\\'t be found, then return \"-1\".\\n\\nBy marking swapped element in the array as \"-1\" and tracking a variable \"shift\" ,we can avoid the cost of actually rearranging the element in the array after swapping. \\n\\nHere is my code:\\n\\'\\'\\'\\nclass Solution:\\n\\n\\tdef minSwaps(self, grid: List[List[int]]) -> int:\\t\\n        N = len(grid)\\n        def count_zeros(row):\\n            i = len(row) - 1\\n            while i >= 0 and not row[i]:\\n                i -= 1\\n            return len(row) - 1 - i\\n        \\n        # zeors[i] == -1 means it has been swapped\\n        zeros = [count_zeros(row) for row in grid]\\n        def find_nearest_alter(i, demand):\\n            cost = 0\\n            j = i\\n            while j < N and (zeros[j] < demand):\\n                # only count the number of elements which haven\\'t been swapped as a cost\\n                cost += (zeros[j] >= 0)\\n                j += 1\\n            return j, cost\\n        \\n        i = res = shift = 0\\n        while i + shift < N:\\n            # the ith element has been swapped.\\n            if zeros[i] < 0:\\n                i += 1\\n                shift -= 1\\n                continue\\n            \\n            # uses shift to calculate the actual number of cur row: (i + shift) and get the demand of it\\n            demand = N - (i + shift) - 1\\n            if zeros[i] < demand:\\n                j, cost = find_nearest_alter(i, demand)\\n                \\n                # return if the next good element can\\'t be found\\n                if j == N:\\n                    return -1\\n                \\n                # mark the jth element as swapped by changing its value to -1\\n                zeros[j] = -1\\n                res += cost\\n                shift += 1\\n            else:\\n                i += 1\\n        return res\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1455050,
                "title": "o-n-2-java-solution",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int []arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                }\\n                arr[i]++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            boolean notfound = true;\\n            for (int j = 0; j < n; j++) {\\n                if (set.contains(j)) {\\n                    continue;\\n                }\\n                if (arr[j] >= i) {\\n                    set.add(j);\\n                    notfound = false;\\n                    break;\\n                } else {\\n                    sum++;\\n                }\\n            }\\n            if (notfound) {\\n                return -1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int []arr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                }\\n                arr[i]++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            boolean notfound = true;\\n            for (int j = 0; j < n; j++) {\\n                if (set.contains(j)) {\\n                    continue;\\n                }\\n                if (arr[j] >= i) {\\n                    set.add(j);\\n                    notfound = false;\\n                    break;\\n                } else {\\n                    sum++;\\n                }\\n            }\\n            if (notfound) {\\n                return -1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399169,
                "title": "java-bubble-sort-hashset-o-n2-time-o-n-space-soution",
                "content": "```\\n// using bubble sort to count no of swaps\\nclass Solution {\\n\\n    public int minSwaps(int[][] grid) {\\n        int res = 0;\\n        \\n        int n = grid.length;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        // fill the array with no of trailing zeroes in each row\\n        int[] arr = new int[n];        \\n        \\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            int j = n-1;\\n            \\n            while(j >= 0 && grid[i][j--] == 0) count++;\\n            \\n            \\n            // if the number of trailing zeroes is greater than required then \\n            // cut down the zeroes to required only\\n            if (set.contains(count)) {\\n                while (set.contains(count)) {\\n                    count--;\\n                }\\n            }\\n            if (count < 0) continue;\\n            set.add(count);\\n            arr[i] = count;\\n        }\\n        \\n        // the set should now contain count of zeroes from 0 to n - 1 else \\n        // solution is not possible\\n        \\n        if(set.size() != n) return -1;\\n\\n        // bubble sort\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = 0; j < n - i - 1; j++) {\\n                if (arr[j + 1] > arr[j]) {\\n                    res++;\\n                    // swap arr[j+1] and arr[j]\\n                    int temp = arr[j];\\n                    arr[j] = arr[j+1];\\n                    arr[j+1] = temp;                    \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// using bubble sort to count no of swaps\\nclass Solution {\\n\\n    public int minSwaps(int[][] grid) {\\n        int res = 0;\\n        \\n        int n = grid.length;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        // fill the array with no of trailing zeroes in each row\\n        int[] arr = new int[n];        \\n        \\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            int j = n-1;\\n            \\n            while(j >= 0 && grid[i][j--] == 0) count++;\\n            \\n            \\n            // if the number of trailing zeroes is greater than required then \\n            // cut down the zeroes to required only\\n            if (set.contains(count)) {\\n                while (set.contains(count)) {\\n                    count--;\\n                }\\n            }\\n            if (count < 0) continue;\\n            set.add(count);\\n            arr[i] = count;\\n        }\\n        \\n        // the set should now contain count of zeroes from 0 to n - 1 else \\n        // solution is not possible\\n        \\n        if(set.size() != n) return -1;\\n\\n        // bubble sort\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = 0; j < n - i - 1; j++) {\\n                if (arr[j + 1] > arr[j]) {\\n                    res++;\\n                    // swap arr[j+1] and arr[j]\\n                    int temp = arr[j];\\n                    arr[j] = arr[j+1];\\n                    arr[j+1] = temp;                    \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324765,
                "title": "java-1ms-100-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minSwaps(int[][] grid) {\\n\\t\\t\\tint n=grid.length,count[]=new int[n],minSwaps=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int j=n-1;j>=0 && grid[i][j]==0;j--)    cnt++;\\n\\t\\t\\t\\tcount[i]=cnt;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n && minSwaps!=-1;i++){\\n\\t\\t\\t\\tif(count[i]<n-i-1){\\n\\t\\t\\t\\t\\tint j=i;\\n\\t\\t\\t\\t\\twhile(j<n && count[j]<n-i-1)    j++;\\n\\t\\t\\t\\t\\tif(j<n && count[j]>=n-i-1){\\n\\t\\t\\t\\t\\t\\twhile(j>i){\\n\\t\\t\\t\\t\\t\\t\\tswap(count,j--);\\n\\t\\t\\t\\t\\t\\t\\tminSwaps++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse minSwaps=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn minSwaps;\\n\\t\\t}\\n\\t\\tprivate void swap(int count[],int j){\\n\\t\\t\\tint t=count[j-1];\\n\\t\\t\\tcount[j-1]=count[j];\\n\\t\\t\\tcount[j--]=t;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minSwaps(int[][] grid) {\\n\\t\\t\\tint n=grid.length,count[]=new int[n],minSwaps=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int j=n-1;j>=0 && grid[i][j]==0;j--)    cnt++;\\n\\t\\t\\t\\tcount[i]=cnt;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1324019,
                "title": "c-easy-solution-100-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int ans=0;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            int total=0;\\n            for(int j=grid.size()-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    total++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            vec.push_back({i,total});\\n        }\\n        for(int t=grid.size()-1;t>0;t--)\\n        {\\n            bool u=false;\\n            for(int j=0;j<vec.size();j++)\\n            {\\n                if(vec[j].second >= t)\\n                {\\n                    u=true;\\n                    ans+=(vec[j].first - vec[0].first);\\n                    for(int k=0;k<j;k++)\\n                    {\\n                        vec[k].first+=1;\\n                    }\\n                    vec.erase(vec.begin()+j);\\n                    break;\\n                }\\n            }\\n            if(u==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int ans=0;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            int total=0;\\n            for(int j=grid.size()-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    total++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            vec.push_back({i,total});\\n        }\\n        for(int t=grid.size()-1;t>0;t--)\\n        {\\n            bool u=false;\\n            for(int j=0;j<vec.size();j++)\\n            {\\n                if(vec[j].second >= t)\\n                {\\n                    u=true;\\n                    ans+=(vec[j].first - vec[0].first);\\n                    for(int k=0;k<j;k++)\\n                    {\\n                        vec[k].first+=1;\\n                    }\\n                    vec.erase(vec.begin()+j);\\n                    break;\\n                }\\n            }\\n            if(u==false)\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280008,
                "title": "bubble-sort-javascript-solution-76-ms",
                "content": "```\\nvar minSwaps = function(grid) {\\n    const n = grid.length;\\n    const lastIndex = n - 1;\\n    const mostRight = new Array(n);\\n    let result = 0;\\n    let tmp;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        for (let j = lastIndex; j >= 0; --j) {\\n            if (grid[i][j] === 1) {\\n                mostRight[i] = j;\\n                break;\\n            }\\n        }\\n        if (mostRight[i] === undefined) mostRight[i] = -1;\\n    }\\n    \\n    for (let i = 0; i < lastIndex; ++i) {\\n        if (mostRight[i] <= i) continue;\\n        \\n        for (let j = i + 1; j < n; ++j) {\\n            if (mostRight[j] <= i) {\\n                while (j !== i) {\\n                    tmp = mostRight[j];\\n                    mostRight[j] = mostRight[j - 1];\\n                    mostRight[j - 1] = tmp;\\n                    ++result;\\n                    --j;\\n                }\\n                break;\\n            }\\n            if (j === lastIndex) return -1;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minSwaps = function(grid) {\\n    const n = grid.length;\\n    const lastIndex = n - 1;\\n    const mostRight = new Array(n);\\n    let result = 0;\\n    let tmp;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        for (let j = lastIndex; j >= 0; --j) {\\n            if (grid[i][j] === 1) {\\n                mostRight[i] = j;\\n                break;\\n            }\\n        }\\n        if (mostRight[i] === undefined) mostRight[i] = -1;\\n    }\\n    \\n    for (let i = 0; i < lastIndex; ++i) {\\n        if (mostRight[i] <= i) continue;\\n        \\n        for (let j = i + 1; j < n; ++j) {\\n            if (mostRight[j] <= i) {\\n                while (j !== i) {\\n                    tmp = mostRight[j];\\n                    mostRight[j] = mostRight[j - 1];\\n                    mostRight[j - 1] = tmp;\\n                    ++result;\\n                    --j;\\n                }\\n                break;\\n            }\\n            if (j === lastIndex) return -1;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248647,
                "title": "javascript-greedy",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minSwaps = function(grid) {\\n    const nums = grid.map(row => row.lastIndexOf(1))\\n    const len = nums.length\\n    \\n    \\n    let result = 0\\n    for (let fromIndex = 0; fromIndex < len; fromIndex++) {\\n        let bestIndex = -1\\n        let bestVal = Infinity\\n        \\n        for (let i = fromIndex; i < len; i++) {\\n            const val = nums[i]\\n            if (val <= fromIndex) {\\n                bestIndex = i\\n                bestVal = val\\n                break\\n            }\\n        }\\n        if (bestIndex === -1)   return -1\\n        \\n        for (let i = bestIndex; i > fromIndex; i--) {\\n            nums[i] = nums[-1 + i]\\n        }\\n        nums[fromIndex] = bestVal\\n\\n        result += bestIndex - fromIndex\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minSwaps = function(grid) {\\n    const nums = grid.map(row => row.lastIndexOf(1))\\n    const len = nums.length\\n    \\n    \\n    let result = 0\\n    for (let fromIndex = 0; fromIndex < len; fromIndex++) {\\n        let bestIndex = -1\\n        let bestVal = Infinity\\n        \\n        for (let i = fromIndex; i < len; i++) {\\n            const val = nums[i]\\n            if (val <= fromIndex) {\\n                bestIndex = i\\n                bestVal = val\\n                break\\n            }\\n        }\\n        if (bestIndex === -1)   return -1\\n        \\n        for (let i = bestIndex; i > fromIndex; i--) {\\n            nums[i] = nums[-1 + i]\\n        }\\n        nums[fromIndex] = bestVal\\n\\n        result += bestIndex - fromIndex\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248181,
                "title": "c-approach",
                "content": "since this is **good and standard question** ,,  dry run please \\n\\none thing i expect from you is at first sight you will see the final ans where you found out that every row will have fixed number of zeros for valid test case.\\nso your work is to replace all the grid at their best position .. \\nso , for that you must have to know that at any index total zeros count required here is at which grid .. once you store this .. now\\nyou just have to bring that grid at their best position .. \\n*key point*: in this process those grid which should have to be in upper grid they will reaching at their grid ... a valid test case will always push rest grid at their position \\nyour work is to swap current grid to respective place ,rest will replaced auto.\\ni\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        // ios_base::sync_with_stdio(false);\\n        // cin.tie(NULL);\\n        // cout.tie(NULL);\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> vect;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=m-1;j>=0;j--){\\n                if(grid[i][j]==0){\\n                    count++;\\n                }\\n                else{\\n                    vect.push_back(count);\\n                    break;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        n=vect.size();\\n        for (int i=0; i<n; i++) {\\n            //check that if vect[i] is at right position or it should go down \\n            //a good valid test case will always arrange itself because when you finding right place\\n            //to place that index you will find or not .will indicate you vaid test case or not\\n            // we have to just swap\\n            if (vect[i] < (n-i-1)) {\\n                int k=i;\\n                while (k < n && vect[k] < (n-i-1)) {\\n                    k++;\\n                }\\n\\t\\t\\t\\t//here if we didn\\'t find valid position then swapping means nothing at the end.\\n                if (k == n) {     \\n                    return -1;  \\n                }\\n                while (k>i) {\\n                    swap(vect[k], vect[k-1]);\\n                    ans++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        // ios_base::sync_with_stdio(false);\\n        // cin.tie(NULL);\\n        // cout.tie(NULL);\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> vect;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=m-1;j>=0;j--){\\n                if(grid[i][j]==0){\\n                    count++;\\n                }\\n                else{\\n                    vect.push_back(count);\\n                    break;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        n=vect.size();\\n        for (int i=0; i<n; i++) {\\n            //check that if vect[i] is at right position or it should go down \\n            //a good valid test case will always arrange itself because when you finding right place\\n            //to place that index you will find or not .will indicate you vaid test case or not\\n            // we have to just swap\\n            if (vect[i] < (n-i-1)) {\\n                int k=i;\\n                while (k < n && vect[k] < (n-i-1)) {\\n                    k++;\\n                }\\n\\t\\t\\t\\t//here if we didn\\'t find valid position then swapping means nothing at the end.\\n                if (k == n) {     \\n                    return -1;  \\n                }\\n                while (k>i) {\\n                    swap(vect[k], vect[k-1]);\\n                    ans++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1236145,
                "title": "swift-solution-bubble-sort",
                "content": "Solution explained in comments\\n```\\nclass Solution {\\n    func minSwaps(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        var result = 0\\n        // For each row of the grid calculate the most right 1 in the grid in the array maxRight\\n        var maxRight = grid.reduce(into: [Int](), { $0.append($1.lastIndex(where: { $0 == 1 }) ?? 0) })\\n        // To check if there exist answer, sort maxRight and check if maxRight[i] \\u2264 i for all possible i\\'s\\n        for (i, v) in Array(0..<n).sorted(by: { maxRight[$0] < maxRight[$1] }).enumerated() where maxRight[v] > i {\\n            return -1\\n        }\\n        // An answer exists, let\\'s simulate the swaps using bubble sort\\n        forrow1: for row1 in 0..<(n - 1) where maxRight[row1] > row1 { // for all rows that requires swap\\n            for row2 in (row1 + 1)..<n where maxRight[row2] <= row1 { // find nearest suitable row\\n                for row in stride(from: row2, to: row1, by: -1) { // apply swaps (bubble pops up)\\n                    maxRight.swapAt(row, row - 1)\\n                    result += 1\\n                }\\n                continue forrow1 // proceed next row\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minSwaps(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        var result = 0\\n        // For each row of the grid calculate the most right 1 in the grid in the array maxRight\\n        var maxRight = grid.reduce(into: [Int](), { $0.append($1.lastIndex(where: { $0 == 1 }) ?? 0) })\\n        // To check if there exist answer, sort maxRight and check if maxRight[i] \\u2264 i for all possible i\\'s\\n        for (i, v) in Array(0..<n).sorted(by: { maxRight[$0] < maxRight[$1] }).enumerated() where maxRight[v] > i {\\n            return -1\\n        }\\n        // An answer exists, let\\'s simulate the swaps using bubble sort\\n        forrow1: for row1 in 0..<(n - 1) where maxRight[row1] > row1 { // for all rows that requires swap\\n            for row2 in (row1 + 1)..<n where maxRight[row2] <= row1 { // find nearest suitable row\\n                for row in stride(from: row2, to: row1, by: -1) { // apply swaps (bubble pops up)\\n                    maxRight.swapAt(row, row - 1)\\n                    result += 1\\n                }\\n                continue forrow1 // proceed next row\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194951,
                "title": "c-brutal-force",
                "content": "* We can figure out that for ith row, the index of last 1 has to be <= i. So we rearrange the rows and check which one should be the 1st, 2nd, ... up to the end.\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int size = grid.size(), res = 0;\\n        for (int i = 0; i < size; ++i)\\n        {\\n            int j = i;\\n            while (j < size)\\n            {\\n                int k = size - 1;\\n                while (k >= 0 && grid[j][k] == 0)\\n                {\\n                    --k;\\n                }\\n                \\n                if (k <= i)\\n                {\\n                    res += j - i;\\n                    for (int r = j; r > i; --r)\\n                    {\\n                        swap(grid[r], grid[r - 1]);\\n                    }\\n                    \\n                    break;\\n                }\\n                \\n                ++j;\\n            }\\n            \\n            if (j >= size)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int size = grid.size(), res = 0;\\n        for (int i = 0; i < size; ++i)\\n        {\\n            int j = i;\\n            while (j < size)\\n            {\\n                int k = size - 1;\\n                while (k >= 0 && grid[j][k] == 0)\\n                {\\n                    --k;\\n                }\\n                \\n                if (k <= i)\\n                {\\n                    res += j - i;\\n                    for (int r = j; r > i; --r)\\n                    {\\n                        swap(grid[r], grid[r - 1]);\\n                    }\\n                    \\n                    break;\\n                }\\n                \\n                ++j;\\n            }\\n            \\n            if (j >= size)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182836,
                "title": "two-indices-90-speed",
                "content": "Runtime: 504 ms, faster than 90.43% of Python3 online submissions for Minimum Swaps to Arrange a Binary Grid.\\nMemory Usage: 15.4 MB, less than 58.26% of Python3 online submissions for Minimum Swaps to Arrange a Binary Grid.\\n```\\nclass Solution:\\n    def minSwaps(self, grid) -> int:\\n        n = len(grid)\\n        max_right = [-1] * n\\n        for r, row in enumerate(grid):\\n            for c in range(n - 1, -1, -1):\\n                if row[c] == 1:\\n                    max_right[r] = c\\n                    break\\n        if all(v <= i for i, v in enumerate(sorted(max_right))):\\n            swaps = 0\\n            i = 0\\n            while i < n:\\n                while i < n and max_right[i] <= i:\\n                    i += 1\\n                if i == n:\\n                    break\\n                j = i\\n                while j < n and max_right[j] > i:\\n                    j += 1\\n                swaps += j - i\\n                max_right[i], max_right[i + 1: j + 1] = (max_right[j],\\n                                                         max_right[i: j])\\n                i += 1\\n            return swaps\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid) -> int:\\n        n = len(grid)\\n        max_right = [-1] * n\\n        for r, row in enumerate(grid):\\n            for c in range(n - 1, -1, -1):\\n                if row[c] == 1:\\n                    max_right[r] = c\\n                    break\\n        if all(v <= i for i, v in enumerate(sorted(max_right))):\\n            swaps = 0\\n            i = 0\\n            while i < n:\\n                while i < n and max_right[i] <= i:\\n                    i += 1\\n                if i == n:\\n                    break\\n                j = i\\n                while j < n and max_right[j] > i:\\n                    j += 1\\n                swaps += j - i\\n                max_right[i], max_right[i + 1: j + 1] = (max_right[j],\\n                                                         max_right[i: j])\\n                i += 1\\n            return swaps\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180631,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> a;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(grid[i][n - 1] == 0) {\\n                int j = n - 1;\\n                count++;\\n                while(j > 0 && grid[i][j] == grid[i][j - 1]) {\\n                    j--;\\n                    count++;\\n                }\\n            }\\n            a.emplace_back(count);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(a[i] < n - i - 1) {\\n                int pos = -1;\\n                for(int j = i + 1; j < n; j++) {\\n                    if(a[j] >= n - 1 - i) {\\n                        pos = j;\\n                        break;\\n                    }\\n                }\\n                if(pos == -1) {\\n                    return -1;\\n                }\\n                int val = a[pos];\\n                while(pos > i) {\\n                    a[pos] = a[pos - 1];\\n                    pos--;\\n                    ans++;\\n                }\\n                a[i] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<int> a;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(grid[i][n - 1] == 0) {\\n                int j = n - 1;\\n                count++;\\n                while(j > 0 && grid[i][j] == grid[i][j - 1]) {\\n                    j--;\\n                    count++;\\n                }\\n            }\\n            a.emplace_back(count);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(a[i] < n - i - 1) {\\n                int pos = -1;\\n                for(int j = i + 1; j < n; j++) {\\n                    if(a[j] >= n - 1 - i) {\\n                        pos = j;\\n                        break;\\n                    }\\n                }\\n                if(pos == -1) {\\n                    return -1;\\n                }\\n                int val = a[pos];\\n                while(pos > i) {\\n                    a[pos] = a[pos - 1];\\n                    pos--;\\n                    ans++;\\n                }\\n                a[i] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139339,
                "title": "python-3-bubble-sort-o-n-2",
                "content": "Similar algorithm as bubble sort. Search for the first valid row and move it to the top, and repeat the process.\\n```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if grid[i][j] != 0:\\n                    break\\n            else:\\n                continue\\n            for k in range(i+1, n):\\n                if grid[k][i+1:] == [0] * (n-i-1):\\n                    ans += (k-i)\\n                    grid[i:k+1] = grid[k:k+1] + grid[i:k]  \\n                    break\\n            else:\\n                return -1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if grid[i][j] != 0:\\n                    break\\n            else:\\n                continue\\n            for k in range(i+1, n):\\n                if grid[k][i+1:] == [0] * (n-i-1):\\n                    ans += (k-i)\\n                    grid[i:k+1] = grid[k:k+1] + grid[i:k]  \\n                    break\\n            else:\\n                return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096785,
                "title": "java-solution-with-arraylist",
                "content": "\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        List<Integer> l = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = grid[i].length-1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    l.add(j);\\n                    break;\\n                }\\n            }\\n            if (l.size() < i+1) l.add(0);\\n        }\\n        \\n        int res = 0;\\n        // System.out.println(l);\\n        for (int i = 0; i < l.size(); i++) {\\n            if (l.get(i) <= i) continue;\\n            int k = -1;\\n            for (int j = i + 1; j < l.size(); j++) {\\n                if (l.get(j) <= i) {\\n                    k = j;\\n                    break;\\n                }\\n            }\\n            if (k == -1) return -1;\\n            int v = l.remove(k);\\n            l.add(0, v);\\n            // System.out.println(l);\\n            res += k - i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        List<Integer> l = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = grid[i].length-1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    l.add(j);\\n                    break;\\n                }\\n            }\\n            if (l.size() < i+1) l.add(0);\\n        }\\n        \\n        int res = 0;\\n        // System.out.println(l);\\n        for (int i = 0; i < l.size(); i++) {\\n            if (l.get(i) <= i) continue;\\n            int k = -1;\\n            for (int j = i + 1; j < l.size(); j++) {\\n                if (l.get(j) <= i) {\\n                    k = j;\\n                    break;\\n                }\\n            }\\n            if (k == -1) return -1;\\n            int v = l.remove(k);\\n            l.add(0, v);\\n            // System.out.println(l);\\n            res += k - i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026690,
                "title": "python-greedy-o-n-2",
                "content": "First, count the number of trailing 0s for each row as zeros.\\nSecond, for i-th row, which needs n - i - 1 trailing 0s, just find the nearest j that j >= i and zeros[j] >= n - i - 1, then the swap operation needed is j - i - 1, so that j-th row move forward to i-th row. If deque is applied to zeros, then zeros denotes the rows not used. for i-th row, find the nearest j that zeros[j] >= n - i - 1, then the swap operation needed is j. Then pop j-th since it is used.\\n```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        zeros = []\\n        need = n - 1\\n        ans = 0\\n        for i in range(n):\\n            cur_zeros = n\\n            for j in range(n - 1, -1, -1):\\n                if grid[i][j] == 1:\\n                    cur_zeros = n - j - 1\\n                    break\\n            zeros.append(cur_zeros)\\n        while zeros:\\n            for i in range(len(zeros)):\\n                if zeros[i] >= need:\\n                    need -= 1\\n                    break\\n            else:\\n                return -1\\n            ans += i\\n            zeros.pop(i)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        zeros = []\\n        need = n - 1\\n        ans = 0\\n        for i in range(n):\\n            cur_zeros = n\\n            for j in range(n - 1, -1, -1):\\n                if grid[i][j] == 1:\\n                    cur_zeros = n - j - 1\\n                    break\\n            zeros.append(cur_zeros)\\n        while zeros:\\n            for i in range(len(zeros)):\\n                if zeros[i] >= need:\\n                    need -= 1\\n                    break\\n            else:\\n                return -1\\n            ans += i\\n            zeros.pop(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024982,
                "title": "java-greedy",
                "content": "LinkedList should be used but arraylist is faster somehow\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int rows = grid.length;\\n        List<Integer> l = new ArrayList();\\n        for(int i=0; i<rows; i++)\\n            l.add(getTrailZeros(grid, i));\\n        int res = 0;\\n        while(l.size()>1){\\n            int expect = l.size()-1;\\n            if(l.get(0)>=expect){\\n                l.remove(0);\\n                continue;\\n            }\\n            for(int j=1; j<l.size(); j++){\\n                if(l.get(j)>=expect){\\n                    res += j;\\n                    l.remove(j);\\n                    break;\\n                }\\n            }\\n            if(l.size() == expect+1)\\n                return -1;\\n        }\\n        return res;\\n    }\\n    public int getTrailZeros(int[][] grid, int idx){\\n        int len = grid.length;\\n        int cnt = 0;\\n        for(int i=len-1; i>=0; i--){\\n            if(grid[idx][i] == 0)\\n                cnt++;\\n            else\\n                break;\\n        }\\n        return cnt;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSwaps(int[][] grid) {\\n        int rows = grid.length;\\n        List<Integer> l = new ArrayList();\\n        for(int i=0; i<rows; i++)\\n            l.add(getTrailZeros(grid, i));\\n        int res = 0;\\n        while(l.size()>1){\\n            int expect = l.size()-1;\\n            if(l.get(0)>=expect){\\n                l.remove(0);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1014602,
                "title": "c-100-100",
                "content": "class Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& v)\\n    {\\n        int n=v.size();\\n        //int m=v[0].size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n            dp[i]=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {  \\n            int x=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(v[i][j]==1)\\n                {\\n                    x=j;\\n                    break;\\n                }\\n            }\\n            int t=0;\\n            while(x+t<n && dp[x+t]!=-1)\\n                t++;\\n            \\n            if(x+t==n)\\n                return -1;\\n            else\\n                dp[x+t]=i;\\n        }\\n        int ans=0;\\n        for(int j=0;j<n;j++)\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(dp[i]>dp[i+1])\\n                {swap(dp[i],dp[i+1]);\\n                    ans++;}\\n                \\n            }\\n        \\n       for(int i=0;i<n;i++)\\n            cout<<dp[i]<<\" \";\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& v)\\n    {\\n        int n=v.size();\\n        //int m=v[0].size();\\n        int dp[n];\\n        for(int i=0;i<n;i++)\\n            dp[i]=-1;\\n        \\n        for(int i=0;i<n;i++)\\n        {  \\n            int x=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(v[i][j]==1)\\n                {\\n                    x=j;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1004162,
                "title": "c-short-solution",
                "content": "Run-time is `O(N^2)`, space is `O(N)`. Idea is to greedily pick the closest row that works (has enough trailing zeros). Implementation using a list is slightly faster (do not need a second pass to shift elements to the right after removing the target row). But the run-time using a vector implementation will still be `O(N^2)`. \\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        std::list<int> rows;\\n        int size{(int)grid.size()};\\n        for(const auto &r: grid) {\\n            int i{size-1}, count{0};\\n            while(i >= 0 && r[i] == 0) ++count, --i;\\n            rows.emplace_back(count);\\n        }\\n        \\n        int cost{0};\\n        for(int i{size-1}; i > 0; --i) {\\n            int l{0};\\n            for(auto it{rows.begin()}; it != rows.end(); ++it, ++l) {\\n                if(*it >= i) {\\n                    cost += l, rows.erase(it);\\n                    goto next;\\n                }\\n            }\\n            \\n            return -1;\\n            \\n            next:\\n            continue;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        std::list<int> rows;\\n        int size{(int)grid.size()};\\n        for(const auto &r: grid) {\\n            int i{size-1}, count{0};\\n            while(i >= 0 && r[i] == 0) ++count, --i;\\n            rows.emplace_back(count);\\n        }\\n        \\n        int cost{0};\\n        for(int i{size-1}; i > 0; --i) {\\n            int l{0};\\n            for(auto it{rows.begin()}; it != rows.end(); ++it, ++l) {\\n                if(*it >= i) {\\n                    cost += l, rows.erase(it);\\n                    goto next;\\n                }\\n            }\\n            \\n            return -1;\\n            \\n            next:\\n            continue;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993046,
                "title": "java-greedy-77",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        //strategy: Greedy\\n        int n = grid.length, answer = 0;\\n        //calculate the length of the trailing zeroes\\n        ArrayList<Integer> trailing = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            int count = 0;\\n            //go from the back until we reach a one\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            //add to ArrayList\\n            trailing.add(count);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            //this is the needed amt to curr row valid\\n            int needed = n - i - 1;\\n            boolean flag = false;\\n            //only needed to check ith row onwards because we already set up the first ith rows\\n            for (int j = i; j < n; j++) {\\n                //find the closest row\\n                if (trailing.get(j) >= needed) {\\n                    //add to swaps\\n                    answer += j - i;\\n                    //simulate swaps\\n                    trailing.add(i, trailing.remove(j));\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            //didn\\'t find it\\n            if (!flag) {\\n                return -1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        //strategy: Greedy\\n        int n = grid.length, answer = 0;\\n        //calculate the length of the trailing zeroes\\n        ArrayList<Integer> trailing = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            int count = 0;\\n            //go from the back until we reach a one\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1) {\\n                    break;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            //add to ArrayList\\n            trailing.add(count);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            //this is the needed amt to curr row valid\\n            int needed = n - i - 1;\\n            boolean flag = false;\\n            //only needed to check ith row onwards because we already set up the first ith rows\\n            for (int j = i; j < n; j++) {\\n                //find the closest row\\n                if (trailing.get(j) >= needed) {\\n                    //add to swaps\\n                    answer += j - i;\\n                    //simulate swaps\\n                    trailing.add(i, trailing.remove(j));\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            //didn\\'t find it\\n            if (!flag) {\\n                return -1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982817,
                "title": "java-greedy-approach-using-list-of-trailing-zeros",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n\\n        int swaps = 0;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int[] arr : grid) {\\n            list.add(trailingZeros(arr));\\n        }\\n        // For the first level we are expecting at least n-1 zeros, so start with that\\n\\t\\t// Iterate through the list, once an index matches where we have at least expected amount use it and delete\\n        // Since we are using a greedy approach, first selection would give the best outcome\\n\\t\\tfor(int i = grid.length - 1; i > 0; i--) {\\n            boolean found = false;\\n            for(int j = 0; j < list.size(); j++) {\\n                if(list.get(j) >= i) {\\n                    swaps += j;\\n                    list.remove(j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found) return -1;\\n        }\\n        \\n        return swaps;\\n    }\\n    private int trailingZeros(int[] grid) {\\n        int count = 0;\\n        for(int j = grid.length - 1; j >= 0; j--) {\\n            if(grid[j] == 0) {\\n                count++;\\n            } else break;\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n\\n        int swaps = 0;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int[] arr : grid) {\\n            list.add(trailingZeros(arr));\\n        }\\n        // For the first level we are expecting at least n-1 zeros, so start with that\\n\\t\\t// Iterate through the list, once an index matches where we have at least expected amount use it and delete\\n        // Since we are using a greedy approach, first selection would give the best outcome\\n\\t\\tfor(int i = grid.length - 1; i > 0; i--) {\\n            boolean found = false;\\n            for(int j = 0; j < list.size(); j++) {\\n                if(list.get(j) >= i) {\\n                    swaps += j;\\n                    list.remove(j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found) return -1;\\n        }\\n        \\n        return swaps;\\n    }\\n    private int trailingZeros(int[] grid) {\\n        int count = 0;\\n        for(int j = grid.length - 1; j >= 0; j--) {\\n            if(grid[j] == 0) {\\n                count++;\\n            } else break;\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979200,
                "title": "python-linked-list-version",
                "content": "- The idea is greedy (same as most of other posts). \\n- For implementation, I used a linkedlist here. No significant improvement or disadvantage here. passed with \"faster than 70%\"\\n```\\nclass Node:\\n    def __init__(self, val = 0, nxt = None):\\n        self.val = val\\n        self.nxt = nxt\\n\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        # convert to array\\n        head = Node()\\n        p = head\\n        for row in grid:\\n            for i in range(len(row)-1,-1,-1):\\n                if row[i] == 1: break\\n            p.nxt = Node(len(row)-1-i)\\n            p = p.nxt\\n        \\n        # find target one by one\\n        res = 0\\n        targets = list(range(len(grid)-1,-1,-1))\\n        for t in targets:\\n            q, p = head, head.nxt\\n            while p and p.val < t:\\n                p = p.nxt\\n                q = q.nxt\\n                res += 1\\n            if not p:\\n                return -1\\n            q.nxt = p.nxt\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, val = 0, nxt = None):\\n        self.val = val\\n        self.nxt = nxt\\n\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        # convert to array\\n        head = Node()\\n        p = head\\n        for row in grid:\\n            for i in range(len(row)-1,-1,-1):\\n                if row[i] == 1: break\\n            p.nxt = Node(len(row)-1-i)\\n            p = p.nxt\\n        \\n        # find target one by one\\n        res = 0\\n        targets = list(range(len(grid)-1,-1,-1))\\n        for t in targets:\\n            q, p = head, head.nxt\\n            while p and p.val < t:\\n                p = p.nxt\\n                q = q.nxt\\n                res += 1\\n            if not p:\\n                return -1\\n            q.nxt = p.nxt\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956039,
                "title": "java",
                "content": "Replace each rows first entry with count of consecutive zeroes at end of row\\nNow for a row i, it must have coutnConsecZeroes >= n-row-1\\nFor examplt at row 0, must have n-0-1 consec zeroes at first row\\nNow for a current row, go down and as soon as we find grid[r ][0] >= n-row-1, for all r>row and  r<n\\nNow if r>=n , not able to find approiate row for currentRow, then return -1\\nelse perform (r-currRow) swaps as thses many will make r row to swap current\\nAlso push down values from currentRow to r\\n7\\n6\\n4\\n3\\n1\\n5\\n6 \\nNow after swap 6(last) with 7\\n6\\n7\\n6\\n4\\n3\\n1\\n5\\nThis work because we go from top to down so if the first row down works for currentRow, then if some greater ele row is prsent it can take the smaller ones",
                "solutionTags": [],
                "code": "Replace each rows first entry with count of consecutive zeroes at end of row\\nNow for a row i, it must have coutnConsecZeroes >= n-row-1\\nFor examplt at row 0, must have n-0-1 consec zeroes at first row\\nNow for a current row, go down and as soon as we find grid[r ][0] >= n-row-1, for all r>row and  r<n\\nNow if r>=n , not able to find approiate row for currentRow, then return -1\\nelse perform (r-currRow) swaps as thses many will make r row to swap current\\nAlso push down values from currentRow to r\\n7\\n6\\n4\\n3\\n1\\n5\\n6 \\nNow after swap 6(last) with 7\\n6\\n7\\n6\\n4\\n3\\n1\\n5\\nThis work because we go from top to down so if the first row down works for currentRow, then if some greater ele row is prsent it can take the smaller ones",
                "codeTag": "C++"
            },
            {
                "id": 937289,
                "title": "c-greedy-list",
                "content": "class Solution {\\npublic:\\n    \\n\\tint minSwaps(vector<vector<int>>& grid) {\\n        ListNode root;\\n        ListNode *cur = &root;\\n        int n = grid.size();\\n        for (int i=0; i<n; ++i) {\\n            int zeroCnt = 0;\\n            for (int j=n-1; j>=1; j--) {\\n                if (grid[i][j]!=0) break;\\n                zeroCnt++;\\n            }\\n            cur->next = new ListNode(zeroCnt);\\n            cur = cur->next;\\n        }\\n        cur = root.next;\\n        int rowIdx = 0;\\n        int ans = 0;\\n        while (cur && rowIdx<n) {\\n            int targetCnt = n - 1 - rowIdx++;\\n            ListNode* tn = cur;\\n            ListNode* pre = NULL;\\n            int swapCnt = 0;\\n            // greedy to find the nearest available targetCnt\\n            while (tn && tn->val < targetCnt) {\\n                pre = tn;\\n                tn = tn->next;\\n                swapCnt++;\\n            }\\n            // return -1 if no valid found\\n            if (!tn) return -1;\\n            // add the swapCnt\\n            ans += swapCnt;\\n            // Adjust the list after swap\\n            // Basically, it could be regarded as the targetCnt node\\n            // is removed from the original position\\n            // c     tn\\n            // 4->3->5->2->1\\n            // <After sdjacent wap process>\\n            // tn c\\n            // 5->4->3->2->1\\n            if (!pre) {\\n                cur = cur->next;\\n            } else {\\n                pre->next = tn->next;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\tint minSwaps(vector<vector<int>>& grid) {\\n        ListNode root;\\n        ListNode *cur = &root;\\n        int n = grid.size();\\n        for (int i=0; i<n; ++i) {\\n            int zeroCnt = 0;\\n            for (int j=n-1; j>=1; j--) {\\n                if (grid[i][j]!=0) break;\\n                zeroCnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 891723,
                "title": "python-100-thinking-it-as-a-1d-array-problem",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        \\n        ############ O(N^N); O(N)\\n        \\n        # Converting 2d array problem to 1d array\\n        \\n        # initialize zeros list, which will include each rows count of consecutive zeros from right to left\\n        zeros=[]\\n        for each in range(len(grid)):\\n            temp=0\\n            for end in range(len(grid[0])-1,-1,-1):\\n                if grid[each][end]==0:\\n                    temp+=1\\n                else:\\n                    break\\n            zeros.append(temp)\\n       \\n        # initialize count i.e swaps \\n        cnt=0\\n        \\n        # currentzero is the required zeros at index \\n        currentzero=len(grid)-1\\n        index=0\\n        while index<=len(grid)-1:\\n            temp=zeros[index]\\n            \\n            # check if zeros[index] is greater or equal to required or currentzero, if it is: mark it as visited (-1) and increment count\\n            if temp>=currentzero:\\n                zeros[index]=-1\\n                index+=1\\n            \\n            else:\\n                # if above condition fails, look for nearest on right which is greater or equal to currentzero\\n                flag=False\\n                for each in range(index,len(zeros)):\\n                    \\n                    # if the current element already visited in previous operation continue\\n                    if zeros[each]==-1:\\n                        continue\\n                    \\n                    # if found, mark as visited and mark flag as visited\\n                    if zeros[each]>=currentzero:\\n                        zeros[each]=-1\\n                        flag=True\\n                        break\\n                    else:\\n                        \\n                        # increment count and look for another element on right which satisfies the above condition\\n                        cnt+=1\\n                \\n                # check if we found the element on right, if not return -1 (not possible to satisfy the problem statement)\\n                if not flag:\\n                    return -1\\n                \\n            # Otherwise decrement currentzero\\n            currentzero-=1\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        \\n        ############ O(N^N); O(N)\\n        \\n        # Converting 2d array problem to 1d array\\n        \\n        # initialize zeros list, which will include each rows count of consecutive zeros from right to left\\n        zeros=[]\\n        for each in range(len(grid)):\\n            temp=0\\n            for end in range(len(grid[0])-1,-1,-1):\\n                if grid[each][end]==0:\\n                    temp+=1\\n                else:\\n                    break\\n            zeros.append(temp)\\n       \\n        # initialize count i.e swaps \\n        cnt=0\\n        \\n        # currentzero is the required zeros at index \\n        currentzero=len(grid)-1\\n        index=0\\n        while index<=len(grid)-1:\\n            temp=zeros[index]\\n            \\n            # check if zeros[index] is greater or equal to required or currentzero, if it is: mark it as visited (-1) and increment count\\n            if temp>=currentzero:\\n                zeros[index]=-1\\n                index+=1\\n            \\n            else:\\n                # if above condition fails, look for nearest on right which is greater or equal to currentzero\\n                flag=False\\n                for each in range(index,len(zeros)):\\n                    \\n                    # if the current element already visited in previous operation continue\\n                    if zeros[each]==-1:\\n                        continue\\n                    \\n                    # if found, mark as visited and mark flag as visited\\n                    if zeros[each]>=currentzero:\\n                        zeros[each]=-1\\n                        flag=True\\n                        break\\n                    else:\\n                        \\n                        # increment count and look for another element on right which satisfies the above condition\\n                        cnt+=1\\n                \\n                # check if we found the element on right, if not return -1 (not possible to satisfy the problem statement)\\n                if not flag:\\n                    return -1\\n                \\n            # Otherwise decrement currentzero\\n            currentzero-=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887726,
                "title": "javascript-92ms",
                "content": "```\\nconst minSwaps = (grid) => {\\n    let n = grid.length;\\n    let a = new Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][n - 1 - j] != 0) break;\\n            a[i]++;\\n        }\\n    }\\n    let res = 0;\\n    top:\\n        for (let i = 0; i < n; i++) {\\n            for (let j = i; j < n; j++) {\\n                if (a[j] >= n - i - 1) {\\n                    for (let k = j - 1; k >= i; k--) {\\n                        [a[k], a[k + 1]] = [a[k + 1], a[k]];  // swap\\n                        res++;\\n                    }\\n                    continue top;\\n                }\\n            }\\n            return -1;\\n        }\\n    return res;\\n};\\n\\n/////////////////// improve to 88ms ///////////////////////\\nconst minSwaps = (grid) => {\\n    let n = grid.length;\\n    let a = new Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][n - 1 - j] != 0) break;\\n            a[i]++;\\n        }\\n    }\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (a[j] >= n - i - 1) {\\n                for (let k = j - 1; k >= i; k--) {\\n                    [a[k], a[k + 1]] = [a[k + 1], a[k]];\\n                    res++;\\n                }\\n                break;\\n            }\\n        }\\n        if (a[i] < n - i - 1) return -1;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst minSwaps = (grid) => {\\n    let n = grid.length;\\n    let a = new Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][n - 1 - j] != 0) break;\\n            a[i]++;\\n        }\\n    }\\n    let res = 0;\\n    top:\\n        for (let i = 0; i < n; i++) {\\n            for (let j = i; j < n; j++) {\\n                if (a[j] >= n - i - 1) {\\n                    for (let k = j - 1; k >= i; k--) {\\n                        [a[k], a[k + 1]] = [a[k + 1], a[k]];  // swap\\n                        res++;\\n                    }\\n                    continue top;\\n                }\\n            }\\n            return -1;\\n        }\\n    return res;\\n};\\n\\n/////////////////// improve to 88ms ///////////////////////\\nconst minSwaps = (grid) => {\\n    let n = grid.length;\\n    let a = new Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][n - 1 - j] != 0) break;\\n            a[i]++;\\n        }\\n    }\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (a[j] >= n - i - 1) {\\n                for (let k = j - 1; k >= i; k--) {\\n                    [a[k], a[k + 1]] = [a[k + 1], a[k]];\\n                    res++;\\n                }\\n                break;\\n            }\\n        }\\n        if (a[i] < n - i - 1) return -1;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874289,
                "title": "python-no-sort-beats-100",
                "content": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        size=len(grid)\\n        if size==1: return 0\\n        l=[]\\n        cnt=0\\n        \\n        for i in grid:\\n            cnt=0\\n            for j in i[::-1]:\\n                if j: break\\n                cnt-=1\\n            l.append(cnt)\\n\\n        target=size-1\\n        pos=0 #search position in l\\n        ans=0\\n        \\n        while target>0:\\n            pos=0\\n            while pos<len(l):\\n                if l[pos]+target<=0: break\\n                pos+=1         \\n            else:\\n                return -1\\n            ans+=pos\\n            l.pop(pos)\\n            target-=1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        size=len(grid)\\n        if size==1: return 0\\n        l=[]\\n        cnt=0\\n        \\n        for i in grid:\\n            cnt=0\\n            for j in i[::-1]:\\n                if j: break\\n                cnt-=1\\n            l.append(cnt)\\n\\n        target=size-1\\n        pos=0 #search position in l\\n        ans=0\\n        \\n        while target>0:\\n            pos=0\\n            while pos<len(l):\\n                if l[pos]+target<=0: break\\n                pos+=1         \\n            else:\\n                return -1\\n            ans+=pos\\n            l.pop(pos)\\n            target-=1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874075,
                "title": "c-simple",
                "content": "```\\nint minSwaps(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        if(!m)\\n            return 0;\\n        vector<int> arr(m, INT_MIN);\\n        for(int i=0;i<m;i++){\\n            int index = -1;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1)\\n                    index = j;\\n            }\\n            if(index!=-1)\\n                arr[i] = index;\\n                \\n        }\\n        vector<int> temp(arr.begin(), arr.end());\\n        sort(temp.begin(), temp.end());\\n        for(int i=0;i<m;i++){\\n            if(temp[i] > i)\\n                return -1;\\n        }\\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int j=i;\\n            while(arr[j] > i)\\n                j++;\\n            count+= j -i;\\n            if(j < arr.size()){\\n                int k = j;\\n                while(k > i){\\n                    swap(arr[k], arr[k-1]);\\n                    k--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minSwaps(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        if(!m)\\n            return 0;\\n        vector<int> arr(m, INT_MIN);\\n        for(int i=0;i<m;i++){\\n            int index = -1;\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1)\\n                    index = j;\\n            }\\n            if(index!=-1)\\n                arr[i] = index;\\n                \\n        }\\n        vector<int> temp(arr.begin(), arr.end());\\n        sort(temp.begin(), temp.end());\\n        for(int i=0;i<m;i++){\\n            if(temp[i] > i)\\n                return -1;\\n        }\\n        int count = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int j=i;\\n            while(arr[j] > i)\\n                j++;\\n            count+= j -i;\\n            if(j < arr.size()){\\n                int k = j;\\n                while(k > i){\\n                    swap(arr[k], arr[k-1]);\\n                    k--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 870956,
                "title": "python3-sort-to-check-viability-then-simulate-minimum-swaps-to-arrange-a-binary-grid",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def lastOne(row):\\n            return next((i for i in range(n-1, -1, -1) if row[i]), -1)\\n        rightZeros = [n - 1 - lastOne(row) for row in grid]\\n        for i, rz in enumerate(sorted(rightZeros)):\\n            if rz < i:\\n                return -1\\n        ans = 0    \\n        for i in range(n):\\n            target = n + ~i\\n            if rightZeros[i] < target:\\n                j = i + 1\\n                while rightZeros[j] < target:\\n                    j += 1\\n                ans += j - i     \\n                rightZeros[i:j+1] = [rightZeros[j]] + rightZeros[i:j]\\n        return ans          \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def lastOne(row):\\n            return next((i for i in range(n-1, -1, -1) if row[i]), -1)\\n        rightZeros = [n - 1 - lastOne(row) for row in grid]\\n        for i, rz in enumerate(sorted(rightZeros)):\\n            if rz < i:\\n                return -1\\n        ans = 0    \\n        for i in range(n):\\n            target = n + ~i\\n            if rightZeros[i] < target:\\n                j = i + 1\\n                while rightZeros[j] < target:\\n                    j += 1\\n                ans += j - i     \\n                rightZeros[i:j+1] = [rightZeros[j]] + rightZeros[i:j]\\n        return ans          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 868117,
                "title": "python-one-pass-greedy-solution-beats-99-9",
                "content": "There are some good solutions in discussion. posting notes on an approach which calculates the solution in one pass by applying a \"greedy\" algorithm based on selecting the optimal destination of each grid row in a final grid starting from the top. This allows us to determine the optimal solution in one pass rather than processing the grid and then going back to apply greedy algorithm.\\n\\nSummary: we can iterate through the grid from the top row, calculating the optimal final destination of each row in a greedy way and also determine how many swaps the row must add to the final solution based on previously-processed rows.\\n\\n## High-level algorithm in more detail:\\n\\n1. Create an array, `filled`, of length n representing \"filled\" rows of final solution matrix\\n2. Set `min_swaps = 0`\\n3. Start from \"top\" of input matrix and go row by row. For each input row,\\n\\t**(a)** Determine the optimal final destination of the row by \"filling\" in the highest unfilled row which the row is valid for. A row is valid for any indexes, `i`, in `filled` where `i >= n - trailing_zeros(row) - 1` e.g. a row with n trailing zeros is valid for all indices > -1, a row with n-1 trailing zeros is valid for all indices > 0, etc... (both values n-1 and n are valid for all indices in `filled`)\\n\\t**(b)** If there aren\\'t any valid rows remaining to fill, then this matrix is invalid.\\n\\t**(c)** Add to `min_swaps` the number of rows which have already been filled that are \"lower\" (e.g. have a higher index in `filled`) than the final destination row for the current row\\n4. Return `min_swaps`\\n\\n## Proof ideas/notes\\n\\n**(a)** assign each row to its optimal destination based on its original position and number of trailing 0s\\n\\t- idea1: if two rows `i` and `j` of same # trailing zeros exist, the optimal destination for the earlier row, `i`, (closest to top of grid) must be higher than later row, `j`, since in order for `j` to end up higher than `i` in the final solution, there must be a swap involving `i` and `j` which could just be removed from that solution to get the same result for one less move\\n\\t- idea2: based on above, we can \"greedily\" determine optimal destination of a row starting from the top of the grid by placing it in the highest valid row which hasn\\'t already been filled by a previous row\\n\\n**(b)** based on above, and since we\\'re re-arranging n rows into n places, if one row doesn\\'t have a valid slot to fill in the final solution, we know that there will be an empty row in the final solution, so we can early return in this case\\n\\n**(c)** we actually know how many moves will be required to \"move\" a row into its optimal end position as we\\'re processing. we just need to count the number of rows we\\'ve already processed which need to end up in later rows\\n\\n**proof idea:** assume that we have an array, `arr` of numbers 0..n-1 which we need to sort in reverse with adj swaps\\n\\tthis is effectively what we end up with after the \"greedy\" optimal destination selection above, where we\\'ve mapped the input rows to their final destination. note that at this point, we don\\'t care about trailing zeros.\\n\\nThe min number of swaps this sort can possibly take if we always swap a higher number with a lower one:\\n- For each num `i` in `arr`, we know that at some point, we must swap `i` with any index `j` before `i` in `arr` where`num[j] < num[i]`\\n\\t\\te.g.  `count(arr[j] if arr[j] < arr[i] for j in range(i))`\\n\\tSo the min number of swaps possible to sort the entire array must be `sum(count(arr[j] if arr[j] < arr[i] for j in range(i) for i in range(n)` if we only ever do useful swaps.\\n\\nNow note that we can always choose to swap a higher number with a lower one in the array because if we can\\'t, then it means the array is already sorted properly\\n\\nSo the above number is the true min number of swaps required to sort array accordingly\\n\\nFinally, mapping back to our solution, the `count(arr[j] if arr[j] < arr[i] for j in range(i))` is effectively equivalent to the number of \"lower\" rows already-filled in the final optimal solution grid when we fill row `i`\\n\\t\\t\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def fill(arr, idx):\\n            # try to fill with simple cascade try the highest and go next until we find an empty slot or can\\'t fill\\n            # where lower index in input arr represents \"higher\" row in potential optimal solution\\n            # potential improvement\\n            while idx < len(arr) and arr[idx]:\\n                idx += 1\\n            if idx < len(arr):\\n                arr[idx] = True\\n                return idx\\n            return -1\\n        \\n        def count_swaps(arr, from_idx):\\n            # count number of rows which have already been filled at a higher index (e.g. a \"lower\" row in solution grid)\\n            # potential improvement\\n            return sum(arr[i] for i in range(from_idx + 1, len(arr))\\n        \\n        def get_trailing_zeros(row):\\n            zeros = 0\\n            for i in reversed(range(len(row))):\\n                if row[i] == 1:\\n                    break\\n                zeros += 1\\n            return zeros\\n        \\n        if len(grid) < 1:\\n            return -1\\n        \\n        n = len(grid)\\n        \\n        # initialize final optimal solution \"filled\" grid\\n        filled_rows = [False for i in range(n)]\\n        \\n        num_swaps = 0\\n        \\n        # O(n) w/ O(n) inner loop -> O(n^2)\\n        for row in grid:\\n                       \\n            # O(n)\\n            trailing_zeros = get_trailing_zeros(row)\\n                       \\n            # print(f\\'row: {row}, trailing 0s: {trailing_zeros}\\')\\n            \\n            # fill in the highest valid row in optimal solution\\n            # the highest row we can fill is determined by number of trailing zeros\\n            # if there are n trailing zeros, set to 0 index (highest row of grid)\\n            # O(n)\\n            fill_idx = fill(filled_rows, max(0, n - trailing_zeros - 1))\\n            \\n            if fill_idx == -1:\\n                # if can\\'t fill one row, we can\\'t get a valid solution\\n                return -1\\n            else:\\n                # use fill_idx to determine how many rows exist prior to this one\\n                # which we need to swap over, and add this to min swaps\\n                # O(n)\\n                num_swaps += count_swaps(filled_rows, fill_idx)\\n                       \\n        assert(all(filled_rows))\\n        return num_swaps\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        def fill(arr, idx):\\n            # try to fill with simple cascade try the highest and go next until we find an empty slot or can\\'t fill\\n            # where lower index in input arr represents \"higher\" row in potential optimal solution\\n            # potential improvement\\n            while idx < len(arr) and arr[idx]:\\n                idx += 1\\n            if idx < len(arr):\\n                arr[idx] = True\\n                return idx\\n            return -1\\n        \\n        def count_swaps(arr, from_idx):\\n            # count number of rows which have already been filled at a higher index (e.g. a \"lower\" row in solution grid)\\n            # potential improvement\\n            return sum(arr[i] for i in range(from_idx + 1, len(arr))\\n        \\n        def get_trailing_zeros(row):\\n            zeros = 0\\n            for i in reversed(range(len(row))):\\n                if row[i] == 1:\\n                    break\\n                zeros += 1\\n            return zeros\\n        \\n        if len(grid) < 1:\\n            return -1\\n        \\n        n = len(grid)\\n        \\n        # initialize final optimal solution \"filled\" grid\\n        filled_rows = [False for i in range(n)]\\n        \\n        num_swaps = 0\\n        \\n        # O(n) w/ O(n) inner loop -> O(n^2)\\n        for row in grid:\\n                       \\n            # O(n)\\n            trailing_zeros = get_trailing_zeros(row)\\n                       \\n            # print(f\\'row: {row}, trailing 0s: {trailing_zeros}\\')\\n            \\n            # fill in the highest valid row in optimal solution\\n            # the highest row we can fill is determined by number of trailing zeros\\n            # if there are n trailing zeros, set to 0 index (highest row of grid)\\n            # O(n)\\n            fill_idx = fill(filled_rows, max(0, n - trailing_zeros - 1))\\n            \\n            if fill_idx == -1:\\n                # if can\\'t fill one row, we can\\'t get a valid solution\\n                return -1\\n            else:\\n                # use fill_idx to determine how many rows exist prior to this one\\n                # which we need to swap over, and add this to min swaps\\n                # O(n)\\n                num_swaps += count_swaps(filled_rows, fill_idx)\\n                       \\n        assert(all(filled_rows))\\n        return num_swaps\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 853689,
                "title": "simple-python-solution-beat-91",
                "content": "```\\n        n = len(grid)\\n        m = [n] * n\\n        for i in range(n):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j] == 1:\\n                    m[i] = n-j-1\\n                    break\\n        t,ans = 0,0\\n        for i in range(n):\\n            t += 1\\n            flag = False\\n            for j in range(i,n):\\n                if m[j] >= n-t:\\n                    ans += j-i\\n                    flag = True\\n                    break\\n            if not flag: return -1\\n            m[i+1:j+1] = m[i:j]\\n        return ans",
                "solutionTags": [],
                "code": "```\\n        n = len(grid)\\n        m = [n] * n\\n        for i in range(n):\\n            for j in range(n-1,-1,-1):\\n                if grid[i][j] == 1:\\n                    m[i] = n-j-1\\n                    break\\n        t,ans = 0,0\\n        for i in range(n):\\n            t += 1\\n            flag = False\\n            for j in range(i,n):\\n                if m[j] >= n-t:\\n                    ans += j-i\\n                    flag = True\\n                    break\\n            if not flag: return -1\\n            m[i+1:j+1] = m[i:j]\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 848773,
                "title": "python-o-mn-o-m",
                "content": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        n = len(grid)\\n        zeroCount = self.getZeroCount(grid)\\n        for i in range(len(grid)):\\n            if zeroCount[i] < n-i-1:\\n                j = i\\n                while j < n and zeroCount[j] < n - i - 1:\\n                    j += 1\\n                if j == n:\\n                    return -1\\n                while j > i:\\n                    zeroCount[j], zeroCount[j-1] = zeroCount[j-1], zeroCount[j]\\n                    j -= 1\\n                    res += 1\\n            \\n        return res\\n    \\n    def getZeroCount(self, grid):\\n        zeroCount = []\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            count = 0\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 0:\\n                    count+=1\\n                else:\\n                    break\\n            zeroCount.append(count)\\n        \\n        return zeroCount\\n                \\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSwaps(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        n = len(grid)\\n        zeroCount = self.getZeroCount(grid)\\n        for i in range(len(grid)):\\n            if zeroCount[i] < n-i-1:\\n                j = i\\n                while j < n and zeroCount[j] < n - i - 1:\\n                    j += 1\\n                if j == n:\\n                    return -1\\n                while j > i:\\n                    zeroCount[j], zeroCount[j-1] = zeroCount[j-1], zeroCount[j]\\n                    j -= 1\\n                    res += 1\\n            \\n        return res\\n    \\n    def getZeroCount(self, grid):\\n        zeroCount = []\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            count = 0\\n            for j in range(n-1, -1, -1):\\n                if grid[i][j] == 0:\\n                    count+=1\\n                else:\\n                    break\\n            zeroCount.append(count)\\n        \\n        return zeroCount\\n                \\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 823386,
                "title": "simple-approach-but-doesnt-pass-all-tests",
                "content": "This approach fails on 106/129th test case due to number of swaps. However the idea is that, count the trailing zeros, use sort to count the swaps & then check the order from the sorted list. It takes only additional O(n) space & time complexity depends on choice of your sort (I used bubble sort - O(n^2))\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n      vector<int> zeroCount;\\n      int swapCount = 0;\\n      \\n      // count the number of trailing zeros\\n      for (int i = 0; i < grid.size(); i++) {\\n        int count = 0;\\n        for (int j = grid[i].size() - 1; j >= 0; j--) {\\n          if (grid[i][j] != 0) {\\n            break;\\n          }\\n          count++;\\n        }\\n        zeroCount.push_back(count);\\n      }\\n      \\n      // bubble sort the array (and keep track of swaps)\\n      // TODO: which sorting does minimum swaps?\\n      for (int i = 0; i < zeroCount.size() - 1; i++) {\\n        for (int j = 0; j < zeroCount.size()-i-1; j++) {\\n          if (zeroCount[j] < zeroCount[j+1]) {\\n            int tmp = zeroCount[j];\\n            zeroCount[j] = zeroCount[j+1];\\n            zeroCount[j+1] = tmp;\\n            swapCount++;\\n          }\\n        }\\n      }\\n      \\n      // if the array is not sorted(descending order), then solution is not possible\\n      for (int i = 0; i < zeroCount.size(); i++) {\\n        if (zeroCount[i] < (zeroCount.size() - i - 1)) {\\n          return -1;\\n        }\\n      }\\n      \\n      return swapCount;\\n    }",
                "solutionTags": [],
                "code": "This approach fails on 106/129th test case due to number of swaps. However the idea is that, count the trailing zeros, use sort to count the swaps & then check the order from the sorted list. It takes only additional O(n) space & time complexity depends on choice of your sort (I used bubble sort - O(n^2))\\n\\n    int minSwaps(vector<vector<int>>& grid) {\\n      vector<int> zeroCount;\\n      int swapCount = 0;\\n      \\n      // count the number of trailing zeros\\n      for (int i = 0; i < grid.size(); i++) {\\n        int count = 0;\\n        for (int j = grid[i].size() - 1; j >= 0; j--) {\\n          if (grid[i][j] != 0) {\\n            break;\\n          }\\n          count++;\\n        }\\n        zeroCount.push_back(count);\\n      }\\n      \\n      // bubble sort the array (and keep track of swaps)\\n      // TODO: which sorting does minimum swaps?\\n      for (int i = 0; i < zeroCount.size() - 1; i++) {\\n        for (int j = 0; j < zeroCount.size()-i-1; j++) {\\n          if (zeroCount[j] < zeroCount[j+1]) {\\n            int tmp = zeroCount[j];\\n            zeroCount[j] = zeroCount[j+1];\\n            zeroCount[j+1] = tmp;\\n            swapCount++;\\n          }\\n        }\\n      }\\n      \\n      // if the array is not sorted(descending order), then solution is not possible\\n      for (int i = 0; i < zeroCount.size(); i++) {\\n        if (zeroCount[i] < (zeroCount.size() - i - 1)) {\\n          return -1;\\n        }\\n      }\\n      \\n      return swapCount;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 823309,
                "title": "golang-simple-solution",
                "content": "```go\\nfunc minSwaps(grid [][]int) int {\\n    // calculate and storage row infos\\n\\tmagic := make([]int, 0, len(grid))\\n\\tloop1:\\n\\tfor _, v := range grid {\\n\\t\\tfor i := len(v)-1; i >= 0; i-- {\\n\\t\\t\\tif v[i] == 1 {\\n\\t\\t\\t\\tmagic = append(magic, i)\\n\\t\\t\\t\\tcontinue loop1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmagic = append(magic, 0)\\n\\t}\\n\\tstep := 0\\n\\tloop2:\\n\\tfor curr := 0; curr < len(grid); curr++ {\\n\\t\\tfor i, v := range magic {\\n\\t\\t\\tif v <= curr {\\n\\t\\t\\t\\tcopy(magic[1:i+1], magic[:i])\\n\\t\\t\\t\\tmagic = magic[1:]\\n\\t\\t\\t\\tstep += i\\n\\t\\t\\t\\tcontinue loop2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n\\treturn step\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minSwaps(grid [][]int) int {\\n    // calculate and storage row infos\\n\\tmagic := make([]int, 0, len(grid))\\n\\tloop1:\\n\\tfor _, v := range grid {\\n\\t\\tfor i := len(v)-1; i >= 0; i-- {\\n\\t\\t\\tif v[i] == 1 {\\n\\t\\t\\t\\tmagic = append(magic, i)\\n\\t\\t\\t\\tcontinue loop1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmagic = append(magic, 0)\\n\\t}\\n\\tstep := 0\\n\\tloop2:\\n\\tfor curr := 0; curr < len(grid); curr++ {\\n\\t\\tfor i, v := range magic {\\n\\t\\t\\tif v <= curr {\\n\\t\\t\\t\\tcopy(magic[1:i+1], magic[:i])\\n\\t\\t\\t\\tmagic = magic[1:]\\n\\t\\t\\t\\tstep += i\\n\\t\\t\\t\\tcontinue loop2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n\\treturn step\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 810576,
                "title": "my-solution-using-priority-queue",
                "content": "Using Priority Queue and TreeSet. Run time may be better for larger arrays.\\n```\\npublic class MinSwapGrid {\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();// find nearest row.\\n    TreeSet<Integer> usedSet = new TreeSet<>();// used Allow to calculate the compensation due to row change.\\n    Map<Integer, List<Integer>> mValue = new HashMap<>();// list of rows with key number of trailing zeros\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int move = 0;\\n        for(int i =0; i < n;i++) {\\n            int key = 0;\\n            for(int j = n-1;j >=0;j--) {\\n                if (grid[i][j] != 0) break;\\n                key++;//Number of zeros\\n            }//\\n            List<Integer> lVal = mValue.getOrDefault(key,new LinkedList<Integer>());\\n            lVal.add(i);\\n            mValue.put(key,lVal);\\n        }\\n        int rr =0;\\n        for(int i =n; i >= 1;i--) {\\n            List<Integer> nList = mValue.get(i);\\n            if (nList != null) {\\n                for(int jj : nList) minHeap.add(jj);\\n            }\\n            if (i == n) continue;\\n            if (minHeap.isEmpty()) return  -1;\\n            int row = minHeap.poll();\\n            Set<Integer> ss = usedSet.tailSet(row);\\n            move += (row+ ((ss == null)?0:ss.size()))-rr;\\n            usedSet.add(row);\\n            rr++;\\n        }\\n\\n        return move;\\n    }\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MinSwapGrid {\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();// find nearest row.\\n    TreeSet<Integer> usedSet = new TreeSet<>();// used Allow to calculate the compensation due to row change.\\n    Map<Integer, List<Integer>> mValue = new HashMap<>();// list of rows with key number of trailing zeros\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int move = 0;\\n        for(int i =0; i < n;i++) {\\n            int key = 0;\\n            for(int j = n-1;j >=0;j--) {\\n                if (grid[i][j] != 0) break;\\n                key++;//Number of zeros\\n            }//\\n            List<Integer> lVal = mValue.getOrDefault(key,new LinkedList<Integer>());\\n            lVal.add(i);\\n            mValue.put(key,lVal);\\n        }\\n        int rr =0;\\n        for(int i =n; i >= 1;i--) {\\n            List<Integer> nList = mValue.get(i);\\n            if (nList != null) {\\n                for(int jj : nList) minHeap.add(jj);\\n            }\\n            if (i == n) continue;\\n            if (minHeap.isEmpty()) return  -1;\\n            int row = minHeap.poll();\\n            Set<Integer> ss = usedSet.tailSet(row);\\n            move += (row+ ((ss == null)?0:ss.size()))-rr;\\n            usedSet.add(row);\\n            rr++;\\n        }\\n\\n        return move;\\n    }\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789410,
                "title": "c-o-nlgn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minSwaps(vector<vector<int>>& A) {\\n\\t\\tconst int N=A.size();\\n\\t\\tvector<vector<int>> G(N);\\n\\t\\t// O(N^2)\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tint x=N;\\n\\t\\t\\twhile(--x && !A[i][x]);\\n\\t\\t\\tG[N-x-1].push_back(i);\\n\\t\\t}\\n\\t\\t// O(NlgN)\\n\\t\\tint sum=0;\\n\\t\\tvector<int> T(N+1);\\n\\t\\tpriority_queue<int> Q;\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tfor(int j:G[N-i-1]) Q.push(-j);\\n\\t\\t\\tif(Q.empty()) return -1;\\n\\t\\t\\tint j=-Q.top();\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tsum+=j-i;\\n\\t\\t\\tfor(int k=N-j; k; k-=k&-k) sum+=T[k];\\n\\t\\t\\tfor(int k=N-j; k<=N; k+=k&-k) T[k]++;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minSwaps(vector<vector<int>>& A) {\\n\\t\\tconst int N=A.size();\\n\\t\\tvector<vector<int>> G(N);\\n\\t\\t// O(N^2)\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tint x=N;\\n\\t\\t\\twhile(--x && !A[i][x]);\\n\\t\\t\\tG[N-x-1].push_back(i);\\n\\t\\t}\\n\\t\\t// O(NlgN)\\n\\t\\tint sum=0;\\n\\t\\tvector<int> T(N+1);\\n\\t\\tpriority_queue<int> Q;\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tfor(int j:G[N-i-1]) Q.push(-j);\\n\\t\\t\\tif(Q.empty()) return -1;\\n\\t\\t\\tint j=-Q.top();\\n\\t\\t\\tQ.pop();\\n\\t\\t\\tsum+=j-i;\\n\\t\\t\\tfor(int k=N-j; k; k-=k&-k) sum+=T[k];\\n\\t\\t\\tfor(int k=N-j; k<=N; k+=k&-k) T[k]++;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778158,
                "title": "faster-than-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        unordered_map<int,int>mp,mp2;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c1=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                    c1++;\\n                else\\n                    break;\\n            }\\n            mp[i]=c1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=mp[i];\\n            int l=(n-i-1);\\n            int j=i;\\n            while(x<l && j<n-1)\\n            {\\n                ans++;\\n                x=mp[++j];\\n                if(j==(n-1) && x<l)\\n                    return -1;\\n            }\\n            for(int l=j;l>=i+1;l--)\\n                mp[l]=mp[l-1];\\n            mp[i]=l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        unordered_map<int,int>mp,mp2;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c1=0;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==0)\\n                    c1++;\\n                else\\n                    break;\\n            }\\n            mp[i]=c1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=mp[i];\\n            int l=(n-i-1);\\n            int j=i;\\n            while(x<l && j<n-1)\\n            {\\n                ans++;\\n                x=mp[++j];\\n                if(j==(n-1) && x<l)\\n                    return -1;\\n            }\\n            for(int l=j;l>=i+1;l--)\\n                mp[l]=mp[l-1];\\n            mp[i]=l;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777078,
                "title": "java-just-count-the-trailing-zeros-for-each-row-and-apply-greedy-selection",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] cntZeros = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] != 0) {\\n                    break;\\n                }\\n                cnt++;\\n            }\\n            cntZeros[i] = cnt;\\n        }\\n        int res = 0;\\n        int target = n - 1;\\n        for (int i = 0; i < n; i++) {\\n            int j;\\n            for (j = i; j < n; j++) {\\n                if (target <= cntZeros[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return -1;\\n            }\\n            res += j - i;\\n            moveToFront(cntZeros, i, j);    \\n            target--;\\n        }\\n        return res;\\n    }\\n    \\n    private void moveToFront(int[] cntZeros, int i, int j) {\\n        int temp = cntZeros[j];\\n        for (int k = j; k > i; k--) {\\n            cntZeros[k] = cntZeros[k - 1];\\n        }\\n        cntZeros[i] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int n = grid.length;\\n        int[] cntZeros = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] != 0) {\\n                    break;\\n                }\\n                cnt++;\\n            }\\n            cntZeros[i] = cnt;\\n        }\\n        int res = 0;\\n        int target = n - 1;\\n        for (int i = 0; i < n; i++) {\\n            int j;\\n            for (j = i; j < n; j++) {\\n                if (target <= cntZeros[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return -1;\\n            }\\n            res += j - i;\\n            moveToFront(cntZeros, i, j);    \\n            target--;\\n        }\\n        return res;\\n    }\\n    \\n    private void moveToFront(int[] cntZeros, int i, int j) {\\n        int temp = cntZeros[j];\\n        for (int k = j; k > i; k--) {\\n            cntZeros[k] = cntZeros[k - 1];\\n        }\\n        cntZeros[i] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776913,
                "title": "python3-easy-solution",
                "content": "```\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        count, size, rowN, tag, has = 0, len(grid), 0, 0, {}\\n        tmpCount = 0\\n        while rowN < size-1 and tag < size:\\n            if tag in has.keys():\\n                tag += 1\\n                tmpCount += 1\\n                continue\\n            if 1 not in grid[tag][rowN+1:]:\\n                count += tag - tmpCount\\n                rowN += 1\\n                has[tag] = tag\\n                tag, tmpCount = 0,0\\n            else:\\n                tag += 1\\n        return count if rowN == size-1 else -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        count, size, rowN, tag, has = 0, len(grid), 0, 0, {}\\n        tmpCount = 0\\n        while rowN < size-1 and tag < size:\\n            if tag in has.keys():\\n                tag += 1\\n                tmpCount += 1\\n                continue\\n            if 1 not in grid[tag][rowN+1:]:\\n                count += tag - tmpCount\\n                rowN += 1\\n                has[tag] = tag\\n                tag, tmpCount = 0,0\\n            else:\\n                tag += 1\\n        return count if rowN == size-1 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 775736,
                "title": "java-clean-solution-in-o-n",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] zeroes = calculateZeroesFromRight(grid);\\n        int steps = countSortSteps(zeroes);\\n        return steps;\\n    }\\n    \\n    private int[] calculateZeroesFromRight(int[][] grid) {\\n        int n = grid.length;\\n        int[] zeroes = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int j;\\n            for (j = n - 1; j >= 0 && grid[i][j] == 0; j--);\\n            \\n            zeroes[i] = n - j - 1;\\n        }\\n        \\n        return zeroes;\\n    }\\n    \\n    private int countSortSteps(int[] arr) {\\n        int n = arr.length;\\n        int steps = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int target = n - i - 1;\\n            int j = i;\\n            \\n            while (j < n && arr[j] < target) {\\n                j++;\\n            }\\n            \\n            if(j >= n) {\\n                return -1;\\n            }\\n            \\n            steps += j - i;\\n            while (j > i) {\\n                swap(arr, j, j - 1);\\n                j--;\\n            }\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] zeroes = calculateZeroesFromRight(grid);\\n        int steps = countSortSteps(zeroes);\\n        return steps;\\n    }\\n    \\n    private int[] calculateZeroesFromRight(int[][] grid) {\\n        int n = grid.length;\\n        int[] zeroes = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int j;\\n            for (j = n - 1; j >= 0 && grid[i][j] == 0; j--);\\n            \\n            zeroes[i] = n - j - 1;\\n        }\\n        \\n        return zeroes;\\n    }\\n    \\n    private int countSortSteps(int[] arr) {\\n        int n = arr.length;\\n        int steps = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int target = n - i - 1;\\n            int j = i;\\n            \\n            while (j < n && arr[j] < target) {\\n                j++;\\n            }\\n            \\n            if(j >= n) {\\n                return -1;\\n            }\\n            \\n            steps += j - i;\\n            while (j > i) {\\n                swap(arr, j, j - 1);\\n                j--;\\n            }\\n        }\\n        \\n        return steps;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775593,
                "title": "python-solution",
                "content": "This is my code in python\\n\\n```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        lenth=len(grid)\\n        zeros=[0]*lenth\\n        for i in range(lenth):\\n            row=grid[i]\\n            for j in range(lenth):\\n                if row[-j-1]==0:\\n                    zeros[i]=j+1\\n                else:\\n                    break\\n        \\n        \\n        count=0\\n        \\n        for i in range(lenth):\\n            print(zeros)\\n            if zeros[i]<lenth-1-i:\\n                \\n                did=0\\n                for next in range(lenth-i-1):\\n                    if zeros[i+next+1]>=lenth-1-i:\\n                        did=1\\n                        k=i+next+1\\n                        while k - i >0:\\n                            count+=1\\n                            zeros[k],zeros[k-1] =zeros[k-1],zeros[k]\\n                            k-=1\\n                        break\\n                        \\n                if did==0:\\n                    return -1\\n        return count\\n                    \\n    ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        lenth=len(grid)\\n        zeros=[0]*lenth\\n        for i in range(lenth):\\n            row=grid[i]\\n            for j in range(lenth):\\n                if row[-j-1]==0:\\n                    zeros[i]=j+1\\n                else:\\n                    break\\n        \\n        \\n        count=0\\n        \\n        for i in range(lenth):\\n            print(zeros)\\n            if zeros[i]<lenth-1-i:\\n                \\n                did=0\\n                for next in range(lenth-i-1):\\n                    if zeros[i+next+1]>=lenth-1-i:\\n                        did=1\\n                        k=i+next+1\\n                        while k - i >0:\\n                            count+=1\\n                            zeros[k],zeros[k-1] =zeros[k-1],zeros[k]\\n                            k-=1\\n                        break\\n                        \\n                if did==0:\\n                    return -1\\n        return count\\n                    \\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 775457,
                "title": "java-solution-using-priorityqueue-and-treeset",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return -1;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] counts = new int[m];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> counts[x] == counts[y] ? x - y : counts[y] - counts[x]);\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < m; i++) {\\n            counts[i] = count(grid[i]);\\n            set.add(i);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            pq.add(i);\\n        }\\n        PriorityQueue<Integer> rank = new PriorityQueue<>();\\n        int result = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && counts[pq.peek()] >= i) {\\n                rank.add(pq.poll());\\n            }\\n            if (rank.isEmpty()) {\\n                return -1;\\n            }\\n            int selectedRow = rank.poll();\\n            result += set.headSet(selectedRow).size();\\n            set.remove(selectedRow);\\n        }\\n        return result;\\n    }\\n    \\n    private int count(int[] row) {\\n        int count = 0;\\n        for (int i = row.length - 1; i >= 0; i--) {\\n            if (row[i] == 0) {\\n                count++;\\n            } else {\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return -1;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] counts = new int[m];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> counts[x] == counts[y] ? x - y : counts[y] - counts[x]);\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < m; i++) {\\n            counts[i] = count(grid[i]);\\n            set.add(i);\\n        }\\n        for (int i = 0; i < m; i++) {\\n            pq.add(i);\\n        }\\n        PriorityQueue<Integer> rank = new PriorityQueue<>();\\n        int result = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && counts[pq.peek()] >= i) {\\n                rank.add(pq.poll());\\n            }\\n            if (rank.isEmpty()) {\\n                return -1;\\n            }\\n            int selectedRow = rank.poll();\\n            result += set.headSet(selectedRow).size();\\n            set.remove(selectedRow);\\n        }\\n        return result;\\n    }\\n    \\n    private int count(int[] row) {\\n        int count = 0;\\n        for (int i = row.length - 1; i >= 0; i--) {\\n            if (row[i] == 0) {\\n                count++;\\n            } else {\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775116,
                "title": "javascript-clean-code-beat-100-speed-and-memory",
                "content": "```javascript\\nvar minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        for(let j = 0; j < arr.length; j++) {\\n            if(arr[j] != null && arr[j] <= i) {\\n                arr[j] = null; break;\\n            } else if(arr[j] != null) count++;\\n        }\\n    }\\n    if(arr.every(x => x == null)) return count;\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minSwaps = function(grid) {\\n    const arr = [];\\n    let count = 0;\\n    \\n    for(let row of grid) {\\n        arr.push(row.lastIndexOf(1));\\n    }\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        for(let j = 0; j < arr.length; j++) {\\n            if(arr[j] != null && arr[j] <= i) {\\n                arr[j] = null; break;\\n            } else if(arr[j] != null) count++;\\n        }\\n    }\\n    if(arr.every(x => x == null)) return count;\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774625,
                "title": "java-short-solution",
                "content": "Bubble Sort !!!\\n\\n```\\n    public int minSwaps(int[][] g) {\\n        int[] res = new int[g.length];\\n        int idx = 0;\\n        for(int[] r : g) {\\n            int count = 0;\\n            for(int i = r.length-1; i >= 0; i--) {\\n                if(r[i] != 0) break;\\n                count++;\\n            }\\n            res[idx++] = count;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < g.length -1; i++) {\\n            int t = g.length - i - 1;\\n            if(res[i] >= t) continue;\\n            int j = i + 1;\\n            while(j < g.length && res[j] < t) j++;\\n            if(j == g.length) return -1;\\n            ans += j-i;\\n            while(j > i) {\\n                int z = res[j];\\n                res[j] = res[j-1];\\n                res[j-1] = z;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSwaps(int[][] g) {\\n        int[] res = new int[g.length];\\n        int idx = 0;\\n        for(int[] r : g) {\\n            int count = 0;\\n            for(int i = r.length-1; i >= 0; i--) {\\n                if(r[i] != 0) break;\\n                count++;\\n            }\\n            res[idx++] = count;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < g.length -1; i++) {\\n            int t = g.length - i - 1;\\n            if(res[i] >= t) continue;\\n            int j = i + 1;\\n            while(j < g.length && res[j] < t) j++;\\n            if(j == g.length) return -1;\\n            ans += j-i;\\n            while(j > i) {\\n                int z = res[j];\\n                res[j] = res[j-1];\\n                res[j-1] = z;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774007,
                "title": "greedy-approach-java",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        \\n        int[] zc = zeroCount(grid);\\n        \\n        int res=0;\\n        for(int i=0;i<zc.length;i++){\\n            int needed = grid.length-i-1;\\n            \\n            // if needed is available - no swaps required\\n            if(zc[i] >= needed){\\n                continue;        \\n            }\\n            \\n            // check next available (needed) value\\n            boolean found = false;\\n            int j=i+1;\\n            for(;j<zc.length;j++){\\n                if(zc[j] >= needed){\\n                    found = true;\\n                    break;\\n                }          \\n            }\\n            \\n            // if found - swap and increment swaps count\\n            if(found){\\n                int countSwaps=0;\\n                for(int k=j;k>i;k--){\\n                    swap(zc, k-1, k);\\n                    countSwaps++;\\n                }\\n                res += countSwaps;\\n            } else {\\n               return -1; \\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    int[] zeroCount(int[][] grid){\\n        int[] zeroCount = new int[grid.length];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            int count = 0;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[i][j] != 0){\\n                    break;\\n                }\\n                count++;\\n            }\\n            zeroCount[i] = count;\\n        }\\n        return zeroCount;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        \\n        int[] zc = zeroCount(grid);\\n        \\n        int res=0;\\n        for(int i=0;i<zc.length;i++){\\n            int needed = grid.length-i-1;\\n            \\n            // if needed is available - no swaps required\\n            if(zc[i] >= needed){\\n                continue;        \\n            }\\n            \\n            // check next available (needed) value\\n            boolean found = false;\\n            int j=i+1;\\n            for(;j<zc.length;j++){\\n                if(zc[j] >= needed){\\n                    found = true;\\n                    break;\\n                }          \\n            }\\n            \\n            // if found - swap and increment swaps count\\n            if(found){\\n                int countSwaps=0;\\n                for(int k=j;k>i;k--){\\n                    swap(zc, k-1, k);\\n                    countSwaps++;\\n                }\\n                res += countSwaps;\\n            } else {\\n               return -1; \\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    int[] zeroCount(int[][] grid){\\n        int[] zeroCount = new int[grid.length];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            int count = 0;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[i][j] != 0){\\n                    break;\\n                }\\n                count++;\\n            }\\n            zeroCount[i] = count;\\n        }\\n        return zeroCount;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773879,
                "title": "ruby-solution-minimum-swaps-to-arrange-a-binary-grid",
                "content": "Runtime: 92 ms\\nMemory Usage: 10.6 MB\\n\\n```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef min_swaps(grid)\\n    step, n = 0, grid.size\\n    (0..(n - 2)).each do |row|\\n        next if grid[row][(row + 1)..-1].sum == 0\\n        expect = -1\\n        ((row + 1)..(n - 1)).each do |j|\\n            if grid[j][(row + 1)..-1].sum == 0\\n                expect = j\\n                break\\n            end\\n        end\\n        return -1 if expect == -1\\n        expect.downto(row + 1) do |switch|\\n            grid[switch], grid[switch - 1] = grid[switch - 1], grid[switch]\\n            step += 1\\n        end\\n    end\\n    step\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef min_swaps(grid)\\n    step, n = 0, grid.size\\n    (0..(n - 2)).each do |row|\\n        next if grid[row][(row + 1)..-1].sum == 0\\n        expect = -1\\n        ((row + 1)..(n - 1)).each do |j|\\n            if grid[j][(row + 1)..-1].sum == 0\\n                expect = j\\n                break\\n            end\\n        end\\n        return -1 if expect == -1\\n        expect.downto(row + 1) do |switch|\\n            grid[switch], grid[switch - 1] = grid[switch - 1], grid[switch]\\n            step += 1\\n        end\\n    end\\n    step\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 773791,
                "title": "python-o-n-2",
                "content": "we just have to count occurance of zeros(from the end) and put the row and 0s in a q. \\nWhen we iterate through the q, we increase the index of all element iterated by one to mimic the swapping. \\nThen we just have to find diff of current row vs row which target number of zero is at.\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        row,col = len(grid),len(grid[0])\\n        q = []\\n        for i in range(row):\\n            count = 0\\n            for j in range(col-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    break\\n                count += 1\\n            q.append([i,count])\\n        total = 0 \\n        for i in range(row):\\n            target = row - i - 1\\n            p1 = 0 \\n            while p1 < row:\\n                if q[p1][1] >= target:\\n                    total += q[p1][0] - i\\n                    q[p1][0] += 1\\n                    q[p1][1] = 0\\n                    break\\n                q[p1][0] += 1\\n                p1 += 1\\n            if p1 == row:\\n                return -1\\n        return total",
                "solutionTags": [],
                "code": "we just have to count occurance of zeros(from the end) and put the row and 0s in a q. \\nWhen we iterate through the q, we increase the index of all element iterated by one to mimic the swapping. \\nThen we just have to find diff of current row vs row which target number of zero is at.\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        row,col = len(grid),len(grid[0])\\n        q = []\\n        for i in range(row):\\n            count = 0\\n            for j in range(col-1, -1, -1):\\n                if grid[i][j] == 1:\\n                    break\\n                count += 1\\n            q.append([i,count])\\n        total = 0 \\n        for i in range(row):\\n            target = row - i - 1\\n            p1 = 0 \\n            while p1 < row:\\n                if q[p1][1] >= target:\\n                    total += q[p1][0] - i\\n                    q[p1][0] += 1\\n                    q[p1][1] = 0\\n                    break\\n                q[p1][0] += 1\\n                p1 += 1\\n            if p1 == row:\\n                return -1\\n        return total",
                "codeTag": "Java"
            },
            {
                "id": 773455,
                "title": "python-no-need-swap-do-it-lazily-time-beast-100",
                "content": "I see almost every post does the swap operation. In fact, because we just want to know the number of swap operations, we do not really need perform the swap operation, though it does not help reduce time complexity (Time complexity still `O(n^2)`).\\n\\nThe trick is to mark an empty slot with `-1`.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        A = []\\n        for row in grid:\\n            zero = 0\\n            for x in row[::-1]:\\n                if x == 0:\\n                    zero += 1\\n                else:\\n                    break\\n            A.append(zero)\\n        \\n        n = len(grid[0])\\n        i, need, res = 0, n - 1, 0\\n        while i < n:\\n            if A[i] == -1:\\n                i += 1\\n                continue\\n            if A[i] >= need:\\n                i += 1\\n                need -= 1\\n                continue\\n            j = i\\n            while j < n and A[j] < need:\\n                res += 1 if A[j] != -1 else 0\\n                j += 1\\n            if j == n:\\n                return -1\\n            A[j] = -1\\n            need -= 1\\n        return res",
                "solutionTags": [],
                "code": "I see almost every post does the swap operation. In fact, because we just want to know the number of swap operations, we do not really need perform the swap operation, though it does not help reduce time complexity (Time complexity still `O(n^2)`).\\n\\nThe trick is to mark an empty slot with `-1`.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        A = []\\n        for row in grid:\\n            zero = 0\\n            for x in row[::-1]:\\n                if x == 0:\\n                    zero += 1\\n                else:\\n                    break\\n            A.append(zero)\\n        \\n        n = len(grid[0])\\n        i, need, res = 0, n - 1, 0\\n        while i < n:\\n            if A[i] == -1:\\n                i += 1\\n                continue\\n            if A[i] >= need:\\n                i += 1\\n                need -= 1\\n                continue\\n            j = i\\n            while j < n and A[j] < need:\\n                res += 1 if A[j] != -1 else 0\\n                j += 1\\n            if j == n:\\n                return -1\\n            A[j] = -1\\n            need -= 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 773381,
                "title": "straightforward-c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> zero = vector<int>{};\\n        int n = grid.size();\\n        for (int i = 0; i < n; i++) {\\n            zero.push_back(countEndingZeros(grid[i]));\\n        }\\n        int sum = 0;\\n        for (int i = n - 1; i > 0; i--) {\\n            bool found = false;\\n            for (int j = 0; j < zero.size(); j++) {\\n                int z = zero[j];\\n                if (z >= i) {\\n                    sum += j;\\n                    zero.erase(zero.begin()+j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                return -1;\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    int countEndingZeros(vector<int>& row) {\\n        int n = row.size();\\n        int count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (row[i] == 0) {\\n                count++;\\n            } else {\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<vector<int>>& grid) {\\n        vector<int> zero = vector<int>{};\\n        int n = grid.size();\\n        for (int i = 0; i < n; i++) {\\n            zero.push_back(countEndingZeros(grid[i]));\\n        }\\n        int sum = 0;\\n        for (int i = n - 1; i > 0; i--) {\\n            bool found = false;\\n            for (int j = 0; j < zero.size(); j++) {\\n                int z = zero[j];\\n                if (z >= i) {\\n                    sum += j;\\n                    zero.erase(zero.begin()+j);\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                return -1;\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    int countEndingZeros(vector<int>& row) {\\n        int n = row.size();\\n        int count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (row[i] == 0) {\\n                count++;\\n            } else {\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772878,
                "title": "java-time-100-space-100",
                "content": "count[i] is repreasent the trailing 0 count at row i\\nValid condition: count[i] >= n - 1- i\\nif there is a count array [3,4,1,2], how many steps does it need to move? The answer is 0.\\nWe don\\'t need to sort it as [4,3,2,1] because it has already matched the valid condition. \\nThat\\'s why I don\\'t need to use the sort algorithm. \\n\\nif there is a count array [1,2,3,4], what would I do? \\nAt row 0, it is invalid because 1 < 4 - 1 - 0. Therefore, I need to find another row count[i] >= 4 - 1- 0;\\nAfter iteration, I found row 2 is matched count[2] >= 4-1-0, and I move row 2 to row 0. ==> [3,1,2,4]\\nThen, I start to check the row 1 and move ==> [3,2,1,4]\\nAnd the row 2 and row 3 are already valid. The final count array is [3,2,1,4]\\n\\nif the count array [0,2,3,0]\\nrow 0 ==> [3,0,2,0]\\nrow 1 ==> [3,2,0,0]\\nrow 2 ==> invalid\\n==> invalid array\\n\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] counts = new int[grid.length];\\n        int n = grid.length;\\n        int steps = 0;\\n        // count contiguous zero from right to left\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 0) {\\n                    counts[i]++;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (counts[i] < n - 1 - i) {\\n                boolean isValid = false;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (counts[j] >= n-1-i) {\\n                        steps+= move(counts,i,j);\\n                        isValid = true;\\n                        break;\\t\\n                    }\\n                }\\n                if (!isValid) return -1;\\n            } \\n        }\\n        return steps;\\n    }\\n    private int move(int[] count, int dst, int src) {\\n        int m = 0;\\n        for (int i = src; i > dst; i--) {\\n            swap(count, i, i-1);\\n            m++;\\n        }\\n        return m;\\n    }\\n    private void swap(int[] ary, int i, int j) {\\n        int temp = ary[i];\\n        ary[i] = ary[j];\\n        ary[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[][] grid) {\\n        int[] counts = new int[grid.length];\\n        int n = grid.length;\\n        int steps = 0;\\n        // count contiguous zero from right to left\\n        for (int i = 0; i < n; i++) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (grid[i][j] == 0) {\\n                    counts[i]++;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (counts[i] < n - 1 - i) {\\n                boolean isValid = false;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (counts[j] >= n-1-i) {\\n                        steps+= move(counts,i,j);\\n                        isValid = true;\\n                        break;\\t\\n                    }\\n                }\\n                if (!isValid) return -1;\\n            } \\n        }\\n        return steps;\\n    }\\n    private int move(int[] count, int dst, int src) {\\n        int m = 0;\\n        for (int i = src; i > dst; i--) {\\n            swap(count, i, i-1);\\n            m++;\\n        }\\n        return m;\\n    }\\n    private void swap(int[] ary, int i, int j) {\\n        int temp = ary[i];\\n        ary[i] = ary[j];\\n        ary[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772760,
                "title": "python-greedy-548-ms-100-time-100-space",
                "content": "This greedy idea was taken from Larry\\'s apprach with a twist.\\nHere we\\'re counting number of zeroes in the end each row and then we just count the min swaps needed to sort the list of integers.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr, N = [], len(grid)\\n        if N == 1:\\n            return -1 if grid[0][0] else 0\\n        \\n        issorted = True\\n        for i in range(N):\\n            zeroes = 0\\n            for j in range(N-1, -1, -1):\\n                if grid[i][j]: \\n                    break\\n                zeroes += 1\\n            arr.append(zeroes)\\n            if len(arr) > 1 and issorted:\\n                issorted = arr[-2] > arr[-1]\\n        \\n        if issorted:\\n            return 0\\n        \\n        swaps = 0\\n        for i in range(N - 1, -1, -1):\\n            lans = 0\\n            for j in range(N):\\n                if arr[j] is not None and arr[j] >= i:\\n                    arr[j] = None\\n                    swaps += lans\\n                    break\\n                elif arr[j] is not None:\\n                    lans += 1\\n            else:\\n                return -1\\n        \\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, grid: List[List[int]]) -> int:\\n        arr, N = [], len(grid)\\n        if N == 1:\\n            return -1 if grid[0][0] else 0\\n        \\n        issorted = True\\n        for i in range(N):\\n            zeroes = 0\\n            for j in range(N-1, -1, -1):\\n                if grid[i][j]: \\n                    break\\n                zeroes += 1\\n            arr.append(zeroes)\\n            if len(arr) > 1 and issorted:\\n                issorted = arr[-2] > arr[-1]\\n        \\n        if issorted:\\n            return 0\\n        \\n        swaps = 0\\n        for i in range(N - 1, -1, -1):\\n            lans = 0\\n            for j in range(N):\\n                if arr[j] is not None and arr[j] >= i:\\n                    arr[j] = None\\n                    swaps += lans\\n                    break\\n                elif arr[j] is not None:\\n                    lans += 1\\n            else:\\n                return -1\\n        \\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772411,
                "title": "my-solution-beats-100-answer",
                "content": "```\\nint minSwaps(vector<vector<int>>& grid){\\n    int ans = 0;\\n    int n = grid.size();\\n    if (!n) return 0;\\n    vector<int> vec(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n        int count = 0;\\n        for (int j = n - 1; j >= 0; --j) {\\n            if (grid[i][j] == 1) break;\\n            ++count;\\n        }\\n        vec[i] = count;\\n    }\\n\\n    int limit = n - 1;\\n    while (limit) {\\n        int count = 0;\\n        bool flag = false;\\n        for (int i = 0; i < n; ++i) {\\n            if (vec[i] >= limit) {\\n                ans += count;\\n                vec[i] = -1;\\n                flag = true;\\n                break;\\n            } else if (vec[i] >= 0) {\\n                ++count;\\n            }\\n        }\\n        if (!flag) return -1;\\n        limit--;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSwaps(vector<vector<int>>& grid){\\n    int ans = 0;\\n    int n = grid.size();\\n    if (!n) return 0;\\n    vector<int> vec(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n        int count = 0;\\n        for (int j = n - 1; j >= 0; --j) {\\n            if (grid[i][j] == 1) break;\\n            ++count;\\n        }\\n        vec[i] = count;\\n    }\\n\\n    int limit = n - 1;\\n    while (limit) {\\n        int count = 0;\\n        bool flag = false;\\n        for (int i = 0; i < n; ++i) {\\n            if (vec[i] >= limit) {\\n                ans += count;\\n                vec[i] = -1;\\n                flag = true;\\n                break;\\n            } else if (vec[i] >= 0) {\\n                ++count;\\n            }\\n        }\\n        if (!flag) return -1;\\n        limit--;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575271,
                "content": [
                    {
                        "username": "winner07",
                        "content": "see, at the end we have to swap if current value is lesser than required one.  But if we swap with first greater element then all middle elements will be shifted by 1 unit. No matter which greater value we choose whether first occurring one or last occuring one, those middle element are bound to shift.\\nSo now  consider a element in this middle range( say at present it is smaller than its required value). since it is shifted by one, the distance between its required value and its postion will be either remains same or will decrease( if larger required value is in middle range then diff will be same, else the middle element will be shifted by one and larger element will remains at  same postion hence decreasing distnace between them). thus required steps will decrease. So if we choose first greater element, then it will have high chances of reducing distance as compared to that of last occuring greater element. \\n \\n Sorry for bad english. I have tried my best to make myself clear.  Please write in comments. i will try my best to make it clearer(if possible). Please upvote if you liked it.\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Process Tasks Using Servers",
        "question_content": "<p>You are given two <strong>0-indexed</strong> integer arrays <code>servers</code> and <code>tasks</code> of lengths <code>n</code>​​​​​​ and <code>m</code>​​​​​​ respectively. <code>servers[i]</code> is the <strong>weight</strong> of the <code>i<sup>​​​​​​th</sup></code>​​​​ server, and <code>tasks[j]</code> is the <strong>time needed</strong> to process the <code>j<sup>​​​​​​th</sup></code>​​​​ task <strong>in seconds</strong>.</p>\n\n<p>Tasks are assigned to the servers using a <strong>task queue</strong>. Initially, all servers are free, and the queue is <strong>empty</strong>.</p>\n\n<p>At second <code>j</code>, the <code>j<sup>th</sup></code> task is <strong>inserted</strong> into the queue (starting with the <code>0<sup>th</sup></code> task being inserted at second <code>0</code>). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the <strong>smallest weight</strong>, and in case of a tie, it is assigned to a free server with the <strong>smallest index</strong>.</p>\n\n<p>If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned <strong>in order of insertion</strong> following the weight and index priorities above.</p>\n\n<p>A server that is assigned task <code>j</code> at second <code>t</code> will be free again at second <code>t + tasks[j]</code>.</p>\n\n<p>Build an array <code>ans</code>​​​​ of length <code>m</code>, where <code>ans[j]</code> is the <strong>index</strong> of the server the <code>j<sup>​​​​​​th</sup></code> task will be assigned to.</p>\n\n<p>Return <em>the array </em><code>ans</code>​​​​.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> servers = [3,3,2], tasks = [1,2,3,2,1,2]\n<strong>Output:</strong> [2,2,0,2,1,2]\n<strong>Explanation: </strong>Events in chronological order go as follows:\n- At second 0, task 0 is added and processed using server 2 until second 1.\n- At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.\n- At second 2, task 2 is added and processed using server 0 until second 5.\n- At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.\n- At second 4, task 4 is added and processed using server 1 until second 5.\n- At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]\n<strong>Output:</strong> [1,4,1,4,1,3,2]\n<strong>Explanation: </strong>Events in chronological order go as follows: \n- At second 0, task 0 is added and processed using server 1 until second 2.\n- At second 1, task 1 is added and processed using server 4 until second 2.\n- At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. \n- At second 3, task 3 is added and processed using server 4 until second 7.\n- At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. \n- At second 5, task 5 is added and processed using server 3 until second 7.\n- At second 6, task 6 is added and processed using server 2 until second 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>servers.length == n</code></li>\n\t<li><code>tasks.length == m</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= servers[i], tasks[j] &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1239780,
                "title": "java-two-heaps-time-o-n-m-logn-detailed-explanation",
                "content": "We use two heaps, one is for free servers, one is for used server.\\n\\nFree server heap is sorted based on weight and index.\\n\\nUsed server heap is sorted on available time. \\n\\nEvery time, we first pop from used heap and add to free server heap if the available time is smaller or equal to current task time. If the free server is empty, then we use the used server with smallest available time. \\n\\nTime: `O((M+N)*logN)`\\nSpace: `O(N)`\\n\\n```\\nclass Solution {\\n    //O((M + N) * logN)\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        //since if there are multiple tasks that need to be assigned, we need to assign in  the order of index\\n        //so we can go through tasks from left to right\\n        //and ask what could be the server for this task\\n        //For which server it can be assigned, it is determined by which servers are avaiable\\n        //we just need to choose from the servers that are available with smallest weight\\n        //Like in priorityQueue\\n        //So if we have a group of servers with their own next available time\\n        //if next avaibable time <= the execution time of the task, we need to choose the server with smallest weight\\n        //can we have 2 PQ, one is sorted by weight and index, this is currently avaiable pq\\n        //one is sorted by available time, this is currently used server pq\\n        //[weight, index, avaialbe_time]\\n        PriorityQueue<int[]> freeServers = new PriorityQueue<>((a, b) -> (a[0] != b[0]) ? (a[0] - b[0]) : (a[1] - b[1]));\\n        PriorityQueue<int[]> usedQueue = new PriorityQueue<>((a, b)->(a[2] != b[2]) ? (a[2] - b[2]) : ((a[0] != b[0]) ? (a[0] - b[0]) : (a[1] - b[1])));\\n        int n = servers.length;\\n        int m = tasks.length;\\n        //O(nLogn)\\n        for (int i = 0; i < n; i++) {\\n            freeServers.add(new int[] {servers[i], i, 0});\\n        }\\n        int[] res = new int[m];\\n        //O(m * Logn)\\n        for (int i = 0; i < m; i++) {\\n            int t = tasks[i];\\n            while (!usedQueue.isEmpty() && usedQueue.peek()[2] <= i) {\\n                freeServers.add(usedQueue.poll());\\n            }\\n            //If there is no free servers now, we can find the used server with smallest available time\\n            if (freeServers.isEmpty()) {\\n                int[] cur = usedQueue.poll();\\n                res[i] = cur[1];\\n                cur[2] += t;\\n                usedQueue.add(cur);\\n            } else {\\n                int[] cur = freeServers.poll();\\n                res[i] = cur[1];\\n                cur[2] = i + t;\\n                usedQueue.add(cur);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //O((M + N) * logN)\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        //since if there are multiple tasks that need to be assigned, we need to assign in  the order of index\\n        //so we can go through tasks from left to right\\n        //and ask what could be the server for this task\\n        //For which server it can be assigned, it is determined by which servers are avaiable\\n        //we just need to choose from the servers that are available with smallest weight\\n        //Like in priorityQueue\\n        //So if we have a group of servers with their own next available time\\n        //if next avaibable time <= the execution time of the task, we need to choose the server with smallest weight\\n        //can we have 2 PQ, one is sorted by weight and index, this is currently avaiable pq\\n        //one is sorted by available time, this is currently used server pq\\n        //[weight, index, avaialbe_time]\\n        PriorityQueue<int[]> freeServers = new PriorityQueue<>((a, b) -> (a[0] != b[0]) ? (a[0] - b[0]) : (a[1] - b[1]));\\n        PriorityQueue<int[]> usedQueue = new PriorityQueue<>((a, b)->(a[2] != b[2]) ? (a[2] - b[2]) : ((a[0] != b[0]) ? (a[0] - b[0]) : (a[1] - b[1])));\\n        int n = servers.length;\\n        int m = tasks.length;\\n        //O(nLogn)\\n        for (int i = 0; i < n; i++) {\\n            freeServers.add(new int[] {servers[i], i, 0});\\n        }\\n        int[] res = new int[m];\\n        //O(m * Logn)\\n        for (int i = 0; i < m; i++) {\\n            int t = tasks[i];\\n            while (!usedQueue.isEmpty() && usedQueue.peek()[2] <= i) {\\n                freeServers.add(usedQueue.poll());\\n            }\\n            //If there is no free servers now, we can find the used server with smallest available time\\n            if (freeServers.isEmpty()) {\\n                int[] cur = usedQueue.poll();\\n                res[i] = cur[1];\\n                cur[2] += t;\\n                usedQueue.add(cur);\\n            } else {\\n                int[] cur = freeServers.poll();\\n                res[i] = cur[1];\\n                cur[2] = i + t;\\n                usedQueue.add(cur);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239822,
                "title": "wrong-test-results",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // System.out.println(servers.length);\\n        // System.out.println(servers[36] + \" ; \" + servers[56]);\\n        int N = tasks.length;\\n        int[] res = new int[N];\\n        PriorityQueue<int[]> available = new PriorityQueue<>((s1, s2) -> {\\n            if (s1[1] == s2[1]) return s1[0] - s2[0];\\n            return s1[1] - s2[1];\\n        }); // (index, weight), sort by weight first then index, increasingly\\n        PriorityQueue<int[]> running = new PriorityQueue<>((s1, s2) -> s1[1] - s2[1]); // (index, finishing time), sort by finishing time increasingly\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            available.add(new int[] {i, servers[i]});\\n        }\\n        int i = 0;\\n        int time = 0;\\n        while (i < N) {\\n            while (!running.isEmpty() && running.peek()[1] <= time) {\\n                int[] freeServer = running.poll();\\n                int index = freeServer[0];\\n                available.offer(new int[] {index, servers[index]});\\n            }\\n            if (!available.isEmpty() && i < N) {\\n                System.out.println(\"free : \" + i + \" ; \"+ Arrays.toString(availableList(available).toArray()));\\n                int[] freeServer = available.poll();\\n                running.offer(new int[] {freeServer[0], time + tasks[i]});\\n                res[i++] = freeServer[0];\\n            }\\n            time++;\\n        }\\n        return res;\\n    }\\n    \\n    private List<String> availableList(PriorityQueue<int[]> pq) {\\n        List<String> res = new ArrayList<>();\\n        for (int[] p : pq) {\\n            res.add(p[0] + \" - \" + p[1]);\\n        }\\n        return res;\\n    }\\n}\\n```\\nTest case:\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nMy result: `[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,56,36,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\n`\\nExpected result: `[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\n`\\nIt\\'s different for task at index 147, when both servers 56 (weight 147), 36 (weight 889) are available, I picked 56 because it has smaller weight. I don\\'t know why the expected result picks 36 instead.\\n\\n\\nCorrect code per @SkyWalker12138\\n```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // System.out.println(servers.length);\\n        // System.out.println(servers[36] + \" ; \" + servers[56]);\\n        int N = tasks.length;\\n        int[] res = new int[N];\\n        PriorityQueue<int[]> available = new PriorityQueue<>((s1, s2) -> {\\n            if (s1[1] == s2[1]) return s1[0] - s2[0];\\n            return s1[1] - s2[1];\\n        }); // (index, weight), sort by weight first then index, increasingly\\n        PriorityQueue<int[]> running = new PriorityQueue<>((s1, s2) -> s1[1] - s2[1]); // (index, finishing time), sort by finishing time increasingly\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            available.add(new int[] {i, servers[i]});\\n        }\\n        int i = 0;\\n        int time = 0;\\n        while (i < N) {\\n            while (!running.isEmpty() && running.peek()[1] <= time) {\\n                int[] freeServer = running.poll();\\n                int index = freeServer[0];\\n                available.offer(new int[] {index, servers[index]});\\n            }\\n            while (!available.isEmpty() && time >= i && i < N) {\\n                int[] freeServer = available.poll();\\n                running.offer(new int[] {freeServer[0], time + tasks[i]});\\n                res[i++] = freeServer[0];\\n            }\\n            if (available.isEmpty()) {\\n                time = running.peek()[1];\\n            } else {\\n                time = i;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // System.out.println(servers.length);\\n        // System.out.println(servers[36] + \" ; \" + servers[56]);\\n        int N = tasks.length;\\n        int[] res = new int[N];\\n        PriorityQueue<int[]> available = new PriorityQueue<>((s1, s2) -> {\\n            if (s1[1] == s2[1]) return s1[0] - s2[0];\\n            return s1[1] - s2[1];\\n        }); // (index, weight), sort by weight first then index, increasingly\\n        PriorityQueue<int[]> running = new PriorityQueue<>((s1, s2) -> s1[1] - s2[1]); // (index, finishing time), sort by finishing time increasingly\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            available.add(new int[] {i, servers[i]});\\n        }\\n        int i = 0;\\n        int time = 0;\\n        while (i < N) {\\n            while (!running.isEmpty() && running.peek()[1] <= time) {\\n                int[] freeServer = running.poll();\\n                int index = freeServer[0];\\n                available.offer(new int[] {index, servers[index]});\\n            }\\n            if (!available.isEmpty() && i < N) {\\n                System.out.println(\"free : \" + i + \" ; \"+ Arrays.toString(availableList(available).toArray()));\\n                int[] freeServer = available.poll();\\n                running.offer(new int[] {freeServer[0], time + tasks[i]});\\n                res[i++] = freeServer[0];\\n            }\\n            time++;\\n        }\\n        return res;\\n    }\\n    \\n    private List<String> availableList(PriorityQueue<int[]> pq) {\\n        List<String> res = new ArrayList<>();\\n        for (int[] p : pq) {\\n            res.add(p[0] + \" - \" + p[1]);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // System.out.println(servers.length);\\n        // System.out.println(servers[36] + \" ; \" + servers[56]);\\n        int N = tasks.length;\\n        int[] res = new int[N];\\n        PriorityQueue<int[]> available = new PriorityQueue<>((s1, s2) -> {\\n            if (s1[1] == s2[1]) return s1[0] - s2[0];\\n            return s1[1] - s2[1];\\n        }); // (index, weight), sort by weight first then index, increasingly\\n        PriorityQueue<int[]> running = new PriorityQueue<>((s1, s2) -> s1[1] - s2[1]); // (index, finishing time), sort by finishing time increasingly\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            available.add(new int[] {i, servers[i]});\\n        }\\n        int i = 0;\\n        int time = 0;\\n        while (i < N) {\\n            while (!running.isEmpty() && running.peek()[1] <= time) {\\n                int[] freeServer = running.poll();\\n                int index = freeServer[0];\\n                available.offer(new int[] {index, servers[index]});\\n            }\\n            while (!available.isEmpty() && time >= i && i < N) {\\n                int[] freeServer = available.poll();\\n                running.offer(new int[] {freeServer[0], time + tasks[i]});\\n                res[i++] = freeServer[0];\\n            }\\n            if (available.isEmpty()) {\\n                time = running.peek()[1];\\n            } else {\\n                time = i;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239767,
                "title": "python-3-simulation-heap-solution",
                "content": "**intuition**\\n* use two heaps to simulate\\n* first heap to hold all the available servers \\n* second heap to hold all the servers that are in use\\n* popping criteria for the first heap is by weight and index\\n* popping criteria for the second is by time\\n\\n**analysis**\\ntime: O(T\\\\*lg(S)) S the length of servers, T the length of tasks\\nspace: O(S+T) \\n\\n**solution**\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res = []\\n        h1 = [[weight, i ,0] for i, weight in enumerate(servers)]\\n        h2 = []\\n        heapq.heapify(h1)\\n        for j, task in enumerate(tasks):\\n            while h2 and h2[0][0] <= j or not h1:\\n                time, weight, i = heapq.heappop(h2)\\n                heapq.heappush(h1, [weight, i, time])\\n            weight, i, time = heapq.heappop(h1)\\n            res.append(i)\\n            heapq.heappush(h2, [max(time,j)+task, weight, i])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res = []\\n        h1 = [[weight, i ,0] for i, weight in enumerate(servers)]\\n        h2 = []\\n        heapq.heapify(h1)\\n        for j, task in enumerate(tasks):\\n            while h2 and h2[0][0] <= j or not h1:\\n                time, weight, i = heapq.heappop(h2)\\n                heapq.heappush(h1, [weight, i, time])\\n            weight, i, time = heapq.heappop(h1)\\n            res.append(i)\\n            heapq.heappush(h2, [max(time,j)+task, weight, i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241936,
                "title": "two-heaps",
                "content": "This one has a bunch of edge cases. I first solved it using two heaps and a queue, but solving it without a queue was tricky.\\n \\nHere, we have two min heaps, ordered by `[time, weight, index]`: available and busy. First, we put all servers into the available heap with time equals to zero.\\n \\nAs we process our tasks:\\n- Move servers that have finished (`time <= t`) from `busy` to `avail`.\\n- Pick the top server from the `avail` heap and move it to the `busy` heap with time = `t + tasks[t]`.\\n\\t- This is where we record the index of the server for that task.\\n \\nWhat happens if no servers are available? In this case, the server that is closest to finishing its task will pick up the new task. So:\\n- We move the top server from `busy` to `avail` heap.\\n- Then we move it back to the `busy` heap, but this time we extend the completion time for the duration of the new task `time + task[t]`.\\n\\t- In other words, the time is `t + task[t]` if we have an available server vs. `time + task[t]`.\\n\\n> Note that the additional test cases were added after the fact, so we need to use long to avoid overflow.\\n\\n**C++**\\n```cpp\\nvector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n    priority_queue<array<long, 3>, vector<array<long, 3>>, greater<array<long, 3>>> avail, busy;\\n    vector<int> res;\\n    for (int i = 0; i < servers.size(); ++i)\\n        avail.push({ 0, servers[i], i });\\n    for (long t = 0; t < tasks.size(); ++t) {\\n        while(!busy.empty() && (busy.top()[0] <= t || avail.empty())) {\\n            auto [time, w, i] = busy.top(); busy.pop();\\n            avail.push({ time <= t ? 0 : time, w, i });\\n        }\\n        auto [time, w, s] = avail.top(); avail.pop();\\n        busy.push({ max(time, t) + tasks[t], w, s });\\n        res.push_back(s);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n    priority_queue<array<long, 3>, vector<array<long, 3>>, greater<array<long, 3>>> avail, busy;\\n    vector<int> res;\\n    for (int i = 0; i < servers.size(); ++i)\\n        avail.push({ 0, servers[i], i });\\n    for (long t = 0; t < tasks.size(); ++t) {\\n        while(!busy.empty() && (busy.top()[0] <= t || avail.empty())) {\\n            auto [time, w, i] = busy.top(); busy.pop();\\n            avail.push({ time <= t ? 0 : time, w, i });\\n        }\\n        auto [time, w, s] = avail.top(); avail.pop();\\n        busy.push({ max(time, t) + tasks[t], w, s });\\n        res.push_back(s);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239810,
                "title": "c-easy-understand-solution-priority-queue",
                "content": "Use two min-heap to record current free servers and busy servers.\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        \\n        // store {weight, server_index}\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> free_server_pq;\\n        // store {end_time, server_index}, use long instead of int because the time maybe overflow\\n        priority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> busy_server_pq;\\n        vector<int> ans(m);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            free_server_pq.push({servers[i], i});\\n        }\\n        \\n        long time = 0;\\n        for (int i = 0; i < m; ++i) {\\n            time = max(static_cast<long>(i), time);\\n            if (free_server_pq.empty() && busy_server_pq.top().first > time) {\\n                time = busy_server_pq.top().first;\\n            }\\n            \\n            while (!busy_server_pq.empty() && busy_server_pq.top().first <= time) {\\n                auto &info = busy_server_pq.top();\\n                int server_idx = static_cast<int>(info.second);\\n                free_server_pq.push({servers[server_idx], server_idx});\\n                busy_server_pq.pop();\\n            }\\n            \\n            auto &info = free_server_pq.top();\\n            busy_server_pq.push({time + tasks[i], info.second});\\n            ans[i] = info.second;\\n            free_server_pq.pop();\\n        }\\n        \\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        \\n        // store {weight, server_index}\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> free_server_pq;\\n        // store {end_time, server_index}, use long instead of int because the time maybe overflow\\n        priority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> busy_server_pq;\\n        vector<int> ans(m);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            free_server_pq.push({servers[i], i});\\n        }\\n        \\n        long time = 0;\\n        for (int i = 0; i < m; ++i) {\\n            time = max(static_cast<long>(i), time);\\n            if (free_server_pq.empty() && busy_server_pq.top().first > time) {\\n                time = busy_server_pq.top().first;\\n            }\\n            \\n            while (!busy_server_pq.empty() && busy_server_pq.top().first <= time) {\\n                auto &info = busy_server_pq.top();\\n                int server_idx = static_cast<int>(info.second);\\n                free_server_pq.push({servers[server_idx], server_idx});\\n                busy_server_pq.pop();\\n            }\\n            \\n            auto &info = free_server_pq.top();\\n            busy_server_pq.push({time + tasks[i], info.second});\\n            ans[i] = info.second;\\n            free_server_pq.pop();\\n        }\\n        \\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239862,
                "title": "python-two-min-heaps-o-n-mlogn",
                "content": "Use one heap to keep track of servers available and another heap to keep track of the tasks that are still in progress.\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        servers_available = [(w, i) for i,w in enumerate(servers)]\\n        heapify(servers_available)\\n        tasks_in_progress = []\\n        res = []\\n        time = 0\\n        for j,task in enumerate(tasks):\\n            time = max(time, j)\\n            if not servers_available:\\n                time = tasks_in_progress[0][0]\\n            while tasks_in_progress and tasks_in_progress[0][0] <= time:\\n                heappush(servers_available, heappop(tasks_in_progress)[1])\\n            res.append(servers_available[0][1])\\n            heappush(tasks_in_progress, (time + task, heappop(servers_available)))\\n        return res\\n```\\nRun-time analysis:\\n`heapify` takes `O(n)` time. The loop iterates `m` times and both heaps have sizes no more than `n`. Thus, the overall run-time is `O(n + mlogn)`.",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        servers_available = [(w, i) for i,w in enumerate(servers)]\\n        heapify(servers_available)\\n        tasks_in_progress = []\\n        res = []\\n        time = 0\\n        for j,task in enumerate(tasks):\\n            time = max(time, j)\\n            if not servers_available:\\n                time = tasks_in_progress[0][0]\\n            while tasks_in_progress and tasks_in_progress[0][0] <= time:\\n                heappush(servers_available, heappop(tasks_in_progress)[1])\\n            res.append(servers_available[0][1])\\n            heappush(tasks_in_progress, (time + task, heappop(servers_available)))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240218,
                "title": "poorly-worded-problem-better-explanation-and-c-priority-queue-solution",
                "content": "The problem is explained terribly in the statement and it is easy to miss the salient details.\\n\\n**Actual Problem Statement**\\n\\tThere is a queue of `M` tasks where `ith` task becomes available at the `ith` second and takes a duration of `tasks[i]` to be processed. We have `N` servers each with a `weight` and `index` of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least `weight`. If there are multiple servers with same `weight`, we pick the one with lowest `index`. When scheduling at time `t`, the selected server will be free again at `t + tasks[i]`.\\n\\t\\nScheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers.\\n\\n**Solution**\\n1. We maintain a task_queue which represents all the tasks that have arrived *so far*, in order.\\n2. We maintain a queue of free servers sorted first by their weight and then by their index.\\n3. We maintain a queue of busy servers sorted by when they will be free so that they can be moved onto free server queue later.\\n\\nWe can implement (2) and (3) by using priority queue. For (1), we can keep track of an extrinsic time variable and push new tasks to task_queue as and when we are ready to receive them.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> free, busy; \\n        for (int i = 0; i < servers.size(); ++i) {\\n            free.push(vector<long long>{servers[i], i});\\n        }\\n        vector<int> ans;\\n        long long time = 0;\\n        queue<int> task_queue;\\n        while (ans.size() < tasks.size()) { \\n            // Bring all eligible tasks to task_queue.\\n            for (int i = ans.size() + task_queue.size(); i <= time && i < tasks.size(); ++i) {\\n                task_queue.push(tasks[i]);\\n            }\\n            // Bring all eligible servers to free queue.\\n            while (!busy.empty() && busy.top()[0] <= time) {\\n                auto& top = busy.top();\\n                free.push(vector<long long>{top[1], top[2]});\\n                busy.pop();\\n            }\\n            // If we have no servers, we cannot match until one of the servers becomes free.\\n            if (free.empty()) {\\n                time = busy.top()[0];\\n                continue;\\n            }\\n            while(!task_queue.empty() && !free.empty()) {\\n                // Now we just take the first task and first server as per defined priority and match the two.\\n                int task = task_queue.front(); \\n                auto& top = free.top();\\n                ans.push_back(top[1]);\\n                busy.push(vector<long long>{time + task, top[0], top[1]});\\n                task_queue.pop();\\n                free.pop();\\n            }\\n            // Only increment time to receive new tasks once we have processed all tasks so far.\\n            if (task_queue.empty()) time++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> free, busy; \\n        for (int i = 0; i < servers.size(); ++i) {\\n            free.push(vector<long long>{servers[i], i});\\n        }\\n        vector<int> ans;\\n        long long time = 0;\\n        queue<int> task_queue;\\n        while (ans.size() < tasks.size()) { \\n            // Bring all eligible tasks to task_queue.\\n            for (int i = ans.size() + task_queue.size(); i <= time && i < tasks.size(); ++i) {\\n                task_queue.push(tasks[i]);\\n            }\\n            // Bring all eligible servers to free queue.\\n            while (!busy.empty() && busy.top()[0] <= time) {\\n                auto& top = busy.top();\\n                free.push(vector<long long>{top[1], top[2]});\\n                busy.pop();\\n            }\\n            // If we have no servers, we cannot match until one of the servers becomes free.\\n            if (free.empty()) {\\n                time = busy.top()[0];\\n                continue;\\n            }\\n            while(!task_queue.empty() && !free.empty()) {\\n                // Now we just take the first task and first server as per defined priority and match the two.\\n                int task = task_queue.front(); \\n                auto& top = free.top();\\n                ans.push_back(top[1]);\\n                busy.push(vector<long long>{time + task, top[0], top[1]});\\n                task_queue.pop();\\n                free.pop();\\n            }\\n            // Only increment time to receive new tasks once we have processed all tasks so far.\\n            if (task_queue.empty()) time++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239922,
                "title": "heap-map-detailed-and-simple-explanation",
                "content": "* We use a `min-heap` to store the servers which are available to use at a given time `\\'t\\'`.\\n* We use a map `free` of type <int, vector<int,int>>, where key is the **time of completion** and value is a **vector of servers** that get free at that time.\\n* We use a variable `curr` to keep a track of the current process that we need to execute, as they\\'re executed in order of their indices.\\n* For a given time `\\'t\\'`, we add all servers present at free[t] into the min heap and then pop and assign these to the processes. We also calculate the time of completion of each process that we assign a server to, as add the key value pair of `{time of completion, sever assigned}` into the **free** map.\\n*  The last crucial optimisation is that, in case the min heap is empty, this means that we have no servers left to use as all are busy, so instead of incrementing our time by 1, we set our time equal to the next smallest time of freedom/completion from the `free `map.\\n```\\ntypedef pair<int,int> pi;\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        vector<pi>serv;\\n        for(int i = 0; i<servers.size(); i++)serv.push_back({servers[i],i});\\n        int curr = 0;\\n        priority_queue<pi, vector<pi>, greater<pi>>mi(serv.begin(),serv.end());\\n        vector<int>ans;\\n        map<int,vector<pi>>free;\\n        int t = 0;\\n        while(1){\\n            for(auto s : free[t])mi.push(s);\\n            free.erase(t);\\n            while(curr<=t && curr<tasks.size() && !mi.empty()){\\n                auto se = mi.top();\\n                mi.pop();\\n                free[t+tasks[curr]].push_back(se);\\n                ans.push_back(se.second);\\n                curr++;\\n            }\\n            if(curr>=tasks.size())break;\\n            if(mi.empty()){\\n                auto it = free.begin();\\n                t = it->first;\\n            }\\n            else t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,int> pi;\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        vector<pi>serv;\\n        for(int i = 0; i<servers.size(); i++)serv.push_back({servers[i],i});\\n        int curr = 0;\\n        priority_queue<pi, vector<pi>, greater<pi>>mi(serv.begin(),serv.end());\\n        vector<int>ans;\\n        map<int,vector<pi>>free;\\n        int t = 0;\\n        while(1){\\n            for(auto s : free[t])mi.push(s);\\n            free.erase(t);\\n            while(curr<=t && curr<tasks.size() && !mi.empty()){\\n                auto se = mi.top();\\n                mi.pop();\\n                free[t+tasks[curr]].push_back(se);\\n                ans.push_back(se.second);\\n                curr++;\\n            }\\n            if(curr>=tasks.size())break;\\n            if(mi.empty()){\\n                auto it = free.begin();\\n                t = it->first;\\n            }\\n            else t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240042,
                "title": "c-two-minheaps-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        queue<int> pendingTasks;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > freeServers, busyServers;\\n        \\n        vector<int> ans;\\n        int timer = 0;\\n        \\n        for(int i = 0; i < servers.size(); i++) {\\n            freeServers.push({servers[i], i}); // Storing {weight, serverIndex}\\n        }\\n        for(int j = 0; j < tasks.size(); j++) {\\n            pendingTasks.push(j);\\n        }\\n        \\n        //  O (m * logn)\\n        \\n        while(!pendingTasks.empty()) {\\n\\t\\t\\t// Freeing the busy server till current time\\n            while(!busyServers.empty() and busyServers.top().first <= timer) {\\n                auto p = busyServers.top();\\n                busyServers.pop();\\n                freeServers.push({servers[p.second], p.second});\\n            }\\n            \\n        // Assigning multiple tasks if possible\\n            while(!freeServers.empty() and !pendingTasks.empty() and pendingTasks.front() <= timer) {\\n                int i = pendingTasks.front();\\n                auto p = freeServers.top();\\n                freeServers.pop();\\n                busyServers.push({timer + tasks[i], p.second}); // storing {time when server get free, serverIndex}\\n                pendingTasks.pop();\\n                ans.push_back(p.second);\\n            }\\n\\t\\t\\t// If no free server is available directly jump to the closest time when atleast one server is going to get free\\n            if(freeServers.empty()) {\\n                timer = busyServers.top().first;\\n                continue;\\n            }\\n            timer++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        queue<int> pendingTasks;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > freeServers, busyServers;\\n        \\n        vector<int> ans;\\n        int timer = 0;\\n        \\n        for(int i = 0; i < servers.size(); i++) {\\n            freeServers.push({servers[i], i}); // Storing {weight, serverIndex}\\n        }\\n        for(int j = 0; j < tasks.size(); j++) {\\n            pendingTasks.push(j);\\n        }\\n        \\n        //  O (m * logn)\\n        \\n        while(!pendingTasks.empty()) {\\n\\t\\t\\t// Freeing the busy server till current time\\n            while(!busyServers.empty() and busyServers.top().first <= timer) {\\n                auto p = busyServers.top();\\n                busyServers.pop();\\n                freeServers.push({servers[p.second], p.second});\\n            }\\n            \\n        // Assigning multiple tasks if possible\\n            while(!freeServers.empty() and !pendingTasks.empty() and pendingTasks.front() <= timer) {\\n                int i = pendingTasks.front();\\n                auto p = freeServers.top();\\n                freeServers.pop();\\n                busyServers.push({timer + tasks[i], p.second}); // storing {time when server get free, serverIndex}\\n                pendingTasks.pop();\\n                ans.push_back(p.second);\\n            }\\n\\t\\t\\t// If no free server is available directly jump to the closest time when atleast one server is going to get free\\n            if(freeServers.empty()) {\\n                timer = busyServers.top().first;\\n                continue;\\n            }\\n            timer++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635716,
                "title": "java-heap-solution-interview-code-with-classes",
                "content": "The question itself mentions that you need to choose minimum weight server with least index in order to schedule a given job.\\nThis alone tells us that \"Greedy\" choice at each step should work.\\n\\nSo, everytime we need to schedule a task, we need to find a candidate server that satisfies \"Greedy\" requirement above. So, at current timestamp\\n1. Check all servers that are free at this point and add them to a PQ\\n2. Poll the PQ and assign tasks to the free servers\\n\\n```\\n    private class Server {\\n        int weight;\\n        int index;\\n\\n        public Server(int weight, int index) {\\n            this.weight = weight;\\n            this.index = index;\\n        }\\n    }\\n\\t\\n\\t// Represents task-server assignment\\n    private class Assign {\\n\\t\\t// time at which this server will become free again\\n        int freeTime;\\n        Server server;\\n\\n        public Assign(int freeTime, Server server) {\\n            this.freeTime = freeTime;\\n            this.server = server;\\n        }\\n    }\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n\\t\\t// PQ to store servers (server with least weight or least index is polled first)\\n        Queue<Server> serverQueue = new PriorityQueue<>((s1, s2) -> {\\n            if (s1.weight - s2.weight != 0)\\n                return s1.weight - s2.weight;\\n            return s1.index - s2.index;\\n        });\\n\\t\\t\\n\\t\\t// PQ to store assigned servers (server with least freeTime is polled first)\\n        Queue<Assign> assignQueue = new PriorityQueue<>(Comparator.comparingInt(a -> a.freeTime));\\n\\n        for (int i = 0; i < servers.length; ++i)\\n            serverQueue.add(new Server(servers[i], i));\\n\\n        int j = 0;\\n        int time = 0;\\n        int[] ans = new int[tasks.length];\\n\\n        while (j < tasks.length) {\\n\\t\\t\\t// check what all servers have become free\\n            while (!assignQueue.isEmpty() && assignQueue.peek().freeTime <= time) {\\n                serverQueue.add(assignQueue.poll().server);\\n            }\\n\\t\\t\\t// assign tasks to available servers\\n            // using condition \"j <= time\" because accd. to question \"At second j, the jth task is inserted into the queue\"\\n            while (!serverQueue.isEmpty() && j <= time && j < tasks.length) {\\n                int task = tasks[j];\\n                Server server = serverQueue.poll();\\n                ans[j] = server.index;\\n                assignQueue.add(new Assign(time + task, server));\\n                ++j;\\n            }\\n            // increase time, so that we can process next task\\n            if (!serverQueue.isEmpty())\\n                time++;\\n            else\\n                // when no servers are available, move to next available server\\'s freeTime\\n\\t\\t\\t\\t// this decreases loop iterations, since there can be a situation where time <<< next freeTime\\n                time = assignQueue.peek().freeTime;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    private class Server {\\n        int weight;\\n        int index;\\n\\n        public Server(int weight, int index) {\\n            this.weight = weight;\\n            this.index = index;\\n        }\\n    }\\n\\t\\n\\t// Represents task-server assignment\\n    private class Assign {\\n\\t\\t// time at which this server will become free again\\n        int freeTime;\\n        Server server;\\n\\n        public Assign(int freeTime, Server server) {\\n            this.freeTime = freeTime;\\n            this.server = server;\\n        }\\n    }\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n\\t\\t// PQ to store servers (server with least weight or least index is polled first)\\n        Queue<Server> serverQueue = new PriorityQueue<>((s1, s2) -> {\\n            if (s1.weight - s2.weight != 0)\\n                return s1.weight - s2.weight;\\n            return s1.index - s2.index;\\n        });\\n\\t\\t\\n\\t\\t// PQ to store assigned servers (server with least freeTime is polled first)\\n        Queue<Assign> assignQueue = new PriorityQueue<>(Comparator.comparingInt(a -> a.freeTime));\\n\\n        for (int i = 0; i < servers.length; ++i)\\n            serverQueue.add(new Server(servers[i], i));\\n\\n        int j = 0;\\n        int time = 0;\\n        int[] ans = new int[tasks.length];\\n\\n        while (j < tasks.length) {\\n\\t\\t\\t// check what all servers have become free\\n            while (!assignQueue.isEmpty() && assignQueue.peek().freeTime <= time) {\\n                serverQueue.add(assignQueue.poll().server);\\n            }\\n\\t\\t\\t// assign tasks to available servers\\n            // using condition \"j <= time\" because accd. to question \"At second j, the jth task is inserted into the queue\"\\n            while (!serverQueue.isEmpty() && j <= time && j < tasks.length) {\\n                int task = tasks[j];\\n                Server server = serverQueue.poll();\\n                ans[j] = server.index;\\n                assignQueue.add(new Assign(time + task, server));\\n                ++j;\\n            }\\n            // increase time, so that we can process next task\\n            if (!serverQueue.isEmpty())\\n                time++;\\n            else\\n                // when no servers are available, move to next available server\\'s freeTime\\n\\t\\t\\t\\t// this decreases loop iterations, since there can be a situation where time <<< next freeTime\\n                time = assignQueue.peek().freeTime;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244233,
                "title": "simple-c-solution-with-explanation",
                "content": "This question becomes really easy to understand if you have some idea of **multiprocessing operating systems** and **scheduling**. Basically we have m number of tasks each of which arrive at time i where ```0 <= i < m``` and take ```tasks[i]``` time to complete. We also have n servers that have a certain weight. Our task is to schedule these tasks and return which task was done by which server.\\n\\nWe will need two min heaps,one to store the busy servers and one to store the available servers. Busy queue stores the completion **time and index** while available queue stores **weight and index**.\\n\\nCase:\\n1. Initially all the servers are free,so we have to put them in the available queue with their weight and index. ```{ server[i],i }```\\n2. Each task arrives at time i. So before we assign a server to task i, we have to first free all the servers that have finished their tasks before time i from the busy queue. This is done using a timer varible inside the while loop.\\n3. Once we have all the free servers at that point in time, we simply choose the top most server from the available queue and put it in the busy queue with its completion time and index. ```{timer+task[i],i}```\\n4.  After all the above is done we increment out timer variable.\\n\\nEdge Case :\\n1. Lets say for a certain ```task i``` there are no available servers. In that case the process is going to wait for the top most server in the busy queue. Essentially our task will wait till any of the servers are free and then choose the one with smallest weight. \\n2. Lets say that the top server in out busy queue has a completeion time of of T. It is also possible that there are other servers in the busy queue that also have completion time T.\\n3. So we update out timer variable to T and then run our while loop to free up the servers.\\n4. Now while ```task i``` was waiting for a free server, it is possible that there were other tasks that came up. These tasks will get scheduled at the same time as ```task i```( multiprocessing feature ). This is what ``` timer = max(timer,i+1) ``` implements.\\n\\n```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pii, vector<pii>, greater<pii>> busy, avl;\\n        vector<int> ans;\\n        int timer = 0;\\n        for(int i=0;i<servers.size();i++)\\n            avl.push({servers[i],i});        \\n        for(int i=0;i<tasks.size();i++){\\n            if(avl.empty())\\n                timer = busy.top().first;            \\n            while(!busy.empty() && busy.top().first<=timer){\\n                int j = busy.top().second;\\n                avl.push({servers[j],j});\\n                busy.pop();\\n            }            \\n            int k = avl.top().second;\\n            avl.pop();\\n            ans.push_back(k);\\n            busy.push({timer + tasks[i],k});\\n            timer = max(timer,i+1);\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```0 <= i < m```\n```tasks[i]```\n```{ server[i],i }```\n```{timer+task[i],i}```\n```task i```\n```task i```\n```task i```\n``` timer = max(timer,i+1) ```\n```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pii, vector<pii>, greater<pii>> busy, avl;\\n        vector<int> ans;\\n        int timer = 0;\\n        for(int i=0;i<servers.size();i++)\\n            avl.push({servers[i],i});        \\n        for(int i=0;i<tasks.size();i++){\\n            if(avl.empty())\\n                timer = busy.top().first;            \\n            while(!busy.empty() && busy.top().first<=timer){\\n                int j = busy.top().second;\\n                avl.push({servers[j],j});\\n                busy.pop();\\n            }            \\n            int k = avl.top().second;\\n            avl.pop();\\n            ans.push_back(k);\\n            busy.push({timer + tasks[i],k});\\n            timer = max(timer,i+1);\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239762,
                "title": "java-treemap-priorityqueue",
                "content": "```\\npublic int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int []> pq = new PriorityQueue<int []>((a,b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        for(int i=0;i<servers.length;i++){\\n            pq.add(new int[]{servers[i], i});\\n        }\\n        int []ans = new int[tasks.length];\\n        TreeMap<Integer, List<int[]>> tm = new TreeMap();\\n        int time = 0;\\n        for(int i=0;i<tasks.length;i++){\\n            time = Math.max(time, i);\\n            if(tm.containsKey(time)){\\n                pq.addAll(tm.get(time));\\n                tm.remove(time);\\n            }\\n            if(pq.isEmpty()){\\n                time = tm.firstKey();\\n                pq.addAll(tm.get(time));\\n                tm.remove(time);\\n            }\\n            int []top = pq.poll();\\n            ans[i] = top[1];\\n            List<int []> al = tm.getOrDefault(time+tasks[i] , new ArrayList());\\n            al.add(top);\\n            tm.put(time+tasks[i], al);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int []> pq = new PriorityQueue<int []>((a,b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        for(int i=0;i<servers.length;i++){\\n            pq.add(new int[]{servers[i], i});\\n        }\\n        int []ans = new int[tasks.length];\\n        TreeMap<Integer, List<int[]>> tm = new TreeMap();\\n        int time = 0;\\n        for(int i=0;i<tasks.length;i++){\\n            time = Math.max(time, i);\\n            if(tm.containsKey(time)){\\n                pq.addAll(tm.get(time));\\n                tm.remove(time);\\n            }\\n            if(pq.isEmpty()){\\n                time = tm.firstKey();\\n                pq.addAll(tm.get(time));\\n                tm.remove(time);\\n            }\\n            int []top = pq.poll();\\n            ans[i] = top[1];\\n            List<int []> al = tm.getOrDefault(time+tasks[i] , new ArrayList());\\n            al.add(top);\\n            tm.put(time+tasks[i], al);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565769,
                "title": "python3-two-heap-beats-98",
                "content": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res, unavailable, time = [], [], 0\\n        available = [(weight, id) for id, weight in enumerate(servers)]\\n        heapify(available)\\n\\n        for task in tasks:\\n            while unavailable and unavailable[0][0] == time:\\n                _, weight, id = heappop(unavailable)\\n                heappush(available, (weight, id))\\n\\n            if len(available) > 0:\\n                weight, id = heappop(available)\\n                heappush(unavailable, (time + task, weight, id))\\n                res.append(id)\\n            else:\\n                finishTime, weight, id = heappop(unavailable)\\n                heappush(unavailable, (finishTime + task, weight, id))\\n                res.append(id)\\n            time +=1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res, unavailable, time = [], [], 0\\n        available = [(weight, id) for id, weight in enumerate(servers)]\\n        heapify(available)\\n\\n        for task in tasks:\\n            while unavailable and unavailable[0][0] == time:\\n                _, weight, id = heappop(unavailable)\\n                heappush(available, (weight, id))\\n\\n            if len(available) > 0:\\n                weight, id = heappop(available)\\n                heappush(unavailable, (time + task, weight, id))\\n                res.append(id)\\n            else:\\n                finishTime, weight, id = heappop(unavailable)\\n                heappush(unavailable, (finishTime + task, weight, id))\\n                res.append(id)\\n            time +=1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255089,
                "title": "java-simple-and-easy-to-understand-solution-using-min-heap-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        PriorityQueue<int[]> availableServer = new PriorityQueue<int[]>((a, b) -> (a[1] != b[1] ? (a[1] - b[1]) : (a[0] - b[0])));\\n        for(int i = 0; i < servers.length; i++){\\n            availableServer.add(new int[]{i, servers[i]});\\n        }\\n        \\n        \\n        //int[[] arr, \\n        //arr[0] - server index\\n        //arr[1] - server weight\\n        //arr[2] - free time\\n        PriorityQueue<int[]> processingServer = new PriorityQueue<int[]>(\\n                (a, b) -> \\n                \\n                ( \\n                    a[2] != b[2] ? a[2] - b[2] :  // try to sort increasing order of free time\\n                    a[1] != b[1] ? a[1] - b[1] :  // try to sort increasing order of server weight \\n                    a[0] - b[0]                   // sort increasing order of server index\\n                )\\n        );\\n        \\n        \\n        int[] result = new int[tasks.length];\\n        \\n        for(int i = 0; i < tasks.length; i++){\\n            \\n            while(!processingServer.isEmpty() && processingServer.peek()[2] <= i){\\n                int serverIndex = processingServer.remove()[0];\\n                availableServer.add(new int[]{serverIndex, servers[serverIndex]});\\n            }\\n            \\n            \\n            int currentTaskTimeRequired = tasks[i];\\n            \\n            int[] server;\\n            \\n            //when current task will free the server done\\n            int freeTime = currentTaskTimeRequired;\\n            \\n            if(!availableServer.isEmpty()){\\n                server = availableServer.remove();\\n                freeTime += i;\\n            }else{\\n                server = processingServer.remove();\\n                //append previous time\\n                freeTime += server[2];\\n            }\\n            \\n            \\n            int serverIndex = server[0];\\n            processingServer.add(new int[]{serverIndex, servers[serverIndex] ,freeTime});\\n                \\n            \\n            //assign this server to current task\\n            result[i] = serverIndex;\\n        }\\n        \\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        PriorityQueue<int[]> availableServer = new PriorityQueue<int[]>((a, b) -> (a[1] != b[1] ? (a[1] - b[1]) : (a[0] - b[0])));\\n        for(int i = 0; i < servers.length; i++){\\n            availableServer.add(new int[]{i, servers[i]});\\n        }\\n        \\n        \\n        //int[[] arr, \\n        //arr[0] - server index\\n        //arr[1] - server weight\\n        //arr[2] - free time\\n        PriorityQueue<int[]> processingServer = new PriorityQueue<int[]>(\\n                (a, b) -> \\n                \\n                ( \\n                    a[2] != b[2] ? a[2] - b[2] :  // try to sort increasing order of free time\\n                    a[1] != b[1] ? a[1] - b[1] :  // try to sort increasing order of server weight \\n                    a[0] - b[0]                   // sort increasing order of server index\\n                )\\n        );\\n        \\n        \\n        int[] result = new int[tasks.length];\\n        \\n        for(int i = 0; i < tasks.length; i++){\\n            \\n            while(!processingServer.isEmpty() && processingServer.peek()[2] <= i){\\n                int serverIndex = processingServer.remove()[0];\\n                availableServer.add(new int[]{serverIndex, servers[serverIndex]});\\n            }\\n            \\n            \\n            int currentTaskTimeRequired = tasks[i];\\n            \\n            int[] server;\\n            \\n            //when current task will free the server done\\n            int freeTime = currentTaskTimeRequired;\\n            \\n            if(!availableServer.isEmpty()){\\n                server = availableServer.remove();\\n                freeTime += i;\\n            }else{\\n                server = processingServer.remove();\\n                //append previous time\\n                freeTime += server[2];\\n            }\\n            \\n            \\n            int serverIndex = server[0];\\n            processingServer.add(new int[]{serverIndex, servers[serverIndex] ,freeTime});\\n                \\n            \\n            //assign this server to current task\\n            result[i] = serverIndex;\\n        }\\n        \\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239859,
                "title": "c-simple-approach",
                "content": "We need to keep track of:\\n1. available servers in sorted order of weight.\\n2. busy servers in sorted order of time at which they will become free.\\n\\nThen always add servers from busy servers which have completed before current time `t`, then try to schedule a task.\\n\\nThe mapping of task with server that runs it will be added to our result.\\n\\n**Comment** if you have doubt, **Upvote** if you get the idea :)\\n```\\n\\n    vector<int> assignTasks(vector<int>& S, vector<int>& T) {\\n        set<vector<int>> q; // busy servers: {completion time, server ind, task ind} \\n        set<pair<int,int>> avail;\\n        vector<int> res(T.size(), -1);\\n        \\n        int nt = T.size(), ns = S.size();\\n        \\n        for(int i=0; i<ns; ++i){\\n            avail.insert({S[i], i});  // add all servers to available.\\n        }\\n        \\n        int t=0;\\n        for(int i=0; i<nt; ++i){\\n            \\n            t = max(t, i);\\n            \\n            // add servers that have become free\\n            while(!q.empty() && (*q.begin())[0] <= t){\\n                int ind = (*q.begin())[1];\\n                avail.insert({S[ind], ind});\\n                res[(*q.begin())[2]] = ind;\\n                q.erase(q.begin());\\n            }\\n            \\n\\t\\t\\t// if server available then schedule the task.\\n            if(!avail.empty()){\\n                auto& [server, ind] = *avail.begin();\\n                q.insert({t+T[i], ind, i});\\n                avail.erase(avail.begin());\\n            }\\n            else{ // wait for a server to become available\\n                t = (*q.begin())[0]; // the server that\\'ll become available first.\\n                --i;\\n            }\\n        }\\n        \\n        while(!q.empty()){ // clear all busy servers i.e. complete the tasks.\\n            res[(*q.begin())[2]] = (*q.begin())[1];\\n            q.erase(q.begin());\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n**Complexity:**\\n```\\nm = |servers|, n = |tasks|\\nTime complexity: O((n+m) * log(m)) (Since each server operation takes log(n) and #find operations ~ #tasks+#servers ~ n+m).\\nSpace complexity: O(m+n)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n    vector<int> assignTasks(vector<int>& S, vector<int>& T) {\\n        set<vector<int>> q; // busy servers: {completion time, server ind, task ind} \\n        set<pair<int,int>> avail;\\n        vector<int> res(T.size(), -1);\\n        \\n        int nt = T.size(), ns = S.size();\\n        \\n        for(int i=0; i<ns; ++i){\\n            avail.insert({S[i], i});  // add all servers to available.\\n        }\\n        \\n        int t=0;\\n        for(int i=0; i<nt; ++i){\\n            \\n            t = max(t, i);\\n            \\n            // add servers that have become free\\n            while(!q.empty() && (*q.begin())[0] <= t){\\n                int ind = (*q.begin())[1];\\n                avail.insert({S[ind], ind});\\n                res[(*q.begin())[2]] = ind;\\n                q.erase(q.begin());\\n            }\\n            \\n\\t\\t\\t// if server available then schedule the task.\\n            if(!avail.empty()){\\n                auto& [server, ind] = *avail.begin();\\n                q.insert({t+T[i], ind, i});\\n                avail.erase(avail.begin());\\n            }\\n            else{ // wait for a server to become available\\n                t = (*q.begin())[0]; // the server that\\'ll become available first.\\n                --i;\\n            }\\n        }\\n        \\n        while(!q.empty()){ // clear all busy servers i.e. complete the tasks.\\n            res[(*q.begin())[2]] = (*q.begin())[1];\\n            q.erase(q.begin());\\n        }\\n        \\n        return res;\\n    }\\n```\n```\\nm = |servers|, n = |tasks|\\nTime complexity: O((n+m) * log(m)) (Since each server operation takes log(n) and #find operations ~ #tasks+#servers ~ n+m).\\nSpace complexity: O(m+n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596304,
                "title": "modular-c-solution-two-heaps-and-a-task-queue",
                "content": "The code is commented. Let me know if you have any questions. Thanks for the previously posted solution on this problem.\\n\\n```\\nstruct Task {\\n    int id;\\n    int time_needed;\\npublic:\\n    Task() {}\\n    Task(int id, int time_needed) : id(id), time_needed(time_needed) {}\\n};\\n\\nstruct Server {\\n    int id;\\n    int weight;\\n    int available_time;\\npublic:\\n    Server() {}\\n    Server(int id, int weight) : id(id), weight(weight), available_time(-1) {}\\n        \\n    void schedule_task(Task task, int curr_time) {\\n        available_time = curr_time + task.time_needed;\\n    }\\n};\\n\\nstruct WeightComparator {\\n    bool operator()(Server const& lhs, Server const& rhs) {\\n        if (lhs.weight == rhs.weight) return lhs.id > rhs.id;\\n        return (lhs.weight > rhs.weight);\\n    }\\n};\\n\\nstruct AvailableComparator {\\n    bool operator()(Server const& lhs, Server const& rhs) {\\n        return (lhs.available_time > rhs.available_time);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int total_tasks = tasks.size();\\n        std::vector<int> ans(total_tasks, -1);\\n        \\n        /// Min-Heap of free servers: The server with minimum weight is on the top\\n        std::priority_queue<Server, std::vector<Server>, WeightComparator> free_servers;\\n        \\n        /// Min-Heap of busy servers: The server with earliest availability is on the top\\n        std::priority_queue<Server, std::vector<Server>, AvailableComparator> busy_servers;\\n        \\n        /// Task of queue which gets 1 new task at every clock tick\\n        std::queue<Task> task_queue;\\n        \\n        /// Initialize the free server heap\\n        for (int i = 0; i < servers.size(); i++) {\\n            free_servers.push(Server{i, servers[i]});\\n        }\\n        \\n        /// Simulate task scheduling starting with 0th task at 0th time\\n        int task_id = 0;\\n        int curr_time = 0;\\n        \\n        /// While we have tasks in the task queue or tasks to schedule in the task queue\\n        while (!task_queue.empty() || task_id < total_tasks) {\\n\\n            /// Peek busy servers heap to find *all* the servers becoming available at the current time\\n            while (!busy_servers.empty() && busy_servers.top().available_time <= curr_time) {\\n                Server server = busy_servers.top();  busy_servers.pop();\\n                free_servers.push(server);\\n            }       \\n            \\n            /// Process *all* tasks from the task_queue on free servers starting with minimum weight\\n            while (!task_queue.empty() && !free_servers.empty()) {\\n                Server server = free_servers.top(); free_servers.pop();\\n                Task task = task_queue.front(); task_queue.pop();\\n                \\n                /// schedule `task` on the free `server` with minimum weight\\n                server.schedule_task(task, curr_time);\\n                busy_servers.push(server);\\n                ans[task.id] = server.id;\\n            }\\n            \\n            /// Simluate timeline\\n            if (task_id < total_tasks) {\\n                // as long as we iterating over tasks we simulate `1` clock tick at a time\\n                // because at each clock tick we can only put one task in the queue\\n                curr_time++;\\n                // every clock tick put a task in the task queue\\n                // note that we put one task per clock tick into the queue, but multiple tasks\\n                // can be scheduled from the the task_queue at a simulated clock tick\\n                task_queue.push(Task{task_id, tasks[task_id++]});\\n            } else {\\n                // once all the tasks are in the task_queue, the next simulation event time stamp\\n                // is governed by when one of the earliest busy server becomes available\\n                curr_time = busy_servers.top().available_time;\\n            }\\n        }\\n                        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct Task {\\n    int id;\\n    int time_needed;\\npublic:\\n    Task() {}\\n    Task(int id, int time_needed) : id(id), time_needed(time_needed) {}\\n};\\n\\nstruct Server {\\n    int id;\\n    int weight;\\n    int available_time;\\npublic:\\n    Server() {}\\n    Server(int id, int weight) : id(id), weight(weight), available_time(-1) {}\\n        \\n    void schedule_task(Task task, int curr_time) {\\n        available_time = curr_time + task.time_needed;\\n    }\\n};\\n\\nstruct WeightComparator {\\n    bool operator()(Server const& lhs, Server const& rhs) {\\n        if (lhs.weight == rhs.weight) return lhs.id > rhs.id;\\n        return (lhs.weight > rhs.weight);\\n    }\\n};\\n\\nstruct AvailableComparator {\\n    bool operator()(Server const& lhs, Server const& rhs) {\\n        return (lhs.available_time > rhs.available_time);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int total_tasks = tasks.size();\\n        std::vector<int> ans(total_tasks, -1);\\n        \\n        /// Min-Heap of free servers: The server with minimum weight is on the top\\n        std::priority_queue<Server, std::vector<Server>, WeightComparator> free_servers;\\n        \\n        /// Min-Heap of busy servers: The server with earliest availability is on the top\\n        std::priority_queue<Server, std::vector<Server>, AvailableComparator> busy_servers;\\n        \\n        /// Task of queue which gets 1 new task at every clock tick\\n        std::queue<Task> task_queue;\\n        \\n        /// Initialize the free server heap\\n        for (int i = 0; i < servers.size(); i++) {\\n            free_servers.push(Server{i, servers[i]});\\n        }\\n        \\n        /// Simulate task scheduling starting with 0th task at 0th time\\n        int task_id = 0;\\n        int curr_time = 0;\\n        \\n        /// While we have tasks in the task queue or tasks to schedule in the task queue\\n        while (!task_queue.empty() || task_id < total_tasks) {\\n\\n            /// Peek busy servers heap to find *all* the servers becoming available at the current time\\n            while (!busy_servers.empty() && busy_servers.top().available_time <= curr_time) {\\n                Server server = busy_servers.top();  busy_servers.pop();\\n                free_servers.push(server);\\n            }       \\n            \\n            /// Process *all* tasks from the task_queue on free servers starting with minimum weight\\n            while (!task_queue.empty() && !free_servers.empty()) {\\n                Server server = free_servers.top(); free_servers.pop();\\n                Task task = task_queue.front(); task_queue.pop();\\n                \\n                /// schedule `task` on the free `server` with minimum weight\\n                server.schedule_task(task, curr_time);\\n                busy_servers.push(server);\\n                ans[task.id] = server.id;\\n            }\\n            \\n            /// Simluate timeline\\n            if (task_id < total_tasks) {\\n                // as long as we iterating over tasks we simulate `1` clock tick at a time\\n                // because at each clock tick we can only put one task in the queue\\n                curr_time++;\\n                // every clock tick put a task in the task queue\\n                // note that we put one task per clock tick into the queue, but multiple tasks\\n                // can be scheduled from the the task_queue at a simulated clock tick\\n                task_queue.push(Task{task_id, tasks[task_id++]});\\n            } else {\\n                // once all the tasks are in the task_queue, the next simulation event time stamp\\n                // is governed by when one of the earliest busy server becomes available\\n                curr_time = busy_servers.top().available_time;\\n            }\\n        }\\n                        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240147,
                "title": "python-heap-o-n-mlogn-easy-and-well-explained",
                "content": "## Idea :\\nUsing two heap one to store the available server for any task and other to store the servers busy in completing the task.\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \\n        # sort the servers in order of weight, keeping index \\n        server_avail = [(w,i) for i,w in enumerate(servers)]\\n        heapify(server_avail)\\n        tasks_in_progress = []\\n        res = []\\n        st=0\\n        for j,task in enumerate(tasks):\\n            #starting time of task\\n            st = max(st,j)\\n            \\n            # if any server is not free then we can take start-time equal to end-time of task\\n            if not server_avail:\\n                st = tasks_in_progress[0][0]\\n            \\n            # pop the completed task\\'s server and push inside the server avail\\n            while tasks_in_progress and tasks_in_progress[0][0]<=st:\\n                heapq.heappush(server_avail,heappop(tasks_in_progress)[1])\\n                \\n            # append index of used server in res\\n            res.append(server_avail[0][1])\\n            \\n            # push the first available server in \"server_avail\" heap to \"tasks_in_progress\" heap\\n            heapq.heappush(tasks_in_progress,(st+task,heappop(server_avail)))\\n        \\n        return res\\n\\nif any doubt or want more explaination feel free to ask\\uD83E\\uDD1E\\nThank you!!\\nif u got helped from this, u can **Upvote**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "## Idea :\\nUsing two heap one to store the available server for any task and other to store the servers busy in completing the task.\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \\n        # sort the servers in order of weight, keeping index \\n        server_avail = [(w,i) for i,w in enumerate(servers)]\\n        heapify(server_avail)\\n        tasks_in_progress = []\\n        res = []\\n        st=0\\n        for j,task in enumerate(tasks):\\n            #starting time of task\\n            st = max(st,j)\\n            \\n            # if any server is not free then we can take start-time equal to end-time of task\\n            if not server_avail:\\n                st = tasks_in_progress[0][0]\\n            \\n            # pop the completed task\\'s server and push inside the server avail\\n            while tasks_in_progress and tasks_in_progress[0][0]<=st:\\n                heapq.heappush(server_avail,heappop(tasks_in_progress)[1])\\n                \\n            # append index of used server in res\\n            res.append(server_avail[0][1])\\n            \\n            # push the first available server in \"server_avail\" heap to \"tasks_in_progress\" heap\\n            heapq.heappush(tasks_in_progress,(st+task,heappop(server_avail)))\\n        \\n        return res\\n\\nif any doubt or want more explaination feel free to ask\\uD83E\\uDD1E\\nThank you!!\\nif u got helped from this, u can **Upvote**",
                "codeTag": "Java"
            },
            {
                "id": 1239861,
                "title": "javascript-2-heaps-w-explanation",
                "content": "```javascript\\n var assignTasks = function(servers, tasks) {\\n    // create a heap to manage free servers.\\n    // free servers will need to be prioritized by weight and index\\n    const freeServers = new Heap((serverA, serverB) => (\\n        serverA.weight - serverB.weight || serverA.index - serverB.index\\n    ));\\n\\n    // create a heap to manage used servers.\\n    // used servers will need to be prioritized by availableTime, weight and index\\n    const usedServers = new Heap((serverA, serverB) => (\\n        serverA.availableTime - serverB.availableTime || \\n        serverA.weight - serverB.weight || \\n        serverA.index - serverB.index\\n    ));\\n    \\n    // add all the servers into the free servers heap with the time it is available\\n    // being 0\\n    for (let i = 0; i < servers.length; i++) {\\n        freeServers.push({ weight: servers[i], index: i, availableTime: 0 })\\n    }\\n    \\n    const result = [];\\n    for (let i = 0; i < tasks.length; i++) {\\n        // find all the servers that are available and add them to the\\n        // free servers heap\\n        while (usedServers.size() && usedServers.peak().availableTime <= i) {\\n            freeServers.push(usedServers.pop());\\n        }\\n        // get the free server with the lowest weight or lower index\\n        // or the usedServer with the lowest start time.\\n        const server = freeServers.pop() || usedServers.pop();\\n        result.push(server.index);\\n        const availableTime = Math.max(i, server.availableTime);\\n        server.availableTime = availableTime + tasks[i];\\n        usedServers.push(server);\\n    }\\n    return result;\\n};\\n\\nclass Heap {\\n\\n    /**\\n     * Create a Heap\\n     * @param {function} compareFunction - compares child and parent element\\n     * to see if they should swap.  If return value is less than 0 it will\\n     * swap to prioritize the child.\\n     */\\n    constructor(compareFunction) {\\n        this.store = [];\\n        this.compareFunction = compareFunction;\\n    }\\n    \\n    peak() {\\n        return this.store[0];\\n    }\\n    \\n    size() {\\n        return this.store.length;\\n    }\\n    \\n    pop() {\\n        if (this.size() < 2) {\\n            return this.store.pop();\\n        }\\n        const result = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return result;\\n    }\\n    \\n    push(val) {\\n        this.store.push(val);\\n        this.heapifyUp(this.size() - 1);\\n    }\\n        \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            \\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            let [child, child2] = [1,2].map((x) => parent * 2 + x).filter((x) => x < this.size());\\n            if (this.shouldSwap(child2, child)) {\\n                child = child2;\\n            }\\n            \\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    shouldSwap(child, parent) {\\n        return child && this.compareFunction(this.store[child], this.store[parent]) < 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```javascript\\n var assignTasks = function(servers, tasks) {\\n    // create a heap to manage free servers.\\n    // free servers will need to be prioritized by weight and index\\n    const freeServers = new Heap((serverA, serverB) => (\\n        serverA.weight - serverB.weight || serverA.index - serverB.index\\n    ));\\n\\n    // create a heap to manage used servers.\\n    // used servers will need to be prioritized by availableTime, weight and index\\n    const usedServers = new Heap((serverA, serverB) => (\\n        serverA.availableTime - serverB.availableTime || \\n        serverA.weight - serverB.weight || \\n        serverA.index - serverB.index\\n    ));\\n    \\n    // add all the servers into the free servers heap with the time it is available\\n    // being 0\\n    for (let i = 0; i < servers.length; i++) {\\n        freeServers.push({ weight: servers[i], index: i, availableTime: 0 })\\n    }\\n    \\n    const result = [];\\n    for (let i = 0; i < tasks.length; i++) {\\n        // find all the servers that are available and add them to the\\n        // free servers heap\\n        while (usedServers.size() && usedServers.peak().availableTime <= i) {\\n            freeServers.push(usedServers.pop());\\n        }\\n        // get the free server with the lowest weight or lower index\\n        // or the usedServer with the lowest start time.\\n        const server = freeServers.pop() || usedServers.pop();\\n        result.push(server.index);\\n        const availableTime = Math.max(i, server.availableTime);\\n        server.availableTime = availableTime + tasks[i];\\n        usedServers.push(server);\\n    }\\n    return result;\\n};\\n\\nclass Heap {\\n\\n    /**\\n     * Create a Heap\\n     * @param {function} compareFunction - compares child and parent element\\n     * to see if they should swap.  If return value is less than 0 it will\\n     * swap to prioritize the child.\\n     */\\n    constructor(compareFunction) {\\n        this.store = [];\\n        this.compareFunction = compareFunction;\\n    }\\n    \\n    peak() {\\n        return this.store[0];\\n    }\\n    \\n    size() {\\n        return this.store.length;\\n    }\\n    \\n    pop() {\\n        if (this.size() < 2) {\\n            return this.store.pop();\\n        }\\n        const result = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return result;\\n    }\\n    \\n    push(val) {\\n        this.store.push(val);\\n        this.heapifyUp(this.size() - 1);\\n    }\\n        \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            \\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            let [child, child2] = [1,2].map((x) => parent * 2 + x).filter((x) => x < this.size());\\n            if (this.shouldSwap(child2, child)) {\\n                child = child2;\\n            }\\n            \\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    shouldSwap(child, parent) {\\n        return child && this.compareFunction(this.store[child], this.store[parent]) < 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251056,
                "title": "cpp-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        vector<int> res;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>  avail;  //declaring minHeap\\n        \\n        for(int i=0; i<servers.size(); i++)\\n            avail.push({servers[i], i});\\n        \\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> endTime;   //declaring minHeap\\n        \\n        int i= 0, time= 0;\\n        \\n        while(i< tasks.size())\\n        {\\n            //retrieving completed tasks\\n            while(!endTime.empty() && endTime.top()[0] <= time)\\n            {\\n                auto [e, server1, idx] = endTime.top(); endTime.pop();\\n                avail.push({server1, idx});\\n            }\\n            \\n            //execute new tasks\\n            while(i < tasks.size() && i<= time)\\n            {\\n                int currStart= tasks[i];\\n                \\n                //if servers are available\\n                if(!avail.empty())\\n                {\\n                    auto [currServer, id] = avail.top(); avail.pop();\\n                    i++;\\n                    res.push_back(id);\\n                    endTime.push({time+currStart, currServer, id});\\n                }\\n                //no server available\\n                else \\n                {\\n                    time = max(time, endTime.top()[0]-1);       // speedup simulation\\n                    break;\\n                }\\n            }\\n            time++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n\\nplease upvote if you like or found helpful :-)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        vector<int> res;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>  avail;  //declaring minHeap\\n        \\n        for(int i=0; i<servers.size(); i++)\\n            avail.push({servers[i], i});\\n        \\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> endTime;   //declaring minHeap\\n        \\n        int i= 0, time= 0;\\n        \\n        while(i< tasks.size())\\n        {\\n            //retrieving completed tasks\\n            while(!endTime.empty() && endTime.top()[0] <= time)\\n            {\\n                auto [e, server1, idx] = endTime.top(); endTime.pop();\\n                avail.push({server1, idx});\\n            }\\n            \\n            //execute new tasks\\n            while(i < tasks.size() && i<= time)\\n            {\\n                int currStart= tasks[i];\\n                \\n                //if servers are available\\n                if(!avail.empty())\\n                {\\n                    auto [currServer, id] = avail.top(); avail.pop();\\n                    i++;\\n                    res.push_back(id);\\n                    endTime.push({time+currStart, currServer, id});\\n                }\\n                //no server available\\n                else \\n                {\\n                    time = max(time, endTime.top()[0]-1);       // speedup simulation\\n                    break;\\n                }\\n            }\\n            time++;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250432,
                "title": "python3-simplified-problem-statement-and-solution-o-mlogn-with-detailed-explanation-of-all-steps",
                "content": "**Problem statement in simple words:**\\nFor each task given in task list we basically need to return the index of server that is going to process that task.\\nCriteria for server assignment is:\\nFree server with the smallest weight, and in case of a tie, use smaller index.\\n\\n**Steps:**\\n1. Maintaine 2 minHeaps:\\n     1. freeServers (weight,index) - List of free servers to process the task.\\n\\t 2. busyServers (waitingtime,weight,index) ->After assigning task to server from freeServers list, server gets occupied for certain time and wont be available for other tasks until current task is processed. So this server is moved to BusyServers List. Initally it will be empty. Waiting time is currenttime + time taken to process the task which is task[i].  We need waiting time as key in minheap because server with minm waitingTime will be the first server to be availbale for use.\\n\\n2. If No servers are available in free servers, update the current time to earlist time at which server will be released from busy server list(first element from busy server list).\\n\\n3. Before processing tasks first check if we have any free server in busyservers(currentTime > waiting time). if yes move it back to free server list.\\n4. Assign server to task from freeServerlist,move server to busylist and add index of it in result.\\n\\n**Complexity -O(mlogn) ** where m is size of tasks and n is size of server list\\nImplementation:\\n```\\nimport heapq\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res=[0]*len(tasks)\\n        freeServers = [(servers[i],i) for i in range(len(servers)) ] #store as (weight,index)\\n        busyServers=[]\\n        currentime=0\\n        heapq.heapify(freeServers)\\n        for i in range(len(tasks)):\\n            # currentime=max(currentime,i) --For cases where tasks have to wait because all servers are busy processing other tasks. In that case it will not be equal to index.\\n            currentime=max(currentime,i) \\n            if len(freeServers)==0:\\n                currentime=busyServers[0][0] #if all servers are busy, we need to update the cuurentime to minm waitingtime from busyServer list.  For example current time is 3 and all servers are busy and Min waiting time in busyserverlist is 7 seconds, update current time to 7.\\n                \\n        # check if server can be moved to available server heap.it can be moved to available servers  heap  when waitingtime stored in busyserver heap is less than or equal to current time.\\n            while busyServers and currentime>=busyServers[0][0]:\\n                waitingtime,weight,index=heapq.heappop(busyServers) #remove server from busyserver list\\n                heapq.heappush(freeServers,(weight,index)) # add server to free servers list\\n            \\n            weight,index=heapq.heappop(freeServers)#get server with min weight for task to use\\n\\n            res[i]=index #add index of server in result for  task[i]\\n        \\n            heapq.heappush(busyServers,(currentime+tasks[i],weight,index)) #move server from freeservers to busyservers with waiting time\\n        return res \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res=[0]*len(tasks)\\n        freeServers = [(servers[i],i) for i in range(len(servers)) ] #store as (weight,index)\\n        busyServers=[]\\n        currentime=0\\n        heapq.heapify(freeServers)\\n        for i in range(len(tasks)):\\n            # currentime=max(currentime,i) --For cases where tasks have to wait because all servers are busy processing other tasks. In that case it will not be equal to index.\\n            currentime=max(currentime,i) \\n            if len(freeServers)==0:\\n                currentime=busyServers[0][0] #if all servers are busy, we need to update the cuurentime to minm waitingtime from busyServer list.  For example current time is 3 and all servers are busy and Min waiting time in busyserverlist is 7 seconds, update current time to 7.\\n                \\n        # check if server can be moved to available server heap.it can be moved to available servers  heap  when waitingtime stored in busyserver heap is less than or equal to current time.\\n            while busyServers and currentime>=busyServers[0][0]:\\n                waitingtime,weight,index=heapq.heappop(busyServers) #remove server from busyserver list\\n                heapq.heappush(freeServers,(weight,index)) # add server to free servers list\\n            \\n            weight,index=heapq.heappop(freeServers)#get server with min weight for task to use\\n\\n            res[i]=index #add index of server in result for  task[i]\\n        \\n            heapq.heappush(busyServers,(currentime+tasks[i],weight,index)) #move server from freeservers to busyservers with waiting time\\n        return res \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240231,
                "title": "c-clean-solution-using-2-sorted-sets",
                "content": "Based off of the instructional video from: https://leetcode.com/problems/process-tasks-using-servers/discuss/1239821/Two-MinHeaps-Explained\\n```\\npublic class Solution {\\n    public int[] AssignTasks(int[] servers, int[] tasks) {\\n        int[] r = new int[tasks.Length];\\n        SortedSet<(int wt, int idx)> avail = new SortedSet<(int wt, int idx)>();\\n        SortedSet<(int tavail, int wt, int idx)> unavail = new SortedSet<(int tavail, int wt, int idx)>();\\n        for (int i = 0; i < servers.Length; ++i) \\n            avail.Add((servers[i], i));\\n        \\n        int t = 0;\\n        for (int i = 0; i < tasks.Length; ++i) {\\n            t = Math.Max(t, i);\\n            if (avail.Count == 0) t = unavail.Min.tavail;\\n            \\n            while (unavail.Count > 0 && t >= unavail.Min.tavail) {\\n                var min = unavail.Min;\\n                unavail.Remove(min);\\n                avail.Add((min.wt, min.idx));\\n            }\\n            \\n            (int wt, int idx) server = avail.Min;\\n            avail.Remove(server);\\n            unavail.Add((t + tasks[i], server.wt, server.idx));\\n            r[i] = server.idx;\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] AssignTasks(int[] servers, int[] tasks) {\\n        int[] r = new int[tasks.Length];\\n        SortedSet<(int wt, int idx)> avail = new SortedSet<(int wt, int idx)>();\\n        SortedSet<(int tavail, int wt, int idx)> unavail = new SortedSet<(int tavail, int wt, int idx)>();\\n        for (int i = 0; i < servers.Length; ++i) \\n            avail.Add((servers[i], i));\\n        \\n        int t = 0;\\n        for (int i = 0; i < tasks.Length; ++i) {\\n            t = Math.Max(t, i);\\n            if (avail.Count == 0) t = unavail.Min.tavail;\\n            \\n            while (unavail.Count > 0 && t >= unavail.Min.tavail) {\\n                var min = unavail.Min;\\n                unavail.Remove(min);\\n                avail.Add((min.wt, min.idx));\\n            }\\n            \\n            (int wt, int idx) server = avail.Min;\\n            avail.Remove(server);\\n            unavail.Add((t + tasks[i], server.wt, server.idx));\\n            r[i] = server.idx;\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240191,
                "title": "clean-readable-easy-to-understand-java-solution-two-heaps",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        Queue<int[]> free = new PriorityQueue<>((a, b) -> a[1] == b[1] ? (a[0] - b[0]) : (a[1] - b[1]));\\n        Queue<int[]> busy = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        int ans[] = new int[tasks.length];\\n        \\n        for(int i = 0; i < servers.length; i++) {\\n            free.add(new int[]{i, servers[i]});\\n        }\\n        \\n        int curTime = 0;\\n        int i = 0;\\n        while(i < tasks.length) {\\n            //free up servers that have comleted tasks till curTime\\n            while(!busy.isEmpty() && busy.peek()[1] <= curTime) {\\n                int id = busy.poll()[0];\\n                free.add(new int[]{id, servers[id]});\\n            }\\n            // allocate all pendig tasks until free servers are available\\n            while(i < tasks.length && i <= curTime && !free.isEmpty()) {\\n                int id = free.poll()[0];\\n                busy.add(new int[]{id, curTime + tasks[i]});\\n                ans[i++] = id;\\n            }\\n            // is no free servers available, wait until a server becomes free\\n\\t\\t\\t// else move to next task\\n            if(free.isEmpty()) {\\n                curTime = busy.peek()[1];\\n            } else {\\n                curTime++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        Queue<int[]> free = new PriorityQueue<>((a, b) -> a[1] == b[1] ? (a[0] - b[0]) : (a[1] - b[1]));\\n        Queue<int[]> busy = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        int ans[] = new int[tasks.length];\\n        \\n        for(int i = 0; i < servers.length; i++) {\\n            free.add(new int[]{i, servers[i]});\\n        }\\n        \\n        int curTime = 0;\\n        int i = 0;\\n        while(i < tasks.length) {\\n            //free up servers that have comleted tasks till curTime\\n            while(!busy.isEmpty() && busy.peek()[1] <= curTime) {\\n                int id = busy.poll()[0];\\n                free.add(new int[]{id, servers[id]});\\n            }\\n            // allocate all pendig tasks until free servers are available\\n            while(i < tasks.length && i <= curTime && !free.isEmpty()) {\\n                int id = free.poll()[0];\\n                busy.add(new int[]{id, curTime + tasks[i]});\\n                ans[i++] = id;\\n            }\\n            // is no free servers available, wait until a server becomes free\\n\\t\\t\\t// else move to next task\\n            if(free.isEmpty()) {\\n                curTime = busy.peek()[1];\\n            } else {\\n                curTime++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567862,
                "title": "java-two-heap-solution-with-descriptive-helper-class",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server> available = new PriorityQueue<>((s1, s2) -> (s1.weight == s2.weight ? s1.index - s2.index : s1.weight - s2.weight));\\n        PriorityQueue<Server> unavailable = new PriorityQueue<>((s1, s2) -> (s1.time == s2.time ? s1.weight == s2.weight ? \\n                                                                             s1.index - s2.index : s1.weight - s2.weight :\\n                                                                             s1.time - s2.time));\\n        for (int i = 0; i < servers.length; i++) {\\n            available.add(new Server(servers[i], i, 0));\\n        }\\n        \\n        int[] result = new int[tasks.length];\\n        for (int i = 0; i < tasks.length; i++) {      \\n            while (!unavailable.isEmpty() && unavailable.peek().time <= i) {                                                \\n                available.add(unavailable.poll());\\n            }\\n            Server as = available.poll(); // available server\\n            if (as == null) {\\n                as = unavailable.poll(); // use the first one from unavailable servers\\n            }\\n            as.time = Math.max(i + tasks[i], as.time + tasks[i]); \\n            result[i] = as.index;\\n            unavailable.add(as);\\n        }\\n        return result;\\n    }\\n    \\n    class Server {\\n        int weight;\\n        int index;\\n        int time;\\n        \\n        Server(int weight, int index, int time) {\\n            this.weight = weight;\\n            this.index = index;\\n            this.time = time;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server> available = new PriorityQueue<>((s1, s2) -> (s1.weight == s2.weight ? s1.index - s2.index : s1.weight - s2.weight));\\n        PriorityQueue<Server> unavailable = new PriorityQueue<>((s1, s2) -> (s1.time == s2.time ? s1.weight == s2.weight ? \\n                                                                             s1.index - s2.index : s1.weight - s2.weight :\\n                                                                             s1.time - s2.time));\\n        for (int i = 0; i < servers.length; i++) {\\n            available.add(new Server(servers[i], i, 0));\\n        }\\n        \\n        int[] result = new int[tasks.length];\\n        for (int i = 0; i < tasks.length; i++) {      \\n            while (!unavailable.isEmpty() && unavailable.peek().time <= i) {                                                \\n                available.add(unavailable.poll());\\n            }\\n            Server as = available.poll(); // available server\\n            if (as == null) {\\n                as = unavailable.poll(); // use the first one from unavailable servers\\n            }\\n            as.time = Math.max(i + tasks[i], as.time + tasks[i]); \\n            result[i] = as.index;\\n            unavailable.add(as);\\n        }\\n        return result;\\n    }\\n    \\n    class Server {\\n        int weight;\\n        int index;\\n        int time;\\n        \\n        Server(int weight, int index, int time) {\\n            this.weight = weight;\\n            this.index = index;\\n            this.time = time;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245655,
                "title": "easy-readable-code-using-heap",
                "content": "If you did not understand any part do comment below and I will help you out ! :D\\n\\n```\\n\\n// simulate the problem description , since the description is priority - driven it gives us an intuition to use heaps , and that is the way to solve this problem optimally \\n\\n// TC : O(nlogn) \\n// sc : O(n)\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n       \\n        PriorityQueue<FreeServers> fpq = new PriorityQueue(); // min heap of free servers \\n        PriorityQueue<RunningServers> rpq = new PriorityQueue(); // min heap of running servers\\n        \\n        for(int i =0;i<servers.length;i++){\\n            fpq.add(new FreeServers(servers[i],i)); // initially all servers are free\\n        }\\n        \\n        int time = 0; // current time;\\n        int ans[] = new int[tasks.length]; // result \\n        \\n        for(int i =0;i<tasks.length;i++){\\n            \\n            time = Math.max(time,i); // for cases when we wait for running servers to become free\\n            \\n            if(fpq.size()==0){ // no free servers\\n                \\n                RunningServers server = rpq.peek();\\n                time = server.freeTime; // wait till a server becomes free \\n                \\n            }\\n                while(rpq.size()>0&&time>=rpq.peek().freeTime){ // add all running servers which became free to free servers \\n                    RunningServers server = rpq.remove();\\n                    fpq.add(new FreeServers(server.weight,server.idx));\\n                    \\n                }\\n            \\n            FreeServers server = fpq.remove(); // get latest free server\\n            ans[i] = server.idx; // index of server is answer for current task\\n            int freeTime = time + tasks[i]; // time by which this task will be completed by server\\n            rpq.add(new RunningServers(freeTime,server.weight,server.idx)); // this server is now a running server till it completes current task , add it to running servers\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\nclass FreeServers implements Comparable<FreeServers> {\\n    int weight;\\n    int idx;\\n    \\n    public FreeServers(int weight , int idx){\\n        this.weight = weight;\\n        this.idx = idx;\\n    }\\n    \\n    public int compareTo(FreeServers other){\\n        if(this.weight!=other.weight) return this.weight-other.weight;\\n        return this.idx-other.idx;\\n    }\\n}\\nclass RunningServers implements Comparable<RunningServers>{\\n    int freeTime;\\n    int weight;\\n    int idx;\\n    \\n    public RunningServers(int freeTime , int weight , int idx){\\n        this.freeTime = freeTime;\\n        this.weight = weight;\\n        this.idx = idx;\\n    }\\n    \\n    public int compareTo(RunningServers other){\\n        if(this.freeTime!=other.freeTime) return this.freeTime-other.freeTime;\\n        if(this.weight!=other.weight) return this.weight - other.weight;\\n        return this.idx - other.idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n// simulate the problem description , since the description is priority - driven it gives us an intuition to use heaps , and that is the way to solve this problem optimally \\n\\n// TC : O(nlogn) \\n// sc : O(n)\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n       \\n        PriorityQueue<FreeServers> fpq = new PriorityQueue(); // min heap of free servers \\n        PriorityQueue<RunningServers> rpq = new PriorityQueue(); // min heap of running servers\\n        \\n        for(int i =0;i<servers.length;i++){\\n            fpq.add(new FreeServers(servers[i],i)); // initially all servers are free\\n        }\\n        \\n        int time = 0; // current time;\\n        int ans[] = new int[tasks.length]; // result \\n        \\n        for(int i =0;i<tasks.length;i++){\\n            \\n            time = Math.max(time,i); // for cases when we wait for running servers to become free\\n            \\n            if(fpq.size()==0){ // no free servers\\n                \\n                RunningServers server = rpq.peek();\\n                time = server.freeTime; // wait till a server becomes free \\n                \\n            }\\n                while(rpq.size()>0&&time>=rpq.peek().freeTime){ // add all running servers which became free to free servers \\n                    RunningServers server = rpq.remove();\\n                    fpq.add(new FreeServers(server.weight,server.idx));\\n                    \\n                }\\n            \\n            FreeServers server = fpq.remove(); // get latest free server\\n            ans[i] = server.idx; // index of server is answer for current task\\n            int freeTime = time + tasks[i]; // time by which this task will be completed by server\\n            rpq.add(new RunningServers(freeTime,server.weight,server.idx)); // this server is now a running server till it completes current task , add it to running servers\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\nclass FreeServers implements Comparable<FreeServers> {\\n    int weight;\\n    int idx;\\n    \\n    public FreeServers(int weight , int idx){\\n        this.weight = weight;\\n        this.idx = idx;\\n    }\\n    \\n    public int compareTo(FreeServers other){\\n        if(this.weight!=other.weight) return this.weight-other.weight;\\n        return this.idx-other.idx;\\n    }\\n}\\nclass RunningServers implements Comparable<RunningServers>{\\n    int freeTime;\\n    int weight;\\n    int idx;\\n    \\n    public RunningServers(int freeTime , int weight , int idx){\\n        this.freeTime = freeTime;\\n        this.weight = weight;\\n        this.idx = idx;\\n    }\\n    \\n    public int compareTo(RunningServers other){\\n        if(this.freeTime!=other.freeTime) return this.freeTime-other.freeTime;\\n        if(this.weight!=other.weight) return this.weight - other.weight;\\n        return this.idx - other.idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240083,
                "title": "two-min-heaps-used-passed-all-cases",
                "content": "class Solution {\\npublic:\\n    struct cust\\n    {\\n        int w;\\n        int ind;\\n        bool operator < (const cust & s2)\\n        const\\n        {\\n            return (w > s2.w) || (w==s2.w && ind > s2.ind);\\n        }\\n    };\\n    struct cust1\\n    {\\n        int time;\\n        int ind;\\n        bool operator < (const cust1 & s2)\\n        const\\n        {\\n            return (time > s2.time);\\n        }\\n    };\\n    vector<int> assignTasks(vector<int>& ser, vector<int>& task) {\\n        \\n        priority_queue<cust>avail;//weight index\\n        priority_queue<cust1>st;//time index\\n        vector<int>ans;\\n        int x = 0;\\n        for(auto it : ser)\\n        {\\n            avail.push({it,x});\\n            x++;\\n        }\\n        int ti = -1;\\n        for(int i = 0;i<task.size();i++)\\n        {\\n            if(ti<i)\\n                ti = i;\\n            if(avail.size()==0)\\n            {\\n                int id = st.top().ind;\\n                int tim = st.top().time;\\n                avail.push({ser[id],id});\\n                st.pop();\\n                ti = max(ti,tim);\\n            }\\n            while(st.size()>0 && st.top().time<=ti)\\n            {\\n                int id = st.top().ind;\\n                avail.push({ser[id],id});\\n                st.pop();\\n            }\\n            int id = avail.top().ind;\\n            ans.push_back(id);\\n            avail.pop();\\n            st.push({ti + task[i],id});\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    struct cust\\n    {\\n        int w;\\n        int ind;\\n        bool operator < (const cust & s2)\\n        const\\n        {\\n            return (w > s2.w) || (w==s2.w && ind > s2.ind);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1239864,
                "title": "c-solution-using-two-min-heaps",
                "content": "Use two priority queues:\\n1) For checking the status of available servers.\\n2) For storing the busy servers such that if it becomes available again we could use them.\\n\\nHere\\'s my code : \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        \\n        priority_queue <pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > available; //{server[index], index}.\\n        for(int i=0;i<n;i++)\\n        {\\n            available.push({servers[i],i});\\n        }\\n        vector<int> ans(m);\\n        priority_queue <pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>> > busy; //{avail. time,{server[ind],ind}}.\\n        \\n        int i=0,time=0;\\n        while(i<m)\\n        {\\n            while(busy.size()==0 && busy.top().first<=time)                  //If it becomes available again after it has completed its previous task.\\n            {\\n                available.push({servers[busy.top().second.second],busy.top().second.second});\\n                busy.pop();\\n            }\\n            \\n            while(i<m && i<=time)                                            // Since we can use multiple servers at a time\\n            {\\n                if(!available.empty())\\n                {\\n                    ans[i]=available.top().second;\\n                    busy.push({tasks[i]+t,{servers[available.top().second],available.top().second}});\\n                    available.pop();\\n                    i++;\\n                }\\n                else\\n                {\\n                    if(time<busy.top().first-1)                             // Removing this will give TLE as it fastens the solution.\\n                    time = busy.top().first-1;\\n                    \\n                    break;\\n                }\\n            }\\n            time++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        \\n        priority_queue <pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > available; //{server[index], index}.\\n        for(int i=0;i<n;i++)\\n        {\\n            available.push({servers[i],i});\\n        }\\n        vector<int> ans(m);\\n        priority_queue <pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>> > busy; //{avail. time,{server[ind],ind}}.\\n        \\n        int i=0,time=0;\\n        while(i<m)\\n        {\\n            while(busy.size()==0 && busy.top().first<=time)                  //If it becomes available again after it has completed its previous task.\\n            {\\n                available.push({servers[busy.top().second.second],busy.top().second.second});\\n                busy.pop();\\n            }\\n            \\n            while(i<m && i<=time)                                            // Since we can use multiple servers at a time\\n            {\\n                if(!available.empty())\\n                {\\n                    ans[i]=available.top().second;\\n                    busy.push({tasks[i]+t,{servers[available.top().second],available.top().second}});\\n                    available.pop();\\n                    i++;\\n                }\\n                else\\n                {\\n                    if(time<busy.top().first-1)                             // Removing this will give TLE as it fastens the solution.\\n                    time = busy.top().first-1;\\n                    \\n                    break;\\n                }\\n            }\\n            time++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239811,
                "title": "java-simulation-by-two-heaps-available-servers-and-in-use-servers-o-m-n-logn",
                "content": "```java\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int n = servers.length;\\n        int m = tasks.length;\\n        int[] res = new int[m];\\n        //[server index, weight]\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) ->{\\n            if(a[1] != b[1]){\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];\\n        });\\n        //[server index, available time]\\n        PriorityQueue<int[]> used = new PriorityQueue<>((a,b) ->{\\n            return a[1] - b[1];\\n        });\\n        for(int i = 0; i < n; i++){\\n            pq.add(new int[]{i, servers[i]});\\n        }\\n        \\n        //processing\\n        int i = 0;\\n        int curTime = 0;\\n        while(i < m){\\n            //get more available servers\\n            while(!used.isEmpty() && used.peek()[1] <= curTime){\\n                int[] out = used.poll();\\n                pq.offer(new int[]{out[0], servers[out[0]]});\\n            }\\n            //has available server\\n            while(i < m && i <= curTime && !pq.isEmpty()){\\n                int[] use = pq.poll();\\n                res[i] = use[0];\\n                used.offer(new int[]{use[0], curTime + tasks[i]});\\n                i++;\\n            }\\n            //jump to next\\n            if(pq.isEmpty()){\\n                curTime = used.peek()[1];\\n            }\\n            //move forward by second\\n            else{\\n                curTime++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int n = servers.length;\\n        int m = tasks.length;\\n        int[] res = new int[m];\\n        //[server index, weight]\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) ->{\\n            if(a[1] != b[1]){\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];\\n        });\\n        //[server index, available time]\\n        PriorityQueue<int[]> used = new PriorityQueue<>((a,b) ->{\\n            return a[1] - b[1];\\n        });\\n        for(int i = 0; i < n; i++){\\n            pq.add(new int[]{i, servers[i]});\\n        }\\n        \\n        //processing\\n        int i = 0;\\n        int curTime = 0;\\n        while(i < m){\\n            //get more available servers\\n            while(!used.isEmpty() && used.peek()[1] <= curTime){\\n                int[] out = used.poll();\\n                pq.offer(new int[]{out[0], servers[out[0]]});\\n            }\\n            //has available server\\n            while(i < m && i <= curTime && !pq.isEmpty()){\\n                int[] use = pq.poll();\\n                res[i] = use[0];\\n                used.offer(new int[]{use[0], curTime + tasks[i]});\\n                i++;\\n            }\\n            //jump to next\\n            if(pq.isEmpty()){\\n                curTime = used.peek()[1];\\n            }\\n            //move forward by second\\n            else{\\n                curTime++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239763,
                "title": "python-heap",
                "content": "```python\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [(w, idx) for idx, w in enumerate(servers)] # heap (weight, server)\\n        heapify(free)\\n        busy = [] # heap (end of execution, server)\\n        time = task = 0\\n        ans = []\\n        \\n        while True:\\n            while free and time >= task:\\n                _, server = heappop(free)\\n                ans.append(server)\\n                heappush(busy, (time + tasks[task], server))\\n                task += 1\\n                if task >= len(tasks):\\n                    return ans\\n            \\n            if free:\\n                time += 1\\n            else:\\n                time = busy[0][0]\\n            \\n            while busy and time >= busy[0][0]:\\n                _, server = heappop(busy)\\n                heappush(free, (servers[server], server))\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [(w, idx) for idx, w in enumerate(servers)] # heap (weight, server)\\n        heapify(free)\\n        busy = [] # heap (end of execution, server)\\n        time = task = 0\\n        ans = []\\n        \\n        while True:\\n            while free and time >= task:\\n                _, server = heappop(free)\\n                ans.append(server)\\n                heappush(busy, (time + tasks[task], server))\\n                task += 1\\n                if task >= len(tasks):\\n                    return ans\\n            \\n            if free:\\n                time += 1\\n            else:\\n                time = busy[0][0]\\n            \\n            while busy and time >= busy[0][0]:\\n                _, server = heappop(busy)\\n                heappush(free, (servers[server], server))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070349,
                "title": "python-2-heap-time-mistake",
                "content": "I got an error for test case 30 as in discussion section. After looking through quite a few posts,  I edit\\nmy \\'time += 1\\' to max(time,i) to update time instead, solving the disgusting multiprocessing problem which is badly worded in this example.\\n\\n*Reason why it works:\\nThe max(time,i) function allow us to toggle the timeline there, allowing task that are below that cur time to be processed, just like \\'multiprocessing\\'. IF we do time += 1 , which is intuitively reasonable in first sight,\\nwe might have edge case that some task with 1 sec free it back to tasks that supposed to be assigned at that toggled second.\\n\\n```\\nclass Solution:\\n    import heapq\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        heaps = []\\n        occupied_server = []\\n        for i in range(len(servers)):\\n            heapq.heappush(heaps,(servers[i],i))\\n        res = []\\n        time = 0\\n            \\n        for i in range(len(tasks)):\\n            time = max(time,i)\\n            if occupied_server:\\n                while occupied_server and occupied_server[0][0] <= time:\\n                    time_free,index=heapq.heappop(occupied_server)\\n                    heapq.heappush(heaps,(servers[index],index))\\n            if not heaps:\\n                time = occupied_server[0][0]\\n                while occupied_server and occupied_server[0][0] <= time:\\n                    time_free,index=heapq.heappop(occupied_server)\\n                    heapq.heappush(heaps,(servers[index],index))\\n                \\n            \\n            weight,best_server = heapq.heappop(heaps)\\n            heapq.heappush(occupied_server,(time+tasks[i],best_server))\\n            res.append(best_server)\\n            # time += 1\\n        return res",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "I got an error for test case 30 as in discussion section. After looking through quite a few posts,  I edit\\nmy \\'time += 1\\' to max(time,i) to update time instead, solving the disgusting multiprocessing problem which is badly worded in this example.\\n\\n*Reason why it works:\\nThe max(time,i) function allow us to toggle the timeline there, allowing task that are below that cur time to be processed, just like \\'multiprocessing\\'. IF we do time += 1 , which is intuitively reasonable in first sight,\\nwe might have edge case that some task with 1 sec free it back to tasks that supposed to be assigned at that toggled second.\\n\\n```\\nclass Solution:\\n    import heapq\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        heaps = []\\n        occupied_server = []\\n        for i in range(len(servers)):\\n            heapq.heappush(heaps,(servers[i],i))\\n        res = []\\n        time = 0\\n            \\n        for i in range(len(tasks)):\\n            time = max(time,i)\\n            if occupied_server:\\n                while occupied_server and occupied_server[0][0] <= time:\\n                    time_free,index=heapq.heappop(occupied_server)\\n                    heapq.heappush(heaps,(servers[index],index))\\n            if not heaps:\\n                time = occupied_server[0][0]\\n                while occupied_server and occupied_server[0][0] <= time:\\n                    time_free,index=heapq.heappop(occupied_server)\\n                    heapq.heappush(heaps,(servers[index],index))\\n                \\n            \\n            weight,best_server = heapq.heappop(heaps)\\n            heapq.heappush(occupied_server,(time+tasks[i],best_server))\\n            res.append(best_server)\\n            # time += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2708472,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> free_server_pq;\\n       \\n        priority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> busy_server_pq;\\n        vector<int> ans(m);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            free_server_pq.push({servers[i], i});\\n        }\\n        \\n        long time = 0;\\n        for (int i = 0; i < m; ++i) {\\n            time = max(static_cast<long>(i), time);\\n            if (free_server_pq.empty() && busy_server_pq.top().first > time) {\\n                time = busy_server_pq.top().first;\\n            }\\n            \\n            while (!busy_server_pq.empty() && busy_server_pq.top().first <= time) {\\n                auto &info = busy_server_pq.top();\\n                int server_idx = static_cast<int>(info.second);\\n                free_server_pq.push({servers[server_idx], server_idx});\\n                busy_server_pq.pop();\\n            }\\n            \\n            auto &info = free_server_pq.top();\\n            busy_server_pq.push({time + tasks[i], info.second});\\n            ans[i] = info.second;\\n            free_server_pq.pop();\\n        }\\n        \\n        return ans;\\n    } \\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> free_server_pq;\\n       \\n        priority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> busy_server_pq;\\n        vector<int> ans(m);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            free_server_pq.push({servers[i], i});\\n        }\\n        \\n        long time = 0;\\n        for (int i = 0; i < m; ++i) {\\n            time = max(static_cast<long>(i), time);\\n            if (free_server_pq.empty() && busy_server_pq.top().first > time) {\\n                time = busy_server_pq.top().first;\\n            }\\n            \\n            while (!busy_server_pq.empty() && busy_server_pq.top().first <= time) {\\n                auto &info = busy_server_pq.top();\\n                int server_idx = static_cast<int>(info.second);\\n                free_server_pq.push({servers[server_idx], server_idx});\\n                busy_server_pq.pop();\\n            }\\n            \\n            auto &info = free_server_pq.top();\\n            busy_server_pq.push({time + tasks[i], info.second});\\n            ans[i] = info.second;\\n            free_server_pq.pop();\\n        }\\n        \\n        return ans;\\n    } \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283867,
                "title": "java-two-heaps-with-detailed-explanation-o-n-m-logn",
                "content": "```\\nWe need to assign tasks to the least weighted server first, so we need to sort the servers by ascending order, we will use min heap / pq.\\neach entry in the queue will have server\\'s index, server\\'s weight (server[i]) and the time until it\\'s busy\\n\\nwe iterate on the tasks, check if the running server\\'s queue is empty, \\n    if it is empty get the first available server from the available servers queue. update the time of that server with task\\'s time and the task\\'s index.\\n    if it is not empty, peek if the time of the 1st server from the running servers queue is less than or equal to the current time (i).\\n        if it is less, poll that server from the running servers queue and add it to the available server\\'s queue.\\n        \\n        total tc - O((n+m) logn) , space - O(n)\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        // if the weight of the 2 server\\'s is not same, we put the lowest weight in the front.\\n        // if the weight is same, we sort by the index, we pick the lowest index value server\\n        PriorityQueue<int[]> availableServers = new PriorityQueue<>((a,b) -> a[1] != b[1] ? Integer.compare(a[1], b[1]) : Integer.compare(a[0], b[0]));\\n        \\n        int n = servers.length;\\n        // initially all servers are free, so time until busy is 0\\n        // time - O(nlogn)\\n        for(int i=0; i<n; i++) { availableServers.add(new int[]{i, servers[i], 0}); }\\n        \\n        // need to sort based on the time that the server is busy, if the times are equal sort the server based on the index\\n        PriorityQueue<int[]> runningServers = new PriorityQueue<>((a,b) -> a[2] != b[2] ? Integer.compare(a[2], b[2]) : a[1] != b[1] ? Integer.compare(a[1], b[1]) : Integer.compare(a[0], b[0]));\\n        \\n        int m = tasks.length;\\n        \\n        int[] result = new int[m];\\n        \\n        // O(mlogn)\\n        for(int i=0; i<m; i++) {\\n            int timeToCompleteTask = tasks[i];\\n            \\n            // if running servers queue is not empty, peek the time from the queue, if its less than the time required to complete the current task, poll that server, else that server is busy doing its task. we will have to look from the available servers queue.\\n            while(!runningServers.isEmpty() && runningServers.peek()[2] <= i) {\\n                availableServers.add(runningServers.poll());\\n            }\\n            \\n            if(!availableServers.isEmpty()) {\\n                int[] curServer = availableServers.poll();\\n                result[i] = curServer[0];\\n                curServer[2] = i + timeToCompleteTask;\\n                runningServers.add(curServer);\\n            } else {\\n                int[] curServer = runningServers.poll();\\n                result[i] = curServer[0];\\n                curServer[2] = curServer[2] + timeToCompleteTask;\\n                runningServers.add(curServer);\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        // if the weight of the 2 server\\'s is not same, we put the lowest weight in the front.\\n        // if the weight is same, we sort by the index, we pick the lowest index value server\\n        PriorityQueue<int[]> availableServers = new PriorityQueue<>((a,b) -> a[1] != b[1] ? Integer.compare(a[1], b[1]) : Integer.compare(a[0], b[0]));\\n        \\n        int n = servers.length;\\n        // initially all servers are free, so time until busy is 0\\n        // time - O(nlogn)\\n        for(int i=0; i<n; i++) { availableServers.add(new int[]{i, servers[i], 0}",
                "codeTag": "Java"
            },
            {
                "id": 2156986,
                "title": "python-heap-clean-code",
                "content": "```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        freeServers = []\\n        busyServers = []\\n        result = []\\n        \\n        for server, weight in enumerate(servers):\\n            heappush(freeServers, [weight, server, 0])\\n        \\n        for currTime, duration in enumerate(tasks):\\n            while busyServers and busyServers[0][0] <= currTime or not freeServers:\\n                time, weight, server = heappop(busyServers)\\n                heappush(freeServers, [weight, server, time])\\n                \\n            weight, server, time = heappop(freeServers)\\n            result.append(server)\\n            heappush(busyServers, [max(currTime, time) + duration, weight, server])\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        freeServers = []\\n        busyServers = []\\n        result = []\\n        \\n        for server, weight in enumerate(servers):\\n            heappush(freeServers, [weight, server, 0])\\n        \\n        for currTime, duration in enumerate(tasks):\\n            while busyServers and busyServers[0][0] <= currTime or not freeServers:\\n                time, weight, server = heappop(busyServers)\\n                heappush(freeServers, [weight, server, time])\\n                \\n            weight, server, time = heappop(freeServers)\\n            result.append(server)\\n            heappush(busyServers, [max(currTime, time) + duration, weight, server])\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145723,
                "title": "can-someone-help-debug-this-c-solution",
                "content": "I feel like my solution is identical to the most vote answer: https://leetcode.com/problems/process-tasks-using-servers/discuss/1239810/C%2B%2B-easy-understand-solution-(priority-queue)\\nBut I always fail on this testcase: 29   only 36 and 56 need to swap. I have no idea.\\n```\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n```\\n\\n```\\nstruct Server\\n{\\n    int index;\\n    int time;\\n};\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        auto comp_weight = [&](const Server &s1, const Server &s2)\\n        {\\n            if(servers[s1.index] == servers[s2.index])\\n            {\\n                return s1.index > s2.index;\\n            }\\n            \\n            return servers[s1.index] > servers[s2.index];\\n        };\\n        \\n        auto comp_time = [](const Server &s1, const Server &s2)\\n        {\\n            if(s1.time == s2.time)\\n            {\\n                return s1.index > s2.index;\\n            }\\n            return s1.time > s2.time;\\n        };\\n        \\n        \\n        priority_queue<Server, vector<Server>, decltype(comp_weight)> available(comp_weight);\\n        priority_queue<Server, vector<Server>, decltype(comp_time)> unavailable(comp_time);\\n        \\n        for(int i = 0 ; i < servers.size(); i++)\\n        {\\n            available.push({i, 0});\\n        }\\n        \\n        vector<int> ans;\\n        int t = 0;\\n        for(int i = 0 ; i < tasks.size() ; i++, t++)\\n        {\\n            if(available.empty() && unavailable.top().time > t)\\n            {\\n                t = unavailable.top().time;\\n            }\\n            \\n            while(!unavailable.empty() && unavailable.top().time <= t)\\n            {\\n                auto topServer = unavailable.top();\\n                unavailable.pop();\\n                available.push(topServer);\\n            }\\n            \\n            auto topServer = available.top();\\n            available.pop();\\n            ans.push_back(topServer.index);\\n            unavailable.push({topServer.index, t+tasks[i]});\\n            // cout << \"index \" << index << endl;\\n        }\\n        return ans;\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "```\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1950163,
                "title": "easy-to-understand-c-solution-using-two-priorityqueues",
                "content": "\\n```\\n  public int[] AssignTasks(int[] servers, int[] tasks) {\\n        \\n        var usedServers=new PriorityQueue<(int time,int w, int index), (int time,int w, int index)>();\\n        var freeServers=new PriorityQueue<(int time, int w, int index),(int w, int index)>();\\n        \\n        for(int i=0; i<servers.Length;i++)\\n        {\\n            freeServers.Enqueue((0, servers[i], i), (servers[i],i));\\n        }\\n        \\n        var result=new int[tasks.Length];\\n        \\n        for(int i=0; i<tasks.Length;i++)\\n        {\\n            while(usedServers.Count>0 && usedServers.Peek().time<=i)\\n            {\\n                var server=usedServers.Dequeue();\\n                freeServers.Enqueue(server, (server.w, server.index));\\n            }\\n            \\n            if(freeServers.Count>0)\\n            {\\n                var worker=freeServers.Dequeue();\\n                result[i]=worker.index;\\n                var tuple=( i+ tasks[i],worker.w, worker.index);\\n                usedServers.Enqueue(tuple, tuple);\\n            }\\n            else{\\n                var worker=usedServers.Dequeue();\\n                result[i]=worker.index;\\n                var tuple=( worker.time+tasks[i],worker.w, worker.index);\\n                usedServers.Enqueue(tuple, tuple);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n  public int[] AssignTasks(int[] servers, int[] tasks) {\\n        \\n        var usedServers=new PriorityQueue<(int time,int w, int index), (int time,int w, int index)>();\\n        var freeServers=new PriorityQueue<(int time, int w, int index),(int w, int index)>();\\n        \\n        for(int i=0; i<servers.Length;i++)\\n        {\\n            freeServers.Enqueue((0, servers[i], i), (servers[i],i));\\n        }\\n        \\n        var result=new int[tasks.Length];\\n        \\n        for(int i=0; i<tasks.Length;i++)\\n        {\\n            while(usedServers.Count>0 && usedServers.Peek().time<=i)\\n            {\\n                var server=usedServers.Dequeue();\\n                freeServers.Enqueue(server, (server.w, server.index));\\n            }\\n            \\n            if(freeServers.Count>0)\\n            {\\n                var worker=freeServers.Dequeue();\\n                result[i]=worker.index;\\n                var tuple=( i+ tasks[i],worker.w, worker.index);\\n                usedServers.Enqueue(tuple, tuple);\\n            }\\n            else{\\n                var worker=usedServers.Dequeue();\\n                result[i]=worker.index;\\n                var tuple=( worker.time+tasks[i],worker.w, worker.index);\\n                usedServers.Enqueue(tuple, tuple);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762113,
                "title": "python-simulate-busy-servers-and-available-servers",
                "content": "I use two heaps to simulate busy and available servers:\\n```\\ndef assign_tasks(servers: List[int], tasks: List[int]) -> List[int]:\\n    avail_servers = [(w, i) for i, w in enumerate(servers)]\\n    heapq.heapify(avail_servers)\\n    busy_servers = []\\n    i, j = 0, 0\\n    ans = [0] * len(tasks)\\n    while i < len(tasks):\\n        while busy_servers and busy_servers[0][0] <= j:\\n            _, server_idx = heapq.heappop(busy_servers)\\n            heapq.heappush(avail_servers, (servers[server_idx], server_idx))\\n\\n        while i <= min(j, len(tasks) - 1) and avail_servers:\\n            _, server_idx = heapq.heappop(avail_servers)\\n            ans[i] = server_idx\\n            heapq.heappush(busy_servers, (j + tasks[i], server_idx))\\n            i += 1\\n\\n        if j < len(tasks):\\n            j += 1\\n        else:\\n            j = busy_servers[0][0]\\n    return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\ndef assign_tasks(servers: List[int], tasks: List[int]) -> List[int]:\\n    avail_servers = [(w, i) for i, w in enumerate(servers)]\\n    heapq.heapify(avail_servers)\\n    busy_servers = []\\n    i, j = 0, 0\\n    ans = [0] * len(tasks)\\n    while i < len(tasks):\\n        while busy_servers and busy_servers[0][0] <= j:\\n            _, server_idx = heapq.heappop(busy_servers)\\n            heapq.heappush(avail_servers, (servers[server_idx], server_idx))\\n\\n        while i <= min(j, len(tasks) - 1) and avail_servers:\\n            _, server_idx = heapq.heappop(avail_servers)\\n            ans[i] = server_idx\\n            heapq.heappush(busy_servers, (j + tasks[i], server_idx))\\n            i += 1\\n\\n        if j < len(tasks):\\n            j += 1\\n        else:\\n            j = busy_servers[0][0]\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1600654,
                "title": "c-priority-queue-maintain-available-inprogress-servers",
                "content": "**Idea** \\n\\nSo we know two things, we need to assign tasks to servers based on certain criteria, and second is once the task is assigned to a server, that server is not available to process any other task until it finishes the task.\\n\\nSo we maintain two things - \\n1. Min Heap to track which server becomes available first so that while assigning a task to a server, we make sure for the first condition.\\n2. Second we also maintain the set of available servers, while assigning a task we check if any server which was assinged some task earlier became free, if yes, we move it to the available servers.\\n\\n\\n\\n\\n```cpp\\nclass Node {\\npublic:\\n    int weight;\\n    int index;\\n    int endTime;\\n};\\n\\nstruct SetComparator {\\n    bool operator() (const Node &a, const Node &b) const {\\n        if (a.weight == b.weight) return a.index < b.index;\\n        return a.weight < b.weight;\\n    }\\n};\\n\\nbool operator<(const Node &a, const Node &b) {\\n    return a.endTime > b.endTime;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int serverCount = servers.size();\\n        int taskCount = tasks.size();\\n        priority_queue<Node> assignedServers;\\n        //-1 endTime indicates all the servers all free\\n        for (int i = 0; i < serverCount; ++i) {\\n            assignedServers.push({servers[i], i, -1});\\n        }\\n        set<Node, SetComparator> availableServers;\\n        int curTime = 0;\\n        vector<int> result(taskCount, -1);\\n        for (int i = 0; i < taskCount; ) {\\n            int curTime = max(i, curTime);\\n            while (assignedServers.size() > 0 && assignedServers.top().endTime <= curTime) {\\n                Node node = assignedServers.top();\\n                assignedServers.pop();\\n                availableServers.insert({node.weight, node.index, -1});\\n            }\\n            if (availableServers.size() > 0) {\\n                Node node = *availableServers.begin();\\n                availableServers.erase(availableServers.begin());\\n                result[i] = node.index;\\n                assignedServers.push({node.weight, node.index, tasks[i] + curTime});\\n                ++i;\\n            } else {\\n                curTime = assignedServers.top().endTime;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Node {\\npublic:\\n    int weight;\\n    int index;\\n    int endTime;\\n};\\n\\nstruct SetComparator {\\n    bool operator() (const Node &a, const Node &b) const {\\n        if (a.weight == b.weight) return a.index < b.index;\\n        return a.weight < b.weight;\\n    }\\n};\\n\\nbool operator<(const Node &a, const Node &b) {\\n    return a.endTime > b.endTime;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int serverCount = servers.size();\\n        int taskCount = tasks.size();\\n        priority_queue<Node> assignedServers;\\n        //-1 endTime indicates all the servers all free\\n        for (int i = 0; i < serverCount; ++i) {\\n            assignedServers.push({servers[i], i, -1});\\n        }\\n        set<Node, SetComparator> availableServers;\\n        int curTime = 0;\\n        vector<int> result(taskCount, -1);\\n        for (int i = 0; i < taskCount; ) {\\n            int curTime = max(i, curTime);\\n            while (assignedServers.size() > 0 && assignedServers.top().endTime <= curTime) {\\n                Node node = assignedServers.top();\\n                assignedServers.pop();\\n                availableServers.insert({node.weight, node.index, -1});\\n            }\\n            if (availableServers.size() > 0) {\\n                Node node = *availableServers.begin();\\n                availableServers.erase(availableServers.begin());\\n                result[i] = node.index;\\n                assignedServers.push({node.weight, node.index, tasks[i] + curTime});\\n                ++i;\\n            } else {\\n                curTime = assignedServers.top().endTime;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509646,
                "title": "c-detailed",
                "content": "```\\ntemplate<typename T1, typename T2, typename T3>\\nstruct triad {\\n    T1 first; T2 second; T3 third;\\n    triad(const T1& _f, const T2& _s, const T3& _t) : first(_f), second(_s), third(_t) {}\\n    triad(T1&& _f, T2&& _s, T3&& _t) : first(move(_f)), second(move(_s)), third(move(_t)) {}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        \\n        // we need to get the free server with the smallest weight, smallest index\\n        typedef triad<int,int,int> Triad;\\n        auto comp = [](auto& v2, auto& v1) {\\n            if(v1.first < v2.first) { return true; }\\n            else if(v1.first > v2.first) { return false; }\\n            else if(v1.first == v2.first) { return v1.second<v2.second; }\\n            else { return false; }\\n        };\\n        \\n        // create a priority queue of free servers\\n        priority_queue<Triad, vector<Triad>, decltype(comp) > pqFreeServers(comp);\\n        \\n        // Mark all servers as intially free\\n        for(int i=0; i<n; ++i) {\\n            pqFreeServers.emplace(servers[i], i, 0);\\n        }\\n        \\n        // reuse the allocated vector for output array\\n        servers.clear();\\n        auto& ret = servers;\\n        \\n        // create a priority queue of busy servers\\n        // sort by the server that gets freed first\\n        auto comp2 = [](auto& v2, auto& v1) { return v1.third<v2.third; };\\n        priority_queue<Triad, vector<Triad>, decltype(comp2) > pqBusyServers(comp2);\\n        \\n        int j = 0;\\n        int currTime = 0;\\n        while(j<m) {\\n        \\n            // jth task is added at jth second\\n            currTime = max(currTime, j);\\n            \\n            // get the next task\\n            auto& t = tasks[j];\\n            \\n            // add servers that are free\\n            while(!pqBusyServers.empty() && pqBusyServers.top().third<=currTime) {\\n                auto s = pqBusyServers.top(); pqBusyServers.pop();\\n                s.third = 0;\\n                pqFreeServers.emplace(s);\\n            }\\n            \\n            // if none of the servers are free, then find one that becomes free the earliest\\n            // time travel: move the clock forward in time\\n            if(pqFreeServers.empty()) {\\n                currTime = max(currTime, pqBusyServers.top().third);\\n                continue;\\n            }\\n            \\n            // get the next free server\\n            auto s = pqFreeServers.top(); pqFreeServers.pop();\\n            \\n            // push the index of server\\n            ret.push_back(s.second);\\n            \\n            // mark the server as \"not free\"\\n            s.third = t + currTime;\\n            pqBusyServers.emplace(s);\\n            \\n            // move to the next task\\n            ++j;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntemplate<typename T1, typename T2, typename T3>\\nstruct triad {\\n    T1 first; T2 second; T3 third;\\n    triad(const T1& _f, const T2& _s, const T3& _t) : first(_f), second(_s), third(_t) {}\\n    triad(T1&& _f, T2&& _s, T3&& _t) : first(move(_f)), second(move(_s)), third(move(_t)) {}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        \\n        // we need to get the free server with the smallest weight, smallest index\\n        typedef triad<int,int,int> Triad;\\n        auto comp = [](auto& v2, auto& v1) {\\n            if(v1.first < v2.first) { return true; }\\n            else if(v1.first > v2.first) { return false; }\\n            else if(v1.first == v2.first) { return v1.second<v2.second; }\\n            else { return false; }\\n        };\\n        \\n        // create a priority queue of free servers\\n        priority_queue<Triad, vector<Triad>, decltype(comp) > pqFreeServers(comp);\\n        \\n        // Mark all servers as intially free\\n        for(int i=0; i<n; ++i) {\\n            pqFreeServers.emplace(servers[i], i, 0);\\n        }\\n        \\n        // reuse the allocated vector for output array\\n        servers.clear();\\n        auto& ret = servers;\\n        \\n        // create a priority queue of busy servers\\n        // sort by the server that gets freed first\\n        auto comp2 = [](auto& v2, auto& v1) { return v1.third<v2.third; };\\n        priority_queue<Triad, vector<Triad>, decltype(comp2) > pqBusyServers(comp2);\\n        \\n        int j = 0;\\n        int currTime = 0;\\n        while(j<m) {\\n        \\n            // jth task is added at jth second\\n            currTime = max(currTime, j);\\n            \\n            // get the next task\\n            auto& t = tasks[j];\\n            \\n            // add servers that are free\\n            while(!pqBusyServers.empty() && pqBusyServers.top().third<=currTime) {\\n                auto s = pqBusyServers.top(); pqBusyServers.pop();\\n                s.third = 0;\\n                pqFreeServers.emplace(s);\\n            }\\n            \\n            // if none of the servers are free, then find one that becomes free the earliest\\n            // time travel: move the clock forward in time\\n            if(pqFreeServers.empty()) {\\n                currTime = max(currTime, pqBusyServers.top().third);\\n                continue;\\n            }\\n            \\n            // get the next free server\\n            auto s = pqFreeServers.top(); pqFreeServers.pop();\\n            \\n            // push the index of server\\n            ret.push_back(s.second);\\n            \\n            // mark the server as \"not free\"\\n            s.third = t + currTime;\\n            pqBusyServers.emplace(s);\\n            \\n            // move to the next task\\n            ++j;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508542,
                "title": "java-2-priorityqueue-simulation-commented-formatted",
                "content": "```java\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> free = new PriorityQueue<>((s1, s2) -> \\n            s1[1] == s2[1] ? s1[0] - s2[0] : s1[1] - s2[1]);\\n        PriorityQueue<int[]> work = new PriorityQueue<>((s1, s2) -> {\\n           if (s1[2] == s2[2]) {\\n               return s1[1] == s2[1] ? s1[0] - s2[0] : s1[1] - s2[1];\\n           } else {\\n               return s1[2] - s2[2];\\n           }\\n        });\\n        \\n        int n = servers.length;\\n        for (int i = 0; i < n; i++) {\\n            free.add(new int[]{i, servers[i], 0});\\n        }\\n        \\n        int m = tasks.length;\\n        int[] res = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            // check if the first \"work\" server we could set free\\n            // if running time <= current second\\n            while (!work.isEmpty() && work.peek()[2] <= i) {\\n                // not forget to add back free queue\\n                free.add(work.poll());\\n            }\\n            \\n            // if there are free servers, use server from it\\n            if (!free.isEmpty()) {\\n                int[] server = free.poll();\\n                // update time as current + required\\n                server[2] = i + tasks[i];\\n                work.add(server);\\n                res[i] = server[0];\\n            } else {\\n                // if no available free servers, we poll the next-avaiable work one\\n                int[] server = work.poll();\\n                // update the time\\n                server[2] += tasks[i];\\n                work.add(server);\\n                // update the \"enqueue\" time\\n                res[i] = server[0];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> free = new PriorityQueue<>((s1, s2) -> \\n            s1[1] == s2[1] ? s1[0] - s2[0] : s1[1] - s2[1]);\\n        PriorityQueue<int[]> work = new PriorityQueue<>((s1, s2) -> {\\n           if (s1[2] == s2[2]) {\\n               return s1[1] == s2[1] ? s1[0] - s2[0] : s1[1] - s2[1];\\n           } else {\\n               return s1[2] - s2[2];\\n           }\\n        });\\n        \\n        int n = servers.length;\\n        for (int i = 0; i < n; i++) {\\n            free.add(new int[]{i, servers[i], 0});\\n        }\\n        \\n        int m = tasks.length;\\n        int[] res = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            // check if the first \"work\" server we could set free\\n            // if running time <= current second\\n            while (!work.isEmpty() && work.peek()[2] <= i) {\\n                // not forget to add back free queue\\n                free.add(work.poll());\\n            }\\n            \\n            // if there are free servers, use server from it\\n            if (!free.isEmpty()) {\\n                int[] server = free.poll();\\n                // update time as current + required\\n                server[2] = i + tasks[i];\\n                work.add(server);\\n                res[i] = server[0];\\n            } else {\\n                // if no available free servers, we poll the next-avaiable work one\\n                int[] server = work.poll();\\n                // update the time\\n                server[2] += tasks[i];\\n                work.add(server);\\n                // update the \"enqueue\" time\\n                res[i] = server[0];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355104,
                "title": "two-heaps-and-a-queue-simple-java-solution",
                "content": "1. Keep a time ticker called \"counter\" that goes from 0 till the end of time until longest running task finishes.\\n2. Keep two Priority queues, first named \"freeQ\" second names \"busyQ\". \\n3. freeQ cosists of {server_weight, server_index} pair which is sorted on weight and if weights are same then sorted on indexes.\\n4. busyQ consists of triplet {server_weight, server_index, finish_time}, sorted on finish time.\\n5. TaskQ is a queue which we enqueque indices from tasks arrays in case freeQ is empty.\\n6. [Catch here] If freeQ is empty, we update the counter value to the task in busyQ which would finish the lastest, i.e the top most task in the busy queue. Hence you dont need to keep doing counter++.\\n\\nkill it!\\n\\nclass Solution {\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int m=servers.length;\\n        int n=tasks.length;\\n        int counter=0;\\n        PriorityQueue<int[]> freeQ=new PriorityQueue<>((a, b) -> (a[0]==b[0])?a[1]-b[1]:a[0]-b[0]);\\n        PriorityQueue<int[]> busyQ=new PriorityQueue<>((a, b) -> a[2]-b[2]);\\n        for(int i=0;i<m;i++){\\n            freeQ.offer(new int[]{servers[i], i});\\n        }\\n        int []ans=new int[n];\\n        Queue<Integer> taskQ=new LinkedList();\\n        while(!taskQ.isEmpty() || counter<n){\\n            if(counter<n)\\n                taskQ.offer(counter);\\n            while(!busyQ.isEmpty() && busyQ.peek()[2]==counter){\\n                int[] top = busyQ.poll();\\n                freeQ.offer(new int[]{top[0], top[1]});\\n            }\\n            while(!freeQ.isEmpty() && !taskQ.isEmpty()){\\n                   int task= taskQ.poll();\\n                int[] busy = freeQ.poll();\\n                ans[task]=busy[1];\\n                int val=counter+tasks[task];\\n                busyQ.offer(new int[]{busy[0], busy[1], val});\\n            }\\n            // dont waste time on doing counter++, directly jump onto the next time when a server becomes available.\\n            if(freeQ.isEmpty() && counter>n){\\n                counter=busyQ.peek()[2];\\n            }\\n            else\\n                counter++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int m=servers.length;\\n        int n=tasks.length;\\n        int counter=0;\\n        PriorityQueue<int[]> freeQ=new PriorityQueue<>((a, b) -> (a[0]==b[0])?a[1]-b[1]:a[0]-b[0]);\\n        PriorityQueue<int[]> busyQ=new PriorityQueue<>((a, b) -> a[2]-b[2]);\\n        for(int i=0;i<m;i++){\\n            freeQ.offer(new int[]{servers[i], i}",
                "codeTag": "Java"
            },
            {
                "id": 1288629,
                "title": "c-solution-with-explaination",
                "content": "* Two priority queue -> free and running\\n* Initally all will be free and time to complete the task will be zero, since no task has been assigned yet. So the priority will be based on minimum weight for the servers.\\n* After we assign the task to servers, time completion will be  j + tasks[j] where j is jth second. So the server will be occupied for j + task[j] seconds. So the second priority queue will be based on time for running servers. ( One with minimum time will be priority. )\\n*  jth second > minmum time for task completion in other priority queue, then that server will get poppped off running server and assigned a new task from tasks array.\\n\\n```\\nclass Solution {\\npublic:\\n  vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n    typedef pair < int, pair < int, int >>pi;\\n    priority_queue <pi, vector<pi>, greater<pi>> free, running;\\n    int server_size = servers.size();\\n    int tasks_size = tasks.size();\\n    \\n    vector<int> server_pos;\\n    \\n    for(int i=0; i < server_size; i++){\\n      free.push(make_pair(0, make_pair(servers[i], i)));\\n    }\\n    \\n    int current_time = 0;\\n    \\n    \\n    for(int j = 0; j < tasks_size; j++){\\n      current_time = max(current_time, j);\\n      \\n      if(free.size()==0){\\n\\t\\tpi top = running.top();\\n\\t\\tcurrent_time = top.first; // wait till server becomes free...\\n      }\\n      \\n      \\n      while(running.size()>0 && current_time >= running.top().first){\\n\\t\\tpi top = running.top();\\n\\t\\tfree.push(make_pair(0, make_pair(top.second.first, top.second.second)));\\n\\t\\trunning.pop();\\n      }\\n      \\n      pi top = free.top();\\n      running.push(make_pair(current_time+tasks[j], make_pair(top.second.first, top.second.second)));\\n      free.pop();\\n      \\n      server_pos.push_back(top.second.second);\\n    }\\n    return server_pos;\\n  }   \\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n    typedef pair < int, pair < int, int >>pi;\\n    priority_queue <pi, vector<pi>, greater<pi>> free, running;\\n    int server_size = servers.size();\\n    int tasks_size = tasks.size();\\n    \\n    vector<int> server_pos;\\n    \\n    for(int i=0; i < server_size; i++){\\n      free.push(make_pair(0, make_pair(servers[i], i)));\\n    }\\n    \\n    int current_time = 0;\\n    \\n    \\n    for(int j = 0; j < tasks_size; j++){\\n      current_time = max(current_time, j);\\n      \\n      if(free.size()==0){\\n\\t\\tpi top = running.top();\\n\\t\\tcurrent_time = top.first; // wait till server becomes free...\\n      }\\n      \\n      \\n      while(running.size()>0 && current_time >= running.top().first){\\n\\t\\tpi top = running.top();\\n\\t\\tfree.push(make_pair(0, make_pair(top.second.first, top.second.second)));\\n\\t\\trunning.pop();\\n      }\\n      \\n      pi top = free.top();\\n      running.push(make_pair(current_time+tasks[j], make_pair(top.second.first, top.second.second)));\\n      free.pop();\\n      \\n      server_pos.push_back(top.second.second);\\n    }\\n    return server_pos;\\n  }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240534,
                "title": "c-solution-with-2-min-heaps-servers-and-usedservers",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> pii;\\n    typedef pair<int,pii> pipii;\\n\\t\\n\\t//Comparator for comparing Free Servers in Servers with Minimum Weight and when same weights on indexex\\n    struct myCompares\\n    {\\n        bool operator()(pii& p1, pii& p2)\\n        {\\n            if(p1.first==p2.first)\\n            {\\n                return p1.second>p2.second;\\n            }\\n            return p1.first>p2.first;\\n        }\\n    };\\n    \\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        priority_queue<pii,vector<pii>,myCompares> Servers;   **//Free Servers**\\n\\tpriority_queue<pipii,vector<pipii>,greater<pipii>> usedServers;  **//Used Servers**\\n        \\n        for(int i=0;i<servers.size();i++)\\n        {\\n\\t\\t// Initially Push all servers in Free Server Min Heap\\n            Servers.push({servers[i],i});\\n        }\\n        \\n        vector<int>ans;\\n        int time=0; //Keep a time counter to keep track of time of processes\\n        \\n        for(int i=0;i<tasks.size();) //Now Until all tasks are done run this loop\\n        {\\n\\t\\t\\n\\t\\t//check at this point if at this time instance any servers are freed or not from used servers\\n            while(!usedServers.empty() && usedServers.top().first<=time)\\n            {\\n                Servers.push({usedServers.top().second.first,usedServers.top().second.second});\\n                usedServers.pop();\\n            }\\n            \\n            if(!Servers.empty())\\n            {  //if servers are not empty and time is greater than the assinged tasks indexes then assign all Tasks until that point to all the servers available at the same time\\n                while(!Servers.empty() && i<=time && i<tasks.size())\\n                {\\n\\n                    pii serv=Servers.top();Servers.pop();\\n                    usedServers.push({time+tasks[i],{serv.first,serv.second}});\\n                    ans.push_back(serv.second);\\n                    i++;\\n                }\\n                time++;\\n            }\\n            else time=usedServers.top().first; //if no servers are availble go to time of used servers top elements finising time\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> pii;\\n    typedef pair<int,pii> pipii;\\n\\t\\n\\t//Comparator for comparing Free Servers in Servers with Minimum Weight and when same weights on indexex\\n    struct myCompares\\n    {\\n        bool operator()(pii& p1, pii& p2)\\n        {\\n            if(p1.first==p2.first)\\n            {\\n                return p1.second>p2.second;\\n            }\\n            return p1.first>p2.first;\\n        }\\n    };\\n    \\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        priority_queue<pii,vector<pii>,myCompares> Servers;   **//Free Servers**\\n\\tpriority_queue<pipii,vector<pipii>,greater<pipii>> usedServers;  **//Used Servers**\\n        \\n        for(int i=0;i<servers.size();i++)\\n        {\\n\\t\\t// Initially Push all servers in Free Server Min Heap\\n            Servers.push({servers[i],i});\\n        }\\n        \\n        vector<int>ans;\\n        int time=0; //Keep a time counter to keep track of time of processes\\n        \\n        for(int i=0;i<tasks.size();) //Now Until all tasks are done run this loop\\n        {\\n\\t\\t\\n\\t\\t//check at this point if at this time instance any servers are freed or not from used servers\\n            while(!usedServers.empty() && usedServers.top().first<=time)\\n            {\\n                Servers.push({usedServers.top().second.first,usedServers.top().second.second});\\n                usedServers.pop();\\n            }\\n            \\n            if(!Servers.empty())\\n            {  //if servers are not empty and time is greater than the assinged tasks indexes then assign all Tasks until that point to all the servers available at the same time\\n                while(!Servers.empty() && i<=time && i<tasks.size())\\n                {\\n\\n                    pii serv=Servers.top();Servers.pop();\\n                    usedServers.push({time+tasks[i],{serv.first,serv.second}});\\n                    ans.push_back(serv.second);\\n                    i++;\\n                }\\n                time++;\\n            }\\n            else time=usedServers.top().first; //if no servers are availble go to time of used servers top elements finising time\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240223,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> freePq, busyPq;\\n        \\n        int n = servers.size();\\n        for (int i = 0; i < n; ++i) freePq.push({servers[i], i});\\n        \\n        int m = tasks.size();\\n        vector<int> ans(m);\\n\\n        \\n        int currTime = 0;\\n        for (int i = 0; i < m; ++i) {\\n            if (freePq.empty()) currTime = max(i, busyPq.top().first);\\n            else currTime = max(i, currTime);\\n            \\n            while (!busyPq.empty() && busyPq.top().first <= currTime) {\\n                int idx = busyPq.top().second;\\n                busyPq.pop();\\n                freePq.push({servers[idx], idx});\\n            }\\n            \\n            pair<int, int> p = freePq.top();\\n            freePq.pop();\\n            int sIdx = p.second;\\n            ans[i] = sIdx;\\n            busyPq.push({currTime + tasks[i], sIdx});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> freePq, busyPq;\\n        \\n        int n = servers.size();\\n        for (int i = 0; i < n; ++i) freePq.push({servers[i], i});\\n        \\n        int m = tasks.size();\\n        vector<int> ans(m);\\n\\n        \\n        int currTime = 0;\\n        for (int i = 0; i < m; ++i) {\\n            if (freePq.empty()) currTime = max(i, busyPq.top().first);\\n            else currTime = max(i, currTime);\\n            \\n            while (!busyPq.empty() && busyPq.top().first <= currTime) {\\n                int idx = busyPq.top().second;\\n                busyPq.pop();\\n                freePq.push({servers[idx], idx});\\n            }\\n            \\n            pair<int, int> p = freePq.top();\\n            freePq.pop();\\n            int sIdx = p.second;\\n            ans[i] = sIdx;\\n            busyPq.push({currTime + tasks[i], sIdx});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240135,
                "title": "java-solution-using-two-heaps",
                "content": "```\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Integer> serverQueue = new PriorityQueue<>((a, b) -> servers[a] == servers[b] ? a - b : servers[a] - servers[b]);\\n        PriorityQueue<int[]> tasksQueue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n                PriorityQueue<Integer> maxQueue = new PriorityQueue<>((a, b) -> b - a);\\n\\n        for (int i = 0; i < servers.length; i++) {\\n            serverQueue.add(i);\\n        }\\n        int time = 0;\\n        int i = 0;\\n        while (i < tasks.length) {\\n            while (!tasksQueue.isEmpty() && tasksQueue.peek()[1] <= time) {\\n                int[] arr = tasksQueue.poll();\\n                serverQueue.add(arr[0]);\\n            }\\n            \\n\\n            if (serverQueue.isEmpty()) {\\n                time = tasksQueue.peek()[1];\\n                continue;\\n            }\\n\\n            while (i <= time && i < tasks.length && !serverQueue.isEmpty()) {\\n              int ans = serverQueue.poll();\\n              tasksQueue.add(new int[]{ans, time + tasks[i]});\\n              tasks[i] = ans;\\n              i++;\\n          }\\n           time++;\\n\\n        }\\n        return tasks;\\n    }\\n}\\n\\n\\n/*\\npool will be available. pick min from that.\\ncan maintain another pool where used and at each second check if anything exit from pool. another pq with root as \\n\\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Integer> serverQueue = new PriorityQueue<>((a, b) -> servers[a] == servers[b] ? a - b : servers[a] - servers[b]);\\n        PriorityQueue<int[]> tasksQueue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n                PriorityQueue<Integer> maxQueue = new PriorityQueue<>((a, b) -> b - a);\\n\\n        for (int i = 0; i < servers.length; i++) {\\n            serverQueue.add(i);\\n        }\\n        int time = 0;\\n        int i = 0;\\n        while (i < tasks.length) {\\n            while (!tasksQueue.isEmpty() && tasksQueue.peek()[1] <= time) {\\n                int[] arr = tasksQueue.poll();\\n                serverQueue.add(arr[0]);\\n            }\\n            \\n\\n            if (serverQueue.isEmpty()) {\\n                time = tasksQueue.peek()[1];\\n                continue;\\n            }\\n\\n            while (i <= time && i < tasks.length && !serverQueue.isEmpty()) {\\n              int ans = serverQueue.poll();\\n              tasksQueue.add(new int[]{ans, time + tasks[i]});\\n              tasks[i] = ans;\\n              i++;\\n          }\\n           time++;\\n\\n        }\\n        return tasks;\\n    }\\n}\\n\\n\\n/*\\npool will be available. pick min from that.\\ncan maintain another pool where used and at each second check if anything exit from pool. another pq with root as \\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240092,
                "title": "java-two-heaps-similar-to-rearrange-string-k-distance-apart",
                "content": "One heap store currently available server, order by weight and index. \\nOne heap to store waitlist, order by finish time.\\n```\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            pq.offer(new int[]{i, servers[i], 0});\\n        }\\n        PriorityQueue<int[]> wait = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        \\n        int time = 0, i = 0;\\n        int[] res = new int[tasks.length];\\n        while (i < tasks.length) {\\n            \\n            if (pq.isEmpty()) {\\n                time = wait.peek()[2];\\n            } \\n            while (!wait.isEmpty() && time >= wait.peek()[2]) {\\n                pq.offer(wait.poll());\\n            }\\n            \\n            while (!pq.isEmpty() && i < tasks.length && i < time) {\\n                // there is server\\n                int[] curr = pq.poll(); // get curr servier\\n                res[i] = curr[0]; // put id to;\\n                curr[2] = time + tasks[i]; \\n                wait.offer(curr);  // put to waitlist    \\n                i++;\\n            }\\n            time++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            pq.offer(new int[]{i, servers[i], 0});\\n        }\\n        PriorityQueue<int[]> wait = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        \\n        int time = 0, i = 0;\\n        int[] res = new int[tasks.length];\\n        while (i < tasks.length) {\\n            \\n            if (pq.isEmpty()) {\\n                time = wait.peek()[2];\\n            } \\n            while (!wait.isEmpty() && time >= wait.peek()[2]) {\\n                pq.offer(wait.poll());\\n            }\\n            \\n            while (!pq.isEmpty() && i < tasks.length && i < time) {\\n                // there is server\\n                int[] curr = pq.poll(); // get curr servier\\n                res[i] = curr[0]; // put id to;\\n                curr[2] = time + tasks[i]; \\n                wait.offer(curr);  // put to waitlist    \\n                i++;\\n            }\\n            time++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240058,
                "title": "c-2-priority-queues-solution",
                "content": "I will try to explain  the approach .\\nwe need to assign tasks to servers with least weight . \\nKey point is servers are busy at times and idle at times .\\nServers state is dynamic change with time .\\nAt each sec we need server who is idle with least weight.\\nSo these leads to idea for priority_queue which can give us least weight server at any time.\\n```\\npriority_queue: This can give us least weight server after any insertions and deletions .\\n```\\n\\nNow, main idea:\\n1. we need two priority_queues for to maintain servers which are idle.\\n2. other one for servers which are processing the tasks.\\npq1 = is straightforword , min heap with server weight as priority element\\npq2 ==  ???\\nin pq2 = we can store processing time .\\ncurrentTime + tasks[j].\\n\\nthen its simple : just play with pq1 and pq2 .\\n\\nuse above argument as a hint and try it once .\\n\\n\\n\\n```\\n  class Solution {\\npublic:\\n    struct myComp {\\n    constexpr bool operator()(\\n        pair<int, int> const& a,\\n        pair<int, int> const& b)\\n        const noexcept\\n    {\\n       if(a.first == b.first){\\n           return a.second > b.second;\\n       }\\n        return a.first > b.first;\\n    }\\n};\\n    \\n    \\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n//         two pqs\\n        priority_queue< pair<int,int> , vector<pair<int,int>> , myComp > pq1,pq2;\\n        \\n//         this queue we are using if all servers are busy then serve them in proper order.\\n        queue<int> q;\\n        \\n//         build server pq\\n        for(int i = 0; i < servers.size(); i++){\\n            pq1.push({servers[i],i});\\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        int m = tasks.size(),sec = 0;\\n        \\n//         \\n        for(int i = 0; i < m; i++){\\n            \\n//             check pq2 if any tasks are processed and can push back to pq1\\n            while(!pq2.empty() && pq2.top().first == sec){\\n                pair<int,int> tmp = pq2.top();\\n                pq2.pop();\\n                \\n                pq1.push({servers[tmp.second],tmp.second});\\n            }\\n            \\n            \\n            q.push(i);\\n            \\n//             check pq1 if any servers are available and use them to process our tasks\\n            while(!q.empty() && !pq1.empty()){\\n                pair<int,int> curr = pq1.top();\\n                pq1.pop();\\n                \\n                int ind = q.front();\\n                q.pop();\\n                \\n                ans.push_back(curr.second);\\n                pq2.push({tasks[ind]+sec,curr.second});\\n            }\\n            \\n            sec++;\\n        }\\n        \\n//         this if any tasks still in queue, then process them\\n        while(!q.empty()){\\n            if(pq1.empty()){\\n                sec = pq2.top().first;\\n            }\\n            \\n             while(!pq2.empty() && pq2.top().first == sec){\\n                pair<int,int> tmp = pq2.top();\\n                pq2.pop();\\n                \\n                pq1.push({servers[tmp.second],tmp.second});\\n            }\\n            \\n             while(!q.empty() && !pq1.empty()){\\n                pair<int,int> curr = pq1.top();\\n                pq1.pop();\\n                \\n                int ind = q.front();\\n                q.pop();\\n                \\n                ans.push_back(curr.second);\\n                pq2.push({tasks[ind]+sec,curr.second});\\n            }\\n            \\n            sec++;\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npriority_queue: This can give us least weight server after any insertions and deletions .\\n```\n```\\n  class Solution {\\npublic:\\n    struct myComp {\\n    constexpr bool operator()(\\n        pair<int, int> const& a,\\n        pair<int, int> const& b)\\n        const noexcept\\n    {\\n       if(a.first == b.first){\\n           return a.second > b.second;\\n       }\\n        return a.first > b.first;\\n    }\\n};\\n    \\n    \\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n//         two pqs\\n        priority_queue< pair<int,int> , vector<pair<int,int>> , myComp > pq1,pq2;\\n        \\n//         this queue we are using if all servers are busy then serve them in proper order.\\n        queue<int> q;\\n        \\n//         build server pq\\n        for(int i = 0; i < servers.size(); i++){\\n            pq1.push({servers[i],i});\\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        int m = tasks.size(),sec = 0;\\n        \\n//         \\n        for(int i = 0; i < m; i++){\\n            \\n//             check pq2 if any tasks are processed and can push back to pq1\\n            while(!pq2.empty() && pq2.top().first == sec){\\n                pair<int,int> tmp = pq2.top();\\n                pq2.pop();\\n                \\n                pq1.push({servers[tmp.second],tmp.second});\\n            }\\n            \\n            \\n            q.push(i);\\n            \\n//             check pq1 if any servers are available and use them to process our tasks\\n            while(!q.empty() && !pq1.empty()){\\n                pair<int,int> curr = pq1.top();\\n                pq1.pop();\\n                \\n                int ind = q.front();\\n                q.pop();\\n                \\n                ans.push_back(curr.second);\\n                pq2.push({tasks[ind]+sec,curr.second});\\n            }\\n            \\n            sec++;\\n        }\\n        \\n//         this if any tasks still in queue, then process them\\n        while(!q.empty()){\\n            if(pq1.empty()){\\n                sec = pq2.top().first;\\n            }\\n            \\n             while(!pq2.empty() && pq2.top().first == sec){\\n                pair<int,int> tmp = pq2.top();\\n                pq2.pop();\\n                \\n                pq1.push({servers[tmp.second],tmp.second});\\n            }\\n            \\n             while(!q.empty() && !pq1.empty()){\\n                pair<int,int> curr = pq1.top();\\n                pq1.pop();\\n                \\n                int ind = q.front();\\n                q.pop();\\n                \\n                ans.push_back(curr.second);\\n                pq2.push({tasks[ind]+sec,curr.second});\\n            }\\n            \\n            sec++;\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239927,
                "title": "python3-for-beginners-using-heapq-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        sv = []\\n        for i, s in enumerate(servers):\\n            heappush(sv, (s, i))\\n        out = []\\n        tsk = []\\n        i = 0\\n        for i, t in enumerate(tasks):\\n            while tsk and tsk[0][0] <= i:\\n                time, (pri, si) = heappop(tsk)\\n                heappush(sv, (pri, si))\\n            extra = 0\\n            if not sv: # If there is no server available, we take the first server and add the extra time to track the finish time\\n                time, (pri, si) = heappop(tsk)\\n                heappush(sv, (pri, si))\\n                extra = time - i\\n                \\n            pri, serveri = heappop(sv)\\n            out.append(serveri)\\n            heappush(tsk, (i+t+extra, (pri, serveri)))\\n        return out",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        sv = []\\n        for i, s in enumerate(servers):\\n            heappush(sv, (s, i))\\n        out = []\\n        tsk = []\\n        i = 0\\n        for i, t in enumerate(tasks):\\n            while tsk and tsk[0][0] <= i:\\n                time, (pri, si) = heappop(tsk)\\n                heappush(sv, (pri, si))\\n            extra = 0\\n            if not sv: # If there is no server available, we take the first server and add the extra time to track the finish time\\n                time, (pri, si) = heappop(tsk)\\n                heappush(sv, (pri, si))\\n                extra = time - i\\n                \\n            pri, serveri = heappop(sv)\\n            out.append(serveri)\\n            heappush(tsk, (i+t+extra, (pri, serveri)))\\n        return out",
                "codeTag": "Java"
            },
            {
                "id": 1239909,
                "title": "c-two-min-priority-queue-code-with-comments",
                "content": "```\\n#define ll long long\\n#define ff first\\n#define ss second\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& s, vector<int>& t) {\\n        // min server weight // index;\\n        // This queue is for servers that are free \\n        priority_queue <pair<int,int>, vector<pair<int,int>>, greater< pair<int,int>>> free;\\n        \\n        //freetime // weight //index\\n         // This queue is for servers that are assigned to tasks\\n        priority_queue <pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater< pair<int,pair<int,int>>>> unfree;\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            free.push({s[i] , i});\\n        }\\n        \\n        int time = 0 ;\\n        int n = t.size();\\n        vector<int>ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            // Taking out the server that became free till that time\\n            if(!unfree.empty()){ \\n                while(!unfree.empty()){\\n                    pair<int,pair<int,int>> p = unfree.top();\\n                    if(p.ff <=time){\\n                        unfree.pop();\\n                        free.push({p.ss.ff , p.ss.ss});\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // If no servers available , then wait till that time\\n            if(free.empty()){\\n\\n                pair<int,pair<int,int>> p = unfree.top();\\n                unfree.pop();\\n                ans[i] = p.ss.ss;\\n                unfree.push({p.ff + t[i],{p.ss.ff , p.ss.ss}});\\n                time++ ;\\n                continue;\\n            }\\n            \\n            // else assign the free server\\n            pair<int,int> x = free.top();\\n            free.pop();\\n            ans[i] = x.ss;\\n            unfree.push({time+t[i],{x.ff , x.ss} });\\n            \\n            time++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define ff first\\n#define ss second\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& s, vector<int>& t) {\\n        // min server weight // index;\\n        // This queue is for servers that are free \\n        priority_queue <pair<int,int>, vector<pair<int,int>>, greater< pair<int,int>>> free;\\n        \\n        //freetime // weight //index\\n         // This queue is for servers that are assigned to tasks\\n        priority_queue <pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater< pair<int,pair<int,int>>>> unfree;\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            free.push({s[i] , i});\\n        }\\n        \\n        int time = 0 ;\\n        int n = t.size();\\n        vector<int>ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            // Taking out the server that became free till that time\\n            if(!unfree.empty()){ \\n                while(!unfree.empty()){\\n                    pair<int,pair<int,int>> p = unfree.top();\\n                    if(p.ff <=time){\\n                        unfree.pop();\\n                        free.push({p.ss.ff , p.ss.ss});\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // If no servers available , then wait till that time\\n            if(free.empty()){\\n\\n                pair<int,pair<int,int>> p = unfree.top();\\n                unfree.pop();\\n                ans[i] = p.ss.ss;\\n                unfree.push({p.ff + t[i],{p.ss.ff , p.ss.ss}});\\n                time++ ;\\n                continue;\\n            }\\n            \\n            // else assign the free server\\n            pair<int,int> x = free.top();\\n            free.pop();\\n            ans[i] = x.ss;\\n            unfree.push({time+t[i],{x.ff , x.ss} });\\n            \\n            time++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239786,
                "title": "simple-java-solution-using-priorityqueue-with-comments",
                "content": "Upvote if this helps.\\n```\\nclass Solution {\\n    public int[] assignTasks(int[] s, int[] t) {\\n        PriorityQueue<int[]> sf = new PriorityQueue<>((a,b) -> a[0] == b[0] ? Integer.compare(a[1],b[1]):Integer.compare(a[0],b[0]));//free server with least weight first\\n        for(int i = 0;i<s.length;i++)\\n            sf.offer(new int[]{s[i],i,0});//initially every server is free\\n        int cs = 0;//current second\\n        PriorityQueue<int[]> su = new PriorityQueue<>((a,b) -> Integer.compare(a[2],b[2]));//server which is being used sorted with their free time\\n        int res[] = new int[t.length];\\n        for(int i = 0;i<t.length;){\\n            if(sf.size() == 0) cs = su.peek()[2];//if no server is free skip to the nearest time when a server will be free\\n            while(!su.isEmpty() && su.peek()[2] <= cs) sf.offer(su.poll());//every server which is free till current time add that to free server queue\\n            while(sf.size() != 0 && i<t.length && i<=cs){//assign server to every task which is ready to process at current time\\n                int[] temp = sf.poll();//remove a free server from the queue\\n                res[i] = temp[1];//stored the server assigned in result\\n                temp[2] = cs+t[i];//set the time when the this server will be free and add it to the queue of used server\\n                su.offer(temp);\\n                i++;\\n            }\\n            cs++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] s, int[] t) {\\n        PriorityQueue<int[]> sf = new PriorityQueue<>((a,b) -> a[0] == b[0] ? Integer.compare(a[1],b[1]):Integer.compare(a[0],b[0]));//free server with least weight first\\n        for(int i = 0;i<s.length;i++)\\n            sf.offer(new int[]{s[i],i,0});//initially every server is free\\n        int cs = 0;//current second\\n        PriorityQueue<int[]> su = new PriorityQueue<>((a,b) -> Integer.compare(a[2],b[2]));//server which is being used sorted with their free time\\n        int res[] = new int[t.length];\\n        for(int i = 0;i<t.length;){\\n            if(sf.size() == 0) cs = su.peek()[2];//if no server is free skip to the nearest time when a server will be free\\n            while(!su.isEmpty() && su.peek()[2] <= cs) sf.offer(su.poll());//every server which is free till current time add that to free server queue\\n            while(sf.size() != 0 && i<t.length && i<=cs){//assign server to every task which is ready to process at current time\\n                int[] temp = sf.poll();//remove a free server from the queue\\n                res[i] = temp[1];//stored the server assigned in result\\n                temp[2] = cs+t[i];//set the time when the this server will be free and add it to the queue of used server\\n                su.offer(temp);\\n                i++;\\n            }\\n            cs++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239775,
                "title": "why-this-failed-with-1-value-different",
                "content": "This question is so confusing...   why this failed?  \\n\\ni even tried with multi-tasks case when free servers have the same weight, but still not right....\\n\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        if not tasks or not servers:\\n            return None\\n        \\n        res = []\\n        \\n        heap = []\\n        for i in range(len(servers)):\\n            heapq.heappush(heap, (servers[i], i))\\n            \\n        processing = collections.defaultdict(list)\\n        \\n        sec = 0\\n        tasks_deque = collections.deque(tasks)\\n        \\n        while tasks_deque:\\n            if sec in processing: # start to free server\\n                for s, s_id in processing[sec]:\\n                    heapq.heappush(heap, (s, s_id))\\n                del processing[sec]\\n                \\n            if not heap:\\n                sec += 1\\n                continue\\n\\n            task_time = tasks_deque.popleft()\\n            server, server_ind = heapq.heappop(heap)\\n            res.append(server_ind)\\n            finish_time = sec + task_time\\n            processing[finish_time].append([server, server_ind])      \\n            \\n            # weight = heap[0][0]\\n            # while heap and heap[0][0] == weight and tasks_deque:\\n            #     server, server_ind = heapq.heappop(heap)\\n            #     task_time = tasks_deque.popleft()\\n            #     res.append(server_ind)\\n            #     finish_time = sec + task_time\\n            #     processing[finish_time].append([server, server_ind])      \\n            \\n            sec += 1\\n\\n        return res\\n            \\n",
                "solutionTags": [],
                "code": "This question is so confusing...   why this failed?  \\n\\ni even tried with multi-tasks case when free servers have the same weight, but still not right....\\n\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        if not tasks or not servers:\\n            return None\\n        \\n        res = []\\n        \\n        heap = []\\n        for i in range(len(servers)):\\n            heapq.heappush(heap, (servers[i], i))\\n            \\n        processing = collections.defaultdict(list)\\n        \\n        sec = 0\\n        tasks_deque = collections.deque(tasks)\\n        \\n        while tasks_deque:\\n            if sec in processing: # start to free server\\n                for s, s_id in processing[sec]:\\n                    heapq.heappush(heap, (s, s_id))\\n                del processing[sec]\\n                \\n            if not heap:\\n                sec += 1\\n                continue\\n\\n            task_time = tasks_deque.popleft()\\n            server, server_ind = heapq.heappop(heap)\\n            res.append(server_ind)\\n            finish_time = sec + task_time\\n            processing[finish_time].append([server, server_ind])      \\n            \\n            # weight = heap[0][0]\\n            # while heap and heap[0][0] == weight and tasks_deque:\\n            #     server, server_ind = heapq.heappop(heap)\\n            #     task_time = tasks_deque.popleft()\\n            #     res.append(server_ind)\\n            #     finish_time = sec + task_time\\n            #     processing[finish_time].append([server, server_ind])      \\n            \\n            sec += 1\\n\\n        return res\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1239764,
                "title": "easy-priorityqueue-solution",
                "content": "Available priorityqueue contains available servers\\n(a, b) -> (weight, index)\\n\\nBusy priorityqueue contains busy servers\\n(a, b, c) -> (weight, index, time) -> server is busy till \"time\"\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> available = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        int m = servers.length, n = tasks.length;\\n        int[] ans = new int[n];\\n        for (int j = 0; j < m; j++){\\n            available.offer(new int[]{servers[j], j});\\n        }     \\n        int time = 0;\\n        int i = 0;\\n        while(i < n){\\n            while(!busy.isEmpty() && busy.peek()[2] <= time){\\n                int[] cur = busy.poll();\\n                available.add(new  int[]{cur[0], cur[1]});\\n            }\\n            if(available.isEmpty()){\\n                time = busy.peek()[2];\\n                continue;\\n            }\\n            while(i < n && i <= time && !available.isEmpty()){\\n                int[] cur = available.poll();\\n                ans[i] = cur[1];\\n                busy.offer(new int[]{cur[0], cur[1], time + tasks[i]});\\n                i++;\\n            }\\n            time++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nTime Complexity: O(mlog(m) + nlog(m)) = O((m + n)log(m))",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> available = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        int m = servers.length, n = tasks.length;\\n        int[] ans = new int[n];\\n        for (int j = 0; j < m; j++){\\n            available.offer(new int[]{servers[j], j});\\n        }     \\n        int time = 0;\\n        int i = 0;\\n        while(i < n){\\n            while(!busy.isEmpty() && busy.peek()[2] <= time){\\n                int[] cur = busy.poll();\\n                available.add(new  int[]{cur[0], cur[1]});\\n            }\\n            if(available.isEmpty()){\\n                time = busy.peek()[2];\\n                continue;\\n            }\\n            while(i < n && i <= time && !available.isEmpty()){\\n                int[] cur = available.poll();\\n                ans[i] = cur[1];\\n                busy.offer(new int[]{cur[0], cur[1], time + tasks[i]});\\n                i++;\\n            }\\n            time++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892432,
                "title": "c-2-queues-solution",
                "content": "```\\npublic class Solution {\\n    public int[] AssignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server,Server> busy = new(new ServerComparer());\\n        PriorityQueue<Server,Server> avail = new(new ServerComparer());\\n        for(int i = 0; i < servers.Length; i++){\\n            var s = new Server() { TimeFree = 0, Weight = servers[i], Index = i };\\n            avail.Enqueue(s,s);\\n        }\\n        int[] result = new int[tasks.Length];\\n        int currTime = 0, resultIdx = 0;\\n        for(int i = 0; i < tasks.Length;){\\n            // if server has finished it\\'s work move it back to avail queue\\n            while(busy.Count > 0 && busy.Peek().TimeFree <= currTime){\\n                var s = busy.Dequeue();\\n                s.TimeFree = 0;\\n                avail.Enqueue(s,s);             \\n            }\\n            // while process all tasks with start time less or equal to curr time\\n            while(i < tasks.Length && i <= currTime && avail.Count > 0){\\n                var s = avail.Dequeue();\\n                s.TimeFree = currTime+tasks[i];\\n                busy.Enqueue(s,s);\\n                result[resultIdx++] = s.Index;\\n                i++;\\n            }\\n            // if no available servers - move in time when \\n            // one of the servers becomes available \\n            if(avail.Count == 0) currTime = busy.Peek().TimeFree;\\n            else currTime++;\\n        }\\n        return result;\\n    }\\n    class Server{\\n        public int TimeFree { get; set; }\\n        public int Weight { get; set; }\\n        public int Index { get; set; }\\n    }\\n    class ServerComparer : IComparer<Server>{\\n        public int Compare(Server x, Server y){\\n            if(x.TimeFree != y.TimeFree){\\n                return x.TimeFree-y.TimeFree;\\n            } else if(x.Weight != y.Weight){\\n                return x.Weight-y.Weight;\\n            } else\\n                return x.Index-y.Index;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] AssignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server,Server> busy = new(new ServerComparer());\\n        PriorityQueue<Server,Server> avail = new(new ServerComparer());\\n        for(int i = 0; i < servers.Length; i++){\\n            var s = new Server() { TimeFree = 0, Weight = servers[i], Index = i };\\n            avail.Enqueue(s,s);\\n        }\\n        int[] result = new int[tasks.Length];\\n        int currTime = 0, resultIdx = 0;\\n        for(int i = 0; i < tasks.Length;){\\n            // if server has finished it\\'s work move it back to avail queue\\n            while(busy.Count > 0 && busy.Peek().TimeFree <= currTime){\\n                var s = busy.Dequeue();\\n                s.TimeFree = 0;\\n                avail.Enqueue(s,s);             \\n            }\\n            // while process all tasks with start time less or equal to curr time\\n            while(i < tasks.Length && i <= currTime && avail.Count > 0){\\n                var s = avail.Dequeue();\\n                s.TimeFree = currTime+tasks[i];\\n                busy.Enqueue(s,s);\\n                result[resultIdx++] = s.Index;\\n                i++;\\n            }\\n            // if no available servers - move in time when \\n            // one of the servers becomes available \\n            if(avail.Count == 0) currTime = busy.Peek().TimeFree;\\n            else currTime++;\\n        }\\n        return result;\\n    }\\n    class Server{\\n        public int TimeFree { get; set; }\\n        public int Weight { get; set; }\\n        public int Index { get; set; }\\n    }\\n    class ServerComparer : IComparer<Server>{\\n        public int Compare(Server x, Server y){\\n            if(x.TimeFree != y.TimeFree){\\n                return x.TimeFree-y.TimeFree;\\n            } else if(x.Weight != y.Weight){\\n                return x.Weight-y.Weight;\\n            } else\\n                return x.Index-y.Index;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179819,
                "title": "c-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int i, j;\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> busyServers;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> freeServers;\\n        \\n        vector<int> ans(tasks.size());\\n        \\n        for(i = 0; i < servers.size(); i++){\\n            freeServers.push({servers[i], i});\\n        }\\n        \\n        int head = 0;\\n        for(i = 0; i < tasks.size(); i++){  \\n            while(!busyServers.empty() && busyServers.top()[0] <= i){\\n                vector<int> temp = busyServers.top();\\n                busyServers.pop();\\n                freeServers.push({temp[1], temp[2]});\\n            }\\n            \\n            while(head <= i && !freeServers.empty()){\\n                pair<int, int> p = freeServers.top();\\n                freeServers.pop();\\n                vector<int> temp{i + tasks[head], p.first, p.second};\\n                busyServers.push(temp);\\n                ans[head++] = p.second;\\n            }   \\n        }\\n        \\n        int time = tasks.size() - 1;\\n        \\n        while(head < tasks.size()){\\n            if(freeServers.empty()){\\n                time = busyServers.top()[0];\\n            }\\n            \\n            while(!busyServers.empty() && busyServers.top()[0] <= time){\\n                vector<int> temp = busyServers.top();\\n                busyServers.pop();\\n                freeServers.push({temp[1], temp[2]});\\n            }\\n            \\n            while(head < tasks.size() && !freeServers.empty()){\\n                pair<int, int> p = freeServers.top();\\n                freeServers.pop();\\n                vector<int> temp{time + tasks[head], p.first, p.second};\\n                busyServers.push(temp);\\n                ans[head++] = p.second;\\n            }   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int i, j;\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> busyServers;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> freeServers;\\n        \\n        vector<int> ans(tasks.size());\\n        \\n        for(i = 0; i < servers.size(); i++){\\n            freeServers.push({servers[i], i});\\n        }\\n        \\n        int head = 0;\\n        for(i = 0; i < tasks.size(); i++){  \\n            while(!busyServers.empty() && busyServers.top()[0] <= i){\\n                vector<int> temp = busyServers.top();\\n                busyServers.pop();\\n                freeServers.push({temp[1], temp[2]});\\n            }\\n            \\n            while(head <= i && !freeServers.empty()){\\n                pair<int, int> p = freeServers.top();\\n                freeServers.pop();\\n                vector<int> temp{i + tasks[head], p.first, p.second};\\n                busyServers.push(temp);\\n                ans[head++] = p.second;\\n            }   \\n        }\\n        \\n        int time = tasks.size() - 1;\\n        \\n        while(head < tasks.size()){\\n            if(freeServers.empty()){\\n                time = busyServers.top()[0];\\n            }\\n            \\n            while(!busyServers.empty() && busyServers.top()[0] <= time){\\n                vector<int> temp = busyServers.top();\\n                busyServers.pop();\\n                freeServers.push({temp[1], temp[2]});\\n            }\\n            \\n            while(head < tasks.size() && !freeServers.empty()){\\n                pair<int, int> p = freeServers.top();\\n                freeServers.pop();\\n                vector<int> temp{time + tasks[head], p.first, p.second};\\n                busyServers.push(temp);\\n                ans[head++] = p.second;\\n            }   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917936,
                "title": "javascript-solution-two-heaps",
                "content": "```\\nvar assignTasks = function(servers, tasks) {\\n    const n = servers.length;\\n    const m = tasks.length;\\n    \\n    // The freeServers are prioritized by the min. weights and then their indexes\\n    const freeServers = new PriorityQueue((a, b) =>  a.weight - b.weight || a.index - b.index);\\n    \\n    for (let index = 0; index < n; ++index) {\\n        const weight = servers[index];\\n        \\n        freeServers.enqueue({ endTime: -1, weight, index });\\n    }\\n   \\n    // Working servers are prioritized by their ending time.\\n    const workingServers = new PriorityQueue((a, b) => a.endTime - b.endTime);\\n   \\n    const res = [];\\n    \\n    let secs = 0;\\n    let taskIdx = 0;\\n    \\n    while (taskIdx < m) {\\n\\n        while (!workingServers.isEmpty() && workingServers.peek().endTime === secs) {\\n            const popped = workingServers.dequeue();\\n            freeServers.enqueue(popped);\\n        }\\n    \\n        if (!freeServers.isEmpty()) {\\n            while (!freeServers.isEmpty() && taskIdx < m && taskIdx <= secs) { // we can batch assign the free servers to the available tasks\\n                const topServer = freeServers.dequeue();\\n\\n                res[taskIdx] = topServer.index;\\n\\n                topServer.endTime = secs + tasks[taskIdx];\\n\\n                workingServers.enqueue(topServer);\\n\\n                ++taskIdx;\\n            }\\n            \\n            secs++;\\n            \\n        } else {\\n            // If we don\\'t have any free servers, we can jump our time all the way to the earliest ending working server\\n            secs = workingServers.peek().endTime; \\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nclass PriorityQueue {\\n    constructor(compare) {\\n      this.compare = compare; // compare function\\n      this.heap = [];\\n    }\\n\\t\\t\\n    size() {\\n      return this.heap.length; \\n    }\\n    \\n    isEmpty() {\\n      return this.size() === 0;\\n    }\\n    \\n    peek() {\\n      return this.heap[0];\\n    }\\n    \\n    getLeftIndex(index) {\\n      return index * 2 + 1;\\n    }\\n    \\n    getRightIndex(index) {\\n      return index * 2 + 2;\\n    }\\n    \\n    getParentIndex(index) {\\n      return Math.floor((index - 1) / 2);\\n    }\\n\\n    swap(i, j) {\\n      [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\\n    }\\n    \\n    enqueue(val) {\\n      this.heap.push(val);\\n      this.swim(this.heap.length - 1);\\n    }\\n    \\n    swim(index) {\\n      let parentIdx = this.getParentIndex(index);\\n        \\n      while (index > 0  && this.compare(this.heap[parentIdx], this.heap[index]) > 0) {\\n        this.swap(parentIdx, index);\\n        \\n        index = parentIdx;\\n        parentIdx = this.getParentIndex(index);\\n      }\\n        \\n      return;\\n    }\\n    \\n    dequeue() {\\n      const min = this.heap[0];\\n      this.swap(0, this.size() - 1);\\n      this.heap.pop();\\n      this.sink(0); \\n      \\n      return min;\\n    }\\n    \\n    sink(index) {\\n      let minIdx = index;\\n        \\n      const size = this.size();\\n      const leftIdx = this.getLeftIndex(minIdx);\\n      const rightIdx = this.getRightIndex(minIdx);\\n        \\n      if (leftIdx < size && this.compare(this.heap[minIdx], this.heap[leftIdx]) > 0) {\\n        minIdx = leftIdx;\\n      } \\n      \\n      if (rightIdx < size && this.compare(this.heap[minIdx], this.heap[rightIdx]) > 0) {\\n        minIdx = rightIdx;\\n      }\\n      \\n      if (index != minIdx) {\\n        this.swap(index, minIdx);\\n        this.sink(minIdx);\\n      }\\n      \\n      return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar assignTasks = function(servers, tasks) {\\n    const n = servers.length;\\n    const m = tasks.length;\\n    \\n    // The freeServers are prioritized by the min. weights and then their indexes\\n    const freeServers = new PriorityQueue((a, b) =>  a.weight - b.weight || a.index - b.index);\\n    \\n    for (let index = 0; index < n; ++index) {\\n        const weight = servers[index];\\n        \\n        freeServers.enqueue({ endTime: -1, weight, index });\\n    }\\n   \\n    // Working servers are prioritized by their ending time.\\n    const workingServers = new PriorityQueue((a, b) => a.endTime - b.endTime);\\n   \\n    const res = [];\\n    \\n    let secs = 0;\\n    let taskIdx = 0;\\n    \\n    while (taskIdx < m) {\\n\\n        while (!workingServers.isEmpty() && workingServers.peek().endTime === secs) {\\n            const popped = workingServers.dequeue();\\n            freeServers.enqueue(popped);\\n        }\\n    \\n        if (!freeServers.isEmpty()) {\\n            while (!freeServers.isEmpty() && taskIdx < m && taskIdx <= secs) { // we can batch assign the free servers to the available tasks\\n                const topServer = freeServers.dequeue();\\n\\n                res[taskIdx] = topServer.index;\\n\\n                topServer.endTime = secs + tasks[taskIdx];\\n\\n                workingServers.enqueue(topServer);\\n\\n                ++taskIdx;\\n            }\\n            \\n            secs++;\\n            \\n        } else {\\n            // If we don\\'t have any free servers, we can jump our time all the way to the earliest ending working server\\n            secs = workingServers.peek().endTime; \\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nclass PriorityQueue {\\n    constructor(compare) {\\n      this.compare = compare; // compare function\\n      this.heap = [];\\n    }\\n\\t\\t\\n    size() {\\n      return this.heap.length; \\n    }\\n    \\n    isEmpty() {\\n      return this.size() === 0;\\n    }\\n    \\n    peek() {\\n      return this.heap[0];\\n    }\\n    \\n    getLeftIndex(index) {\\n      return index * 2 + 1;\\n    }\\n    \\n    getRightIndex(index) {\\n      return index * 2 + 2;\\n    }\\n    \\n    getParentIndex(index) {\\n      return Math.floor((index - 1) / 2);\\n    }\\n\\n    swap(i, j) {\\n      [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\\n    }\\n    \\n    enqueue(val) {\\n      this.heap.push(val);\\n      this.swim(this.heap.length - 1);\\n    }\\n    \\n    swim(index) {\\n      let parentIdx = this.getParentIndex(index);\\n        \\n      while (index > 0  && this.compare(this.heap[parentIdx], this.heap[index]) > 0) {\\n        this.swap(parentIdx, index);\\n        \\n        index = parentIdx;\\n        parentIdx = this.getParentIndex(index);\\n      }\\n        \\n      return;\\n    }\\n    \\n    dequeue() {\\n      const min = this.heap[0];\\n      this.swap(0, this.size() - 1);\\n      this.heap.pop();\\n      this.sink(0); \\n      \\n      return min;\\n    }\\n    \\n    sink(index) {\\n      let minIdx = index;\\n        \\n      const size = this.size();\\n      const leftIdx = this.getLeftIndex(minIdx);\\n      const rightIdx = this.getRightIndex(minIdx);\\n        \\n      if (leftIdx < size && this.compare(this.heap[minIdx], this.heap[leftIdx]) > 0) {\\n        minIdx = leftIdx;\\n      } \\n      \\n      if (rightIdx < size && this.compare(this.heap[minIdx], this.heap[rightIdx]) > 0) {\\n        minIdx = rightIdx;\\n      }\\n      \\n      if (index != minIdx) {\\n        this.swap(index, minIdx);\\n        this.sink(minIdx);\\n      }\\n      \\n      return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802015,
                "title": "issue-with-test-case-27",
                "content": "I think my solution is very similar to the 2 heaps simulation submitted by many on here.\\n\\nHow ever I am seeing an issue with test case 27, where the order of servers 36,56 in my solution is reversed. Not able to spot the bug in my code if any.\\n\\n```\\nfrom collections import deque\\nimport heapq\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        time = 0\\n        currTask = 0\\n        usedHeap = []\\n        availableHeap = []\\n        result = [-1 for task in tasks]\\n        self.addServers(availableHeap, servers)\\n        while currTask < len(tasks):\\n            isAssigned = self.assignTask(availableHeap, usedHeap, servers, currTask, tasks, time, result)\\n            if isAssigned:\\n                currTask += 1\\n            time += 1\\n        return result\\n        \\n    def assignTask(self, availableHeap, usedHeap, servers, taskIndex, tasks, time, result):\\n        taskDuration = tasks[taskIndex]\\n        self.reclaimAvailableServers(availableHeap, usedHeap, servers, time)\\n        if availableHeap:\\n             # assign task to this server\\n            avHeapTopWeight, avHeapTopIndex = availableHeap[0]\\n            newAvTime = time + taskDuration\\n            result[taskIndex] = avHeapTopIndex\\n            heapq.heappop(availableHeap)\\n            heapq.heappush(usedHeap, (newAvTime, avHeapTopIndex))\\n            return True\\n        else:\\n            return False\\n\\n    def reclaimAvailableServers(self, availableHeap, usedHeap, servers, time):\\n        while usedHeap:\\n            usedTopTime, usedTopIndex = usedHeap[0]\\n            if time >= usedTopTime:\\n                heapq.heappop(usedHeap)\\n                heapq.heappush(availableHeap, (servers[usedTopIndex], usedTopIndex))\\n            else:\\n                break\\n    \\n        \\n    def addServers(self, heap, servers):\\n        for i, server in enumerate(servers):\\n            # available time, weight, index\\n            heapq.heappush(heap, (server, i))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nimport heapq\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        time = 0\\n        currTask = 0\\n        usedHeap = []\\n        availableHeap = []\\n        result = [-1 for task in tasks]\\n        self.addServers(availableHeap, servers)\\n        while currTask < len(tasks):\\n            isAssigned = self.assignTask(availableHeap, usedHeap, servers, currTask, tasks, time, result)\\n            if isAssigned:\\n                currTask += 1\\n            time += 1\\n        return result\\n        \\n    def assignTask(self, availableHeap, usedHeap, servers, taskIndex, tasks, time, result):\\n        taskDuration = tasks[taskIndex]\\n        self.reclaimAvailableServers(availableHeap, usedHeap, servers, time)\\n        if availableHeap:\\n             # assign task to this server\\n            avHeapTopWeight, avHeapTopIndex = availableHeap[0]\\n            newAvTime = time + taskDuration\\n            result[taskIndex] = avHeapTopIndex\\n            heapq.heappop(availableHeap)\\n            heapq.heappush(usedHeap, (newAvTime, avHeapTopIndex))\\n            return True\\n        else:\\n            return False\\n\\n    def reclaimAvailableServers(self, availableHeap, usedHeap, servers, time):\\n        while usedHeap:\\n            usedTopTime, usedTopIndex = usedHeap[0]\\n            if time >= usedTopTime:\\n                heapq.heappop(usedHeap)\\n                heapq.heappush(availableHeap, (servers[usedTopIndex], usedTopIndex))\\n            else:\\n                break\\n    \\n        \\n    def addServers(self, heap, servers):\\n        for i, server in enumerate(servers):\\n            # available time, weight, index\\n            heapq.heappush(heap, (server, i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703249,
                "title": "c-with-a-key-insight",
                "content": "vector operations in c++ are heavy so will give TLE. the code using Vectors is given below and the next code is written using the pairs which got accepted. *So if you want to have finite number of parameters inside the priority_queue* **never use vectors use pairs instead**\\n```\\nclass compare1\\n{\\n    public:\\n    bool operator()(vector<int>&a ,vector<int>&b)\\n    {\\n        \\n        if(a[0] == b[0])\\n        {\\n            if(a[1] == b[1])\\n                return (a[2] > b[2]);\\n            return (a[1] > b[1]);\\n        }\\n        \\n        return (a[0] > b[0]);\\n    }\\n};\\nclass compare2\\n{\\n    public:\\n    bool operator()(vector<int>&a ,vector<int>&b)\\n    {\\n        if(a[0] == b[0])\\n            return (a[1] > b[1]);\\n        return (a[0] > b[0]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& s, vector<int>& t) \\n    {\\n        int n = s.size();\\n        int m = t.size();\\n        priority_queue<vector<int>,vector<vector<int>>,compare1>processing;\\n        priority_queue<vector<int>,vector<vector<int>>,compare2>free;\\n        queue<int>q;\\n        vector<int>assign(m,0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            free.push({s[i],i});\\n        }\\n        for(int i = 0; i < m; i++)\\n        {\\n            while(!processing.empty() and processing.top()[0] <= i)\\n            {\\n                free.push({processing.top()[1],processing.top()[2]});\\n                processing.pop();\\n            }\\n            q.push(i);\\n            while(!free.empty() and !q.empty())\\n            {\\n                int cur = q.front();\\n                q.pop();\\n                vector<int>best = free.top();\\n                free.pop();\\n                assign[cur] = best[1];\\n                processing.push({i + t[cur],best[0],best[1]});\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int cur = q.front();\\n            q.pop();\\n            vector<int>out = processing.top(); \\n            free.push({processing.top()[1],processing.top()[2]});\\n            processing.pop();\\n            vector<int>best = free.top();\\n            free.pop();\\n            assign[cur] = best[1];\\n            processing.push({out[0] + t[cur],best[0],best[1]});\\n        }\\n        return assign;\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\n***The code below has pairs inside the priority queue which will be accepted.***\\n```\\nclass compare1\\n{\\n    public:\\n    bool operator()(pair<int,pair<int,int>>&a ,pair<int,pair<int,int>>&b)\\n    {\\n        \\n        if(a.first == b.first)\\n        {\\n            if(a.second.first == b.second.first)\\n                return (a.second.second > b.second.second);\\n            return (a.second.first > b.second.first);\\n        }\\n        return (a.first > b.first);\\n    }\\n};\\nclass compare2\\n{\\n    public:\\n    bool operator()(pair<int,int>&a ,pair<int,int>&b)\\n    {\\n        if(a.first == b.first)\\n            return (a.second > b.second);\\n        return (a.first > b.first);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& s, vector<int>& t) \\n    {\\n        int n = s.size();\\n        int m = t.size();\\n        priority_queue<pair<int,pair<int,int>>,vector< pair<int,pair<int,int>> >,compare1>processing;\\n        priority_queue<pair<int,int>,vector< pair<int,int> >,compare2>free;\\n        queue<int>q;\\n        vector<int>assign(m,0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            free.push({s[i],i});\\n        }\\n        for(int i = 0; i < m; i++)\\n        {\\n            while(!processing.empty() and processing.top().first <= i)\\n            {\\n                free.push({processing.top().second.first,processing.top().second.second});\\n                processing.pop();\\n            }\\n            q.push(i);\\n            while(!free.empty() and !q.empty())\\n            {\\n                int cur = q.front();\\n                q.pop();\\n                pair<int,int>best = free.top();\\n                free.pop();\\n                assign[cur] = best.second;\\n                processing.push({i + t[cur], {best.first,best.second} });\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int cur = q.front();\\n            q.pop();\\n            pair<int,pair<int,int>>out = processing.top(); \\n            free.push({processing.top().second.first,processing.top().second.second});\\n            processing.pop();\\n            pair<int,int>best = free.top();\\n            free.pop();\\n            assign[cur] = best.second;\\n            processing.push({out.first + t[cur],{best.first,best.second}} );\\n        }\\n        return assign;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass compare1\\n{\\n    public:\\n    bool operator()(vector<int>&a ,vector<int>&b)\\n    {\\n        \\n        if(a[0] == b[0])\\n        {\\n            if(a[1] == b[1])\\n                return (a[2] > b[2]);\\n            return (a[1] > b[1]);\\n        }\\n        \\n        return (a[0] > b[0]);\\n    }\\n};\\nclass compare2\\n{\\n    public:\\n    bool operator()(vector<int>&a ,vector<int>&b)\\n    {\\n        if(a[0] == b[0])\\n            return (a[1] > b[1]);\\n        return (a[0] > b[0]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& s, vector<int>& t) \\n    {\\n        int n = s.size();\\n        int m = t.size();\\n        priority_queue<vector<int>,vector<vector<int>>,compare1>processing;\\n        priority_queue<vector<int>,vector<vector<int>>,compare2>free;\\n        queue<int>q;\\n        vector<int>assign(m,0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            free.push({s[i],i});\\n        }\\n        for(int i = 0; i < m; i++)\\n        {\\n            while(!processing.empty() and processing.top()[0] <= i)\\n            {\\n                free.push({processing.top()[1],processing.top()[2]});\\n                processing.pop();\\n            }\\n            q.push(i);\\n            while(!free.empty() and !q.empty())\\n            {\\n                int cur = q.front();\\n                q.pop();\\n                vector<int>best = free.top();\\n                free.pop();\\n                assign[cur] = best[1];\\n                processing.push({i + t[cur],best[0],best[1]});\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int cur = q.front();\\n            q.pop();\\n            vector<int>out = processing.top(); \\n            free.push({processing.top()[1],processing.top()[2]});\\n            processing.pop();\\n            vector<int>best = free.top();\\n            free.pop();\\n            assign[cur] = best[1];\\n            processing.push({out[0] + t[cur],best[0],best[1]});\\n        }\\n        return assign;\\n        \\n        \\n        \\n    }\\n};\\n```\n```\\nclass compare1\\n{\\n    public:\\n    bool operator()(pair<int,pair<int,int>>&a ,pair<int,pair<int,int>>&b)\\n    {\\n        \\n        if(a.first == b.first)\\n        {\\n            if(a.second.first == b.second.first)\\n                return (a.second.second > b.second.second);\\n            return (a.second.first > b.second.first);\\n        }\\n        return (a.first > b.first);\\n    }\\n};\\nclass compare2\\n{\\n    public:\\n    bool operator()(pair<int,int>&a ,pair<int,int>&b)\\n    {\\n        if(a.first == b.first)\\n            return (a.second > b.second);\\n        return (a.first > b.first);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& s, vector<int>& t) \\n    {\\n        int n = s.size();\\n        int m = t.size();\\n        priority_queue<pair<int,pair<int,int>>,vector< pair<int,pair<int,int>> >,compare1>processing;\\n        priority_queue<pair<int,int>,vector< pair<int,int> >,compare2>free;\\n        queue<int>q;\\n        vector<int>assign(m,0);\\n        for(int i = 0; i < n; i++)\\n        {\\n            free.push({s[i],i});\\n        }\\n        for(int i = 0; i < m; i++)\\n        {\\n            while(!processing.empty() and processing.top().first <= i)\\n            {\\n                free.push({processing.top().second.first,processing.top().second.second});\\n                processing.pop();\\n            }\\n            q.push(i);\\n            while(!free.empty() and !q.empty())\\n            {\\n                int cur = q.front();\\n                q.pop();\\n                pair<int,int>best = free.top();\\n                free.pop();\\n                assign[cur] = best.second;\\n                processing.push({i + t[cur], {best.first,best.second} });\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int cur = q.front();\\n            q.pop();\\n            pair<int,pair<int,int>>out = processing.top(); \\n            free.push({processing.top().second.first,processing.top().second.second});\\n            processing.pop();\\n            pair<int,int>best = free.top();\\n            free.pop();\\n            assign[cur] = best.second;\\n            processing.push({out.first + t[cur],{best.first,best.second}} );\\n        }\\n        return assign;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679506,
                "title": "python-91-faster-two-heaps",
                "content": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = []\\n        ans = []\\n        busy = []\\n        \\n        for i, wt in enumerate(servers):\\n            heapq.heappush(free, (wt,i))\\n\\n        for t, task in enumerate(tasks):\\n            f = t + task\\n            while busy and busy[0][0]<=t:\\n                _, wt, i = heapq.heappop(busy)\\n                heapq.heappush(free, (wt, i))\\n            if free:\\n                s_wt, s_i  = heapq.heappop(free)\\n                ans.append(s_i)    \\n                heapq.heappush(busy, (f, s_wt, s_i))\\n            else:\\n                # if not free , get the next server which will become free,\\n                # and add the task time to it and insert back\\n                bt, s_wt, s_i  = heapq.heappop(busy)\\n                ans.append(s_i)    \\n                heapq.heappush(busy, (bt+task, s_wt, s_i))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = []\\n        ans = []\\n        busy = []\\n        \\n        for i, wt in enumerate(servers):\\n            heapq.heappush(free, (wt,i))\\n\\n        for t, task in enumerate(tasks):\\n            f = t + task\\n            while busy and busy[0][0]<=t:\\n                _, wt, i = heapq.heappop(busy)\\n                heapq.heappush(free, (wt, i))\\n            if free:\\n                s_wt, s_i  = heapq.heappop(free)\\n                ans.append(s_i)    \\n                heapq.heappush(busy, (f, s_wt, s_i))\\n            else:\\n                # if not free , get the next server which will become free,\\n                # and add the task time to it and insert back\\n                bt, s_wt, s_i  = heapq.heappop(busy)\\n                ans.append(s_i)    \\n                heapq.heappush(busy, (bt+task, s_wt, s_i))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469470,
                "title": "java-two-heaps-one-queue",
                "content": "```\\n   class Solution {\\n        public int[] assignTasks(int[] servers, int[] tasks) {\\n            /**\\n             * idle pq with free servers.\\n             * int[] {server_idx, server_weight}\\n             */\\n            PriorityQueue<int[]> idle = new PriorityQueue<>((a, b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n            for (int i = 0; i < servers.length; i++) {\\n                idle.offer(new int[]{i, servers[i]});\\n            }\\n\\n            /**\\n             * busy pq with servers that are busy\\n             * int[] {server_idx, task_finish_time, server_weight}\\n             */\\n            PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n\\n            Queue<int[]> q = new LinkedList<>();\\n            int n = tasks.length;\\n\\n            int[] res = new int[n];\\n            int i = 0;\\n\\n            /**\\n             * !!!\\n             * Can\\'t just iterate through tasks index, process time may be very long and it may finish long after\\n             * the last task is put into queue. We also need to wait until the task queue is empty (all tasks are\\n             * assigned with servers)\\n             */\\n            while (i < n || !q.isEmpty()) {\\n                /**\\n                 * enqueue task when it comes its time.\\n                 */\\n                if (i < n)  {\\n                    q.offer(new int[]{i, tasks[i]});\\n                }\\n\\n                /**\\n                 * Release all servers that finished their tasks at current time\\n                 * and put into idle pq.\\n                 */\\n                while (!busy.isEmpty() && busy.peek()[1] == i) {\\n                    int[] s = busy.poll();\\n                    idle.offer(new int[]{s[0], s[2]});\\n                }\\n\\n                /**\\n                 * Assign tasks to servers, put servers to busy pq.\\n                 * Because we always assign server from idle pq, it\\'s already properly sorted based on weight and idx,\\n                 * so the busy pq only needs to be sorted by finish_time.\\n                 */\\n                while (!idle.isEmpty() && !q.isEmpty()) {\\n                    int[] server = idle.poll();\\n                    int[] task = q.poll();\\n                    res[task[0]] = server[0];\\n                    busy.offer(new int[]{server[0], i + task[1], server[1]});\\n                }\\n\\n                /**\\n                 * Speed up the iteration for test case like:\\n                 * Servers : [1,2,3,4,5,6,7,8,9,10]\\n                 * Tasks : [90000,90001,90002,90003,90004,90005,90006,90007,90008,90009,....]\\n                 *\\n                 * After all tasks are put into q, find the finish time of the top element in busy pq, catch up with it.\\n                 *\\n                 * Without this logic, it will TLE.\\n                 */\\n                if (i >= n && !busy.isEmpty() && busy.peek()[1] > i) {\\n                    i = busy.peek()[1];\\n                } else {\\n                    i++;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   class Solution {\\n        public int[] assignTasks(int[] servers, int[] tasks) {\\n            /**\\n             * idle pq with free servers.\\n             * int[] {server_idx, server_weight}\\n             */\\n            PriorityQueue<int[]> idle = new PriorityQueue<>((a, b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n            for (int i = 0; i < servers.length; i++) {\\n                idle.offer(new int[]{i, servers[i]});\\n            }\\n\\n            /**\\n             * busy pq with servers that are busy\\n             * int[] {server_idx, task_finish_time, server_weight}\\n             */\\n            PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n\\n            Queue<int[]> q = new LinkedList<>();\\n            int n = tasks.length;\\n\\n            int[] res = new int[n];\\n            int i = 0;\\n\\n            /**\\n             * !!!\\n             * Can\\'t just iterate through tasks index, process time may be very long and it may finish long after\\n             * the last task is put into queue. We also need to wait until the task queue is empty (all tasks are\\n             * assigned with servers)\\n             */\\n            while (i < n || !q.isEmpty()) {\\n                /**\\n                 * enqueue task when it comes its time.\\n                 */\\n                if (i < n)  {\\n                    q.offer(new int[]{i, tasks[i]});\\n                }\\n\\n                /**\\n                 * Release all servers that finished their tasks at current time\\n                 * and put into idle pq.\\n                 */\\n                while (!busy.isEmpty() && busy.peek()[1] == i) {\\n                    int[] s = busy.poll();\\n                    idle.offer(new int[]{s[0], s[2]});\\n                }\\n\\n                /**\\n                 * Assign tasks to servers, put servers to busy pq.\\n                 * Because we always assign server from idle pq, it\\'s already properly sorted based on weight and idx,\\n                 * so the busy pq only needs to be sorted by finish_time.\\n                 */\\n                while (!idle.isEmpty() && !q.isEmpty()) {\\n                    int[] server = idle.poll();\\n                    int[] task = q.poll();\\n                    res[task[0]] = server[0];\\n                    busy.offer(new int[]{server[0], i + task[1], server[1]});\\n                }\\n\\n                /**\\n                 * Speed up the iteration for test case like:\\n                 * Servers : [1,2,3,4,5,6,7,8,9,10]\\n                 * Tasks : [90000,90001,90002,90003,90004,90005,90006,90007,90008,90009,....]\\n                 *\\n                 * After all tasks are put into q, find the finish time of the top element in busy pq, catch up with it.\\n                 *\\n                 * Without this logic, it will TLE.\\n                 */\\n                if (i >= n && !busy.isEmpty() && busy.peek()[1] > i) {\\n                    i = busy.peek()[1];\\n                } else {\\n                    i++;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417116,
                "title": "easy-python-solution",
                "content": "```\\nfrom heapq import heapify,heappop,heappush\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        available_server,processed_server = [],[]\\n        res = []\\n        for i in range(len(servers)):\\n            heappush(available_server,(servers[i],i))\\n        for i,task in enumerate(tasks):\\n            while processed_server and processed_server[0][0] <= i:\\n                time,weight,idx = heappop(processed_server)\\n                heappush(available_server,(weight,idx))\\n            if available_server:\\n                weight,idx = heappop(available_server)\\n            else:\\n                i,weight,idx = heappop(processed_server)\\n            res.append(idx)\\n            heappush(processed_server,(i+task,weight,idx))\\n       \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heapify,heappop,heappush\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        available_server,processed_server = [],[]\\n        res = []\\n        for i in range(len(servers)):\\n            heappush(available_server,(servers[i],i))\\n        for i,task in enumerate(tasks):\\n            while processed_server and processed_server[0][0] <= i:\\n                time,weight,idx = heappop(processed_server)\\n                heappush(available_server,(weight,idx))\\n            if available_server:\\n                weight,idx = heappop(available_server)\\n            else:\\n                i,weight,idx = heappop(processed_server)\\n            res.append(idx)\\n            heappush(processed_server,(i+task,weight,idx))\\n       \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416763,
                "title": "python-two-minheaps-solution-clear-straight-forward-comments-included",
                "content": "**Idea:** using two min heaps, one store idle servers. another for busy servers.\\n* **idel servers**: min-heap . element with tuple `(weight, index)`\\n* **busy servers**: min-heap . element with tuple `(end_time_sec, (weight, index))`\\n\\t* `end_time_sec`: when the time this server can be freed\\n* we just need to iterate with times, to append each tasks\\n\\n```python\\ndef assignTasks(self, servers, tasks):\\n        \"\"\"\\n        :type servers: List[int]\\n        :type tasks: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # idle servers : min-heap (wieght, index)\\n        # busy servers: min-heap (end_time, (wieght, index))\\n        # iterate task with sec time frame\\n        import heapq\\n        \\n        idle_servers = []\\n        busy_servers = []\\n        for idx, weight in enumerate(servers):\\n            heapq.heappush(idle_servers, (weight, idx))\\n        \\n        rest = []\\n        sec = 0\\n        while len(rest) != len(tasks):\\n            # free servers from busy servers if we passed the end_time_sec \\n            while busy_servers and busy_servers[0][0] <= sec:\\n                _, server = heapq.heappop(busy_servers)\\n                heapq.heappush(idle_servers, server)\\n                \\n            # assign tasks to idle server\\n            # You may assign multiple tasks at the same second \\n            # if there are multiple free servers.\\n            while idle_servers and len(rest) <= sec and len(rest) < len(tasks):\\n                next_task = tasks[len(rest)]\\n                server = heapq.heappop(idle_servers)\\n                heapq.heappush(busy_servers, (sec+next_task, server))\\n                rest.append(server[1])\\n            \\n            if not idle_servers:\\n\\t\\t\\t    # no free server, speed up we can jump to next closet time to free\\n                sec = busy_servers[0][0]\\n            else:\\n                sec += 1\\n            \\n        return rest\\n```\\n\\n* time complexity: `O((n + m)log(n))`",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\ndef assignTasks(self, servers, tasks):\\n        \"\"\"\\n        :type servers: List[int]\\n        :type tasks: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # idle servers : min-heap (wieght, index)\\n        # busy servers: min-heap (end_time, (wieght, index))\\n        # iterate task with sec time frame\\n        import heapq\\n        \\n        idle_servers = []\\n        busy_servers = []\\n        for idx, weight in enumerate(servers):\\n            heapq.heappush(idle_servers, (weight, idx))\\n        \\n        rest = []\\n        sec = 0\\n        while len(rest) != len(tasks):\\n            # free servers from busy servers if we passed the end_time_sec \\n            while busy_servers and busy_servers[0][0] <= sec:\\n                _, server = heapq.heappop(busy_servers)\\n                heapq.heappush(idle_servers, server)\\n                \\n            # assign tasks to idle server\\n            # You may assign multiple tasks at the same second \\n            # if there are multiple free servers.\\n            while idle_servers and len(rest) <= sec and len(rest) < len(tasks):\\n                next_task = tasks[len(rest)]\\n                server = heapq.heappop(idle_servers)\\n                heapq.heappush(busy_servers, (sec+next_task, server))\\n                rest.append(server[1])\\n            \\n            if not idle_servers:\\n\\t\\t\\t    # no free server, speed up we can jump to next closet time to free\\n                sec = busy_servers[0][0]\\n            else:\\n                sec += 1\\n            \\n        return rest\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1400255,
                "title": "java-track-free-and-busy-servers-using-two-heaps",
                "content": "```\\nclass Server {\\n  int index;\\n  int weight;\\n  int availableTime;\\n  Server(int index, int weight) {\\n    this.index = index;\\n    this.weight = weight;\\n  }\\n}\\nclass Solution {\\n  public int[] assignTasks(int[] servers, int[] tasks) {\\n    // sort free servers by weight ASC, index ASC\\n    PriorityQueue<Server> freeServers = new PriorityQueue<>((a,b) -> a.weight != b.weight ? Integer.compare(a.weight, b.weight) : Integer.compare(a.index, b.index));\\n    \\n    for (int i = 0; i < servers.length; i++)\\n      freeServers.add(new Server(i, servers[i]));\\n    \\n    int[] result = new int[tasks.length];\\n    // sort busy servers by availableTime ASC, weight ASC, index ASC\\n    PriorityQueue<Server> busyServers = new PriorityQueue<>((a,b) -> {\\n      if (a.availableTime != b.availableTime)\\n        return Integer.compare(a.availableTime, b.availableTime);\\n      else if (a.weight != b.weight)\\n        return Integer.compare(a.weight, b.weight);\\n      else\\n        return Integer.compare(a.index, b.index);\\n      });\\n    for (int time = 0; time < tasks.length; time++) {\\n      while (!busyServers.isEmpty() && busyServers.peek().availableTime <= time)\\n        freeServers.add(busyServers.remove());\\n        \\n      if (!freeServers.isEmpty()) {\\n        // if there are one or more free servers take the one with the smallest weight, index\\n        Server server = freeServers.remove();                \\n        result[time] = server.index;\\n        server.availableTime = time + tasks[time];\\n        busyServers.add(server);\\n      } else {\\n        // if there are no free servers, take the busy server with the smallest available time, weight, index\\n        Server server = busyServers.remove();                \\n        result[time] = server.index;\\n\\t\\t// set the server\\'s new available time based on its current available time\\n        server.availableTime += tasks[time];\\n        busyServers.add(server);\\n      }\\n    } \\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Server {\\n  int index;\\n  int weight;\\n  int availableTime;\\n  Server(int index, int weight) {\\n    this.index = index;\\n    this.weight = weight;\\n  }\\n}\\nclass Solution {\\n  public int[] assignTasks(int[] servers, int[] tasks) {\\n    // sort free servers by weight ASC, index ASC\\n    PriorityQueue<Server> freeServers = new PriorityQueue<>((a,b) -> a.weight != b.weight ? Integer.compare(a.weight, b.weight) : Integer.compare(a.index, b.index));\\n    \\n    for (int i = 0; i < servers.length; i++)\\n      freeServers.add(new Server(i, servers[i]));\\n    \\n    int[] result = new int[tasks.length];\\n    // sort busy servers by availableTime ASC, weight ASC, index ASC\\n    PriorityQueue<Server> busyServers = new PriorityQueue<>((a,b) -> {\\n      if (a.availableTime != b.availableTime)\\n        return Integer.compare(a.availableTime, b.availableTime);\\n      else if (a.weight != b.weight)\\n        return Integer.compare(a.weight, b.weight);\\n      else\\n        return Integer.compare(a.index, b.index);\\n      });\\n    for (int time = 0; time < tasks.length; time++) {\\n      while (!busyServers.isEmpty() && busyServers.peek().availableTime <= time)\\n        freeServers.add(busyServers.remove());\\n        \\n      if (!freeServers.isEmpty()) {\\n        // if there are one or more free servers take the one with the smallest weight, index\\n        Server server = freeServers.remove();                \\n        result[time] = server.index;\\n        server.availableTime = time + tasks[time];\\n        busyServers.add(server);\\n      } else {\\n        // if there are no free servers, take the busy server with the smallest available time, weight, index\\n        Server server = busyServers.remove();                \\n        result[time] = server.index;\\n\\t\\t// set the server\\'s new available time based on its current available time\\n        server.availableTime += tasks[time];\\n        busyServers.add(server);\\n      }\\n    } \\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355095,
                "title": "intuitive-c-solution-using-2-min-priority-queues",
                "content": "```\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n    vector<int> ans(tasks.size());\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> availableServers;\\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> unavailableServers;\\n    int currentTime = 0, taskNum = 0;\\n    int m = servers.size(), n = tasks.size();\\n    for (int i = 0; i < m; ++i) {\\n        availableServers.push({servers[i], i});\\n    }\\n    while (taskNum < n) {\\n        currentTime = max(currentTime, taskNum);\\n        while (unavailableServers.size() && unavailableServers.top().first <= currentTime) {\\n            pair<int, pair<int, int>> x = unavailableServers.top();\\n            unavailableServers.pop();\\n            availableServers.push(x.second);\\n        }\\n        if (availableServers.size()) {\\n            pair<int, int> y = availableServers.top();\\n            availableServers.pop();\\n            ans[taskNum] = y.second;\\n            unavailableServers.push({currentTime + tasks[taskNum], y});\\n            ++taskNum;\\n        } else {\\n            currentTime = unavailableServers.top().first;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n    vector<int> ans(tasks.size());\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> availableServers;\\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> unavailableServers;\\n    int currentTime = 0, taskNum = 0;\\n    int m = servers.size(), n = tasks.size();\\n    for (int i = 0; i < m; ++i) {\\n        availableServers.push({servers[i], i});\\n    }\\n    while (taskNum < n) {\\n        currentTime = max(currentTime, taskNum);\\n        while (unavailableServers.size() && unavailableServers.top().first <= currentTime) {\\n            pair<int, pair<int, int>> x = unavailableServers.top();\\n            unavailableServers.pop();\\n            availableServers.push(x.second);\\n        }\\n        if (availableServers.size()) {\\n            pair<int, int> y = availableServers.top();\\n            availableServers.pop();\\n            ans[taskNum] = y.second;\\n            unavailableServers.push({currentTime + tasks[taskNum], y});\\n            ++taskNum;\\n        } else {\\n            currentTime = unavailableServers.top().first;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1272973,
                "title": "java-very-clean-o-logn-m-n-solution-with-comments",
                "content": "The problem is challenging in two aspects:\\n1. How to frame the problem into algorithms & data structures\\n2. How to implement it with elegancy & readability\\n\\nFor me, it\\'s not obvious how to handle the case when there\\'s no free server available. I think of using a global variable: time. Then increment time until a server is free. However this approach is very time-consuming. \\n\\nAfter realizing using a second ProrityQueue, I face the problem of how to make my code more readable. I started with using int[] to store all the informations: serverIndex, serverWeight, finishTime. Then I realized that this implementation seems messy in the lambda expressions of PriorityQueue. \\n\\nThen I have this final result which looks okay for me. \\n```\\nclass Solution {\\n    class Server implements Comparable<Server> {\\n        private int idx;\\n        private int weight;\\n        private int time;\\n        \\n        public Server(int idx, int weight) {\\n            this.idx = idx;\\n            this.weight = weight;\\n            this.time = 0;\\n        }\\n        \\n        @Override\\n        public int compareTo(Server other) {\\n            return (this.weight != other.weight ? this.weight - other.weight\\n                                                : this.idx - other.idx);\\n        }\\n    }\\n    \\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server> free = new PriorityQueue<>();\\n        for (int i = 0; i < servers.length; i++) {\\n            free.add(new Server(i, servers[i]));\\n        }\\n        \\n        // sorted by finishTime\\n        PriorityQueue<Server> used = new PriorityQueue<>((a,b) -> a.time != b.time ? a.time - b.time : \\n                                                                  a.compareTo(b));\\n        \\n        int[] res = new int[tasks.length];\\n        \\n        for (int i = 0; i < tasks.length; i++) {\\n            // update available servers\\n            while (!used.isEmpty() && used.peek().time <= i) {\\n                free.add(used.poll());\\n            }\\n            \\n            Server s;\\n            if (!free.isEmpty()) {        // Case 1). we have a server ready\\n                s = free.poll();\\n                s.time = i + tasks[i];\\n            } else {                      // Case 2). we do NOT have a server ready\\n                s = used.poll();\\n                s.time = s.time + tasks[i];\\n            }\\n            \\n            used.add(s);\\n            res[i] = s.idx;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Server implements Comparable<Server> {\\n        private int idx;\\n        private int weight;\\n        private int time;\\n        \\n        public Server(int idx, int weight) {\\n            this.idx = idx;\\n            this.weight = weight;\\n            this.time = 0;\\n        }\\n        \\n        @Override\\n        public int compareTo(Server other) {\\n            return (this.weight != other.weight ? this.weight - other.weight\\n                                                : this.idx - other.idx);\\n        }\\n    }\\n    \\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server> free = new PriorityQueue<>();\\n        for (int i = 0; i < servers.length; i++) {\\n            free.add(new Server(i, servers[i]));\\n        }\\n        \\n        // sorted by finishTime\\n        PriorityQueue<Server> used = new PriorityQueue<>((a,b) -> a.time != b.time ? a.time - b.time : \\n                                                                  a.compareTo(b));\\n        \\n        int[] res = new int[tasks.length];\\n        \\n        for (int i = 0; i < tasks.length; i++) {\\n            // update available servers\\n            while (!used.isEmpty() && used.peek().time <= i) {\\n                free.add(used.poll());\\n            }\\n            \\n            Server s;\\n            if (!free.isEmpty()) {        // Case 1). we have a server ready\\n                s = free.poll();\\n                s.time = i + tasks[i];\\n            } else {                      // Case 2). we do NOT have a server ready\\n                s = used.poll();\\n                s.time = s.time + tasks[i];\\n            }\\n            \\n            used.add(s);\\n            res[i] = s.idx;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270629,
                "title": "python-heap-solution",
                "content": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def assignTasks(self, servers, tasks):\\n        \"\"\"\\n        :type servers: List[int]\\n        :type tasks: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        freeServers = []\\n        occupiedServers = []\\n        serverAssignment = []\\n        \\n        for serverIndex, serverWeight in enumerate(servers):\\n            serverAvailableTime = 0\\n            heapq.heappush(freeServers, (serverWeight, serverIndex, serverAvailableTime))\\n            \\n        for taskEnqueueTime, taskProcessingTime in enumerate(tasks):\\n            while len(occupiedServers) > 0 and occupiedServers[0][0] <= taskEnqueueTime:\\n                serverAvailableTime, serverWeight, serverIndex = heapq.heappop(occupiedServers)\\n                heapq.heappush(freeServers, (serverWeight, serverIndex, serverAvailableTime))    \\n                \\n            if len(freeServers) == 0:\\n                serverAvailableTime, serverWeight, serverIndex = heapq.heappop(occupiedServers)\\n                heapq.heappush(freeServers, (serverWeight, serverIndex, serverAvailableTime)) \\n                \\n            serverWeight, serverIndex, serverAvailableTime = heapq.heappop(freeServers)\\n            serverAssignment.append(serverIndex)\\n            heapq.heappush(occupiedServers, (max(taskEnqueueTime, serverAvailableTime) + taskProcessingTime, serverWeight, serverIndex))\\n            \\n        return serverAssignment\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def assignTasks(self, servers, tasks):\\n        \"\"\"\\n        :type servers: List[int]\\n        :type tasks: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        freeServers = []\\n        occupiedServers = []\\n        serverAssignment = []\\n        \\n        for serverIndex, serverWeight in enumerate(servers):\\n            serverAvailableTime = 0\\n            heapq.heappush(freeServers, (serverWeight, serverIndex, serverAvailableTime))\\n            \\n        for taskEnqueueTime, taskProcessingTime in enumerate(tasks):\\n            while len(occupiedServers) > 0 and occupiedServers[0][0] <= taskEnqueueTime:\\n                serverAvailableTime, serverWeight, serverIndex = heapq.heappop(occupiedServers)\\n                heapq.heappush(freeServers, (serverWeight, serverIndex, serverAvailableTime))    \\n                \\n            if len(freeServers) == 0:\\n                serverAvailableTime, serverWeight, serverIndex = heapq.heappop(occupiedServers)\\n                heapq.heappush(freeServers, (serverWeight, serverIndex, serverAvailableTime)) \\n                \\n            serverWeight, serverIndex, serverAvailableTime = heapq.heappop(freeServers)\\n            serverAssignment.append(serverIndex)\\n            heapq.heappush(occupiedServers, (max(taskEnqueueTime, serverAvailableTime) + taskProcessingTime, serverWeight, serverIndex))\\n            \\n        return serverAssignment\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256353,
                "title": "java-solution-but-with-tle-error",
                "content": "I came up with this Java solution, with a priorityQueue (freeQueue) and busyMap (maps the time when task ends to the those list of tasks) . \\nThe solution works for most of the test cases, but it failed with TLE on a super large dataset. I posted the approach here. \\n```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        /* server freeQueue stores available server in the order such that poll() will get the first one */\\n        PriorityQueue<int[]> freeQueue = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                \\n                if (a[0] > b[0])\\n                    return 1;\\n                else if (a[0] < b[0])\\n                    return -1;\\n                else \\n                    return a[1] - b[1];\\n            }\\n        });\\n        \\n        Map<Integer, List<Integer>> busyMap = new HashMap<>();\\n        \\n        int n = servers.length;\\n        int m = tasks.length;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            \\n            int[] serverObj = { servers[i], i };\\n            freeQueue.offer(serverObj);\\n        }\\n        \\n        int index = 0;\\n        int[] res = new int[m];\\n        int time = 0;\\n        \\n        while (index < m) {\\n            \\n            // we do the loop when we have server in freeQueue and we need to process tasks up to the current time\\n            while (freeQueue.size() > 0 && index <= time && index < m) {\\n                \\n                int task = tasks[index];\\n                processTask(freeQueue, busyMap, task, index, time, res);\\n                index++;\\n            }\\n            \\n            time++;\\n            \\n            // release busyMap if any exists\\n            if (busyMap.containsKey(time)) {\\n                \\n                List<Integer> pendingList = busyMap.get(time);\\n                \\n                for (int i : pendingList) {\\n                    \\n                    int[] serverObj = { servers[i], i };\\n                    \\n                    freeQueue.offer(serverObj);\\n                }\\n                busyMap.remove(time);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    private void processTask(PriorityQueue<int[]> freeQueue, Map<Integer, List<Integer>> busyMap, \\n                            int task, int index, int time, int[] res) {\\n        \\n        int[] serverObj = freeQueue.poll();\\n        \\n        res[index] = serverObj[1];\\n\\n        int waitTime = time + task;\\n\\t\\t\\n        if (busyMap.containsKey(waitTime)) {\\n            List<Integer> list = busyMap.get(waitTime);\\n            list.add(serverObj[1]);\\n\\t\\t\\t\\n        } else {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(serverObj[1]);\\n\\n            busyMap.put(waitTime, list);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        /* server freeQueue stores available server in the order such that poll() will get the first one */\\n        PriorityQueue<int[]> freeQueue = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                \\n                if (a[0] > b[0])\\n                    return 1;\\n                else if (a[0] < b[0])\\n                    return -1;\\n                else \\n                    return a[1] - b[1];\\n            }\\n        });\\n        \\n        Map<Integer, List<Integer>> busyMap = new HashMap<>();\\n        \\n        int n = servers.length;\\n        int m = tasks.length;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            \\n            int[] serverObj = { servers[i], i };\\n            freeQueue.offer(serverObj);\\n        }\\n        \\n        int index = 0;\\n        int[] res = new int[m];\\n        int time = 0;\\n        \\n        while (index < m) {\\n            \\n            // we do the loop when we have server in freeQueue and we need to process tasks up to the current time\\n            while (freeQueue.size() > 0 && index <= time && index < m) {\\n                \\n                int task = tasks[index];\\n                processTask(freeQueue, busyMap, task, index, time, res);\\n                index++;\\n            }\\n            \\n            time++;\\n            \\n            // release busyMap if any exists\\n            if (busyMap.containsKey(time)) {\\n                \\n                List<Integer> pendingList = busyMap.get(time);\\n                \\n                for (int i : pendingList) {\\n                    \\n                    int[] serverObj = { servers[i], i };\\n                    \\n                    freeQueue.offer(serverObj);\\n                }\\n                busyMap.remove(time);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    private void processTask(PriorityQueue<int[]> freeQueue, Map<Integer, List<Integer>> busyMap, \\n                            int task, int index, int time, int[] res) {\\n        \\n        int[] serverObj = freeQueue.poll();\\n        \\n        res[index] = serverObj[1];\\n\\n        int waitTime = time + task;\\n\\t\\t\\n        if (busyMap.containsKey(waitTime)) {\\n            List<Integer> list = busyMap.get(waitTime);\\n            list.add(serverObj[1]);\\n\\t\\t\\t\\n        } else {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(serverObj[1]);\\n\\n            busyMap.put(waitTime, list);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249713,
                "title": "go-two-priority-queues-solution",
                "content": "here is min priority queue.\\n\\n```\\n// An Item is something we manage in a priority queue.\\ntype Item struct {\\n    // The index is needed by update and is maintained by the heap.Interface methods.\\n\\tindex     int // The index of the item in the heap.\\n\\tpriority1 int \\n\\tpriority2 int\\n\\tpriority3 int\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n    if pq[i].priority1 == pq[j].priority1 {\\n        if pq[i].priority2 == pq[j].priority2 {\\n            return pq[i].priority3 < pq[j].priority3 // lowest come first\\n        }\\n        return pq[i].priority2 < pq[j].priority2 // lowest come first\\n    }\\n\\t// We want Pop to give us the lowest\\n\\treturn pq[i].priority1 < pq[j].priority1\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\titem.index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n// update modifies the priority and value of an Item in the queue.\\nfunc (pq *PriorityQueue) update(item *Item, priority1 int, priority2 int, priority3 int) {\\n\\titem.priority1 = priority1\\n\\titem.priority2 = priority2\\n    item.priority3 = priority3\\n\\theap.Fix(pq, item.index)\\n}\\n\\nfunc assignTasks(servers []int, tasks []int) []int {\\n    // (weight, index, time)\\n\\tfree := make(PriorityQueue, len(servers))\\n\\tfor index, weight := range servers {\\n\\t\\tfree[index] = &Item{\\n            index:        index,\\n\\t\\t\\tpriority1:    weight,\\n\\t\\t\\tpriority2:    index,\\n\\t\\t\\tpriority3:    0, // time\\n\\t\\t}\\n\\t}\\n    // (time, weight, index)\\n    used := make(PriorityQueue, 0)\\n\\theap.Init(&free)\\n    heap.Init(&used)\\n    ans := make([]int, len(tasks))\\n    \\n    for j:=0; j<len(tasks); j++ {\\n        for used.Len()>0 && used[0].priority1 <= j || free.Len() == 0 {\\n            // time, weight, index\\n            item := heap.Pop(&used).(*Item)\\n            heap.Push(&free, &Item{\\n                priority1:    item.priority2, // weight\\n                priority2:    item.priority3, // index\\n                priority3:    item.priority1, // time\\n            })\\n        }\\n        // weight, index, time\\n        item := heap.Pop(&free).(*Item)\\n        ans[j] = item.priority2\\n        heap.Push(&used, &Item{\\n            priority1: Max(j, item.priority3) + tasks[j], // time\\n            priority2: item.priority1, // weight\\n            priority3: item.priority2, // index\\n        })\\n    }\\n    return ans\\n}\\n\\nfunc Max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n    \\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// An Item is something we manage in a priority queue.\\ntype Item struct {\\n    // The index is needed by update and is maintained by the heap.Interface methods.\\n\\tindex     int // The index of the item in the heap.\\n\\tpriority1 int \\n\\tpriority2 int\\n\\tpriority3 int\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n    if pq[i].priority1 == pq[j].priority1 {\\n        if pq[i].priority2 == pq[j].priority2 {\\n            return pq[i].priority3 < pq[j].priority3 // lowest come first\\n        }\\n        return pq[i].priority2 < pq[j].priority2 // lowest come first\\n    }\\n\\t// We want Pop to give us the lowest\\n\\treturn pq[i].priority1 < pq[j].priority1\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\titem.index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n// update modifies the priority and value of an Item in the queue.\\nfunc (pq *PriorityQueue) update(item *Item, priority1 int, priority2 int, priority3 int) {\\n\\titem.priority1 = priority1\\n\\titem.priority2 = priority2\\n    item.priority3 = priority3\\n\\theap.Fix(pq, item.index)\\n}\\n\\nfunc assignTasks(servers []int, tasks []int) []int {\\n    // (weight, index, time)\\n\\tfree := make(PriorityQueue, len(servers))\\n\\tfor index, weight := range servers {\\n\\t\\tfree[index] = &Item{\\n            index:        index,\\n\\t\\t\\tpriority1:    weight,\\n\\t\\t\\tpriority2:    index,\\n\\t\\t\\tpriority3:    0, // time\\n\\t\\t}\\n\\t}\\n    // (time, weight, index)\\n    used := make(PriorityQueue, 0)\\n\\theap.Init(&free)\\n    heap.Init(&used)\\n    ans := make([]int, len(tasks))\\n    \\n    for j:=0; j<len(tasks); j++ {\\n        for used.Len()>0 && used[0].priority1 <= j || free.Len() == 0 {\\n            // time, weight, index\\n            item := heap.Pop(&used).(*Item)\\n            heap.Push(&free, &Item{\\n                priority1:    item.priority2, // weight\\n                priority2:    item.priority3, // index\\n                priority3:    item.priority1, // time\\n            })\\n        }\\n        // weight, index, time\\n        item := heap.Pop(&free).(*Item)\\n        ans[j] = item.priority2\\n        heap.Push(&used, &Item{\\n            priority1: Max(j, item.priority3) + tasks[j], // time\\n            priority2: item.priority1, // weight\\n            priority3: item.priority2, // index\\n        })\\n    }\\n    return ans\\n}\\n\\nfunc Max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1244310,
                "title": "java-two-min-heaps-fully-explained-easily",
                "content": "We use two heap:\\n1. one is for free servers  ( keep track of servers available )\\n2.  one is for busy servers (  keep track of the tasks that are still in progress )\\n\\nHere, we have two min heaps, ordered by [weight, index, time].\\nFirst, we put all servers into the available heap with time equals to zero.\\n\\n\\nAs we process our tasks:\\n1.  Move servers that have finished (time <= t) from busyServers to freeServers.\\n2.  If no servers are available.   \\n\\t* We use the top server from busyServers.\\n4.   ELSE\\n       * Pick the top server from the avail heap and move it to the busy heap with time = t + tasks[t].\\n\\nO((M + N) * logN)\\n```\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> freeServers = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                //o1[0] and o2[0] is \\'weight\\' of servers\\n                //o1[1] and o2[1] is \\'index\\' of servers\\n                //o1[2] and o2[2] is \\'busy till\\' of servers\\n                //Free server heap is sorted based on weight and index.\\n                return o1[0] != o2[0] ? o1[0] - o2[0] : o1[1] - o2[1];\\n            }\\n        });\\n        PriorityQueue<int[]> busyServers = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                //busy server heap is sorted on available time.\\n                return o1[2] != o2[2] ? o1[2] - o2[2] : (o1[0] != o2[0] ? o1[0] - o2[0] : o1[1] - o2[1]);\\n            }\\n        });\\n\\t\\t// Initially Push all servers in freeServer Min Heap\\n        for (int i = 0; i < servers.length; i++) {\\n            freeServers.add(new int[]{servers[i], i, 0});\\n        }\\n        int[] result = new int[tasks.length];\\n        for (int i = 0; i < tasks.length; i++) {\\n            int task = tasks[i];\\n            while (!busyServers.isEmpty() && busyServers.peek()[2] <= i) {\\n                freeServers.add(busyServers.poll());\\n            }\\n\\t\\t\\t//check at this point if at this time instance any servers are freed or not from used server\\n            if (freeServers.isEmpty()) {\\n                int[] cur = busyServers.poll();\\n                result[i] = cur[1];\\n                cur[2] += task;\\n                busyServers.add(cur);\\n            } else {\\n                int[] cur = freeServers.poll();\\n                result[i] = cur[1];\\n                cur[2] = i + task;\\n                busyServers.add(cur);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> freeServers = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                //o1[0] and o2[0] is \\'weight\\' of servers\\n                //o1[1] and o2[1] is \\'index\\' of servers\\n                //o1[2] and o2[2] is \\'busy till\\' of servers\\n                //Free server heap is sorted based on weight and index.\\n                return o1[0] != o2[0] ? o1[0] - o2[0] : o1[1] - o2[1];\\n            }\\n        });\\n        PriorityQueue<int[]> busyServers = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                //busy server heap is sorted on available time.\\n                return o1[2] != o2[2] ? o1[2] - o2[2] : (o1[0] != o2[0] ? o1[0] - o2[0] : o1[1] - o2[1]);\\n            }\\n        });\\n\\t\\t// Initially Push all servers in freeServer Min Heap\\n        for (int i = 0; i < servers.length; i++) {\\n            freeServers.add(new int[]{servers[i], i, 0});\\n        }\\n        int[] result = new int[tasks.length];\\n        for (int i = 0; i < tasks.length; i++) {\\n            int task = tasks[i];\\n            while (!busyServers.isEmpty() && busyServers.peek()[2] <= i) {\\n                freeServers.add(busyServers.poll());\\n            }\\n\\t\\t\\t//check at this point if at this time instance any servers are freed or not from used server\\n            if (freeServers.isEmpty()) {\\n                int[] cur = busyServers.poll();\\n                result[i] = cur[1];\\n                cur[2] += task;\\n                busyServers.add(cur);\\n            } else {\\n                int[] cur = freeServers.poll();\\n                result[i] = cur[1];\\n                cur[2] = i + task;\\n                busyServers.add(cur);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243909,
                "title": "java-priorityqueue-treemap-and-timestamp-approach",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        TreeMap<Integer, Queue<Integer>> timeStamp = new TreeMap();\\n        Queue<Integer> queueTasks = new LinkedList();\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a, int[] b)\\n            {\\n                if(a[1] == b[1])\\n                    return a[0] - b[0];\\n                \\n                return a[1] - b[1];\\n            }\\n        });\\n        \\n        for(int i=0; i<servers.length; i++)\\n            pq.add(new int[]{i, servers[i]});\\n        \\n        int[] res= new int[tasks.length];\\n        int taskProcessingTimeIndex = 0;\\n        int time=0;\\n        queueTasks.add(tasks[0]);\\n        while(!queueTasks.isEmpty()) {\\n            \\n            // Get servers that need to be freed\\n            var q = timeStamp.get(time);\\n            \\n            // Free servers\\n            while(q != null && !q.isEmpty()) {         \\n                var item = q.poll();\\n                pq.add(new int[]{-item, servers[-item]});\\n            }\\n            \\n\\t\\t\\t// Remove time entry\\n            if(q != null)\\n                timeStamp.remove(time);\\n            \\n            // All servers busy\\n            if(pq.isEmpty()) {\\n                \\n                // Add next task\\n                if(++time<tasks.length)\\n                    queueTasks.add(tasks[time]);\\n                else // If time has past tasks length, get the next time when a server is available\\n                    time = timeStamp.firstKey();\\n                \\n                continue;\\n            }\\n            \\n            // Allocate servers for queued tasks\\n            while(!pq.isEmpty() && !queueTasks.isEmpty()) {                \\n                 var taskTime = queueTasks.poll();\\n                 var server = pq.poll();\\n                 res[taskProcessingTimeIndex++] = server[0];\\n\\n                if(!timeStamp.containsKey(time+taskTime))\\n                    timeStamp.put(time+taskTime, new LinkedList());\\n                \\n                // Log the time when the server used gets free\\n                timeStamp.get(time+taskTime).add(-server[0]);\\n            }\\n            \\n            // Add next task\\n            if(++time<tasks.length)\\n                queueTasks.add(tasks[time]);\\n            else // If time has past tasks length, get the next time when a server is available\\n                time = timeStamp.firstKey();\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        TreeMap<Integer, Queue<Integer>> timeStamp = new TreeMap();\\n        Queue<Integer> queueTasks = new LinkedList();\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a, int[] b)\\n            {\\n                if(a[1] == b[1])\\n                    return a[0] - b[0];\\n                \\n                return a[1] - b[1];\\n            }\\n        });\\n        \\n        for(int i=0; i<servers.length; i++)\\n            pq.add(new int[]{i, servers[i]});\\n        \\n        int[] res= new int[tasks.length];\\n        int taskProcessingTimeIndex = 0;\\n        int time=0;\\n        queueTasks.add(tasks[0]);\\n        while(!queueTasks.isEmpty()) {\\n            \\n            // Get servers that need to be freed\\n            var q = timeStamp.get(time);\\n            \\n            // Free servers\\n            while(q != null && !q.isEmpty()) {         \\n                var item = q.poll();\\n                pq.add(new int[]{-item, servers[-item]});\\n            }\\n            \\n\\t\\t\\t// Remove time entry\\n            if(q != null)\\n                timeStamp.remove(time);\\n            \\n            // All servers busy\\n            if(pq.isEmpty()) {\\n                \\n                // Add next task\\n                if(++time<tasks.length)\\n                    queueTasks.add(tasks[time]);\\n                else // If time has past tasks length, get the next time when a server is available\\n                    time = timeStamp.firstKey();\\n                \\n                continue;\\n            }\\n            \\n            // Allocate servers for queued tasks\\n            while(!pq.isEmpty() && !queueTasks.isEmpty()) {                \\n                 var taskTime = queueTasks.poll();\\n                 var server = pq.poll();\\n                 res[taskProcessingTimeIndex++] = server[0];\\n\\n                if(!timeStamp.containsKey(time+taskTime))\\n                    timeStamp.put(time+taskTime, new LinkedList());\\n                \\n                // Log the time when the server used gets free\\n                timeStamp.get(time+taskTime).add(-server[0]);\\n            }\\n            \\n            // Add next task\\n            if(++time<tasks.length)\\n                queueTasks.add(tasks[time]);\\n            else // If time has past tasks length, get the next time when a server is available\\n                time = timeStamp.firstKey();\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242504,
                "title": "use-2-minheap-for-freeserver-and-listofseconds-and-use-serverfinishedat-map-with-explanation",
                "content": "Use **2 min heap** for **freeServer** and **list of seconds** that each of those seconds, there is at least one task will be finished. If all of servers are busy, and we will jump to first element of seconds list instead of tracing sequentially every second.\\nI use also **serverFinishedAt** map, **serverFinishedAt[i]** will contains server list will be finished at ith second\\n```\\nclass Compare\\n{\\npublic:\\n    bool operator() (pair<int,int> &a, pair<int,int> &b){\\n        if (a.first==b.first) return a.second>=b.second;\\n        return a.first>b.first;\\n    }\\n};\\nclass Compare2\\n{\\npublic:\\n    bool operator() (long long &a, long long &b){\\n        return a>b;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int len=servers.size();\\n        vector<int> ans;\\n        //server\\n        // will pop smallest element of priority queue\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,Compare> freeServers; // each element will contain value of server and its index\\n        //task\\n        int taskCurIdx=0; // servers will process from taskCurIdx th task to sec th task\\n        unordered_map<long long,vector<pair<int,int>>> serverFinishedAt; //serverFinishAt[i] contains servers are free at ith second. Each server also contains value of server and its index\\n        \\n        //list of seconds contains second that task will be finished\\n        //use priorityQueue to ensure first element is smallest second\\n        // secondQueue is useful in the case that all servers are busy, and we will jump to first element of secondQueue contains the second that has task is finished and server is free again\\n        // jump will be faster than trace sequentially every sec\\n        priority_queue<long long,vector<long long>,Compare2> secondQueue;\\n        //create servers min heap\\n        pair<int,int> p;\\n        for (int i=0;i<len;i++){\\n            p.first=servers[i];\\n            p.second=i;\\n            freeServers.push(p);\\n        }\\n        long long sec=0;\\n        while(1){\\n            // at sec th second, old task is finished\\n            for(int i=0;i<serverFinishedAt[sec].size();i++)\\n                freeServers.push(serverFinishedAt[sec][i]);\\n            if(serverFinishedAt[sec].size()>0&&secondQueue.top()==sec)\\n                secondQueue.pop(); //remove that second from queue, because we reached that second and all servers in serverFinishedAt[sec] are free, so we needn\\'t to care that second and will care next element in secondQueue\\n            //process tasks is contained in taskQueue\\n            int i=0;\\n            pair<int,int> server;\\n            while(taskCurIdx<=sec){\\n                if(freeServers.size()>0){\\n                    // find first server is free (servers are ascending)\\n                    server=freeServers.top();\\n                    freeServers.pop();\\n                    // assign taskCurIdx th task to server for processing and update ans\\n                    int task=tasks[taskCurIdx];\\n                    taskCurIdx++;\\n                    ans.push_back(server.second); // name of server that processes this task\\n                    \\n                    if(serverFinishedAt[sec+task].size()==0) // avoid the case that has coincident (sec+task) values in list of serverFinishedAt[sec+task]\\n                        secondQueue.push(sec+task); //append to list of seconds that contain task will be finished, and we will jump to those seconds if necessary\\n                    \\n                    serverFinishedAt[sec+task].push_back(server); // append this server to server list that will finish task at (sec+task) th second\\n                    \\n                    if(ans.size()==tasks.size()) return ans; //end program when there is still has available servers but we had answer\\n                    \\n                // all servers are busy\\n                } else{\\n                    sec=secondQueue.top()-1; //jump to next second contain task will be finished\\n                    // -1 because below statement is sec++\\n                    break;\\n                }\\n            }\\n            sec++;\\n            if(ans.size()==tasks.size()) break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Compare\\n{\\npublic:\\n    bool operator() (pair<int,int> &a, pair<int,int> &b){\\n        if (a.first==b.first) return a.second>=b.second;\\n        return a.first>b.first;\\n    }\\n};\\nclass Compare2\\n{\\npublic:\\n    bool operator() (long long &a, long long &b){\\n        return a>b;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int len=servers.size();\\n        vector<int> ans;\\n        //server\\n        // will pop smallest element of priority queue\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,Compare> freeServers; // each element will contain value of server and its index\\n        //task\\n        int taskCurIdx=0; // servers will process from taskCurIdx th task to sec th task\\n        unordered_map<long long,vector<pair<int,int>>> serverFinishedAt; //serverFinishAt[i] contains servers are free at ith second. Each server also contains value of server and its index\\n        \\n        //list of seconds contains second that task will be finished\\n        //use priorityQueue to ensure first element is smallest second\\n        // secondQueue is useful in the case that all servers are busy, and we will jump to first element of secondQueue contains the second that has task is finished and server is free again\\n        // jump will be faster than trace sequentially every sec\\n        priority_queue<long long,vector<long long>,Compare2> secondQueue;\\n        //create servers min heap\\n        pair<int,int> p;\\n        for (int i=0;i<len;i++){\\n            p.first=servers[i];\\n            p.second=i;\\n            freeServers.push(p);\\n        }\\n        long long sec=0;\\n        while(1){\\n            // at sec th second, old task is finished\\n            for(int i=0;i<serverFinishedAt[sec].size();i++)\\n                freeServers.push(serverFinishedAt[sec][i]);\\n            if(serverFinishedAt[sec].size()>0&&secondQueue.top()==sec)\\n                secondQueue.pop(); //remove that second from queue, because we reached that second and all servers in serverFinishedAt[sec] are free, so we needn\\'t to care that second and will care next element in secondQueue\\n            //process tasks is contained in taskQueue\\n            int i=0;\\n            pair<int,int> server;\\n            while(taskCurIdx<=sec){\\n                if(freeServers.size()>0){\\n                    // find first server is free (servers are ascending)\\n                    server=freeServers.top();\\n                    freeServers.pop();\\n                    // assign taskCurIdx th task to server for processing and update ans\\n                    int task=tasks[taskCurIdx];\\n                    taskCurIdx++;\\n                    ans.push_back(server.second); // name of server that processes this task\\n                    \\n                    if(serverFinishedAt[sec+task].size()==0) // avoid the case that has coincident (sec+task) values in list of serverFinishedAt[sec+task]\\n                        secondQueue.push(sec+task); //append to list of seconds that contain task will be finished, and we will jump to those seconds if necessary\\n                    \\n                    serverFinishedAt[sec+task].push_back(server); // append this server to server list that will finish task at (sec+task) th second\\n                    \\n                    if(ans.size()==tasks.size()) return ans; //end program when there is still has available servers but we had answer\\n                    \\n                // all servers are busy\\n                } else{\\n                    sec=secondQueue.top()-1; //jump to next second contain task will be finished\\n                    // -1 because below statement is sec++\\n                    break;\\n                }\\n            }\\n            sec++;\\n            if(ans.size()==tasks.size()) break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241989,
                "title": "java-priorityqueue-treemap-two-ways-of-simulation-with-detailed-explanations",
                "content": "# Simulation\\n## Intuition\\nAt any task arriving at time t between 0 and m-1, we should:\\n1. Release all busy servers which finish tasks before <= t\\n2. If still no free servers, we have to release the earliest avaiable busy server\\n3. Pick the free server with minimum weight and index to work on the task.\\n\\n## Algorithm\\n1. Create a PriorityQueue for free servers, ordered by weight then index, add all servers \\n2. Create a TreeMap for busy servers, with key as next available time and value as a list of servers\\n3. For t = 0 to m-1:\\n3.1 Release all busy servers with available time <= t and add to free servers\\n3.2 If still no free servers, release the earliest available busy server\\n3.3 Poll one free server and assign to the task t\\n\\nTime: O(nlogn + mlogn), as free servers and busy servers add up to n, and in the worst case either free or busy servers can be up to n.\\nSpace: O(n)\\n\\n```java\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // Free servers [{index, weight}]\\n        PriorityQueue<int[]> freeServers = \\n            new PriorityQueue<>((a, b) -> a[1] != b[1] ? a[1] - b[1] : a[0] - b[0]);\\n        for (int i = 0; i < servers.length; i++) {\\n            freeServers.offer(new int[]{i, servers[i]});\\n        }\\n        \\n        TreeMap<Integer, List<int[]>> busyServers = new TreeMap<>(); // Busy servers (availableTime -> [{index, weight}])\\n        int[] assigned = new int[tasks.length]; // server index tasks assigned with\\n        int freeTime = 0; // next free server\\'s available time\\n        \\n        for (int t = 0; t < tasks.length; t++) {\\n            freeTime = Math.max(freeTime, t); // lower bound freeTime to \"now\"\\n            \\n            // release busy servers finishing before t\\n            while (!busyServers.isEmpty() && busyServers.firstKey() <= freeTime) {\\n                freeServers.addAll(busyServers.pollFirstEntry().getValue());\\n            }\\n            \\n            // If free servers still empty, release earliest available busy servers\\n            if (freeServers.isEmpty()) {\\n                freeTime = busyServers.firstKey();\\n                freeServers.addAll(busyServers.pollFirstEntry().getValue());\\n            }\\n            \\n            // Poll a free server and assign to current task\\n            int[] server = freeServers.poll();\\n            assigned[t] = server[0];\\n            busyServers.computeIfAbsent(freeTime + tasks[t], ignored -> new ArrayList<>()).add(server);\\n        }\\n        return assigned;\\n    }\\n}\\n```\\n# Simulation 2\\nA slightly more intuitive simulation approach is to keep a freeTasks queue, and sweeps one single time line.\\n## Algorithm\\n1. Create a PriorityQueue for free servers, ordered by weight then index, add all servers \\n2. Create a TreeMap for busy servers, with key as next available time and value as a list of servers, and a queue for free tasks.\\n3. For t = 0 to m-1, or when freeTasks is non-empty:\\n3.1 Add a free task t if t < m\\n3.2 Release all busy servers with available time <= t and add to free servers\\n3.3 While freeServers and freeTasks are both non-empty, poll one free server and one free task to match\\n3.4 Update next t to t+1 if t < m, otherwise use next busy server availableTime.\\n    \\nThe time and space complexity remain the same as we only poll m freeServers in total.\\n\\n```java\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // Free servers [{index, weight}]\\n        PriorityQueue<int[]> freeServers = \\n            new PriorityQueue<>((a, b) -> a[1] != b[1] ? a[1] - b[1] : a[0] - b[0]);\\n        for (int i = 0; i < servers.length; i++) {\\n            freeServers.offer(new int[]{i, servers[i]});\\n        }\\n        \\n        TreeMap<Integer, List<int[]>> busyServers = new TreeMap<>(); // Busy servers (availableTime -> [{index, weight}])\\n        Queue<Integer> freeTasks = new LinkedList<>();\\n        int[] assigned = new int[tasks.length]; // server index tasks assigned with\\n\\n        for (int t = 0; t < tasks.length || !freeTasks.isEmpty();) {\\n            if (t < tasks.length) {\\n                freeTasks.offer(t);\\n            }\\n            \\n            // release busy servers finishing before t\\n            while (!busyServers.isEmpty() && busyServers.firstKey() <= t) {\\n                freeServers.addAll(busyServers.pollFirstEntry().getValue());\\n            }\\n            \\n            // Poll free servers and assign to current freeTasks\\n            while (!freeServers.isEmpty() && !freeTasks.isEmpty()) {\\n                int[] server = freeServers.poll();\\n                int task = freeTasks.poll();\\n                assigned[task] = server[0];\\n                busyServers.computeIfAbsent(t + tasks[task], ignored -> new ArrayList<>()).add(server);\\n            }\\n            \\n            // Next time to check\\n            if (t < tasks.length) {\\n                t++;\\n            } else {\\n                t = busyServers.firstKey(); // busyServers should be non-empty until all tasks finished\\n            }\\n        }\\n        return assigned;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // Free servers [{index, weight}]\\n        PriorityQueue<int[]> freeServers = \\n            new PriorityQueue<>((a, b) -> a[1] != b[1] ? a[1] - b[1] : a[0] - b[0]);\\n        for (int i = 0; i < servers.length; i++) {\\n            freeServers.offer(new int[]{i, servers[i]});\\n        }\\n        \\n        TreeMap<Integer, List<int[]>> busyServers = new TreeMap<>(); // Busy servers (availableTime -> [{index, weight}])\\n        int[] assigned = new int[tasks.length]; // server index tasks assigned with\\n        int freeTime = 0; // next free server\\'s available time\\n        \\n        for (int t = 0; t < tasks.length; t++) {\\n            freeTime = Math.max(freeTime, t); // lower bound freeTime to \"now\"\\n            \\n            // release busy servers finishing before t\\n            while (!busyServers.isEmpty() && busyServers.firstKey() <= freeTime) {\\n                freeServers.addAll(busyServers.pollFirstEntry().getValue());\\n            }\\n            \\n            // If free servers still empty, release earliest available busy servers\\n            if (freeServers.isEmpty()) {\\n                freeTime = busyServers.firstKey();\\n                freeServers.addAll(busyServers.pollFirstEntry().getValue());\\n            }\\n            \\n            // Poll a free server and assign to current task\\n            int[] server = freeServers.poll();\\n            assigned[t] = server[0];\\n            busyServers.computeIfAbsent(freeTime + tasks[t], ignored -> new ArrayList<>()).add(server);\\n        }\\n        return assigned;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // Free servers [{index, weight}]\\n        PriorityQueue<int[]> freeServers = \\n            new PriorityQueue<>((a, b) -> a[1] != b[1] ? a[1] - b[1] : a[0] - b[0]);\\n        for (int i = 0; i < servers.length; i++) {\\n            freeServers.offer(new int[]{i, servers[i]});\\n        }\\n        \\n        TreeMap<Integer, List<int[]>> busyServers = new TreeMap<>(); // Busy servers (availableTime -> [{index, weight}])\\n        Queue<Integer> freeTasks = new LinkedList<>();\\n        int[] assigned = new int[tasks.length]; // server index tasks assigned with\\n\\n        for (int t = 0; t < tasks.length || !freeTasks.isEmpty();) {\\n            if (t < tasks.length) {\\n                freeTasks.offer(t);\\n            }\\n            \\n            // release busy servers finishing before t\\n            while (!busyServers.isEmpty() && busyServers.firstKey() <= t) {\\n                freeServers.addAll(busyServers.pollFirstEntry().getValue());\\n            }\\n            \\n            // Poll free servers and assign to current freeTasks\\n            while (!freeServers.isEmpty() && !freeTasks.isEmpty()) {\\n                int[] server = freeServers.poll();\\n                int task = freeTasks.poll();\\n                assigned[task] = server[0];\\n                busyServers.computeIfAbsent(t + tasks[task], ignored -> new ArrayList<>()).add(server);\\n            }\\n            \\n            // Next time to check\\n            if (t < tasks.length) {\\n                t++;\\n            } else {\\n                t = busyServers.firstKey(); // busyServers should be non-empty until all tasks finished\\n            }\\n        }\\n        return assigned;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240961,
                "title": "time-simulation-two-priority-queues-c",
                "content": "**Code is Well comment, please go through that**\\nThis solution is based on time simulation and two priority queues( or can say Min Heaps).\\n1. To keep FREE servers sorted according to their weights along with their index.\\n2. To keep BUSY servers sorted according to their last busy time along with their index.\\n\\nIntially all the servers are free, so insert them in first PQ.\\nStart processing tasks one by one.\\n1. Check is there any BUSY Server which is getting free at current \"time\". If yes then insert all those free servers back to the FREE servers PQ(pq).\\n2. As given that we can assign multiple tasks at the same second if there are multiple free servers. So check if current time is more than starting time of remaining tasks and we have FREE server to assign that task.\\n3. If found that there is task to do at current time but no FREE server then we will simulate (increase) the time to the 1st BUSY server\\'s time because this will the first server to get free and untill then we cant do anything.\\n4. If found that we have no task to execute at current time then we will increase the time by one.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        // priority queue(MIN) to keep FREE servers sorted according to their weights\\n        // \"first\" stores weight\\n        // \"second\" store index of this current FREE server\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n        \\n        // priority queue(MIN) to keep BUSY servers sorted according to their last busy second\\n        // \"first\" stores time in seconds\\n        // \"second\" store index of this current BUSY server\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq2;\\n        \\n        //to store answer\\n        vector<int> ans;\\n        \\n        // Intially all the servers are free,\\n        // So insert them in first PQ\\n        // first is weight\\n        // second is index (needed to for answer purpose)\\n        for(int i=0;i<servers.size();i++){\\n            pq.push({servers[i],i});\\n        }\\n        \\n        // To simulate time\\n        int time = 0;\\n        \\n        // start processing tasks one by one.\\n        for(int i=0;i<tasks.size();i++){\\n            \\n            // Check is there any BUSY Server which is getting free at current \"time\"\\n            // if yes then insert all those free servers back to the FREE servers PQ(pq)\\n            while(!pq2.empty() && pq2.top().first==time){\\n                pq.push({servers[pq2.top().second],pq2.top().second});\\n                pq2.pop();\\n            }\\n            \\n            // To check whether FREE Server\\'s PQ is empty or not\\n            bool helo = false;\\n            \\n            // As given that we can assign multiple tasks at the same second if there are multiple free servers.\\n            // So check \\n            // if current time is more than starting time of remaining tasks and\\n            // we have FREE server to assign that task\\n            while(time>=i && i<tasks.size()){\\n                if(pq.empty()){\\n                    helo = true;\\n                    break;\\n                }\\n                \\n                // Take the FREE server, \\n                // assign the task i, \\n                // insert Server info in BUSY server\\'s PQ,\\n                // go to next task\\n                \\n                pair<int,int> val = pq.top();\\n                pq.pop();\\n                pq2.push({time+tasks[i], val.second});\\n                ans.push_back(val.second);\\n                i++;\\n            }\\n            \\n            // If found that there is task to do at current time but no FREE server\\n            // then we will simulate (increase) the time to the 1st BUSY server\\'s time\\n            // because this will the first server to get free and\\n            // untill then we cant do anything\\n            if(helo){\\n                time = pq2.top().first;\\n            }\\n            // If found that we have no task to execute at current time\\n            // then we will increase the time by one\\n            else{\\n                time++;\\n            }\\n            \\n            // as we know that when we come out of while loop (line 46)\\n            // the value of i has already been incresed in its last iteration\\n            // but sing condition got false, we wont complete the task at ith index\\n            // So after changing the simulated time, we will decrease the value of i by 1\\n            // so that in next for loop iteration, this task will get a server.\\n            i--;\\n        }\\n       \\n        //Return the answer\\n        return ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        // priority queue(MIN) to keep FREE servers sorted according to their weights\\n        // \"first\" stores weight\\n        // \"second\" store index of this current FREE server\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n        \\n        // priority queue(MIN) to keep BUSY servers sorted according to their last busy second\\n        // \"first\" stores time in seconds\\n        // \"second\" store index of this current BUSY server\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq2;\\n        \\n        //to store answer\\n        vector<int> ans;\\n        \\n        // Intially all the servers are free,\\n        // So insert them in first PQ\\n        // first is weight\\n        // second is index (needed to for answer purpose)\\n        for(int i=0;i<servers.size();i++){\\n            pq.push({servers[i],i});\\n        }\\n        \\n        // To simulate time\\n        int time = 0;\\n        \\n        // start processing tasks one by one.\\n        for(int i=0;i<tasks.size();i++){\\n            \\n            // Check is there any BUSY Server which is getting free at current \"time\"\\n            // if yes then insert all those free servers back to the FREE servers PQ(pq)\\n            while(!pq2.empty() && pq2.top().first==time){\\n                pq.push({servers[pq2.top().second],pq2.top().second});\\n                pq2.pop();\\n            }\\n            \\n            // To check whether FREE Server\\'s PQ is empty or not\\n            bool helo = false;\\n            \\n            // As given that we can assign multiple tasks at the same second if there are multiple free servers.\\n            // So check \\n            // if current time is more than starting time of remaining tasks and\\n            // we have FREE server to assign that task\\n            while(time>=i && i<tasks.size()){\\n                if(pq.empty()){\\n                    helo = true;\\n                    break;\\n                }\\n                \\n                // Take the FREE server, \\n                // assign the task i, \\n                // insert Server info in BUSY server\\'s PQ,\\n                // go to next task\\n                \\n                pair<int,int> val = pq.top();\\n                pq.pop();\\n                pq2.push({time+tasks[i], val.second});\\n                ans.push_back(val.second);\\n                i++;\\n            }\\n            \\n            // If found that there is task to do at current time but no FREE server\\n            // then we will simulate (increase) the time to the 1st BUSY server\\'s time\\n            // because this will the first server to get free and\\n            // untill then we cant do anything\\n            if(helo){\\n                time = pq2.top().first;\\n            }\\n            // If found that we have no task to execute at current time\\n            // then we will increase the time by one\\n            else{\\n                time++;\\n            }\\n            \\n            // as we know that when we come out of while loop (line 46)\\n            // the value of i has already been incresed in its last iteration\\n            // but sing condition got false, we wont complete the task at ith index\\n            // So after changing the simulated time, we will decrease the value of i by 1\\n            // so that in next for loop iteration, this task will get a server.\\n            i--;\\n        }\\n       \\n        //Return the answer\\n        return ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240403,
                "title": "crisp-and-clear-c-solution-explained",
                "content": "\\tvector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        // Defined struct WI and TI with their respective comparators already\\n        // Min priority queues : Free - {weight, idx}, Busy - {time, idx}\\n        priority_queue<WI, vector<WI>, CompareWI> Free;\\n        priority_queue<TI, vector<TI>, CompareTI> Busy;\\n        \\n        // Initalizing Free with all servers\\n        for(int i=0;i<servers.size();i++)\\n            Free.push( WI(servers[i], i) );\\n        \\n        // Array to store Assignments\\n        vector<int> Assign(tasks.size());\\n        \\n        int time = 0;\\n        \\n        // First, the first server will be popped from Free and Task 0 will be assigned to it\\n        // so it will be pushed to Busy.\\n        // Then, we will increment time by 1 and pop elements from Busy whose tasks are done\\n        // and push them back into Free. Then we again pick from Free and so on... \\n        // When all the servers become Busy, we jump our time from now to the time\\n        // when the next server is free (with lowest end time).\\n        \\n        // To handle the case of assigning multiple tasks, we will not increment time when\\n        // we popped more that one element from Busy, So we increment time only after we assign\\n        // all the tasks to servers available . \\n        \\n        for(int i = 0; i < tasks.size(); i++){\\n                \\n            if(Free.empty()) time = Busy.top().time;\\n            \\n            while(!Busy.empty()&&Busy.top().time<=time){\\n                \\n                Free.push( WI( servers[Busy.top().idx], Busy.top().idx ) );\\n                Busy.pop();\\n                \\n            }\\n            \\n            Assign[i] = Free.top().idx;\\n            Busy.push( TI( time + tasks[i], Free.top().idx ) );\\n            Free.pop();\\n            \\n            if(time<=i)\\n                time++;\\n            \\n        }\\n        \\n        return Assign;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\tvector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        // Defined struct WI and TI with their respective comparators already\\n        // Min priority queues : Free - {weight, idx}, Busy - {time, idx}\\n        priority_queue<WI, vector<WI>, CompareWI> Free;\\n        priority_queue<TI, vector<TI>, CompareTI> Busy;\\n        \\n        // Initalizing Free with all servers\\n        for(int i=0;i<servers.size();i++)\\n            Free.push( WI(servers[i], i) );\\n        \\n        // Array to store Assignments\\n        vector<int> Assign(tasks.size());\\n        \\n        int time = 0;\\n        \\n        // First, the first server will be popped from Free and Task 0 will be assigned to it\\n        // so it will be pushed to Busy.\\n        // Then, we will increment time by 1 and pop elements from Busy whose tasks are done\\n        // and push them back into Free. Then we again pick from Free and so on... \\n        // When all the servers become Busy, we jump our time from now to the time\\n        // when the next server is free (with lowest end time).\\n        \\n        // To handle the case of assigning multiple tasks, we will not increment time when\\n        // we popped more that one element from Busy, So we increment time only after we assign\\n        // all the tasks to servers available . \\n        \\n        for(int i = 0; i < tasks.size(); i++){\\n                \\n            if(Free.empty()) time = Busy.top().time;\\n            \\n            while(!Busy.empty()&&Busy.top().time<=time){\\n                \\n                Free.push( WI( servers[Busy.top().idx], Busy.top().idx ) );\\n                Busy.pop();\\n                \\n            }\\n            \\n            Assign[i] = Free.top().idx;\\n            Busy.push( TI( time + tasks[i], Free.top().idx ) );\\n            Free.pop();\\n            \\n            if(time<=i)\\n                time++;\\n            \\n        }\\n        \\n        return Assign;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1240374,
                "title": "javascript-two-min-pq-1184ms",
                "content": "```\\nconst mx = Math.max;\\nconst priorAssign = 2 * 10 ** 5;\\nconst assignTasks = (sv, tk) => {\\n    let n = sv.length;\\n    let m = tk.length;\\n\\t// pq for server, compare x[1] first, tie, then compare x[2]\\n    let spq = new MinPriorityQueue({ priority: x => x[1] * priorAssign + x[2] }); \\n    for (let i = 0; i < n; i++) {\\n        spq.enqueue([0, sv[i], i]);\\n    }\\n\\t// pq for process task, compare x[0] first, tie, then compare x[1], tie again, then compare x[2]\\n    let tpq = new MinPriorityQueue({ priority: x => x[0] * priorAssign * priorAssign + x[1] * priorAssign + x[2] }); \\n    let t = 0;\\n    let res = Array(m).fill(0);\\n    for (let i = 0; i < m; i++) {\\n        t = mx(t, i);\\n        while (tpq.size()) { // process task\\n            if (tpq.front().element[0] <= t) {\\n                spq.enqueue(tpq.dequeue().element) // release server when task finish\\n            } else {\\n                break;\\n            }\\n        }\\n        if (spq.isEmpty()) {\\n            t = tpq.front().element[0];\\n            spq.enqueue(tpq.dequeue().element);\\n        }\\n        let cur = spq.dequeue().element; // assign server to task\\n        res[i] = cur[2];\\n        cur[0] = t + tk[i];\\n        tpq.enqueue(cur); // add to task pq for processing until t + tk[i] then pop\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst mx = Math.max;\\nconst priorAssign = 2 * 10 ** 5;\\nconst assignTasks = (sv, tk) => {\\n    let n = sv.length;\\n    let m = tk.length;\\n\\t// pq for server, compare x[1] first, tie, then compare x[2]\\n    let spq = new MinPriorityQueue({ priority: x => x[1] * priorAssign + x[2] }); \\n    for (let i = 0; i < n; i++) {\\n        spq.enqueue([0, sv[i], i]);\\n    }\\n\\t// pq for process task, compare x[0] first, tie, then compare x[1], tie again, then compare x[2]\\n    let tpq = new MinPriorityQueue({ priority: x => x[0] * priorAssign * priorAssign + x[1] * priorAssign + x[2] }); \\n    let t = 0;\\n    let res = Array(m).fill(0);\\n    for (let i = 0; i < m; i++) {\\n        t = mx(t, i);\\n        while (tpq.size()) { // process task\\n            if (tpq.front().element[0] <= t) {\\n                spq.enqueue(tpq.dequeue().element) // release server when task finish\\n            } else {\\n                break;\\n            }\\n        }\\n        if (spq.isEmpty()) {\\n            t = tpq.front().element[0];\\n            spq.enqueue(tpq.dequeue().element);\\n        }\\n        let cur = spq.dequeue().element; // assign server to task\\n        res[i] = cur[2];\\n        cur[0] = t + tk[i];\\n        tpq.enqueue(cur); // add to task pq for processing until t + tk[i] then pop\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240094,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& a, vector<int>& b) {\\n        int n=a.size(),m=b.size();\\n        vector<int> ans(m,0);\\n        set<int> p;\\n        set<pair<int,int>> q,tm;\\n        for(int i=0;i<n;i++) q.insert({a[i],i});\\n        int cur=0;p.insert(0);\\n        while(cur<m || !p.empty()){\\n            while(!tm.empty() && cur>=(*tm.begin()).first){\\n                int id=(*tm.begin()).second;\\n                tm.erase(tm.begin());\\n                q.insert({a[id],id});\\n            }\\n            while(!p.empty() && !q.empty()){\\n                int t=*p.begin();p.erase(p.begin());\\n                pair<int,int> s=*q.begin();q.erase(q.begin());\\n                ans[t]=s.second;\\n                tm.insert({cur+b[t],s.second});\\n            }\\n            if(cur<m) cur++;\\n            else{\\n                if(!tm.empty()){\\n                    cur=(*tm.begin()).first;\\n                }\\n                else cur++;\\n            }\\n            if(cur<m) p.insert(cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& a, vector<int>& b) {\\n        int n=a.size(),m=b.size();\\n        vector<int> ans(m,0);\\n        set<int> p;\\n        set<pair<int,int>> q,tm;\\n        for(int i=0;i<n;i++) q.insert({a[i],i});\\n        int cur=0;p.insert(0);\\n        while(cur<m || !p.empty()){\\n            while(!tm.empty() && cur>=(*tm.begin()).first){\\n                int id=(*tm.begin()).second;\\n                tm.erase(tm.begin());\\n                q.insert({a[id],id});\\n            }\\n            while(!p.empty() && !q.empty()){\\n                int t=*p.begin();p.erase(p.begin());\\n                pair<int,int> s=*q.begin();q.erase(q.begin());\\n                ans[t]=s.second;\\n                tm.insert({cur+b[t],s.second});\\n            }\\n            if(cur<m) cur++;\\n            else{\\n                if(!tm.empty()){\\n                    cur=(*tm.begin()).first;\\n                }\\n                else cur++;\\n            }\\n            if(cur<m) p.insert(cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239977,
                "title": "python-two-heaps",
                "content": "Ideas:\\n\\n- Keeping two heaps: one for available machine and one for busy machine\\n- For every iteration, try to pop the first machine from the available heap if possible\\n- If not, pop the first one from the busy machine\\n- Push the recent machine in the busy heap for next iteration\\n\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \\n        avai_heap = [[weight,idx] for idx,weight in enumerate(servers)]\\n        busy_heap = []\\n        heapq.heapify(avai_heap)\\n        ans = []\\n        availabel_time = 0\\n        for time,cost in enumerate(tasks):\\n            while (busy_heap and time >= busy_heap[0][0]) or not avai_heap:\\n                availabel_time,weight,idx = heapq.heappop(busy_heap)\\n                heapq.heappush(avai_heap,[weight,idx])\\n            weight,idx = heapq.heappop(avai_heap)\\n            ans.append(idx)\\n            #in the case of no available machine, taking the first one from the busy heap\\n            # and calculate new time from that heap\\n            time = max(time,availabel_time)+cost\\n            heapq.heappush(busy_heap,[time,weight,idx])\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \\n        avai_heap = [[weight,idx] for idx,weight in enumerate(servers)]\\n        busy_heap = []\\n        heapq.heapify(avai_heap)\\n        ans = []\\n        availabel_time = 0\\n        for time,cost in enumerate(tasks):\\n            while (busy_heap and time >= busy_heap[0][0]) or not avai_heap:\\n                availabel_time,weight,idx = heapq.heappop(busy_heap)\\n                heapq.heappush(avai_heap,[weight,idx])\\n            weight,idx = heapq.heappop(avai_heap)\\n            ans.append(idx)\\n            #in the case of no available machine, taking the first one from the busy heap\\n            # and calculate new time from that heap\\n            time = max(time,availabel_time)+cost\\n            heapq.heappush(busy_heap,[time,weight,idx])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239935,
                "title": "ruby-standard-library-needs-heap",
                "content": "# Ruby\\nTried to emulate priority queue or heap using sorted Array.\\nThis solution gives TLE due tue complexity of `Array#insert`\\n\\n```ruby\\ndef assign_tasks(servers, tasks)\\n  n = servers.size\\n  pq = servers.zip(0...n).sort! \\n  servers = []\\n  time = 0\\n  tasks.map.with_index do |dur, start_time|\\n    time = [time, start_time].max\\n    while servers.any? && servers[0][0] <= time\\n      _, w, i = servers.shift\\n      pq.insert((pq.bsearch_index { |wt, j| w < wt || (w == wt && i < j) } || pq.size), [w, i])\\n    end\\n    if pq.empty?\\n      time = servers[0][0]\\n      while servers.any? && servers[0][0] == time\\n        _, w, i = servers.shift\\n        pq.insert((pq.bsearch_index { |wt, j| w < wt || (w == wt && i < j) } || pq.size), [w, i])\\n      end\\n    end\\n    w, i = pq.shift\\n    atime = time + dur\\n    servers.insert((servers.bsearch_index { |t, _, _| atime <= t } || servers.size), [atime, w, i])\\n    i\\n  end\\nend\\n```\\n\\n# Python\\n\\nConverted to Python using `heapq`  gives working solution:\\n\\n```python\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        pq = [[weight, i] for i, weight in enumerate(servers)]\\n        heapq.heapify(pq)\\n        servers = []\\n        time = 0\\n        res = []\\n        for start_time, dur in enumerate(tasks):\\n            time = max(time, start_time)\\n            while len(servers) > 0 and servers[0][0] <= time:\\n              t, w, i = heapq.heappop(servers)\\n              heapq.heappush(pq, [w, i])\\n\\n            if len(pq) == 0:\\n              time = servers[0][0]\\n              while len(servers) > 0 and servers[0][0] <= time:\\n                t, w, i = heapq.heappop(servers)\\n                heapq.heappush(pq, [w, i])\\n\\n            w, i = heapq.heappop(pq)\\n            heapq.heappush(servers, [time + dur, w, i])\\n            res.append(i)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Ruby",
                    "Heap (Priority Queue)"
                ],
                "code": "```ruby\\ndef assign_tasks(servers, tasks)\\n  n = servers.size\\n  pq = servers.zip(0...n).sort! \\n  servers = []\\n  time = 0\\n  tasks.map.with_index do |dur, start_time|\\n    time = [time, start_time].max\\n    while servers.any? && servers[0][0] <= time\\n      _, w, i = servers.shift\\n      pq.insert((pq.bsearch_index { |wt, j| w < wt || (w == wt && i < j) } || pq.size), [w, i])\\n    end\\n    if pq.empty?\\n      time = servers[0][0]\\n      while servers.any? && servers[0][0] == time\\n        _, w, i = servers.shift\\n        pq.insert((pq.bsearch_index { |wt, j| w < wt || (w == wt && i < j) } || pq.size), [w, i])\\n      end\\n    end\\n    w, i = pq.shift\\n    atime = time + dur\\n    servers.insert((servers.bsearch_index { |t, _, _| atime <= t } || servers.size), [atime, w, i])\\n    i\\n  end\\nend\\n```\n```python\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        pq = [[weight, i] for i, weight in enumerate(servers)]\\n        heapq.heapify(pq)\\n        servers = []\\n        time = 0\\n        res = []\\n        for start_time, dur in enumerate(tasks):\\n            time = max(time, start_time)\\n            while len(servers) > 0 and servers[0][0] <= time:\\n              t, w, i = heapq.heappop(servers)\\n              heapq.heappush(pq, [w, i])\\n\\n            if len(pq) == 0:\\n              time = servers[0][0]\\n              while len(servers) > 0 and servers[0][0] <= time:\\n                t, w, i = heapq.heappop(servers)\\n                heapq.heappush(pq, [w, i])\\n\\n            w, i = heapq.heappop(pq)\\n            heapq.heappush(servers, [time + dur, w, i])\\n            res.append(i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239923,
                "title": "c-solution-using-sets",
                "content": "**Approach**\\nWe use two sets here, one to store all the free servers and the other to store all the busy servers that are processing tasks.We use another varaible *curr* to keep track of the current time.\\nFor each task we check if any of the busy server is freed up and put it back again in the free servers set. We also set *b_time* to the next time at which a server gets free. Now we check if any of the server is free or not and if none of the servers are free we simply increase *curr*(current time) to *b_time* at which atleast one of the server is free and iterate for the current task again otherwise we assign that task to the server with minimum weight.\\n```\\nvector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n\\tset<pair<int,int>> free; // To store servers that are free.\\n\\tset<pair<int,pair<int,int>>> busy;  // To store servers that are processing tasks.\\n\\tint n = servers.size();\\n\\tint m = tasks.size();\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tfree.insert({servers[i],i}); // Stores weight and index of server.\\n\\tint curr = 0; // To keep track of time.\\n\\tvector<int> ans(m);\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tcurr = max(curr,i); //. At each iteration we set curr to max of i and curr since the ith task cannot be processed before time i\\n\\t\\tint b_time = curr; // To store the minumum time at which a server frees up.\\n\\t\\twhile(!busy.empty())\\n\\t\\t{\\n\\t\\t\\tauto it = (*busy.begin()); // Server that frees up earliest.\\n\\t\\t\\tif(it.first <= curr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfree.insert({it.second.first,it.second.second}); \\n\\t\\t\\t\\tbusy.erase(it);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t b_time = it.first;\\n\\t\\t\\t\\t break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(free.empty())\\n\\t\\t{\\n\\t\\t\\tcurr = b_time;\\n\\t\\t\\t--i; // To reiterate this task with updated time.\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tauto it = (*free.begin());\\n\\t\\tans[i] = it.second;\\n\\t\\tbusy.insert({tasks[i] + curr,{it.first,it.second}}); //. Stores time at which it frees up again and server.\\n\\t\\tfree.erase(it);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n\\tset<pair<int,int>> free; // To store servers that are free.\\n\\tset<pair<int,pair<int,int>>> busy;  // To store servers that are processing tasks.\\n\\tint n = servers.size();\\n\\tint m = tasks.size();\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tfree.insert({servers[i],i}); // Stores weight and index of server.\\n\\tint curr = 0; // To keep track of time.\\n\\tvector<int> ans(m);\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tcurr = max(curr,i); //. At each iteration we set curr to max of i and curr since the ith task cannot be processed before time i\\n\\t\\tint b_time = curr; // To store the minumum time at which a server frees up.\\n\\t\\twhile(!busy.empty())\\n\\t\\t{\\n\\t\\t\\tauto it = (*busy.begin()); // Server that frees up earliest.\\n\\t\\t\\tif(it.first <= curr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfree.insert({it.second.first,it.second.second}); \\n\\t\\t\\t\\tbusy.erase(it);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t b_time = it.first;\\n\\t\\t\\t\\t break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(free.empty())\\n\\t\\t{\\n\\t\\t\\tcurr = b_time;\\n\\t\\t\\t--i; // To reiterate this task with updated time.\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tauto it = (*free.begin());\\n\\t\\tans[i] = it.second;\\n\\t\\tbusy.insert({tasks[i] + curr,{it.first,it.second}}); //. Stores time at which it frees up again and server.\\n\\t\\tfree.erase(it);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239888,
                "title": "python3-priority-queue",
                "content": "\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        busy = []\\n        free = [(wt, i) for i, wt in enumerate(servers)]\\n        heapify(free)\\n        \\n        ans = []\\n        for t, task in enumerate(tasks): \\n            while busy and busy[0][0] == t: \\n                _, wt, i = heappop(busy)\\n                heappush(free, (wt, i))\\n            if free: wt, i = heappop(free)\\n            else: t, wt, i = heappop(busy)\\n            ans.append(i)\\n            heappush(busy, (t+task, wt, i))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        busy = []\\n        free = [(wt, i) for i, wt in enumerate(servers)]\\n        heapify(free)\\n        \\n        ans = []\\n        for t, task in enumerate(tasks): \\n            while busy and busy[0][0] == t: \\n                _, wt, i = heappop(busy)\\n                heappush(free, (wt, i))\\n            if free: wt, i = heappop(free)\\n            else: t, wt, i = heappop(busy)\\n            ans.append(i)\\n            heappush(busy, (t+task, wt, i))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239871,
                "title": "python-work-idle-heaps-o-nlogn",
                "content": "**Complexity**\\nTime: O(N * logN)\\nSpace: O(N)\\n\\n**Idea**\\nSimulation. Get from idle queue and put to work queue. \\nIf no more idle then time-travel to the closest idle time of any busy server.\\n\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        wq = [] # work queue\\n        iq = [] # idle queue\\n        n = len(tasks)\\n        res = [0] * n\\n        for i in range(len(servers)): # add all to iq (time, weight, idx)\\n            heapq.heappush(iq, (0, servers[i], i))\\n        \\n        sec = 0\\n        for i in range(n):\\n            sec = max(i, sec) # native seconds tick\\n            if not iq: # teleport to nearest any server idle time\\n                sec = max(sec, wq[0][0])\\n            # flush work queue\\n            while wq:\\n                if wq[0][0] > sec: # time\\n                    break\\n                time, weight, idx = heapq.heappop(wq)\\n                heapq.heappush(iq, (0, weight, idx))\\n                \\n            _, weight, idx = heapq.heappop(iq)\\n            res[i] = idx\\n            heapq.heappush(wq, (sec + tasks[i], weight, idx))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        wq = [] # work queue\\n        iq = [] # idle queue\\n        n = len(tasks)\\n        res = [0] * n\\n        for i in range(len(servers)): # add all to iq (time, weight, idx)\\n            heapq.heappush(iq, (0, servers[i], i))\\n        \\n        sec = 0\\n        for i in range(n):\\n            sec = max(i, sec) # native seconds tick\\n            if not iq: # teleport to nearest any server idle time\\n                sec = max(sec, wq[0][0])\\n            # flush work queue\\n            while wq:\\n                if wq[0][0] > sec: # time\\n                    break\\n                time, weight, idx = heapq.heappop(wq)\\n                heapq.heappush(iq, (0, weight, idx))\\n                \\n            _, weight, idx = heapq.heappop(iq)\\n            res[i] = idx\\n            heapq.heappush(wq, (sec + tasks[i], weight, idx))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239794,
                "title": "java-2-priorityqueue-method",
                "content": "Basic idea is to maintain 2 pq to track the next available server for the current tasks\\n```\\nclass Server {\\n        int index;\\n        int weight;\\n        int freeTime;\\n        \\n        public Server(int i, int w) {\\n            index = i;\\n            weight = w;\\n            freeTime = 0;\\n        }\\n    }\\n    \\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int n = tasks.length;\\n        int[] res = new int[n];\\n        int idx = 0;\\n        \\n        PriorityQueue<Server> pq = new PriorityQueue<>(new Comparator<>() {\\n            public int compare(Server a, Server b) {\\n                if (a.weight == b.weight) {\\n                    return a.index - b.index;\\n                }\\n                \\n                return a.weight - b.weight;\\n            }\\n        });\\n        \\n        PriorityQueue<Server> available = new PriorityQueue<>((a,b) -> (a.freeTime - b.freeTime));\\n        \\n        for (int i = 0; i < servers.length; i ++) {\\n            pq.add(new Server(i, servers[i]));\\n        }\\n        \\n        int nextTask = 0;\\n        int curTime = 0;\\n        \\n        while (nextTask < n) {\\n            while (!available.isEmpty() && available.peek().freeTime == curTime) {\\n                pq.offer(available.poll());\\n            }\\n            \\n            while (!pq.isEmpty() && nextTask < n && nextTask <= curTime) {\\n                Server cur = pq.poll();\\n                res[idx ++] = cur.index;\\n                cur.freeTime = curTime + tasks[nextTask];\\n                available.offer(cur);\\n                nextTask ++;\\n            }\\n            \\n            if (curTime < n) curTime ++;\\n            else curTime = available.peek().freeTime; // make current time euqals to next available server free time after queued all tasks\\n        }\\n        \\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Server {\\n        int index;\\n        int weight;\\n        int freeTime;\\n        \\n        public Server(int i, int w) {\\n            index = i;\\n            weight = w;\\n            freeTime = 0;\\n        }\\n    }\\n    \\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int n = tasks.length;\\n        int[] res = new int[n];\\n        int idx = 0;\\n        \\n        PriorityQueue<Server> pq = new PriorityQueue<>(new Comparator<>() {\\n            public int compare(Server a, Server b) {\\n                if (a.weight == b.weight) {\\n                    return a.index - b.index;\\n                }\\n                \\n                return a.weight - b.weight;\\n            }\\n        });\\n        \\n        PriorityQueue<Server> available = new PriorityQueue<>((a,b) -> (a.freeTime - b.freeTime));\\n        \\n        for (int i = 0; i < servers.length; i ++) {\\n            pq.add(new Server(i, servers[i]));\\n        }\\n        \\n        int nextTask = 0;\\n        int curTime = 0;\\n        \\n        while (nextTask < n) {\\n            while (!available.isEmpty() && available.peek().freeTime == curTime) {\\n                pq.offer(available.poll());\\n            }\\n            \\n            while (!pq.isEmpty() && nextTask < n && nextTask <= curTime) {\\n                Server cur = pq.poll();\\n                res[idx ++] = cur.index;\\n                cur.freeTime = curTime + tasks[nextTask];\\n                available.offer(cur);\\n                nextTask ++;\\n            }\\n            \\n            if (curTime < n) curTime ++;\\n            else curTime = available.peek().freeTime; // make current time euqals to next available server free time after queued all tasks\\n        }\\n        \\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239789,
                "title": "python-3-waiting-queue-and-two-server-heaps",
                "content": "Edit: there is a cleaner way to handle this, please refer to:\\nhttps://leetcode.com/problems/process-tasks-using-servers/discuss/1239767/Python-3-Simulation-Heap-Solution\\n\\nGet available servers at beginning of on each time tick, and assign the status of the assigned server.\\n\\n```\\nimport collections\\nimport heapq\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        waiting, ans = collections.deque(), [-1] * len(tasks)\\n        available = [(weight, i) for i, weight in enumerate(servers)]\\n        working = []\\n        heapq.heapify(available)\\n        for s, task in enumerate(tasks):\\n            while working and working[0][0] <= s:\\n                _, weight, server = heapq.heappop(working)\\n                heapq.heappush(available, (weight, server))\\n            waiting.append((s, task))\\n            while waiting and available:\\n                weight, server = heapq.heappop(available)\\n                j, cost = waiting.popleft()\\n                ans[j] = server\\n                heapq.heappush(working, (s + cost, weight, server))\\n        s, weight, server = -1, -1, -1\\n        while waiting:\\n            if available:\\n                weight, server = heapq.heappop(available)\\n            else:\\n                s, weight, server = heapq.heappop(working)\\n            j, cost = waiting.popleft()\\n            ans[j] = server\\n            heapq.heappush(working, (s + cost, weight, server))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport heapq\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        waiting, ans = collections.deque(), [-1] * len(tasks)\\n        available = [(weight, i) for i, weight in enumerate(servers)]\\n        working = []\\n        heapq.heapify(available)\\n        for s, task in enumerate(tasks):\\n            while working and working[0][0] <= s:\\n                _, weight, server = heapq.heappop(working)\\n                heapq.heappush(available, (weight, server))\\n            waiting.append((s, task))\\n            while waiting and available:\\n                weight, server = heapq.heappop(available)\\n                j, cost = waiting.popleft()\\n                ans[j] = server\\n                heapq.heappush(working, (s + cost, weight, server))\\n        s, weight, server = -1, -1, -1\\n        while waiting:\\n            if available:\\n                weight, server = heapq.heappop(available)\\n            else:\\n                s, weight, server = heapq.heappop(working)\\n            j, cost = waiting.popleft()\\n            ans[j] = server\\n            heapq.heappush(working, (s + cost, weight, server))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239765,
                "title": "python3-two-min-heaps",
                "content": "* Create two heaps called free and assigned\\n* Each task is assigned at the jth second. So if any servers have finished the task when that task is due for assignment, move them over to the free heap\\n* If there is a free server, remove it from the free heap and push it to the assigned heap\\n* While pushing to assigned heap, make sure to record the time at which the server will become free\\n* If no free servers are available when trying to assign, take the server that completes it\\'s assigned task the earliest\\n\\nTime Complexity: O(TSlgS)\\nSpace Complexity: O(S)\\n\\nS is the number of servers\\nT is the number of tasks\\n```\\nimport heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [(weight, i) for i, weight in enumerate(servers)]\\n        heapq.heapify(free)\\n        assigned = []\\n        result = []\\n        \\n        for time, dur in enumerate(tasks):\\n            while assigned and assigned[0][0] == time:\\n                _, weight, i = heapq.heappop(assigned)\\n                heapq.heappush(free, (weight, i))\\n            \\n            if not free:\\n                time, weight, i = heapq.heappop(assigned)\\n            else:\\n                weight, i = heapq.heappop(free)\\n                \\n            result.append(i)\\n            heapq.heappush(assigned, (time+dur, weight, i))\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [(weight, i) for i, weight in enumerate(servers)]\\n        heapq.heapify(free)\\n        assigned = []\\n        result = []\\n        \\n        for time, dur in enumerate(tasks):\\n            while assigned and assigned[0][0] == time:\\n                _, weight, i = heapq.heappop(assigned)\\n                heapq.heappush(free, (weight, i))\\n            \\n            if not free:\\n                time, weight, i = heapq.heappop(assigned)\\n            else:\\n                weight, i = heapq.heappop(free)\\n                \\n            result.append(i)\\n            heapq.heappush(assigned, (time+dur, weight, i))\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038914,
                "title": "beats-90-in-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& s, vector<int>& t) {\\n\\n        int n = s.size();\\n        int m = t.size();\\n\\n        int timer = 0;\\n\\n        queue<int>q;\\n        priority_queue<pi, vector<pi>, greater<pi> > available;\\n        priority_queue <pi, vector<pi>, greater<pi>> free;\\n\\n        for(int i = 0 ; i < n ; i++){\\n\\n            available.push(make_pair(s[i] , i));\\n        }\\n\\n        vector<int>ans;\\n\\n        pi use = available.top();\\n        available.pop();\\n        free.push(make_pair(t[0] , use.second));\\n        ans.push_back(use.second);\\n\\n        timer = 1;\\n\\n        while(ans.size() < m){\\n\\n            if(timer < m) q.push(timer);\\n\\n            while( !free.empty() && timer >= free.top().first){\\n\\n                pi temp = free.top();\\n                free.pop();\\n                int server_index = temp.second;\\n                available.push(make_pair(s[server_index] , server_index));\\n            }\\n\\n\\n            while( !available.empty() && !q.empty() ){\\n\\n                int task = q.front();\\n                q.pop();\\n\\n                pi temp = available.top();\\n                available.pop();\\n\\n                ans.push_back(temp.second);\\n                free.push(make_pair(timer+t[task],temp.second));\\n            }\\n\\n            if(timer >= m) timer += free.top().first-timer;\\n            else timer++;\\n        }\\n\\n       \\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& s, vector<int>& t) {\\n\\n        int n = s.size();\\n        int m = t.size();\\n\\n        int timer = 0;\\n\\n        queue<int>q;\\n        priority_queue<pi, vector<pi>, greater<pi> > available;\\n        priority_queue <pi, vector<pi>, greater<pi>> free;\\n\\n        for(int i = 0 ; i < n ; i++){\\n\\n            available.push(make_pair(s[i] , i));\\n        }\\n\\n        vector<int>ans;\\n\\n        pi use = available.top();\\n        available.pop();\\n        free.push(make_pair(t[0] , use.second));\\n        ans.push_back(use.second);\\n\\n        timer = 1;\\n\\n        while(ans.size() < m){\\n\\n            if(timer < m) q.push(timer);\\n\\n            while( !free.empty() && timer >= free.top().first){\\n\\n                pi temp = free.top();\\n                free.pop();\\n                int server_index = temp.second;\\n                available.push(make_pair(s[server_index] , server_index));\\n            }\\n\\n\\n            while( !available.empty() && !q.empty() ){\\n\\n                int task = q.front();\\n                q.pop();\\n\\n                pi temp = available.top();\\n                available.pop();\\n\\n                ans.push_back(temp.second);\\n                free.push(make_pair(timer+t[task],temp.second));\\n            }\\n\\n            if(timer >= m) timer += free.top().first-timer;\\n            else timer++;\\n        }\\n\\n       \\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981705,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct T {\\n  int weight;\\n  int index;\\n  int freeTime;\\n  T(int weight, int index, int freeTime)\\n      : weight(weight), index(index), freeTime(freeTime) {}\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n    const int n = servers.size();\\n    const int m = tasks.size();\\n    vector<int> ans(m);\\n    auto compareFree = [](const T& a, const T& b) {\\n      return a.weight == b.weight ? a.index > b.index : a.weight > b.weight;\\n    };\\n    auto compareUsed = [](const T& a, const T& b) {\\n      if (a.freeTime != b.freeTime)\\n        return a.freeTime > b.freeTime;\\n      if (a.weight != b.weight)\\n        return a.weight > b.weight;\\n      return a.index > b.index;\\n    };\\n    priority_queue<T, vector<T>, decltype(compareFree)> free(compareFree);\\n    priority_queue<T, vector<T>, decltype(compareUsed)> used(compareUsed);\\n\\n    for (int i = 0; i < n; ++i)\\n      free.emplace(servers[i], i, 0);\\n\\n    for (int i = 0; i < m; ++i) {  // I := current time\\n      const int executionTime = tasks[i];\\n      // Pop all servers that\\'ll be free at time i\\n      while (!used.empty() && used.top().freeTime <= i) {\\n        const T curr = used.top();\\n        used.pop();\\n        free.push(curr);\\n      }\\n      if (free.empty()) {\\n        T server = used.top();\\n        used.pop();\\n        ans[i] = server.index;\\n        server.freeTime += executionTime;\\n        used.push(server);\\n      } else {\\n        T server = free.top();\\n        free.pop();\\n        ans[i] = server.index;\\n        server.freeTime = i + executionTime;\\n        used.push(server);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct T {\\n  int weight;\\n  int index;\\n  int freeTime;\\n  T(int weight, int index, int freeTime)\\n      : weight(weight), index(index), freeTime(freeTime) {}\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n    const int n = servers.size();\\n    const int m = tasks.size();\\n    vector<int> ans(m);\\n    auto compareFree = [](const T& a, const T& b) {\\n      return a.weight == b.weight ? a.index > b.index : a.weight > b.weight;\\n    };\\n    auto compareUsed = [](const T& a, const T& b) {\\n      if (a.freeTime != b.freeTime)\\n        return a.freeTime > b.freeTime;\\n      if (a.weight != b.weight)\\n        return a.weight > b.weight;\\n      return a.index > b.index;\\n    };\\n    priority_queue<T, vector<T>, decltype(compareFree)> free(compareFree);\\n    priority_queue<T, vector<T>, decltype(compareUsed)> used(compareUsed);\\n\\n    for (int i = 0; i < n; ++i)\\n      free.emplace(servers[i], i, 0);\\n\\n    for (int i = 0; i < m; ++i) {  // I := current time\\n      const int executionTime = tasks[i];\\n      // Pop all servers that\\'ll be free at time i\\n      while (!used.empty() && used.top().freeTime <= i) {\\n        const T curr = used.top();\\n        used.pop();\\n        free.push(curr);\\n      }\\n      if (free.empty()) {\\n        T server = used.top();\\n        used.pop();\\n        ans[i] = server.index;\\n        server.freeTime += executionTime;\\n        used.push(server);\\n      } else {\\n        T server = free.top();\\n        free.pop();\\n        ans[i] = server.index;\\n        server.freeTime = i + executionTime;\\n        used.push(server);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964931,
                "title": "rust-solution-using-priority-queue",
                "content": "# Code\\n```\\nuse std::cmp::*;\\nuse std::collections::*;\\n\\nimpl PartialEq for Wrapper {\\n  fn eq(&self, other: &Wrapper) -> bool {\\n    self.0 == other.0\\n  }\\n}\\n\\nimpl PartialOrd for Wrapper {\\n  fn partial_cmp(&self, other: &Wrapper) -> Option<Ordering> {\\n    let v = self.0.cmp(&other.0);\\n    Some(if v == Ordering::Equal {\\n      self.1.cmp(&other.1)\\n    } else {\\n      v\\n    })\\n  }\\n}\\n\\n#[derive(Clone, Copy, Ord, Eq, Debug)] \\nstruct Wrapper(isize,usize);\\nimpl Solution {\\n  pub fn assign_tasks(servers: Vec<i32>, tasks: Vec<i32>) -> Vec<i32> {\\n    let mut btree_set = BTreeSet::new();\\n    let n = servers.len();\\n    let m = tasks.len();\\n    let mut result = vec![0;m];\\n    for i in 0..n {\\n      btree_set.insert(Wrapper(servers[i] as isize,i));\\n    }\\n\\n    let mut time = 0;\\n    let mut heap = BinaryHeap::new();\\n    \\n    for (i, v) in tasks.into_iter().enumerate() { \\n      time = i.max(time);\\n      if btree_set.is_empty() {\\n        let Reverse((ct, index)) = heap.pop().unwrap();\\n        time = ct;\\n        btree_set.insert(Wrapper(servers[index] as isize, index));\\n      }\\n\\n      while let Some(Reverse((ct, index))) = heap.pop() {\\n        if time < ct {\\n          heap.push(Reverse((ct, index)));\\n          break\\n        }\\n        btree_set.insert(Wrapper(servers[index] as isize, index));\\n      }\\n\\n      let &Wrapper(wait, index) = btree_set.iter().next().unwrap();\\n      btree_set.remove(&Wrapper(wait, index));\\n      result[i] = index as i32;\\n\\n      let nt = time+v as usize;\\n      heap.push(Reverse((nt, index)));\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nuse std::cmp::*;\\nuse std::collections::*;\\n\\nimpl PartialEq for Wrapper {\\n  fn eq(&self, other: &Wrapper) -> bool {\\n    self.0 == other.0\\n  }\\n}\\n\\nimpl PartialOrd for Wrapper {\\n  fn partial_cmp(&self, other: &Wrapper) -> Option<Ordering> {\\n    let v = self.0.cmp(&other.0);\\n    Some(if v == Ordering::Equal {\\n      self.1.cmp(&other.1)\\n    } else {\\n      v\\n    })\\n  }\\n}\\n\\n#[derive(Clone, Copy, Ord, Eq, Debug)] \\nstruct Wrapper(isize,usize);\\nimpl Solution {\\n  pub fn assign_tasks(servers: Vec<i32>, tasks: Vec<i32>) -> Vec<i32> {\\n    let mut btree_set = BTreeSet::new();\\n    let n = servers.len();\\n    let m = tasks.len();\\n    let mut result = vec![0;m];\\n    for i in 0..n {\\n      btree_set.insert(Wrapper(servers[i] as isize,i));\\n    }\\n\\n    let mut time = 0;\\n    let mut heap = BinaryHeap::new();\\n    \\n    for (i, v) in tasks.into_iter().enumerate() { \\n      time = i.max(time);\\n      if btree_set.is_empty() {\\n        let Reverse((ct, index)) = heap.pop().unwrap();\\n        time = ct;\\n        btree_set.insert(Wrapper(servers[index] as isize, index));\\n      }\\n\\n      while let Some(Reverse((ct, index))) = heap.pop() {\\n        if time < ct {\\n          heap.push(Reverse((ct, index)));\\n          break\\n        }\\n        btree_set.insert(Wrapper(servers[index] as isize, index));\\n      }\\n\\n      let &Wrapper(wait, index) = btree_set.iter().next().unwrap();\\n      btree_set.remove(&Wrapper(wait, index));\\n      result[i] = index as i32;\\n\\n      let nt = time+v as usize;\\n      heap.push(Reverse((nt, index)));\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3939439,
                "title": "python-two-heaps-one-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to 1834 Single-Threaded CPU, but instead of just one server, we have multiple servers. Therefore the code structure are similar instead we use while inside the outter while \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n2 min heap and 1 queue. First min heap store servers that are awaliable to work, second min heap store the servers that are currently occupied. The queue store the tasks that are ready to be done. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        for i in range(len(servers)):\\n            servers[i] = [servers[i], i]\\n        \\n        serverQueue = servers\\n        heapq.heapify(serverQueue)\\n\\n        processQueue = []\\n        heapq.heapify(processQueue)\\n\\n        taskQueue = deque()\\n        \\n        cur_time = 0\\n        i = 0\\n        res = [0] * len(tasks)\\n        while i < len(tasks) or taskQueue:\\n            while i < len(tasks) and cur_time >= i:\\n                taskQueue.append([i, tasks[i]])\\n                i += 1\\n                cur_time == i\\n\\n            while processQueue and processQueue[0][0] <= cur_time:\\n                time, weight, idx = heapq.heappop(processQueue)\\n                heapq.heappush(serverQueue, [weight, idx])\\n\\n           \\n            while taskQueue and serverQueue:\\n                serverWeight, serverIdx = heapq.heappop(serverQueue)\\n                taskIdx, processTime = taskQueue.popleft()\\n                res[taskIdx] = serverIdx\\n                heapq.heappush(processQueue, [cur_time + processTime, serverWeight, serverIdx])\\n            \\n            if processQueue and taskQueue:\\n                cur_time = processQueue[0][0]\\n            else:\\n                cur_time += 1\\n        \\n        return res\\n\\n\\n\\n            \\n\\n            \\n            \\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        for i in range(len(servers)):\\n            servers[i] = [servers[i], i]\\n        \\n        serverQueue = servers\\n        heapq.heapify(serverQueue)\\n\\n        processQueue = []\\n        heapq.heapify(processQueue)\\n\\n        taskQueue = deque()\\n        \\n        cur_time = 0\\n        i = 0\\n        res = [0] * len(tasks)\\n        while i < len(tasks) or taskQueue:\\n            while i < len(tasks) and cur_time >= i:\\n                taskQueue.append([i, tasks[i]])\\n                i += 1\\n                cur_time == i\\n\\n            while processQueue and processQueue[0][0] <= cur_time:\\n                time, weight, idx = heapq.heappop(processQueue)\\n                heapq.heappush(serverQueue, [weight, idx])\\n\\n           \\n            while taskQueue and serverQueue:\\n                serverWeight, serverIdx = heapq.heappop(serverQueue)\\n                taskIdx, processTime = taskQueue.popleft()\\n                res[taskIdx] = serverIdx\\n                heapq.heappush(processQueue, [cur_time + processTime, serverWeight, serverIdx])\\n            \\n            if processQueue and taskQueue:\\n                cur_time = processQueue[0][0]\\n            else:\\n                cur_time += 1\\n        \\n        return res\\n\\n\\n\\n            \\n\\n            \\n            \\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894197,
                "title": "o-mlogn-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have given m number of tasks with processing time and n number of servers with weight. We have to schedule these tasks and return which task was done by which server i.e indices of the servers.\\n\\nFor each task arriving at time t i.e at index i:\\n- release all busy servers with availability time <= t\\n- if free servers are available, pick the one with minimum weight and index and assign it to the task\\n- if free server is not available, release the earliest available busy server and assign it to the task\\n\\nWe need to track the minimum weight in available/free servers and the earliest available time in unavailable/busy servers. Use min heap because it returns the top/min element in O(1) time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- create a result list to store the indices of servers\\n- create a min heap for busy servers. For each server the heap will contain availability time, weight, and index i.e the heap will be sorted by availability time\\n- create a min heap for free servers. For each server, the heap will contain weight, index, and availability time i.e the heap will be sorted by weight. \\n- Note: create a list first and then heapify to create a min heap. If you create min-heap without heapify i.e by pushing elements one by one, the time complexity will be O(nlogn) \\n- Traverse all tasks. For index/start time and processing time for each task\\n    - if there are busy servers and busy server availability time <= start time of the current task, release the busy server by removing it from the busy servers heap and add it to the free server heap \\n    - if there is a server available, pop free server heap to get the minimum weight server and assign it to process the task by marking it busy i.e push it to the busy heap and add its index to the result \\n    - else there is no server available, pop busy server heap to get the busy server with minimal availability time, and assign it to the task i.e push the server with new availability time to the busy heap and add its index to result\\n- return result list\\n\\n# Complexity\\n- Time complexity: (free server list + heapify + iteration * heap push pop) \\u2192 (n + n + m * logn) \\u2192 (mlogn)\\n    - n = number of servers\\n    - m = number of tasks\\n    - logn = heap push pop takes log(heap size) and heap size is n\\n    - the inner while loop will not run n times for each outer loop iteration \\u2192 O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(free server heap + busy server heap + result) \\u2192 O(n + n + n) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res = []\\n        busy = []\\n        free = [(weight, i, 0) for i, weight in enumerate(servers)]\\n        heapify(free)\\n        for start_time, process_time in enumerate(tasks):\\n            while busy and busy[0][0] <= start_time:\\n                free_time, weight, index = heappop(busy)\\n                heappush(free, (weight, index, free_time))\\n            if free:\\n                weight, index, free_time = heappop(free)\\n                res.append(index)\\n                heappush(busy, (start_time + process_time, weight, index))\\n            else:\\n                free_time, weight, index = heappop(busy)\\n                res.append(index)\\n                heappush(busy, (free_time + process_time, weight, index))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res = []\\n        busy = []\\n        free = [(weight, i, 0) for i, weight in enumerate(servers)]\\n        heapify(free)\\n        for start_time, process_time in enumerate(tasks):\\n            while busy and busy[0][0] <= start_time:\\n                free_time, weight, index = heappop(busy)\\n                heappush(free, (weight, index, free_time))\\n            if free:\\n                weight, index, free_time = heappop(free)\\n                res.append(index)\\n                heappush(busy, (start_time + process_time, weight, index))\\n            else:\\n                free_time, weight, index = heappop(busy)\\n                res.append(index)\\n                heappush(busy, (free_time + process_time, weight, index))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867612,
                "title": "c-two-heaps-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        vector<int> res;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> avail; \\n        // this will keep track of available servers\\n\\n        // pushing servers in available heap\\n        for(int i = 0; i < servers.size(); i++) avail.push({servers[i], i});\\n\\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> unavail; \\n        // (timeServerBecomesFree, serverWeight, ind) \\n        // this will keep track of unavailable servers\\n\\n        int time = 0;\\n\\n        for(int i = 0; i < tasks.size(); i++){\\n            time = max(time, i); \\n            // ideally time will be equal to i, but if we ever\\n            // advance the time then it will take care of it\\n\\n            \\n            // if there is a case where there is no available \\n            // servers then we will advance the time\\n            if(avail.empty())\\n                time = unavail.top()[0]; \\n                // advancing time to the time when the first \\n                // server will become available\\n            \\n\\n            // every itration of the loop time maybe updated so \\n            // we will go through every unavailable serveres and \\n            // check if it\\'s available or not and push in our avail\\n            while(!unavail.empty() && unavail.top()[0] <= time){\\n                auto [e, server, ind] = unavail.top();\\n                unavail.pop();\\n                avail.push({server, ind});\\n            }\\n\\n\\n            // now we after above two operation we are sure that    \\n            // there will be a server available so now we will take \\n            // that available server and make it unavailable and \\n            // put it in our res\\n            auto t = avail.top();\\n            avail.pop();\\n            unavail.push({time+tasks[i], t.first, t.second});\\n            res.push_back(t.second);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        vector<int> res;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> avail; \\n        // this will keep track of available servers\\n\\n        // pushing servers in available heap\\n        for(int i = 0; i < servers.size(); i++) avail.push({servers[i], i});\\n\\n        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> unavail; \\n        // (timeServerBecomesFree, serverWeight, ind) \\n        // this will keep track of unavailable servers\\n\\n        int time = 0;\\n\\n        for(int i = 0; i < tasks.size(); i++){\\n            time = max(time, i); \\n            // ideally time will be equal to i, but if we ever\\n            // advance the time then it will take care of it\\n\\n            \\n            // if there is a case where there is no available \\n            // servers then we will advance the time\\n            if(avail.empty())\\n                time = unavail.top()[0]; \\n                // advancing time to the time when the first \\n                // server will become available\\n            \\n\\n            // every itration of the loop time maybe updated so \\n            // we will go through every unavailable serveres and \\n            // check if it\\'s available or not and push in our avail\\n            while(!unavail.empty() && unavail.top()[0] <= time){\\n                auto [e, server, ind] = unavail.top();\\n                unavail.pop();\\n                avail.push({server, ind});\\n            }\\n\\n\\n            // now we after above two operation we are sure that    \\n            // there will be a server available so now we will take \\n            // that available server and make it unavailable and \\n            // put it in our res\\n            auto t = avail.top();\\n            avail.pop();\\n            unavail.push({time+tasks[i], t.first, t.second});\\n            res.push_back(t.second);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839031,
                "title": "using-minheap-the-solution-can-be-solved-in-o-nlogm",
                "content": "# Intuition\\nWe create two heaps for servers, available and unavailable.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogm)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res = []\\n        avail = [(servers[i], i) for i in range(len(servers))]\\n        heapq.heapify(avail)\\n        unavail = []\\n        t = 0\\n        for i in range(len(tasks)):\\n            t = max(t, i)\\n\\n            # forward time if necessary\\n            if len(avail) == 0:\\n                t = unavail[0][0]\\n            \\n            # check if there are servers in unavail that can be made available\\n            while unavail and t >= unavail[0][0]:\\n                time, weight, idx = heapq.heappop(unavail)\\n                heapq.heappush(avail, (weight, idx))\\n            \\n            # now take an available server and assign it some task\\n            weight, idx = heapq.heappop(avail)\\n            res.append(idx)\\n            heapq.heappush(unavail, (t + tasks[i], weight, idx))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res = []\\n        avail = [(servers[i], i) for i in range(len(servers))]\\n        heapq.heapify(avail)\\n        unavail = []\\n        t = 0\\n        for i in range(len(tasks)):\\n            t = max(t, i)\\n\\n            # forward time if necessary\\n            if len(avail) == 0:\\n                t = unavail[0][0]\\n            \\n            # check if there are servers in unavail that can be made available\\n            while unavail and t >= unavail[0][0]:\\n                time, weight, idx = heapq.heappop(unavail)\\n                heapq.heappush(avail, (weight, idx))\\n            \\n            # now take an available server and assign it some task\\n            weight, idx = heapq.heappop(avail)\\n            res.append(idx)\\n            heapq.heappush(unavail, (t + tasks[i], weight, idx))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831106,
                "title": "c-simulate-the-problem-to-solve",
                "content": "**Intuition:**\\n\\nThe paradigm used to solve this task allocation problem is a simulation-based approach combined with priority queues. By simulating the task assignment process and maintaining two priority queues to efficiently track free and busy servers, we can assign tasks to servers optimally based on their weights and availability, following the specified priority rules. The priority queues help to find the most suitable servers for each task in an efficient manner, and the simulation ensures the tasks are processed in the correct order and that servers\\' completion times are updated accurately.\\n\\n**Approach:**\\n\\n1. Initialize two priority queues, `free` and `busy`, as Min Heaps, to keep track of free and busy servers, respectively.\\n2. Create an empty vector `ans` to store the indices of servers to which tasks will be assigned.\\n3. Initialize `time` to 0, which will be used to keep track of the current time or the task index.\\n4. Iterate through the `servers` array and add each server to the `free` priority queue with an initial completion time of 0, its weight, and the respective server index.\\n5. While there are still tasks to be processed (time < tasks.size()):\\n   a. If there is a free server available (the `free` priority queue is not empty):\\n      - Pop the top server from the `free` priority queue, assign the current task to this server, and update its completion time as `time + tasks[time]`. Push this server to the `busy` priority queue.\\n      - Add the server\\'s index to the `ans` array.\\n      - Increment `time` to process the next task.\\n   b. While there are servers in the `busy` priority queue and their completion time is less than or equal to the current time (`time`), free up the server and push it back to the `free` priority queue.\\n   c. If there are no free servers available (the `free` priority queue is empty):\\n      - Pop the top server from the `busy` priority queue since it will become free at the current time (`time`).\\n      - Update the completion time of the server as `server[0] - time` (the time when it becomes free).\\n      - Push the server back to the `free` priority queue.\\n6. Return the `ans` array.\\n\\n**Complexity Analysis:**\\n\\n- Time Complexity: The time complexity of this approach is O(m log n), where n is the number of servers and m is the number of tasks. In each iteration, we perform operations on the priority queues, and each operation takes O(log n) time.\\n- Space Complexity: The space complexity is O(n) to store the two priority queues.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> busy, free;\\n        vector<int> ans;\\n        int time = 0;\\n\\n        for(int i = 0 ; i < servers.size() ; ++i ){\\n            free.push({0, servers[i], i});\\n        }\\n\\n        while(time < tasks.size()){\\n\\n            if(!free.empty()){\\n                vector<int> server = free.top();\\n                free.pop();\\n                server[0] +=  time + tasks[time];\\n                busy.push(server);\\n                ans.push_back(server[2]);\\n                time++;\\n            }\\n\\n\\n            while(!busy.empty() && busy.top()[0] <= time){\\n                vector<int> server =  busy.top();\\n                busy.pop();\\n                server[0] = 0;\\n                free.push(server);\\n            }\\n\\n            if(free.empty()){\\n                vector<int> server = busy.top();\\n                busy.pop();\\n                server[0] = server[0] - time;\\n                free.push(server);\\n            }\\n\\n        }\\n\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> busy, free;\\n        vector<int> ans;\\n        int time = 0;\\n\\n        for(int i = 0 ; i < servers.size() ; ++i ){\\n            free.push({0, servers[i], i});\\n        }\\n\\n        while(time < tasks.size()){\\n\\n            if(!free.empty()){\\n                vector<int> server = free.top();\\n                free.pop();\\n                server[0] +=  time + tasks[time];\\n                busy.push(server);\\n                ans.push_back(server[2]);\\n                time++;\\n            }\\n\\n\\n            while(!busy.empty() && busy.top()[0] <= time){\\n                vector<int> server =  busy.top();\\n                busy.pop();\\n                server[0] = 0;\\n                free.push(server);\\n            }\\n\\n            if(free.empty()){\\n                vector<int> server = busy.top();\\n                busy.pop();\\n                server[0] = server[0] - time;\\n                free.push(server);\\n            }\\n\\n        }\\n\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827747,
                "title": "process-tasks-using-servers-well-explained-two-heaps-commented-on-every-step-min-heaps",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        import heapq as hq\\n        #List **a** is a heap consist particular server and its id/index.\\n        a=[]\\n        hq.heapify(a)\\n        for i in range(len(servers)):\\n            hq.heappush(a,[servers[i],i])\\n        print(a)\\n        \\n        t=0\\n        # List **aw** is heap which is for keeping a track of the servers which is assigned to the tasks.\\n        aw=[]\\n        # List **q** is an answers list to store ans (whhis task is assigned to which server)\\n        q=[]\\n        hq.heapify(aw)\\n        for i in range(len(tasks)):\\n            #Pop out all the free server First so we can assign \\n            #task easily to the servers as we have to assign work    \\n            #to the Smallest weighted server  \\n            while len(aw):\\n                if aw[0][0]<=t: # if task has completed the pop out\\n                    x=hq.heappop(aw)\\n                    new=[x[1],x[2]]\\n                    hq.heappush(a,new)\\n                else:\\n                    break # if task hasnt completed yet then break \\n            #if no server is free so pop out small weighted server\\n            #from the assigned servers and assign it to the next task\\n            if len(a)==0:\\n                x=hq.heappop(aw)\\n                hq.heappush(aw,[x[0]+tasks[i],x[1],x[2]])\\n                q.append(x[2])# add the index or id of the server to ans list for keeping track of which task is assigned to which servee\\n            #else if all or some of servers are free the assign \\n            #them tasj blindly if task is there in queue/list \\n            else:\\n                x=hq.heappop(a)\\n                q.append(x[1])\\n                new=[t+tasks[i]]\\n                hq.heappush(aw,new+x)\\n            t+=1\\n        return(q) \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        import heapq as hq\\n        #List **a** is a heap consist particular server and its id/index.\\n        a=[]\\n        hq.heapify(a)\\n        for i in range(len(servers)):\\n            hq.heappush(a,[servers[i],i])\\n        print(a)\\n        \\n        t=0\\n        # List **aw** is heap which is for keeping a track of the servers which is assigned to the tasks.\\n        aw=[]\\n        # List **q** is an answers list to store ans (whhis task is assigned to which server)\\n        q=[]\\n        hq.heapify(aw)\\n        for i in range(len(tasks)):\\n            #Pop out all the free server First so we can assign \\n            #task easily to the servers as we have to assign work    \\n            #to the Smallest weighted server  \\n            while len(aw):\\n                if aw[0][0]<=t: # if task has completed the pop out\\n                    x=hq.heappop(aw)\\n                    new=[x[1],x[2]]\\n                    hq.heappush(a,new)\\n                else:\\n                    break # if task hasnt completed yet then break \\n            #if no server is free so pop out small weighted server\\n            #from the assigned servers and assign it to the next task\\n            if len(a)==0:\\n                x=hq.heappop(aw)\\n                hq.heappush(aw,[x[0]+tasks[i],x[1],x[2]])\\n                q.append(x[2])# add the index or id of the server to ans list for keeping track of which task is assigned to which servee\\n            #else if all or some of servers are free the assign \\n            #them tasj blindly if task is there in queue/list \\n            else:\\n                x=hq.heappop(a)\\n                q.append(x[1])\\n                new=[t+tasks[i]]\\n                hq.heappush(aw,new+x)\\n            t+=1\\n        return(q) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732344,
                "title": "java-solution-with-two-priority-queues-with-own-comporators",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe task sounds like we will need to implement priority queue container with list of servers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create two comparators and two priority queues. The first pair for servers that are available, and the second one for servers that are in processing. In the first moment of time all the servers are free, so we put all the servers to the freeServQueue. Then we begin to assign tasks using for loop. \\nConsider every iteration:\\nwe calculate time. It depends on if we have available servers. if we don`t have available servers time = time of the first server from the top of busy servers queue. Otherwise, time = max value between i index and current value of time.\\nThen we, using temp var, we work out a task with current server, write down task to result var and back server to queue with free servers. We are repeating these operations while we have tasks to do.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int[] result = new int[tasks.length];\\n\\n        Comparator<int[]> freeServComparator = (a, b) -> (a[0] == b[0]) ? (a[1] - b[1]) : (a[0] - b[0]);\\n        Comparator<int[]> busyServComparator = Comparator.comparingInt(a -> a[0]);\\n\\n        PriorityQueue<int[]> freeServQueue = new PriorityQueue<>(freeServComparator);\\n        PriorityQueue<int[]> busyServQueue = new PriorityQueue<>(busyServComparator);\\n\\n        for (int i = 0; i < servers.length; i++) freeServQueue.add(new int[]{servers[i], i});\\n\\n        int time = 0;\\n\\n        for (int i = 0; i < tasks.length; i++) {\\n            time = Math.max(i, time);\\n            if (freeServQueue.isEmpty()) time = busyServQueue.peek()[0];\\n\\n\\n            while (!busyServQueue.isEmpty() && time == busyServQueue.peek()[0]) {\\n                int[] temp = busyServQueue.poll();\\n                int[] freeServer = {servers[temp[1]], temp[1]};\\n                freeServQueue.offer(freeServer);\\n            }\\n            int[] server = freeServQueue.poll();\\n            result[i] = server[1];\\n            busyServQueue.offer(new int[]{time + tasks[i], server[1]});\\n\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int[] result = new int[tasks.length];\\n\\n        Comparator<int[]> freeServComparator = (a, b) -> (a[0] == b[0]) ? (a[1] - b[1]) : (a[0] - b[0]);\\n        Comparator<int[]> busyServComparator = Comparator.comparingInt(a -> a[0]);\\n\\n        PriorityQueue<int[]> freeServQueue = new PriorityQueue<>(freeServComparator);\\n        PriorityQueue<int[]> busyServQueue = new PriorityQueue<>(busyServComparator);\\n\\n        for (int i = 0; i < servers.length; i++) freeServQueue.add(new int[]{servers[i], i});\\n\\n        int time = 0;\\n\\n        for (int i = 0; i < tasks.length; i++) {\\n            time = Math.max(i, time);\\n            if (freeServQueue.isEmpty()) time = busyServQueue.peek()[0];\\n\\n\\n            while (!busyServQueue.isEmpty() && time == busyServQueue.peek()[0]) {\\n                int[] temp = busyServQueue.poll();\\n                int[] freeServer = {servers[temp[1]], temp[1]};\\n                freeServQueue.offer(freeServer);\\n            }\\n            int[] server = freeServQueue.poll();\\n            result[i] = server[1];\\n            busyServQueue.offer(new int[]{time + tasks[i], server[1]});\\n\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720197,
                "title": "java-priority-queue-same-as-heap-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO((N + M)logN), M: task\\'s length, N: servers\\' length\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private class FreeServComparator implements Comparator<int[]> {\\n        @Override\\n        public int compare(int[] a, int[] b) {\\n            if(a[0] == b[0]) {\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];\\n        }\\n    }\\n\\n    private class RunningServComparator implements Comparator<int[]> {\\n        @Override\\n        public int compare(int[] a, int[] b) {\\n            return a[0] - b[0];\\n        }\\n    }\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> free = new PriorityQueue<>(new FreeServComparator());\\n        PriorityQueue<int[]> running = new PriorityQueue<>(new RunningServComparator());\\n\\n        for(int i = 0; i < servers.length; i++) {\\n            free.offer(new int[]{servers[i], i});\\n        }\\n        \\n        int[] ans = new int[tasks.length];\\n        int currTime = 0;\\n        for(int j = 0; j < tasks.length; j++) {\\n            currTime = Math.max(j, currTime);\\n            if(free.isEmpty()) {\\n                currTime = (running.peek())[0];\\n            }\\n            while(!running.isEmpty() && currTime == (running.peek())[0]) {\\n                int[] temp = running.poll();\\n                int[] freeServ = new int[]{servers[temp[1]], temp[1]};\\n                free.offer(freeServ);\\n            }\\n            int[] serv = free.poll();\\n            ans[j] = serv[1];\\n            running.offer(new int[]{currTime + tasks[j], serv[1]});\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private class FreeServComparator implements Comparator<int[]> {\\n        @Override\\n        public int compare(int[] a, int[] b) {\\n            if(a[0] == b[0]) {\\n                return a[1] - b[1];\\n            }\\n            return a[0] - b[0];\\n        }\\n    }\\n\\n    private class RunningServComparator implements Comparator<int[]> {\\n        @Override\\n        public int compare(int[] a, int[] b) {\\n            return a[0] - b[0];\\n        }\\n    }\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> free = new PriorityQueue<>(new FreeServComparator());\\n        PriorityQueue<int[]> running = new PriorityQueue<>(new RunningServComparator());\\n\\n        for(int i = 0; i < servers.length; i++) {\\n            free.offer(new int[]{servers[i], i});\\n        }\\n        \\n        int[] ans = new int[tasks.length];\\n        int currTime = 0;\\n        for(int j = 0; j < tasks.length; j++) {\\n            currTime = Math.max(j, currTime);\\n            if(free.isEmpty()) {\\n                currTime = (running.peek())[0];\\n            }\\n            while(!running.isEmpty() && currTime == (running.peek())[0]) {\\n                int[] temp = running.poll();\\n                int[] freeServ = new int[]{servers[temp[1]], temp[1]};\\n                free.offer(freeServ);\\n            }\\n            int[] serv = free.poll();\\n            ans[j] = serv[1];\\n            running.offer(new int[]{currTime + tasks[j], serv[1]});\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687878,
                "title": "c-easy-solution-explained",
                "content": "```\\n vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>wait;\\n        //min heap  used to store time and index\\n         priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>active;\\n        //min heap used to store weight and index\\n        vector<int>ans;\\n        //used to store time at which a particular tasks is assigned to a schedular\\n        int len=tasks.size(), len2=servers.size();\\n        ll  time=0;\\n        for(int i=0;i<len2;i++){\\n            active.push({servers[i],i});//store server with its index\\n        }\\n        int ind=0;\\n        while(ind<len){\\n            if(!wait.empty()){\\n                //suppose their is no active server and also the smallest waiting server is \\n                if(active.empty()){//will free after 10000 seconds then there is no \\n                    time=wait.top().first;//way we gonna increase time by one second \\n    }//it will cause tle its better to just make time equal to smallest wating element      \\n      while(!wait.empty()&&wait.top().first<=time){\\n                    int val=wait.top().second;\\n                    active.push({servers[val],val});\\n                    wait.pop();\\n                }\\n            }\\n            while(!active.empty()&&ind<len&&ind<=time){//if multiple severs and tasks and servers availale at the same time then we schedule them at the same time \\n                auto val=active.top();\\n                active.pop();\\n                wait.push({time+tasks[ind],val.second});\\n                ans.push_back(val.second);\\n                 ind++;\\n            }\\n            time++;  \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>wait;\\n        //min heap  used to store time and index\\n         priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>active;\\n        //min heap used to store weight and index\\n        vector<int>ans;\\n        //used to store time at which a particular tasks is assigned to a schedular\\n        int len=tasks.size(), len2=servers.size();\\n        ll  time=0;\\n        for(int i=0;i<len2;i++){\\n            active.push({servers[i],i});//store server with its index\\n        }\\n        int ind=0;\\n        while(ind<len){\\n            if(!wait.empty()){\\n                //suppose their is no active server and also the smallest waiting server is \\n                if(active.empty()){//will free after 10000 seconds then there is no \\n                    time=wait.top().first;//way we gonna increase time by one second \\n    }//it will cause tle its better to just make time equal to smallest wating element      \\n      while(!wait.empty()&&wait.top().first<=time){\\n                    int val=wait.top().second;\\n                    active.push({servers[val],val});\\n                    wait.pop();\\n                }\\n            }\\n            while(!active.empty()&&ind<len&&ind<=time){//if multiple severs and tasks and servers availale at the same time then we schedule them at the same time \\n                auto val=active.top();\\n                active.pop();\\n                wait.push({time+tasks[ind],val.second});\\n                ans.push_back(val.second);\\n                 ind++;\\n            }\\n            time++;  \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3661353,
                "title": "priority-queue-detailed-explanation-cpppro",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two priority queues: avail to track available servers and use to track currently busy servers. The pairs stored in these queues represent the time when a server becomes available and the server index.\\n2. Populate the avail priority queue with the initial server availability information. Each pair contains the server\\'s availability time and its index.\\n\\n3. Iterate over the tasks to be assigned. For each task:\\n    - Update the current time to be the maximum of the current task\\n    index and the previous time.\\n    - If no servers are currently available (avail is empty), set the  current time to the earliest availability time among the busy servers in the use priority queue.\\n    - Process all the servers in the use priority queue that have become available by comparing their availability time with the current time. Remove them from the use queue and add them back to the avail queue.\\n    - Assign the task to the top available server in the avail priority queue. Push the server\\'s completion time (current time + task duration) and its index to the use priority queue.\\n    - Store the assigned server\\'s index in the ans vector.\\n    - Remove the assigned server from the avail queue.\\n4. Return the ans vector containing the assigned server indices for each task\\n\\n# Complexity\\n- Time complexity: **O((n+m)logn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> avail;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> use;\\n\\n        int n = servers.size();\\n        int m = tasks.size();\\n        vector<int> ans(m);\\n\\n        for (int i = 0; i < n; i++) {\\n            avail.push({servers[i], i});\\n        }\\n\\n        long long time = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            time = max(static_cast<long long>(i), time);\\n            if (avail.empty()) {\\n                time = use.top().first;\\n            }\\n\\n            while (!use.empty() && use.top().first <= time) {\\n                auto [useTime, index] = use.top();\\n                avail.push({servers[index], index});\\n                use.pop();\\n            }\\n            auto [server, index] = avail.top();\\n            use.push({time + tasks[i], index});\\n            ans[i] = index;\\n            avail.pop();\\n    }\\n    return ans;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> avail;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> use;\\n\\n        int n = servers.size();\\n        int m = tasks.size();\\n        vector<int> ans(m);\\n\\n        for (int i = 0; i < n; i++) {\\n            avail.push({servers[i], i});\\n        }\\n\\n        long long time = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            time = max(static_cast<long long>(i), time);\\n            if (avail.empty()) {\\n                time = use.top().first;\\n            }\\n\\n            while (!use.empty() && use.top().first <= time) {\\n                auto [useTime, index] = use.top();\\n                avail.push({servers[index], index});\\n                use.pop();\\n            }\\n            auto [server, index] = avail.top();\\n            use.push({time + tasks[i], index});\\n            ans[i] = index;\\n            avail.pop();\\n    }\\n    return ans;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543027,
                "title": "c-longer-code-with-cleaner-logic",
                "content": "I\\'ve tried to make the code shorter and even much shorter, but the logic gets a little convoluted. Sometime, clean logic actually requires more coding.\\n\\n- Two min heaps to keep `free`/available servers and `busy`/to-be-finished servers.\\n- Add task to `request`queue and `assign` one by one for task at each given `time`.\\n- After that if there are still `request` in the queue, that means we run out of `free` servers: **jump** `time` to and release first `busy` server, and `assign` thereafter.\\n- On each `assign` at `time`, first release `busy` servers if just finished\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        auto cmp = [&servers](int i, int j) { return pair(servers[i],i) > pair(servers[j], j); };\\n        priority_queue<int,vector<int>, decltype(cmp)> free(cmp);\\n        for(int id = 0; id < servers.size(); ++id) \\n            free.push(id);\\n        \\n        queue<int> request;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> busy/*(finish time, id)*/;\\n        vector<int> ans;\\n        \\n        auto assign = [&busy, &free, &request, &servers,&ans] (int time) {\\n            while(!busy.empty() && busy.top().first == time) {\\n                int id = busy.top().second;\\n                free.push(id);\\n                busy.pop();\\n            }\\n\\n            while(!free.empty() && !request.empty()) {\\n                int id = free.top();\\n                ans.push_back(id);\\n                busy.emplace(time+ request.front(), id);\\n                free.pop();\\n                request.pop();\\n            }\\n        };\\n        for(int time = 0; time < tasks.size(); ++time) {\\n            request.push(tasks[time]);\\n            assign(time);\\n        }\\n        while(!request.empty()) { // come here only if no free servers, jump time to release first busy server\\n            assign(busy.top().first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        auto cmp = [&servers](int i, int j) { return pair(servers[i],i) > pair(servers[j], j); };\\n        priority_queue<int,vector<int>, decltype(cmp)> free(cmp);\\n        for(int id = 0; id < servers.size(); ++id) \\n            free.push(id);\\n        \\n        queue<int> request;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> busy/*(finish time, id)*/;\\n        vector<int> ans;\\n        \\n        auto assign = [&busy, &free, &request, &servers,&ans] (int time) {\\n            while(!busy.empty() && busy.top().first == time) {\\n                int id = busy.top().second;\\n                free.push(id);\\n                busy.pop();\\n            }\\n\\n            while(!free.empty() && !request.empty()) {\\n                int id = free.top();\\n                ans.push_back(id);\\n                busy.emplace(time+ request.front(), id);\\n                free.pop();\\n                request.pop();\\n            }\\n        };\\n        for(int time = 0; time < tasks.size(); ++time) {\\n            request.push(tasks[time]);\\n            assign(time);\\n        }\\n        while(!request.empty()) { // come here only if no free servers, jump time to release first busy server\\n            assign(busy.top().first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491088,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O((n_servers + n_tasks) * log(n_servers))\\n * Space Complexity: O(n_servers)\\n * where `n_servers` is the length of the vector `servers`\\n *       `n_tasks` is the length of the vector `tasks`\\n */\\nclass Solution {\\n public:\\n  vector<int> assignTasks(const vector<int> &servers, const vector<int> &tasks) {\\n    using pq_busy_servers_node = pair<int, int>;   // {the available time, the server index}\\n    const int n_servers = static_cast<int>(servers.size());\\n    const int n_tasks = static_cast<int>(tasks.size());\\n    auto compare_available_servers = [&servers](const int lhs, const int rhs) -> bool {\\n      return !(servers[lhs] < servers[rhs] || (servers[lhs] == servers[rhs] && lhs < rhs));\\n    };\\n    priority_queue<int, vector<int>, decltype(compare_available_servers)> pq_available_servers(compare_available_servers);\\n    priority_queue<pq_busy_servers_node, vector<pq_busy_servers_node>, greater<>> pq_busy_servers;\\n    for (int i_server = 0; i_server < n_servers; ++i_server) {\\n      pq_available_servers.emplace(i_server);\\n    }\\n    \\n    int current_time = numeric_limits<int>::min();\\n    vector<int> ret(n_tasks);\\n    for (int i_task = 0; i_task < n_tasks;) {\\n      if (current_time < i_task) {\\n        current_time = i_task;\\n      }\\n      \\n      while (!pq_busy_servers.empty() && pq_busy_servers.top().first <= current_time) {\\n        const auto [_, server_index] = pq_busy_servers.top();\\n        pq_busy_servers.pop();\\n        pq_available_servers.emplace(server_index);\\n      }\\n      \\n      if (pq_available_servers.empty()) {\\n        current_time = pq_busy_servers.top().first;\\n        continue;\\n      }\\n      \\n      const int server_index = pq_available_servers.top();\\n      pq_available_servers.pop();\\n      ret[i_task] = server_index;\\n      pq_busy_servers.emplace(current_time + tasks[i_task], server_index);\\n      ++i_task;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O((n_servers + n_tasks) * log(n_servers))\\n * Space Complexity: O(n_servers)\\n * where `n_servers` is the length of the vector `servers`\\n *       `n_tasks` is the length of the vector `tasks`\\n */\\nclass Solution {\\n public:\\n  vector<int> assignTasks(const vector<int> &servers, const vector<int> &tasks) {\\n    using pq_busy_servers_node = pair<int, int>;   // {the available time, the server index}\\n    const int n_servers = static_cast<int>(servers.size());\\n    const int n_tasks = static_cast<int>(tasks.size());\\n    auto compare_available_servers = [&servers](const int lhs, const int rhs) -> bool {\\n      return !(servers[lhs] < servers[rhs] || (servers[lhs] == servers[rhs] && lhs < rhs));\\n    };\\n    priority_queue<int, vector<int>, decltype(compare_available_servers)> pq_available_servers(compare_available_servers);\\n    priority_queue<pq_busy_servers_node, vector<pq_busy_servers_node>, greater<>> pq_busy_servers;\\n    for (int i_server = 0; i_server < n_servers; ++i_server) {\\n      pq_available_servers.emplace(i_server);\\n    }\\n    \\n    int current_time = numeric_limits<int>::min();\\n    vector<int> ret(n_tasks);\\n    for (int i_task = 0; i_task < n_tasks;) {\\n      if (current_time < i_task) {\\n        current_time = i_task;\\n      }\\n      \\n      while (!pq_busy_servers.empty() && pq_busy_servers.top().first <= current_time) {\\n        const auto [_, server_index] = pq_busy_servers.top();\\n        pq_busy_servers.pop();\\n        pq_available_servers.emplace(server_index);\\n      }\\n      \\n      if (pq_available_servers.empty()) {\\n        current_time = pq_busy_servers.top().first;\\n        continue;\\n      }\\n      \\n      const int server_index = pq_available_servers.top();\\n      pq_available_servers.pop();\\n      ret[i_task] = server_index;\\n      pq_busy_servers.emplace(current_time + tasks[i_task], server_index);\\n      ++i_task;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424329,
                "title": "java-multiple-iterator-2-heap",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> free=new PriorityQueue<>(10, (a,b)->{\\n            int cmp=a[1]-b[1];\\n            if(cmp==0){\\n                cmp=a[0]-b[0];\\n            }\\n            return cmp;\\n        });\\n        PriorityQueue<int[]> busy=new PriorityQueue<>(10, (a,b)->a[2]-b[2]);\\n        int n=servers.length;\\n        for(int i=0; i<n; i++){\\n            free.add(new int[]{i, servers[i], 0});\\n        }\\n        int m=tasks.length;//seconds\\n        int[] ans=new int[m];\\n        int taskIterator=0;\\n        for(int i=0; taskIterator<m; i++){\\n            while(!busy.isEmpty() && busy.peek()[2]<=i){\\n                int[] busyServer=busy.poll();\\n                busyServer[2]=0;\\n                free.add(busyServer);\\n            }\\n            while(taskIterator<m && taskIterator<i){\\n                if(!free.isEmpty()){\\n                    int[] freeServer=free.poll();\\n                    freeServer[2]=i+tasks[taskIterator];\\n                    busy.add(freeServer);\\n                    ans[taskIterator++]=freeServer[0];\\n                }else{\\n                    i=busy.peek()[2]-1;\\n                    break;\\n                }   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> free=new PriorityQueue<>(10, (a,b)->{\\n            int cmp=a[1]-b[1];\\n            if(cmp==0){\\n                cmp=a[0]-b[0];\\n            }\\n            return cmp;\\n        });\\n        PriorityQueue<int[]> busy=new PriorityQueue<>(10, (a,b)->a[2]-b[2]);\\n        int n=servers.length;\\n        for(int i=0; i<n; i++){\\n            free.add(new int[]{i, servers[i], 0});\\n        }\\n        int m=tasks.length;//seconds\\n        int[] ans=new int[m];\\n        int taskIterator=0;\\n        for(int i=0; taskIterator<m; i++){\\n            while(!busy.isEmpty() && busy.peek()[2]<=i){\\n                int[] busyServer=busy.poll();\\n                busyServer[2]=0;\\n                free.add(busyServer);\\n            }\\n            while(taskIterator<m && taskIterator<i){\\n                if(!free.isEmpty()){\\n                    int[] freeServer=free.poll();\\n                    freeServer[2]=i+tasks[taskIterator];\\n                    busy.add(freeServer);\\n                    ans[taskIterator++]=freeServer[0];\\n                }else{\\n                    i=busy.peek()[2]-1;\\n                    break;\\n                }   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260531,
                "title": "python-simple-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def assignTasks(self, servers, tasks):\\n        ans = []\\n\\n        free = [[weight,i,0] for i,weight in enumerate(servers)]\\n        busy = []\\n        heapq.heapify(free)\\n\\n        for j,task in enumerate(tasks):\\n            while busy and busy[0][0] <= j or not free:\\n                time, weight, i = heapq.heappop(busy)\\n                heapq.heappush(free,[weight,i,time])\\n\\n            weight,i,time = heapq.heappop(free)\\n            ans.append(i)\\n            heapq.heappush(busy,[max(time,j)+task,weight,i])\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers, tasks):\\n        ans = []\\n\\n        free = [[weight,i,0] for i,weight in enumerate(servers)]\\n        busy = []\\n        heapq.heapify(free)\\n\\n        for j,task in enumerate(tasks):\\n            while busy and busy[0][0] <= j or not free:\\n                time, weight, i = heapq.heappop(busy)\\n                heapq.heappush(free,[weight,i,time])\\n\\n            weight,i,time = heapq.heappop(free)\\n            ans.append(i)\\n            heapq.heappush(busy,[max(time,j)+task,weight,i])\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228539,
                "title": "minimum-heap-priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((m+n)log(n+n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m+n), 2 heaps\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        vector<int> ans(m, -1);\\n        auto comp = [](pair<int, int>& p1, pair<int, int>& p2) {\\n            if (p1.first != p2.first) {\\n                return p1.first > p2.first;\\n            }\\n            return p1.second > p2.second;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq1(comp);  // {weight, index}\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq2(comp);  // {avail_time, index}\\n        for (int i = 0; i < n; ++i) {\\n            pq1.push({servers[i], i});\\n        }\\n        int t = 0;\\n        int j = 0;\\n        while (j < m) {\\n            if (pq1.empty()) {\\n                t = pq2.top().first;  // skip waiting time\\n            }\\n            while (!pq2.empty() && pq2.top().first <= t) {\\n                pq1.push({servers[pq2.top().second], pq2.top().second});\\n                pq2.pop();\\n            }\\n            while (!pq1.empty() && j < m && j <= t) {\\n                pq2.push({t + tasks[j], pq1.top().second});\\n                ans[j] = pq1.top().second;\\n                pq1.pop();\\n                j++;\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        vector<int> ans(m, -1);\\n        auto comp = [](pair<int, int>& p1, pair<int, int>& p2) {\\n            if (p1.first != p2.first) {\\n                return p1.first > p2.first;\\n            }\\n            return p1.second > p2.second;\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq1(comp);  // {weight, index}\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq2(comp);  // {avail_time, index}\\n        for (int i = 0; i < n; ++i) {\\n            pq1.push({servers[i], i});\\n        }\\n        int t = 0;\\n        int j = 0;\\n        while (j < m) {\\n            if (pq1.empty()) {\\n                t = pq2.top().first;  // skip waiting time\\n            }\\n            while (!pq2.empty() && pq2.top().first <= t) {\\n                pq1.push({servers[pq2.top().second], pq2.top().second});\\n                pq2.pop();\\n            }\\n            while (!pq1.empty() && j < m && j <= t) {\\n                pq2.push({t + tasks[j], pq1.top().second});\\n                ans[j] = pq1.top().second;\\n                pq1.pop();\\n                j++;\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227996,
                "title": "just-give-newbies-a-chance-to-see-the-other-solutions",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn assign_tasks(servers: Vec<i32>, tasks: Vec<i32>) -> Vec<i32> {\\n        let mut q = std::collections::BTreeSet::<(i32, i32, i32)>::new();\\n        let mut avail = std::collections::BTreeSet::new();\\n        let mut res = vec![-1; tasks.len()];\\n        for (i, &server) in servers.iter().enumerate() {\\n            avail.insert((server, i as i32));\\n        }\\n        let mut i = 0;\\n        let mut t = 0;\\n        while i < tasks.len() as i32 {\\n            t = t.max(i);\\n            while !q.is_empty() && q.iter().next().unwrap().0 <= t {\\n                let v = *q.iter().next().unwrap();\\n                q.remove(&v);\\n                let &(_, ind, index) = &v;\\n                avail.insert((servers[ind as usize], ind));\\n                res[index as usize] = ind;\\n            }\\n            if !avail.is_empty() {\\n                let &(server, ind) = avail.iter().next().unwrap();\\n                q.insert((t + tasks[i as usize], ind, i as i32));\\n                avail.remove(&(server, ind));\\n            } else {\\n                t = q.iter().next().unwrap().0;\\n                i -= 1;\\n            }\\n            i += 1;\\n        }\\n        while !q.is_empty() {\\n            let v = *q.iter().next().unwrap();\\n            q.remove(&v);\\n            let &(_, ind, index) = &v;\\n            res[index as usize] = ind;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn assign_tasks(servers: Vec<i32>, tasks: Vec<i32>) -> Vec<i32> {\\n        let mut q = std::collections::BTreeSet::<(i32, i32, i32)>::new();\\n        let mut avail = std::collections::BTreeSet::new();\\n        let mut res = vec![-1; tasks.len()];\\n        for (i, &server) in servers.iter().enumerate() {\\n            avail.insert((server, i as i32));\\n        }\\n        let mut i = 0;\\n        let mut t = 0;\\n        while i < tasks.len() as i32 {\\n            t = t.max(i);\\n            while !q.is_empty() && q.iter().next().unwrap().0 <= t {\\n                let v = *q.iter().next().unwrap();\\n                q.remove(&v);\\n                let &(_, ind, index) = &v;\\n                avail.insert((servers[ind as usize], ind));\\n                res[index as usize] = ind;\\n            }\\n            if !avail.is_empty() {\\n                let &(server, ind) = avail.iter().next().unwrap();\\n                q.insert((t + tasks[i as usize], ind, i as i32));\\n                avail.remove(&(server, ind));\\n            } else {\\n                t = q.iter().next().unwrap().0;\\n                i -= 1;\\n            }\\n            i += 1;\\n        }\\n        while !q.is_empty() {\\n            let v = *q.iter().next().unwrap();\\n            q.remove(&v);\\n            let &(_, ind, index) = &v;\\n            res[index as usize] = ind;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212868,
                "title": "2-priority-queues-java",
                "content": "```\\nclass Solution {\\n    class FreeServer{\\n        public int serverIdx;\\n        public int serverWeight;\\n        public FreeServer(int serverIdx,int serverWeight){\\n            this.serverIdx=serverIdx;\\n            this.serverWeight=serverWeight;\\n        }\\n    }\\n    class ServerTime{\\n        public int serverIdx;\\n        public int endTime;\\n        public ServerTime(int serverIdx,int endTime){\\n            this.serverIdx=serverIdx;\\n            this.endTime=endTime;\\n        }\\n    }\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int n=tasks.length;\\n        int [] ans = new int[n];\\n        PriorityQueue<ServerTime> pqServerTime= new PriorityQueue<>((s1,s2)->Integer.compare(s1.endTime,s2.endTime));\\n        PriorityQueue<FreeServer> pqFreeServer=new PriorityQueue<>((s1,s2)->{\\n            if(s1.serverWeight!=s2.serverWeight)\\n                return Integer.compare(s1.serverWeight,s2.serverWeight);\\n            else\\n                return Integer.compare(s1.serverIdx,s2.serverIdx);\\n        });\\n        \\n\\n        for(int i=0;i<servers.length;i++)\\n            pqFreeServer.add(new FreeServer(i,servers[i]));\\n        \\n        int ctime=0;\\n        int lp=0;\\n\\n        while(lp!=tasks.length){\\n            while(pqServerTime.size()!=0 && pqServerTime.peek().endTime<=ctime){\\n               ServerTime tmp= pqServerTime.remove();\\n               int serverWeight = servers[tmp.serverIdx];\\n               pqFreeServer.add(new FreeServer(tmp.serverIdx,serverWeight));\\n            }\\n            if(pqFreeServer.size()==0){\\n                  ctime=pqServerTime.peek().endTime;\\n                  continue;\\n            }\\n            FreeServer fs=pqFreeServer.remove();\\n            ans[lp]=fs.serverIdx;\\n            pqServerTime.add(new ServerTime(ans[lp],ctime+tasks[lp]));\\n            lp++;\\n            ctime=Integer.max(ctime,lp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class FreeServer{\\n        public int serverIdx;\\n        public int serverWeight;\\n        public FreeServer(int serverIdx,int serverWeight){\\n            this.serverIdx=serverIdx;\\n            this.serverWeight=serverWeight;\\n        }\\n    }\\n    class ServerTime{\\n        public int serverIdx;\\n        public int endTime;\\n        public ServerTime(int serverIdx,int endTime){\\n            this.serverIdx=serverIdx;\\n            this.endTime=endTime;\\n        }\\n    }\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int n=tasks.length;\\n        int [] ans = new int[n];\\n        PriorityQueue<ServerTime> pqServerTime= new PriorityQueue<>((s1,s2)->Integer.compare(s1.endTime,s2.endTime));\\n        PriorityQueue<FreeServer> pqFreeServer=new PriorityQueue<>((s1,s2)->{\\n            if(s1.serverWeight!=s2.serverWeight)\\n                return Integer.compare(s1.serverWeight,s2.serverWeight);\\n            else\\n                return Integer.compare(s1.serverIdx,s2.serverIdx);\\n        });\\n        \\n\\n        for(int i=0;i<servers.length;i++)\\n            pqFreeServer.add(new FreeServer(i,servers[i]));\\n        \\n        int ctime=0;\\n        int lp=0;\\n\\n        while(lp!=tasks.length){\\n            while(pqServerTime.size()!=0 && pqServerTime.peek().endTime<=ctime){\\n               ServerTime tmp= pqServerTime.remove();\\n               int serverWeight = servers[tmp.serverIdx];\\n               pqFreeServer.add(new FreeServer(tmp.serverIdx,serverWeight));\\n            }\\n            if(pqFreeServer.size()==0){\\n                  ctime=pqServerTime.peek().endTime;\\n                  continue;\\n            }\\n            FreeServer fs=pqFreeServer.remove();\\n            ans[lp]=fs.serverIdx;\\n            pqServerTime.add(new ServerTime(ans[lp],ctime+tasks[lp]));\\n            lp++;\\n            ctime=Integer.max(ctime,lp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211738,
                "title": "java-solution-using-priorityqueue",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogM)\\n\\n- Space complexity:\\nO(M)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // int[0] = weight, int[1] = index.\\n        PriorityQueue<int[]> ava = new PriorityQueue<>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            } else {\\n                return a[0] - b[0];\\n            }\\n        });\\n        // int[0] = available time, int[1] = index.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        for (int i = 0; i < servers.length; i++) {\\n            ava.offer(new int[]{servers[i], i});\\n        }\\n\\n        int[] res = new int[tasks.length];\\n        int index = 0, time = 0;\\n        while (index < tasks.length) {\\n            while (!pq.isEmpty() && pq.peek()[0] <= time) {\\n                int[] s = pq.poll();\\n                ava.offer(new int[]{servers[s[1]], s[1]});\\n            }\\n            boolean pick = false;\\n            while (!ava.isEmpty() && index < time && index < tasks.length) {\\n                int[] cur = ava.poll();\\n                pq.offer(new int[]{time + tasks[index], cur[1]});\\n                res[index++] = cur[1];\\n                pick = true;\\n            }\\n            if (!pick && !pq.isEmpty()) {\\n                time = pq.peek()[0];\\n            } else {\\n                time++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        // int[0] = weight, int[1] = index.\\n        PriorityQueue<int[]> ava = new PriorityQueue<>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return a[1] - b[1];\\n            } else {\\n                return a[0] - b[0];\\n            }\\n        });\\n        // int[0] = available time, int[1] = index.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        for (int i = 0; i < servers.length; i++) {\\n            ava.offer(new int[]{servers[i], i});\\n        }\\n\\n        int[] res = new int[tasks.length];\\n        int index = 0, time = 0;\\n        while (index < tasks.length) {\\n            while (!pq.isEmpty() && pq.peek()[0] <= time) {\\n                int[] s = pq.poll();\\n                ava.offer(new int[]{servers[s[1]], s[1]});\\n            }\\n            boolean pick = false;\\n            while (!ava.isEmpty() && index < time && index < tasks.length) {\\n                int[] cur = ava.poll();\\n                pq.offer(new int[]{time + tasks[index], cur[1]});\\n                res[index++] = cur[1];\\n                pick = true;\\n            }\\n            if (!pick && !pq.isEmpty()) {\\n                time = pq.peek()[0];\\n            } else {\\n                time++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139371,
                "title": "1320-ms",
                "content": "`Containers::CArrHeap` missing.\\n```ruby\\ndef assign_tasks s, t\\n    f = CRBTreeMap.new\\n    b = CRBTreeMap.new\\n    s.each_with_index { f[(_1 << 20) | _2] = 1 }\\n    r, j, z = [], 0, t.size\\n    l = (1 << 20) - 1\\n    while j < z\\n        x = f.empty? && (m = b.min_key >> 20) > j ? m : j\\n        while (k = b.min_key) && (k >> 20) <= x\\n            b.delete_min\\n            i = k & l\\n            f[(s[i] << 20) | i] = 1\\n        end\\n        while !f.empty? && j < z && j <= x\\n            i = f.min_key & l\\n            f.delete_min\\n            b[((x + t[j]) << 20) | i] = 1\\n            r << i\\n            j += 1\\n        end\\n    end\\n    r\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef assign_tasks s, t\\n    f = CRBTreeMap.new\\n    b = CRBTreeMap.new\\n    s.each_with_index { f[(_1 << 20) | _2] = 1 }\\n    r, j, z = [], 0, t.size\\n    l = (1 << 20) - 1\\n    while j < z\\n        x = f.empty? && (m = b.min_key >> 20) > j ? m : j\\n        while (k = b.min_key) && (k >> 20) <= x\\n            b.delete_min\\n            i = k & l\\n            f[(s[i] << 20) | i] = 1\\n        end\\n        while !f.empty? && j < z && j <= x\\n            i = f.min_key & l\\n            f.delete_min\\n            b[((x + t[j]) << 20) | i] = 1\\n            r << i\\n            j += 1\\n        end\\n    end\\n    r\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3136102,
                "title": "java-heap",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int[] res = new int[tasks.length];\\n        PriorityQueue<int[]> occupied  = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n        PriorityQueue<Integer> avail = new PriorityQueue<>((a,b) -> {\\n            if(servers[a] == servers[b])\\n                return a-b;\\n            return servers[a] - servers[b];\\n        });\\n        for (int i = 0; i < servers.length; i++)\\n            avail.offer(i);\\n\\n        for (int time = 0; time < tasks.length; time++){\\n            int currTime = time;\\n            while (!occupied.isEmpty() && occupied.peek()[1] <= currTime){\\n                int[] server = occupied.poll();\\n                int idx = server[0];\\n                avail.offer(idx);\\n            }\\n            if(avail.size() > 0){\\n                int currServerIndex = avail.poll();\\n                occupied.offer(new int[]{currServerIndex, time+ tasks[time]});\\n                res[time] = currServerIndex;\\n            }else{\\n                int[] occupiedServer = occupied.poll();\\n                occupied.offer(new int[]{occupiedServer[0], (occupiedServer[1]-time)+ tasks[time]});\\n                res[time] = occupiedServer[0];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int[] res = new int[tasks.length];\\n        PriorityQueue<int[]> occupied  = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n        PriorityQueue<Integer> avail = new PriorityQueue<>((a,b) -> {\\n            if(servers[a] == servers[b])\\n                return a-b;\\n            return servers[a] - servers[b];\\n        });\\n        for (int i = 0; i < servers.length; i++)\\n            avail.offer(i);\\n\\n        for (int time = 0; time < tasks.length; time++){\\n            int currTime = time;\\n            while (!occupied.isEmpty() && occupied.peek()[1] <= currTime){\\n                int[] server = occupied.poll();\\n                int idx = server[0];\\n                avail.offer(idx);\\n            }\\n            if(avail.size() > 0){\\n                int currServerIndex = avail.poll();\\n                occupied.offer(new int[]{currServerIndex, time+ tasks[time]});\\n                res[time] = currServerIndex;\\n            }else{\\n                int[] occupiedServer = occupied.poll();\\n                occupied.offer(new int[]{occupiedServer[0], (occupiedServer[1]-time)+ tasks[time]});\\n                res[time] = occupiedServer[0];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134215,
                "title": "java-solution-with-two-priority-queues",
                "content": "\\n- Time complexity:\\n    O(total time to complete all tasks)\\n\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    class Server{\\n\\n        int weight;\\n        int ind;\\n        int orderOfInsertion;\\n\\n        public Server(int weight, int ind){\\n            this.weight = weight;\\n            this.ind = ind;\\n        }\\n\\n\\n    }\\n\\n    class Task{\\n\\n        Server s;\\n        int timeStart;\\n        int duration;\\n        int ind;\\n\\n        public Task(Server s, int start, int duration, int ind){\\n            this.s = s;\\n            this.timeStart = start;\\n            this.duration = duration;\\n            this.ind = ind;\\n        }\\n\\n    }\\n\\n    class ServerComparator1 implements Comparator<Server>{\\n\\n        public int compare(Server s1, Server s2){\\n\\n            if(s1.weight == s2.weight) return s1.ind - s2.ind;\\n            return s1.weight - s2.weight;\\n\\n        }\\n\\n\\n    }\\n\\n    class TaskComparator implements Comparator<Task>{\\n\\n        public int compare(Task t1, Task t2){\\n\\n            if(t1.timeStart + t1.duration == t2.timeStart + t2.duration){\\n                return t1.ind - t2.ind;\\n            }\\n\\n            return (t1.timeStart + t1.duration) - (t2.timeStart + t2.duration);\\n\\n\\n        }\\n\\n    }\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n\\n        int[] ans = new int[tasks.length];\\n        PriorityQueue<Server> pq = new PriorityQueue<Server>( new ServerComparator1());\\n        PriorityQueue<Task> taskQ = new PriorityQueue(new TaskComparator());\\n        int taskInd = 0;\\n        int seconds = 0;\\n\\n        for(int i = 0; i < servers.length; i++){\\n            pq.offer(new Server(servers[i], i));\\n        }\\n\\n        while(taskInd < tasks.length){           \\n\\n            while(!taskQ.isEmpty() && taskQ.peek().timeStart + taskQ.peek().duration <= seconds){\\n                // System.out.println(\"========removing tasks==========\");\\n                // System.out.println(taskQ.peek() + \" Time:\" + seconds);\\n                Task t = taskQ.poll();\\n                pq.offer(t.s);\\n            }\\n\\n            if(pq.isEmpty()){\\n                seconds = taskQ.peek().timeStart + taskQ.peek().duration;\\n                continue;\\n            }\\n\\n            while(!pq.isEmpty() && taskInd < seconds && taskInd < tasks.length){\\n                // System.out.println(\"========add tasks==========\");\\n                Server s = pq.poll();\\n                Task t = new Task(s, seconds, tasks[taskInd], taskInd);\\n                // System.out.println(t + \" Time:\" + seconds);\\n\\n                taskQ.offer(t);\\n                ans[taskInd] = s.ind;\\n                taskInd++;\\n            }\\n\\n            seconds++;\\n\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    class Server{\\n\\n        int weight;\\n        int ind;\\n        int orderOfInsertion;\\n\\n        public Server(int weight, int ind){\\n            this.weight = weight;\\n            this.ind = ind;\\n        }\\n\\n\\n    }\\n\\n    class Task{\\n\\n        Server s;\\n        int timeStart;\\n        int duration;\\n        int ind;\\n\\n        public Task(Server s, int start, int duration, int ind){\\n            this.s = s;\\n            this.timeStart = start;\\n            this.duration = duration;\\n            this.ind = ind;\\n        }\\n\\n    }\\n\\n    class ServerComparator1 implements Comparator<Server>{\\n\\n        public int compare(Server s1, Server s2){\\n\\n            if(s1.weight == s2.weight) return s1.ind - s2.ind;\\n            return s1.weight - s2.weight;\\n\\n        }\\n\\n\\n    }\\n\\n    class TaskComparator implements Comparator<Task>{\\n\\n        public int compare(Task t1, Task t2){\\n\\n            if(t1.timeStart + t1.duration == t2.timeStart + t2.duration){\\n                return t1.ind - t2.ind;\\n            }\\n\\n            return (t1.timeStart + t1.duration) - (t2.timeStart + t2.duration);\\n\\n\\n        }\\n\\n    }\\n\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n\\n        int[] ans = new int[tasks.length];\\n        PriorityQueue<Server> pq = new PriorityQueue<Server>( new ServerComparator1());\\n        PriorityQueue<Task> taskQ = new PriorityQueue(new TaskComparator());\\n        int taskInd = 0;\\n        int seconds = 0;\\n\\n        for(int i = 0; i < servers.length; i++){\\n            pq.offer(new Server(servers[i], i));\\n        }\\n\\n        while(taskInd < tasks.length){           \\n\\n            while(!taskQ.isEmpty() && taskQ.peek().timeStart + taskQ.peek().duration <= seconds){\\n                // System.out.println(\"========removing tasks==========\");\\n                // System.out.println(taskQ.peek() + \" Time:\" + seconds);\\n                Task t = taskQ.poll();\\n                pq.offer(t.s);\\n            }\\n\\n            if(pq.isEmpty()){\\n                seconds = taskQ.peek().timeStart + taskQ.peek().duration;\\n                continue;\\n            }\\n\\n            while(!pq.isEmpty() && taskInd < seconds && taskInd < tasks.length){\\n                // System.out.println(\"========add tasks==========\");\\n                Server s = pq.poll();\\n                Task t = new Task(s, seconds, tasks[taskInd], taskInd);\\n                // System.out.println(t + \" Time:\" + seconds);\\n\\n                taskQ.offer(t);\\n                ans[taskInd] = s.ind;\\n                taskInd++;\\n            }\\n\\n            seconds++;\\n\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104050,
                "title": "c-two-maps-used-like-heap-and-list-used-similar-to-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        vector<int> res(m, 0);\\n        list<int> avail_task{};\\n        map<int, set<int>> free_servers{}; // weight : set of server indicies\\n        map<int, vector<int>> busy_servers{}; // next_free_time : set of server indicies\\n        for (int j = 0; j < n; j++) // place all servers as free\\n        {\\n            free_servers[servers[j]].emplace(j); \\n        }\\n        \\n        for(int i = 0; i < m; i++) \\n        {\\n            if (i < m) { avail_task.emplace_back(i); }\\n\\n            if (busy_servers.count(i) > 0)\\n            {\\n                for (const int _j : busy_servers[i])\\n                {\\n                    free_servers[servers[_j]].emplace(_j);\\n                }\\n                busy_servers.erase(i);\\n            }\\n\\n            while (!avail_task.empty() && !free_servers.empty())\\n            {\\n                int i_next = avail_task.front(); avail_task.pop_front();\\n                int j = *(free_servers.begin()->second.begin());\\n                decrement_free(free_servers, free_servers.begin()->first, j);\\n                res[i_next] = j;\\n                int next_free_time = i + tasks[i_next];\\n                busy_servers[next_free_time].emplace_back(j);\\n            }\\n        }\\n \\n        while (!avail_task.empty())\\n        {\\n            int t = busy_servers.begin()->first;\\n            for (const int _j : busy_servers[t])\\n            {\\n                free_servers[servers[_j]].emplace(_j);\\n            }\\n            busy_servers.erase(t);\\n            while (!free_servers.empty() && !avail_task.empty())\\n            {\\n                int i_next = avail_task.front(); avail_task.pop_front();\\n                int j = *(free_servers.begin()->second.begin());\\n                decrement_free(free_servers, free_servers.begin()->first, j);\\n                res[i_next] = j;\\n                int next_free_time = t + tasks[i_next];\\n                busy_servers[next_free_time].emplace_back(j);\\n            }\\n        }\\n\\n        return res;\\n    }\\nprivate:\\n    void decrement_free(map<int, set<int>>& free_servers, int weight, int i)\\n    {\\n        if (free_servers[weight].size() == 1) { free_servers.erase(weight); }\\n        else \\n        {\\n            free_servers[weight].erase(i);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size();\\n        int m = tasks.size();\\n        vector<int> res(m, 0);\\n        list<int> avail_task{};\\n        map<int, set<int>> free_servers{}; // weight : set of server indicies\\n        map<int, vector<int>> busy_servers{}; // next_free_time : set of server indicies\\n        for (int j = 0; j < n; j++) // place all servers as free\\n        {\\n            free_servers[servers[j]].emplace(j); \\n        }\\n        \\n        for(int i = 0; i < m; i++) \\n        {\\n            if (i < m) { avail_task.emplace_back(i); }\\n\\n            if (busy_servers.count(i) > 0)\\n            {\\n                for (const int _j : busy_servers[i])\\n                {\\n                    free_servers[servers[_j]].emplace(_j);\\n                }\\n                busy_servers.erase(i);\\n            }\\n\\n            while (!avail_task.empty() && !free_servers.empty())\\n            {\\n                int i_next = avail_task.front(); avail_task.pop_front();\\n                int j = *(free_servers.begin()->second.begin());\\n                decrement_free(free_servers, free_servers.begin()->first, j);\\n                res[i_next] = j;\\n                int next_free_time = i + tasks[i_next];\\n                busy_servers[next_free_time].emplace_back(j);\\n            }\\n        }\\n \\n        while (!avail_task.empty())\\n        {\\n            int t = busy_servers.begin()->first;\\n            for (const int _j : busy_servers[t])\\n            {\\n                free_servers[servers[_j]].emplace(_j);\\n            }\\n            busy_servers.erase(t);\\n            while (!free_servers.empty() && !avail_task.empty())\\n            {\\n                int i_next = avail_task.front(); avail_task.pop_front();\\n                int j = *(free_servers.begin()->second.begin());\\n                decrement_free(free_servers, free_servers.begin()->first, j);\\n                res[i_next] = j;\\n                int next_free_time = t + tasks[i_next];\\n                busy_servers[next_free_time].emplace_back(j);\\n            }\\n        }\\n\\n        return res;\\n    }\\nprivate:\\n    void decrement_free(map<int, set<int>>& free_servers, int weight, int i)\\n    {\\n        if (free_servers[weight].size() == 1) { free_servers.erase(weight); }\\n        else \\n        {\\n            free_servers[weight].erase(i);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067042,
                "title": "go-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\n// Heap\\ntype MyHeap [][2]int\\n\\nfunc (h MyHeap) Len() int { return len(h) }\\nfunc (h MyHeap) Less(i, j int) bool {\\n\\tif h[i][0] == h[j][0] {\\n\\t\\treturn h[i][1] < h[j][1]\\n\\t} else {\\n\\t\\treturn h[i][0] < h[j][0]\\n\\t}\\n}\\nfunc (h MyHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MyHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.([2]int))\\n}\\n\\nfunc (h *MyHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc (h MyHeap) Top() interface{} {\\n\\treturn h[0]\\n}\\nfunc assignTasks(servers []int, tasks []int) []int {\\n\\tmTask := map[int]int{}\\n\\tres := []int{}\\n\\n\\treadyH := &MyHeap{}\\n\\trunningH := &MyHeap{}\\n\\n\\tfor i := 0; i < len(servers); i++ {\\n\\t\\tmTask[i] = servers[i]\\n\\t\\theap.Push(readyH, [2]int{servers[i], i})\\n\\t}\\n\\n\\ti, time := 0, 0\\n\\n\\tfor runningH.Len() > 0 || i < len(tasks) {\\n\\t\\t// utilize resource when process is done\\n\\t\\tfor runningH.Len() > 0 && runningH.Top().([2]int)[0] <= time {\\n\\t\\t\\ttop := heap.Pop(runningH).([2]int)\\n\\t\\t\\theap.Push(readyH, [2]int{mTask[top[1]], top[1]})\\n\\t\\t\\ttime = top[0]\\n\\t\\t}\\n\\n\\t\\t// assigned task to servers\\n\\t\\tfor readyH.Len() > 0 && i < len(tasks) && time >= i {\\n\\t\\t\\tassignedSvr := heap.Pop(readyH).([2]int)\\n\\t\\t\\tres = append(res, assignedSvr[1])\\n\\t\\t\\theap.Push(runningH, [2]int{time + tasks[i], assignedSvr[1]})\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\t// increase timer\\n\\t\\tif readyH.Len() == 0 && runningH.Len() > 0 {\\n\\t\\t\\ttime = runningH.Top().([2]int)[0]\\n\\t\\t} else {\\n\\t\\t\\ttime++\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\n// Heap\\ntype MyHeap [][2]int\\n\\nfunc (h MyHeap) Len() int { return len(h) }\\nfunc (h MyHeap) Less(i, j int) bool {\\n\\tif h[i][0] == h[j][0] {\\n\\t\\treturn h[i][1] < h[j][1]\\n\\t} else {\\n\\t\\treturn h[i][0] < h[j][0]\\n\\t}\\n}\\nfunc (h MyHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MyHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.([2]int))\\n}\\n\\nfunc (h *MyHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc (h MyHeap) Top() interface{} {\\n\\treturn h[0]\\n}\\nfunc assignTasks(servers []int, tasks []int) []int {\\n\\tmTask := map[int]int{}\\n\\tres := []int{}\\n\\n\\treadyH := &MyHeap{}\\n\\trunningH := &MyHeap{}\\n\\n\\tfor i := 0; i < len(servers); i++ {\\n\\t\\tmTask[i] = servers[i]\\n\\t\\theap.Push(readyH, [2]int{servers[i], i})\\n\\t}\\n\\n\\ti, time := 0, 0\\n\\n\\tfor runningH.Len() > 0 || i < len(tasks) {\\n\\t\\t// utilize resource when process is done\\n\\t\\tfor runningH.Len() > 0 && runningH.Top().([2]int)[0] <= time {\\n\\t\\t\\ttop := heap.Pop(runningH).([2]int)\\n\\t\\t\\theap.Push(readyH, [2]int{mTask[top[1]], top[1]})\\n\\t\\t\\ttime = top[0]\\n\\t\\t}\\n\\n\\t\\t// assigned task to servers\\n\\t\\tfor readyH.Len() > 0 && i < len(tasks) && time >= i {\\n\\t\\t\\tassignedSvr := heap.Pop(readyH).([2]int)\\n\\t\\t\\tres = append(res, assignedSvr[1])\\n\\t\\t\\theap.Push(runningH, [2]int{time + tasks[i], assignedSvr[1]})\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\t// increase timer\\n\\t\\tif readyH.Len() == 0 && runningH.Len() > 0 {\\n\\t\\t\\ttime = runningH.Top().([2]int)[0]\\n\\t\\t} else {\\n\\t\\t\\ttime++\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3066771,
                "title": "2-heaps-queue-c-simulation-easy",
                "content": "Queue can be discarded we can use pointer variable pointing to first uncompleted tasks \\n\\n\\n# Code\\n```\\n#define pq priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> \\n#define mk make_pair \\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        pq workingServers , freeServers ;\\n\\n        queue<int> waiting ; \\n\\n        vector<int> temp(servers.size(),-1),ans(tasks.size());\\n\\n        for(int i=0;i<servers.size();i++)  freeServers.push(mk(servers[i],i));\\n\\n        int time =0 ,iter =0 ;\\n\\n        while( time<tasks.size() || !waiting.empty() ){\\n            \\n            // fast forward time  \\n            if(time>=tasks.size()) time = workingServers.top().first ;\\n\\n            // remove idle server from free servers \\n            while(!workingServers.empty() && workingServers.top().first==time) {\\n                \\n                pair<int,int> top = workingServers.top();\\n\\n                freeServers.push(mk( servers[top.second], top.second ));\\n\\n                workingServers.pop();\\n            }\\n            // push it to queue \\n            if(iter<tasks.size()) waiting.push(iter++);\\n\\n            // see if any servers are free and assign to unfinieshed  tasks!\\n\\n            while(!freeServers.empty() && !waiting.empty()  ){\\n               \\n                int taskNo = waiting.front();  waiting.pop();\\n              \\n                int allotedServer = freeServers.top().second ; freeServers.pop();\\n                \\n                ans[taskNo] = allotedServer;\\n\\n                workingServers.push(mk( time+tasks[taskNo] ,allotedServer ));\\n\\n            }\\n            time++ ;\\n\\n        }\\n\\n\\n        return ans ;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pq priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> \\n#define mk make_pair \\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        pq workingServers , freeServers ;\\n\\n        queue<int> waiting ; \\n\\n        vector<int> temp(servers.size(),-1),ans(tasks.size());\\n\\n        for(int i=0;i<servers.size();i++)  freeServers.push(mk(servers[i],i));\\n\\n        int time =0 ,iter =0 ;\\n\\n        while( time<tasks.size() || !waiting.empty() ){\\n            \\n            // fast forward time  \\n            if(time>=tasks.size()) time = workingServers.top().first ;\\n\\n            // remove idle server from free servers \\n            while(!workingServers.empty() && workingServers.top().first==time) {\\n                \\n                pair<int,int> top = workingServers.top();\\n\\n                freeServers.push(mk( servers[top.second], top.second ));\\n\\n                workingServers.pop();\\n            }\\n            // push it to queue \\n            if(iter<tasks.size()) waiting.push(iter++);\\n\\n            // see if any servers are free and assign to unfinieshed  tasks!\\n\\n            while(!freeServers.empty() && !waiting.empty()  ){\\n               \\n                int taskNo = waiting.front();  waiting.pop();\\n              \\n                int allotedServer = freeServers.top().second ; freeServers.pop();\\n                \\n                ans[taskNo] = allotedServer;\\n\\n                workingServers.push(mk( time+tasks[taskNo] ,allotedServer ));\\n\\n            }\\n            time++ ;\\n\\n        }\\n\\n\\n        return ans ;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037035,
                "title": "c-two-heaps-commented-tried-to-explain-each-step",
                "content": "```\\n#define vi vector<int>\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        auto compare1 = [](auto &p1, auto &p2) {\\n            if(p1[0] == p2[0])\\n                return p1[1] > p2[1];\\n            else\\n                return p1[0] > p2[0];\\n        };\\n        \\n        auto compare2 = [](auto &p1, auto &p2) {\\n            return p1[2] > p2[2];\\n        };\\n        \\n        // Sorted on the basis of server weight first and on the basis of index second\\n        // pq -> {server_weight, server_idx}\\n        \\n        priority_queue<vi, vector<vi>, decltype(compare1)> available(compare1);\\n        \\n        // sorted on the basis of endTimeOfCompletionOfTask\\n        \\n        // pq -> {server_weight, server_idx, endTimeOfCompletionOfTask}\\n        priority_queue<vi, vector<vi>, decltype(compare2)> notAvailable(compare2);\\n        \\n        for(int i=0; i<servers.size(); i++) {\\n            available.push({servers[i], i});\\n        }\\n        \\n        vector<int> res;\\n        int time = 0;\\n        \\n        for(int i=0; i<tasks.size(); i++) {\\n            \\n            // It might be possible that time value becomes greater than i in the case\\n            // when no server is available\\n            time = max(time, i);\\n            \\n            // If no server is available then we just fast forward the time to the \\n            // completion time of the first non available server\\n            \\n            if(available.size() == 0) {\\n                time = notAvailable.top()[2];\\n            }\\n            \\n            // If at this current instance of time there are servers which need to be \\n            // pushed again into the available if they are completed do it\\n            while(notAvailable.size() != 0 and notAvailable.top()[2] <= time) {\\n                auto t = notAvailable.top();\\n                notAvailable.pop();\\n                available.push({t[0], t[1]});\\n            }\\n            \\n            // Finally assign the task the server for processing\\n            if(available.size() != 0) {\\n                auto t = available.top();\\n                available.pop();\\n                res.push_back(t[1]);\\n                notAvailable.push({t[0], t[1], time + tasks[i]});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define vi vector<int>\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        auto compare1 = [](auto &p1, auto &p2) {\\n            if(p1[0] == p2[0])\\n                return p1[1] > p2[1];\\n            else\\n                return p1[0] > p2[0];\\n        };\\n        \\n        auto compare2 = [](auto &p1, auto &p2) {\\n            return p1[2] > p2[2];\\n        };\\n        \\n        // Sorted on the basis of server weight first and on the basis of index second\\n        // pq -> {server_weight, server_idx}\\n        \\n        priority_queue<vi, vector<vi>, decltype(compare1)> available(compare1);\\n        \\n        // sorted on the basis of endTimeOfCompletionOfTask\\n        \\n        // pq -> {server_weight, server_idx, endTimeOfCompletionOfTask}\\n        priority_queue<vi, vector<vi>, decltype(compare2)> notAvailable(compare2);\\n        \\n        for(int i=0; i<servers.size(); i++) {\\n            available.push({servers[i], i});\\n        }\\n        \\n        vector<int> res;\\n        int time = 0;\\n        \\n        for(int i=0; i<tasks.size(); i++) {\\n            \\n            // It might be possible that time value becomes greater than i in the case\\n            // when no server is available\\n            time = max(time, i);\\n            \\n            // If no server is available then we just fast forward the time to the \\n            // completion time of the first non available server\\n            \\n            if(available.size() == 0) {\\n                time = notAvailable.top()[2];\\n            }\\n            \\n            // If at this current instance of time there are servers which need to be \\n            // pushed again into the available if they are completed do it\\n            while(notAvailable.size() != 0 and notAvailable.top()[2] <= time) {\\n                auto t = notAvailable.top();\\n                notAvailable.pop();\\n                available.push({t[0], t[1]});\\n            }\\n            \\n            // Finally assign the task the server for processing\\n            if(available.size() != 0) {\\n                auto t = available.top();\\n                available.pop();\\n                res.push_back(t[1]);\\n                notAvailable.push({t[0], t[1], time + tasks[i]});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004842,
                "title": "python-two-minheap-solution",
                "content": "```\\ndef assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\tans, q0, q = [], [[w, i, 0] for i, w in enumerate(servers)], []\\n\\theapify(q0)\\n\\t# q:[endtime, weight, idx], q0:[weight, idx, endtime]\\n\\tfor i, t in enumerate(tasks):\\n\\t\\twhile(not q0 or q and q[0][0]<=i):\\n\\t\\t\\tte, w, idx = heappop(q)\\n\\t\\t\\theappush(q0, [w, idx, te])\\n\\t\\tw, idx, te = heappop(q0)\\n\\t\\theappush(q, [max(te, i)+t, w, idx])\\n\\t\\tans.append(idx)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\tans, q0, q = [], [[w, i, 0] for i, w in enumerate(servers)], []\\n\\theapify(q0)\\n\\t# q:[endtime, weight, idx], q0:[weight, idx, endtime]\\n\\tfor i, t in enumerate(tasks):\\n\\t\\twhile(not q0 or q and q[0][0]<=i):\\n\\t\\t\\tte, w, idx = heappop(q)\\n\\t\\t\\theappush(q0, [w, idx, te])\\n\\t\\tw, idx, te = heappop(q0)\\n\\t\\theappush(q, [max(te, i)+t, w, idx])\\n\\t\\tans.append(idx)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2985924,
                "title": "clean-python-solution-beats-98",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogm) where n = length of tasks and m = length of servers\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(max(m, n))\\n# Code\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \"\"\"\\n        - Task inserted in queue in order of arrival\\n        - Task in the queue is assigned to free server with the smallest with smallest weight(if tie\\n        add to server with smaller index)\\n\\n        \"\"\"\\n\\n        available = [(servers[i], i) for i in range(len(servers))]\\n        heapify(available)\\n        unavailable = []\\n\\n        ans = [0]*len(tasks)\\n\\n        curr_time = 0\\n        for i in range(len(tasks)):\\n            curr_time = max(i , curr_time)\\n            if len(available) == 0:\\n                curr_time = unavailable[0][0]\\n\\n            while unavailable and curr_time >= unavailable[0][0]:\\n                timefree, weight, index = heappop(unavailable)\\n                heappush(available, (weight, index))\\n\\n            weight, index = heappop(available)\\n            heappush(unavailable, (curr_time + tasks[i], weight, index))\\n            ans[i] = index\\n\\n        return ans\\n                \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \"\"\"\\n        - Task inserted in queue in order of arrival\\n        - Task in the queue is assigned to free server with the smallest with smallest weight(if tie\\n        add to server with smaller index)\\n\\n        \"\"\"\\n\\n        available = [(servers[i], i) for i in range(len(servers))]\\n        heapify(available)\\n        unavailable = []\\n\\n        ans = [0]*len(tasks)\\n\\n        curr_time = 0\\n        for i in range(len(tasks)):\\n            curr_time = max(i , curr_time)\\n            if len(available) == 0:\\n                curr_time = unavailable[0][0]\\n\\n            while unavailable and curr_time >= unavailable[0][0]:\\n                timefree, weight, index = heappop(unavailable)\\n                heappush(available, (weight, index))\\n\\n            weight, index = heappop(available)\\n            heappush(unavailable, (curr_time + tasks[i], weight, index))\\n            ans[i] = index\\n\\n        return ans\\n                \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984275,
                "title": "python-two-heaps-free-inuse-clean-code",
                "content": "# Code\\n```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [ (w, i) for i, w in enumerate(servers)]\\n        inuse = []\\n        heapify(free)\\n        res = []\\n        for i, t in enumerate(tasks):\\n            while inuse and inuse[0][0] <= i:\\n                heappush(free, heappop(inuse)[1:])\\n            far = 0\\n            if not free:\\n                far, w, j = heappop(inuse)\\n                heappush(free, (w, j))\\n            w, j = heappop(free)\\n            heappush(inuse, (max(i,far)+t, w, j))\\n            res.append(j)\\n        return res\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [ (w, i) for i, w in enumerate(servers)]\\n        inuse = []\\n        heapify(free)\\n        res = []\\n        for i, t in enumerate(tasks):\\n            while inuse and inuse[0][0] <= i:\\n                heappush(free, heappop(inuse)[1:])\\n            far = 0\\n            if not free:\\n                far, w, j = heappop(inuse)\\n                heappush(free, (w, j))\\n            w, j = heappop(free)\\n            heappush(inuse, (max(i,far)+t, w, j))\\n            res.append(j)\\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984274,
                "title": "python-two-heaps-free-inuse-clean-code",
                "content": "# Code\\n```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [ (w, i) for i, w in enumerate(servers)]\\n        inuse = []\\n        heapify(free)\\n        res = []\\n        for i, t in enumerate(tasks):\\n            while inuse and inuse[0][0] <= i:\\n                heappush(free, heappop(inuse)[1:])\\n            far = 0\\n            if not free:\\n                far, w, j = heappop(inuse)\\n                heappush(free, (w, j))\\n            w, j = heappop(free)\\n            heappush(inuse, (max(i,far)+t, w, j))\\n            res.append(j)\\n        return res\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [ (w, i) for i, w in enumerate(servers)]\\n        inuse = []\\n        heapify(free)\\n        res = []\\n        for i, t in enumerate(tasks):\\n            while inuse and inuse[0][0] <= i:\\n                heappush(free, heappop(inuse)[1:])\\n            far = 0\\n            if not free:\\n                far, w, j = heappop(inuse)\\n                heappush(free, (w, j))\\n            w, j = heappop(free)\\n            heappush(inuse, (max(i,far)+t, w, j))\\n            res.append(j)\\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982089,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo heaps\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct serverData {\\n    int weight;\\n    int index;\\n    int finishTime;\\n    serverData(int weight, int index, int finishTime) : weight(weight), index(index), finishTime(finishTime) {}\\n};\\n\\nclass cmp {\\npublic:\\n    bool operator()(serverData &s1, serverData &s2) {\\n        if (s1.weight > s2.weight) {\\n            return true;\\n        } else if (s1.weight < s2.weight) {\\n            return false;\\n        }\\n\\n        // s1.weight == s2.weight is true\\n        return s1.index > s2.index;\\n    }\\n};\\n\\nclass cmp2 {\\npublic:\\n    bool operator()(serverData &s1, serverData &s2) {\\n        if (s1.finishTime > s2.finishTime) {\\n            return true;\\n        } else if (s1.finishTime < s2.finishTime) {\\n            return false;\\n        }\\n\\n        // s1.finishTime == s2.finishTime is true.\\n        if (s1.weight > s2.weight) {\\n            return true;\\n        } else if (s1.weight < s2.weight) {\\n            return false;\\n        }\\n\\n        // s1.weight == s2.weight is true\\n        return s1.index > s2.index;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int> &servers, vector<int> &tasks) {\\n        priority_queue<serverData, vector<serverData>, cmp> freeServers;\\n        for (int i = 0; i < servers.size(); ++i) {\\n            freeServers.push(serverData(servers[i], i, 0));\\n        }\\n\\n        priority_queue<serverData, vector<serverData>, cmp2> busyServers;\\n        vector<int> answer(tasks.size());\\n        for (int j = 0; j < tasks.size(); ++j) {\\n            while (!busyServers.empty() && j >= busyServers.top().finishTime) {\\n                serverData server = busyServers.top();\\n                busyServers.pop();\\n\\n                freeServers.push(server);\\n            }\\n\\n            if (!freeServers.empty()) {\\n                serverData freeServer = freeServers.top();\\n                freeServers.pop();\\n\\n                answer[j] = freeServer.index;\\n                freeServer.finishTime = j + tasks[j];\\n                busyServers.push(freeServer);\\n            } else {\\n                serverData busyServer = busyServers.top();\\n                busyServers.pop();\\n\\n                answer[j] = busyServer.index;\\n                busyServer.finishTime += tasks[j];\\n                busyServers.push(busyServer);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct serverData {\\n    int weight;\\n    int index;\\n    int finishTime;\\n    serverData(int weight, int index, int finishTime) : weight(weight), index(index), finishTime(finishTime) {}\\n};\\n\\nclass cmp {\\npublic:\\n    bool operator()(serverData &s1, serverData &s2) {\\n        if (s1.weight > s2.weight) {\\n            return true;\\n        } else if (s1.weight < s2.weight) {\\n            return false;\\n        }\\n\\n        // s1.weight == s2.weight is true\\n        return s1.index > s2.index;\\n    }\\n};\\n\\nclass cmp2 {\\npublic:\\n    bool operator()(serverData &s1, serverData &s2) {\\n        if (s1.finishTime > s2.finishTime) {\\n            return true;\\n        } else if (s1.finishTime < s2.finishTime) {\\n            return false;\\n        }\\n\\n        // s1.finishTime == s2.finishTime is true.\\n        if (s1.weight > s2.weight) {\\n            return true;\\n        } else if (s1.weight < s2.weight) {\\n            return false;\\n        }\\n\\n        // s1.weight == s2.weight is true\\n        return s1.index > s2.index;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int> &servers, vector<int> &tasks) {\\n        priority_queue<serverData, vector<serverData>, cmp> freeServers;\\n        for (int i = 0; i < servers.size(); ++i) {\\n            freeServers.push(serverData(servers[i], i, 0));\\n        }\\n\\n        priority_queue<serverData, vector<serverData>, cmp2> busyServers;\\n        vector<int> answer(tasks.size());\\n        for (int j = 0; j < tasks.size(); ++j) {\\n            while (!busyServers.empty() && j >= busyServers.top().finishTime) {\\n                serverData server = busyServers.top();\\n                busyServers.pop();\\n\\n                freeServers.push(server);\\n            }\\n\\n            if (!freeServers.empty()) {\\n                serverData freeServer = freeServers.top();\\n                freeServers.pop();\\n\\n                answer[j] = freeServer.index;\\n                freeServer.finishTime = j + tasks[j];\\n                busyServers.push(freeServer);\\n            } else {\\n                serverData busyServer = busyServers.top();\\n                busyServers.pop();\\n\\n                answer[j] = busyServer.index;\\n                busyServer.finishTime += tasks[j];\\n                busyServers.push(busyServer);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981701,
                "title": "c-two-heaps-with-comments",
                "content": "# Approach\\nMentioned in the comments\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct ServerInfo {\\n        int id;\\n        int weight;\\n        long long availableTime;\\n        explicit ServerInfo(int id, int weight, int availableTime) \\n                : id(id), weight(weight), availableTime(availableTime) {}\\n    };\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        // At second j, the jth task is inserted into the queue\\n        // task at front will be assigned to a free server with the smallest (weight, index)\\n        \\n        // setup:\\n        // - use two priority queues (min heaps) to hold servers, \\n        //   - one for working servers, sorted by (availableTime)\\n        //   - another one for free servers, sorted by (weight, index)\\n        // - use a queue to hold available tasks\\n        // - use a variable curTime and increase it at each round\\n        auto customGreaterAvailableTime = [](const auto& lhs, const auto& rhs) -> bool {\\n            return lhs.availableTime > rhs.availableTime;\\n        };\\n        auto customGreaterWeight = [](const auto& lhs, const auto& rhs) -> bool {\\n            if (lhs.weight == rhs.weight) {\\n                return lhs.id > rhs.id;\\n            }\\n            return lhs.weight > rhs.weight;\\n        };\\n        priority_queue<ServerInfo, vector<ServerInfo>, decltype(customGreaterAvailableTime)> \\n                workingServerInfoPQ(customGreaterAvailableTime);\\n        priority_queue<ServerInfo, vector<ServerInfo>, decltype(customGreaterWeight)> \\n                freeServerInfoPQ(customGreaterWeight);\\n        long long curTime = 0;\\n        for (int i = 0; i < servers.size(); ++i) {\\n            freeServerInfoPQ.emplace(i, servers[i], curTime);\\n        }\\n        queue<int> taskProcessingTimeQ;\\n\\n        // at each round, \\n        // - check workingServerPQ and move free ones to freeServerPQ\\n        // - push one task into the queue\\n        // - try assign the task at front of the queue to a free server\\n        // - increase current timestamp\\n        vector<int> result;\\n        result.reserve(tasks.size());\\n        while (curTime < tasks.size() || !taskProcessingTimeQ.empty()) {\\n            while (!workingServerInfoPQ.empty() && workingServerInfoPQ.top().availableTime == curTime) {\\n                auto top = workingServerInfoPQ.top();\\n                top.availableTime = curTime;\\n                freeServerInfoPQ.emplace(std::move(top));\\n                workingServerInfoPQ.pop();\\n            }\\n\\n            if (curTime < tasks.size()) {\\n                taskProcessingTimeQ.push(tasks[curTime]);\\n            }\\n\\n            while (!taskProcessingTimeQ.empty() && !freeServerInfoPQ.empty()) {\\n                auto taskProcessingTime = taskProcessingTimeQ.front();\\n                auto top = freeServerInfoPQ.top();\\n                top.availableTime = curTime + taskProcessingTime;\\n                result.push_back(top.id);\\n                workingServerInfoPQ.emplace(std::move(top));\\n                freeServerInfoPQ.pop();\\n                taskProcessingTimeQ.pop();\\n            }\\n\\n            if (curTime < tasks.size()) {\\n                ++curTime;\\n            } else {\\n                // jump to next available time\\n                curTime = workingServerInfoPQ.top().availableTime;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct ServerInfo {\\n        int id;\\n        int weight;\\n        long long availableTime;\\n        explicit ServerInfo(int id, int weight, int availableTime) \\n                : id(id), weight(weight), availableTime(availableTime) {}\\n    };\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        // At second j, the jth task is inserted into the queue\\n        // task at front will be assigned to a free server with the smallest (weight, index)\\n        \\n        // setup:\\n        // - use two priority queues (min heaps) to hold servers, \\n        //   - one for working servers, sorted by (availableTime)\\n        //   - another one for free servers, sorted by (weight, index)\\n        // - use a queue to hold available tasks\\n        // - use a variable curTime and increase it at each round\\n        auto customGreaterAvailableTime = [](const auto& lhs, const auto& rhs) -> bool {\\n            return lhs.availableTime > rhs.availableTime;\\n        };\\n        auto customGreaterWeight = [](const auto& lhs, const auto& rhs) -> bool {\\n            if (lhs.weight == rhs.weight) {\\n                return lhs.id > rhs.id;\\n            }\\n            return lhs.weight > rhs.weight;\\n        };\\n        priority_queue<ServerInfo, vector<ServerInfo>, decltype(customGreaterAvailableTime)> \\n                workingServerInfoPQ(customGreaterAvailableTime);\\n        priority_queue<ServerInfo, vector<ServerInfo>, decltype(customGreaterWeight)> \\n                freeServerInfoPQ(customGreaterWeight);\\n        long long curTime = 0;\\n        for (int i = 0; i < servers.size(); ++i) {\\n            freeServerInfoPQ.emplace(i, servers[i], curTime);\\n        }\\n        queue<int> taskProcessingTimeQ;\\n\\n        // at each round, \\n        // - check workingServerPQ and move free ones to freeServerPQ\\n        // - push one task into the queue\\n        // - try assign the task at front of the queue to a free server\\n        // - increase current timestamp\\n        vector<int> result;\\n        result.reserve(tasks.size());\\n        while (curTime < tasks.size() || !taskProcessingTimeQ.empty()) {\\n            while (!workingServerInfoPQ.empty() && workingServerInfoPQ.top().availableTime == curTime) {\\n                auto top = workingServerInfoPQ.top();\\n                top.availableTime = curTime;\\n                freeServerInfoPQ.emplace(std::move(top));\\n                workingServerInfoPQ.pop();\\n            }\\n\\n            if (curTime < tasks.size()) {\\n                taskProcessingTimeQ.push(tasks[curTime]);\\n            }\\n\\n            while (!taskProcessingTimeQ.empty() && !freeServerInfoPQ.empty()) {\\n                auto taskProcessingTime = taskProcessingTimeQ.front();\\n                auto top = freeServerInfoPQ.top();\\n                top.availableTime = curTime + taskProcessingTime;\\n                result.push_back(top.id);\\n                workingServerInfoPQ.emplace(std::move(top));\\n                freeServerInfoPQ.pop();\\n                taskProcessingTimeQ.pop();\\n            }\\n\\n            if (curTime < tasks.size()) {\\n                ++curTime;\\n            } else {\\n                // jump to next available time\\n                curTime = workingServerInfoPQ.top().availableTime;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972239,
                "title": "c-two-priority-queues-object-oriented",
                "content": "# Complexity\\n```\\nS := servers\\nT := tasks\\n```\\n\\n- Time complexity:\\n`O((T + S) * log S)`\\n\\n- Space complexity:\\n`O(S)`\\n\\n# Code\\n```\\nstruct Server {\\n    int weight;\\n    int idx;\\n\\n    bool operator<(const Server& a) const {\\n        if (weight == a.weight) return idx < a.idx;\\n        return weight < a.weight;\\n    }\\n};\\n\\nclass ServerRack {\\npublic:\\n    explicit ServerRack(const vector<int>& servers) {\\n        if (servers.empty()) throw logic_error(\"Bad Test Case\");\\n\\n        for(int i = 0; i < servers.size(); ++i) {\\n            m_availableServers.emplace(Server{servers[i], i});\\n        }\\n    }\\n\\n    pair<int, int> getAvailableServer(int time, int taskTime) {\\n        time = elapseUntilFree(time);\\n\\n        Server server = m_availableServers.top();\\n        m_availableServers.pop();\\n\\n        m_busyServers.emplace(time + taskTime, server);\\n        return {time, server.idx};\\n    }\\n\\n\\nprivate:\\n    struct AvailableServerCompare {\\n        bool operator()(const Server& a, const Server& b) {\\n            return a.weight == b.weight\\n                ? a.idx > b.idx\\n                : a.weight > b.weight;\\n        }\\n    };\\n\\n    priority_queue<Server, vector<Server>, AvailableServerCompare> m_availableServers;\\n    priority_queue<pair<int, Server>, vector<pair<int, Server>>, greater<>> m_busyServers;\\n\\n    int elapseUntilFree(int currentTime) {\\n        while(!m_busyServers.empty() && m_busyServers.top().first <= currentTime) {\\n            m_availableServers.emplace(m_busyServers.top().second);\\n            m_busyServers.pop();\\n        }\\n\\n        if (m_availableServers.empty()) {\\n            return elapseUntilFree(m_busyServers.top().first);\\n        }\\n\\n        return currentTime;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        vector<int> results;\\n        results.reserve(tasks.size());\\n\\n        int time = 0;\\n        ServerRack rack(servers);\\n        for(int i = 0; i < tasks.size(); ++i) {\\n            int taskTime = tasks[i];\\n\\n            auto [availableTime, serverIdx] = rack.getAvailableServer(time, taskTime);\\n            results.push_back(serverIdx);\\n\\n            if (availableTime <= i) {\\n                // Increment time when we are having no trouble processing the queue\\n                time = i + 1;\\n            } else {\\n                // Don\\'t incremement  if we\\'re behind on the queue\\n                time = availableTime;\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nS := servers\\nT := tasks\\n```\n```\\nstruct Server {\\n    int weight;\\n    int idx;\\n\\n    bool operator<(const Server& a) const {\\n        if (weight == a.weight) return idx < a.idx;\\n        return weight < a.weight;\\n    }\\n};\\n\\nclass ServerRack {\\npublic:\\n    explicit ServerRack(const vector<int>& servers) {\\n        if (servers.empty()) throw logic_error(\"Bad Test Case\");\\n\\n        for(int i = 0; i < servers.size(); ++i) {\\n            m_availableServers.emplace(Server{servers[i], i});\\n        }\\n    }\\n\\n    pair<int, int> getAvailableServer(int time, int taskTime) {\\n        time = elapseUntilFree(time);\\n\\n        Server server = m_availableServers.top();\\n        m_availableServers.pop();\\n\\n        m_busyServers.emplace(time + taskTime, server);\\n        return {time, server.idx};\\n    }\\n\\n\\nprivate:\\n    struct AvailableServerCompare {\\n        bool operator()(const Server& a, const Server& b) {\\n            return a.weight == b.weight\\n                ? a.idx > b.idx\\n                : a.weight > b.weight;\\n        }\\n    };\\n\\n    priority_queue<Server, vector<Server>, AvailableServerCompare> m_availableServers;\\n    priority_queue<pair<int, Server>, vector<pair<int, Server>>, greater<>> m_busyServers;\\n\\n    int elapseUntilFree(int currentTime) {\\n        while(!m_busyServers.empty() && m_busyServers.top().first <= currentTime) {\\n            m_availableServers.emplace(m_busyServers.top().second);\\n            m_busyServers.pop();\\n        }\\n\\n        if (m_availableServers.empty()) {\\n            return elapseUntilFree(m_busyServers.top().first);\\n        }\\n\\n        return currentTime;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        vector<int> results;\\n        results.reserve(tasks.size());\\n\\n        int time = 0;\\n        ServerRack rack(servers);\\n        for(int i = 0; i < tasks.size(); ++i) {\\n            int taskTime = tasks[i];\\n\\n            auto [availableTime, serverIdx] = rack.getAvailableServer(time, taskTime);\\n            results.push_back(serverIdx);\\n\\n            if (availableTime <= i) {\\n                // Increment time when we are having no trouble processing the queue\\n                time = i + 1;\\n            } else {\\n                // Don\\'t incremement  if we\\'re behind on the queue\\n                time = availableTime;\\n            }\\n        }\\n\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970629,
                "title": "java-two-minheaps",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n.Logn)\\n\\n- Space complexity:\\nO(N + K)\\n\\n# Code\\n```\\nclass Server {\\n    int index;\\n    int weight;\\n    int time;\\n\\n    public Server(int index, int weight){\\n        this.index = index;\\n        this.weight = weight;\\n    }\\n\\n     public Server(int index, int weight, int time){\\n        this.index = index;\\n        this.weight = weight;\\n        this.time = time;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        PriorityQueue<Server> available = new PriorityQueue<>((a,b) -> a.weight == b.weight ? Integer.compare(a.index,b.index):Integer.compare(a.weight, b.weight));\\n         PriorityQueue<Server> unavailable = new PriorityQueue<>((a,b) -> a.time - b.time);\\n\\n        for(int i = 0; i < servers.length; i++){\\n            available.add(new Server(i, servers[i]));\\n        }\\n\\n        int time = 0;\\n        int j = 0;\\n        int[] resultant = new int[tasks.length];\\n        \\n        for(int i = 0; i < tasks.length; i++){\\n            time = Math.max(time, i);\\n\\n            if(available.isEmpty()){\\n                time = unavailable.peek().time;\\n            }\\n            \\n            while(!unavailable.isEmpty() && unavailable.peek().time <= time){\\n                Server availableServer = unavailable.poll();\\n                available.add(new Server(availableServer.index, availableServer.weight));\\n            }\\n\\n            if(!available.isEmpty()){\\n                Server server = available.poll();\\n                unavailable.add(new Server(server.index, server.weight, time + tasks[i]));\\n                resultant[j++] = server.index;\\n            }\\n        }\\n\\n        return resultant;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Server {\\n    int index;\\n    int weight;\\n    int time;\\n\\n    public Server(int index, int weight){\\n        this.index = index;\\n        this.weight = weight;\\n    }\\n\\n     public Server(int index, int weight, int time){\\n        this.index = index;\\n        this.weight = weight;\\n        this.time = time;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        PriorityQueue<Server> available = new PriorityQueue<>((a,b) -> a.weight == b.weight ? Integer.compare(a.index,b.index):Integer.compare(a.weight, b.weight));\\n         PriorityQueue<Server> unavailable = new PriorityQueue<>((a,b) -> a.time - b.time);\\n\\n        for(int i = 0; i < servers.length; i++){\\n            available.add(new Server(i, servers[i]));\\n        }\\n\\n        int time = 0;\\n        int j = 0;\\n        int[] resultant = new int[tasks.length];\\n        \\n        for(int i = 0; i < tasks.length; i++){\\n            time = Math.max(time, i);\\n\\n            if(available.isEmpty()){\\n                time = unavailable.peek().time;\\n            }\\n            \\n            while(!unavailable.isEmpty() && unavailable.peek().time <= time){\\n                Server availableServer = unavailable.poll();\\n                available.add(new Server(availableServer.index, availableServer.weight));\\n            }\\n\\n            if(!available.isEmpty()){\\n                Server server = available.poll();\\n                unavailable.add(new Server(server.index, server.weight, time + tasks[i]));\\n                resultant[j++] = server.index;\\n            }\\n        }\\n\\n        return resultant;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857879,
                "title": "c-two-queues-faster-than-90-percent",
                "content": "``` \\nclass Solution {\\npublic:  \\n    \\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>> , greater<pair<int,int>> >q; \\n        \\n        for(int i = 0; i < servers.size(); i++){\\n            q.push(make_pair(servers[i],i));\\n        } \\n        \\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>> ,  greater<pair<int,int>> >time;\\n       \\n        vector<int>ans(tasks.size(),0); \\n        int t = 0 ;\\n        int i=0; \\n        \\n        while(i<tasks.size()) {\\n            \\n              if(q.empty()){\\n                t=time.top().first;  \\n            }\\n            \\n            //freeing servers\\n            while(!time.empty() && time.top().first<= t ){ \\n                q.push(make_pair(servers[time.top().second], time.top().second));\\n                time.pop(); \\n            }\\n              \\n            \\n            while(!q.empty() &&  i<tasks.size() &&  t >= i){\\n              pair<int,int>temp= q.top(); \\n              q.pop(); \\n              ans[i] = temp.second;\\n              time.push(make_pair(t+tasks[i],temp.second)); \\n              i++;   \\n            }\\n            \\n            t++; \\n           \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:  \\n    \\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>> , greater<pair<int,int>> >q; \\n        \\n        for(int i = 0; i < servers.size(); i++){\\n            q.push(make_pair(servers[i],i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2837065,
                "title": "using-two-min-heap-fast-and-concise-python-3",
                "content": "\\nThe idea is to keep track of free servers while also keep track of current running tasks along with the needed information such as the ending time, the server index and weight.\\n\\nFirst catch :-\\nThe problem is asking us to sort free servers by smallest weight then smallest index, so we will use \\na min heap to store tuples of sorted (weight, index).\\n\\nSecond catch:-\\nNot every tasks will find a free server immediately. \\nSo, if no free servers available at the moment, the task need to wait in the queue. \\nBut in order to correclty keep track of it\\'s actual ending time, we should update it\\'s ending time to be (earliest ending time in the current running tasks + the task\\'s orginal ending time).\\n\\nOne thing to note here is that the in_use queue need to be sorted by the ending time, then by the server\\'s weight and finally the server\\'s index.\\n\\n\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \\n        free_servers = [(w, i) for i, w in enumerate(servers)] # (weight, index), sort by weight\\n        heapify(free_servers)\\n        \\n        in_use = [] # (endTime, weight, index), sort by endTime\\n        \\n        ans = [i for i in range(len(tasks))]\\n\\n        for start in range(len(tasks)):\\n            # If there are any servers who finised before current starting time, free them up\\n            while in_use and in_use[0][0] <= start:\\n                time, _ , server = heappop(in_use)\\n                heappush(free_servers, (servers[server], server))                \\n                \\n            if free_servers:\\n                # always pick the smallest weight first\\n                _ , server = heappop(free_servers)\\n                # assign the server to current task that will end at \"tasks[start]+start\"\\n                heappush(in_use, (tasks[start]+start, servers[server], server))            \\n            else:\\n                # pop the earliest ending time from the current running tasks queue (in_use)\\n                earliest_time, _ , server = heappop(in_use)\\n                new_duration = tasks[start] + earliest_time\\n                heappush(in_use, (new_duration, servers[server], server))   \\n                \\n            ans[start] = server\\n            \\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        \\n        free_servers = [(w, i) for i, w in enumerate(servers)] # (weight, index), sort by weight\\n        heapify(free_servers)\\n        \\n        in_use = [] # (endTime, weight, index), sort by endTime\\n        \\n        ans = [i for i in range(len(tasks))]\\n\\n        for start in range(len(tasks)):\\n            # If there are any servers who finised before current starting time, free them up\\n            while in_use and in_use[0][0] <= start:\\n                time, _ , server = heappop(in_use)\\n                heappush(free_servers, (servers[server], server))                \\n                \\n            if free_servers:\\n                # always pick the smallest weight first\\n                _ , server = heappop(free_servers)\\n                # assign the server to current task that will end at \"tasks[start]+start\"\\n                heappush(in_use, (tasks[start]+start, servers[server], server))            \\n            else:\\n                # pop the earliest ending time from the current running tasks queue (in_use)\\n                earliest_time, _ , server = heappop(in_use)\\n                new_duration = tasks[start] + earliest_time\\n                heappush(in_use, (new_duration, servers[server], server))   \\n                \\n            ans[start] = server\\n            \\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816810,
                "title": "java-solution-with-priorityqueue-o-k-n-logn",
                "content": "```\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        // [piority, serverIndex]\\n        PriorityQueue<int[]> freeQueue = new PriorityQueue<>((n1, n2) -> n1[0] != n2[0] ? n1[0] - n2[0] : n1[1] - n2[1]);\\n        for(int i = 0; i < servers.length; i++) {\\n            freeQueue.add(new int[]{servers[i], i});\\n        }\\n        \\n        // [finishTime, serverIndex]\\n        PriorityQueue<int[]> busyQueue = new PriorityQueue<int[]>((n1, n2) -> n1[0] - n2[0]);\\n        \\n        int[] result = new int[tasks.length];\\n        for(int i = 0, time = 0; i < tasks.length; time++) {\\n            while (freeQueue.isEmpty() || (!busyQueue.isEmpty() && busyQueue.peek()[0] <= time)) {\\n                int[] t = busyQueue.poll();\\n                time = t[0];\\n                freeQueue.add(new int[] {servers[t[1]], t[1]});\\n            }\\n            \\n            while(i <= time && i < tasks.length && !freeQueue.isEmpty()) {\\n                int[] freeServer = freeQueue.poll();\\n                busyQueue.add(new int[] {time + tasks[i], freeServer[1]});\\n                result[i++] = freeServer[1];\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        // [piority, serverIndex]\\n        PriorityQueue<int[]> freeQueue = new PriorityQueue<>((n1, n2) -> n1[0] != n2[0] ? n1[0] - n2[0] : n1[1] - n2[1]);\\n        for(int i = 0; i < servers.length; i++) {\\n            freeQueue.add(new int[]{servers[i], i});\\n        }\\n        \\n        // [finishTime, serverIndex]\\n        PriorityQueue<int[]> busyQueue = new PriorityQueue<int[]>((n1, n2) -> n1[0] - n2[0]);\\n        \\n        int[] result = new int[tasks.length];\\n        for(int i = 0, time = 0; i < tasks.length; time++) {\\n            while (freeQueue.isEmpty() || (!busyQueue.isEmpty() && busyQueue.peek()[0] <= time)) {\\n                int[] t = busyQueue.poll();\\n                time = t[0];\\n                freeQueue.add(new int[] {servers[t[1]], t[1]});\\n            }\\n            \\n            while(i <= time && i < tasks.length && !freeQueue.isEmpty()) {\\n                int[] freeServer = freeQueue.poll();\\n                busyQueue.add(new int[] {time + tasks[i], freeServer[1]});\\n                result[i++] = freeServer[1];\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2815218,
                "title": "java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    class Server{\\n        int weight;\\n        int index;\\n        int finishTime;\\n        Server(int w,int i,int ft){\\n            this.weight=w;\\n            this.index=i;\\n            this.finishTime=ft;\\n        }\\n    }\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        Comparator<Server> cmp1=new Comparator<>(){\\n            public int compare(Server s1,Server s2){\\n                if(s1.weight==s2.weight){\\n                    return s1.index-s2.index;\\n                }else{\\n                    return s1.weight-s2.weight;\\n                }\\n            }\\n        };\\n        Comparator<Server> cmp2=new Comparator<>(){\\n            public int compare(Server s1,Server s2){\\n                if(s1.finishTime==s2.finishTime){\\n                    if(s1.weight==s2.weight){\\n                        return s1.index-s2.index;\\n                    }else{\\n                        return s1.weight-s2.weight;\\n                    }    \\n                }else{\\n                     return s1.finishTime-s2.finishTime;\\n                }\\n            }\\n        };\\n        PriorityQueue<Server> freeServers=new PriorityQueue<>(cmp1);\\n        for(int i=0;i<servers.length;i++){\\n            Server s=new Server(servers[i],i,Integer.MIN_VALUE);\\n            freeServers.offer(s);\\n        }\\n        PriorityQueue<Server> busyServers=new PriorityQueue<>(cmp2);\\n        int[] ans=new int[tasks.length];\\n        for(int i=0;i<tasks.length;i++){\\n            //move servers that are now idle from busy servers to free servers\\n            int curTime=i;\\n            while(!busyServers.isEmpty() && busyServers.peek().finishTime==curTime){\\n                freeServers.offer(busyServers.poll());\\n            }\\n            if(freeServers.isEmpty()){\\n                Server s=busyServers.poll();\\n                s.finishTime=s.finishTime+tasks[i];\\n                ans[i]=s.index;\\n                busyServers.offer(s);\\n            }else{\\n                Server s=freeServers.poll();\\n                ans[i]=s.index;\\n                s.finishTime=curTime+tasks[i];\\n                busyServers.offer(s);  \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Server{\\n        int weight;\\n        int index;\\n        int finishTime;\\n        Server(int w,int i,int ft){\\n            this.weight=w;\\n            this.index=i;\\n            this.finishTime=ft;\\n        }\\n    }\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        Comparator<Server> cmp1=new Comparator<>(){\\n            public int compare(Server s1,Server s2){\\n                if(s1.weight==s2.weight){\\n                    return s1.index-s2.index;\\n                }else{\\n                    return s1.weight-s2.weight;\\n                }\\n            }\\n        };\\n        Comparator<Server> cmp2=new Comparator<>(){\\n            public int compare(Server s1,Server s2){\\n                if(s1.finishTime==s2.finishTime){\\n                    if(s1.weight==s2.weight){\\n                        return s1.index-s2.index;\\n                    }else{\\n                        return s1.weight-s2.weight;\\n                    }    \\n                }else{\\n                     return s1.finishTime-s2.finishTime;\\n                }\\n            }\\n        };\\n        PriorityQueue<Server> freeServers=new PriorityQueue<>(cmp1);\\n        for(int i=0;i<servers.length;i++){\\n            Server s=new Server(servers[i],i,Integer.MIN_VALUE);\\n            freeServers.offer(s);\\n        }\\n        PriorityQueue<Server> busyServers=new PriorityQueue<>(cmp2);\\n        int[] ans=new int[tasks.length];\\n        for(int i=0;i<tasks.length;i++){\\n            //move servers that are now idle from busy servers to free servers\\n            int curTime=i;\\n            while(!busyServers.isEmpty() && busyServers.peek().finishTime==curTime){\\n                freeServers.offer(busyServers.poll());\\n            }\\n            if(freeServers.isEmpty()){\\n                Server s=busyServers.poll();\\n                s.finishTime=s.finishTime+tasks[i];\\n                ans[i]=s.index;\\n                busyServers.offer(s);\\n            }else{\\n                Server s=freeServers.poll();\\n                ans[i]=s.index;\\n                s.finishTime=curTime+tasks[i];\\n                busyServers.offer(s);  \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749561,
                "title": "meeting-rooms-iii-similar-qn-nearly-same-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        return solve(servers,tasks);\\n    }\\n    static int[] solve(int[] servers,int[] tasks){\\n        int N = tasks.length;;\\n        int[] res = new int[N];\\n\\n        // already tasks are based on timing so no need\\n        // sort based on timing\\n\\n        //{index, end time}\\n        PriorityQueue<int[]> used =  new PriorityQueue<>((a,b)->\\n                a[1]==b[1]?(\\n                        servers[a[0]]==servers[b[0]]?\\n                        a[0]-b[0]: servers[a[0]]-servers[b[0]]\\n                )\\n                        :a[1]-b[1]);\\n\\n        // {room value,index}\\n        PriorityQueue<int[]> unused = new PriorityQueue<>((a,b)->\\n                a[0]==b[0]?a[1]-b[1]:a[0]-b[0]);\\n\\n        for(int i=0;i<servers.length;i++){\\n            unused.add(new int[]{servers[i],i});\\n        }\\n\\n        for(int time = 0;time<tasks.length;time++){\\n            // remove all used roooms that ending here\\n            while(!used.isEmpty() && used.peek()[1]<=time){\\n                int index = used.poll()[0];\\n                unused.add(new int[]{servers[index],index});\\n            }\\n            // check is any server is available\\n            if(unused.size()>0){\\n                int index = unused.poll()[1];\\n                used.add(new int[]{index,time+tasks[time]});\\n                res[time] = index;\\n            }else{ // if no server available\\n                int[] obj = used.poll();\\n                int firstFree = obj[0];\\n                int newStart = obj[1];\\n                // suddenly gonna use so dont add to unuse\\n                res[time] = firstFree;\\n                used.add(new int[]{firstFree,newStart+tasks[time]});\\n            }\\n        }\\n\\n\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        return solve(servers,tasks);\\n    }\\n    static int[] solve(int[] servers,int[] tasks){\\n        int N = tasks.length;;\\n        int[] res = new int[N];\\n\\n        // already tasks are based on timing so no need\\n        // sort based on timing\\n\\n        //{index, end time}\\n        PriorityQueue<int[]> used =  new PriorityQueue<>((a,b)->\\n                a[1]==b[1]?(\\n                        servers[a[0]]==servers[b[0]]?\\n                        a[0]-b[0]: servers[a[0]]-servers[b[0]]\\n                )\\n                        :a[1]-b[1]);\\n\\n        // {room value,index}\\n        PriorityQueue<int[]> unused = new PriorityQueue<>((a,b)->\\n                a[0]==b[0]?a[1]-b[1]:a[0]-b[0]);\\n\\n        for(int i=0;i<servers.length;i++){\\n            unused.add(new int[]{servers[i],i});\\n        }\\n\\n        for(int time = 0;time<tasks.length;time++){\\n            // remove all used roooms that ending here\\n            while(!used.isEmpty() && used.peek()[1]<=time){\\n                int index = used.poll()[0];\\n                unused.add(new int[]{servers[index],index});\\n            }\\n            // check is any server is available\\n            if(unused.size()>0){\\n                int index = unused.poll()[1];\\n                used.add(new int[]{index,time+tasks[time]});\\n                res[time] = index;\\n            }else{ // if no server available\\n                int[] obj = used.poll();\\n                int firstFree = obj[0];\\n                int newStart = obj[1];\\n                // suddenly gonna use so dont add to unuse\\n                res[time] = firstFree;\\n                used.add(new int[]{firstFree,newStart+tasks[time]});\\n            }\\n        }\\n\\n\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704277,
                "title": "python-two-heaps-solution-with-explanation",
                "content": "*Runtime: 2181 ms, faster than 95.77% of Python3 online submissions for Process Tasks Using Servers.\\nMemory Usage: 55.5 MB, less than 73.66% of Python3 online submissions for Process Tasks Using Servers.*\\n\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        ns = len(servers)\\n        nt = len(tasks)\\n        \\n        free = [] # (weight, index, time), sort by weight\\n        for i in range(ns):\\n            heapq.heappush(free, (servers[i], i, 0))\\n            \\n        busy = [] # (time, weight, index), sort by time\\n        \\n        result = []\\n        \\n        for j in range(nt):\\n            # move finished server from busy to free\\n            while len(busy)> 0 and busy[0][0] <= j:\\n                time, weight, index = heapq.heappop(busy)\\n                heapq.heappush(free, (weight, index, time))\\n                \\n            # assign new task\\n            if len(free) > 0:\\n                weight, index, time = heapq.heappop(free)\\n            else:\\n                time, weight, index = heapq.heappop(busy)\\n            result.append(index)\\n            \\n            # why time = max(time, j)?\\n            # case1:\\n            # there are free servers, add time to the first free server\\n            # e.g. j = 2, tasks[j] = 3, \\n            #      free[0] = (3, 0, 0) -> busy[0] = (5, 3, 0)\\n            \\n            # case2:\\n            # no free server, the first server in busy is still working, add time to the first busy server\\n            # e.g. j = 2, tasks[j] = 3,\\n            #      busy[0] = (3, 3, 0), still working\\n            #   -> busy[0] = (6, 3, 0)\\n            time = max(time, j) \\n            # move assigned server from free to busy\\n            heapq.heappush(busy, (time + tasks[j], weight, index))\\n            \\n        return result\\n```\\n\\n\\nPhew~~ This problem is quite confusing, took me a long time to figure out the logic. \\u256E(\\u256F-\\u2570)\\u256D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        ns = len(servers)\\n        nt = len(tasks)\\n        \\n        free = [] # (weight, index, time), sort by weight\\n        for i in range(ns):\\n            heapq.heappush(free, (servers[i], i, 0))\\n            \\n        busy = [] # (time, weight, index), sort by time\\n        \\n        result = []\\n        \\n        for j in range(nt):\\n            # move finished server from busy to free\\n            while len(busy)> 0 and busy[0][0] <= j:\\n                time, weight, index = heapq.heappop(busy)\\n                heapq.heappush(free, (weight, index, time))\\n                \\n            # assign new task\\n            if len(free) > 0:\\n                weight, index, time = heapq.heappop(free)\\n            else:\\n                time, weight, index = heapq.heappop(busy)\\n            result.append(index)\\n            \\n            # why time = max(time, j)?\\n            # case1:\\n            # there are free servers, add time to the first free server\\n            # e.g. j = 2, tasks[j] = 3, \\n            #      free[0] = (3, 0, 0) -> busy[0] = (5, 3, 0)\\n            \\n            # case2:\\n            # no free server, the first server in busy is still working, add time to the first busy server\\n            # e.g. j = 2, tasks[j] = 3,\\n            #      busy[0] = (3, 3, 0), still working\\n            #   -> busy[0] = (6, 3, 0)\\n            time = max(time, j) \\n            # move assigned server from free to busy\\n            heapq.heappush(busy, (time + tasks[j], weight, index))\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700242,
                "title": "c-easy-solution-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    class comp {\\n    public:\\n        bool operator()(pair<int, pair<int,int>>& a, pair<int, pair<int,int>>& b) {\\n            if(a.first!=b.first) return a.first>b.first;\\n            if(a.second.first!=b.second.first) return a.second.first>b.second.first;\\n            return a.second.second>b.second.second;\\n        }\\n    };\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size(), m = tasks.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, comp> busy;\\n        for(int i=0; i<n; i++) {\\n            pq.push({servers[i], i});\\n        }\\n        vector<int> ans(m);\\n        int i = 0, tim = 0;\\n        while(i<m) {\\n            tim = max(tim, i);\\n            if(pq.empty() && !busy.empty() && busy.top().first>tim) {\\n                tim = busy.top().first;\\n            }\\n            while(!busy.empty() && busy.top().first<=tim) {\\n                pq.push(busy.top().second);\\n                busy.pop();\\n            }\\n            while(i<=tim && i<m && !pq.empty()) {\\n                ans[i] = pq.top().second;\\n                busy.push({tim + tasks[i], pq.top()});\\n                pq.pop();\\n                ++i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class comp {\\n    public:\\n        bool operator()(pair<int, pair<int,int>>& a, pair<int, pair<int,int>>& b) {\\n            if(a.first!=b.first) return a.first>b.first;\\n            if(a.second.first!=b.second.first) return a.second.first>b.second.first;\\n            return a.second.second>b.second.second;\\n        }\\n    };\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        int n = servers.size(), m = tasks.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, comp> busy;\\n        for(int i=0; i<n; i++) {\\n            pq.push({servers[i], i});\\n        }\\n        vector<int> ans(m);\\n        int i = 0, tim = 0;\\n        while(i<m) {\\n            tim = max(tim, i);\\n            if(pq.empty() && !busy.empty() && busy.top().first>tim) {\\n                tim = busy.top().first;\\n            }\\n            while(!busy.empty() && busy.top().first<=tim) {\\n                pq.push(busy.top().second);\\n                busy.pop();\\n            }\\n            while(i<=tim && i<m && !pq.empty()) {\\n                ans[i] = pq.top().second;\\n                busy.push({tim + tasks[i], pq.top()});\\n                pq.pop();\\n                ++i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699176,
                "title": "clean-fast-python3-2-heaps",
                "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        ans, avail, busy = [], [], []\\n        for i, w in enumerate(servers):\\n            avail.append([0, w, i])\\n        heapq.heapify(avail)\\n        \\n        for time, task in enumerate(tasks):\\n            \\n            while busy and busy[0][0] <= time:\\n                serv = heapq.heappop(busy)\\n                serv[0] = 0\\n                heapq.heappush(avail, serv)\\n            \\n            assign = heapq.heappop(avail) if avail else heapq.heappop(busy)\\n            ans.append(assign[2])\\n            assign[0] = max(time, assign[0]) + task\\n            heapq.heappush(busy, assign)\\n        \\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        ans, avail, busy = [], [], []\\n        for i, w in enumerate(servers):\\n            avail.append([0, w, i])\\n        heapq.heapify(avail)\\n        \\n        for time, task in enumerate(tasks):\\n            \\n            while busy and busy[0][0] <= time:\\n                serv = heapq.heappop(busy)\\n                serv[0] = 0\\n                heapq.heappush(avail, serv)\\n            \\n            assign = heapq.heappop(avail) if avail else heapq.heappop(busy)\\n            ans.append(assign[2])\\n            assign[0] = max(time, assign[0]) + task\\n            heapq.heappush(busy, assign)\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2692123,
                "title": "python-two-heaps",
                "content": "This question is really similar to Meeting Room III\\n```\\n\"\"\"\\nAlgorithm : Simulation : DO as they ask us to do:\\nOne Heap: keep track of the weight and its index, if the heap is not empty, suggesting that\\nthere are free server we can use.\\n\\nkeep track of the globla time counter\\nwe also need a queue to track the current mission end time\\nres = []\\n                             s  i\\nservers = [3,3,2]  server - heap =  {[3, 0], [3, 1], [2, 2]}\\ntasks = [1,2,3,2,1,2]: task - heap{[]}\\n-> t = 0 \\n        server - heap =  {[3, 0], [3, 1]}; [2, 2]\\n        task - heap{[2, 1]}\\n-> t = 1\\n        t > heap[0][1], pop every task smaller than this time, and push the server back to the server - heap\\n...\\n\\neverytime we add the task the heap, we append the result\\n\"\"\"\\nfrom heapq import *\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        servers_heap = [(server, idx) for idx, server in enumerate(servers)]\\n        heapq.heapify(servers_heap)\\n        task_heap = []\\n        res = []\\n\\t\\ttime = 0\\n\\t\\t# start the iteration\\n        for curr, dur in enumerate(tasks):\\n\\t\\t\\t# always track the current time\\n            time = max(curr, time)\\n\\t\\t\\t# the case if there are not server but we still have the tasks\\n            if not servers_heap:\\n                time = task_heap[0][0]\\n\\t\\t\\t# some tasks have finised, then push the server back to the server heap\\n            while task_heap and task_heap[0][0] <= time:\\n                heapq.heappush(servers_heap, heapq.heappop(task_heap)[1])\\n            server, idx = heapq.heappop(servers_heap)\\n            res.append(idx)\\n            heapq.heappush(task_heap, (time + dur, (server, idx)))\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nAlgorithm : Simulation : DO as they ask us to do:\\nOne Heap: keep track of the weight and its index, if the heap is not empty, suggesting that\\nthere are free server we can use.\\n\\nkeep track of the globla time counter\\nwe also need a queue to track the current mission end time\\nres = []\\n                             s  i\\nservers = [3,3,2]  server - heap =  {[3, 0], [3, 1], [2, 2]}\\ntasks = [1,2,3,2,1,2]: task - heap{[]}\\n-> t = 0 \\n        server - heap =  {[3, 0], [3, 1]}; [2, 2]\\n        task - heap{[2, 1]}\\n-> t = 1\\n        t > heap[0][1], pop every task smaller than this time, and push the server back to the server - heap\\n...\\n\\neverytime we add the task the heap, we append the result\\n\"\"\"\\nfrom heapq import *\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        servers_heap = [(server, idx) for idx, server in enumerate(servers)]\\n        heapq.heapify(servers_heap)\\n        task_heap = []\\n        res = []\\n\\t\\ttime = 0\\n\\t\\t# start the iteration\\n        for curr, dur in enumerate(tasks):\\n\\t\\t\\t# always track the current time\\n            time = max(curr, time)\\n\\t\\t\\t# the case if there are not server but we still have the tasks\\n            if not servers_heap:\\n                time = task_heap[0][0]\\n\\t\\t\\t# some tasks have finised, then push the server back to the server heap\\n            while task_heap and task_heap[0][0] <= time:\\n                heapq.heappush(servers_heap, heapq.heappop(task_heap)[1])\\n            server, idx = heapq.heappop(servers_heap)\\n            res.append(idx)\\n            heapq.heappush(task_heap, (time + dur, (server, idx)))\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691168,
                "title": "c-solution-using-two-priority-queues",
                "content": "\\n\\n# Code\\n```\\nusing T = pair<int, int>;\\nclass Solution {\\npublic:\\n\\n    int min(int a, int b)\\n    {\\n        if(a<b)\\n        return a;\\n        else\\n        return b;\\n    }\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<T, vector<T>, greater<T>> pq;\\n        priority_queue<T, vector<T>, greater<T>> busy;\\n        vector<int> ans;\\n\\n        for(int i = 0; i < servers.size(); i++)\\n        {\\n            pq.push({servers[i], i});\\n        }\\n\\n        int com= 0; // to store number of completed tasks\\n\\n        for(int j = 0; com<tasks.size() ; j++)\\n        {\\n            //when there are no free servers\\n            if(pq.empty())\\n            {\\n                j = busy.top().first;\\n            } \\n\\n            // freeing the servers\\n            while(!busy.empty() && busy.top().first <= j)\\n            {\\n                pq.push({servers[busy.top().second], busy.top().second});\\n                busy.pop();\\n            }\\n            \\n            // assigning tasks to servers\\n            while(!pq.empty() && com < min(tasks.size(), j+1))\\n            {\\n                ans.push_back(pq.top().second);\\n                busy.push({j+ tasks[com], pq.top().second});\\n                com++;\\n                pq.pop();\\n            }\\n            \\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing T = pair<int, int>;\\nclass Solution {\\npublic:\\n\\n    int min(int a, int b)\\n    {\\n        if(a<b)\\n        return a;\\n        else\\n        return b;\\n    }\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<T, vector<T>, greater<T>> pq;\\n        priority_queue<T, vector<T>, greater<T>> busy;\\n        vector<int> ans;\\n\\n        for(int i = 0; i < servers.size(); i++)\\n        {\\n            pq.push({servers[i], i});\\n        }\\n\\n        int com= 0; // to store number of completed tasks\\n\\n        for(int j = 0; com<tasks.size() ; j++)\\n        {\\n            //when there are no free servers\\n            if(pq.empty())\\n            {\\n                j = busy.top().first;\\n            } \\n\\n            // freeing the servers\\n            while(!busy.empty() && busy.top().first <= j)\\n            {\\n                pq.push({servers[busy.top().second], busy.top().second});\\n                busy.pop();\\n            }\\n            \\n            // assigning tasks to servers\\n            while(!pq.empty() && com < min(tasks.size(), j+1))\\n            {\\n                ans.push_back(pq.top().second);\\n                busy.push({j+ tasks[com], pq.top().second});\\n                com++;\\n                pq.pop();\\n            }\\n            \\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691167,
                "title": "c-solution-using-two-priority-queues",
                "content": "\\n\\n# Code\\n```\\nusing T = pair<int, int>;\\nclass Solution {\\npublic:\\n\\n    int min(int a, int b)\\n    {\\n        if(a<b)\\n        return a;\\n        else\\n        return b;\\n    }\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<T, vector<T>, greater<T>> pq;\\n        priority_queue<T, vector<T>, greater<T>> busy;\\n        vector<int> ans;\\n\\n        for(int i = 0; i < servers.size(); i++)\\n        {\\n            pq.push({servers[i], i});\\n        }\\n\\n        int com= 0;\\n        \\n        map<int, queue<int>> mp;\\n\\n        for(int j = 0; com<tasks.size() ; j++)\\n        {\\n            if(pq.empty())\\n            {\\n                j = busy.top().first;\\n            }\\n\\n            while(!busy.empty() && busy.top().first <= j)\\n            {\\n                pq.push({servers[busy.top().second], busy.top().second});\\n                busy.pop();\\n            }\\n            \\n\\n            while(!pq.empty() && com < min(tasks.size(), j+1))\\n            {\\n                ans.push_back(pq.top().second);\\n                busy.push({j+ tasks[com], pq.top().second});\\n                com++;\\n                pq.pop();\\n            }\\n            \\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing T = pair<int, int>;\\nclass Solution {\\npublic:\\n\\n    int min(int a, int b)\\n    {\\n        if(a<b)\\n        return a;\\n        else\\n        return b;\\n    }\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<T, vector<T>, greater<T>> pq;\\n        priority_queue<T, vector<T>, greater<T>> busy;\\n        vector<int> ans;\\n\\n        for(int i = 0; i < servers.size(); i++)\\n        {\\n            pq.push({servers[i], i});\\n        }\\n\\n        int com= 0;\\n        \\n        map<int, queue<int>> mp;\\n\\n        for(int j = 0; com<tasks.size() ; j++)\\n        {\\n            if(pq.empty())\\n            {\\n                j = busy.top().first;\\n            }\\n\\n            while(!busy.empty() && busy.top().first <= j)\\n            {\\n                pq.push({servers[busy.top().second], busy.top().second});\\n                busy.pop();\\n            }\\n            \\n\\n            while(!pq.empty() && com < min(tasks.size(), j+1))\\n            {\\n                ans.push_back(pq.top().second);\\n                busy.push({j+ tasks[com], pq.top().second});\\n                com++;\\n                pq.pop();\\n            }\\n            \\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631983,
                "title": "python-two-heaps-available-servers-and-busy-servers",
                "content": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        n = len(servers)\\n        m = len(tasks)\\n        available = [] # [server_weight, server_index]\\n        busy = [] # [end_time, server_weight, server_index]\\n        for i, w in enumerate(servers):\\n            heapq.heappush(available, [w, i])\\n        ans = []\\n        for j in range(m):\\n            while busy and busy[0][0] == j:\\n                e, w, idx = heapq.heappop(busy)\\n                heapq.heappush(available, [w, idx])\\n            if available:\\n                w, idx = heapq.heappop(available)\\n                heapq.heappush(busy, (j + tasks[j], w, idx))\\n            else:\\n                e, w, idx = heapq.heappop(busy)\\n                heapq.heappush(busy, (e + tasks[j], w, idx))\\n            ans.append(idx)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        n = len(servers)\\n        m = len(tasks)\\n        available = [] # [server_weight, server_index]\\n        busy = [] # [end_time, server_weight, server_index]\\n        for i, w in enumerate(servers):\\n            heapq.heappush(available, [w, i])\\n        ans = []\\n        for j in range(m):\\n            while busy and busy[0][0] == j:\\n                e, w, idx = heapq.heappop(busy)\\n                heapq.heappush(available, [w, idx])\\n            if available:\\n                w, idx = heapq.heappop(available)\\n                heapq.heappush(busy, (j + tasks[j], w, idx))\\n            else:\\n                e, w, idx = heapq.heappop(busy)\\n                heapq.heappush(busy, (e + tasks[j], w, idx))\\n            ans.append(idx)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605999,
                "title": "readable-golang-solution",
                "content": "```\\nfunc assignTasks(servers []int, tasks []int) []int {\\n    n := len(tasks)\\n    order := []int{}\\n    busy := TaskHeap{}\\n    free := ServerHeap{}\\n    \\n    for i, server := range servers {\\n        heap.Push(&free, Server{index: i, weight: server})\\n    }\\n    \\n    t := 0\\n    i := 0\\n    \\n    for len(order) < n {\\n        for busy.Len() > 0 && busy[0].end <= t {\\n            task := heap.Pop(&busy).(Task)\\n            heap.Push(&free, Server(task.server))\\n        }\\n        \\n        if free.Len() == 0 {\\n            // fmt.Printf(\"t = %d, skipped to %d \\\\n\", t, busy[0].end)\\n            t = busy[0].end\\n            continue\\n        }\\n        \\n        // fmt.Printf(\"t = %d, free = %+v, busy = %+v \\\\n\", t, free, busy)\\n        \\n        task := tasks[i]\\n        server := heap.Pop(&free).(Server)\\n        order = append(order, server.index)\\n        heap.Push(&busy, Task{index: i, second: task, end: t + task, server: server})\\n        i += 1\\n        \\n        if i > t {\\n            t += 1\\n        }\\n    }\\n    \\n    return order\\n}\\n\\ntype Task struct {\\n\\tindex      int\\n    second     int\\n    end        int\\n    server     Server\\n}\\n\\ntype TaskHeap []Task\\n\\nfunc (h TaskHeap) Len() int { return len(h) }\\nfunc (h TaskHeap) Less(i, j int) bool {\\n\\treturn h[i].end < h[j].end\\n}\\nfunc (h TaskHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *TaskHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(Task))\\n}\\n\\nfunc (h *TaskHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n    *h = (*h)[0:len(*h)-1]\\n\\treturn x\\n}\\n\\ntype Server struct {\\n\\tindex      int\\n    weight     int\\n}\\n\\ntype ServerHeap []Server\\n\\nfunc (h ServerHeap) Len() int { return len(h) }\\nfunc (h ServerHeap) Less(i, j int) bool {\\n\\tif h[i].weight == h[j].weight {\\n\\t\\treturn h[i].index < h[j].index\\n\\t}\\n\\n\\treturn h[i].weight < h[j].weight\\n}\\nfunc (h ServerHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *ServerHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(Server))\\n}\\n\\nfunc (h *ServerHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n    *h = (*h)[0:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc assignTasks(servers []int, tasks []int) []int {\\n    n := len(tasks)\\n    order := []int{}\\n    busy := TaskHeap{}\\n    free := ServerHeap{}\\n    \\n    for i, server := range servers {\\n        heap.Push(&free, Server{index: i, weight: server})\\n    }\\n    \\n    t := 0\\n    i := 0\\n    \\n    for len(order) < n {\\n        for busy.Len() > 0 && busy[0].end <= t {\\n            task := heap.Pop(&busy).(Task)\\n            heap.Push(&free, Server(task.server))\\n        }\\n        \\n        if free.Len() == 0 {\\n            // fmt.Printf(\"t = %d, skipped to %d \\\\n\", t, busy[0].end)\\n            t = busy[0].end\\n            continue\\n        }\\n        \\n        // fmt.Printf(\"t = %d, free = %+v, busy = %+v \\\\n\", t, free, busy)\\n        \\n        task := tasks[i]\\n        server := heap.Pop(&free).(Server)\\n        order = append(order, server.index)\\n        heap.Push(&busy, Task{index: i, second: task, end: t + task, server: server})\\n        i += 1\\n        \\n        if i > t {\\n            t += 1\\n        }\\n    }\\n    \\n    return order\\n}\\n\\ntype Task struct {\\n\\tindex      int\\n    second     int\\n    end        int\\n    server     Server\\n}\\n\\ntype TaskHeap []Task\\n\\nfunc (h TaskHeap) Len() int { return len(h) }\\nfunc (h TaskHeap) Less(i, j int) bool {\\n\\treturn h[i].end < h[j].end\\n}\\nfunc (h TaskHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *TaskHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(Task))\\n}\\n\\nfunc (h *TaskHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n    *h = (*h)[0:len(*h)-1]\\n\\treturn x\\n}\\n\\ntype Server struct {\\n\\tindex      int\\n    weight     int\\n}\\n\\ntype ServerHeap []Server\\n\\nfunc (h ServerHeap) Len() int { return len(h) }\\nfunc (h ServerHeap) Less(i, j int) bool {\\n\\tif h[i].weight == h[j].weight {\\n\\t\\treturn h[i].index < h[j].index\\n\\t}\\n\\n\\treturn h[i].weight < h[j].weight\\n}\\nfunc (h ServerHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *ServerHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(Server))\\n}\\n\\nfunc (h *ServerHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n    *h = (*h)[0:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567193,
                "title": "python-two-heaps-w-comments",
                "content": "\\tclass Solution:\\n\\t\\tdef assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n\\t\\t\\tans = []\\n\\t\\t\\tfreeServers = []\\n\\t\\t\\tusedServers = []\\n\\n\\t\\t\\t# push all available severs into free server heap, smallest server weight on top\\n\\t\\t\\tfor idx, serverWeight in enumerate(servers):\\n\\t\\t\\t\\theapq.heappush(freeServers, (serverWeight, idx))\\n\\n\\t\\t\\t# iterate through each task\\n\\t\\t\\tfor idx, taskTime in enumerate(tasks):\\n\\t\\t\\t\\tcurTime = idx\\n\\n\\t\\t\\t\\t# while a servers completion time is less than or equal to curTime, pop it and add to free\\n\\t\\t\\t\\twhile usedServers and usedServers[0][0] <= curTime:\\n\\t\\t\\t\\t\\t_, w, i = heapq.heappop(usedServers)\\n\\t\\t\\t\\t\\theapq.heappush(freeServers, (w, i))\\n\\n\\t\\t\\t\\t# if there is a free server, use it\\n\\t\\t\\t\\tif freeServers:\\n\\t\\t\\t\\t\\tweight, i = heapq.heappop(freeServers)\\n\\t\\t\\t\\t\\tans.append(i)\\n\\n\\t\\t\\t\\t\\ttaskCompletion = curTime + taskTime\\n\\t\\t\\t\\t\\theapq.heappush(usedServers, (taskCompletion, weight, i))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# if no free server, top most used server will be next free, so update completion time \\n\\t\\t\\t\\t\\ttCompletion, weight, i = heapq.heappop(usedServers)\\n\\t\\t\\t\\t\\ttCompletion += taskTime\\n\\n\\t\\t\\t\\t\\theapq.heappush(usedServers, (tCompletion, weight, i))\\n\\t\\t\\t\\t\\tans.append(i)\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n\\t\\t\\tans = []\\n\\t\\t\\tfreeServers = []\\n\\t\\t\\tusedServers = []\\n\\n\\t\\t\\t# push all available severs into free server heap, smallest server weight on top\\n\\t\\t\\tfor idx, serverWeight in enumerate(servers):\\n\\t\\t\\t\\theapq.heappush(freeServers, (serverWeight, idx))\\n\\n\\t\\t\\t# iterate through each task\\n\\t\\t\\tfor idx, taskTime in enumerate(tasks):\\n\\t\\t\\t\\tcurTime = idx\\n\\n\\t\\t\\t\\t# while a servers completion time is less than or equal to curTime, pop it and add to free\\n\\t\\t\\t\\twhile usedServers and usedServers[0][0] <= curTime:\\n\\t\\t\\t\\t\\t_, w, i = heapq.heappop(usedServers)\\n\\t\\t\\t\\t\\theapq.heappush(freeServers, (w, i))\\n\\n\\t\\t\\t\\t# if there is a free server, use it\\n\\t\\t\\t\\tif freeServers:\\n\\t\\t\\t\\t\\tweight, i = heapq.heappop(freeServers)\\n\\t\\t\\t\\t\\tans.append(i)\\n\\n\\t\\t\\t\\t\\ttaskCompletion = curTime + taskTime\\n\\t\\t\\t\\t\\theapq.heappush(usedServers, (taskCompletion, weight, i))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# if no free server, top most used server will be next free, so update completion time \\n\\t\\t\\t\\t\\ttCompletion, weight, i = heapq.heappop(usedServers)\\n\\t\\t\\t\\t\\ttCompletion += taskTime\\n\\n\\t\\t\\t\\t\\theapq.heappush(usedServers, (tCompletion, weight, i))\\n\\t\\t\\t\\t\\tans.append(i)\\n\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2489109,
                "title": "simple-c-solution-using-heap-and-sets",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for (int i=0;i<servers.size();i++) pq.push({servers[i],i});\\n        vector<int> ans(tasks.size());\\n        set<pair<int,pair<int,int>>> s;\\n        int i=0,t=0;\\n        while (i<tasks.size()) {\\n            if (pq.empty()) t=s.begin()->first;\\n            for (auto j:s) {\\n                if (j.first==t) {\\n                    pq.push(j.second);\\n                    s.erase(j);\\n                }\\n                if (j.first>t) break;\\n            }\\n            while (i<=t&&i<tasks.size()&&pq.size()) {\\n                ans[i]=pq.top().second;\\n                s.insert({t+tasks[i],pq.top()});\\n                pq.pop();\\n                i++;\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for (int i=0;i<servers.size();i++) pq.push({servers[i],i});\\n        vector<int> ans(tasks.size());\\n        set<pair<int,pair<int,int>>> s;\\n        int i=0,t=0;\\n        while (i<tasks.size()) {\\n            if (pq.empty()) t=s.begin()->first;\\n            for (auto j:s) {\\n                if (j.first==t) {\\n                    pq.push(j.second);\\n                    s.erase(j);\\n                }\\n                if (j.first>t) break;\\n            }\\n            while (i<=t&&i<tasks.size()&&pq.size()) {\\n                ans[i]=pq.top().second;\\n                s.insert({t+tasks[i],pq.top()});\\n                pq.pop();\\n                i++;\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467953,
                "title": "time-complexity-explanation-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        //0 is index, 1 is weight, 2 is available time\\n        PriorityQueue<int[]> busyServer = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]);\\n        //0 is index, 1 is weight, 2 is available time\\n        PriorityQueue<int[]> freeServer = new PriorityQueue<int[]>((a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);\\n        for(int i = 0; i < servers.length; i++){\\n            freeServer.offer(new int[]{i, servers[i], 0});    \\n        }\\n        int time = 0;\\n        int[] ans = new int[tasks.length];\\n        for(int j = 0; j < tasks.length; j++){\\n            time = Math.max(time, j);\\n            while(!busyServer.isEmpty() && busyServer.peek()[2] <= time){\\n                int[] free = busyServer.poll();\\n                freeServer.offer(free);\\n            }\\n            if(freeServer.isEmpty()){\\n                time = busyServer.peek()[2];\\n                while(!busyServer.isEmpty() && busyServer.peek()[2] <= time){\\n                    int[] free = busyServer.poll();\\n                    freeServer.offer(free);\\n                }                \\n            }\\n            int[] assigned = freeServer.poll();\\n            assigned[2] = time + tasks[j];\\n            busyServer.offer(assigned);\\n            ans[j] = assigned[0];\\n        }\\n        return ans;\\n    }\\n}\\n//How to analyze time complexity?\\n//First, we have to notice that whenever there are free servers, each round in for-loop will only take O(log#server)\\n//Second, if there is no free server, we may put x busy servers into free server queue; after this, the next \"x\" rounds\\n//will only take O(log#server) each round again.\\n//Therefore, time complexisty is only O(#task*log(#server)), which is O(nlogn)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        //0 is index, 1 is weight, 2 is available time\\n        PriorityQueue<int[]> busyServer = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]);\\n        //0 is index, 1 is weight, 2 is available time\\n        PriorityQueue<int[]> freeServer = new PriorityQueue<int[]>((a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);\\n        for(int i = 0; i < servers.length; i++){\\n            freeServer.offer(new int[]{i, servers[i], 0});    \\n        }\\n        int time = 0;\\n        int[] ans = new int[tasks.length];\\n        for(int j = 0; j < tasks.length; j++){\\n            time = Math.max(time, j);\\n            while(!busyServer.isEmpty() && busyServer.peek()[2] <= time){\\n                int[] free = busyServer.poll();\\n                freeServer.offer(free);\\n            }\\n            if(freeServer.isEmpty()){\\n                time = busyServer.peek()[2];\\n                while(!busyServer.isEmpty() && busyServer.peek()[2] <= time){\\n                    int[] free = busyServer.poll();\\n                    freeServer.offer(free);\\n                }                \\n            }\\n            int[] assigned = freeServer.poll();\\n            assigned[2] = time + tasks[j];\\n            busyServer.offer(assigned);\\n            ans[j] = assigned[0];\\n        }\\n        return ans;\\n    }\\n}\\n//How to analyze time complexity?\\n//First, we have to notice that whenever there are free servers, each round in for-loop will only take O(log#server)\\n//Second, if there is no free server, we may put x busy servers into free server queue; after this, the next \"x\" rounds\\n//will only take O(log#server) each round again.\\n//Therefore, time complexisty is only O(#task*log(#server)), which is O(nlogn)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443940,
                "title": "pyton-clean-2-heap",
                "content": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [ (w, i) for i, w in enumerate(servers)]\\n        busy = []\\n        heapq.heapify(free)\\n        \\n        res = []\\n        elapsed = 0\\n        for i, t in enumerate(tasks):\\n            elapsed = max(i, elapsed)\\n            while busy and busy[0][0] <= elapsed:\\n                _, w, i = heapq.heappop(busy)\\n                heapq.heappush(free, (w, i))\\n                \\n            if free:\\n                w, i = heapq.heappop(free)\\n                heapq.heappush(busy, (elapsed + t, w, i))\\n                res.append(i)\\n                continue\\n            \\n            if busy:\\n                time, w, i = heapq.heappop(busy)\\n                elapsed = time\\n                heapq.heappush(busy, (elapsed + t, w, i))\\n                res.append(i)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        free = [ (w, i) for i, w in enumerate(servers)]\\n        busy = []\\n        heapq.heapify(free)\\n        \\n        res = []\\n        elapsed = 0\\n        for i, t in enumerate(tasks):\\n            elapsed = max(i, elapsed)\\n            while busy and busy[0][0] <= elapsed:\\n                _, w, i = heapq.heappop(busy)\\n                heapq.heappush(free, (w, i))\\n                \\n            if free:\\n                w, i = heapq.heappop(free)\\n                heapq.heappush(busy, (elapsed + t, w, i))\\n                res.append(i)\\n                continue\\n            \\n            if busy:\\n                time, w, i = heapq.heappop(busy)\\n                elapsed = time\\n                heapq.heappush(busy, (elapsed + t, w, i))\\n                res.append(i)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2441033,
                "title": "c-two-priorityqueues-used-free-servers",
                "content": "```csharp\\npublic class Solution {\\n    public int[] AssignTasks(int[] servers, int[] tasks) {\\n        // start with servers with minimum weight\\n        int[] result = new int[tasks.Length];\\n        var freeServers = new PriorityQueue<(int weight, int index), (int weight, int index)>();\\n        // time - time when server becomes free\\n        var usedServers = new PriorityQueue<(int time, int weight, int index), (int time, int weight, int index)>();\\n\\n        for (int i = 0; i < servers.Length; i++) {\\n            freeServers.Enqueue((servers[i], i), (servers[i], i));\\n        }\\n        int time = 0;\\n        for (int i = 0; i < tasks.Length; i++) {\\n            // by default, time == i, but it can be overriden (advanced)\\n            time = Math.Max(time, i); // if time was overriden (shifted), because there were no available servers, take that \\'time\\'\\n\\n            // there are no servers available - advance time to the next available time\\n            if (freeServers.Count == 0) {\\n                time = usedServers.Peek().time; // override time to the next available period. This is the time when a first server will be available\\n            }\\n            // check if any server became available - first try to pop used servers if available and put them into the free queue\\n            while(usedServers.Count > 0 && time >= usedServers.Peek().time) { // first available server for that time\\n                var (timeFree, w, idx) = usedServers.Dequeue(); // timeFree - used for priority\\n                freeServers.Enqueue((w, idx), (w, idx));\\n            }\\n            var (weight, index) = freeServers.Dequeue();\\n            result[i] = index;\\n            int timeServerBecomesFree = time + tasks[i];\\n            usedServers.Enqueue((timeServerBecomesFree, weight, index), (time + tasks[i], weight, index));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```csharp\\npublic class Solution {\\n    public int[] AssignTasks(int[] servers, int[] tasks) {\\n        // start with servers with minimum weight\\n        int[] result = new int[tasks.Length];\\n        var freeServers = new PriorityQueue<(int weight, int index), (int weight, int index)>();\\n        // time - time when server becomes free\\n        var usedServers = new PriorityQueue<(int time, int weight, int index), (int time, int weight, int index)>();\\n\\n        for (int i = 0; i < servers.Length; i++) {\\n            freeServers.Enqueue((servers[i], i), (servers[i], i));\\n        }\\n        int time = 0;\\n        for (int i = 0; i < tasks.Length; i++) {\\n            // by default, time == i, but it can be overriden (advanced)\\n            time = Math.Max(time, i); // if time was overriden (shifted), because there were no available servers, take that \\'time\\'\\n\\n            // there are no servers available - advance time to the next available time\\n            if (freeServers.Count == 0) {\\n                time = usedServers.Peek().time; // override time to the next available period. This is the time when a first server will be available\\n            }\\n            // check if any server became available - first try to pop used servers if available and put them into the free queue\\n            while(usedServers.Count > 0 && time >= usedServers.Peek().time) { // first available server for that time\\n                var (timeFree, w, idx) = usedServers.Dequeue(); // timeFree - used for priority\\n                freeServers.Enqueue((w, idx), (w, idx));\\n            }\\n            var (weight, index) = freeServers.Dequeue();\\n            result[i] = index;\\n            int timeServerBecomesFree = time + tasks[i];\\n            usedServers.Enqueue((timeServerBecomesFree, weight, index), (time + tasks[i], weight, index));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423294,
                "title": "java-solution-using-2-heaps",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> free = new PriorityQueue<int[]>((a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);\\n        PriorityQueue<int[]> used = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]);                                                   \\n\\t\\t\\n        for(int i = 0; i < servers.length; i++)\\n             free.offer(new int[]{i, servers[i], 0});                \\n\\t\\t\\t \\n        int[] ans = new int[tasks.length];\\n\\t\\t\\n        for(int i = 0; i < tasks.length; i++)\\n        {\\n            while(!used.isEmpty() && used.peek()[2] <= i)\\n                free.offer(used.poll());\\n            \\n            if(free.isEmpty())\\n            {\\n                int nextTime = used.peek()[2];\\n                while(!used.isEmpty() && used.peek()[2] == nextTime)\\n                    free.offer(used.poll());\\n            }\\n            \\n            int[] currentServer = free.poll();\\n            ans[i] = currentServer[0];\\n            currentServer[2] = Math.max(currentServer[2], i) + tasks[i];\\n            used.offer(currentServer);\\n        }                                                                                               \\n        return ans;                                                   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> free = new PriorityQueue<int[]>((a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);\\n        PriorityQueue<int[]> used = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]);                                                   \\n\\t\\t\\n        for(int i = 0; i < servers.length; i++)\\n             free.offer(new int[]{i, servers[i], 0});                \\n\\t\\t\\t \\n        int[] ans = new int[tasks.length];\\n\\t\\t\\n        for(int i = 0; i < tasks.length; i++)\\n        {\\n            while(!used.isEmpty() && used.peek()[2] <= i)\\n                free.offer(used.poll());\\n            \\n            if(free.isEmpty())\\n            {\\n                int nextTime = used.peek()[2];\\n                while(!used.isEmpty() && used.peek()[2] == nextTime)\\n                    free.offer(used.poll());\\n            }\\n            \\n            int[] currentServer = free.poll();\\n            ans[i] = currentServer[0];\\n            currentServer[2] = Math.max(currentServer[2], i) + tasks[i];\\n            used.offer(currentServer);\\n        }                                                                                               \\n        return ans;                                                   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409632,
                "title": "c-straightforward-solution-using-two-priority-queues",
                "content": "We can keep track of the current time. If all the servers are busy, we can fast forward our current time to the next earliest time a server will be free.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        // weight, index\\n        using Server = pair<int, int>;\\n        priority_queue<Server, vector<Server>, greater<Server>> avail_servers;\\n        priority_queue<pair<int, Server>, vector<pair<int, Server>>, greater<pair<int, Server>>> busy_servers;\\n        for (int i = 0; i < servers.size(); ++i) {\\n            avail_servers.push(make_pair(servers[i], i));\\n        }\\n        vector<int> result;\\n        int cur_time = 0;\\n        for (int i = 0; i < tasks.size(); ++i) {\\n            cur_time = max(cur_time, i);\\n            if (avail_servers.empty()) {\\n                cur_time = busy_servers.top().first;\\n            }\\n            while (!busy_servers.empty() && busy_servers.top().first <= cur_time) {\\n                avail_servers.push(busy_servers.top().second);\\n                busy_servers.pop();\\n            }\\n            Server cur_server = avail_servers.top();\\n            avail_servers.pop();\\n            result.push_back(cur_server.second);\\n            busy_servers.push(make_pair(cur_time + tasks[i], cur_server));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n        // weight, index\\n        using Server = pair<int, int>;\\n        priority_queue<Server, vector<Server>, greater<Server>> avail_servers;\\n        priority_queue<pair<int, Server>, vector<pair<int, Server>>, greater<pair<int, Server>>> busy_servers;\\n        for (int i = 0; i < servers.size(); ++i) {\\n            avail_servers.push(make_pair(servers[i], i));\\n        }\\n        vector<int> result;\\n        int cur_time = 0;\\n        for (int i = 0; i < tasks.size(); ++i) {\\n            cur_time = max(cur_time, i);\\n            if (avail_servers.empty()) {\\n                cur_time = busy_servers.top().first;\\n            }\\n            while (!busy_servers.empty() && busy_servers.top().first <= cur_time) {\\n                avail_servers.push(busy_servers.top().second);\\n                busy_servers.pop();\\n            }\\n            Server cur_server = avail_servers.top();\\n            avail_servers.pop();\\n            result.push_back(cur_server.second);\\n            busy_servers.push(make_pair(cur_time + tasks[i], cur_server));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324148,
                "title": "why-is-the-time-complexity-oftasks-log-ofservers",
                "content": "In order to populate the available heap, you may have to pop the unavailable heap multiple times if the current time on top there is <= the current time, which makes me doubt that its  #ofTasks*Log(#ofServers)?",
                "solutionTags": [],
                "code": "In order to populate the available heap, you may have to pop the unavailable heap multiple times if the current time on top there is <= the current time, which makes me doubt that its  #ofTasks*Log(#ofServers)?",
                "codeTag": "Unknown"
            },
            {
                "id": 2321937,
                "title": "c-using-2-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& ser, vector<int>& tasks) {\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> available;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> unavailable;\\n        \\n        int n = ser.size(),m = tasks.size();\\n        \\n        vector<int> ans;\\n        for(int i = 0;i<n;i++)\\n        {\\n            available.push({ser[i],i});\\n        }\\n        \\n        int t = 0;\\n        for(int j = 0;j<m;j++)\\n        {\\n            t = max(t,j);\\n            if(available.size()==0)\\n            {\\n                t = unavailable.top()[0];\\n            }\\n            while(unavailable.size() and unavailable.top()[0]<=t)\\n            {\\n                available.push({unavailable.top()[1],unavailable.top()[2]});\\n                unavailable.pop();\\n            }\\n            auto curr = available.top();\\n            available.pop();\\n            ans.push_back(curr[1]);\\n            unavailable.push({t+tasks[j],curr[0],curr[1]});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> assignTasks(vector<int>& ser, vector<int>& tasks) {\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> available;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> unavailable;\\n        \\n        int n = ser.size(),m = tasks.size();\\n        \\n        vector<int> ans;\\n        for(int i = 0;i<n;i++)\\n        {\\n            available.push({ser[i],i});\\n        }\\n        \\n        int t = 0;\\n        for(int j = 0;j<m;j++)\\n        {\\n            t = max(t,j);\\n            if(available.size()==0)\\n            {\\n                t = unavailable.top()[0];\\n            }\\n            while(unavailable.size() and unavailable.top()[0]<=t)\\n            {\\n                available.push({unavailable.top()[1],unavailable.top()[2]});\\n                unavailable.pop();\\n            }\\n            auto curr = available.top();\\n            available.pop();\\n            ans.push_back(curr[1]);\\n            unavailable.push({t+tasks[j],curr[0],curr[1]});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307179,
                "title": "my-java-tle-solution-using-heap-and-treemap",
                "content": "``` java\\n// TLE\\n// use a tree map to record after what seconds then what servers in use will be released to free\\n// use a heap to record the free servers with lower weight\\nclass Solution {\\n    class Server {\\n        int idx;\\n        int weight;\\n        Server(int idx, int weight) {\\n            this.idx = idx;\\n            this.weight = weight;\\n        }\\n    }\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int[] res = new int[tasks.length];\\n        PriorityQueue<Server> q = new PriorityQueue<>((a, b) -> a.weight - b.weight != 0 ? a.weight - b.weight : a.idx - b.idx);\\n        for (int i = 0; i < servers.length; i++) q.offer(new Server(i, servers[i]));\\n        TreeMap<Integer, List<Server>> map = new TreeMap<>();\\n        int passedSeconds = 0;\\n        for (int i = 0; i < tasks.length; i++) {\\n            passedSeconds = Math.max(passedSeconds, i);\\n            TreeMap<Integer, List<Server>> tmpMap = new TreeMap<>();\\n            if (i >= passedSeconds) {\\n                for (Server s : map.getOrDefault(1, new ArrayList<>())) q.offer(s); \\n                map.remove(1);\\n                for (int key : map.keySet()) tmpMap.put(key - 1, map.get(key));\\n                map = tmpMap;\\n                passedSeconds++;\\n            }\\n            if (q.isEmpty()) {\\n                tmpMap = new TreeMap<>();\\n                int k = map.keySet().iterator().next();\\n                for (Server s : map.get(k)) q.offer(s);\\n                map.remove(k);\\n                for (int key : map.keySet()) tmpMap.put(key - k, map.get(key));\\n                map = tmpMap;\\n                passedSeconds += k;\\n            }\\n            if (!map.containsKey(tasks[i])) map.put(tasks[i], new ArrayList<>());\\n            Server s = q.poll();\\n            map.get(tasks[i]).add(s);\\n            res[i] = s.idx;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\n// TLE\\n// use a tree map to record after what seconds then what servers in use will be released to free\\n// use a heap to record the free servers with lower weight\\nclass Solution {\\n    class Server {\\n        int idx;\\n        int weight;\\n        Server(int idx, int weight) {\\n            this.idx = idx;\\n            this.weight = weight;\\n        }\\n    }\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        int[] res = new int[tasks.length];\\n        PriorityQueue<Server> q = new PriorityQueue<>((a, b) -> a.weight - b.weight != 0 ? a.weight - b.weight : a.idx - b.idx);\\n        for (int i = 0; i < servers.length; i++) q.offer(new Server(i, servers[i]));\\n        TreeMap<Integer, List<Server>> map = new TreeMap<>();\\n        int passedSeconds = 0;\\n        for (int i = 0; i < tasks.length; i++) {\\n            passedSeconds = Math.max(passedSeconds, i);\\n            TreeMap<Integer, List<Server>> tmpMap = new TreeMap<>();\\n            if (i >= passedSeconds) {\\n                for (Server s : map.getOrDefault(1, new ArrayList<>())) q.offer(s); \\n                map.remove(1);\\n                for (int key : map.keySet()) tmpMap.put(key - 1, map.get(key));\\n                map = tmpMap;\\n                passedSeconds++;\\n            }\\n            if (q.isEmpty()) {\\n                tmpMap = new TreeMap<>();\\n                int k = map.keySet().iterator().next();\\n                for (Server s : map.get(k)) q.offer(s);\\n                map.remove(k);\\n                for (int key : map.keySet()) tmpMap.put(key - k, map.get(key));\\n                map = tmpMap;\\n                passedSeconds += k;\\n            }\\n            if (!map.containsKey(tasks[i])) map.put(tasks[i], new ArrayList<>());\\n            Server s = q.poll();\\n            map.get(tasks[i]).add(s);\\n            res[i] = s.idx;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257957,
                "title": "min-heap-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    class comp \\n    {\\n        public:\\n            bool operator() (pair<int, int> &a, pair<int, int> &b) \\n            {\\n                return a.first == b.first ? a.second > b.second : a.first > b.first;\\n            }\\n    };\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) \\n    {\\n        int n=servers.size();\\n        int m=tasks.size();\\n        vector<int>ans(m);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp>pq;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp>pq1;  \\n        for(int i=0;i<n;i++)pq.push({servers[i],i});\\n        vector<int>tmp(n,0);\\n         int tme=0;\\n        for(int i=0;i<m;i++)\\n        {  \\n            while(pq1.size()>0&&pq1.top().first<=i)\\n            {\\n                pair<int,int>p1=pq1.top();\\n                pq1.pop();\\n                pq.push({servers[p1.second],p1.second});\\n            }\\n            if(pq.size()==0)\\n            {\\n                tme=pq1.top().first;\\n                while(pq1.size()>0&&pq1.top().first==tme)\\n                {\\n                pair<int,int>p1=pq1.top();\\n                pq1.pop();\\n                pq.push({servers[p1.second],p1.second});\\n                tmp[p1.second]=tme;\\n                }\\n            }\\n            pair<int,int>pt=pq.top();\\n            pq.pop();\\n            tmp[pt.second]=max(tmp[pt.second],i);\\n            pq1.push({tasks[i]+tmp[pt.second],pt.second});\\n            ans[i]=pt.second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class comp \\n    {\\n        public:\\n            bool operator() (pair<int, int> &a, pair<int, int> &b) \\n            {\\n                return a.first == b.first ? a.second > b.second : a.first > b.first;\\n            }\\n    };\\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) \\n    {\\n        int n=servers.size();\\n        int m=tasks.size();\\n        vector<int>ans(m);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp>pq;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp>pq1;  \\n        for(int i=0;i<n;i++)pq.push({servers[i],i});\\n        vector<int>tmp(n,0);\\n         int tme=0;\\n        for(int i=0;i<m;i++)\\n        {  \\n            while(pq1.size()>0&&pq1.top().first<=i)\\n            {\\n                pair<int,int>p1=pq1.top();\\n                pq1.pop();\\n                pq.push({servers[p1.second],p1.second});\\n            }\\n            if(pq.size()==0)\\n            {\\n                tme=pq1.top().first;\\n                while(pq1.size()>0&&pq1.top().first==tme)\\n                {\\n                pair<int,int>p1=pq1.top();\\n                pq1.pop();\\n                pq.push({servers[p1.second],p1.second});\\n                tmp[p1.second]=tme;\\n                }\\n            }\\n            pair<int,int>pt=pq.top();\\n            pq.pop();\\n            tmp[pt.second]=max(tmp[pt.second],i);\\n            pq1.push({tasks[i]+tmp[pt.second],pt.second});\\n            ans[i]=pt.second;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250398,
                "title": "java-time-o-nlogn-space-o-n-two-heaps",
                "content": "```\\n//at first, this problem seems kinda overwhelming, but if you start to work on one example \\n//like I did down below, you will gradually figure out, you need two queues (with priority)\\n//to achieve this function ... it\\'s a great problem, more like a system design i think.\\n\\n//there is one thing I felt quite tricky to get right is the time, at first, I mentained a variable\\n//t, and tried to update it simulating the whole process, but then my code could not pass\\n//#36 test case, stuck on it for 10 mins.....\\n\\n//later, I discard the time variable, and simply used the index of tasks.\\n\\n//logic :\\n\\t//1. you want to use a idle queue as well as a using queue for servers\\n\\t//2. at every index of task, you first check if any servers can be freed\\n\\t//3. after server state are updated, you check whether idle queue is empty\\n\\t//4. if idle queue is not empty, swell, you assign the server with the first priority\\n\\t//5. if idle queue is empty, you go to using queue, you use the top element in using queue\\n\\t//6. you update this top element and add it back to using queue\\n\\t\\n\\t\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        int n = servers.length, m = tasks.length;\\n        \\n        //index 0:server ID, index 1:server weight\\n        PriorityQueue<int[]> idle = new PriorityQueue<>((a,b)->(a[1]==b[1]?a[0]-b[0]:a[1]-b[1]));\\n        for(int i=0;i<n;i++)\\n            idle.offer(new int[]{i,servers[i]});\\n        \\n        //index 0:server ID, index 1:server weight, index 2:free time\\n        PriorityQueue<int[]> using = new PriorityQueue<>((a,b)->(a[2]==b[2]?(a[1]==b[1]?a[0]-b[0]:a[1]-b[1]):a[2]-b[2]));\\n        \\n        \\n        int[] answer = new int[m];\\n        \\n        //int t = 0;\\n        for(int i=0;i<m;i++){\\n            int task = tasks[i];\\n            while(!using.isEmpty()&&using.peek()[2]<=i){\\n                int[] tmp = using.poll();\\n                idle.offer(new int[]{tmp[0],tmp[1]});\\n            }\\n            \\n            if(!idle.isEmpty()){\\n                int[] tmp = idle.poll();\\n                answer[i] = tmp[0];\\n                using.offer(new int[]{tmp[0],tmp[1],i+task});\\n            }else{\\n                int[] tmp = using.poll();\\n                tmp[2] += task;\\n                answer[i] = tmp[0];\\n                using.offer(new int[]{tmp[0],tmp[1],tmp[2]});\\n            }         \\n        }\\n        return answer;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n//servers = [3 3 2]\\n//tasks = [1, 2, 3, 2, 1, 2]\\n\\n//at time 0 : servers = [false, false, false]\\n//                         3      3      2\\n//assign 1 to servers = [false, false, true (last till 1)]  => 2\\n//\\n//\\n//at time 1 : servers = [false, false, false]\\n//                         3      3      2\\n//assign 2 to servers = [false, false, true (last till 3)] => 2\\n//\\n//\\n//at time 2 : servers = [false, false, true (last till 3)]\\n//\\n//assign 3 to servers = [true (last till 5), false, true, (last till 3)] => 0\\n//\\n//\\n//at time 3 : servers = [true (last till 5), false, false]\\n//assign 2 to servers = [true(last till 5), false, true (last till 5)] => 2\\n//\\n//\\n//at time 4 : servers = [true (5), false, true (5)]\\n//assign 1 to servers = [true(5),true(5),true(5)] => 1\\n//\\n//\\n//at time 5 : servers = [false, false, false]\\n//assign 2 to servers = [false, false, true(7)] =>2\\n\\n\\n// m = 2*10^5\\n// at every time i, we need to update servers, we need to do it O(1)\\n// we also need to find a server with smallest weight, priorityqueue?\\n\\n\\n// data structure : servers in use, server ID, server weight, freeing time\\n// data structure : servers in idle, server ID, server weight\\n\\n\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//at first, this problem seems kinda overwhelming, but if you start to work on one example \\n//like I did down below, you will gradually figure out, you need two queues (with priority)\\n//to achieve this function ... it\\'s a great problem, more like a system design i think.\\n\\n//there is one thing I felt quite tricky to get right is the time, at first, I mentained a variable\\n//t, and tried to update it simulating the whole process, but then my code could not pass\\n//#36 test case, stuck on it for 10 mins.....\\n\\n//later, I discard the time variable, and simply used the index of tasks.\\n\\n//logic :\\n\\t//1. you want to use a idle queue as well as a using queue for servers\\n\\t//2. at every index of task, you first check if any servers can be freed\\n\\t//3. after server state are updated, you check whether idle queue is empty\\n\\t//4. if idle queue is not empty, swell, you assign the server with the first priority\\n\\t//5. if idle queue is empty, you go to using queue, you use the top element in using queue\\n\\t//6. you update this top element and add it back to using queue\\n\\t\\n\\t\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        \\n        int n = servers.length, m = tasks.length;\\n        \\n        //index 0:server ID, index 1:server weight\\n        PriorityQueue<int[]> idle = new PriorityQueue<>((a,b)->(a[1]==b[1]?a[0]-b[0]:a[1]-b[1]));\\n        for(int i=0;i<n;i++)\\n            idle.offer(new int[]{i,servers[i]});\\n        \\n        //index 0:server ID, index 1:server weight, index 2:free time\\n        PriorityQueue<int[]> using = new PriorityQueue<>((a,b)->(a[2]==b[2]?(a[1]==b[1]?a[0]-b[0]:a[1]-b[1]):a[2]-b[2]));\\n        \\n        \\n        int[] answer = new int[m];\\n        \\n        //int t = 0;\\n        for(int i=0;i<m;i++){\\n            int task = tasks[i];\\n            while(!using.isEmpty()&&using.peek()[2]<=i){\\n                int[] tmp = using.poll();\\n                idle.offer(new int[]{tmp[0],tmp[1]});\\n            }\\n            \\n            if(!idle.isEmpty()){\\n                int[] tmp = idle.poll();\\n                answer[i] = tmp[0];\\n                using.offer(new int[]{tmp[0],tmp[1],i+task});\\n            }else{\\n                int[] tmp = using.poll();\\n                tmp[2] += task;\\n                answer[i] = tmp[0];\\n                using.offer(new int[]{tmp[0],tmp[1],tmp[2]});\\n            }         \\n        }\\n        return answer;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n//servers = [3 3 2]\\n//tasks = [1, 2, 3, 2, 1, 2]\\n\\n//at time 0 : servers = [false, false, false]\\n//                         3      3      2\\n//assign 1 to servers = [false, false, true (last till 1)]  => 2\\n//\\n//\\n//at time 1 : servers = [false, false, false]\\n//                         3      3      2\\n//assign 2 to servers = [false, false, true (last till 3)] => 2\\n//\\n//\\n//at time 2 : servers = [false, false, true (last till 3)]\\n//\\n//assign 3 to servers = [true (last till 5), false, true, (last till 3)] => 0\\n//\\n//\\n//at time 3 : servers = [true (last till 5), false, false]\\n//assign 2 to servers = [true(last till 5), false, true (last till 5)] => 2\\n//\\n//\\n//at time 4 : servers = [true (5), false, true (5)]\\n//assign 1 to servers = [true(5),true(5),true(5)] => 1\\n//\\n//\\n//at time 5 : servers = [false, false, false]\\n//assign 2 to servers = [false, false, true(7)] =>2\\n\\n\\n// m = 2*10^5\\n// at every time i, we need to update servers, we need to do it O(1)\\n// we also need to find a server with smallest weight, priorityqueue?\\n\\n\\n// data structure : servers in use, server ID, server weight, freeing time\\n// data structure : servers in idle, server ID, server weight\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235874,
                "title": "priority-queue-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    class ComparisonClass {\\n        public:\\n            bool operator() (pair<int, int> &a, pair<int, int> &b) {\\n                return a.first == b.first ? a.second > b.second : a.first > b.first;\\n            }\\n    };\\n    \\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> busy;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, ComparisonClass> free;\\n        \\n        for(int i=0;i<servers.size();i++){\\n            free.push({servers[i], i});\\n        }\\n        \\n        vector<int> res;\\n        \\n        int i = 0;\\n        int currTime = 0;\\n                \\n        while(i<tasks.size()){\\n            \\n            while(!busy.empty() && busy.top().first <= i){\\n                auto top = busy.top();\\n                busy.pop();\\n                free.push({servers[top.second], top.second});\\n            }\\n            \\n            if(free.empty()){\\n                auto top = busy.top();\\n                currTime = top.first;\\n                busy.pop();\\n                free.push({servers[top.second], top.second});\\n                while(!busy.empty() && busy.top().first == top.first){\\n                    top = busy.top();\\n                    busy.pop();\\n                    free.push({servers[top.second], top.second});\\n                }\\n            }\\n            else if(currTime < i) currTime = i;\\n            \\n            auto top = free.top();\\n            free.pop();\\n            res.push_back(top.second);\\n            int expire = tasks[i]+currTime;\\n            busy.push({expire, top.second});\\n            i++;\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    class ComparisonClass {\\n        public:\\n            bool operator() (pair<int, int> &a, pair<int, int> &b) {\\n                return a.first == b.first ? a.second > b.second : a.first > b.first;\\n            }\\n    };\\n    \\n    vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {\\n \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> busy;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, ComparisonClass> free;\\n        \\n        for(int i=0;i<servers.size();i++){\\n            free.push({servers[i], i});\\n        }\\n        \\n        vector<int> res;\\n        \\n        int i = 0;\\n        int currTime = 0;\\n                \\n        while(i<tasks.size()){\\n            \\n            while(!busy.empty() && busy.top().first <= i){\\n                auto top = busy.top();\\n                busy.pop();\\n                free.push({servers[top.second], top.second});\\n            }\\n            \\n            if(free.empty()){\\n                auto top = busy.top();\\n                currTime = top.first;\\n                busy.pop();\\n                free.push({servers[top.second], top.second});\\n                while(!busy.empty() && busy.top().first == top.first){\\n                    top = busy.top();\\n                    busy.pop();\\n                    free.push({servers[top.second], top.second});\\n                }\\n            }\\n            else if(currTime < i) currTime = i;\\n            \\n            auto top = free.top();\\n            free.pop();\\n            res.push_back(top.second);\\n            int expire = tasks[i]+currTime;\\n            busy.push({expire, top.second});\\n            i++;\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202973,
                "title": "python3-two-heaps-with-comments",
                "content": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        idle = [(weight, idx) for idx, weight in enumerate(servers)]\\n        heapq.heapify(idle)\\n        \\n        # done_time, weight, idx\\n        busy = []\\n        \\n        res = []\\n        curr_time = 0\\n        \\n        for t, task in enumerate(tasks):\\n            # if curr_time is less than t then curr_time = t because time has advanced when getting the next task\\n            # else if curr_time is greater than t then we \"wait\" till curr_time\\n            curr_time = max(curr_time, t)\\n            \\n            # drain busy heap for all tasks that are done before curr_time\\n            while busy and busy[0][0] <= curr_time:\\n                done_time, weight, idx = heapq.heappop(busy)\\n                curr_time = done_time\\n                heapq.heappush(idle, (weight, idx))\\n                \\n            # if there are no servers idle, pull one from busy and jump time\\n            if not idle:\\n                done_time, weight, idx = heapq.heappop(busy)\\n                curr_time = done_time\\n                heapq.heappush(idle, (weight, idx))\\n            \\n            # at this point we have an available server for current task\\n            weight, idx = heapq.heappop(idle)\\n            res.append(idx)\\n            # push done_time to busy heap\\n            heapq.heappush(busy, (curr_time + task, weight, idx))\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        idle = [(weight, idx) for idx, weight in enumerate(servers)]\\n        heapq.heapify(idle)\\n        \\n        # done_time, weight, idx\\n        busy = []\\n        \\n        res = []\\n        curr_time = 0\\n        \\n        for t, task in enumerate(tasks):\\n            # if curr_time is less than t then curr_time = t because time has advanced when getting the next task\\n            # else if curr_time is greater than t then we \"wait\" till curr_time\\n            curr_time = max(curr_time, t)\\n            \\n            # drain busy heap for all tasks that are done before curr_time\\n            while busy and busy[0][0] <= curr_time:\\n                done_time, weight, idx = heapq.heappop(busy)\\n                curr_time = done_time\\n                heapq.heappush(idle, (weight, idx))\\n                \\n            # if there are no servers idle, pull one from busy and jump time\\n            if not idle:\\n                done_time, weight, idx = heapq.heappop(busy)\\n                curr_time = done_time\\n                heapq.heappush(idle, (weight, idx))\\n            \\n            # at this point we have an available server for current task\\n            weight, idx = heapq.heappop(idle)\\n            res.append(idx)\\n            # push done_time to busy heap\\n            heapq.heappush(busy, (curr_time + task, weight, idx))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124659,
                "title": "python-two-heaps",
                "content": "```\\nimport heapq as hq\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        heap = []\\n        res = []\\n        working = []\\n        time = 0\\n        for i in range(len(servers)):\\n            hq.heappush(heap, [servers[i], i])\\n        for begin in range(len(tasks)):\\n            task = tasks[begin]\\n            time = max(time, begin)\\n            # correct time when there is a wait for availibilities\\n            if not heap:\\n                time = working[0][0]\\n            while working and working[0][0] <= time:\\n                _, server_w, server_i = hq.heappop(working)\\n                hq.heappush(heap, [server_w, server_i])\\n            server_w, server_i = hq.heappop(heap)\\n            hq.heappush(working, [time+task, server_w, server_i])\\n            res.append(server_i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq as hq\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        heap = []\\n        res = []\\n        working = []\\n        time = 0\\n        for i in range(len(servers)):\\n            hq.heappush(heap, [servers[i], i])\\n        for begin in range(len(tasks)):\\n            task = tasks[begin]\\n            time = max(time, begin)\\n            # correct time when there is a wait for availibilities\\n            if not heap:\\n                time = working[0][0]\\n            while working and working[0][0] <= time:\\n                _, server_w, server_i = hq.heappop(working)\\n                hq.heappush(heap, [server_w, server_i])\\n            server_w, server_i = hq.heappop(heap)\\n            hq.heappush(working, [time+task, server_w, server_i])\\n            res.append(server_i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124305,
                "title": "java-two-priority-queues-o-nlgn",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> serverQ = new PriorityQueue<>(\\n            (int[] s1, int[] s2) -> (s1[1] != s2[1]) ? Integer.compare(s1[1], s2[1]) : Integer.compare(s1[0], s2[0])\\n        );\\n        \\n        PriorityQueue <int[]> jobsQ = new PriorityQueue<>( (int[] s1, int[] s2) -> Integer.compare(s1[2], s2[2]));\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            // 0 => server index\\n            // 1 => priority\\n            // 2 => time available\\n            serverQ.add(new int[]{i, servers[i], 0});\\n        }\\n        \\n        int[] ans = new int[tasks.length];\\n        \\n        for (int t = 0; t < tasks.length; t++) {\\n\\t\\t\\t// relese servers which done by time t\\n            while ( ! jobsQ.isEmpty() && jobsQ.peek()[2] <= t) {\\n                serverQ.add(jobsQ.poll());\\n            }\\n           \\n\\t\\t\\t// if still no server available by time t, release all servers which availalbe at next t\\n            if (serverQ.isEmpty()) {\\n                int ti = jobsQ.peek()[2];\\n                while (! jobsQ.isEmpty() && jobsQ.peek()[2] == ti) {\\n                    serverQ.add(jobsQ.poll());    \\n                }\\n            }\\n            \\n            int[] s = serverQ.poll();\\n            \\n            ans[t] = s[0];\\n            \\n            s[2] = (s[2] < t) ? (t+tasks[t]) : (s[2]+tasks[t]);\\n            jobsQ.add(s);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<int[]> serverQ = new PriorityQueue<>(\\n            (int[] s1, int[] s2) -> (s1[1] != s2[1]) ? Integer.compare(s1[1], s2[1]) : Integer.compare(s1[0], s2[0])\\n        );\\n        \\n        PriorityQueue <int[]> jobsQ = new PriorityQueue<>( (int[] s1, int[] s2) -> Integer.compare(s1[2], s2[2]));\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            // 0 => server index\\n            // 1 => priority\\n            // 2 => time available\\n            serverQ.add(new int[]{i, servers[i], 0});\\n        }\\n        \\n        int[] ans = new int[tasks.length];\\n        \\n        for (int t = 0; t < tasks.length; t++) {\\n\\t\\t\\t// relese servers which done by time t\\n            while ( ! jobsQ.isEmpty() && jobsQ.peek()[2] <= t) {\\n                serverQ.add(jobsQ.poll());\\n            }\\n           \\n\\t\\t\\t// if still no server available by time t, release all servers which availalbe at next t\\n            if (serverQ.isEmpty()) {\\n                int ti = jobsQ.peek()[2];\\n                while (! jobsQ.isEmpty() && jobsQ.peek()[2] == ti) {\\n                    serverQ.add(jobsQ.poll());    \\n                }\\n            }\\n            \\n            int[] s = serverQ.poll();\\n            \\n            ans[t] = s[0];\\n            \\n            s[2] = (s[2] < t) ? (t+tasks[t]) : (s[2]+tasks[t]);\\n            jobsQ.add(s);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036799,
                "title": "java-heap-o-nlgn",
                "content": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server> occupied = new PriorityQueue<>((a, b) -> {\\n            if (a.endTime != b.endTime) {\\n                return a.endTime - b.endTime;\\n            } else if (a.weight != b.weight){\\n                return a.weight - b.weight;\\n            } else {\\n                return a.index - b.index;\\n            }\\n        });\\n\\n        PriorityQueue<Server> available = new PriorityQueue<>((a, b) -> {\\n            if (a.weight != b.weight){\\n                return a.weight - b.weight;\\n            } else {\\n                return a.index - b.index;\\n            }\\n        });\\n        for (int i = 0; i < servers.length; i++) {\\n            available.add(new Server(i, 0, servers[i]));\\n        }\\n        int[] res = new int[tasks.length]; \\n        for (int j = 0; j < tasks.length; j++) {\\n\\t\\t//when a server is available, put it into the \"available\" heap \\n            while (!occupied.isEmpty() && occupied.peek().endTime <= j) {\\n                Server cur = occupied.poll();\\n                available.add(cur);\\n            }\\n\\t\\t//always check wether there is an available server  \\n            if (!available.isEmpty()) {\\n                Server toUse = available.poll();\\n                toUse.endTime = j + tasks[j];\\n                res[j] = toUse.index;\\n                occupied.add(toUse);                \\n            } else {    //if there is no available servers, use the server that has earliset end time, smallest weight and index  \\n                Server toUse = occupied.poll();\\n                toUse.endTime += tasks[j];\\n                res[j] = toUse.index;\\n                occupied.add(toUse);         \\n            }\\n        }\\n        return res;\\n    }\\n    class Server{\\n        int endTime;\\n        int index;\\n        int weight;\\n        public Server(int index, int t, int w) {\\n            this.index = index;\\n            this.endTime = t;\\n            this.weight = w;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server> occupied = new PriorityQueue<>((a, b) -> {\\n            if (a.endTime != b.endTime) {\\n                return a.endTime - b.endTime;\\n            } else if (a.weight != b.weight){\\n                return a.weight - b.weight;\\n            } else {\\n                return a.index - b.index;\\n            }\\n        });\\n\\n        PriorityQueue<Server> available = new PriorityQueue<>((a, b) -> {\\n            if (a.weight != b.weight){\\n                return a.weight - b.weight;\\n            } else {\\n                return a.index - b.index;\\n            }\\n        });\\n        for (int i = 0; i < servers.length; i++) {\\n            available.add(new Server(i, 0, servers[i]));\\n        }\\n        int[] res = new int[tasks.length]; \\n        for (int j = 0; j < tasks.length; j++) {\\n\\t\\t//when a server is available, put it into the \"available\" heap \\n            while (!occupied.isEmpty() && occupied.peek().endTime <= j) {\\n                Server cur = occupied.poll();\\n                available.add(cur);\\n            }\\n\\t\\t//always check wether there is an available server  \\n            if (!available.isEmpty()) {\\n                Server toUse = available.poll();\\n                toUse.endTime = j + tasks[j];\\n                res[j] = toUse.index;\\n                occupied.add(toUse);                \\n            } else {    //if there is no available servers, use the server that has earliset end time, smallest weight and index  \\n                Server toUse = occupied.poll();\\n                toUse.endTime += tasks[j];\\n                res[j] = toUse.index;\\n                occupied.add(toUse);         \\n            }\\n        }\\n        return res;\\n    }\\n    class Server{\\n        int endTime;\\n        int index;\\n        int weight;\\n        public Server(int index, int t, int w) {\\n            this.index = index;\\n            this.endTime = t;\\n            this.weight = w;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032803,
                "title": "understandable-java-code-using-two-min-heap-without-explanation",
                "content": "```\\nclass Solution {\\n    class Server{\\n        int time;int weight;int idx;\\n        Server(int t, int w, int i) {\\n            time = t;weight = w;idx = i;\\n        }\\n    }\\n    class WeightComparator implements Comparator<Server> {\\n        public int compare(Server one, Server two) {\\n            int c = Integer.compare(one.weight, two.weight);\\n            if (c == 0) c = Integer.compare(one.idx, two.idx);\\n            return c;\\n        }\\n    }\\n    class TimeComparator implements Comparator<Server> {\\n        public int compare(Server one, Server two) {\\n            int c = Integer.compare(one.time, two.time);\\n            return c;\\n        }\\n    }\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server> available = new PriorityQueue(new WeightComparator());\\n        PriorityQueue<Server> occupied = new PriorityQueue(new TimeComparator());\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            available.offer (new Server(0, servers[i], i));\\n        }\\n        \\n        int t = 0;\\n        for (int i = 0; i < tasks.length; i++) {\\n            t = Math.max(i, t);\\n            if (available.isEmpty()) {\\n                t = occupied.peek().time;\\n            }\\n            while (!occupied.isEmpty() && occupied.peek().time <= t) {\\n                available.offer(occupied.poll());\\n            }\\n            Server s = available.poll();\\n            s.time = t + tasks[i];\\n            tasks[i] = s.idx;\\n            occupied.offer(s);\\n        }\\n        return tasks;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Server{\\n        int time;int weight;int idx;\\n        Server(int t, int w, int i) {\\n            time = t;weight = w;idx = i;\\n        }\\n    }\\n    class WeightComparator implements Comparator<Server> {\\n        public int compare(Server one, Server two) {\\n            int c = Integer.compare(one.weight, two.weight);\\n            if (c == 0) c = Integer.compare(one.idx, two.idx);\\n            return c;\\n        }\\n    }\\n    class TimeComparator implements Comparator<Server> {\\n        public int compare(Server one, Server two) {\\n            int c = Integer.compare(one.time, two.time);\\n            return c;\\n        }\\n    }\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n        PriorityQueue<Server> available = new PriorityQueue(new WeightComparator());\\n        PriorityQueue<Server> occupied = new PriorityQueue(new TimeComparator());\\n        \\n        for (int i = 0; i < servers.length; i++) {\\n            available.offer (new Server(0, servers[i], i));\\n        }\\n        \\n        int t = 0;\\n        for (int i = 0; i < tasks.length; i++) {\\n            t = Math.max(i, t);\\n            if (available.isEmpty()) {\\n                t = occupied.peek().time;\\n            }\\n            while (!occupied.isEmpty() && occupied.peek().time <= t) {\\n                available.offer(occupied.poll());\\n            }\\n            Server s = available.poll();\\n            s.time = t + tasks[i];\\n            tasks[i] = s.idx;\\n            occupied.offer(s);\\n        }\\n        return tasks;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029137,
                "title": "java-with-only-2-min-heaps",
                "content": "class ServerPair {\\n  int weight;\\n  int index;\\n\\n  ServerPair(int weight, int index){\\n    this.weight = weight;\\n    this.index = index;\\n  }\\n }\\n\\n class Triplet {\\n  int timeFree;\\n  int weight;\\n  int index;\\n\\n  Triplet(int timeFree, int weight, int index){\\n    this.timeFree = timeFree;\\n    this.weight = weight;\\n    this.index = index;\\n  }\\n }\\n\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n       PriorityQueue<ServerPair> available = new PriorityQueue<>(( ServerPair i1, ServerPair i2)->\\n         {\\n             if(i1.weight==i2.weight)\\n             {\\n                 return i1.index - i2.index;\\n             }\\n             else\\n             {\\n                 return i1.weight - i2.weight;\\n             }\\n         });\\n        for(int i = 0; i < servers.length; i++)\\n        {\\n            available.offer(new ServerPair(servers[i],i));\\n        }\\n        \\n        PriorityQueue<Triplet> unavail = new PriorityQueue<>(( Triplet i1, Triplet i2)->\\n         {\\n             if(i1.timeFree==i2.timeFree)\\n             {\\n                 return i1.index - i2.index;\\n             }\\n             else\\n             {\\n                 return i1.timeFree - i2.timeFree;\\n             }\\n         });\\n        int time = 0;\\n        int[] res = new int[tasks.length];\\n        for(int i = 0; i < tasks.length; i++)\\n        {\\n            time = Math.max(time, i);\\n            if(available.size()==0){\\n                time = unavail.peek().timeFree;\\n            }\\n            while(unavail.size() > 0 && time >= unavail.peek().timeFree){\\n              Triplet t = unavail.poll();\\n              available.offer(new ServerPair(t.weight, t.index));\\n            }\\n            \\n            ServerPair server = available.poll();\\n            res[i] = server.index;\\n            unavail.offer(new Triplet(time+tasks[i], server.weight, server.index));\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n       PriorityQueue<ServerPair> available = new PriorityQueue<>(( ServerPair i1, ServerPair i2)->\\n         {\\n             if(i1.weight==i2.weight)\\n             {\\n                 return i1.index - i2.index;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2016084,
                "title": "simulation-with-comments",
                "content": "```cpp\\n// available server<weight, server id>\\n// processing task<duration, task id>\\n// queueing task<task id>\\npriority_queue<\\n\\tpair<int, int>, \\n\\tvector<pair<int, int>>, \\n\\tgreater<pair<int, int>>\\n> available, processing;\\nqueue<int> queueing;\\n\\nint n = servers.size();\\nint m = tasks.size();\\nvector<int> ret(m);\\n\\n// all servers are initially available\\nfor (int i = 0; i < n; ++i)\\n\\tavailable.push({servers[i], i});\\n\\n// the current time\\nint t = 0;\\n\\n// put first task into queueing\\nqueueing.push(0);\\n\\n// keep loop while there are any task in waiting.\\nwhile (queueing.size())\\n{\\n\\t// if there are any processing task has been done, \\n\\t// the server become available.\\n\\twhile (processing.size() && processing.top().first <= t)\\n\\t{\\n\\t\\tint sid = processing.top().second;\\n\\t\\tavailable.push({servers[sid], sid});\\n\\t\\tprocessing.pop();\\n\\t}\\n\\t\\n\\t// if there are any available server and any waiting task,\\n\\t// assign them and put the task into processing queue.\\n\\twhile (available.size() && queueing.size())\\n\\t{\\n\\t\\tint tid = queueing.front();\\n\\t\\tint sid = available.top().second;\\n\\t\\tret[tid] = sid;\\n\\t\\tprocessing.push({t + tasks[tid], sid});\\n\\t\\t\\n\\t\\tavailable.pop();\\n\\t\\tqueueing.pop();\\n\\t}\\n\\t\\n\\t// while there are more in-question tasks\\n\\tif (++ t < m)\\n\\t\\tqueueing.push(t);\\n\\t// after all the in-question tasks have been put into waiting queue, \\n\\t// jump the time to the finishing time of the nearest processing task, if there are any.\\n\\telse if (processing.size())\\n\\t\\tt = processing.top().first;\\n}\\n\\nreturn ret;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```cpp\\n// available server<weight, server id>\\n// processing task<duration, task id>\\n// queueing task<task id>\\npriority_queue<\\n\\tpair<int, int>, \\n\\tvector<pair<int, int>>, \\n\\tgreater<pair<int, int>>\\n> available, processing;\\nqueue<int> queueing;\\n\\nint n = servers.size();\\nint m = tasks.size();\\nvector<int> ret(m);\\n\\n// all servers are initially available\\nfor (int i = 0; i < n; ++i)\\n\\tavailable.push({servers[i], i});\\n\\n// the current time\\nint t = 0;\\n\\n// put first task into queueing\\nqueueing.push(0);\\n\\n// keep loop while there are any task in waiting.\\nwhile (queueing.size())\\n{\\n\\t// if there are any processing task has been done, \\n\\t// the server become available.\\n\\twhile (processing.size() && processing.top().first <= t)\\n\\t{\\n\\t\\tint sid = processing.top().second;\\n\\t\\tavailable.push({servers[sid], sid});\\n\\t\\tprocessing.pop();\\n\\t}\\n\\t\\n\\t// if there are any available server and any waiting task,\\n\\t// assign them and put the task into processing queue.\\n\\twhile (available.size() && queueing.size())\\n\\t{\\n\\t\\tint tid = queueing.front();\\n\\t\\tint sid = available.top().second;\\n\\t\\tret[tid] = sid;\\n\\t\\tprocessing.push({t + tasks[tid], sid});\\n\\t\\t\\n\\t\\tavailable.pop();\\n\\t\\tqueueing.pop();\\n\\t}\\n\\t\\n\\t// while there are more in-question tasks\\n\\tif (++ t < m)\\n\\t\\tqueueing.push(t);\\n\\t// after all the in-question tasks have been put into waiting queue, \\n\\t// jump the time to the finishing time of the nearest processing task, if there are any.\\n\\telse if (processing.size())\\n\\t\\tt = processing.top().first;\\n}\\n\\nreturn ret;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1941086,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "servers\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\ntasks\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\n\n\nThis test case probably incorrect! \nExpected output:\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5, \n 36,56, 55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\n\nI marked the wrong place. server#56 has to start doing task before server#36 because both of them free at that moment and do not have any current task. However, 56 server has weigh (147) lower than server#36(889).\nHave anybody also got this problem? \n\nOr can anyone answer. When I get few free servers at the same time. What server I have to pick next? With lower index or weigh?? "
                    },
                    {
                        "username": "ddubrava",
                        "content": " ith task becomes available at the ith second"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "[@miles_1337](/miles_1337) dude your test case is gold! i use a simple if statement to deal with backlogging, works perfectly!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) yes! I waste 8 hours in total to resolve it. Many times I just erased code and started again. A tried a lot of ways to resolve this. And every time I got different test cases fail. Finally, I have resolved it. And this task is totally hell! A have never wasted so much time to one problem here!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@miles_1337](/miles_1337) thanks!"
                    },
                    {
                        "username": "miles_1337",
                        "content": "Failing this test case means you\\'re incrementing time when you don\\'t need to. Consider the following (much simpler) scenario:\\n\\nservers:\\n[1, 20, 300]\\n\\ntasks:\\n[10, 9, 8, 1, 1, 1]\\n\\nThe first 3 tasks come in-- going to server 0, server 1, and then server 2 respectively. All 3 of these will finish simultaneously at time = 10 sec. At this point, the last 3 tasks are all waiting to be launched (they are \"backlogged\", not streaming in). The correct answer is that at time = 10, you launch all 3 \"backlogged\" tasks immediately (one on each server). However, if you\\'re not handling this case (and incrementing time when you don\\'t need to), the 4th task will be assigned to server 0... server 0 will finish that task in 1 sec, and then the 5th (and similarly the 6th) task will run on server 0.\\n\\nThis larger test case ends up being impacted by the above scenario, just in a much more complex situation. "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) Not yet. I have tried a few methods (by weight, by index, etc). But still get an error at different test cases. Temporary stopped to attempt. Because I already waste many hours. "
                    },
                    {
                        "username": "_Kuldeep_01",
                        "content": "yeah it is mentioned to pick the smallest weight nd if tie then go with the smallest index .....I got the same problem.. did you find the solution ?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "found it to be a lower hard than medium"
                    },
                    {
                        "username": "mohanyash73",
                        "content": "**You will be able to process the jth task starting from the jth second beginning with the 0th task at second 0. To process task j, you assign it to the server with the smallest weight that is free, and in case of a tie, choose the server with the smallest index. If a free server gets assigned task j at second t, it will be free again at the second t + tasks[j].**\\n--> from this statement I understood that at j\\'th second we can start processing the j\\'th task and we must choose the server which has the least weight and in case of ties the least index. And if we start processing at j\\'th second then till j + tasks[j] the choosen server won\\'t be free agian.\\n\\n**If there are no free servers, you must wait until one is free and execute the free tasks as soon as possible. If multiple tasks need to be assigned, assign them in order of increasing index.**\\n\\n--> because of this statement it gave a hint that there\\'s a possibility that at j\\'th second our servers might not be free. So we must wait until the server is free and then assign it to the server which becomes free ASAP.  But the last statement \"If multiple tasks need to be assigned, assign them in order of increasing index\" confused me. Does it mean that we choose the servers in increasing index or the tasks in increasing index ?\\n\\n\\n**You may assign multiple tasks at the same second if there are multiple free servers.**\\n--> And this statement says we might be able to assign multiple tasks at the same time. But the first statement said we should assign only at j\\'th second? So how could we assign multiple tasks at the same time? And what ordering should we follow while choosing the servers in this case??"
                    },
                    {
                        "username": "ddubrava",
                        "content": "It's funny though that you forgot to mention that 'ith task becomes available at the ith second,' and you can schedule multiple tasks at the same time...\n\nThe problem description by [@buttercup_powerPuff](/buttercup_powerPuff)\n\n> The problem statement is really poorly worded.\n> \n> Actual Problem Statement\n> There is a queue of M tasks where ith task becomes available at the ith second and takes a duration of tasks[i] to be processed. We > have N servers each with a weight and index of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least weight. If there are multiple servers with same weight, we pick the one with > lowest index. When scheduling at time t, the selected server will be free again at t + tasks[i].\n> \n> Scheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers."
                    },
                    {
                        "username": "apooash2020",
                        "content": "Can someone help ? I am getting TLE `import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        available_cpu = [] ## PQ with (cpu_weight, cpu_index)\\n        busy_cpu = [] ## PQ with (task_finish_time, cpu_weight, cpu_index)\\n\\n        for index,weight in enumerate(servers):\\n            heapq.heappush(available_cpu, (weight, index))\\n\\n        curr_time = 0\\n        q = []\\n        result = []\\n        curr_task = 0\\n\\n        num_of_tasks = len(tasks)\\n\\n        while curr_task < len(tasks) or len(q) !=0: ## do we check len(q) !=0\\n\\n            ## get free servers from busy list into available list  \\n            while len(busy_cpu)!= 0 and busy_cpu[0][0] <= curr_time:\\n                _,free_cpu_weight,free_cpu_index = heapq.heappop(busy_cpu)\\n                heapq.heappush(available_cpu, (free_cpu_weight, free_cpu_index))\\n\\n            if curr_task < len(tasks):\\n                curr_task_time = tasks[curr_task]\\n                q.append(curr_task_time)\\n\\n            if available_cpu:\\n                while len(available_cpu) > 0 and len(q) > 0:\\n                    first_inserted_task_in_q_weight = q.pop(0)\\n                    task_finish_time = curr_time + first_inserted_task_in_q_weight\\n                    available_cpu_weight,available_cpu_index = heapq.heappop(available_cpu)\\n                    result.append(available_cpu_index)\\n                    heapq.heappush(busy_cpu,(task_finish_time,available_cpu_weight,available_cpu_index) )\\n    \\n            curr_time += 1\\n            curr_task += 1\\n\\n        return result\\n`"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unnecessarily complicated business logic.\\n\\nHere are some test cases:\\n\\nservers=\\n```\\n[3, 7, 9, 1, 10, 10, 9, 10, 8, 8]\\n```\\ntasks=\\n```\\n[10, 6, 9, 2, 3, 7, 6, 4, 5, 5]\\n```\\n\\nservers=\\n```\\n[5, 5, 9, 9, 9, 5, 10]\\n```\\ntasks=\\n```\\n[9, 9, 9, 6, 7, 3, 1, 10, 8, 6, 8, 9, 5, 7, 8, 3, 7, 3, 3, 7]\\n```\\n\\nPython script to generate test cases\\n\\n```\\nn = 7\\nm = 20\\nmax_server_weight = 10\\nmax_task = 10\\n\\nservers = [random.randint(1, max_server_weight) for _ in range(n)]\\ntasks = [random.randint(1, max_task) for _ in range(m)]\\nprint(json.dumps(servers))\\nprint(json.dumps(tasks))\\n```"
                    },
                    {
                        "username": "had0uken",
                        "content": "It`s not clear for me. What server have I pick for task, when I get few free servers at the same time? With the lowest index or with the lowest weight. Please explain anyone )"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) тю... ох и бредовое задание) То есть вначале задания назначаются постепенно, а потом уже как сервера поработали - одновременно? ) Автор задания умеет поиздеваться. И не так сложно задание, как понять что от тебя хотят сделать! ("
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0412\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u041D\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u0430\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C \\u043E\\u0434\\u043D\\u0443 \\u0434\\u0435\\u0442\\u0430\\u043B\\u044C: \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0437\\u0430\\u0434\\u0430\\u0447 \\u0436\\u0434\\u0443\\u0442 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438 (\\u0412\\u0441\\u0435 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043D\\u044F\\u0442\\u044B 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0437\\u0430 \\u044D\\u0442\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F 5 \\u0437\\u0430\\u0434\\u0430\\u0447 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438 \\u0436\\u0434\\u0430\\u0442\\u044C \\u0441\\u0432\\u043E\\u0435\\u0439 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438) \\u0438 \\u043E\\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u0438\\u043B\\u043E\\u0441\\u044C 3 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 - 3 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0431\\u044B\\u0442\\u044C \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044B \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0438 \\u0435\\u0449\\u0435 \\u043E\\u0434\\u0438\\u043D \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441: \\u0434\\u043E\\u043F\\u0443\\u0441\\u0442\\u0438\\u043C \\u0435\\u0441\\u0442\\u044C 3 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430. \\u0422\\u0440\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F \\u043D\\u0430 \\u043D\\u0438\\u0445 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0442\\u0443 \\u0436\\u0435 \\u0441\\u0430\\u043C\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443? \\u0418\\u043B\\u0438 \\u0432 \\u043F\\u0435\\u0440\\u0432\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 \\u043D\\u0430 1 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F, \\u043D\\u0430 2 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 - \\u043D\\u0430 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439, \\u0438 \\u0432 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0430 \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0439 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u0439\\u0434\\u0435\\u0439\\u0441\\u0442\\u043E\\u0432\\u0430\\u043D 3\\u0438\\u0439 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440? "
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0415\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F, \\u043C\\u044B \\u0432\\u044B\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043F\\u043E \\u0442\\u043E\\u043C\\u0443 \\u0436\\u0435 \\u043F\\u0440\\u0438\\u043D\\u0446\\u0438\\u043F\\u0443, \\u0447\\u0442\\u043E \\u0438 \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435. \\u0421\\u0435\\u0440\\u0432\\u0435\\u0440 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0435\\u0441\\u043B\\u0438 \\u0432\\u0435\\u0441\\u0430 \\u0440\\u0430\\u0432\\u043D\\u044B, \\u0442\\u043E \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0412\\u0438\\u0436\\u0443, \\u0447\\u0442\\u043E \\u0442\\u0435\\u0431\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438 \\u043D\\u0430 \\u0440\\u0443\\u0441\\u0441\\u043A\\u043E\\u043C \\u043D\\u0430\\u043F\\u0438\\u0441\\u0430\\u0442\\u044C. \\u041F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0436\\u0438 \\u043F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430. \\u0412\\u043E\\u0442 \\u043C\\u044B \\u0444\\u043E\\u0440\\u043C\\u0438\\u0440\\u0443\\u0435\\u043C \\u0444\\u0438\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u041A\\u0430\\u043A\\u043E\\u0435 \\u0442\\u0430\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043E\\u043A\\u0430\\u0436\\u0435\\u0442\\u0441\\u044F \\u043F\\u0435\\u0440\\u0432\\u0435\\u0435, \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F. \\u0422\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0438\\u043B\\u0438 \\u0442\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C? \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E \\u0437\\u0430\\u0440\\u0430\\u043D\\u0435\\u0435 "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) Thanx. I got it about time variable. But when I assign two task at the same time, what task I have to write to result array firstly? With the lowest index or lowest weight. What the main priority?"
                    },
                    {
                        "username": "Pavjelv",
                        "content": "You have to note this statement:\\n\"If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\"\\n\\nSo, there might me a case when multiple servers are free and you could assign more than one task without increasing time variable."
                    },
                    {
                        "username": "pawan1818",
                        "content": "Could anyone help me debug the below code?\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n      \\n       \\n    // Server Priority Queue\\n    // 0 -> server\\n    // 1 -> server index\\n    PriorityQueue<List<Integer>> freeServer = new PriorityQueue<>(\\n            (a,b) -> {\\n              if(a.get(0) == b.get(0)){\\n                return a.get(1) - b.get(1);\\n              }else{\\n                return a.get(0) - b.get(0);\\n              }\\n            }\\n    );\\n\\n    // Create array list of servers with index\\n    for(int i=0;i<servers.length;i++){\\n      List<Integer> list = new ArrayList<>();\\n      list.add(servers[i]);\\n      list.add(i);\\n      freeServer.add(list);\\n    }\\n\\n\\n    // List<List<Integer>> usedServer = new ArrayList<>();\\n\\n    // 0 -> server\\n    // 1 -> server index\\n    // 2 -> time\\n    // Unavailable usedServer       \\n    PriorityQueue<List<Integer>> usedServer = new PriorityQueue<>(\\n            (a,b) -> a.get(2) - b.get(2)\\n    );\\n\\n    int time = 0;\\n\\n    int[] res = new int[tasks.length];\\n\\n\\n    for(int i=0;i<tasks.length;i++){\\n      time = Math.max(time, i);\\n\\n\\n    if(freeServer.size() == 0){\\n         time = usedServer.peek().get(2);\\n    }\\n    \\n      \\n      while(usedServer.size() > 0 && usedServer.peek().get(2) <= time){\\n\\n        List<Integer> list = usedServer.poll();\\n        List<Integer> newList = new ArrayList<>();\\n        newList.add(list.get(0));\\n        newList.add(list.get(1));\\n        freeServer.add(newList);\\n\\n      }\\n\\n      if(freeServer.size() != 0){\\n           List<Integer> list = freeServer.poll();\\n            // index 2 is time\\n            List<Integer> newList = new ArrayList<>();\\n            newList.add(list.get(0));\\n        newList.add(list.get(1));\\n             newList.add(tasks[i]+time);\\n             usedServer.add(newList);\\n            res[i] =newList.get(1);\\n            \\n      }\\n\\n    }\\n\\n\\n    return res;\\n    \\n    }\\n}\\n\\nThis test case fails\\nInput\\nservers =\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\ntasks =\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nOutput\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,34,22,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,34,51,11,53,36,57,26,5,36,56,55,31,22,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\nExpected\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,"
                    },
                    {
                        "username": "user9178m",
                        "content": "I'm a bit lost as to what I've done wrong. It's a rather large test case to run through, so in the meantime, if anyone spots my mistake, please let me know.\n\n `\n\n        serverHeap = [(w,i) for i,w in enumerate(servers)]\n        heapq.heapify(serverHeap)\n        workingHeap = []\n\n        res = []\n        time = 0\n        while len(tasks) > 0:\n\n            print(serverHeap, time)\n            if len(serverHeap) > 0:\n                server = heapq.heappop(serverHeap)\n                heapq.heappush(workingHeap, (tasks.pop(0)+time, server[0], server[1]))\n                res.append(server[1])\n                time += 1\n\n            else:\n                print(workingHeap)\n                server = heapq.heappop(workingHeap)\n                time = server[0]\n                heapq.heappush(serverHeap, (server[1], server[2]))\n            \n            while len(workingHeap) > 0 and workingHeap[0][0] <= time:\n                server = heapq.heappop(workingHeap)\n                heapq.heappush(serverHeap, (server[1], server[2]))\n        \n        return res            \n\n`"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "i have the same error. Seems to have issue with time variable. Did you find any solution ?"
                    }
                ]
            },
            {
                "id": 2025636,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "servers\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\ntasks\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\n\n\nThis test case probably incorrect! \nExpected output:\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5, \n 36,56, 55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\n\nI marked the wrong place. server#56 has to start doing task before server#36 because both of them free at that moment and do not have any current task. However, 56 server has weigh (147) lower than server#36(889).\nHave anybody also got this problem? \n\nOr can anyone answer. When I get few free servers at the same time. What server I have to pick next? With lower index or weigh?? "
                    },
                    {
                        "username": "ddubrava",
                        "content": " ith task becomes available at the ith second"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "[@miles_1337](/miles_1337) dude your test case is gold! i use a simple if statement to deal with backlogging, works perfectly!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) yes! I waste 8 hours in total to resolve it. Many times I just erased code and started again. A tried a lot of ways to resolve this. And every time I got different test cases fail. Finally, I have resolved it. And this task is totally hell! A have never wasted so much time to one problem here!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@miles_1337](/miles_1337) thanks!"
                    },
                    {
                        "username": "miles_1337",
                        "content": "Failing this test case means you\\'re incrementing time when you don\\'t need to. Consider the following (much simpler) scenario:\\n\\nservers:\\n[1, 20, 300]\\n\\ntasks:\\n[10, 9, 8, 1, 1, 1]\\n\\nThe first 3 tasks come in-- going to server 0, server 1, and then server 2 respectively. All 3 of these will finish simultaneously at time = 10 sec. At this point, the last 3 tasks are all waiting to be launched (they are \"backlogged\", not streaming in). The correct answer is that at time = 10, you launch all 3 \"backlogged\" tasks immediately (one on each server). However, if you\\'re not handling this case (and incrementing time when you don\\'t need to), the 4th task will be assigned to server 0... server 0 will finish that task in 1 sec, and then the 5th (and similarly the 6th) task will run on server 0.\\n\\nThis larger test case ends up being impacted by the above scenario, just in a much more complex situation. "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) Not yet. I have tried a few methods (by weight, by index, etc). But still get an error at different test cases. Temporary stopped to attempt. Because I already waste many hours. "
                    },
                    {
                        "username": "_Kuldeep_01",
                        "content": "yeah it is mentioned to pick the smallest weight nd if tie then go with the smallest index .....I got the same problem.. did you find the solution ?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "found it to be a lower hard than medium"
                    },
                    {
                        "username": "mohanyash73",
                        "content": "**You will be able to process the jth task starting from the jth second beginning with the 0th task at second 0. To process task j, you assign it to the server with the smallest weight that is free, and in case of a tie, choose the server with the smallest index. If a free server gets assigned task j at second t, it will be free again at the second t + tasks[j].**\\n--> from this statement I understood that at j\\'th second we can start processing the j\\'th task and we must choose the server which has the least weight and in case of ties the least index. And if we start processing at j\\'th second then till j + tasks[j] the choosen server won\\'t be free agian.\\n\\n**If there are no free servers, you must wait until one is free and execute the free tasks as soon as possible. If multiple tasks need to be assigned, assign them in order of increasing index.**\\n\\n--> because of this statement it gave a hint that there\\'s a possibility that at j\\'th second our servers might not be free. So we must wait until the server is free and then assign it to the server which becomes free ASAP.  But the last statement \"If multiple tasks need to be assigned, assign them in order of increasing index\" confused me. Does it mean that we choose the servers in increasing index or the tasks in increasing index ?\\n\\n\\n**You may assign multiple tasks at the same second if there are multiple free servers.**\\n--> And this statement says we might be able to assign multiple tasks at the same time. But the first statement said we should assign only at j\\'th second? So how could we assign multiple tasks at the same time? And what ordering should we follow while choosing the servers in this case??"
                    },
                    {
                        "username": "ddubrava",
                        "content": "It's funny though that you forgot to mention that 'ith task becomes available at the ith second,' and you can schedule multiple tasks at the same time...\n\nThe problem description by [@buttercup_powerPuff](/buttercup_powerPuff)\n\n> The problem statement is really poorly worded.\n> \n> Actual Problem Statement\n> There is a queue of M tasks where ith task becomes available at the ith second and takes a duration of tasks[i] to be processed. We > have N servers each with a weight and index of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least weight. If there are multiple servers with same weight, we pick the one with > lowest index. When scheduling at time t, the selected server will be free again at t + tasks[i].\n> \n> Scheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers."
                    },
                    {
                        "username": "apooash2020",
                        "content": "Can someone help ? I am getting TLE `import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        available_cpu = [] ## PQ with (cpu_weight, cpu_index)\\n        busy_cpu = [] ## PQ with (task_finish_time, cpu_weight, cpu_index)\\n\\n        for index,weight in enumerate(servers):\\n            heapq.heappush(available_cpu, (weight, index))\\n\\n        curr_time = 0\\n        q = []\\n        result = []\\n        curr_task = 0\\n\\n        num_of_tasks = len(tasks)\\n\\n        while curr_task < len(tasks) or len(q) !=0: ## do we check len(q) !=0\\n\\n            ## get free servers from busy list into available list  \\n            while len(busy_cpu)!= 0 and busy_cpu[0][0] <= curr_time:\\n                _,free_cpu_weight,free_cpu_index = heapq.heappop(busy_cpu)\\n                heapq.heappush(available_cpu, (free_cpu_weight, free_cpu_index))\\n\\n            if curr_task < len(tasks):\\n                curr_task_time = tasks[curr_task]\\n                q.append(curr_task_time)\\n\\n            if available_cpu:\\n                while len(available_cpu) > 0 and len(q) > 0:\\n                    first_inserted_task_in_q_weight = q.pop(0)\\n                    task_finish_time = curr_time + first_inserted_task_in_q_weight\\n                    available_cpu_weight,available_cpu_index = heapq.heappop(available_cpu)\\n                    result.append(available_cpu_index)\\n                    heapq.heappush(busy_cpu,(task_finish_time,available_cpu_weight,available_cpu_index) )\\n    \\n            curr_time += 1\\n            curr_task += 1\\n\\n        return result\\n`"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unnecessarily complicated business logic.\\n\\nHere are some test cases:\\n\\nservers=\\n```\\n[3, 7, 9, 1, 10, 10, 9, 10, 8, 8]\\n```\\ntasks=\\n```\\n[10, 6, 9, 2, 3, 7, 6, 4, 5, 5]\\n```\\n\\nservers=\\n```\\n[5, 5, 9, 9, 9, 5, 10]\\n```\\ntasks=\\n```\\n[9, 9, 9, 6, 7, 3, 1, 10, 8, 6, 8, 9, 5, 7, 8, 3, 7, 3, 3, 7]\\n```\\n\\nPython script to generate test cases\\n\\n```\\nn = 7\\nm = 20\\nmax_server_weight = 10\\nmax_task = 10\\n\\nservers = [random.randint(1, max_server_weight) for _ in range(n)]\\ntasks = [random.randint(1, max_task) for _ in range(m)]\\nprint(json.dumps(servers))\\nprint(json.dumps(tasks))\\n```"
                    },
                    {
                        "username": "had0uken",
                        "content": "It`s not clear for me. What server have I pick for task, when I get few free servers at the same time? With the lowest index or with the lowest weight. Please explain anyone )"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) тю... ох и бредовое задание) То есть вначале задания назначаются постепенно, а потом уже как сервера поработали - одновременно? ) Автор задания умеет поиздеваться. И не так сложно задание, как понять что от тебя хотят сделать! ("
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0412\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u041D\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u0430\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C \\u043E\\u0434\\u043D\\u0443 \\u0434\\u0435\\u0442\\u0430\\u043B\\u044C: \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0437\\u0430\\u0434\\u0430\\u0447 \\u0436\\u0434\\u0443\\u0442 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438 (\\u0412\\u0441\\u0435 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043D\\u044F\\u0442\\u044B 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0437\\u0430 \\u044D\\u0442\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F 5 \\u0437\\u0430\\u0434\\u0430\\u0447 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438 \\u0436\\u0434\\u0430\\u0442\\u044C \\u0441\\u0432\\u043E\\u0435\\u0439 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438) \\u0438 \\u043E\\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u0438\\u043B\\u043E\\u0441\\u044C 3 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 - 3 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0431\\u044B\\u0442\\u044C \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044B \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0438 \\u0435\\u0449\\u0435 \\u043E\\u0434\\u0438\\u043D \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441: \\u0434\\u043E\\u043F\\u0443\\u0441\\u0442\\u0438\\u043C \\u0435\\u0441\\u0442\\u044C 3 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430. \\u0422\\u0440\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F \\u043D\\u0430 \\u043D\\u0438\\u0445 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0442\\u0443 \\u0436\\u0435 \\u0441\\u0430\\u043C\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443? \\u0418\\u043B\\u0438 \\u0432 \\u043F\\u0435\\u0440\\u0432\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 \\u043D\\u0430 1 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F, \\u043D\\u0430 2 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 - \\u043D\\u0430 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439, \\u0438 \\u0432 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0430 \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0439 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u0439\\u0434\\u0435\\u0439\\u0441\\u0442\\u043E\\u0432\\u0430\\u043D 3\\u0438\\u0439 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440? "
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0415\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F, \\u043C\\u044B \\u0432\\u044B\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043F\\u043E \\u0442\\u043E\\u043C\\u0443 \\u0436\\u0435 \\u043F\\u0440\\u0438\\u043D\\u0446\\u0438\\u043F\\u0443, \\u0447\\u0442\\u043E \\u0438 \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435. \\u0421\\u0435\\u0440\\u0432\\u0435\\u0440 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0435\\u0441\\u043B\\u0438 \\u0432\\u0435\\u0441\\u0430 \\u0440\\u0430\\u0432\\u043D\\u044B, \\u0442\\u043E \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0412\\u0438\\u0436\\u0443, \\u0447\\u0442\\u043E \\u0442\\u0435\\u0431\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438 \\u043D\\u0430 \\u0440\\u0443\\u0441\\u0441\\u043A\\u043E\\u043C \\u043D\\u0430\\u043F\\u0438\\u0441\\u0430\\u0442\\u044C. \\u041F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0436\\u0438 \\u043F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430. \\u0412\\u043E\\u0442 \\u043C\\u044B \\u0444\\u043E\\u0440\\u043C\\u0438\\u0440\\u0443\\u0435\\u043C \\u0444\\u0438\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u041A\\u0430\\u043A\\u043E\\u0435 \\u0442\\u0430\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043E\\u043A\\u0430\\u0436\\u0435\\u0442\\u0441\\u044F \\u043F\\u0435\\u0440\\u0432\\u0435\\u0435, \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F. \\u0422\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0438\\u043B\\u0438 \\u0442\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C? \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E \\u0437\\u0430\\u0440\\u0430\\u043D\\u0435\\u0435 "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) Thanx. I got it about time variable. But when I assign two task at the same time, what task I have to write to result array firstly? With the lowest index or lowest weight. What the main priority?"
                    },
                    {
                        "username": "Pavjelv",
                        "content": "You have to note this statement:\\n\"If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\"\\n\\nSo, there might me a case when multiple servers are free and you could assign more than one task without increasing time variable."
                    },
                    {
                        "username": "pawan1818",
                        "content": "Could anyone help me debug the below code?\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n      \\n       \\n    // Server Priority Queue\\n    // 0 -> server\\n    // 1 -> server index\\n    PriorityQueue<List<Integer>> freeServer = new PriorityQueue<>(\\n            (a,b) -> {\\n              if(a.get(0) == b.get(0)){\\n                return a.get(1) - b.get(1);\\n              }else{\\n                return a.get(0) - b.get(0);\\n              }\\n            }\\n    );\\n\\n    // Create array list of servers with index\\n    for(int i=0;i<servers.length;i++){\\n      List<Integer> list = new ArrayList<>();\\n      list.add(servers[i]);\\n      list.add(i);\\n      freeServer.add(list);\\n    }\\n\\n\\n    // List<List<Integer>> usedServer = new ArrayList<>();\\n\\n    // 0 -> server\\n    // 1 -> server index\\n    // 2 -> time\\n    // Unavailable usedServer       \\n    PriorityQueue<List<Integer>> usedServer = new PriorityQueue<>(\\n            (a,b) -> a.get(2) - b.get(2)\\n    );\\n\\n    int time = 0;\\n\\n    int[] res = new int[tasks.length];\\n\\n\\n    for(int i=0;i<tasks.length;i++){\\n      time = Math.max(time, i);\\n\\n\\n    if(freeServer.size() == 0){\\n         time = usedServer.peek().get(2);\\n    }\\n    \\n      \\n      while(usedServer.size() > 0 && usedServer.peek().get(2) <= time){\\n\\n        List<Integer> list = usedServer.poll();\\n        List<Integer> newList = new ArrayList<>();\\n        newList.add(list.get(0));\\n        newList.add(list.get(1));\\n        freeServer.add(newList);\\n\\n      }\\n\\n      if(freeServer.size() != 0){\\n           List<Integer> list = freeServer.poll();\\n            // index 2 is time\\n            List<Integer> newList = new ArrayList<>();\\n            newList.add(list.get(0));\\n        newList.add(list.get(1));\\n             newList.add(tasks[i]+time);\\n             usedServer.add(newList);\\n            res[i] =newList.get(1);\\n            \\n      }\\n\\n    }\\n\\n\\n    return res;\\n    \\n    }\\n}\\n\\nThis test case fails\\nInput\\nservers =\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\ntasks =\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nOutput\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,34,22,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,34,51,11,53,36,57,26,5,36,56,55,31,22,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\nExpected\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,"
                    },
                    {
                        "username": "user9178m",
                        "content": "I'm a bit lost as to what I've done wrong. It's a rather large test case to run through, so in the meantime, if anyone spots my mistake, please let me know.\n\n `\n\n        serverHeap = [(w,i) for i,w in enumerate(servers)]\n        heapq.heapify(serverHeap)\n        workingHeap = []\n\n        res = []\n        time = 0\n        while len(tasks) > 0:\n\n            print(serverHeap, time)\n            if len(serverHeap) > 0:\n                server = heapq.heappop(serverHeap)\n                heapq.heappush(workingHeap, (tasks.pop(0)+time, server[0], server[1]))\n                res.append(server[1])\n                time += 1\n\n            else:\n                print(workingHeap)\n                server = heapq.heappop(workingHeap)\n                time = server[0]\n                heapq.heappush(serverHeap, (server[1], server[2]))\n            \n            while len(workingHeap) > 0 and workingHeap[0][0] <= time:\n                server = heapq.heappop(workingHeap)\n                heapq.heappush(serverHeap, (server[1], server[2]))\n        \n        return res            \n\n`"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "i have the same error. Seems to have issue with time variable. Did you find any solution ?"
                    }
                ]
            },
            {
                "id": 1575332,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "servers\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\ntasks\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\n\n\nThis test case probably incorrect! \nExpected output:\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5, \n 36,56, 55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\n\nI marked the wrong place. server#56 has to start doing task before server#36 because both of them free at that moment and do not have any current task. However, 56 server has weigh (147) lower than server#36(889).\nHave anybody also got this problem? \n\nOr can anyone answer. When I get few free servers at the same time. What server I have to pick next? With lower index or weigh?? "
                    },
                    {
                        "username": "ddubrava",
                        "content": " ith task becomes available at the ith second"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "[@miles_1337](/miles_1337) dude your test case is gold! i use a simple if statement to deal with backlogging, works perfectly!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) yes! I waste 8 hours in total to resolve it. Many times I just erased code and started again. A tried a lot of ways to resolve this. And every time I got different test cases fail. Finally, I have resolved it. And this task is totally hell! A have never wasted so much time to one problem here!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@miles_1337](/miles_1337) thanks!"
                    },
                    {
                        "username": "miles_1337",
                        "content": "Failing this test case means you\\'re incrementing time when you don\\'t need to. Consider the following (much simpler) scenario:\\n\\nservers:\\n[1, 20, 300]\\n\\ntasks:\\n[10, 9, 8, 1, 1, 1]\\n\\nThe first 3 tasks come in-- going to server 0, server 1, and then server 2 respectively. All 3 of these will finish simultaneously at time = 10 sec. At this point, the last 3 tasks are all waiting to be launched (they are \"backlogged\", not streaming in). The correct answer is that at time = 10, you launch all 3 \"backlogged\" tasks immediately (one on each server). However, if you\\'re not handling this case (and incrementing time when you don\\'t need to), the 4th task will be assigned to server 0... server 0 will finish that task in 1 sec, and then the 5th (and similarly the 6th) task will run on server 0.\\n\\nThis larger test case ends up being impacted by the above scenario, just in a much more complex situation. "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) Not yet. I have tried a few methods (by weight, by index, etc). But still get an error at different test cases. Temporary stopped to attempt. Because I already waste many hours. "
                    },
                    {
                        "username": "_Kuldeep_01",
                        "content": "yeah it is mentioned to pick the smallest weight nd if tie then go with the smallest index .....I got the same problem.. did you find the solution ?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "found it to be a lower hard than medium"
                    },
                    {
                        "username": "mohanyash73",
                        "content": "**You will be able to process the jth task starting from the jth second beginning with the 0th task at second 0. To process task j, you assign it to the server with the smallest weight that is free, and in case of a tie, choose the server with the smallest index. If a free server gets assigned task j at second t, it will be free again at the second t + tasks[j].**\\n--> from this statement I understood that at j\\'th second we can start processing the j\\'th task and we must choose the server which has the least weight and in case of ties the least index. And if we start processing at j\\'th second then till j + tasks[j] the choosen server won\\'t be free agian.\\n\\n**If there are no free servers, you must wait until one is free and execute the free tasks as soon as possible. If multiple tasks need to be assigned, assign them in order of increasing index.**\\n\\n--> because of this statement it gave a hint that there\\'s a possibility that at j\\'th second our servers might not be free. So we must wait until the server is free and then assign it to the server which becomes free ASAP.  But the last statement \"If multiple tasks need to be assigned, assign them in order of increasing index\" confused me. Does it mean that we choose the servers in increasing index or the tasks in increasing index ?\\n\\n\\n**You may assign multiple tasks at the same second if there are multiple free servers.**\\n--> And this statement says we might be able to assign multiple tasks at the same time. But the first statement said we should assign only at j\\'th second? So how could we assign multiple tasks at the same time? And what ordering should we follow while choosing the servers in this case??"
                    },
                    {
                        "username": "ddubrava",
                        "content": "It's funny though that you forgot to mention that 'ith task becomes available at the ith second,' and you can schedule multiple tasks at the same time...\n\nThe problem description by [@buttercup_powerPuff](/buttercup_powerPuff)\n\n> The problem statement is really poorly worded.\n> \n> Actual Problem Statement\n> There is a queue of M tasks where ith task becomes available at the ith second and takes a duration of tasks[i] to be processed. We > have N servers each with a weight and index of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least weight. If there are multiple servers with same weight, we pick the one with > lowest index. When scheduling at time t, the selected server will be free again at t + tasks[i].\n> \n> Scheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers."
                    },
                    {
                        "username": "apooash2020",
                        "content": "Can someone help ? I am getting TLE `import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        available_cpu = [] ## PQ with (cpu_weight, cpu_index)\\n        busy_cpu = [] ## PQ with (task_finish_time, cpu_weight, cpu_index)\\n\\n        for index,weight in enumerate(servers):\\n            heapq.heappush(available_cpu, (weight, index))\\n\\n        curr_time = 0\\n        q = []\\n        result = []\\n        curr_task = 0\\n\\n        num_of_tasks = len(tasks)\\n\\n        while curr_task < len(tasks) or len(q) !=0: ## do we check len(q) !=0\\n\\n            ## get free servers from busy list into available list  \\n            while len(busy_cpu)!= 0 and busy_cpu[0][0] <= curr_time:\\n                _,free_cpu_weight,free_cpu_index = heapq.heappop(busy_cpu)\\n                heapq.heappush(available_cpu, (free_cpu_weight, free_cpu_index))\\n\\n            if curr_task < len(tasks):\\n                curr_task_time = tasks[curr_task]\\n                q.append(curr_task_time)\\n\\n            if available_cpu:\\n                while len(available_cpu) > 0 and len(q) > 0:\\n                    first_inserted_task_in_q_weight = q.pop(0)\\n                    task_finish_time = curr_time + first_inserted_task_in_q_weight\\n                    available_cpu_weight,available_cpu_index = heapq.heappop(available_cpu)\\n                    result.append(available_cpu_index)\\n                    heapq.heappush(busy_cpu,(task_finish_time,available_cpu_weight,available_cpu_index) )\\n    \\n            curr_time += 1\\n            curr_task += 1\\n\\n        return result\\n`"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unnecessarily complicated business logic.\\n\\nHere are some test cases:\\n\\nservers=\\n```\\n[3, 7, 9, 1, 10, 10, 9, 10, 8, 8]\\n```\\ntasks=\\n```\\n[10, 6, 9, 2, 3, 7, 6, 4, 5, 5]\\n```\\n\\nservers=\\n```\\n[5, 5, 9, 9, 9, 5, 10]\\n```\\ntasks=\\n```\\n[9, 9, 9, 6, 7, 3, 1, 10, 8, 6, 8, 9, 5, 7, 8, 3, 7, 3, 3, 7]\\n```\\n\\nPython script to generate test cases\\n\\n```\\nn = 7\\nm = 20\\nmax_server_weight = 10\\nmax_task = 10\\n\\nservers = [random.randint(1, max_server_weight) for _ in range(n)]\\ntasks = [random.randint(1, max_task) for _ in range(m)]\\nprint(json.dumps(servers))\\nprint(json.dumps(tasks))\\n```"
                    },
                    {
                        "username": "had0uken",
                        "content": "It`s not clear for me. What server have I pick for task, when I get few free servers at the same time? With the lowest index or with the lowest weight. Please explain anyone )"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) тю... ох и бредовое задание) То есть вначале задания назначаются постепенно, а потом уже как сервера поработали - одновременно? ) Автор задания умеет поиздеваться. И не так сложно задание, как понять что от тебя хотят сделать! ("
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0412\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u041D\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u0430\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C \\u043E\\u0434\\u043D\\u0443 \\u0434\\u0435\\u0442\\u0430\\u043B\\u044C: \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0437\\u0430\\u0434\\u0430\\u0447 \\u0436\\u0434\\u0443\\u0442 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438 (\\u0412\\u0441\\u0435 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043D\\u044F\\u0442\\u044B 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0437\\u0430 \\u044D\\u0442\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F 5 \\u0437\\u0430\\u0434\\u0430\\u0447 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438 \\u0436\\u0434\\u0430\\u0442\\u044C \\u0441\\u0432\\u043E\\u0435\\u0439 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438) \\u0438 \\u043E\\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u0438\\u043B\\u043E\\u0441\\u044C 3 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 - 3 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0431\\u044B\\u0442\\u044C \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044B \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0438 \\u0435\\u0449\\u0435 \\u043E\\u0434\\u0438\\u043D \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441: \\u0434\\u043E\\u043F\\u0443\\u0441\\u0442\\u0438\\u043C \\u0435\\u0441\\u0442\\u044C 3 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430. \\u0422\\u0440\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F \\u043D\\u0430 \\u043D\\u0438\\u0445 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0442\\u0443 \\u0436\\u0435 \\u0441\\u0430\\u043C\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443? \\u0418\\u043B\\u0438 \\u0432 \\u043F\\u0435\\u0440\\u0432\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 \\u043D\\u0430 1 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F, \\u043D\\u0430 2 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 - \\u043D\\u0430 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439, \\u0438 \\u0432 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0430 \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0439 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u0439\\u0434\\u0435\\u0439\\u0441\\u0442\\u043E\\u0432\\u0430\\u043D 3\\u0438\\u0439 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440? "
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0415\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F, \\u043C\\u044B \\u0432\\u044B\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043F\\u043E \\u0442\\u043E\\u043C\\u0443 \\u0436\\u0435 \\u043F\\u0440\\u0438\\u043D\\u0446\\u0438\\u043F\\u0443, \\u0447\\u0442\\u043E \\u0438 \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435. \\u0421\\u0435\\u0440\\u0432\\u0435\\u0440 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0435\\u0441\\u043B\\u0438 \\u0432\\u0435\\u0441\\u0430 \\u0440\\u0430\\u0432\\u043D\\u044B, \\u0442\\u043E \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0412\\u0438\\u0436\\u0443, \\u0447\\u0442\\u043E \\u0442\\u0435\\u0431\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438 \\u043D\\u0430 \\u0440\\u0443\\u0441\\u0441\\u043A\\u043E\\u043C \\u043D\\u0430\\u043F\\u0438\\u0441\\u0430\\u0442\\u044C. \\u041F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0436\\u0438 \\u043F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430. \\u0412\\u043E\\u0442 \\u043C\\u044B \\u0444\\u043E\\u0440\\u043C\\u0438\\u0440\\u0443\\u0435\\u043C \\u0444\\u0438\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u041A\\u0430\\u043A\\u043E\\u0435 \\u0442\\u0430\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043E\\u043A\\u0430\\u0436\\u0435\\u0442\\u0441\\u044F \\u043F\\u0435\\u0440\\u0432\\u0435\\u0435, \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F. \\u0422\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0438\\u043B\\u0438 \\u0442\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C? \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E \\u0437\\u0430\\u0440\\u0430\\u043D\\u0435\\u0435 "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) Thanx. I got it about time variable. But when I assign two task at the same time, what task I have to write to result array firstly? With the lowest index or lowest weight. What the main priority?"
                    },
                    {
                        "username": "Pavjelv",
                        "content": "You have to note this statement:\\n\"If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\"\\n\\nSo, there might me a case when multiple servers are free and you could assign more than one task without increasing time variable."
                    },
                    {
                        "username": "pawan1818",
                        "content": "Could anyone help me debug the below code?\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n      \\n       \\n    // Server Priority Queue\\n    // 0 -> server\\n    // 1 -> server index\\n    PriorityQueue<List<Integer>> freeServer = new PriorityQueue<>(\\n            (a,b) -> {\\n              if(a.get(0) == b.get(0)){\\n                return a.get(1) - b.get(1);\\n              }else{\\n                return a.get(0) - b.get(0);\\n              }\\n            }\\n    );\\n\\n    // Create array list of servers with index\\n    for(int i=0;i<servers.length;i++){\\n      List<Integer> list = new ArrayList<>();\\n      list.add(servers[i]);\\n      list.add(i);\\n      freeServer.add(list);\\n    }\\n\\n\\n    // List<List<Integer>> usedServer = new ArrayList<>();\\n\\n    // 0 -> server\\n    // 1 -> server index\\n    // 2 -> time\\n    // Unavailable usedServer       \\n    PriorityQueue<List<Integer>> usedServer = new PriorityQueue<>(\\n            (a,b) -> a.get(2) - b.get(2)\\n    );\\n\\n    int time = 0;\\n\\n    int[] res = new int[tasks.length];\\n\\n\\n    for(int i=0;i<tasks.length;i++){\\n      time = Math.max(time, i);\\n\\n\\n    if(freeServer.size() == 0){\\n         time = usedServer.peek().get(2);\\n    }\\n    \\n      \\n      while(usedServer.size() > 0 && usedServer.peek().get(2) <= time){\\n\\n        List<Integer> list = usedServer.poll();\\n        List<Integer> newList = new ArrayList<>();\\n        newList.add(list.get(0));\\n        newList.add(list.get(1));\\n        freeServer.add(newList);\\n\\n      }\\n\\n      if(freeServer.size() != 0){\\n           List<Integer> list = freeServer.poll();\\n            // index 2 is time\\n            List<Integer> newList = new ArrayList<>();\\n            newList.add(list.get(0));\\n        newList.add(list.get(1));\\n             newList.add(tasks[i]+time);\\n             usedServer.add(newList);\\n            res[i] =newList.get(1);\\n            \\n      }\\n\\n    }\\n\\n\\n    return res;\\n    \\n    }\\n}\\n\\nThis test case fails\\nInput\\nservers =\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\ntasks =\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nOutput\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,34,22,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,34,51,11,53,36,57,26,5,36,56,55,31,22,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\nExpected\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,"
                    },
                    {
                        "username": "user9178m",
                        "content": "I'm a bit lost as to what I've done wrong. It's a rather large test case to run through, so in the meantime, if anyone spots my mistake, please let me know.\n\n `\n\n        serverHeap = [(w,i) for i,w in enumerate(servers)]\n        heapq.heapify(serverHeap)\n        workingHeap = []\n\n        res = []\n        time = 0\n        while len(tasks) > 0:\n\n            print(serverHeap, time)\n            if len(serverHeap) > 0:\n                server = heapq.heappop(serverHeap)\n                heapq.heappush(workingHeap, (tasks.pop(0)+time, server[0], server[1]))\n                res.append(server[1])\n                time += 1\n\n            else:\n                print(workingHeap)\n                server = heapq.heappop(workingHeap)\n                time = server[0]\n                heapq.heappush(serverHeap, (server[1], server[2]))\n            \n            while len(workingHeap) > 0 and workingHeap[0][0] <= time:\n                server = heapq.heappop(workingHeap)\n                heapq.heappush(serverHeap, (server[1], server[2]))\n        \n        return res            \n\n`"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "i have the same error. Seems to have issue with time variable. Did you find any solution ?"
                    }
                ]
            },
            {
                "id": 2062247,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "servers\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\ntasks\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\n\n\nThis test case probably incorrect! \nExpected output:\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5, \n 36,56, 55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\n\nI marked the wrong place. server#56 has to start doing task before server#36 because both of them free at that moment and do not have any current task. However, 56 server has weigh (147) lower than server#36(889).\nHave anybody also got this problem? \n\nOr can anyone answer. When I get few free servers at the same time. What server I have to pick next? With lower index or weigh?? "
                    },
                    {
                        "username": "ddubrava",
                        "content": " ith task becomes available at the ith second"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "[@miles_1337](/miles_1337) dude your test case is gold! i use a simple if statement to deal with backlogging, works perfectly!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) yes! I waste 8 hours in total to resolve it. Many times I just erased code and started again. A tried a lot of ways to resolve this. And every time I got different test cases fail. Finally, I have resolved it. And this task is totally hell! A have never wasted so much time to one problem here!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@miles_1337](/miles_1337) thanks!"
                    },
                    {
                        "username": "miles_1337",
                        "content": "Failing this test case means you\\'re incrementing time when you don\\'t need to. Consider the following (much simpler) scenario:\\n\\nservers:\\n[1, 20, 300]\\n\\ntasks:\\n[10, 9, 8, 1, 1, 1]\\n\\nThe first 3 tasks come in-- going to server 0, server 1, and then server 2 respectively. All 3 of these will finish simultaneously at time = 10 sec. At this point, the last 3 tasks are all waiting to be launched (they are \"backlogged\", not streaming in). The correct answer is that at time = 10, you launch all 3 \"backlogged\" tasks immediately (one on each server). However, if you\\'re not handling this case (and incrementing time when you don\\'t need to), the 4th task will be assigned to server 0... server 0 will finish that task in 1 sec, and then the 5th (and similarly the 6th) task will run on server 0.\\n\\nThis larger test case ends up being impacted by the above scenario, just in a much more complex situation. "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) Not yet. I have tried a few methods (by weight, by index, etc). But still get an error at different test cases. Temporary stopped to attempt. Because I already waste many hours. "
                    },
                    {
                        "username": "_Kuldeep_01",
                        "content": "yeah it is mentioned to pick the smallest weight nd if tie then go with the smallest index .....I got the same problem.. did you find the solution ?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "found it to be a lower hard than medium"
                    },
                    {
                        "username": "mohanyash73",
                        "content": "**You will be able to process the jth task starting from the jth second beginning with the 0th task at second 0. To process task j, you assign it to the server with the smallest weight that is free, and in case of a tie, choose the server with the smallest index. If a free server gets assigned task j at second t, it will be free again at the second t + tasks[j].**\\n--> from this statement I understood that at j\\'th second we can start processing the j\\'th task and we must choose the server which has the least weight and in case of ties the least index. And if we start processing at j\\'th second then till j + tasks[j] the choosen server won\\'t be free agian.\\n\\n**If there are no free servers, you must wait until one is free and execute the free tasks as soon as possible. If multiple tasks need to be assigned, assign them in order of increasing index.**\\n\\n--> because of this statement it gave a hint that there\\'s a possibility that at j\\'th second our servers might not be free. So we must wait until the server is free and then assign it to the server which becomes free ASAP.  But the last statement \"If multiple tasks need to be assigned, assign them in order of increasing index\" confused me. Does it mean that we choose the servers in increasing index or the tasks in increasing index ?\\n\\n\\n**You may assign multiple tasks at the same second if there are multiple free servers.**\\n--> And this statement says we might be able to assign multiple tasks at the same time. But the first statement said we should assign only at j\\'th second? So how could we assign multiple tasks at the same time? And what ordering should we follow while choosing the servers in this case??"
                    },
                    {
                        "username": "ddubrava",
                        "content": "It's funny though that you forgot to mention that 'ith task becomes available at the ith second,' and you can schedule multiple tasks at the same time...\n\nThe problem description by [@buttercup_powerPuff](/buttercup_powerPuff)\n\n> The problem statement is really poorly worded.\n> \n> Actual Problem Statement\n> There is a queue of M tasks where ith task becomes available at the ith second and takes a duration of tasks[i] to be processed. We > have N servers each with a weight and index of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least weight. If there are multiple servers with same weight, we pick the one with > lowest index. When scheduling at time t, the selected server will be free again at t + tasks[i].\n> \n> Scheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers."
                    },
                    {
                        "username": "apooash2020",
                        "content": "Can someone help ? I am getting TLE `import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        available_cpu = [] ## PQ with (cpu_weight, cpu_index)\\n        busy_cpu = [] ## PQ with (task_finish_time, cpu_weight, cpu_index)\\n\\n        for index,weight in enumerate(servers):\\n            heapq.heappush(available_cpu, (weight, index))\\n\\n        curr_time = 0\\n        q = []\\n        result = []\\n        curr_task = 0\\n\\n        num_of_tasks = len(tasks)\\n\\n        while curr_task < len(tasks) or len(q) !=0: ## do we check len(q) !=0\\n\\n            ## get free servers from busy list into available list  \\n            while len(busy_cpu)!= 0 and busy_cpu[0][0] <= curr_time:\\n                _,free_cpu_weight,free_cpu_index = heapq.heappop(busy_cpu)\\n                heapq.heappush(available_cpu, (free_cpu_weight, free_cpu_index))\\n\\n            if curr_task < len(tasks):\\n                curr_task_time = tasks[curr_task]\\n                q.append(curr_task_time)\\n\\n            if available_cpu:\\n                while len(available_cpu) > 0 and len(q) > 0:\\n                    first_inserted_task_in_q_weight = q.pop(0)\\n                    task_finish_time = curr_time + first_inserted_task_in_q_weight\\n                    available_cpu_weight,available_cpu_index = heapq.heappop(available_cpu)\\n                    result.append(available_cpu_index)\\n                    heapq.heappush(busy_cpu,(task_finish_time,available_cpu_weight,available_cpu_index) )\\n    \\n            curr_time += 1\\n            curr_task += 1\\n\\n        return result\\n`"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unnecessarily complicated business logic.\\n\\nHere are some test cases:\\n\\nservers=\\n```\\n[3, 7, 9, 1, 10, 10, 9, 10, 8, 8]\\n```\\ntasks=\\n```\\n[10, 6, 9, 2, 3, 7, 6, 4, 5, 5]\\n```\\n\\nservers=\\n```\\n[5, 5, 9, 9, 9, 5, 10]\\n```\\ntasks=\\n```\\n[9, 9, 9, 6, 7, 3, 1, 10, 8, 6, 8, 9, 5, 7, 8, 3, 7, 3, 3, 7]\\n```\\n\\nPython script to generate test cases\\n\\n```\\nn = 7\\nm = 20\\nmax_server_weight = 10\\nmax_task = 10\\n\\nservers = [random.randint(1, max_server_weight) for _ in range(n)]\\ntasks = [random.randint(1, max_task) for _ in range(m)]\\nprint(json.dumps(servers))\\nprint(json.dumps(tasks))\\n```"
                    },
                    {
                        "username": "had0uken",
                        "content": "It`s not clear for me. What server have I pick for task, when I get few free servers at the same time? With the lowest index or with the lowest weight. Please explain anyone )"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) тю... ох и бредовое задание) То есть вначале задания назначаются постепенно, а потом уже как сервера поработали - одновременно? ) Автор задания умеет поиздеваться. И не так сложно задание, как понять что от тебя хотят сделать! ("
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0412\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u041D\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u0430\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C \\u043E\\u0434\\u043D\\u0443 \\u0434\\u0435\\u0442\\u0430\\u043B\\u044C: \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0437\\u0430\\u0434\\u0430\\u0447 \\u0436\\u0434\\u0443\\u0442 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438 (\\u0412\\u0441\\u0435 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043D\\u044F\\u0442\\u044B 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0437\\u0430 \\u044D\\u0442\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F 5 \\u0437\\u0430\\u0434\\u0430\\u0447 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438 \\u0436\\u0434\\u0430\\u0442\\u044C \\u0441\\u0432\\u043E\\u0435\\u0439 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438) \\u0438 \\u043E\\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u0438\\u043B\\u043E\\u0441\\u044C 3 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 - 3 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0431\\u044B\\u0442\\u044C \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044B \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0438 \\u0435\\u0449\\u0435 \\u043E\\u0434\\u0438\\u043D \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441: \\u0434\\u043E\\u043F\\u0443\\u0441\\u0442\\u0438\\u043C \\u0435\\u0441\\u0442\\u044C 3 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430. \\u0422\\u0440\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F \\u043D\\u0430 \\u043D\\u0438\\u0445 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0442\\u0443 \\u0436\\u0435 \\u0441\\u0430\\u043C\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443? \\u0418\\u043B\\u0438 \\u0432 \\u043F\\u0435\\u0440\\u0432\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 \\u043D\\u0430 1 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F, \\u043D\\u0430 2 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 - \\u043D\\u0430 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439, \\u0438 \\u0432 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0430 \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0439 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u0439\\u0434\\u0435\\u0439\\u0441\\u0442\\u043E\\u0432\\u0430\\u043D 3\\u0438\\u0439 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440? "
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0415\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F, \\u043C\\u044B \\u0432\\u044B\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043F\\u043E \\u0442\\u043E\\u043C\\u0443 \\u0436\\u0435 \\u043F\\u0440\\u0438\\u043D\\u0446\\u0438\\u043F\\u0443, \\u0447\\u0442\\u043E \\u0438 \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435. \\u0421\\u0435\\u0440\\u0432\\u0435\\u0440 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0435\\u0441\\u043B\\u0438 \\u0432\\u0435\\u0441\\u0430 \\u0440\\u0430\\u0432\\u043D\\u044B, \\u0442\\u043E \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0412\\u0438\\u0436\\u0443, \\u0447\\u0442\\u043E \\u0442\\u0435\\u0431\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438 \\u043D\\u0430 \\u0440\\u0443\\u0441\\u0441\\u043A\\u043E\\u043C \\u043D\\u0430\\u043F\\u0438\\u0441\\u0430\\u0442\\u044C. \\u041F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0436\\u0438 \\u043F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430. \\u0412\\u043E\\u0442 \\u043C\\u044B \\u0444\\u043E\\u0440\\u043C\\u0438\\u0440\\u0443\\u0435\\u043C \\u0444\\u0438\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u041A\\u0430\\u043A\\u043E\\u0435 \\u0442\\u0430\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043E\\u043A\\u0430\\u0436\\u0435\\u0442\\u0441\\u044F \\u043F\\u0435\\u0440\\u0432\\u0435\\u0435, \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F. \\u0422\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0438\\u043B\\u0438 \\u0442\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C? \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E \\u0437\\u0430\\u0440\\u0430\\u043D\\u0435\\u0435 "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) Thanx. I got it about time variable. But when I assign two task at the same time, what task I have to write to result array firstly? With the lowest index or lowest weight. What the main priority?"
                    },
                    {
                        "username": "Pavjelv",
                        "content": "You have to note this statement:\\n\"If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\"\\n\\nSo, there might me a case when multiple servers are free and you could assign more than one task without increasing time variable."
                    },
                    {
                        "username": "pawan1818",
                        "content": "Could anyone help me debug the below code?\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n      \\n       \\n    // Server Priority Queue\\n    // 0 -> server\\n    // 1 -> server index\\n    PriorityQueue<List<Integer>> freeServer = new PriorityQueue<>(\\n            (a,b) -> {\\n              if(a.get(0) == b.get(0)){\\n                return a.get(1) - b.get(1);\\n              }else{\\n                return a.get(0) - b.get(0);\\n              }\\n            }\\n    );\\n\\n    // Create array list of servers with index\\n    for(int i=0;i<servers.length;i++){\\n      List<Integer> list = new ArrayList<>();\\n      list.add(servers[i]);\\n      list.add(i);\\n      freeServer.add(list);\\n    }\\n\\n\\n    // List<List<Integer>> usedServer = new ArrayList<>();\\n\\n    // 0 -> server\\n    // 1 -> server index\\n    // 2 -> time\\n    // Unavailable usedServer       \\n    PriorityQueue<List<Integer>> usedServer = new PriorityQueue<>(\\n            (a,b) -> a.get(2) - b.get(2)\\n    );\\n\\n    int time = 0;\\n\\n    int[] res = new int[tasks.length];\\n\\n\\n    for(int i=0;i<tasks.length;i++){\\n      time = Math.max(time, i);\\n\\n\\n    if(freeServer.size() == 0){\\n         time = usedServer.peek().get(2);\\n    }\\n    \\n      \\n      while(usedServer.size() > 0 && usedServer.peek().get(2) <= time){\\n\\n        List<Integer> list = usedServer.poll();\\n        List<Integer> newList = new ArrayList<>();\\n        newList.add(list.get(0));\\n        newList.add(list.get(1));\\n        freeServer.add(newList);\\n\\n      }\\n\\n      if(freeServer.size() != 0){\\n           List<Integer> list = freeServer.poll();\\n            // index 2 is time\\n            List<Integer> newList = new ArrayList<>();\\n            newList.add(list.get(0));\\n        newList.add(list.get(1));\\n             newList.add(tasks[i]+time);\\n             usedServer.add(newList);\\n            res[i] =newList.get(1);\\n            \\n      }\\n\\n    }\\n\\n\\n    return res;\\n    \\n    }\\n}\\n\\nThis test case fails\\nInput\\nservers =\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\ntasks =\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nOutput\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,34,22,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,34,51,11,53,36,57,26,5,36,56,55,31,22,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\nExpected\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,"
                    },
                    {
                        "username": "user9178m",
                        "content": "I'm a bit lost as to what I've done wrong. It's a rather large test case to run through, so in the meantime, if anyone spots my mistake, please let me know.\n\n `\n\n        serverHeap = [(w,i) for i,w in enumerate(servers)]\n        heapq.heapify(serverHeap)\n        workingHeap = []\n\n        res = []\n        time = 0\n        while len(tasks) > 0:\n\n            print(serverHeap, time)\n            if len(serverHeap) > 0:\n                server = heapq.heappop(serverHeap)\n                heapq.heappush(workingHeap, (tasks.pop(0)+time, server[0], server[1]))\n                res.append(server[1])\n                time += 1\n\n            else:\n                print(workingHeap)\n                server = heapq.heappop(workingHeap)\n                time = server[0]\n                heapq.heappush(serverHeap, (server[1], server[2]))\n            \n            while len(workingHeap) > 0 and workingHeap[0][0] <= time:\n                server = heapq.heappop(workingHeap)\n                heapq.heappush(serverHeap, (server[1], server[2]))\n        \n        return res            \n\n`"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "i have the same error. Seems to have issue with time variable. Did you find any solution ?"
                    }
                ]
            },
            {
                "id": 2020226,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "servers\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\ntasks\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\n\n\nThis test case probably incorrect! \nExpected output:\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5, \n 36,56, 55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\n\nI marked the wrong place. server#56 has to start doing task before server#36 because both of them free at that moment and do not have any current task. However, 56 server has weigh (147) lower than server#36(889).\nHave anybody also got this problem? \n\nOr can anyone answer. When I get few free servers at the same time. What server I have to pick next? With lower index or weigh?? "
                    },
                    {
                        "username": "ddubrava",
                        "content": " ith task becomes available at the ith second"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "[@miles_1337](/miles_1337) dude your test case is gold! i use a simple if statement to deal with backlogging, works perfectly!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) yes! I waste 8 hours in total to resolve it. Many times I just erased code and started again. A tried a lot of ways to resolve this. And every time I got different test cases fail. Finally, I have resolved it. And this task is totally hell! A have never wasted so much time to one problem here!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@miles_1337](/miles_1337) thanks!"
                    },
                    {
                        "username": "miles_1337",
                        "content": "Failing this test case means you\\'re incrementing time when you don\\'t need to. Consider the following (much simpler) scenario:\\n\\nservers:\\n[1, 20, 300]\\n\\ntasks:\\n[10, 9, 8, 1, 1, 1]\\n\\nThe first 3 tasks come in-- going to server 0, server 1, and then server 2 respectively. All 3 of these will finish simultaneously at time = 10 sec. At this point, the last 3 tasks are all waiting to be launched (they are \"backlogged\", not streaming in). The correct answer is that at time = 10, you launch all 3 \"backlogged\" tasks immediately (one on each server). However, if you\\'re not handling this case (and incrementing time when you don\\'t need to), the 4th task will be assigned to server 0... server 0 will finish that task in 1 sec, and then the 5th (and similarly the 6th) task will run on server 0.\\n\\nThis larger test case ends up being impacted by the above scenario, just in a much more complex situation. "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) Not yet. I have tried a few methods (by weight, by index, etc). But still get an error at different test cases. Temporary stopped to attempt. Because I already waste many hours. "
                    },
                    {
                        "username": "_Kuldeep_01",
                        "content": "yeah it is mentioned to pick the smallest weight nd if tie then go with the smallest index .....I got the same problem.. did you find the solution ?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "found it to be a lower hard than medium"
                    },
                    {
                        "username": "mohanyash73",
                        "content": "**You will be able to process the jth task starting from the jth second beginning with the 0th task at second 0. To process task j, you assign it to the server with the smallest weight that is free, and in case of a tie, choose the server with the smallest index. If a free server gets assigned task j at second t, it will be free again at the second t + tasks[j].**\\n--> from this statement I understood that at j\\'th second we can start processing the j\\'th task and we must choose the server which has the least weight and in case of ties the least index. And if we start processing at j\\'th second then till j + tasks[j] the choosen server won\\'t be free agian.\\n\\n**If there are no free servers, you must wait until one is free and execute the free tasks as soon as possible. If multiple tasks need to be assigned, assign them in order of increasing index.**\\n\\n--> because of this statement it gave a hint that there\\'s a possibility that at j\\'th second our servers might not be free. So we must wait until the server is free and then assign it to the server which becomes free ASAP.  But the last statement \"If multiple tasks need to be assigned, assign them in order of increasing index\" confused me. Does it mean that we choose the servers in increasing index or the tasks in increasing index ?\\n\\n\\n**You may assign multiple tasks at the same second if there are multiple free servers.**\\n--> And this statement says we might be able to assign multiple tasks at the same time. But the first statement said we should assign only at j\\'th second? So how could we assign multiple tasks at the same time? And what ordering should we follow while choosing the servers in this case??"
                    },
                    {
                        "username": "ddubrava",
                        "content": "It's funny though that you forgot to mention that 'ith task becomes available at the ith second,' and you can schedule multiple tasks at the same time...\n\nThe problem description by [@buttercup_powerPuff](/buttercup_powerPuff)\n\n> The problem statement is really poorly worded.\n> \n> Actual Problem Statement\n> There is a queue of M tasks where ith task becomes available at the ith second and takes a duration of tasks[i] to be processed. We > have N servers each with a weight and index of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least weight. If there are multiple servers with same weight, we pick the one with > lowest index. When scheduling at time t, the selected server will be free again at t + tasks[i].\n> \n> Scheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers."
                    },
                    {
                        "username": "apooash2020",
                        "content": "Can someone help ? I am getting TLE `import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        available_cpu = [] ## PQ with (cpu_weight, cpu_index)\\n        busy_cpu = [] ## PQ with (task_finish_time, cpu_weight, cpu_index)\\n\\n        for index,weight in enumerate(servers):\\n            heapq.heappush(available_cpu, (weight, index))\\n\\n        curr_time = 0\\n        q = []\\n        result = []\\n        curr_task = 0\\n\\n        num_of_tasks = len(tasks)\\n\\n        while curr_task < len(tasks) or len(q) !=0: ## do we check len(q) !=0\\n\\n            ## get free servers from busy list into available list  \\n            while len(busy_cpu)!= 0 and busy_cpu[0][0] <= curr_time:\\n                _,free_cpu_weight,free_cpu_index = heapq.heappop(busy_cpu)\\n                heapq.heappush(available_cpu, (free_cpu_weight, free_cpu_index))\\n\\n            if curr_task < len(tasks):\\n                curr_task_time = tasks[curr_task]\\n                q.append(curr_task_time)\\n\\n            if available_cpu:\\n                while len(available_cpu) > 0 and len(q) > 0:\\n                    first_inserted_task_in_q_weight = q.pop(0)\\n                    task_finish_time = curr_time + first_inserted_task_in_q_weight\\n                    available_cpu_weight,available_cpu_index = heapq.heappop(available_cpu)\\n                    result.append(available_cpu_index)\\n                    heapq.heappush(busy_cpu,(task_finish_time,available_cpu_weight,available_cpu_index) )\\n    \\n            curr_time += 1\\n            curr_task += 1\\n\\n        return result\\n`"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unnecessarily complicated business logic.\\n\\nHere are some test cases:\\n\\nservers=\\n```\\n[3, 7, 9, 1, 10, 10, 9, 10, 8, 8]\\n```\\ntasks=\\n```\\n[10, 6, 9, 2, 3, 7, 6, 4, 5, 5]\\n```\\n\\nservers=\\n```\\n[5, 5, 9, 9, 9, 5, 10]\\n```\\ntasks=\\n```\\n[9, 9, 9, 6, 7, 3, 1, 10, 8, 6, 8, 9, 5, 7, 8, 3, 7, 3, 3, 7]\\n```\\n\\nPython script to generate test cases\\n\\n```\\nn = 7\\nm = 20\\nmax_server_weight = 10\\nmax_task = 10\\n\\nservers = [random.randint(1, max_server_weight) for _ in range(n)]\\ntasks = [random.randint(1, max_task) for _ in range(m)]\\nprint(json.dumps(servers))\\nprint(json.dumps(tasks))\\n```"
                    },
                    {
                        "username": "had0uken",
                        "content": "It`s not clear for me. What server have I pick for task, when I get few free servers at the same time? With the lowest index or with the lowest weight. Please explain anyone )"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) тю... ох и бредовое задание) То есть вначале задания назначаются постепенно, а потом уже как сервера поработали - одновременно? ) Автор задания умеет поиздеваться. И не так сложно задание, как понять что от тебя хотят сделать! ("
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0412\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u041D\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u0430\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C \\u043E\\u0434\\u043D\\u0443 \\u0434\\u0435\\u0442\\u0430\\u043B\\u044C: \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0437\\u0430\\u0434\\u0430\\u0447 \\u0436\\u0434\\u0443\\u0442 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438 (\\u0412\\u0441\\u0435 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043D\\u044F\\u0442\\u044B 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0437\\u0430 \\u044D\\u0442\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F 5 \\u0437\\u0430\\u0434\\u0430\\u0447 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438 \\u0436\\u0434\\u0430\\u0442\\u044C \\u0441\\u0432\\u043E\\u0435\\u0439 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438) \\u0438 \\u043E\\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u0438\\u043B\\u043E\\u0441\\u044C 3 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 - 3 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0431\\u044B\\u0442\\u044C \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044B \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0438 \\u0435\\u0449\\u0435 \\u043E\\u0434\\u0438\\u043D \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441: \\u0434\\u043E\\u043F\\u0443\\u0441\\u0442\\u0438\\u043C \\u0435\\u0441\\u0442\\u044C 3 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430. \\u0422\\u0440\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F \\u043D\\u0430 \\u043D\\u0438\\u0445 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0442\\u0443 \\u0436\\u0435 \\u0441\\u0430\\u043C\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443? \\u0418\\u043B\\u0438 \\u0432 \\u043F\\u0435\\u0440\\u0432\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 \\u043D\\u0430 1 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F, \\u043D\\u0430 2 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 - \\u043D\\u0430 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439, \\u0438 \\u0432 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0430 \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0439 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u0439\\u0434\\u0435\\u0439\\u0441\\u0442\\u043E\\u0432\\u0430\\u043D 3\\u0438\\u0439 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440? "
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0415\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F, \\u043C\\u044B \\u0432\\u044B\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043F\\u043E \\u0442\\u043E\\u043C\\u0443 \\u0436\\u0435 \\u043F\\u0440\\u0438\\u043D\\u0446\\u0438\\u043F\\u0443, \\u0447\\u0442\\u043E \\u0438 \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435. \\u0421\\u0435\\u0440\\u0432\\u0435\\u0440 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0435\\u0441\\u043B\\u0438 \\u0432\\u0435\\u0441\\u0430 \\u0440\\u0430\\u0432\\u043D\\u044B, \\u0442\\u043E \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0412\\u0438\\u0436\\u0443, \\u0447\\u0442\\u043E \\u0442\\u0435\\u0431\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438 \\u043D\\u0430 \\u0440\\u0443\\u0441\\u0441\\u043A\\u043E\\u043C \\u043D\\u0430\\u043F\\u0438\\u0441\\u0430\\u0442\\u044C. \\u041F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0436\\u0438 \\u043F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430. \\u0412\\u043E\\u0442 \\u043C\\u044B \\u0444\\u043E\\u0440\\u043C\\u0438\\u0440\\u0443\\u0435\\u043C \\u0444\\u0438\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u041A\\u0430\\u043A\\u043E\\u0435 \\u0442\\u0430\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043E\\u043A\\u0430\\u0436\\u0435\\u0442\\u0441\\u044F \\u043F\\u0435\\u0440\\u0432\\u0435\\u0435, \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F. \\u0422\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0438\\u043B\\u0438 \\u0442\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C? \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E \\u0437\\u0430\\u0440\\u0430\\u043D\\u0435\\u0435 "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) Thanx. I got it about time variable. But when I assign two task at the same time, what task I have to write to result array firstly? With the lowest index or lowest weight. What the main priority?"
                    },
                    {
                        "username": "Pavjelv",
                        "content": "You have to note this statement:\\n\"If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\"\\n\\nSo, there might me a case when multiple servers are free and you could assign more than one task without increasing time variable."
                    },
                    {
                        "username": "pawan1818",
                        "content": "Could anyone help me debug the below code?\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n      \\n       \\n    // Server Priority Queue\\n    // 0 -> server\\n    // 1 -> server index\\n    PriorityQueue<List<Integer>> freeServer = new PriorityQueue<>(\\n            (a,b) -> {\\n              if(a.get(0) == b.get(0)){\\n                return a.get(1) - b.get(1);\\n              }else{\\n                return a.get(0) - b.get(0);\\n              }\\n            }\\n    );\\n\\n    // Create array list of servers with index\\n    for(int i=0;i<servers.length;i++){\\n      List<Integer> list = new ArrayList<>();\\n      list.add(servers[i]);\\n      list.add(i);\\n      freeServer.add(list);\\n    }\\n\\n\\n    // List<List<Integer>> usedServer = new ArrayList<>();\\n\\n    // 0 -> server\\n    // 1 -> server index\\n    // 2 -> time\\n    // Unavailable usedServer       \\n    PriorityQueue<List<Integer>> usedServer = new PriorityQueue<>(\\n            (a,b) -> a.get(2) - b.get(2)\\n    );\\n\\n    int time = 0;\\n\\n    int[] res = new int[tasks.length];\\n\\n\\n    for(int i=0;i<tasks.length;i++){\\n      time = Math.max(time, i);\\n\\n\\n    if(freeServer.size() == 0){\\n         time = usedServer.peek().get(2);\\n    }\\n    \\n      \\n      while(usedServer.size() > 0 && usedServer.peek().get(2) <= time){\\n\\n        List<Integer> list = usedServer.poll();\\n        List<Integer> newList = new ArrayList<>();\\n        newList.add(list.get(0));\\n        newList.add(list.get(1));\\n        freeServer.add(newList);\\n\\n      }\\n\\n      if(freeServer.size() != 0){\\n           List<Integer> list = freeServer.poll();\\n            // index 2 is time\\n            List<Integer> newList = new ArrayList<>();\\n            newList.add(list.get(0));\\n        newList.add(list.get(1));\\n             newList.add(tasks[i]+time);\\n             usedServer.add(newList);\\n            res[i] =newList.get(1);\\n            \\n      }\\n\\n    }\\n\\n\\n    return res;\\n    \\n    }\\n}\\n\\nThis test case fails\\nInput\\nservers =\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\ntasks =\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nOutput\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,34,22,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,34,51,11,53,36,57,26,5,36,56,55,31,22,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\nExpected\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,"
                    },
                    {
                        "username": "user9178m",
                        "content": "I'm a bit lost as to what I've done wrong. It's a rather large test case to run through, so in the meantime, if anyone spots my mistake, please let me know.\n\n `\n\n        serverHeap = [(w,i) for i,w in enumerate(servers)]\n        heapq.heapify(serverHeap)\n        workingHeap = []\n\n        res = []\n        time = 0\n        while len(tasks) > 0:\n\n            print(serverHeap, time)\n            if len(serverHeap) > 0:\n                server = heapq.heappop(serverHeap)\n                heapq.heappush(workingHeap, (tasks.pop(0)+time, server[0], server[1]))\n                res.append(server[1])\n                time += 1\n\n            else:\n                print(workingHeap)\n                server = heapq.heappop(workingHeap)\n                time = server[0]\n                heapq.heappush(serverHeap, (server[1], server[2]))\n            \n            while len(workingHeap) > 0 and workingHeap[0][0] <= time:\n                server = heapq.heappop(workingHeap)\n                heapq.heappush(serverHeap, (server[1], server[2]))\n        \n        return res            \n\n`"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "i have the same error. Seems to have issue with time variable. Did you find any solution ?"
                    }
                ]
            },
            {
                "id": 1984400,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "servers\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\ntasks\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\n\n\nThis test case probably incorrect! \nExpected output:\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5, \n 36,56, 55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\n\nI marked the wrong place. server#56 has to start doing task before server#36 because both of them free at that moment and do not have any current task. However, 56 server has weigh (147) lower than server#36(889).\nHave anybody also got this problem? \n\nOr can anyone answer. When I get few free servers at the same time. What server I have to pick next? With lower index or weigh?? "
                    },
                    {
                        "username": "ddubrava",
                        "content": " ith task becomes available at the ith second"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "[@miles_1337](/miles_1337) dude your test case is gold! i use a simple if statement to deal with backlogging, works perfectly!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) yes! I waste 8 hours in total to resolve it. Many times I just erased code and started again. A tried a lot of ways to resolve this. And every time I got different test cases fail. Finally, I have resolved it. And this task is totally hell! A have never wasted so much time to one problem here!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@miles_1337](/miles_1337) thanks!"
                    },
                    {
                        "username": "miles_1337",
                        "content": "Failing this test case means you\\'re incrementing time when you don\\'t need to. Consider the following (much simpler) scenario:\\n\\nservers:\\n[1, 20, 300]\\n\\ntasks:\\n[10, 9, 8, 1, 1, 1]\\n\\nThe first 3 tasks come in-- going to server 0, server 1, and then server 2 respectively. All 3 of these will finish simultaneously at time = 10 sec. At this point, the last 3 tasks are all waiting to be launched (they are \"backlogged\", not streaming in). The correct answer is that at time = 10, you launch all 3 \"backlogged\" tasks immediately (one on each server). However, if you\\'re not handling this case (and incrementing time when you don\\'t need to), the 4th task will be assigned to server 0... server 0 will finish that task in 1 sec, and then the 5th (and similarly the 6th) task will run on server 0.\\n\\nThis larger test case ends up being impacted by the above scenario, just in a much more complex situation. "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) Not yet. I have tried a few methods (by weight, by index, etc). But still get an error at different test cases. Temporary stopped to attempt. Because I already waste many hours. "
                    },
                    {
                        "username": "_Kuldeep_01",
                        "content": "yeah it is mentioned to pick the smallest weight nd if tie then go with the smallest index .....I got the same problem.. did you find the solution ?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "found it to be a lower hard than medium"
                    },
                    {
                        "username": "mohanyash73",
                        "content": "**You will be able to process the jth task starting from the jth second beginning with the 0th task at second 0. To process task j, you assign it to the server with the smallest weight that is free, and in case of a tie, choose the server with the smallest index. If a free server gets assigned task j at second t, it will be free again at the second t + tasks[j].**\\n--> from this statement I understood that at j\\'th second we can start processing the j\\'th task and we must choose the server which has the least weight and in case of ties the least index. And if we start processing at j\\'th second then till j + tasks[j] the choosen server won\\'t be free agian.\\n\\n**If there are no free servers, you must wait until one is free and execute the free tasks as soon as possible. If multiple tasks need to be assigned, assign them in order of increasing index.**\\n\\n--> because of this statement it gave a hint that there\\'s a possibility that at j\\'th second our servers might not be free. So we must wait until the server is free and then assign it to the server which becomes free ASAP.  But the last statement \"If multiple tasks need to be assigned, assign them in order of increasing index\" confused me. Does it mean that we choose the servers in increasing index or the tasks in increasing index ?\\n\\n\\n**You may assign multiple tasks at the same second if there are multiple free servers.**\\n--> And this statement says we might be able to assign multiple tasks at the same time. But the first statement said we should assign only at j\\'th second? So how could we assign multiple tasks at the same time? And what ordering should we follow while choosing the servers in this case??"
                    },
                    {
                        "username": "ddubrava",
                        "content": "It's funny though that you forgot to mention that 'ith task becomes available at the ith second,' and you can schedule multiple tasks at the same time...\n\nThe problem description by [@buttercup_powerPuff](/buttercup_powerPuff)\n\n> The problem statement is really poorly worded.\n> \n> Actual Problem Statement\n> There is a queue of M tasks where ith task becomes available at the ith second and takes a duration of tasks[i] to be processed. We > have N servers each with a weight and index of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least weight. If there are multiple servers with same weight, we pick the one with > lowest index. When scheduling at time t, the selected server will be free again at t + tasks[i].\n> \n> Scheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers."
                    },
                    {
                        "username": "apooash2020",
                        "content": "Can someone help ? I am getting TLE `import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        available_cpu = [] ## PQ with (cpu_weight, cpu_index)\\n        busy_cpu = [] ## PQ with (task_finish_time, cpu_weight, cpu_index)\\n\\n        for index,weight in enumerate(servers):\\n            heapq.heappush(available_cpu, (weight, index))\\n\\n        curr_time = 0\\n        q = []\\n        result = []\\n        curr_task = 0\\n\\n        num_of_tasks = len(tasks)\\n\\n        while curr_task < len(tasks) or len(q) !=0: ## do we check len(q) !=0\\n\\n            ## get free servers from busy list into available list  \\n            while len(busy_cpu)!= 0 and busy_cpu[0][0] <= curr_time:\\n                _,free_cpu_weight,free_cpu_index = heapq.heappop(busy_cpu)\\n                heapq.heappush(available_cpu, (free_cpu_weight, free_cpu_index))\\n\\n            if curr_task < len(tasks):\\n                curr_task_time = tasks[curr_task]\\n                q.append(curr_task_time)\\n\\n            if available_cpu:\\n                while len(available_cpu) > 0 and len(q) > 0:\\n                    first_inserted_task_in_q_weight = q.pop(0)\\n                    task_finish_time = curr_time + first_inserted_task_in_q_weight\\n                    available_cpu_weight,available_cpu_index = heapq.heappop(available_cpu)\\n                    result.append(available_cpu_index)\\n                    heapq.heappush(busy_cpu,(task_finish_time,available_cpu_weight,available_cpu_index) )\\n    \\n            curr_time += 1\\n            curr_task += 1\\n\\n        return result\\n`"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unnecessarily complicated business logic.\\n\\nHere are some test cases:\\n\\nservers=\\n```\\n[3, 7, 9, 1, 10, 10, 9, 10, 8, 8]\\n```\\ntasks=\\n```\\n[10, 6, 9, 2, 3, 7, 6, 4, 5, 5]\\n```\\n\\nservers=\\n```\\n[5, 5, 9, 9, 9, 5, 10]\\n```\\ntasks=\\n```\\n[9, 9, 9, 6, 7, 3, 1, 10, 8, 6, 8, 9, 5, 7, 8, 3, 7, 3, 3, 7]\\n```\\n\\nPython script to generate test cases\\n\\n```\\nn = 7\\nm = 20\\nmax_server_weight = 10\\nmax_task = 10\\n\\nservers = [random.randint(1, max_server_weight) for _ in range(n)]\\ntasks = [random.randint(1, max_task) for _ in range(m)]\\nprint(json.dumps(servers))\\nprint(json.dumps(tasks))\\n```"
                    },
                    {
                        "username": "had0uken",
                        "content": "It`s not clear for me. What server have I pick for task, when I get few free servers at the same time? With the lowest index or with the lowest weight. Please explain anyone )"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) тю... ох и бредовое задание) То есть вначале задания назначаются постепенно, а потом уже как сервера поработали - одновременно? ) Автор задания умеет поиздеваться. И не так сложно задание, как понять что от тебя хотят сделать! ("
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0412\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u041D\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u0430\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C \\u043E\\u0434\\u043D\\u0443 \\u0434\\u0435\\u0442\\u0430\\u043B\\u044C: \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0437\\u0430\\u0434\\u0430\\u0447 \\u0436\\u0434\\u0443\\u0442 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438 (\\u0412\\u0441\\u0435 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043D\\u044F\\u0442\\u044B 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0437\\u0430 \\u044D\\u0442\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F 5 \\u0437\\u0430\\u0434\\u0430\\u0447 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438 \\u0436\\u0434\\u0430\\u0442\\u044C \\u0441\\u0432\\u043E\\u0435\\u0439 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438) \\u0438 \\u043E\\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u0438\\u043B\\u043E\\u0441\\u044C 3 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 - 3 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0431\\u044B\\u0442\\u044C \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044B \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0438 \\u0435\\u0449\\u0435 \\u043E\\u0434\\u0438\\u043D \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441: \\u0434\\u043E\\u043F\\u0443\\u0441\\u0442\\u0438\\u043C \\u0435\\u0441\\u0442\\u044C 3 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430. \\u0422\\u0440\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F \\u043D\\u0430 \\u043D\\u0438\\u0445 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0442\\u0443 \\u0436\\u0435 \\u0441\\u0430\\u043C\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443? \\u0418\\u043B\\u0438 \\u0432 \\u043F\\u0435\\u0440\\u0432\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 \\u043D\\u0430 1 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F, \\u043D\\u0430 2 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 - \\u043D\\u0430 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439, \\u0438 \\u0432 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0430 \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0439 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u0439\\u0434\\u0435\\u0439\\u0441\\u0442\\u043E\\u0432\\u0430\\u043D 3\\u0438\\u0439 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440? "
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0415\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F, \\u043C\\u044B \\u0432\\u044B\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043F\\u043E \\u0442\\u043E\\u043C\\u0443 \\u0436\\u0435 \\u043F\\u0440\\u0438\\u043D\\u0446\\u0438\\u043F\\u0443, \\u0447\\u0442\\u043E \\u0438 \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435. \\u0421\\u0435\\u0440\\u0432\\u0435\\u0440 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0435\\u0441\\u043B\\u0438 \\u0432\\u0435\\u0441\\u0430 \\u0440\\u0430\\u0432\\u043D\\u044B, \\u0442\\u043E \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0412\\u0438\\u0436\\u0443, \\u0447\\u0442\\u043E \\u0442\\u0435\\u0431\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438 \\u043D\\u0430 \\u0440\\u0443\\u0441\\u0441\\u043A\\u043E\\u043C \\u043D\\u0430\\u043F\\u0438\\u0441\\u0430\\u0442\\u044C. \\u041F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0436\\u0438 \\u043F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430. \\u0412\\u043E\\u0442 \\u043C\\u044B \\u0444\\u043E\\u0440\\u043C\\u0438\\u0440\\u0443\\u0435\\u043C \\u0444\\u0438\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u041A\\u0430\\u043A\\u043E\\u0435 \\u0442\\u0430\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043E\\u043A\\u0430\\u0436\\u0435\\u0442\\u0441\\u044F \\u043F\\u0435\\u0440\\u0432\\u0435\\u0435, \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F. \\u0422\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0438\\u043B\\u0438 \\u0442\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C? \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E \\u0437\\u0430\\u0440\\u0430\\u043D\\u0435\\u0435 "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) Thanx. I got it about time variable. But when I assign two task at the same time, what task I have to write to result array firstly? With the lowest index or lowest weight. What the main priority?"
                    },
                    {
                        "username": "Pavjelv",
                        "content": "You have to note this statement:\\n\"If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\"\\n\\nSo, there might me a case when multiple servers are free and you could assign more than one task without increasing time variable."
                    },
                    {
                        "username": "pawan1818",
                        "content": "Could anyone help me debug the below code?\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n      \\n       \\n    // Server Priority Queue\\n    // 0 -> server\\n    // 1 -> server index\\n    PriorityQueue<List<Integer>> freeServer = new PriorityQueue<>(\\n            (a,b) -> {\\n              if(a.get(0) == b.get(0)){\\n                return a.get(1) - b.get(1);\\n              }else{\\n                return a.get(0) - b.get(0);\\n              }\\n            }\\n    );\\n\\n    // Create array list of servers with index\\n    for(int i=0;i<servers.length;i++){\\n      List<Integer> list = new ArrayList<>();\\n      list.add(servers[i]);\\n      list.add(i);\\n      freeServer.add(list);\\n    }\\n\\n\\n    // List<List<Integer>> usedServer = new ArrayList<>();\\n\\n    // 0 -> server\\n    // 1 -> server index\\n    // 2 -> time\\n    // Unavailable usedServer       \\n    PriorityQueue<List<Integer>> usedServer = new PriorityQueue<>(\\n            (a,b) -> a.get(2) - b.get(2)\\n    );\\n\\n    int time = 0;\\n\\n    int[] res = new int[tasks.length];\\n\\n\\n    for(int i=0;i<tasks.length;i++){\\n      time = Math.max(time, i);\\n\\n\\n    if(freeServer.size() == 0){\\n         time = usedServer.peek().get(2);\\n    }\\n    \\n      \\n      while(usedServer.size() > 0 && usedServer.peek().get(2) <= time){\\n\\n        List<Integer> list = usedServer.poll();\\n        List<Integer> newList = new ArrayList<>();\\n        newList.add(list.get(0));\\n        newList.add(list.get(1));\\n        freeServer.add(newList);\\n\\n      }\\n\\n      if(freeServer.size() != 0){\\n           List<Integer> list = freeServer.poll();\\n            // index 2 is time\\n            List<Integer> newList = new ArrayList<>();\\n            newList.add(list.get(0));\\n        newList.add(list.get(1));\\n             newList.add(tasks[i]+time);\\n             usedServer.add(newList);\\n            res[i] =newList.get(1);\\n            \\n      }\\n\\n    }\\n\\n\\n    return res;\\n    \\n    }\\n}\\n\\nThis test case fails\\nInput\\nservers =\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\ntasks =\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nOutput\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,34,22,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,34,51,11,53,36,57,26,5,36,56,55,31,22,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\nExpected\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,"
                    },
                    {
                        "username": "user9178m",
                        "content": "I'm a bit lost as to what I've done wrong. It's a rather large test case to run through, so in the meantime, if anyone spots my mistake, please let me know.\n\n `\n\n        serverHeap = [(w,i) for i,w in enumerate(servers)]\n        heapq.heapify(serverHeap)\n        workingHeap = []\n\n        res = []\n        time = 0\n        while len(tasks) > 0:\n\n            print(serverHeap, time)\n            if len(serverHeap) > 0:\n                server = heapq.heappop(serverHeap)\n                heapq.heappush(workingHeap, (tasks.pop(0)+time, server[0], server[1]))\n                res.append(server[1])\n                time += 1\n\n            else:\n                print(workingHeap)\n                server = heapq.heappop(workingHeap)\n                time = server[0]\n                heapq.heappush(serverHeap, (server[1], server[2]))\n            \n            while len(workingHeap) > 0 and workingHeap[0][0] <= time:\n                server = heapq.heappop(workingHeap)\n                heapq.heappush(serverHeap, (server[1], server[2]))\n        \n        return res            \n\n`"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "i have the same error. Seems to have issue with time variable. Did you find any solution ?"
                    }
                ]
            },
            {
                "id": 1945518,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "servers\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\ntasks\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\n\n\nThis test case probably incorrect! \nExpected output:\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5, \n 36,56, 55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\n\nI marked the wrong place. server#56 has to start doing task before server#36 because both of them free at that moment and do not have any current task. However, 56 server has weigh (147) lower than server#36(889).\nHave anybody also got this problem? \n\nOr can anyone answer. When I get few free servers at the same time. What server I have to pick next? With lower index or weigh?? "
                    },
                    {
                        "username": "ddubrava",
                        "content": " ith task becomes available at the ith second"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "[@miles_1337](/miles_1337) dude your test case is gold! i use a simple if statement to deal with backlogging, works perfectly!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) yes! I waste 8 hours in total to resolve it. Many times I just erased code and started again. A tried a lot of ways to resolve this. And every time I got different test cases fail. Finally, I have resolved it. And this task is totally hell! A have never wasted so much time to one problem here!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@miles_1337](/miles_1337) thanks!"
                    },
                    {
                        "username": "miles_1337",
                        "content": "Failing this test case means you\\'re incrementing time when you don\\'t need to. Consider the following (much simpler) scenario:\\n\\nservers:\\n[1, 20, 300]\\n\\ntasks:\\n[10, 9, 8, 1, 1, 1]\\n\\nThe first 3 tasks come in-- going to server 0, server 1, and then server 2 respectively. All 3 of these will finish simultaneously at time = 10 sec. At this point, the last 3 tasks are all waiting to be launched (they are \"backlogged\", not streaming in). The correct answer is that at time = 10, you launch all 3 \"backlogged\" tasks immediately (one on each server). However, if you\\'re not handling this case (and incrementing time when you don\\'t need to), the 4th task will be assigned to server 0... server 0 will finish that task in 1 sec, and then the 5th (and similarly the 6th) task will run on server 0.\\n\\nThis larger test case ends up being impacted by the above scenario, just in a much more complex situation. "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) Not yet. I have tried a few methods (by weight, by index, etc). But still get an error at different test cases. Temporary stopped to attempt. Because I already waste many hours. "
                    },
                    {
                        "username": "_Kuldeep_01",
                        "content": "yeah it is mentioned to pick the smallest weight nd if tie then go with the smallest index .....I got the same problem.. did you find the solution ?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "found it to be a lower hard than medium"
                    },
                    {
                        "username": "mohanyash73",
                        "content": "**You will be able to process the jth task starting from the jth second beginning with the 0th task at second 0. To process task j, you assign it to the server with the smallest weight that is free, and in case of a tie, choose the server with the smallest index. If a free server gets assigned task j at second t, it will be free again at the second t + tasks[j].**\\n--> from this statement I understood that at j\\'th second we can start processing the j\\'th task and we must choose the server which has the least weight and in case of ties the least index. And if we start processing at j\\'th second then till j + tasks[j] the choosen server won\\'t be free agian.\\n\\n**If there are no free servers, you must wait until one is free and execute the free tasks as soon as possible. If multiple tasks need to be assigned, assign them in order of increasing index.**\\n\\n--> because of this statement it gave a hint that there\\'s a possibility that at j\\'th second our servers might not be free. So we must wait until the server is free and then assign it to the server which becomes free ASAP.  But the last statement \"If multiple tasks need to be assigned, assign them in order of increasing index\" confused me. Does it mean that we choose the servers in increasing index or the tasks in increasing index ?\\n\\n\\n**You may assign multiple tasks at the same second if there are multiple free servers.**\\n--> And this statement says we might be able to assign multiple tasks at the same time. But the first statement said we should assign only at j\\'th second? So how could we assign multiple tasks at the same time? And what ordering should we follow while choosing the servers in this case??"
                    },
                    {
                        "username": "ddubrava",
                        "content": "It's funny though that you forgot to mention that 'ith task becomes available at the ith second,' and you can schedule multiple tasks at the same time...\n\nThe problem description by [@buttercup_powerPuff](/buttercup_powerPuff)\n\n> The problem statement is really poorly worded.\n> \n> Actual Problem Statement\n> There is a queue of M tasks where ith task becomes available at the ith second and takes a duration of tasks[i] to be processed. We > have N servers each with a weight and index of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least weight. If there are multiple servers with same weight, we pick the one with > lowest index. When scheduling at time t, the selected server will be free again at t + tasks[i].\n> \n> Scheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers."
                    },
                    {
                        "username": "apooash2020",
                        "content": "Can someone help ? I am getting TLE `import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        available_cpu = [] ## PQ with (cpu_weight, cpu_index)\\n        busy_cpu = [] ## PQ with (task_finish_time, cpu_weight, cpu_index)\\n\\n        for index,weight in enumerate(servers):\\n            heapq.heappush(available_cpu, (weight, index))\\n\\n        curr_time = 0\\n        q = []\\n        result = []\\n        curr_task = 0\\n\\n        num_of_tasks = len(tasks)\\n\\n        while curr_task < len(tasks) or len(q) !=0: ## do we check len(q) !=0\\n\\n            ## get free servers from busy list into available list  \\n            while len(busy_cpu)!= 0 and busy_cpu[0][0] <= curr_time:\\n                _,free_cpu_weight,free_cpu_index = heapq.heappop(busy_cpu)\\n                heapq.heappush(available_cpu, (free_cpu_weight, free_cpu_index))\\n\\n            if curr_task < len(tasks):\\n                curr_task_time = tasks[curr_task]\\n                q.append(curr_task_time)\\n\\n            if available_cpu:\\n                while len(available_cpu) > 0 and len(q) > 0:\\n                    first_inserted_task_in_q_weight = q.pop(0)\\n                    task_finish_time = curr_time + first_inserted_task_in_q_weight\\n                    available_cpu_weight,available_cpu_index = heapq.heappop(available_cpu)\\n                    result.append(available_cpu_index)\\n                    heapq.heappush(busy_cpu,(task_finish_time,available_cpu_weight,available_cpu_index) )\\n    \\n            curr_time += 1\\n            curr_task += 1\\n\\n        return result\\n`"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unnecessarily complicated business logic.\\n\\nHere are some test cases:\\n\\nservers=\\n```\\n[3, 7, 9, 1, 10, 10, 9, 10, 8, 8]\\n```\\ntasks=\\n```\\n[10, 6, 9, 2, 3, 7, 6, 4, 5, 5]\\n```\\n\\nservers=\\n```\\n[5, 5, 9, 9, 9, 5, 10]\\n```\\ntasks=\\n```\\n[9, 9, 9, 6, 7, 3, 1, 10, 8, 6, 8, 9, 5, 7, 8, 3, 7, 3, 3, 7]\\n```\\n\\nPython script to generate test cases\\n\\n```\\nn = 7\\nm = 20\\nmax_server_weight = 10\\nmax_task = 10\\n\\nservers = [random.randint(1, max_server_weight) for _ in range(n)]\\ntasks = [random.randint(1, max_task) for _ in range(m)]\\nprint(json.dumps(servers))\\nprint(json.dumps(tasks))\\n```"
                    },
                    {
                        "username": "had0uken",
                        "content": "It`s not clear for me. What server have I pick for task, when I get few free servers at the same time? With the lowest index or with the lowest weight. Please explain anyone )"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) тю... ох и бредовое задание) То есть вначале задания назначаются постепенно, а потом уже как сервера поработали - одновременно? ) Автор задания умеет поиздеваться. И не так сложно задание, как понять что от тебя хотят сделать! ("
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0412\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u041D\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u0430\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C \\u043E\\u0434\\u043D\\u0443 \\u0434\\u0435\\u0442\\u0430\\u043B\\u044C: \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0437\\u0430\\u0434\\u0430\\u0447 \\u0436\\u0434\\u0443\\u0442 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438 (\\u0412\\u0441\\u0435 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043D\\u044F\\u0442\\u044B 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0437\\u0430 \\u044D\\u0442\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F 5 \\u0437\\u0430\\u0434\\u0430\\u0447 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438 \\u0436\\u0434\\u0430\\u0442\\u044C \\u0441\\u0432\\u043E\\u0435\\u0439 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438) \\u0438 \\u043E\\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u0438\\u043B\\u043E\\u0441\\u044C 3 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 - 3 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0431\\u044B\\u0442\\u044C \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044B \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0438 \\u0435\\u0449\\u0435 \\u043E\\u0434\\u0438\\u043D \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441: \\u0434\\u043E\\u043F\\u0443\\u0441\\u0442\\u0438\\u043C \\u0435\\u0441\\u0442\\u044C 3 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430. \\u0422\\u0440\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F \\u043D\\u0430 \\u043D\\u0438\\u0445 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0442\\u0443 \\u0436\\u0435 \\u0441\\u0430\\u043C\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443? \\u0418\\u043B\\u0438 \\u0432 \\u043F\\u0435\\u0440\\u0432\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 \\u043D\\u0430 1 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F, \\u043D\\u0430 2 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 - \\u043D\\u0430 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439, \\u0438 \\u0432 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0430 \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0439 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u0439\\u0434\\u0435\\u0439\\u0441\\u0442\\u043E\\u0432\\u0430\\u043D 3\\u0438\\u0439 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440? "
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0415\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F, \\u043C\\u044B \\u0432\\u044B\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043F\\u043E \\u0442\\u043E\\u043C\\u0443 \\u0436\\u0435 \\u043F\\u0440\\u0438\\u043D\\u0446\\u0438\\u043F\\u0443, \\u0447\\u0442\\u043E \\u0438 \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435. \\u0421\\u0435\\u0440\\u0432\\u0435\\u0440 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0435\\u0441\\u043B\\u0438 \\u0432\\u0435\\u0441\\u0430 \\u0440\\u0430\\u0432\\u043D\\u044B, \\u0442\\u043E \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0412\\u0438\\u0436\\u0443, \\u0447\\u0442\\u043E \\u0442\\u0435\\u0431\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438 \\u043D\\u0430 \\u0440\\u0443\\u0441\\u0441\\u043A\\u043E\\u043C \\u043D\\u0430\\u043F\\u0438\\u0441\\u0430\\u0442\\u044C. \\u041F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0436\\u0438 \\u043F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430. \\u0412\\u043E\\u0442 \\u043C\\u044B \\u0444\\u043E\\u0440\\u043C\\u0438\\u0440\\u0443\\u0435\\u043C \\u0444\\u0438\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u041A\\u0430\\u043A\\u043E\\u0435 \\u0442\\u0430\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043E\\u043A\\u0430\\u0436\\u0435\\u0442\\u0441\\u044F \\u043F\\u0435\\u0440\\u0432\\u0435\\u0435, \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F. \\u0422\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0438\\u043B\\u0438 \\u0442\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C? \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E \\u0437\\u0430\\u0440\\u0430\\u043D\\u0435\\u0435 "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) Thanx. I got it about time variable. But when I assign two task at the same time, what task I have to write to result array firstly? With the lowest index or lowest weight. What the main priority?"
                    },
                    {
                        "username": "Pavjelv",
                        "content": "You have to note this statement:\\n\"If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\"\\n\\nSo, there might me a case when multiple servers are free and you could assign more than one task without increasing time variable."
                    },
                    {
                        "username": "pawan1818",
                        "content": "Could anyone help me debug the below code?\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n      \\n       \\n    // Server Priority Queue\\n    // 0 -> server\\n    // 1 -> server index\\n    PriorityQueue<List<Integer>> freeServer = new PriorityQueue<>(\\n            (a,b) -> {\\n              if(a.get(0) == b.get(0)){\\n                return a.get(1) - b.get(1);\\n              }else{\\n                return a.get(0) - b.get(0);\\n              }\\n            }\\n    );\\n\\n    // Create array list of servers with index\\n    for(int i=0;i<servers.length;i++){\\n      List<Integer> list = new ArrayList<>();\\n      list.add(servers[i]);\\n      list.add(i);\\n      freeServer.add(list);\\n    }\\n\\n\\n    // List<List<Integer>> usedServer = new ArrayList<>();\\n\\n    // 0 -> server\\n    // 1 -> server index\\n    // 2 -> time\\n    // Unavailable usedServer       \\n    PriorityQueue<List<Integer>> usedServer = new PriorityQueue<>(\\n            (a,b) -> a.get(2) - b.get(2)\\n    );\\n\\n    int time = 0;\\n\\n    int[] res = new int[tasks.length];\\n\\n\\n    for(int i=0;i<tasks.length;i++){\\n      time = Math.max(time, i);\\n\\n\\n    if(freeServer.size() == 0){\\n         time = usedServer.peek().get(2);\\n    }\\n    \\n      \\n      while(usedServer.size() > 0 && usedServer.peek().get(2) <= time){\\n\\n        List<Integer> list = usedServer.poll();\\n        List<Integer> newList = new ArrayList<>();\\n        newList.add(list.get(0));\\n        newList.add(list.get(1));\\n        freeServer.add(newList);\\n\\n      }\\n\\n      if(freeServer.size() != 0){\\n           List<Integer> list = freeServer.poll();\\n            // index 2 is time\\n            List<Integer> newList = new ArrayList<>();\\n            newList.add(list.get(0));\\n        newList.add(list.get(1));\\n             newList.add(tasks[i]+time);\\n             usedServer.add(newList);\\n            res[i] =newList.get(1);\\n            \\n      }\\n\\n    }\\n\\n\\n    return res;\\n    \\n    }\\n}\\n\\nThis test case fails\\nInput\\nservers =\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\ntasks =\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nOutput\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,34,22,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,34,51,11,53,36,57,26,5,36,56,55,31,22,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\nExpected\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,"
                    },
                    {
                        "username": "user9178m",
                        "content": "I'm a bit lost as to what I've done wrong. It's a rather large test case to run through, so in the meantime, if anyone spots my mistake, please let me know.\n\n `\n\n        serverHeap = [(w,i) for i,w in enumerate(servers)]\n        heapq.heapify(serverHeap)\n        workingHeap = []\n\n        res = []\n        time = 0\n        while len(tasks) > 0:\n\n            print(serverHeap, time)\n            if len(serverHeap) > 0:\n                server = heapq.heappop(serverHeap)\n                heapq.heappush(workingHeap, (tasks.pop(0)+time, server[0], server[1]))\n                res.append(server[1])\n                time += 1\n\n            else:\n                print(workingHeap)\n                server = heapq.heappop(workingHeap)\n                time = server[0]\n                heapq.heappush(serverHeap, (server[1], server[2]))\n            \n            while len(workingHeap) > 0 and workingHeap[0][0] <= time:\n                server = heapq.heappop(workingHeap)\n                heapq.heappush(serverHeap, (server[1], server[2]))\n        \n        return res            \n\n`"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "i have the same error. Seems to have issue with time variable. Did you find any solution ?"
                    }
                ]
            },
            {
                "id": 1810009,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "servers\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\ntasks\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\n\n\nThis test case probably incorrect! \nExpected output:\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5, \n 36,56, 55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\n\nI marked the wrong place. server#56 has to start doing task before server#36 because both of them free at that moment and do not have any current task. However, 56 server has weigh (147) lower than server#36(889).\nHave anybody also got this problem? \n\nOr can anyone answer. When I get few free servers at the same time. What server I have to pick next? With lower index or weigh?? "
                    },
                    {
                        "username": "ddubrava",
                        "content": " ith task becomes available at the ith second"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "[@miles_1337](/miles_1337) dude your test case is gold! i use a simple if statement to deal with backlogging, works perfectly!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) yes! I waste 8 hours in total to resolve it. Many times I just erased code and started again. A tried a lot of ways to resolve this. And every time I got different test cases fail. Finally, I have resolved it. And this task is totally hell! A have never wasted so much time to one problem here!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@miles_1337](/miles_1337) thanks!"
                    },
                    {
                        "username": "miles_1337",
                        "content": "Failing this test case means you\\'re incrementing time when you don\\'t need to. Consider the following (much simpler) scenario:\\n\\nservers:\\n[1, 20, 300]\\n\\ntasks:\\n[10, 9, 8, 1, 1, 1]\\n\\nThe first 3 tasks come in-- going to server 0, server 1, and then server 2 respectively. All 3 of these will finish simultaneously at time = 10 sec. At this point, the last 3 tasks are all waiting to be launched (they are \"backlogged\", not streaming in). The correct answer is that at time = 10, you launch all 3 \"backlogged\" tasks immediately (one on each server). However, if you\\'re not handling this case (and incrementing time when you don\\'t need to), the 4th task will be assigned to server 0... server 0 will finish that task in 1 sec, and then the 5th (and similarly the 6th) task will run on server 0.\\n\\nThis larger test case ends up being impacted by the above scenario, just in a much more complex situation. "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) Not yet. I have tried a few methods (by weight, by index, etc). But still get an error at different test cases. Temporary stopped to attempt. Because I already waste many hours. "
                    },
                    {
                        "username": "_Kuldeep_01",
                        "content": "yeah it is mentioned to pick the smallest weight nd if tie then go with the smallest index .....I got the same problem.. did you find the solution ?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "found it to be a lower hard than medium"
                    },
                    {
                        "username": "mohanyash73",
                        "content": "**You will be able to process the jth task starting from the jth second beginning with the 0th task at second 0. To process task j, you assign it to the server with the smallest weight that is free, and in case of a tie, choose the server with the smallest index. If a free server gets assigned task j at second t, it will be free again at the second t + tasks[j].**\\n--> from this statement I understood that at j\\'th second we can start processing the j\\'th task and we must choose the server which has the least weight and in case of ties the least index. And if we start processing at j\\'th second then till j + tasks[j] the choosen server won\\'t be free agian.\\n\\n**If there are no free servers, you must wait until one is free and execute the free tasks as soon as possible. If multiple tasks need to be assigned, assign them in order of increasing index.**\\n\\n--> because of this statement it gave a hint that there\\'s a possibility that at j\\'th second our servers might not be free. So we must wait until the server is free and then assign it to the server which becomes free ASAP.  But the last statement \"If multiple tasks need to be assigned, assign them in order of increasing index\" confused me. Does it mean that we choose the servers in increasing index or the tasks in increasing index ?\\n\\n\\n**You may assign multiple tasks at the same second if there are multiple free servers.**\\n--> And this statement says we might be able to assign multiple tasks at the same time. But the first statement said we should assign only at j\\'th second? So how could we assign multiple tasks at the same time? And what ordering should we follow while choosing the servers in this case??"
                    },
                    {
                        "username": "ddubrava",
                        "content": "It's funny though that you forgot to mention that 'ith task becomes available at the ith second,' and you can schedule multiple tasks at the same time...\n\nThe problem description by [@buttercup_powerPuff](/buttercup_powerPuff)\n\n> The problem statement is really poorly worded.\n> \n> Actual Problem Statement\n> There is a queue of M tasks where ith task becomes available at the ith second and takes a duration of tasks[i] to be processed. We > have N servers each with a weight and index of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least weight. If there are multiple servers with same weight, we pick the one with > lowest index. When scheduling at time t, the selected server will be free again at t + tasks[i].\n> \n> Scheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers."
                    },
                    {
                        "username": "apooash2020",
                        "content": "Can someone help ? I am getting TLE `import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        available_cpu = [] ## PQ with (cpu_weight, cpu_index)\\n        busy_cpu = [] ## PQ with (task_finish_time, cpu_weight, cpu_index)\\n\\n        for index,weight in enumerate(servers):\\n            heapq.heappush(available_cpu, (weight, index))\\n\\n        curr_time = 0\\n        q = []\\n        result = []\\n        curr_task = 0\\n\\n        num_of_tasks = len(tasks)\\n\\n        while curr_task < len(tasks) or len(q) !=0: ## do we check len(q) !=0\\n\\n            ## get free servers from busy list into available list  \\n            while len(busy_cpu)!= 0 and busy_cpu[0][0] <= curr_time:\\n                _,free_cpu_weight,free_cpu_index = heapq.heappop(busy_cpu)\\n                heapq.heappush(available_cpu, (free_cpu_weight, free_cpu_index))\\n\\n            if curr_task < len(tasks):\\n                curr_task_time = tasks[curr_task]\\n                q.append(curr_task_time)\\n\\n            if available_cpu:\\n                while len(available_cpu) > 0 and len(q) > 0:\\n                    first_inserted_task_in_q_weight = q.pop(0)\\n                    task_finish_time = curr_time + first_inserted_task_in_q_weight\\n                    available_cpu_weight,available_cpu_index = heapq.heappop(available_cpu)\\n                    result.append(available_cpu_index)\\n                    heapq.heappush(busy_cpu,(task_finish_time,available_cpu_weight,available_cpu_index) )\\n    \\n            curr_time += 1\\n            curr_task += 1\\n\\n        return result\\n`"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unnecessarily complicated business logic.\\n\\nHere are some test cases:\\n\\nservers=\\n```\\n[3, 7, 9, 1, 10, 10, 9, 10, 8, 8]\\n```\\ntasks=\\n```\\n[10, 6, 9, 2, 3, 7, 6, 4, 5, 5]\\n```\\n\\nservers=\\n```\\n[5, 5, 9, 9, 9, 5, 10]\\n```\\ntasks=\\n```\\n[9, 9, 9, 6, 7, 3, 1, 10, 8, 6, 8, 9, 5, 7, 8, 3, 7, 3, 3, 7]\\n```\\n\\nPython script to generate test cases\\n\\n```\\nn = 7\\nm = 20\\nmax_server_weight = 10\\nmax_task = 10\\n\\nservers = [random.randint(1, max_server_weight) for _ in range(n)]\\ntasks = [random.randint(1, max_task) for _ in range(m)]\\nprint(json.dumps(servers))\\nprint(json.dumps(tasks))\\n```"
                    },
                    {
                        "username": "had0uken",
                        "content": "It`s not clear for me. What server have I pick for task, when I get few free servers at the same time? With the lowest index or with the lowest weight. Please explain anyone )"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) тю... ох и бредовое задание) То есть вначале задания назначаются постепенно, а потом уже как сервера поработали - одновременно? ) Автор задания умеет поиздеваться. И не так сложно задание, как понять что от тебя хотят сделать! ("
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0412\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u041D\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u0430\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C \\u043E\\u0434\\u043D\\u0443 \\u0434\\u0435\\u0442\\u0430\\u043B\\u044C: \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0437\\u0430\\u0434\\u0430\\u0447 \\u0436\\u0434\\u0443\\u0442 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438 (\\u0412\\u0441\\u0435 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043D\\u044F\\u0442\\u044B 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0437\\u0430 \\u044D\\u0442\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F 5 \\u0437\\u0430\\u0434\\u0430\\u0447 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438 \\u0436\\u0434\\u0430\\u0442\\u044C \\u0441\\u0432\\u043E\\u0435\\u0439 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438) \\u0438 \\u043E\\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u0438\\u043B\\u043E\\u0441\\u044C 3 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 - 3 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0431\\u044B\\u0442\\u044C \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044B \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0438 \\u0435\\u0449\\u0435 \\u043E\\u0434\\u0438\\u043D \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441: \\u0434\\u043E\\u043F\\u0443\\u0441\\u0442\\u0438\\u043C \\u0435\\u0441\\u0442\\u044C 3 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430. \\u0422\\u0440\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F \\u043D\\u0430 \\u043D\\u0438\\u0445 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0442\\u0443 \\u0436\\u0435 \\u0441\\u0430\\u043C\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443? \\u0418\\u043B\\u0438 \\u0432 \\u043F\\u0435\\u0440\\u0432\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 \\u043D\\u0430 1 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F, \\u043D\\u0430 2 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 - \\u043D\\u0430 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439, \\u0438 \\u0432 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0430 \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0439 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u0439\\u0434\\u0435\\u0439\\u0441\\u0442\\u043E\\u0432\\u0430\\u043D 3\\u0438\\u0439 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440? "
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0415\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F, \\u043C\\u044B \\u0432\\u044B\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043F\\u043E \\u0442\\u043E\\u043C\\u0443 \\u0436\\u0435 \\u043F\\u0440\\u0438\\u043D\\u0446\\u0438\\u043F\\u0443, \\u0447\\u0442\\u043E \\u0438 \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435. \\u0421\\u0435\\u0440\\u0432\\u0435\\u0440 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0435\\u0441\\u043B\\u0438 \\u0432\\u0435\\u0441\\u0430 \\u0440\\u0430\\u0432\\u043D\\u044B, \\u0442\\u043E \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0412\\u0438\\u0436\\u0443, \\u0447\\u0442\\u043E \\u0442\\u0435\\u0431\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438 \\u043D\\u0430 \\u0440\\u0443\\u0441\\u0441\\u043A\\u043E\\u043C \\u043D\\u0430\\u043F\\u0438\\u0441\\u0430\\u0442\\u044C. \\u041F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0436\\u0438 \\u043F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430. \\u0412\\u043E\\u0442 \\u043C\\u044B \\u0444\\u043E\\u0440\\u043C\\u0438\\u0440\\u0443\\u0435\\u043C \\u0444\\u0438\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u041A\\u0430\\u043A\\u043E\\u0435 \\u0442\\u0430\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043E\\u043A\\u0430\\u0436\\u0435\\u0442\\u0441\\u044F \\u043F\\u0435\\u0440\\u0432\\u0435\\u0435, \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F. \\u0422\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0438\\u043B\\u0438 \\u0442\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C? \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E \\u0437\\u0430\\u0440\\u0430\\u043D\\u0435\\u0435 "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) Thanx. I got it about time variable. But when I assign two task at the same time, what task I have to write to result array firstly? With the lowest index or lowest weight. What the main priority?"
                    },
                    {
                        "username": "Pavjelv",
                        "content": "You have to note this statement:\\n\"If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\"\\n\\nSo, there might me a case when multiple servers are free and you could assign more than one task without increasing time variable."
                    },
                    {
                        "username": "pawan1818",
                        "content": "Could anyone help me debug the below code?\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n      \\n       \\n    // Server Priority Queue\\n    // 0 -> server\\n    // 1 -> server index\\n    PriorityQueue<List<Integer>> freeServer = new PriorityQueue<>(\\n            (a,b) -> {\\n              if(a.get(0) == b.get(0)){\\n                return a.get(1) - b.get(1);\\n              }else{\\n                return a.get(0) - b.get(0);\\n              }\\n            }\\n    );\\n\\n    // Create array list of servers with index\\n    for(int i=0;i<servers.length;i++){\\n      List<Integer> list = new ArrayList<>();\\n      list.add(servers[i]);\\n      list.add(i);\\n      freeServer.add(list);\\n    }\\n\\n\\n    // List<List<Integer>> usedServer = new ArrayList<>();\\n\\n    // 0 -> server\\n    // 1 -> server index\\n    // 2 -> time\\n    // Unavailable usedServer       \\n    PriorityQueue<List<Integer>> usedServer = new PriorityQueue<>(\\n            (a,b) -> a.get(2) - b.get(2)\\n    );\\n\\n    int time = 0;\\n\\n    int[] res = new int[tasks.length];\\n\\n\\n    for(int i=0;i<tasks.length;i++){\\n      time = Math.max(time, i);\\n\\n\\n    if(freeServer.size() == 0){\\n         time = usedServer.peek().get(2);\\n    }\\n    \\n      \\n      while(usedServer.size() > 0 && usedServer.peek().get(2) <= time){\\n\\n        List<Integer> list = usedServer.poll();\\n        List<Integer> newList = new ArrayList<>();\\n        newList.add(list.get(0));\\n        newList.add(list.get(1));\\n        freeServer.add(newList);\\n\\n      }\\n\\n      if(freeServer.size() != 0){\\n           List<Integer> list = freeServer.poll();\\n            // index 2 is time\\n            List<Integer> newList = new ArrayList<>();\\n            newList.add(list.get(0));\\n        newList.add(list.get(1));\\n             newList.add(tasks[i]+time);\\n             usedServer.add(newList);\\n            res[i] =newList.get(1);\\n            \\n      }\\n\\n    }\\n\\n\\n    return res;\\n    \\n    }\\n}\\n\\nThis test case fails\\nInput\\nservers =\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\ntasks =\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nOutput\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,34,22,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,34,51,11,53,36,57,26,5,36,56,55,31,22,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\nExpected\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,"
                    },
                    {
                        "username": "user9178m",
                        "content": "I'm a bit lost as to what I've done wrong. It's a rather large test case to run through, so in the meantime, if anyone spots my mistake, please let me know.\n\n `\n\n        serverHeap = [(w,i) for i,w in enumerate(servers)]\n        heapq.heapify(serverHeap)\n        workingHeap = []\n\n        res = []\n        time = 0\n        while len(tasks) > 0:\n\n            print(serverHeap, time)\n            if len(serverHeap) > 0:\n                server = heapq.heappop(serverHeap)\n                heapq.heappush(workingHeap, (tasks.pop(0)+time, server[0], server[1]))\n                res.append(server[1])\n                time += 1\n\n            else:\n                print(workingHeap)\n                server = heapq.heappop(workingHeap)\n                time = server[0]\n                heapq.heappush(serverHeap, (server[1], server[2]))\n            \n            while len(workingHeap) > 0 and workingHeap[0][0] <= time:\n                server = heapq.heappop(workingHeap)\n                heapq.heappush(serverHeap, (server[1], server[2]))\n        \n        return res            \n\n`"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "i have the same error. Seems to have issue with time variable. Did you find any solution ?"
                    }
                ]
            },
            {
                "id": 1714430,
                "content": [
                    {
                        "username": "had0uken",
                        "content": "servers\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\ntasks\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\n\n\nThis test case probably incorrect! \nExpected output:\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5, \n 36,56, 55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\n\nI marked the wrong place. server#56 has to start doing task before server#36 because both of them free at that moment and do not have any current task. However, 56 server has weigh (147) lower than server#36(889).\nHave anybody also got this problem? \n\nOr can anyone answer. When I get few free servers at the same time. What server I have to pick next? With lower index or weigh?? "
                    },
                    {
                        "username": "ddubrava",
                        "content": " ith task becomes available at the ith second"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "[@miles_1337](/miles_1337) dude your test case is gold! i use a simple if statement to deal with backlogging, works perfectly!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) yes! I waste 8 hours in total to resolve it. Many times I just erased code and started again. A tried a lot of ways to resolve this. And every time I got different test cases fail. Finally, I have resolved it. And this task is totally hell! A have never wasted so much time to one problem here!"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@miles_1337](/miles_1337) thanks!"
                    },
                    {
                        "username": "miles_1337",
                        "content": "Failing this test case means you\\'re incrementing time when you don\\'t need to. Consider the following (much simpler) scenario:\\n\\nservers:\\n[1, 20, 300]\\n\\ntasks:\\n[10, 9, 8, 1, 1, 1]\\n\\nThe first 3 tasks come in-- going to server 0, server 1, and then server 2 respectively. All 3 of these will finish simultaneously at time = 10 sec. At this point, the last 3 tasks are all waiting to be launched (they are \"backlogged\", not streaming in). The correct answer is that at time = 10, you launch all 3 \"backlogged\" tasks immediately (one on each server). However, if you\\'re not handling this case (and incrementing time when you don\\'t need to), the 4th task will be assigned to server 0... server 0 will finish that task in 1 sec, and then the 5th (and similarly the 6th) task will run on server 0.\\n\\nThis larger test case ends up being impacted by the above scenario, just in a much more complex situation. "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@_Kuldeep_01](/_Kuldeep_01) Not yet. I have tried a few methods (by weight, by index, etc). But still get an error at different test cases. Temporary stopped to attempt. Because I already waste many hours. "
                    },
                    {
                        "username": "_Kuldeep_01",
                        "content": "yeah it is mentioned to pick the smallest weight nd if tie then go with the smallest index .....I got the same problem.. did you find the solution ?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "found it to be a lower hard than medium"
                    },
                    {
                        "username": "mohanyash73",
                        "content": "**You will be able to process the jth task starting from the jth second beginning with the 0th task at second 0. To process task j, you assign it to the server with the smallest weight that is free, and in case of a tie, choose the server with the smallest index. If a free server gets assigned task j at second t, it will be free again at the second t + tasks[j].**\\n--> from this statement I understood that at j\\'th second we can start processing the j\\'th task and we must choose the server which has the least weight and in case of ties the least index. And if we start processing at j\\'th second then till j + tasks[j] the choosen server won\\'t be free agian.\\n\\n**If there are no free servers, you must wait until one is free and execute the free tasks as soon as possible. If multiple tasks need to be assigned, assign them in order of increasing index.**\\n\\n--> because of this statement it gave a hint that there\\'s a possibility that at j\\'th second our servers might not be free. So we must wait until the server is free and then assign it to the server which becomes free ASAP.  But the last statement \"If multiple tasks need to be assigned, assign them in order of increasing index\" confused me. Does it mean that we choose the servers in increasing index or the tasks in increasing index ?\\n\\n\\n**You may assign multiple tasks at the same second if there are multiple free servers.**\\n--> And this statement says we might be able to assign multiple tasks at the same time. But the first statement said we should assign only at j\\'th second? So how could we assign multiple tasks at the same time? And what ordering should we follow while choosing the servers in this case??"
                    },
                    {
                        "username": "ddubrava",
                        "content": "It's funny though that you forgot to mention that 'ith task becomes available at the ith second,' and you can schedule multiple tasks at the same time...\n\nThe problem description by [@buttercup_powerPuff](/buttercup_powerPuff)\n\n> The problem statement is really poorly worded.\n> \n> Actual Problem Statement\n> There is a queue of M tasks where ith task becomes available at the ith second and takes a duration of tasks[i] to be processed. We > have N servers each with a weight and index of their own. When we have to schedule a task, we find a server that is free. If multiple servers are free, then we pick the one with least weight. If there are multiple servers with same weight, we pick the one with > lowest index. When scheduling at time t, the selected server will be free again at t + tasks[i].\n> \n> Scheduling a task onto a server takes no time, so we can possibly schedule multiple tasks on multiple servers at the same time if we have the resources. If a task cannot be scheduled when it arrives, it must wait until there are free servers."
                    },
                    {
                        "username": "apooash2020",
                        "content": "Can someone help ? I am getting TLE `import heapq\\n\\nclass Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n\\n        available_cpu = [] ## PQ with (cpu_weight, cpu_index)\\n        busy_cpu = [] ## PQ with (task_finish_time, cpu_weight, cpu_index)\\n\\n        for index,weight in enumerate(servers):\\n            heapq.heappush(available_cpu, (weight, index))\\n\\n        curr_time = 0\\n        q = []\\n        result = []\\n        curr_task = 0\\n\\n        num_of_tasks = len(tasks)\\n\\n        while curr_task < len(tasks) or len(q) !=0: ## do we check len(q) !=0\\n\\n            ## get free servers from busy list into available list  \\n            while len(busy_cpu)!= 0 and busy_cpu[0][0] <= curr_time:\\n                _,free_cpu_weight,free_cpu_index = heapq.heappop(busy_cpu)\\n                heapq.heappush(available_cpu, (free_cpu_weight, free_cpu_index))\\n\\n            if curr_task < len(tasks):\\n                curr_task_time = tasks[curr_task]\\n                q.append(curr_task_time)\\n\\n            if available_cpu:\\n                while len(available_cpu) > 0 and len(q) > 0:\\n                    first_inserted_task_in_q_weight = q.pop(0)\\n                    task_finish_time = curr_time + first_inserted_task_in_q_weight\\n                    available_cpu_weight,available_cpu_index = heapq.heappop(available_cpu)\\n                    result.append(available_cpu_index)\\n                    heapq.heappush(busy_cpu,(task_finish_time,available_cpu_weight,available_cpu_index) )\\n    \\n            curr_time += 1\\n            curr_task += 1\\n\\n        return result\\n`"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Unnecessarily complicated business logic.\\n\\nHere are some test cases:\\n\\nservers=\\n```\\n[3, 7, 9, 1, 10, 10, 9, 10, 8, 8]\\n```\\ntasks=\\n```\\n[10, 6, 9, 2, 3, 7, 6, 4, 5, 5]\\n```\\n\\nservers=\\n```\\n[5, 5, 9, 9, 9, 5, 10]\\n```\\ntasks=\\n```\\n[9, 9, 9, 6, 7, 3, 1, 10, 8, 6, 8, 9, 5, 7, 8, 3, 7, 3, 3, 7]\\n```\\n\\nPython script to generate test cases\\n\\n```\\nn = 7\\nm = 20\\nmax_server_weight = 10\\nmax_task = 10\\n\\nservers = [random.randint(1, max_server_weight) for _ in range(n)]\\ntasks = [random.randint(1, max_task) for _ in range(m)]\\nprint(json.dumps(servers))\\nprint(json.dumps(tasks))\\n```"
                    },
                    {
                        "username": "had0uken",
                        "content": "It`s not clear for me. What server have I pick for task, when I get few free servers at the same time? With the lowest index or with the lowest weight. Please explain anyone )"
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) тю... ох и бредовое задание) То есть вначале задания назначаются постепенно, а потом уже как сервера поработали - одновременно? ) Автор задания умеет поиздеваться. И не так сложно задание, как понять что от тебя хотят сделать! ("
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0412\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u041D\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u0430\\u043C\\u0435\\u0442\\u0438\\u0442\\u044C \\u043E\\u0434\\u043D\\u0443 \\u0434\\u0435\\u0442\\u0430\\u043B\\u044C: \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0437\\u0430\\u0434\\u0430\\u0447 \\u0436\\u0434\\u0443\\u0442 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438 (\\u0412\\u0441\\u0435 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 \\u0431\\u044B\\u043B\\u0438 \\u0437\\u0430\\u043D\\u044F\\u0442\\u044B 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0437\\u0430 \\u044D\\u0442\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F 5 \\u0437\\u0430\\u0434\\u0430\\u0447 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0438 \\u0436\\u0434\\u0430\\u0442\\u044C \\u0441\\u0432\\u043E\\u0435\\u0439 \\u043E\\u0447\\u0435\\u0440\\u0435\\u0434\\u0438) \\u0438 \\u043E\\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u0438\\u043B\\u043E\\u0441\\u044C 3 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430 - 3 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0434\\u043E\\u043B\\u0436\\u043D\\u044B \\u0431\\u044B\\u0442\\u044C \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044B \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0438 \\u0435\\u0449\\u0435 \\u043E\\u0434\\u0438\\u043D \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441: \\u0434\\u043E\\u043F\\u0443\\u0441\\u0442\\u0438\\u043C \\u0435\\u0441\\u0442\\u044C 3 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440\\u0430. \\u0422\\u0440\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F \\u043D\\u0430 \\u043D\\u0438\\u0445 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0442\\u0443 \\u0436\\u0435 \\u0441\\u0430\\u043C\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443? \\u0418\\u043B\\u0438 \\u0432 \\u043F\\u0435\\u0440\\u0432\\u0443\\u044E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 \\u043D\\u0430 1 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F, \\u043D\\u0430 2 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0443 - \\u043D\\u0430 \\u0434\\u0440\\u0443\\u0433\\u043E\\u0439, \\u0438 \\u0432 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0430 \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0439 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u0439\\u0434\\u0435\\u0439\\u0441\\u0442\\u043E\\u0432\\u0430\\u043D 3\\u0438\\u0439 \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440? "
                    },
                    {
                        "username": "Pavjelv",
                        "content": "[@had0uken](/had0uken) \\u0415\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F, \\u043C\\u044B \\u0432\\u044B\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043F\\u043E \\u0442\\u043E\\u043C\\u0443 \\u0436\\u0435 \\u043F\\u0440\\u0438\\u043D\\u0446\\u0438\\u043F\\u0443, \\u0447\\u0442\\u043E \\u0438 \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435. \\u0421\\u0435\\u0440\\u0432\\u0435\\u0440 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0435\\u0441\\u043B\\u0438 \\u0432\\u0435\\u0441\\u0430 \\u0440\\u0430\\u0432\\u043D\\u044B, \\u0442\\u043E \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C."
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) \\u0412\\u0438\\u0436\\u0443, \\u0447\\u0442\\u043E \\u0442\\u0435\\u0431\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438 \\u043D\\u0430 \\u0440\\u0443\\u0441\\u0441\\u043A\\u043E\\u043C \\u043D\\u0430\\u043F\\u0438\\u0441\\u0430\\u0442\\u044C. \\u041F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0436\\u0438 \\u043F\\u043E\\u0436\\u0430\\u043B\\u0443\\u0439\\u0441\\u0442\\u0430. \\u0412\\u043E\\u0442 \\u043C\\u044B \\u0444\\u043E\\u0440\\u043C\\u0438\\u0440\\u0443\\u0435\\u043C \\u0444\\u0438\\u043D\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432. \\u041A\\u0430\\u043A\\u043E\\u0435 \\u0442\\u0430\\u043C \\u0441\\u0435\\u0440\\u0432\\u0435\\u0440 \\u043E\\u043A\\u0430\\u0436\\u0435\\u0442\\u0441\\u044F \\u043F\\u0435\\u0440\\u0432\\u0435\\u0435, \\u0435\\u0441\\u043B\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0434\\u0432\\u0430 \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u044F. \\u0422\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0432\\u0435\\u0441\\u043E\\u043C, \\u0438\\u043B\\u0438 \\u0442\\u043E\\u0442, \\u043D\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043D\\u0430\\u0437\\u043D\\u0430\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u0434\\u0430\\u043D\\u0438\\u0435 \\u0441 \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u043C \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C? \\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E \\u0437\\u0430\\u0440\\u0430\\u043D\\u0435\\u0435 "
                    },
                    {
                        "username": "had0uken",
                        "content": "[@Pavjelv](/Pavjelv) Thanx. I got it about time variable. But when I assign two task at the same time, what task I have to write to result array firstly? With the lowest index or lowest weight. What the main priority?"
                    },
                    {
                        "username": "Pavjelv",
                        "content": "You have to note this statement:\\n\"If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.\"\\n\\nSo, there might me a case when multiple servers are free and you could assign more than one task without increasing time variable."
                    },
                    {
                        "username": "pawan1818",
                        "content": "Could anyone help me debug the below code?\\nclass Solution {\\n    public int[] assignTasks(int[] servers, int[] tasks) {\\n      \\n       \\n    // Server Priority Queue\\n    // 0 -> server\\n    // 1 -> server index\\n    PriorityQueue<List<Integer>> freeServer = new PriorityQueue<>(\\n            (a,b) -> {\\n              if(a.get(0) == b.get(0)){\\n                return a.get(1) - b.get(1);\\n              }else{\\n                return a.get(0) - b.get(0);\\n              }\\n            }\\n    );\\n\\n    // Create array list of servers with index\\n    for(int i=0;i<servers.length;i++){\\n      List<Integer> list = new ArrayList<>();\\n      list.add(servers[i]);\\n      list.add(i);\\n      freeServer.add(list);\\n    }\\n\\n\\n    // List<List<Integer>> usedServer = new ArrayList<>();\\n\\n    // 0 -> server\\n    // 1 -> server index\\n    // 2 -> time\\n    // Unavailable usedServer       \\n    PriorityQueue<List<Integer>> usedServer = new PriorityQueue<>(\\n            (a,b) -> a.get(2) - b.get(2)\\n    );\\n\\n    int time = 0;\\n\\n    int[] res = new int[tasks.length];\\n\\n\\n    for(int i=0;i<tasks.length;i++){\\n      time = Math.max(time, i);\\n\\n\\n    if(freeServer.size() == 0){\\n         time = usedServer.peek().get(2);\\n    }\\n    \\n      \\n      while(usedServer.size() > 0 && usedServer.peek().get(2) <= time){\\n\\n        List<Integer> list = usedServer.poll();\\n        List<Integer> newList = new ArrayList<>();\\n        newList.add(list.get(0));\\n        newList.add(list.get(1));\\n        freeServer.add(newList);\\n\\n      }\\n\\n      if(freeServer.size() != 0){\\n           List<Integer> list = freeServer.poll();\\n            // index 2 is time\\n            List<Integer> newList = new ArrayList<>();\\n            newList.add(list.get(0));\\n        newList.add(list.get(1));\\n             newList.add(tasks[i]+time);\\n             usedServer.add(newList);\\n            res[i] =newList.get(1);\\n            \\n      }\\n\\n    }\\n\\n\\n    return res;\\n    \\n    }\\n}\\n\\nThis test case fails\\nInput\\nservers =\\n[338,890,301,532,284,930,426,616,919,267,571,140,716,859,980,469,628,490,195,664,925,652,503,301,917,563,82,947,910,451,366,190,253,516,503,721,889,964,506,914,986,718,520,328,341,765,922,139,911,578,86,435,824,321,942,215,147,985,619,865]\\ntasks =\\n[773,537,46,317,233,34,712,625,336,221,145,227,194,693,981,861,317,308,400,2,391,12,626,265,710,792,620,416,267,611,875,361,494,128,133,157,638,632,2,158,428,284,847,431,94,782,888,44,117,489,222,932,494,948,405,44,185,587,738,164,356,783,276,547,605,609,930,847,39,579,768,59,976,790,612,196,865,149,975,28,653,417,539,131,220,325,252,160,761,226,629,317,185,42,713,142,130,695,944,40,700,122,992,33,30,136,773,124,203,384,910,214,536,767,859,478,96,172,398,146,713,80,235,176,876,983,363,646,166,928,232,699,504,612,918,406,42,931,647,795,139,933,746,51,63,359,303,752,799,836,50,854,161,87,346,507,468,651,32,717,279,139,851,178,934,233,876,797,701,505,878,731,468,884,87,921,782,788,803,994,67,905,309,2,85,200,368,672,995,128,734,157,157,814,327,31,556,394,47,53,755,721,159,843]\\n\\nOutput\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,34,22,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,34,51,11,53,36,57,26,5,36,56,55,31,22,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,24,57,28,4,45,43,39,38,8,2,44,45,29,25,25,12,54,5,44,30,27,23,26,7,33,58,41,25,52,40,58,9,52,40]\\nExpected\\n[26,50,47,11,56,31,18,55,32,9,4,2,23,53,43,0,44,30,6,51,29,51,15,17,22,34,38,33,42,3,25,10,49,51,7,58,16,21,19,31,19,12,41,35,45,52,13,59,47,36,1,28,48,39,24,8,46,20,5,54,27,37,14,57,40,59,8,45,4,51,47,7,58,4,31,23,54,7,9,56,2,46,56,1,17,42,11,30,12,44,14,32,7,10,23,1,29,27,6,10,33,24,19,10,35,30,35,10,17,49,50,36,29,1,48,44,7,11,24,57,42,30,10,55,3,20,38,15,7,46,32,21,40,16,59,30,53,17,18,22,51,11,53,36,57,26,5,36,56,55,31,34,57,7,52,37,31,10,0,51,41,2,32,25,0,7,49,47,13,14,"
                    },
                    {
                        "username": "user9178m",
                        "content": "I'm a bit lost as to what I've done wrong. It's a rather large test case to run through, so in the meantime, if anyone spots my mistake, please let me know.\n\n `\n\n        serverHeap = [(w,i) for i,w in enumerate(servers)]\n        heapq.heapify(serverHeap)\n        workingHeap = []\n\n        res = []\n        time = 0\n        while len(tasks) > 0:\n\n            print(serverHeap, time)\n            if len(serverHeap) > 0:\n                server = heapq.heappop(serverHeap)\n                heapq.heappush(workingHeap, (tasks.pop(0)+time, server[0], server[1]))\n                res.append(server[1])\n                time += 1\n\n            else:\n                print(workingHeap)\n                server = heapq.heappop(workingHeap)\n                time = server[0]\n                heapq.heappush(serverHeap, (server[1], server[2]))\n            \n            while len(workingHeap) > 0 and workingHeap[0][0] <= time:\n                server = heapq.heappop(workingHeap)\n                heapq.heappush(serverHeap, (server[1], server[2]))\n        \n        return res            \n\n`"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "i have the same error. Seems to have issue with time variable. Did you find any solution ?"
                    }
                ]
            }
        ]
    }
]