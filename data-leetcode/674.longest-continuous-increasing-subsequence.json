[
    {
        "title": "Bulb Switcher II",
        "question_content": "There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons on the wall. Each of the four buttons has a different functionality where:\n\n\tButton 1: Flips the status of all the bulbs.\n\tButton 2: Flips the status of all the bulbs with even labels (i.e., 2, 4, ...).\n\tButton 3: Flips the status of all the bulbs with odd labels (i.e., 1, 3, ...).\n\tButton 4: Flips the status of all the bulbs with a label j = 3k + 1 where k = 0, 1, 2, ... (i.e., 1, 4, 7, 10, ...).\n\nYou must make exactly presses button presses in total. For each press, you may pick any of the four buttons to press.\nGiven the two integers n and presses, return the number of different possible statuses after performing all presses button presses.\n&nbsp;\nExample 1:\n\nInput: n = 1, presses = 1\nOutput: 2\nExplanation: Status can be:\n- [off] by pressing button 1\n- [on] by pressing button 2\n\nExample 2:\n\nInput: n = 2, presses = 1\nOutput: 3\nExplanation: Status can be:\n- [off, off] by pressing button 1\n- [on, off] by pressing button 2\n- [off, on] by pressing button 3\n\nExample 3:\n\nInput: n = 3, presses = 1\nOutput: 4\nExplanation: Status can be:\n- [off, off, off] by pressing button 1\n- [off, on, off] by pressing button 2\n- [on, off, on] by pressing button 3\n- [off, on, on] by pressing button 4\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000\n\t0 <= presses <= 1000",
        "solutions": [
            {
                "id": 107269,
                "title": "java-o-1",
                "content": "We only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8. \\nThe four buttons:\\n\\n1. Flip all the lights.\\n2. Flip lights with even numbers.\\n3. Flip lights with odd numbers.\\n4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n\\n\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n`1 + 2 --> 3,    1 + 3 --> 2,      2 + 3 --> 1`\\nSo, there are only 8 cases. \\n\\n`All_on`, `1`, `2`, `3`, `4`, `1+4`, `2+4`, `3+4`\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n```java\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107267,
                "title": "python-straightforward-with-explanation",
                "content": "Suppose we did `f[0]` of the first operation, `f[1]` of the second, `f[2]` of the third, and `f[3]` of the fourth, where `sum(f) == m`.\\n\\nFirst, all these operations commute: doing operation A followed by operation B yields the same result as doing operation B followed by operation A.  Also, doing operation A followed by operation A again is the same as doing nothing.  So really, we only needed to know the residues `cand[i] = f[i] % 2`.  There are only 16 different possibilities for the residues in total, so we can try them all.\\n\\nWe'll loop `cand` through all 16 possibilities `(0, 0, 0, 0), (0, 0, 0, 1), ..., (1, 1, 1, 1)`.  A necessary and sufficient condition for `cand` to be valid is that `sum(cand) % 2 == m % 2 and sum(cand) <= m`, as only when these conditions are satisfied can we find some `f` with `sum(f) == m` and `cand[i] = f[i] % 2`.\\n\\nAlso, as the sequence of lights definitely repeats every 6 lights, we could replace `n` with `min(n, 6)`. Actually, we could replace it with `min(n, 3)`, as those lights are representative: that is, knowing the first 3 lights is enough to reconstruct what the next 3 lights will be.  If the first 3 lights are X, Y, Z, then with a little effort we can prove the next 3 lights will be (X^Y^Z), Z, Y.\\n\\n```python\\ndef flipLights(self, n, m):\\n    seen = set()\\n    for cand in itertools.product((0, 1), repeat = 4):\\n        if sum(cand) % 2 == m % 2 and sum(cand) <= m:\\n            A = []\\n            for i in xrange(min(n, 3)):\\n                light = 1\\n                light ^= cand[0]\\n                light ^= cand[1] and i % 2\\n                light ^= cand[2] and i % 2 == 0\\n                light ^= cand[3] and i % 3 == 0\\n                A.append(light)\\n            seen.add(tuple(A))\\n\\n    return len(seen)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef flipLights(self, n, m):\\n    seen = set()\\n    for cand in itertools.product((0, 1), repeat = 4):\\n        if sum(cand) % 2 == m % 2 and sum(cand) <= m:\\n            A = []\\n            for i in xrange(min(n, 3)):\\n                light = 1\\n                light ^= cand[0]\\n                light ^= cand[1] and i % 2\\n                light ^= cand[2] and i % 2 == 0\\n                light ^= cand[3] and i % 3 == 0\\n                A.append(light)\\n            seen.add(tuple(A))\\n\\n    return len(seen)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 107271,
                "title": "c-concise-code-o-1",
                "content": "When n <= 1, the solution is trial.\\n\\nFrom the 4 types of operations, \\n``` \\n1. Flip all the lights.\\n2. Flip lights with even numbers.\\n3. Flip lights with odd numbers.\\n4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n```\\nThere are three important observations:\\n1) For any operation, only odd or even matters, i.e. 0 or 1. Two same operations equal no operation.\\n2) The first 3 operations can be reduced to 1 or 0 operation. For example, flip all + flip even = flip odd. So the result of the first 3 operations is the same as either 1 operation or original.   \\n3) The solution for n > 3 is the same as n = 3. \\nFor example, 1 0 0 ....., I use 0 and 1 to represent off and on.\\nThe state of 2nd digit indicates even flip; The state of 3rd digit indicates odd flip; And the state difference of 1st and 3rd digits indicates 3k+1 flip.\\n\\nIn summary, the question can be simplified as m <= 3, n <= 3. I am sure you can figure out the rest easily. \\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if (m == 0 || n == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2) return m == 1? 3:4;\\n        if (m == 1) return 4;\\n        return m == 2? 7:8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\n1. Flip all the lights.\\n2. Flip lights with even numbers.\\n3. Flip lights with odd numbers.\\n4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n```\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if (m == 0 || n == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2) return m == 1? 3:4;\\n        if (m == 1) return 4;\\n        return m == 2? 7:8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107272,
                "title": "short-and-clean-java-o-1-solution",
                "content": "> `1`: light is on\\n> `0`: light is off\\n\\n**n == 1**\\n\\nOnly **2** possibilities: `1` and `0`.\\n\\n**n == 2**\\n\\nAfter one operation, it has only **3** possibilities: `00`, `10` and `01`.\\nAfter two and more operations, it has only **4** possibilities: `11`, `10`, `01` and `00`.\\n\\n**n == 3**\\n\\nAfter one operation, it has only **4** possibilities: `000`, `101`, `010` and `011`.\\nAfter two operations, it has **7** possibilities: `111`,`101`,`010`,`100`,`000`,`001` and `110`.\\nAfter three and more operations, it has **8** possibilities, plus `011` on above case.\\n\\n**n >= 4**\\n\\nAfter one operation, it has only **4** possibilities: `0000`, `1010`, `0101` and `0110`.\\nAfter two or more operations: it has **8** possibilities, `1111`,`1010`,`0101`,`0111`,`0000`,`0011`, `1100` and `1001`.\\n\\n```java\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (m == 0) return 1;\\n        if (n <= 0 || m < 0) return 0;\\n        \\n        if (n == 1) return 2;\\n        else if (n == 2) return (m == 1) ? 3 : 4;\\n        else return (m == 1) ? 4 : ((m == 2) ? 7 : 8);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (m == 0) return 1;\\n        if (n <= 0 || m < 0) return 0;\\n        \\n        if (n == 1) return 2;\\n        else if (n == 2) return (m == 1) ? 3 : 4;\\n        else return (m == 1) ? 4 : ((m == 2) ? 7 : 8);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107270,
                "title": "easy-to-understand-java-bfs-solution-o-m",
                "content": "I see all are math based solutions and it is O(1). \\nHere is my BFS solution to count all potential status for n bulb after m operations.\\n\\n```\\npublic int flipLights(int n, int m) {\\n        n = n <= 6? n: (n % 6 + 6);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        int init = (1 << n) - 1;\\n        queue.offer(init);\\n        for (int i=0; i<m; i++) {\\n            int size = queue.size();\\n            visited.clear();\\n            for (int k=0; k<size; k++) {\\n                int s = queue.poll();\\n                int[] next = new int[] {flipAll(s, n), \\n                     flipEven(s, n), flipOdd(s, n), flip3k1(s, n)};\\n                for (int s1: next) {\\n                    if (!visited.contains(s1)) {\\n                        queue.offer(s1);\\n                        visited.add(s1);\\n                    }\\n                }\\n            }\\n        }\\n        return queue.size();\\n    }\\n    \\n    private int flipAll(int s, int n) {\\n        int x = (1 << n) - 1;\\n        return s ^ x;\\n    }\\n\\n    private int flipEven(int s, int n) {\\n        for (int i=0; i<n; i+=2) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n\\n    private int flipOdd(int s, int n) {\\n        for (int i=1; i<n; i+=2) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n\\n    private int flip3k1(int s, int n) {\\n        for (int i=0; i<n; i+=3) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n        n = n <= 6? n: (n % 6 + 6);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        int init = (1 << n) - 1;\\n        queue.offer(init);\\n        for (int i=0; i<m; i++) {\\n            int size = queue.size();\\n            visited.clear();\\n            for (int k=0; k<size; k++) {\\n                int s = queue.poll();\\n                int[] next = new int[] {flipAll(s, n), \\n                     flipEven(s, n), flipOdd(s, n), flip3k1(s, n)};\\n                for (int s1: next) {\\n                    if (!visited.contains(s1)) {\\n                        queue.offer(s1);\\n                        visited.add(s1);\\n                    }\\n                }\\n            }\\n        }\\n        return queue.size();\\n    }\\n    \\n    private int flipAll(int s, int n) {\\n        int x = (1 << n) - 1;\\n        return s ^ x;\\n    }\\n\\n    private int flipEven(int s, int n) {\\n        for (int i=0; i<n; i+=2) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n\\n    private int flipOdd(int s, int n) {\\n        for (int i=1; i<n; i+=2) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n\\n    private int flip3k1(int s, int n) {\\n        for (int i=0; i<n; i+=3) {\\n            s ^= 1 << i;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107278,
                "title": "very-easy-to-understand-c-with-detailed-explanation",
                "content": "At first this problem appears very intimidating.  However, after walking through actual values, it is very simple.  Below is my solution, and a step-by-step analysis for each part of code.  Please feel free to provide comments to add/edit this post in order to provide better understanding for everyone.  Thanks!\\n\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        \\n        if (m==0) return 1;\\n        \\n        if (n==1)\\n            if (m>=1) return 2;\\n\\n        if (n==2){\\n            if (m==1) return 3;\\n            if (m>=2) return 4;\\n        }\\n        if (n>=3){\\n            if (m==1) return 4;\\n            if (m==2) return 7;\\n            if (m>=3) return 8;\\n        }\\n        \\n        return 0; // invalid value for n or m\\n    }\\n};\\n```\\n**STEP-BY-STEP ANALYSIS:**\\n\\n**Part 1: Description**\\nThe first value to consider is m=0 operations.  Regardless how many n lightbulbs there are with initial state ON, with 0 operations, all n lightbulbs will remain ON.  Therefore, there is only one state ( all n lightbulbs ON ).\\n\\n**Part 1: Code**\\n```\\nif (m==0) return 1;\\n\\n```\\n\\n**Part 2: Description**\\nNow consider one lightbulb (n=1).  If we perform m=1 operation on that 1 lightbulb, then that 1 operation can be (flip all, flip odd, flip even, or flip 3k+1 [k=0, 3k+1=1]).  The lightbulb\\'s end state after 1 operation from [ flip all, flip odd, or flip 3k+1 ] is OFF.  The end state after 1 operation from [ flip even ] is ON (since there are no even lightbulbs to flip, this single odd lightbulb remains ON).  Therefore, there are 2 states for this 1 lightbulb after 1 operation.  Below is a table summary of this lightbulb and its potential states.  ON=1 and OFF=0.\\n\\n```\\nn=1\\nlightbulb ID       1\\n\\nINIT_STATE:\\n(initially ON)     1\\n\\nm=1\\nOPERATIONS:\\n                   0 ( after 1 operation: flip all, odd, or 3k+1 )\\n                   1 ( after 1 operation: flip even )\\nSTATE_COUNT:\\n                   2 ( 0 or 1 )\\n```\\n\\nNow consider if there are any additional unique states which can be created with this one lightbulb with more than one operation.  There are none.  Either this one lightbulb is ON or OFF after m=1 operations.  Any additional operations revert the lightbulb to a previous state, so there are no additional unique states created by any m>=1 operations.\\n\\n**Part 2: Code**\\n```\\n        if (n==1){\\n            if (m>=1) return 2;\\n        }\\n```\\n\\n**Part 3: Description**\\nNext consider n=2 lightbulbs.  The logic here is again the same as above, so I will skip the complete description and instead directly create an abridged table summary:\\n\\n```\\nn=2\\nlightbulb ID       1 2\\n\\nINIT_STATE:\\n(initially ON)     1 1\\n\\nm=1\\nOPERATIONS:\\n                   0 0 ( after 1 operation: flip all )\\n                   0 1 ( after 1 operation: flip odd or 3k+1 )\\n                   1 0 ( after 1 operation: flip even )\\nm=1\\nSTATE_COUNT:\\n                   3 ( 00 or 01 or 10 )\\n\\nm=2\\nOPERATIONS:\\n                   0 0 ( after 2 operations: flip odd, flip even )\\n                   0 1 ( after 2 operations: flip all, flip even )\\n                   1 0 ( after 2 operations: flip all, flip odd )\\n                   1 1 ( after 2 operations: flip all, flip all )\\n\\nm=2\\nSTATE_COUNT:\\n                   4 ( 00 or 01 or 10 or 11 )\\n```\\n\\nThere are multiple ways to arrive at the same lightbulb state with m=2 operations, but I did NOT list them all.  This brevity is on purpose in order to help keep my verbose post as short and concise as possible.  There is no need to list them all anyways because we are only interested in the amount of unique states in the end, NOT all the different ways which we arrived at those states.\\n\\nNow consider if there are any additional unique states which can be created with these two lightbulbs with more than two operations.  There are none.  Any additional operation m>=2 reverts these 2 lightbulbs to a previous state.\\n\\n**Part 3: Code**\\n```\\n        if (n==2){\\n            if (m==1) return 3;\\n            if (m>=2) return 4;\\n        }\\n```\\n\\n**Part 4: Description**\\nNext consider n=3 lightbulbs. The logic here is again the same as above, so I will skip the complete description and instead directly create another abridged table summary:\\n\\n```\\nn=2\\nlightbulb ID       1 2 3\\n\\nINIT_STATE:\\n(initially ON)     1 1 1\\n\\nm=1\\nOPERATIONS:\\n                   0 0 0 ( after 1 operation: flip all )\\n                   0 1 0 ( after 1 operation: flip odd )\\n                   0 1 1 ( after 1 operation: flip 3k+1 ) \\n                   1 0 1 ( after 1 operation: flip even )\\nm=1\\nSTATE_COUNT:\\n                   4 ( 000 or 010 or 011 or 101 )\\n\\nm=2\\nOPERATIONS:\\n                   0 0 0 ( after 2 operations: flip odd, flip even )\\n                   0 0 1 ( after 2 operations: flip 3k+1, flip even )\\n                   0 1 0 ( after 2 operations: flip even, flip all )\\n                   1 0 0 ( after 2 operations: flip all, flip 3k+1 )\\n                   1 0 1 ( after 2 operations: flip odd, flip all )\\n                   1 1 0 ( after 2 operations: flip odd, flip 3k+1 )\\n                   1 1 1 ( after 2 operations: flip all, flip all )\\n\\nm=2\\nSTATE_COUNT:\\n                   7 ( 000 or 001 or 010 or 100 or 101 or 110 or 111 )\\n\\nm=3\\nOPERATIONS:\\n                   ect...\\n                   ect...\\n                   ect...\\nm=3\\nSTATE_COUNT:\\n                   8 ( 000 or 001 or 010 or 011 or 100 or 101 or 110 or 111 )\\n```\\nAgain, there are multiple ways to arrive at the same lightbulb state with m=2 and m=3 operations, but I did NOT list them all. This brevity is on purpose.  Also, I did NOT explicitly write out all the different permutations for m=3, since they are all redundant states except for 011 which can be created with 3 operations [ flip 3k+1, flip odd, flip odd ].\\n\\nAgain, consider if there are any additional unique states which can be created with these three lightbulbs with more than three operations. There are none. Any additional operation m>=3 reverts these 3 lightbulbs to a previous state.  Also consider if there are more unique states which can be created with more than n=3 lightbulbs.  There are none.  Any additional amount of lightbulbs n>=3 does NOT create a new unique state.  Instead repeated patterns are observed for lightbulbs that are even 2,4,6,etc (i.e. lightbulbs at positions 2(k+1), k=0,1,2... ), lightbulbs that are odd 1,3,5,etc (i.e. lightbulbs at positions 2k+1, k=0,1,2...), and lightbulbs at every 3rd position 1,4,7,10,etc ( i.e. lightbulbs at positions 3k+1, k=0,1,2...).\\n\\n**Part 4: Code**\\n```\\n        if (n>=3){\\n            if (m==1) return 4;\\n            if (m==2) return 7;\\n            if (m>=3) return 8;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        \\n        if (m==0) return 1;\\n        \\n        if (n==1)\\n            if (m>=1) return 2;\\n\\n        if (n==2){\\n            if (m==1) return 3;\\n            if (m>=2) return 4;\\n        }\\n        if (n>=3){\\n            if (m==1) return 4;\\n            if (m==2) return 7;\\n            if (m>=3) return 8;\\n        }\\n        \\n        return 0; // invalid value for n or m\\n    }\\n};\\n```\n```\\nif (m==0) return 1;\\n\\n```\n```\\nn=1\\nlightbulb ID       1\\n\\nINIT_STATE:\\n(initially ON)     1\\n\\nm=1\\nOPERATIONS:\\n                   0 ( after 1 operation: flip all, odd, or 3k+1 )\\n                   1 ( after 1 operation: flip even )\\nSTATE_COUNT:\\n                   2 ( 0 or 1 )\\n```\n```\\n        if (n==1){\\n            if (m>=1) return 2;\\n        }\\n```\n```\\nn=2\\nlightbulb ID       1 2\\n\\nINIT_STATE:\\n(initially ON)     1 1\\n\\nm=1\\nOPERATIONS:\\n                   0 0 ( after 1 operation: flip all )\\n                   0 1 ( after 1 operation: flip odd or 3k+1 )\\n                   1 0 ( after 1 operation: flip even )\\nm=1\\nSTATE_COUNT:\\n                   3 ( 00 or 01 or 10 )\\n\\nm=2\\nOPERATIONS:\\n                   0 0 ( after 2 operations: flip odd, flip even )\\n                   0 1 ( after 2 operations: flip all, flip even )\\n                   1 0 ( after 2 operations: flip all, flip odd )\\n                   1 1 ( after 2 operations: flip all, flip all )\\n\\nm=2\\nSTATE_COUNT:\\n                   4 ( 00 or 01 or 10 or 11 )\\n```\n```\\n        if (n==2){\\n            if (m==1) return 3;\\n            if (m>=2) return 4;\\n        }\\n```\n```\\nn=2\\nlightbulb ID       1 2 3\\n\\nINIT_STATE:\\n(initially ON)     1 1 1\\n\\nm=1\\nOPERATIONS:\\n                   0 0 0 ( after 1 operation: flip all )\\n                   0 1 0 ( after 1 operation: flip odd )\\n                   0 1 1 ( after 1 operation: flip 3k+1 ) \\n                   1 0 1 ( after 1 operation: flip even )\\nm=1\\nSTATE_COUNT:\\n                   4 ( 000 or 010 or 011 or 101 )\\n\\nm=2\\nOPERATIONS:\\n                   0 0 0 ( after 2 operations: flip odd, flip even )\\n                   0 0 1 ( after 2 operations: flip 3k+1, flip even )\\n                   0 1 0 ( after 2 operations: flip even, flip all )\\n                   1 0 0 ( after 2 operations: flip all, flip 3k+1 )\\n                   1 0 1 ( after 2 operations: flip odd, flip all )\\n                   1 1 0 ( after 2 operations: flip odd, flip 3k+1 )\\n                   1 1 1 ( after 2 operations: flip all, flip all )\\n\\nm=2\\nSTATE_COUNT:\\n                   7 ( 000 or 001 or 010 or 100 or 101 or 110 or 111 )\\n\\nm=3\\nOPERATIONS:\\n                   ect...\\n                   ect...\\n                   ect...\\nm=3\\nSTATE_COUNT:\\n                   8 ( 000 or 001 or 010 or 011 or 100 or 101 or 110 or 111 )\\n```\n```\\n        if (n>=3){\\n            if (m==1) return 4;\\n            if (m==2) return 7;\\n            if (m>=3) return 8;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107273,
                "title": "2-short-lines-simple-formula",
                "content": "    int flipLights(int n, int m) {\\n        n = min(n, 3);\\n        return min(1<<n, 1+m*n);\\n    }\\n\\nI can't (yet?) explain the `1+m*n` part, though. Really I just wrote a brute force solution, looked at the results for all cases where n, m &le; 10 and found a formula for the pattern I saw :-)",
                "solutionTags": [],
                "code": "    int flipLights(int n, int m) {\\n        n = min(n, 3);\\n        return min(1<<n, 1+m*n);\\n    }\\n\\nI can't (yet?) explain the `1+m*n` part, though. Really I just wrote a brute force solution, looked at the results for all cases where n, m &le; 10 and found a formula for the pattern I saw :-)",
                "codeTag": "Unknown"
            },
            {
                "id": 107277,
                "title": "share-my-o-1-c-solution-with-thinking-process-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nThere is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.\\n\\nSuppose n lights are labeled as number [1, 2, 3, ..., n], function of these 4 buttons are given below:\\n\\n    1. Flip all the lights.\\n    2. Flip lights with even numbers.\\n    3. Flip lights with odd numbers.\\n    4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n\\n**Example 1:**\\n\\n    Input: n = 1, m = 1.\\n    Output: 2\\n    Explanation: Status can be: [on], [off]\\n\\n**Example 2:**\\n\\n    Input: n = 2, m = 1.\\n    Output: 3\\n    Explanation: Status can be: [on, off], [off, on], [off, off]\\n\\n**Example 3:**\\n\\n    Input: n = 3, m = 1.\\n    Output: 4\\n    Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].\\n\\n**Note:** n and m both fit in range [0, 1000]. \\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Predefinition\\n\\n---\\n\\nIn order to make the explanation much clearer, **the state of the lights** is defined by an **n-digit binary number K**.\\n\\nSince n lights are labeled as number [1, 2, 3, ..., n], the **p-th (1 \\u2264 p \\u2264 n) digit of K** represents **the state of light p**, which means\\n\\n- When the digit is 1, light p is on.\\n\\n- When the digit is 0, light p is off.\\n\\nSince all lights are turned on initially, **the initial K is 111....1 (with n 1's)**.\\n\\nHere, the operations of the 4 buttons from 1 to 4 are also named to \\n\\n>#### **OP1, OP2, OP3, OP4**\\n\\nThe whole problem now becomes\\n\\n>#### **By doing m operations in {OP1, OP2, OP3, OP4}, how many different K's can we get?**\\n\\n---\\nIn the following explanation, the **4 different operations** will be marked by **4 different colors**:\\n\\n![0_1504591374428_color.png](https://discuss.leetcode.com/assets/uploads/files/1504591306285-color.png) \\n\\n---\\nHere, we also need to introduce [2 definitions in mathematics](https://en.wikipedia.org/wiki/Closure_(mathematics)).\\n\\n**Closure:**\\n\\n> #### **A set has closure under an operation if performance of that operation on members of the set always produces a member of the same set; in this case we also say that the set is closed under the operation.**\\n\\n**Closed under a collection of operations:**\\n\\n>#### **A set is said to be **closed under a collection of operations** if it is closed under each of the operations individually.**\\n\\n---\\n#### 2.2 Bi-directional proof\\n\\n---\\nIf the state of all the lights are represented by a binary number K,\\n\\n- If we do **a single operation** (OP1, OP2, OP3 or OP4) **even times**, the **specified lights** (all in OP1, even in OP2, odd in OP3, 3k+1 in OP4) will be **toggled even times**.\\n\\n- **The specified lights' status won't change, which means K won't change**.\\n\\n---\\nIt can be inferred that\\n\\n>#### **The transition between different K's are always bi-directional.**\\n\\n---\\n#### 2.3 Special case\\n\\n---\\nIf **m = 0, we do nothing, the result is only the initial K**, which means\\n\\n> #### **The answer is 1.**\\n\\n---\\n\\n#### 2.4 When n = 1\\n\\n---\\n\\nThe state diagram will be\\n\\n![0_1504591559446_diagram_1.png](http://discuss.leetcode.com/assets/uploads/files/1504591491378-diagram_1.png) \\n\\n---\\n**Initially, K = 1.**\\n\\n- After OP1, light 1 is off, K = 0.\\n- After OP2, since 1 is odd, light 1 is still on, K = 1.\\n- After OP3, since 1 is odd, light 1 is off, K = 0.\\n- After OP4, since 1 mod 3 = 1, light 1 is off, K = 0.\\n\\nSince the 4 transitions in the diagram are all bi-directional, the maximum number of probable K's is 2 (1 and 0).\\n\\n---\\nThen, do the **mathematical Induction**\\n\\n- When **m = 1**, the result can be 1(do OP2 once) and 0(do OP1, OP3 or OP4 once).\\n- Suppose after the q-th transition, **m = q (q \\u2265 1)**, we are probably at 0, 1.(**2 probable statuses**)\\n   - If the **result is 1**, in the next transition **(m = q + 1), K can be 1 or 0**.\\n   - If the **result is 0**, in the next transition **(m = q + 1), K can only be 1**.\\n   - **Still 2 probable statuses.**\\n- When **m = q + 1**, the **probable result STILL** can be **0 or 1**.\\n- **When n = 1, for all m, K can only be 0 or 1, and the answer is 2**\\n\\n---\\nIt's clear that\\n\\n> #### **The set {0,1} is a closure, and it is closed under the operation set {OP1, OP2, OP3, OP4}.**\\n\\nwhich means\\n\\n>#### **When n = 1, the answer is always 2.**\\n\\n---\\n#### 2.5 When n = 2\\n\\n---\\nThe state diagram will be\\n\\n![0_1504666814740_diagram_2.png](/assets/uploads/files/1504666748347-diagram_2.png) \\n\\n---\\n**Here, since all transitions are bi-directional, all two-way arrows are omitted.**\\n\\n**The maximum number of probable different K's is 4 (11, 00, 10, 01).**\\n\\n**The 4 statuses of K are marked as A0, A1, A2 and A3.**\\n\\n---\\n\\nFrom the diagram, we can see\\n\\n**Initially, K = A0 = 11.** Then, do the **mathematical Induction**\\n\\n- When **m = 1**, go from A0 to A1, A2 or A3. There are 3 different K's. **The answer is 3.**\\n- **We are now at A1, A2 or A3 after first transition.** \\n- When **m = 2**\\n    - Since A1, A2, A3 forms a **triangle loop**, they can **transit to each other**, which means A1, A2, A3 are all possible answer for K. \\n    - Since A1, A2, A3 can transit to A0, A0 is also a possible answer for K.\\n    - **The answer is 3 + 1 = 4.**\\n\\n- Suppose after the q-th transition, **m = q (q \\u2265 2)**, we are probably at A0, A1, A2, A3. (**4 probable statuses**)\\n- When **m = q + 1**\\n   - If we are at A0, next status will probably be A1, A2, A3.\\n   - If we are at A1, A2 or A3, next status will probably be A0, A1, A2, A3.\\n   - We are still probably at A0, A1, A2, A3.\\n   - **Still 4 probable statuses in all.**\\n\\n---\\nIt's clear that\\n\\n>#### **The set {A0, A1, A2, A3} is a closure, and it is closed under operation set {OP1, OP2, OP3, OP4}.**\\n\\nThe conclusion is\\n\\n> #### **When n = 2, If m = 1, the answer is 3. If m \\u2265 2, the answer is 4.**\\n\\n---\\n#### 2.6 When n = 3\\n\\n---\\nThe state diagram will be\\n\\n![0_1504666826464_diagram_3.png](/assets/uploads/files/1504666758850-diagram_3.png) \\n\\n---\\n**Here, since all transitions are bi-directional, all two-way arrows are omitted.**\\n\\n**The maximum number of probable different K's is 8 (111, 000, 101, 010, 011, 100, 001, 110).**\\n\\n**The 8 statuses of K are marked as A0, A1, A2, A3 (vertices in the outer pyramid) and B0, B1, B2, B3 (vertices in the inner pyramid).**\\n\\n---\\n\\nFrom the diagram, we can see\\n\\n**Initially, K = A0 = 111**. Then, do the **mathematical Induction**\\n\\n- When **m = 1**, go from A0 to B0, A1, A2 or A3. There are 4 different K's. **The answer is 4.**\\n- **We are now at B0, A1, A2 or A3 after first transition.** \\n- When **m = 2**\\n  - Since **A1, A2, A3 forms a triangle loop**, they can **transit to each other**, which means **A1, A2, A3 are possible answer for K**. \\n  - Since **A1 can transit to B1, A2 can transit to B2, A3 can transit to B3**, **B1, B2, B3 are possible answer for K**. \\n  - Since **B0, A1, A2 or A3 can transit to A0**, **A0 is a possible answer for K**.\\n  - Since **B0 can transit to B1, B2, B3**,  **B1, B2, B3 are possible answer for K**.\\n  - **All possible K's are A0, A1, A2, A3, B1, B2, B3 after second transition**.\\n  - **The answer is 7.**\\n- **We are now at A0, A1, A2, A3, B1, B2, B3 after second transition.**\\n- When **m = 3**\\n  - **A0 can transit to B0.**\\n  - **A1 can transit to B1.**\\n  - **A2 can transit to B2.**\\n  - **A3 can transit to B3.**\\n  - **A1, A2, A3 can transit to A0.**\\n  - **B1 can transit to A1.**\\n  - **B2 can transit to A2.**\\n  - **B3 can transit to A3.**\\n  - **All possible K's are A0, A1, A2, A3, B0, B1, B2, B3 after third transition**.\\n  - **The answer is 8.**\\n- Suppose after the q-th transition, **m = q (q \\u2265 3)**, we are probably at A0, A1, A2, A3, B0, B1, B2, B3. (**8 probable statuses**)\\n- When **m = q + 1**\\n  - **A0 can transit to B0.**\\n  - **A1 can transit to B1.**\\n  - **A2 can transit to B2.**\\n  - **A3 can transit to B3.**\\n  - **B0 can transit to A0.**\\n  - **B1 can transit to A1.**\\n  - **B2 can transit to A2.**\\n  - **B3 can transit to A3.**\\n  - **All possible K's are STILL A0, A1, A2, A3, B0, B1, B2, B3**.\\n  - **Still, the answer is 8.**\\n\\n---\\nIt's clear that\\n\\n> #### **The set {A0, A1, A2, A3, B0, B1, B2, B3} is a closure, and it is closed under operation set {OP1, OP2, OP3, OP4}.**\\n\\nThe conclusion is\\n\\n> #### **When n = 3, If m = 1, the answer is 4. If m = 2, the answer is 7. If m \\u2265 3, the answer is 8.**\\n\\n---\\n\\n#### 2.7 When n > 3\\n\\n---\\nSuppose **K = A0 has n digits, and its p-th digit is A0(p), 1 \\u2264 p \\u2264 n.**\\n\\n- **Initially, A0 = 111...1 (n 1's)**, which means\\n  - **A0(p) = 1, p mod 6 = 1.**\\n  - **A0(p) = 1, p mod 6 = 2.**\\n  - **A0(p) = 1, p mod 6 = 3.**\\n  - **A0(p) = 1, p mod 6 = 4.**\\n  - **A0(p) = 1, p mod 6 = 5.** \\n  - **A0(p) = 1, p mod 6 = 0.**\\n\\n---\\n- **By doing OP1 on A0 , we get A1,** and\\n  - **A1(p) = 0, p mod 6 = 1.**\\n  - **A1(p) = 0, p mod 6 = 2.**\\n  - **A1(p) = 0, p mod 6 = 3.**\\n  - **A1(p) = 0, p mod 6 = 4.**\\n  - **A1(p) = 0, p mod 6 = 5.**\\n  - **A1(p) = 0, p mod 6 = 0.**\\n- **By doing OP2 on A0 , we get A2,** and\\n  - **A2(p) = 1, p mod 6 = 1.**\\n  - **A2(p) = 0, p mod 6 = 2.**\\n  - **A2(p) = 1, p mod 6 = 3.**\\n  - **A2(p) = 0, p mod 6 = 4.**\\n  - **A2(p) = 1, p mod 6 = 5.**\\n  - **A2(p) = 0, p mod 6 = 0.**\\n- **By doing OP3 on A0 , we get A3,** and\\n  - **A3(p) = 0, p mod 6 = 1.**\\n  - **A3(p) = 1, p mod 6 = 2.**\\n  - **A3(p) = 0, p mod 6 = 3.**\\n  - **A3(p) = 1, p mod 6 = 4.**\\n  - **A3(p) = 0, p mod 6 = 5.**\\n  - **A3(p) = 1, p mod 6 = 0.**\\n\\n---\\n- **By doing OP4 on A0 , we get B0,** and\\n  - **B0(p) = 0, p mod 6 = 1.**\\n  - **B0(p) = 1, p mod 6 = 2.**\\n  - **B0(p) = 1, p mod 6 = 3.**\\n  - **B0(p) = 0, p mod 6 = 4.**\\n  - **B0(p) = 1, p mod 6 = 5.**\\n  - **B0(p) = 1, p mod 6 = 0.**\\n\\n---\\n- **By doing OP1 on B0 , we get B1,** and\\n  - **B1(p) = 1, p mod 6 = 1.**\\n  - **B1(p) = 0, p mod 6 = 2.**\\n  - **B1(p) = 0, p mod 6 = 3.**\\n  - **B1(p) = 1, p mod 6 = 4.**\\n  - **B1(p) = 0, p mod 6 = 5.**\\n  - **B1(p) = 0, p mod 6 = 0.**\\n- **By doing OP2 on B0 , we get B2,** and\\n  - **B2(p) = 0, p mod 6 = 1.**\\n  - **B2(p) = 0, p mod 6 = 2.**\\n  - **B2(p) = 1, p mod 6 = 3.**\\n  - **B2(p) = 1, p mod 6 = 4.**\\n  - **B2(p) = 1, p mod 6 = 5.**\\n  - **B2(p) = 0, p mod 6 = 0.**\\n- **By doing OP3 on B0 , we get B3,** and\\n  - **B3(p) = 1, p mod 6 = 1.**\\n  - **B3(p) = 1, p mod 6 = 2.**\\n  - **B3(p) = 0, p mod 6 = 3.**\\n  - **B3(p) = 0, p mod 6 = 4.**\\n  - **B3(p) = 0, p mod 6 = 5.**\\n  - **B3(p) = 1, p mod 6 = 0.**\\n\\n---\\nSince it has already been proved in 2.2 that\\n\\n> #### **The transition between different K's are always bi-directional.**\\n\\nSince we only need to calculate on a single direction, we can get\\n\\n- **By doing OP4 on B1 , we get A1.**\\n- **By doing OP4 on B2 , we get A2.**\\n- **By doing OP4 on B3 , we get A3.**\\n\\n---\\n- **By doing OP3 on A1 , we get A2.**\\n- **By doing OP1 on A2 , we get A3.**\\n- **By doing OP2 on A3 , we get A1.**\\n\\nSimilarly,\\n- **By doing OP3 on B1 , we get B2.**\\n- **By doing OP1 on B2 , we get B3.**\\n- **By doing OP2 on B3 , we get B1.**\\n\\n---\\nSince **the first 3 digits of A0, A1, A2, A3, B0, B1, B2, B3 are different**, we can inferred that\\n\\n>#### **A0, A1, A2, A3, B0, B1, B2, B3 are all different binary numbers.**\\n\\nwhich means\\n\\n>#### **A0, A1, A2, A3, B0, B1, B2, B3 represents 8 different statuses.**\\n\\nSince the result of doing {OP1, OP2, OP3, OP4} on the set {A0, A1, A2, A3, B0, B1, B2, B3} is still in the set  {A0, A1, A2, A3, B0, B1, B2, B3}, it can be inferred that when n > 3\\n\\n> #### **The set {A0, A1, A2, A3, B0, B1, B2, B3} is STILL a closure, and it is STILL closed under operation set {OP1, OP2, OP3, OP4}.**\\n\\n---\\nIf we draw the state diagram\\n\\n![0_1504666840971_diagram_m.png](/assets/uploads/files/1504666773118-diagram_m.png) \\n\\nwe can find **this diagram is as same as those in 2.6 when n = 3**.\\n\\n---\\nSince we have already discussed on the diagram in 2.6, here we come to the conclusion\\n\\n> #### **When n > 3, If m = 1, the answer is 4. If m = 2, the answer is 7. If m \\u2265 3, the answer is 8.**\\n\\n---\\n## 3. Conclusion\\n\\n---\\nAfter the discussion, we can infer that **the final answer is**\\n\\n- **When m = 0, the answer is 1.**\\n\\n\\n- **When n = 1, the answer is 2.**\\n- **When n = 2**\\n   - **If m = 1, the answer is 3.**\\n   - **If m \\u2265 2, the answer is 4.**\\n- **When n \\u2265 3**\\n   - **If m = 1, the answer is 4.**\\n   - **If m = 2, the answer is 7.**\\n   - **If m \\u2265 3, the answer is 8.**\\n\\n---\\n## 4. Complexity analysis\\n\\n---\\n> #### **Both the time and space complexity are O(1).**\\n\\n---\\n## 5. Code\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0)\\n        {\\n            return 1;\\n        }else{\\n            switch(n)\\n            {\\n                case 1: return 2;break;\\n                case 2: return (m == 1) ? 3 : 4;break;\\n                default:\\n                switch(m)\\n                {\\n                    case 1: return 4;break;\\n                    case 2: return 7;break;\\n                    default: return 8;break;\\n                }\\n                break;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0)\\n        {\\n            return 1;\\n        }else{\\n            switch(n)\\n            {\\n                case 1: return 2;break;\\n                case 2: return (m == 1) ? 3 : 4;break;\\n                default:\\n                switch(m)\\n                {\\n                    case 1: return 4;break;\\n                    case 2: return 7;break;\\n                    default: return 8;break;\\n                }\\n                break;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107274,
                "title": "2-line-python-recursive-with-explanation",
                "content": "Inspired by: [this post](https://discuss.leetcode.com/topic/102395/2-short-lines-simple-formula/2)\\n```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        m, n = min(3, m), min(3, n)\\n        return 1 if n == 0 or m == 0 else self.flipLights(n - 1,  m) + self.flipLights( n - 1, m - 1)      \\n```\\n\\nOperations: O(flip odds), E(flip evens), A(flip all), T(flip 3k + 1), N(flip nothing)\\nRelations:\\nO + O = N, E + E = N, A + A = N, T + T = N\\nO + E = A, O + A = E, E + A = O\\nExclusive statuses :\\nn > 2:\\n\\u2460 N\\n\\u2461 O\\n\\u2462 E\\n\\u2463 A\\n\\u2464 T\\n\\u2465 O + T\\n\\u2466 E + T\\n\\u2467 A + T\\n\\nn = 2 (remove all T related statuses):\\n\\u2460 N\\n\\u2461 O\\n\\u2462 E\\n\\u2463 A\\n\\nn = 1(remove all T, E, A related statuses):\\n\\u2460 N\\n\\u2461 O\\n\\nSteps needed to all status( always can plus 2 * k)\\n\\u2460 can only be achieved by 0, 2 steps\\n\\u2461\\uff0c\\u2462\\uff0c\\u2463 can be achieved by either 1 or 2 steps\\n\\u2464 can only be achieved by 1 steps\\n\\u2465\\uff0c\\u2466\\uff0c\\u2467 can only be achieved by 2 steps,\\n\\nThus:\\n0 steps -> \\u2460\\n1 steps -> \\u2461\\uff0c\\u2462\\uff0c\\u2463\\uff0c\\u2464\\n2 steps -> \\u2460\\uff0c\\u2461\\uff0c\\u2462\\uff0c\\u2463\\uff0c\\u2465\\uff0c\\u2466\\uff0c\\u2467\\nmore than 2 steps -> \\u2460, \\u2461, \\u2462, \\u2463, \\u2464, \\u2465, \\u2466, \\u2467\\n\\n![0_1504741152259_Screen Shot 2017-09-06 at 4.23.25 PM.png](/assets/uploads/files/1504741152817-screen-shot-2017-09-06-at-4.23.25-pm.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        m, n = min(3, m), min(3, n)\\n        return 1 if n == 0 or m == 0 else self.flipLights(n - 1,  m) + self.flipLights( n - 1, m - 1)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674197,
                "title": "c-5-lines-code-with-line-by-line-explanations-and-observations",
                "content": "I must admit I can\\'t solve it after staring at it for hours (Partly because I believe there must be a way to solve it without enumerating all cases...). So I read many posts and tried to write my code according to those posts, below is the AC code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) return 1; // no presses, original state\\n        if (n == 1) return 2; // constraint: (p > 0) : one light, binary states.\\n        if (p == 1) return n > 2 ? 4 : 3; // constraint: (p > 0 && n > 1) : one press, if (1) two lights -> all 2^2 but original state = 3 states (2) more than two lights -> 011, 010, 101, 000 = 4 states\\n        if (n == 2) return 4; // constraint: (p > 1 && n > 1) : two lights, multiple press, 4 states.\\n        return p == 2 ? 7 : 8; // constraint: (p > 1 && n > 2) : if only two presses, can\\'t be in 4(011) state -> 8-1 = 7\\n    }\\n};\\n\\n/**\\n\\nObservations:\\n1) only the first 3 lights matter, since we can only switch (1) even (2) odd (3) (x = 1 MOD 3) lights\\n2) all ops are commutative.\\n3) there is only 8 states possible for all situations: All-on(111), 1(000), 2(010), 3(101), 4(011), 41(100), 42(110), 43(001)\\n*/\\n```\\nIf it is helpful, maybe a upvote?",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) return 1; // no presses, original state\\n        if (n == 1) return 2; // constraint: (p > 0) : one light, binary states.\\n        if (p == 1) return n > 2 ? 4 : 3; // constraint: (p > 0 && n > 1) : one press, if (1) two lights -> all 2^2 but original state = 3 states (2) more than two lights -> 011, 010, 101, 000 = 4 states\\n        if (n == 2) return 4; // constraint: (p > 1 && n > 1) : two lights, multiple press, 4 states.\\n        return p == 2 ? 7 : 8; // constraint: (p > 1 && n > 2) : if only two presses, can\\'t be in 4(011) state -> 8-1 = 7\\n    }\\n};\\n\\n/**\\n\\nObservations:\\n1) only the first 3 lights matter, since we can only switch (1) even (2) odd (3) (x = 1 MOD 3) lights\\n2) all ops are commutative.\\n3) there is only 8 states possible for all situations: All-on(111), 1(000), 2(010), 3(101), 4(011), 41(100), 42(110), 43(001)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107282,
                "title": "java-o-1-solution",
                "content": "There's a total only `six` possible answers:\\n`1, 2, 3, 4, 7 and 8`\\n```\\npublic int flipLights(int n, int m) {\\n            if (n == 1 && m > 0) {\\n                return 2;\\n            } else if (n == 2 && m == 1) {\\n                return 3;\\n            } else if ((n > 2 && m == 1) || (n == 2 && m > 1)) {\\n                return 4;\\n            } else if (n > 2 && m == 2) {\\n                return 7;\\n            } else if (n > 2 && m > 2) {\\n                return 8;\\n            } else {\\n                return 1;\\n            }\\n        }\\n```\\n\\nOne can imagine there's a 2d array `dp` with `m` rows and `n` columns, suppose m == 5 and n == 7, this `dp` matrix will be like the following:\\n\\n```\\n2, 3, 4, 4, 4, 4, 4, \\n2, 4, 7, 7, 7, 7, 7, \\n2, 4, 8, 8, 8, 8, 8, \\n2, 4, 8, 8, 8, 8, 8, \\n2, 4, 8, 8, 8, 8, 8,\\n```\\n\\nAs `m` and `n` extend, the result will be fixed, so a total only 6 possible answers, we could basically \"hardcode\" them as the above.\\n\\nAlso viewable [here](https://github.com/fishercoder1534/Leetcode/blob/master/src/main/java/com/fishercoder/solutions/_672.java) on Github.",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n            if (n == 1 && m > 0) {\\n                return 2;\\n            } else if (n == 2 && m == 1) {\\n                return 3;\\n            } else if ((n > 2 && m == 1) || (n == 2 && m > 1)) {\\n                return 4;\\n            } else if (n > 2 && m == 2) {\\n                return 7;\\n            } else if (n > 2 && m > 2) {\\n                return 8;\\n            } else {\\n                return 1;\\n            }\\n        }\\n```\n```\\n2, 3, 4, 4, 4, 4, 4, \\n2, 4, 7, 7, 7, 7, 7, \\n2, 4, 8, 8, 8, 8, 8, \\n2, 4, 8, 8, 8, 8, 8, \\n2, 4, 8, 8, 8, 8, 8,\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107290,
                "title": "python-solution-this-is-not-a-programming-questions-imo",
                "content": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0:\\n            return 1\\n        if n >= 3:\\n            return 4 if m == 1 else 7 if m == 2 else 8\\n        if n == 2:\\n            return 3 if m == 1 else 4\\n        if n == 1:\\n            return 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0:\\n            return 1\\n        if n >= 3:\\n            return 4 if m == 1 else 7 if m == 2 else 8\\n        if n == 2:\\n            return 3 if m == 1 else 4\\n        if n == 1:\\n            return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897976,
                "title": "python3-o-1",
                "content": "Key insight: \\nIt is not difficult to find out that there are not a lot of states since \\n1) operations are reversible;\\n2) operations can be reproduced by other operations. \\n\\nTo get a more concrete understanding, let\\'s list the outcomes of given `m` and `n` up to 5. From the table, it is obvious that \\n1) beyond 3, `n` and `m` become irrelevant because there are at most 8 states all of which become achievable when `m` and `n` are large enough; \\n2) below 3, `fn(n, m) = fn(n-1, m-1) + fn(n-1, m)`. \\n\\n```\\nn/m 0 1 2 3 4 5\\t\\t\\n0   1 1 1 1 1 1\\t \\n1   1 2 2 2 2 2\\n2   1 3 4 4 4 4\\n3   1 4 7 8 8 8\\n4   1 4 7 8 8 8\\n5   1 4 7 8 8 8\\n```\\n\\n```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        \\n        def fn(n, m): \\n            \"\"\"Return number of different status.\"\"\"\\n            if m * n == 0: return 1\\n            return fn(n-1, m-1) + fn(n-1, m)\\n        \\n        return fn(min(n, 3), min(m, 3))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nn/m 0 1 2 3 4 5\\t\\t\\n0   1 1 1 1 1 1\\t \\n1   1 2 2 2 2 2\\n2   1 3 4 4 4 4\\n3   1 4 7 8 8 8\\n4   1 4 7 8 8 8\\n5   1 4 7 8 8 8\\n```\n```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        \\n        def fn(n, m): \\n            \"\"\"Return number of different status.\"\"\"\\n            if m * n == 0: return 1\\n            return fn(n-1, m-1) + fn(n-1, m)\\n        \\n        return fn(min(n, 3), min(m, 3))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175165,
                "title": "conventional-c-bfs-solution-with-very-clear-explanation",
                "content": "At first glance of this question, we can easily come up with a dfs or bfs idea. But considering the time complexity (n,m<=1000), it appears a traditional search-based method will generate TLE. But if we carefully look at the state-transfer function, we can see that, the first three will just generate 3 different status (`00000....`,`11111....`,`01010101......`,`10101010....`) . So we may assume that the final status after m operations should not be too large, though we still didn\\'t take the 4th operations into account. Let\\'s think about our bfs solution in this way: after k steps,we expanded all elements that should be visited in the next level, let\\'s call them `status_set`. Here we use set because we don\\'t want to have duplicates of these status; We also memoraize the size of `status_set` (`prev_size`) generate by previous level. Once we found `status_set.size()==prev_size`, we know that there is no need to search deeper because no more elements will be added to the set. So now we can just return the `prev_size`, which is actually only 8. Below is my code:\\n```\\nclass Solution {\\npublic:\\n    string op(int type,string& s){\\n        if(type==0){\\n            for(int i = 0;i<s.length();i++){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==1){\\n            for(int i = 1;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==2){\\n            for(int i = 0;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else{\\n            for(int k = 0;3*k+1<=s.length();k++){\\n                int i = 3*k;\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n    int flipLights(int n, int m) {\\n        string root(n,\\'1\\');\\n        unordered_set<string> mset;\\n        queue<string> q;\\n        q.push(root);\\n        mset.insert(root);\\n        int cur_size = mset.size();\\n        int level = 0;\\n        while(!q.empty() && level<m){\\n            int size = q.size();\\n            mset.clear();\\n            for(int i = 0;i<size;i++){\\n                string front = q.front();\\n                q.pop();\\n                for(int k = 0;k<4;k++){\\n                    string s = op(k,front);\\n                    mset.insert(s);   \\n                    q.push(s);\\n                }\\n            }\\n            level++;\\n            if(mset.size()==cur_size) break;\\n            cur_size = mset.size();\\n        }\\n        return cur_size;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string op(int type,string& s){\\n        if(type==0){\\n            for(int i = 0;i<s.length();i++){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==1){\\n            for(int i = 1;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==2){\\n            for(int i = 0;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else{\\n            for(int k = 0;3*k+1<=s.length();k++){\\n                int i = 3*k;\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n    int flipLights(int n, int m) {\\n        string root(n,\\'1\\');\\n        unordered_set<string> mset;\\n        queue<string> q;\\n        q.push(root);\\n        mset.insert(root);\\n        int cur_size = mset.size();\\n        int level = 0;\\n        while(!q.empty() && level<m){\\n            int size = q.size();\\n            mset.clear();\\n            for(int i = 0;i<size;i++){\\n                string front = q.front();\\n                q.pop();\\n                for(int k = 0;k<4;k++){\\n                    string s = op(k,front);\\n                    mset.insert(s);   \\n                    q.push(s);\\n                }\\n            }\\n            level++;\\n            if(mset.size()==cur_size) break;\\n            cur_size = mset.size();\\n        }\\n        return cur_size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497288,
                "title": "easy-o-1-solution",
                "content": "\\n# Complexity\\n- Time complexity: **O(1)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k == 0) return 1;\\n        if(n == 1) return 2;\\n        if(n == 2 && k == 1) return 3;\\n        if(n == 2 || k == 1) return 4;\\n        if(k == 2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k == 0) return 1;\\n        if(n == 1) return 2;\\n        if(n == 2 && k == 1) return 3;\\n        if(n == 2 || k == 1) return 4;\\n        if(k == 2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317125,
                "title": "672-time-96-77-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Reduce n to at most 3, since any action performed more than 3 times will result in a pattern that has already been counted.\\n2. If m is 0, return 1 as there is only one possible outcome (all lights off).\\n3. If m is 1, return the number of possible outcomes for the given value of n and m.\\n4. If m is 2, return the number of possible outcomes for the given value of n and m.\\n5. If m is greater than or equal to 3, return the number of possible outcomes for the given value of n and m.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        # Reduce n to at most 3, since any action performed more than 3 times\\n        # will result in a pattern that has already been counted\\n        n = min(n, 3)\\n        if m == 0:\\n            return 1\\n        elif m == 1:\\n            # For m=1, there are only 2 outcomes for n=1, 3 outcomes for n=2, and 4 outcomes for n=3\\n            return [2, 3, 4][n - 1]\\n        elif m == 2:\\n            # For m=2, there are only 2 outcomes for n=1, 4 outcomes for n=2, and 7 outcomes for n=3\\n            return [2, 4, 7][n - 1]\\n        else:\\n            # For m>=3, there are only 2 outcomes for n=1, 4 outcomes for n=2, and 8 outcomes for n=3\\n            return [2, 4, 8][n - 1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        # Reduce n to at most 3, since any action performed more than 3 times\\n        # will result in a pattern that has already been counted\\n        n = min(n, 3)\\n        if m == 0:\\n            return 1\\n        elif m == 1:\\n            # For m=1, there are only 2 outcomes for n=1, 3 outcomes for n=2, and 4 outcomes for n=3\\n            return [2, 3, 4][n - 1]\\n        elif m == 2:\\n            # For m=2, there are only 2 outcomes for n=1, 4 outcomes for n=2, and 7 outcomes for n=3\\n            return [2, 4, 7][n - 1]\\n        else:\\n            # For m>=3, there are only 2 outcomes for n=1, 4 outcomes for n=2, and 8 outcomes for n=3\\n            return [2, 4, 8][n - 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723656,
                "title": "4-liner-c-solution-o-1-tc",
                "content": "Here is my solution.\\n\\nThere are only 8 states possible and which can be convered in the following cases.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if(n == 0) return 1;\\n        if(n == 1) return vector<int>{1,2}[min(p,1)];\\n        if(n == 2) return vector<int>{1,3,4}[min(p,2)];\\n        return vector<int>{1,4,7,8}[min(p,3)];\\n    }\\n};\\n```\\n\\nTC : O(1)\\nSC : O(1)\\n\\nThank you :>",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if(n == 0) return 1;\\n        if(n == 1) return vector<int>{1,2}[min(p,1)];\\n        if(n == 2) return vector<int>{1,3,4}[min(p,2)];\\n        return vector<int>{1,4,7,8}[min(p,3)];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926323,
                "title": "python-bfs",
                "content": "# Intuition\\nWe need to traverse the states graph for exactly ``presses`` levels and get the total number of states discovered on the last level.\\n\\n# Approach\\nWe can do either BFS or DFS. We also need an efficient way to represent a state and to calculate next states. \\nWe can represent states as binary numbers where ith bit is set to ``1`` if the ith bulb is switched on and ``0`` otherwise. \\nThen, for the state transitions, we have: \\n1. Toggle all bulbs - perform an bitwise XOR on the state with all bits set to 1\\n2. Toggle even bulbs - perform an bitwise XOR on the state with all even bits set to 1 \\n3. Toggle odd bulbs - perform an bitwise XOR on the state with all odd bits set to 1 \\n4. Toggle ``3*k+1`` bulbs - perform an bitwise XOR on the state with all ith bits set to 1, where ``i % 3 == 1``\\n\\nSince ``n <= 1000`` we would need big numbers to represent those states. Luckily Python has an out of the box support for big numbers.\\n\\n\\n# Complexity\\n- Time complexity: $$O(presses)$$\\nWe need to perform ``presses`` steps traversing the states graph, each step has $$O(1)$$ operations.\\n\\n- Space complexity:\\nSpace complexity is trickier here. On each step we discover 4 states from each state, however there are a lot of duplicated states. It can be proven that because of the operations that we have we wouldn\\'t get more than ``8`` different states on each level. \\n\\nIntuition:\\nWe can divide the whole state in groups of 3 digits and only have following operations:\\n1. Switch all 3 bits\\n2. Switch odd bits\\n3. Switch even bits\\n4. Switch only last bit\\n\\nRest bits will be changed in the same way. The only problem is that we would change odd and even groups of 3 differently for odd and even bits toggles.\\n\\nI don\\'t have a better explanation yet, but my guess is that only ``8`` different states are possible at most.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n\\n        all_ones, evens, odds, three = 0, 0, 0, 0\\n        for i in range(n):\\n            all_ones = (all_ones << 1) + 1\\n            evens = (evens << 1) + (1 if (i+1) % 2 == 0 else 0)\\n            odds = (odds << 1) + (1 if (i+1) % 2 == 1 else 0)\\n            three = (three << 1) + (1 if (i+1) % 3 == 1 else 0)\\n\\n        state = all_ones\\n\\n        level = {state}\\n        for i in range(presses):\\n            next_level = set()\\n            for state in level:\\n                states = [state ^ all_ones,\\n                          state ^ evens,\\n                          state ^ odds,\\n                          state ^ three]\\n                for next_state in states:\\n                    next_level.add(next_state)\\n            level = next_level\\n\\n        return len(level)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n\\n        all_ones, evens, odds, three = 0, 0, 0, 0\\n        for i in range(n):\\n            all_ones = (all_ones << 1) + 1\\n            evens = (evens << 1) + (1 if (i+1) % 2 == 0 else 0)\\n            odds = (odds << 1) + (1 if (i+1) % 2 == 1 else 0)\\n            three = (three << 1) + (1 if (i+1) % 3 == 1 else 0)\\n\\n        state = all_ones\\n\\n        level = {state}\\n        for i in range(presses):\\n            next_level = set()\\n            for state in level:\\n                states = [state ^ all_ones,\\n                          state ^ evens,\\n                          state ^ odds,\\n                          state ^ three]\\n                for next_state in states:\\n                    next_level.add(next_state)\\n            level = next_level\\n\\n        return len(level)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623308,
                "title": "java-c-python-all-constant-time-o-1-explained",
                "content": "**UPVOTE PLEASE**\\n```\\nWe only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8.\\nThe four buttons:\\n\\nFlip all the lights.\\nFlip lights with even numbers.\\nFlip lights with odd numbers.\\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n1 + 2 --> 3, 1 + 3 --> 2, 2 + 3 --> 1\\nSo, there are only 8 cases.\\n\\nAll_on, 1, 2, 3, 4, 1+4, 2+4, 3+4\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n\\nC++:\\n\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n};\\n\\n\\nPY:\\n\\ndef flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type presses: int\\n        :rtype: int\\n        \"\"\"\\n        if(m==0): return 1;\\n        if(n==1): return 2;\\n        if(n==2 and m==1): return 3;\\n        if(n==2): return 4;\\n        if(m==1): return 4;\\n        if(m==2): return 7;\\n        if(m>=3): return 8;\\n        return 8;\\n\\nJAVA:\\n\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nWe only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8.\\nThe four buttons:\\n\\nFlip all the lights.\\nFlip lights with even numbers.\\nFlip lights with odd numbers.\\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n1 + 2 --> 3, 1 + 3 --> 2, 2 + 3 --> 1\\nSo, there are only 8 cases.\\n\\nAll_on, 1, 2, 3, 4, 1+4, 2+4, 3+4\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n\\nC++:\\n\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n};\\n\\n\\nPY:\\n\\ndef flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type presses: int\\n        :rtype: int\\n        \"\"\"\\n        if(m==0): return 1;\\n        if(n==1): return 2;\\n        if(n==2 and m==1): return 3;\\n        if(n==2): return 4;\\n        if(m==1): return 4;\\n        if(m==2): return 7;\\n        if(m>=3): return 8;\\n        return 8;\\n\\nJAVA:\\n\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&m==1) return 3;\\n        if(n==2) return 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633645,
                "title": "java-o-1-observation",
                "content": "Some press combination result in other press combination, for example, \\n1 & 2 == 3\\n1 & 3 == 2\\n2 & 3 == 1\\nThe only thing that\\'s interesting is press 4, but it can only stack with 2 or 3 to result in a new pattern `(4, 4 + 2, 4 + 3, 4 + 2 + 3)`, so there will only ever be at most 8 patterns in total.\\n\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        //1, 2 -> 3\\n        //1, 3 -> 2\\n        //2, 3 -> 1\\n        //all on, all off, even on, odd on, 3k+1 on, 3k+0+2 on, 3k+1 w/ 2, 3k+1 w/ 3\\n        if (n == 2 && presses == 1) return 3;\\n        if (presses == 1) return Math.min(1 << Math.min(4, n), 4); //i chose 4 arbitarily, just has to be big enough to cover small number and less than 31\\n        if (presses == 2) return Math.min(1 << Math.min(4, n), 7);\\n        if (presses >= 3) return Math.min(1 << Math.min(4, n), 8);\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        //1, 2 -> 3\\n        //1, 3 -> 2\\n        //2, 3 -> 1\\n        //all on, all off, even on, odd on, 3k+1 on, 3k+0+2 on, 3k+1 w/ 2, 3k+1 w/ 3\\n        if (n == 2 && presses == 1) return 3;\\n        if (presses == 1) return Math.min(1 << Math.min(4, n), 4); //i chose 4 arbitarily, just has to be big enough to cover small number and less than 31\\n        if (presses == 2) return Math.min(1 << Math.min(4, n), 7);\\n        if (presses >= 3) return Math.min(1 << Math.min(4, n), 8);\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598457,
                "title": "recursion",
                "content": "<br>\\n\\n![image](https://assets.leetcode.com/users/images/bb37b438-213f-4324-bc41-c8152a7764ba_1638030052.542557.png)\\n\\n<br>\\n<br>\\n\\n```\\nint flipLights(int n, int p)\\n{   \\n\\treturn !p or !n ? 1\\n                    : n>3 ? flipLights(3, p)\\n\\t\\t\\t\\t          : flipLights(n-1, p-1) + flipLights(n-1, p);\\n}\\n```\\n||\\n```\\nint flipLights(int n, int p)\\n{\\n\\treturn n*p ? n>3 ? flipLights(3, p)\\n\\t\\t\\t\\t     : flipLights(n-1, p-1) + flipLights(n-1, p)\\n               : 1;\\n}\\n```\\nI like this solution as it clearly has Fibonacci/Binomial_coeffs vibes.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint flipLights(int n, int p)\\n{   \\n\\treturn !p or !n ? 1\\n                    : n>3 ? flipLights(3, p)\\n\\t\\t\\t\\t          : flipLights(n-1, p-1) + flipLights(n-1, p);\\n}\\n```\n```\\nint flipLights(int n, int p)\\n{\\n\\treturn n*p ? n>3 ? flipLights(3, p)\\n\\t\\t\\t\\t     : flipLights(n-1, p-1) + flipLights(n-1, p)\\n               : 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580973,
                "title": "java-math-o-1-faster-than100-brief-explanation-by-formulas",
                "content": "We can get these formulas easily:\\n* \\tB1B2 = B3\\n* \\tB2B3 = B1\\n* \\tB3B1 = B2\\n* \\tBiBi = 0 (initial status)\\n* \\tBiBj = BjBi (commutative law)\\n\\nSo, for number of bulbs no less than 3, there are at most 8 statuses:\\n* 0(initial status)\\n* B1\\n* B2\\n* B3\\n* B1B4\\n* B2B4\\n* B3B4\\n* B4\\n\\nWe can easily enumrate all final statuses given the number of times we press buttons using the formulas above.\\n\\nNote that for number of bulbs less than 3:\\n1. B4 = B3\\n2. The final statuses will be less than 2^n.\\n\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] mapForLessThan3 = new int[]{1,3,4};\\n        int[] mapForMoreThan2 = new int[]{1,4,7,8};\\n        \\n        if(n<3)\\n            return Math.min(1<<n,mapForLessThan3[Math.min(presses,2)]);            \\n        return mapForMoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] mapForLessThan3 = new int[]{1,3,4};\\n        int[] mapForMoreThan2 = new int[]{1,4,7,8};\\n        \\n        if(n<3)\\n            return Math.min(1<<n,mapForLessThan3[Math.min(presses,2)]);            \\n        return mapForMoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337871,
                "title": "faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if ((presses == 0) || (n == 0)) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2; // even => noop\\n        }\\n        if (presses == 1) {\\n            // n = 2\\n            // |-> 01, 10, 11\\n            // n > 2\\n            // |-> 101, 010, 111, 100\\n            return 3 + (n >= 3);\\n        }\\n        if (n == 2) {\\n            // 10  odd or 3k+1\\n            // 01  even\\n            // 11  full or (even + odd)\\n            // 00  two identical ops\\n            return 3 + (presses >= 2);\\n        }\\n        // n >= 3, presses >= 2\\n        // |-> 010, 101, 111 \\n        // |-> 000 (two identical ops)\\n        // |-> 110, 011 (combined with 3k+1)\\n        // 100 cannot be done with 2 ops\\n        return 7 + (presses >= 3);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if ((presses == 0) || (n == 0)) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2; // even => noop\\n        }\\n        if (presses == 1) {\\n            // n = 2\\n            // |-> 01, 10, 11\\n            // n > 2\\n            // |-> 101, 010, 111, 100\\n            return 3 + (n >= 3);\\n        }\\n        if (n == 2) {\\n            // 10  odd or 3k+1\\n            // 01  even\\n            // 11  full or (even + odd)\\n            // 00  two identical ops\\n            return 3 + (presses >= 2);\\n        }\\n        // n >= 3, presses >= 2\\n        // |-> 010, 101, 111 \\n        // |-> 000 (two identical ops)\\n        // |-> 110, 011 (combined with 3k+1)\\n        // 100 cannot be done with 2 ops\\n        return 7 + (presses >= 3);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042202,
                "title": "o-1-detailed-explanation",
                "content": "```\\nfunction flipLights(n: number, m: number): number {\\n\\n    // Some observations:\\n    // Combination of 1 - 4 operations\\n    \\n    // Flip all and Flip even numbers = Flip odd numbers\\n    // Flip all and Flip odd numbers = Flip even numbers\\n    // Flip odd ande even numbers = Flip all\\n    // if n < 3, Flip 3k + 1 numbers = Flip odd numbers\\n    \\n    // => 1 + 2 = 3\\n    // => 1 + 3 = 2\\n    // => 2 + 3 = 1\\n    // => n < 3, 4 = 2\\n    \\n    // n = 0 or m = 0, only 1 state (initial state)\\n    if (n == 0 || m == 0) return 1;\\n    \\n    // n = 1, only 2 state\\n    if (n == 1) return 2;\\n    \\n    // n = 2, m = 1\\n    // we cound have 4 operations:\\n    // flip all => 00\\n    // flip odd => 01\\n    // flip even => 10\\n    // flip 3k + 1 => 01\\n    // 2 and 4 are the same, so we have 3 states\\n    if (n == 2 && m == 1) return 3\\n    \\n    // n = 2, m = 2\\n    // possible operations:\\n    // 1 + 1 => nothing change,     11 -> 00 -> 11\\n    // 1 + 2 => 3, flip odd,        11 -> 00 -> 01\\n    // 1 + 3 => 2, flip even,       11 -> 00 -> 10\\n    // 1 + 4 => 2, flip even,       11 -> 00 -> 10\\n    // 2 + 3 => 1, flip all,        11 -> 10 -> 00\\n    // 2 + 4 => 1, flip all,        11 -> 10 -> 00\\n    // 3 + 4 => nothing change,     11 -> 01 -> 11\\n    // added one more state on top of m = 1, so m = 2, 4 states\\n\\n    // based on the above, we can conclude that:\\n    // 1 + 2 = 3\\n    // 1 + 3 = 2\\n    // 2 + 3 = 1\\n    \\n    // n = 2, m > 2\\n    // 1 + 2 + 1 = 3 + 1, flip odd\\n    // 1 + 3 + 1 = 2 + 1, flip even\\n    // not gonna list all of them, but you got the idea:\\n    \\n    // for m >= 2, the possible states are 4\\n    if (n == 2 && m >= 2) return 4;\\n    \\n    // Say, n = 3, m = 1\\n    // flip all     =>      111 -> 000\\n    // flip odd     =>      111 -> 010\\n    // flip even    =>      111 -> 101\\n    // flip 3k + 1  =>      111 -> 011\\n    // could have 4 states, this is a general rule for all n > 2\\n    if (n > 2 && m == 1) return 4;\\n    \\n    // Say, n = 3, m = 2\\n    // 1 + 1                        111 -> 000 -> 111\\n    // 1 + 2 = 3, flip odd,         111 -> 000 -> 010\\n    // 1 + 3 = 2, flip even,        111 -> 000 -> 101\\n    // 1 + 4,                       111 -> 000 -> 100\\n    // 2 + 3 = 1, flip all,         111 -> 101 -> 000\\n    // 2 + 4                        111 -> 101 -> 001\\n    // 3 + 4                        111 -> 010 -> 110\\n    // could have 7 states, this is a general rule for all n > 2 and m = 2\\n    if (n > 2 && m == 2) return 7;\\n    \\n    // n = 3, m > 2\\n    // 1 + 2 + 4 = 3 + 4            111 -> 000 -> 010 -> 110\\n    // 1 + 3 + 4 = 2 + 4            111 -> 000 -> 101 -> 001\\n    // 1 + 4 + 1 = 4                111 -> 000 -> 100 -> 011\\n    // 2 + 4 + 1 = 3 + 4            111 -> 101 -> 001 -> 110\\n    // 3 + 4 + 1 = 2 + 4            111 -> 010 -> 110 -> 001\\n    // added one new possible state on top of m = 1, we got 8 states here\\n    // not gonna list all, but you got the idea:\\n    // for m > 2, we could simpify it to the base case m = 2\\n    // e.g. 1 + 4 + 2 + 3 \\n    //      => simpify 2 + 3 to 1           => 1 + 1 + 4\\n    //      => 1 + 1 is doing nothing       => 4\\n    if (n == 3 && m > 2) return 8;\\n    \\n    // for n > 3, m > 2 it is same as n = 3\\n    if (n > 3 && m > 2) return 8;\\n    \\n    // we can simplify the above findings to the follows but I would keep it to teach the future me\\n    if (n == 0 || m == 0) return 1;\\n    else if (n == 1) return 2;\\n    else if (n == 2 && m == 1) return 3;\\n    else if (m == 1) return 4;\\n    else if (m == 2) return 7;\\n    else return 8;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction flipLights(n: number, m: number): number {\\n\\n    // Some observations:\\n    // Combination of 1 - 4 operations\\n    \\n    // Flip all and Flip even numbers = Flip odd numbers\\n    // Flip all and Flip odd numbers = Flip even numbers\\n    // Flip odd ande even numbers = Flip all\\n    // if n < 3, Flip 3k + 1 numbers = Flip odd numbers\\n    \\n    // => 1 + 2 = 3\\n    // => 1 + 3 = 2\\n    // => 2 + 3 = 1\\n    // => n < 3, 4 = 2\\n    \\n    // n = 0 or m = 0, only 1 state (initial state)\\n    if (n == 0 || m == 0) return 1;\\n    \\n    // n = 1, only 2 state\\n    if (n == 1) return 2;\\n    \\n    // n = 2, m = 1\\n    // we cound have 4 operations:\\n    // flip all => 00\\n    // flip odd => 01\\n    // flip even => 10\\n    // flip 3k + 1 => 01\\n    // 2 and 4 are the same, so we have 3 states\\n    if (n == 2 && m == 1) return 3\\n    \\n    // n = 2, m = 2\\n    // possible operations:\\n    // 1 + 1 => nothing change,     11 -> 00 -> 11\\n    // 1 + 2 => 3, flip odd,        11 -> 00 -> 01\\n    // 1 + 3 => 2, flip even,       11 -> 00 -> 10\\n    // 1 + 4 => 2, flip even,       11 -> 00 -> 10\\n    // 2 + 3 => 1, flip all,        11 -> 10 -> 00\\n    // 2 + 4 => 1, flip all,        11 -> 10 -> 00\\n    // 3 + 4 => nothing change,     11 -> 01 -> 11\\n    // added one more state on top of m = 1, so m = 2, 4 states\\n\\n    // based on the above, we can conclude that:\\n    // 1 + 2 = 3\\n    // 1 + 3 = 2\\n    // 2 + 3 = 1\\n    \\n    // n = 2, m > 2\\n    // 1 + 2 + 1 = 3 + 1, flip odd\\n    // 1 + 3 + 1 = 2 + 1, flip even\\n    // not gonna list all of them, but you got the idea:\\n    \\n    // for m >= 2, the possible states are 4\\n    if (n == 2 && m >= 2) return 4;\\n    \\n    // Say, n = 3, m = 1\\n    // flip all     =>      111 -> 000\\n    // flip odd     =>      111 -> 010\\n    // flip even    =>      111 -> 101\\n    // flip 3k + 1  =>      111 -> 011\\n    // could have 4 states, this is a general rule for all n > 2\\n    if (n > 2 && m == 1) return 4;\\n    \\n    // Say, n = 3, m = 2\\n    // 1 + 1                        111 -> 000 -> 111\\n    // 1 + 2 = 3, flip odd,         111 -> 000 -> 010\\n    // 1 + 3 = 2, flip even,        111 -> 000 -> 101\\n    // 1 + 4,                       111 -> 000 -> 100\\n    // 2 + 3 = 1, flip all,         111 -> 101 -> 000\\n    // 2 + 4                        111 -> 101 -> 001\\n    // 3 + 4                        111 -> 010 -> 110\\n    // could have 7 states, this is a general rule for all n > 2 and m = 2\\n    if (n > 2 && m == 2) return 7;\\n    \\n    // n = 3, m > 2\\n    // 1 + 2 + 4 = 3 + 4            111 -> 000 -> 010 -> 110\\n    // 1 + 3 + 4 = 2 + 4            111 -> 000 -> 101 -> 001\\n    // 1 + 4 + 1 = 4                111 -> 000 -> 100 -> 011\\n    // 2 + 4 + 1 = 3 + 4            111 -> 101 -> 001 -> 110\\n    // 3 + 4 + 1 = 2 + 4            111 -> 010 -> 110 -> 001\\n    // added one new possible state on top of m = 1, we got 8 states here\\n    // not gonna list all, but you got the idea:\\n    // for m > 2, we could simpify it to the base case m = 2\\n    // e.g. 1 + 4 + 2 + 3 \\n    //      => simpify 2 + 3 to 1           => 1 + 1 + 4\\n    //      => 1 + 1 is doing nothing       => 4\\n    if (n == 3 && m > 2) return 8;\\n    \\n    // for n > 3, m > 2 it is same as n = 3\\n    if (n > 3 && m > 2) return 8;\\n    \\n    // we can simplify the above findings to the follows but I would keep it to teach the future me\\n    if (n == 0 || m == 0) return 1;\\n    else if (n == 1) return 2;\\n    else if (n == 2 && m == 1) return 3;\\n    else if (m == 1) return 4;\\n    else if (m == 2) return 7;\\n    else return 8;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699368,
                "title": "python3-bit-manipulate-first-3-bits-bulb-switcher-ii",
                "content": "I am too lazy to calculate the result manually and I don\\'t want to copy others answer. So I let computer do it for me.\\nInspired by https://leetcode.com/problems/bulb-switcher-ii/discuss/107274/2-Line-Python-Recursive-With-Explanation\\n```\\nclass Solution:\\n    # Operations: O(flip odds), E(flip evens), A(flip all), T(flip 3k + 1), N(flip nothing)\\n    states = {\\n        \\'N\\': 0b000,\\n        \\'A\\': 0b111,\\n        \\'O\\': 0b101,\\n        \\'E\\': 0b010,\\n        \\'T\\': 0b001,\\n        \\'AT\\': 0b111 ^ 0b001,\\n        \\'OT\\': 0b101 ^ 0b001,\\n        \\'ET\\': 0b010 ^ 0b001,\\n    }\\n    steps = {\\n        0: [\\'N\\'],\\n        1: [\\'A\\', \\'O\\', \\'E\\', \\'T\\'],\\n        2: [\\'N\\', \\'A\\', \\'O\\', \\'E\\', \\'AT\\', \\'OT\\', \\'ET\\'],\\n        3: states.keys(),\\n    }\\n    def flipLights(self, n: int, m: int) -> int:\\n        n, m = min(n, 3), min(m, 3)\\n        mask = (1 << n) - 1\\n        ans = set()\\n        for s in self.steps[m]:\\n            ans.add((0b111 ^ self.states[s]) & mask)\\n        return len(ans) \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    # Operations: O(flip odds), E(flip evens), A(flip all), T(flip 3k + 1), N(flip nothing)\\n    states = {\\n        \\'N\\': 0b000,\\n        \\'A\\': 0b111,\\n        \\'O\\': 0b101,\\n        \\'E\\': 0b010,\\n        \\'T\\': 0b001,\\n        \\'AT\\': 0b111 ^ 0b001,\\n        \\'OT\\': 0b101 ^ 0b001,\\n        \\'ET\\': 0b010 ^ 0b001,\\n    }\\n    steps = {\\n        0: [\\'N\\'],\\n        1: [\\'A\\', \\'O\\', \\'E\\', \\'T\\'],\\n        2: [\\'N\\', \\'A\\', \\'O\\', \\'E\\', \\'AT\\', \\'OT\\', \\'ET\\'],\\n        3: states.keys(),\\n    }\\n    def flipLights(self, n: int, m: int) -> int:\\n        n, m = min(n, 3), min(m, 3)\\n        mask = (1 << n) - 1\\n        ans = set()\\n        for s in self.steps[m]:\\n            ans.add((0b111 ^ self.states[s]) & mask)\\n        return len(ans) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 663670,
                "title": "java-sol",
                "content": "Idea: only look at the first 3 balls, once we know the state of the first 3, we can know the rest\\n```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0)return 1;\\n        if(m==1){\\n            if(n==1)return 2;\\n            if(n==2)return 3;\\n            return 4;\\n        }\\n        if(m==2){\\n            if(n==1)return 2;\\n            if(n==2)return 4;\\n            return 7;\\n        }\\n        if(m>=3){\\n            if(n==1)return 2;\\n            if(n==2)return 4;\\n            return 8;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if(m==0)return 1;\\n        if(m==1){\\n            if(n==1)return 2;\\n            if(n==2)return 3;\\n            return 4;\\n        }\\n        if(m==2){\\n            if(n==1)return 2;\\n            if(n==2)return 4;\\n            return 7;\\n        }\\n        if(m>=3){\\n            if(n==1)return 2;\\n            if(n==2)return 4;\\n            return 8;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774929,
                "title": "dfs-memoization-bit-manipulation-java",
                "content": "# Code\\n```\\nclass Solution {\\n    private final Map<List<Integer>, Set<Integer>> memo = new HashMap<>();\\n    public int flipLights(int n, int presses) {\\n        int initialState = ((int) Math.pow(2, n)) - 1;\\n        List<Function<Integer, Integer>> buttons = initOperations(n);\\n        Set<Integer> states = new HashSet<>();\\n        dfs(initialState, presses, buttons, states);\\n        return states.size();\\n    }\\n\\n    private Set<Integer> dfs(int state, int presses, List<Function<Integer, Integer>> buttons, Set<Integer> states) {\\n        List<Integer> key = List.of(state, presses);\\n        if(memo.containsKey(key)) return memo.get(key);\\n        if(presses == 0) {\\n            states.add(state);\\n            memo.put(key, states);\\n            return states;\\n        }\\n        Set<Integer> uniqueStates = new HashSet<>();\\n        Set<Integer> newStates = new HashSet<>(states);\\n        for (Function<Integer, Integer> button: buttons) uniqueStates.add(button.apply(state));\\n        for(Integer newState: uniqueStates) newStates.addAll(dfs(newState, presses - 1, buttons, states));\\n        memo.put(key, newStates);\\n        return newStates;\\n    }\\n\\n    private List<Function<Integer, Integer>> initOperations(int n) {\\n        List<Function<Integer, Integer>> buttons = new ArrayList<>();\\n        int mask = (1 << n) - 1;\\n        buttons.add(i-> flipBits(i, mask));\\n        buttons.add(i-> flipOddBits(i, mask));\\n        buttons.add(i-> flipEvenBits(i, mask));\\n        buttons.add(i-> flipLabeledBits(i, mask));\\n        return buttons;\\n    }\\n\\n    private int flipBits(int state, int mask) { return (~state) & mask; }\\n\\n    private int flipOddBits(int state, int mask) { return (state ^ 0x55555555) & mask; }\\n\\n    private int flipEvenBits(int state, int mask) { return (state ^ 0xAAAAAAA) & mask; }\\n\\n    private int flipLabeledBits(int state, int mask) { return (state ^ 0x1249249) & mask; }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private final Map<List<Integer>, Set<Integer>> memo = new HashMap<>();\\n    public int flipLights(int n, int presses) {\\n        int initialState = ((int) Math.pow(2, n)) - 1;\\n        List<Function<Integer, Integer>> buttons = initOperations(n);\\n        Set<Integer> states = new HashSet<>();\\n        dfs(initialState, presses, buttons, states);\\n        return states.size();\\n    }\\n\\n    private Set<Integer> dfs(int state, int presses, List<Function<Integer, Integer>> buttons, Set<Integer> states) {\\n        List<Integer> key = List.of(state, presses);\\n        if(memo.containsKey(key)) return memo.get(key);\\n        if(presses == 0) {\\n            states.add(state);\\n            memo.put(key, states);\\n            return states;\\n        }\\n        Set<Integer> uniqueStates = new HashSet<>();\\n        Set<Integer> newStates = new HashSet<>(states);\\n        for (Function<Integer, Integer> button: buttons) uniqueStates.add(button.apply(state));\\n        for(Integer newState: uniqueStates) newStates.addAll(dfs(newState, presses - 1, buttons, states));\\n        memo.put(key, newStates);\\n        return newStates;\\n    }\\n\\n    private List<Function<Integer, Integer>> initOperations(int n) {\\n        List<Function<Integer, Integer>> buttons = new ArrayList<>();\\n        int mask = (1 << n) - 1;\\n        buttons.add(i-> flipBits(i, mask));\\n        buttons.add(i-> flipOddBits(i, mask));\\n        buttons.add(i-> flipEvenBits(i, mask));\\n        buttons.add(i-> flipLabeledBits(i, mask));\\n        return buttons;\\n    }\\n\\n    private int flipBits(int state, int mask) { return (~state) & mask; }\\n\\n    private int flipOddBits(int state, int mask) { return (state ^ 0x55555555) & mask; }\\n\\n    private int flipEvenBits(int state, int mask) { return (state ^ 0xAAAAAAA) & mask; }\\n\\n    private int flipLabeledBits(int state, int mask) { return (state ^ 0x1249249) & mask; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426981,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int flipLights(int n, int m) {\\n    n = min(n, 3);\\n    if (m == 0)\\n      return 1;\\n    if (m == 1)\\n      return vector{2, 3, 4}[n - 1];\\n    if (m == 2)\\n      return vector{2, 4, 7}[n - 1];\\n    return pow(2, n);\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n  def flipLights(self, n: int, m: int) -> int:\\n    n = min(n, 3)\\n\\n    if m == 0:\\n      return 1\\n    if m == 1:\\n      return [2, 3, 4][n - 1]\\n    if m == 2:\\n      return [2, 4, 7][n - 1]\\n\\n    return [2, 4, 8][n - 1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] mapForLessThan3 = new int[]{1,3,4};\\n        int[] mapForMoreThan2 = new int[]{1,4,7,8};\\n        if(n<3)\\n            return Math.min(1<<n,mapForLessThan3[Math.min(presses,2)]);            \\n        return mapForMoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int flipLights(int n, int m) {\\n    n = min(n, 3);\\n    if (m == 0)\\n      return 1;\\n    if (m == 1)\\n      return vector{2, 3, 4}[n - 1];\\n    if (m == 2)\\n      return vector{2, 4, 7}[n - 1];\\n    return pow(2, n);\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n  def flipLights(self, n: int, m: int) -> int:\\n    n = min(n, 3)\\n\\n    if m == 0:\\n      return 1\\n    if m == 1:\\n      return [2, 3, 4][n - 1]\\n    if m == 2:\\n      return [2, 4, 7][n - 1]\\n\\n    return [2, 4, 8][n - 1]\\n```\n```Java []\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] mapForLessThan3 = new int[]{1,3,4};\\n        int[] mapForMoreThan2 = new int[]{1,4,7,8};\\n        if(n<3)\\n            return Math.min(1<<n,mapForLessThan3[Math.min(presses,2)]);            \\n        return mapForMoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052235,
                "title": "python-sol-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem is to first check the base cases where n is 0 or presses is 0, and then to check for the different cases where n is 1, 2, or greater than 2 and presses is 1, 2, or greater than 2. Based on these cases, I can return the appropriate number of unique states that can be achieved by flipping the lights.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use if-else statements to check for the different cases of n and presses, and then return the appropriate number of unique states based on the cases.\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if n == 0 or presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if presses == 1:\\n                return 3\\n            else:\\n                return 4\\n        if presses == 1:\\n            return 4\\n        if presses == 2:\\n            return 7\\n        return 8\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if n == 0 or presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if presses == 1:\\n                return 3\\n            else:\\n                return 4\\n        if presses == 1:\\n            return 4\\n        if presses == 2:\\n            return 7\\n        return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584778,
                "title": "bulb-switcher-ii-very-easy-java-sol-with-proper-explanation",
                "content": "When any of p and n is 0, return 1\\nWhen p = 1:\\n        n = 1, the light has two states: on or off, so the answer is 2;\\n        n = 2, the light has 3 states: 00, 01, 10, so the answer is 3;\\n        n = 3, the light has 4 states: 000, 101, 010, 011, so the answer is 4;\\n        n = 4, the light has 4 states: 0000, 1010, 0101, 0110, so the answer is 4;\\n        Combining n = 3, n = 4, when n > 3, the answer is both 4.\\n\\nWhen p = 2:\\n        n = 1, the light has two states: on or off, so the answer is 2;\\n        n = 2, the light has 4 states: 11, 01, 10, 00, so the answer is 4;\\n        n = 3, the lamp has 7 states: 111, 101.010, 100, 000, 001, 110, so the answer is 7;\\n        Ditto, when n > 3, the answer is both 7.\\n\\n\\nWhen p = 3:\\n        n = 1, the light has two states: on or off, so the answer is 2;\\n        n = 2, the light has 4 states: 00, 01, 10, 11, so the answer is 4;\\n        n = 3, the light has 8 states: 111, 101.010, 100, 000, 001, 110, 011, so the answer is 8;\\n        Ditto, when n > 3, the answer is both 8.\\n\\nWhen p > 3, the answer should be the same as p = 3.\\n\\n\\n\\n```\\nclass Solution {\\n    public int flipLights(int n, int p) {\\n        if (p == 0){\\n            return 1;\\n        }\\n            if(p==1){\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 3;\\n                }\\n                else{\\n                    return 4;\\n                }\\n            }\\n        \\n        if(p==2){\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 4;\\n                }\\n                else{\\n                    return 7;\\n                }\\n            }\\n        \\n        else{\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 4;\\n                }\\n                else{\\n                    return 8;\\n                }\\n            }       \\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int p) {\\n        if (p == 0){\\n            return 1;\\n        }\\n            if(p==1){\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 3;\\n                }\\n                else{\\n                    return 4;\\n                }\\n            }\\n        \\n        if(p==2){\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 4;\\n                }\\n                else{\\n                    return 7;\\n                }\\n            }\\n        \\n        else{\\n                if(n==1){\\n                    return 2;\\n                }\\n                if(n==2){\\n                    return 4;\\n                }\\n                else{\\n                    return 8;\\n                }\\n            }       \\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172426,
                "title": "c-simple-approach-understanding-the-states",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k==0)\\n        return 1;\\n        \\n        if(n==1)\\n        return 2;\\n        if(n==2)\\n        {\\n            if(k==1)\\n            {\\n                return 3;\\n            }\\n            else\\n            {\\n                return 4;\\n            }\\n        }\\n        else\\n        {\\n            if(k==1)\\n            {\\n                return 4;\\n            }\\n            else if(k==2)\\n            {\\n                return 7;\\n            }\\n            else\\n            {\\n                return 8;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k==0)\\n        return 1;\\n        \\n        if(n==1)\\n        return 2;\\n        if(n==2)\\n        {\\n            if(k==1)\\n            {\\n                return 3;\\n            }\\n            else\\n            {\\n                return 4;\\n            }\\n        }\\n        else\\n        {\\n            if(k==1)\\n            {\\n                return 4;\\n            }\\n            else if(k==2)\\n            {\\n                return 7;\\n            }\\n            else\\n            {\\n                return 8;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909669,
                "title": "java-brute-force-with-optimization-then-o-1-solution",
                "content": "Here\\'s the matrix for all the possibilities of answers. \\n\\n```plain\\n       1  2  3  4 presses\\n1      2, 2, 2, 2\\n2      3, 4, 4, 4\\n3      4, 7, 8, 8\\n4      4, 7, 8, 8\\nlights\\n\\n* 0 press = 1\\n* for presses more than 4, if presses % 2 == 1 check 3 presses, otherwise 4 presses\\n```\\n\\nThere are countless ways to hard-code this matrix, but it is more important to know where these numbers come from.\\n\\nFirst is the brute-force solution. It takes about 1 second. The code uses a string to represent the lights and then switches the light with 4 buttons. Using a set to remove duplicated patterns.\\n\\n```java\\nint flipLights(int n, int presses) {\\n    Set<String> set = new HashSet<>();\\n    StringBuilder builder = new StringBuilder();\\n    for (int i = 0; i < n; i++) {\\n        builder.append(\\'1\\');\\n    }\\n    set.add(builder.toString());\\n    for (int t = 0; t < presses; t++) {\\n        Set<String> newSet = new HashSet<>();\\n        for (String s : set) {\\n            // button 1\\n            char[] cs = s.toCharArray();\\n            for (int i = 0; i < length; i++) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 2\\n            cs = s.toCharArray();\\n            for (int i = 0; i < length; i += 2) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 3\\n            cs = s.toCharArray();\\n            for (int i = 1; i < length; i += 2) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 4\\n            cs = s.toCharArray();\\n            for (int i = 0; i < length; i += 3) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n        }\\n        set = newSet;\\n    }\\n    return set.size();\\n}\\n```\\n\\nA quick optimization to reduce the time is to check how many lights we need to care about. There are 4 buttons, each button flips different lights. \\n\\n```plain\\nlight 1 button 1, 3, 4\\nlight 2 button 1, 2\\nlight 3 button 1, 3\\nlight 4 button 1, 2, 4\\nlight 5 button 1, 3\\nlight 6 button 1, 2\\nlight 7 button 1, 3, 4\\n...\\n```\\n\\nWhat we can see here is the first 4 lights have all the combinations of buttons. We can use these 4 lights as the sample to check all the patterns. \\n\\n```java\\nint flipLights(int n, int times) {\\n    n = Math.min(n, 4);\\n\\t// ...\\n}\\n```\\n\\nThis optimization gives me a solution with 55ms. It could be better, because 4 lights can be represented with a byte with 8 bits and you can flip the bit with xor bitwise operation.\\n\\nOn the other hand, there should be some way to reduce the presses as well. \\n\\nIf we think of the status of each light, **its final status depends on the count of operations to the light**. For example, 3 times means off, 4 times means on. If the count is an odd, the light is off, otherwise on.\\n\\nThis theory gives me an idea that **the order of the operations doesn\\'t matter** here since you only need to count the operations.\\n\\nAnother observation is **if the same button is pressed twice, the result doesn\\'t change**. Adding an even number to an odd number is still an odd number.\\n\\nWith these two observations, when considering the final status, the count of pressing each button could be simplified to\\n\\n* button 1: 0 times or once\\n* button 2: 0 times or once\\n* button 3: 0 times or once\\n* button 4: 0 times or once\\n\\nany even number becomes 0, any odd number becomes 1 here. In other words, **presses more than 4 can always be reduced to 4 or less**. \\n\\nThis is a big step but we need to think carefully about the button combinations here.\\n\\n```plain\\npresses\\n1: \\nunique buttons: {1}, {2}, {3}, {4}\\n\\n2: \\npress button x twice: {}\\nunique buttons: {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}\\n\\n3: \\npress button x twice: {1}, {2}, {3}, {4}\\nunique buttons: {1, 2, 3}, {1, 2, 4}, {1, 3, 4}, {2, 3, 4}\\n\\n4: \\npress button x 4 times: {}\\npress button x twice: {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}\\nunique buttons: {1, 2, 3, 4}\\n\\n5: same as 3\\n6: same as 4\\n7: same as 3\\n...\\n```\\n\\nSome people would continue to find the patterns to reduce the combinations, I think it is good enough since we have only 4 cases here.\\n\\nThe code to calculate the patterns. This time I also add bit manipulation to do the flipping.\\n\\n```java\\npublic int flipLights(int n, int presses) {\\n    if (presses == 0) return 1;\\n\\n    int maxPresses = presses;\\n    if (presses > 4) {\\n        maxPresses = (presses % 2 == 1 ? 3 : 4);\\n    }\\n    return countPatterns(Math.min(n, 4), maxPresses);\\n}\\n\\nint countPatterns(int lights, int maxPresses) {\\n    if (maxPresses == 1) {\\n        return countPatterns(lights, Arrays.asList(Collections.singletonList(1), Collections.singletonList(2),\\n                Collections.singletonList(3), Collections.singletonList(4)));\\n    }\\n    if (maxPresses == 2) {\\n        return countPatterns(lights, Arrays.asList(Collections.emptyList(), Arrays.asList(1, 2), Arrays.asList(1, 3),\\n                Arrays.asList(1, 4), Arrays.asList(2, 3), Arrays.asList(2, 4), Arrays.asList(3, 4)));\\n    }\\n    if (maxPresses == 3) {\\n        return countPatterns(lights, Arrays.asList(Collections.singletonList(1), Collections.singletonList(2),\\n                Collections.singletonList(3), Collections.singletonList(4),\\n                Arrays.asList(1, 2, 3), Arrays.asList(1, 2, 4), Arrays.asList(1, 3, 4), Arrays.asList(2, 3, 4)));\\n    }\\n    // 4\\n    return countPatterns(lights, Arrays.asList(Collections.emptyList(), Arrays.asList(1, 2), Arrays.asList(1, 3),\\n            Arrays.asList(1, 4), Arrays.asList(2, 3), Arrays.asList(2, 4), Arrays.asList(3, 4), Arrays.asList(1, 2, 3, 4)));\\n}\\n\\nint countPatterns(int lights, List<List<Integer>> combinations) {\\n    int base = (1 << lights) - 1;\\n    Set<Integer> patterns = new HashSet<>();\\n    for (List<Integer> instructions : combinations) {\\n        patterns.addAll(pressButtons(base, instructions));\\n    }\\n    return patterns.size();\\n}\\n\\nprivate Set<Integer> pressButtons(int base, List<Integer> instructions) {\\n    Set<Integer> prev = new HashSet<>();\\n    prev.add(base);\\n    for (Integer button : instructions) {\\n        Set<Integer> next = new HashSet<>();\\n        for (Integer n : prev) {\\n            if (button == 1) {\\n\\t\\t\\t    // if we have only 3 lights, we need 0b111 here so using base as the mask\\n                next.add(n ^ (base & 0b1111));\\n            } else if (button == 2) {\\n                next.add(n ^ (base & 0b0101));\\n            } else if (button == 3) {\\n                next.add(n ^ (base & 0b1010));\\n            } else { // 4\\n                next.add(n ^ (base & 0b1001));\\n            }\\n        }\\n        prev = next;\\n    }\\n    return prev;\\n}\\n```\\n\\nThis solution only takes 5ms. In principal we don\\'t need to do optimization any more. If you want to use some hard-coded answers, do a simple 4x4 loop to generate the matrix at the first of this post.\\n\\nHope this post helps.",
                "solutionTags": [],
                "code": "```plain\\n       1  2  3  4 presses\\n1      2, 2, 2, 2\\n2      3, 4, 4, 4\\n3      4, 7, 8, 8\\n4      4, 7, 8, 8\\nlights\\n\\n* 0 press = 1\\n* for presses more than 4, if presses % 2 == 1 check 3 presses, otherwise 4 presses\\n```\n```java\\nint flipLights(int n, int presses) {\\n    Set<String> set = new HashSet<>();\\n    StringBuilder builder = new StringBuilder();\\n    for (int i = 0; i < n; i++) {\\n        builder.append(\\'1\\');\\n    }\\n    set.add(builder.toString());\\n    for (int t = 0; t < presses; t++) {\\n        Set<String> newSet = new HashSet<>();\\n        for (String s : set) {\\n            // button 1\\n            char[] cs = s.toCharArray();\\n            for (int i = 0; i < length; i++) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 2\\n            cs = s.toCharArray();\\n            for (int i = 0; i < length; i += 2) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 3\\n            cs = s.toCharArray();\\n            for (int i = 1; i < length; i += 2) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n\\n            // button 4\\n            cs = s.toCharArray();\\n            for (int i = 0; i < length; i += 3) {\\n                cs[i] = (cs[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            newSet.add(new String(cs));\\n        }\\n        set = newSet;\\n    }\\n    return set.size();\\n}\\n```\n```plain\\nlight 1 button 1, 3, 4\\nlight 2 button 1, 2\\nlight 3 button 1, 3\\nlight 4 button 1, 2, 4\\nlight 5 button 1, 3\\nlight 6 button 1, 2\\nlight 7 button 1, 3, 4\\n...\\n```\n```java\\nint flipLights(int n, int times) {\\n    n = Math.min(n, 4);\\n\\t// ...\\n}\\n```\n```plain\\npresses\\n1: \\nunique buttons: {1}, {2}, {3}, {4}\\n\\n2: \\npress button x twice: {}\\nunique buttons: {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}\\n\\n3: \\npress button x twice: {1}, {2}, {3}, {4}\\nunique buttons: {1, 2, 3}, {1, 2, 4}, {1, 3, 4}, {2, 3, 4}\\n\\n4: \\npress button x 4 times: {}\\npress button x twice: {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}\\nunique buttons: {1, 2, 3, 4}\\n\\n5: same as 3\\n6: same as 4\\n7: same as 3\\n...\\n```\n```java\\npublic int flipLights(int n, int presses) {\\n    if (presses == 0) return 1;\\n\\n    int maxPresses = presses;\\n    if (presses > 4) {\\n        maxPresses = (presses % 2 == 1 ? 3 : 4);\\n    }\\n    return countPatterns(Math.min(n, 4), maxPresses);\\n}\\n\\nint countPatterns(int lights, int maxPresses) {\\n    if (maxPresses == 1) {\\n        return countPatterns(lights, Arrays.asList(Collections.singletonList(1), Collections.singletonList(2),\\n                Collections.singletonList(3), Collections.singletonList(4)));\\n    }\\n    if (maxPresses == 2) {\\n        return countPatterns(lights, Arrays.asList(Collections.emptyList(), Arrays.asList(1, 2), Arrays.asList(1, 3),\\n                Arrays.asList(1, 4), Arrays.asList(2, 3), Arrays.asList(2, 4), Arrays.asList(3, 4)));\\n    }\\n    if (maxPresses == 3) {\\n        return countPatterns(lights, Arrays.asList(Collections.singletonList(1), Collections.singletonList(2),\\n                Collections.singletonList(3), Collections.singletonList(4),\\n                Arrays.asList(1, 2, 3), Arrays.asList(1, 2, 4), Arrays.asList(1, 3, 4), Arrays.asList(2, 3, 4)));\\n    }\\n    // 4\\n    return countPatterns(lights, Arrays.asList(Collections.emptyList(), Arrays.asList(1, 2), Arrays.asList(1, 3),\\n            Arrays.asList(1, 4), Arrays.asList(2, 3), Arrays.asList(2, 4), Arrays.asList(3, 4), Arrays.asList(1, 2, 3, 4)));\\n}\\n\\nint countPatterns(int lights, List<List<Integer>> combinations) {\\n    int base = (1 << lights) - 1;\\n    Set<Integer> patterns = new HashSet<>();\\n    for (List<Integer> instructions : combinations) {\\n        patterns.addAll(pressButtons(base, instructions));\\n    }\\n    return patterns.size();\\n}\\n\\nprivate Set<Integer> pressButtons(int base, List<Integer> instructions) {\\n    Set<Integer> prev = new HashSet<>();\\n    prev.add(base);\\n    for (Integer button : instructions) {\\n        Set<Integer> next = new HashSet<>();\\n        for (Integer n : prev) {\\n            if (button == 1) {\\n\\t\\t\\t    // if we have only 3 lights, we need 0b111 here so using base as the mask\\n                next.add(n ^ (base & 0b1111));\\n            } else if (button == 2) {\\n                next.add(n ^ (base & 0b0101));\\n            } else if (button == 3) {\\n                next.add(n ^ (base & 0b1010));\\n            } else { // 4\\n                next.add(n ^ (base & 0b1001));\\n            }\\n        }\\n        prev = next;\\n    }\\n    return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554733,
                "title": "c-bfs-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string rec( string temp , int k ){\\n        \\n        for( int i = 0 ; k == 1 && i < temp.length() ; i++ ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1;}\\n        }\\n        \\n        for( int i = 0 ; k == 2 && i < temp.length(); i += 2 ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1 ; }\\n        }\\n\\n        for( int i = 1 ; k == 3 && i < temp.length() ; i += 2 ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1 ; }\\n        }\\n\\n        for( int i =0 ; k == 4 && 3*i < temp.length() ; i++ ){\\n            if( temp[3*i] ){ temp[3*i] = 0; }\\n            else{ temp[3*i] = 1 ; }\\n        }\\n \\n        return temp;\\n    }\\n    \\n    int flipLights(int n, int presses) {\\n        string r(n,1);\\n        unordered_map<string,int> umap;\\n        queue<string> q;\\n        q.push(r);\\n        int depth = 0;\\n        int prev_size = 0;\\n        while( depth < presses  ){\\n            int size = q.size();\\n            umap.clear();\\n            while( size-- ){\\n                string s = q.front(); q.pop();\\n                for( int k = 1 ; k <= 4 ; k++ ){\\n                    string a = rec(s , k );\\n                    umap[a] = 1;\\n                    q.push(a);\\n                }\\n            }\\n            if( umap.size() == prev_size ){\\n                break;\\n            }\\n            prev_size = umap.size();\\n            \\n            depth++;\\n               \\n        }\\n        \\n        \\n        \\n        return umap.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string rec( string temp , int k ){\\n        \\n        for( int i = 0 ; k == 1 && i < temp.length() ; i++ ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1;}\\n        }\\n        \\n        for( int i = 0 ; k == 2 && i < temp.length(); i += 2 ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1 ; }\\n        }\\n\\n        for( int i = 1 ; k == 3 && i < temp.length() ; i += 2 ){\\n            if( temp[i] ){ temp[i] = 0; }\\n            else{ temp[i] = 1 ; }\\n        }\\n\\n        for( int i =0 ; k == 4 && 3*i < temp.length() ; i++ ){\\n            if( temp[3*i] ){ temp[3*i] = 0; }\\n            else{ temp[3*i] = 1 ; }\\n        }\\n \\n        return temp;\\n    }\\n    \\n    int flipLights(int n, int presses) {\\n        string r(n,1);\\n        unordered_map<string,int> umap;\\n        queue<string> q;\\n        q.push(r);\\n        int depth = 0;\\n        int prev_size = 0;\\n        while( depth < presses  ){\\n            int size = q.size();\\n            umap.clear();\\n            while( size-- ){\\n                string s = q.front(); q.pop();\\n                for( int k = 1 ; k <= 4 ; k++ ){\\n                    string a = rec(s , k );\\n                    umap[a] = 1;\\n                    q.push(a);\\n                }\\n            }\\n            if( umap.size() == prev_size ){\\n                break;\\n            }\\n            prev_size = umap.size();\\n            \\n            depth++;\\n               \\n        }\\n        \\n        \\n        \\n        return umap.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535818,
                "title": "python-3-math-o-1",
                "content": "- There are total 8 different status maximum\\n- Give some test case and play around, you will find the pattern for smaller inputs\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if not presses: \\n            return 1\\n        elif n < 3:\\n            if n == 1: \\n                return 2\\n            elif presses >= 2:\\n                return 4\\n            else:\\n                return 3\\n        else:\\n            if presses >= 3: \\n                return 8\\n            elif presses == 2:\\n                return 7\\n            else:\\n                return 4\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if not presses: \\n            return 1\\n        elif n < 3:\\n            if n == 1: \\n                return 2\\n            elif presses >= 2:\\n                return 4\\n            else:\\n                return 3\\n        else:\\n            if presses >= 3: \\n                return 8\\n            elif presses == 2:\\n                return 7\\n            else:\\n                return 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420284,
                "title": "c-faster-than-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if(p==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return p==1?3:4;\\n        else return p==1?4:p==2?7:8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if(p==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return p==1?3:4;\\n        else return p==1?4:p==2?7:8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069221,
                "title": "hard-coded-python-with-picture",
                "content": "![image](https://assets.leetcode.com/users/images/c0886d27-c976-40a0-b01d-d5769caec17c_1613532414.2023501.png)\\n\\n```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        if m == 0:\\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if m<2 else 4\\n        \\n        else:\\n            if m==1:\\n                return 4\\n            if m==2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        if m == 0:\\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if m<2 else 4\\n        \\n        else:\\n            if m==1:\\n                return 4\\n            if m==2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828794,
                "title": "golang-o-1-0ms-solution-with-explanation",
                "content": "```go\\nfunc flipLights(n int, m int) int {\\n    // state1: all on\\n    // state2: all off\\n    // state3: even on odd off\\n    // state4: even off odd on\\n    // state5: 3k + 1 on others off\\n    // state6: 3k + 1 off others on\\n    // state7: even on odd off and press button4 once\\n    // state8: even off odd on and press button4 once\\n    if m == 0 || n == 0 {\\n        return 1\\n    }\\n    switch n {\\n    case 1:\\n        // only two status on or off\\n        return 2\\n    case 2:\\n        // button3 & button4 are the same\\n        if m == 1 {\\n            // state 2,3,4\\n            return 3\\n        }\\n        // state 1,2,3,4\\n        return 4\\n    }\\n    // n \\u2265 3 here\\n    switch m {\\n    case 1:\\n        // state 2,3,4,6\\n        return 4\\n    case 2:\\n        // state 1,2,3,4,5,7,8\\n        return 7\\n    }\\n    return 8\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc flipLights(n int, m int) int {\\n    // state1: all on\\n    // state2: all off\\n    // state3: even on odd off\\n    // state4: even off odd on\\n    // state5: 3k + 1 on others off\\n    // state6: 3k + 1 off others on\\n    // state7: even on odd off and press button4 once\\n    // state8: even off odd on and press button4 once\\n    if m == 0 || n == 0 {\\n        return 1\\n    }\\n    switch n {\\n    case 1:\\n        // only two status on or off\\n        return 2\\n    case 2:\\n        // button3 & button4 are the same\\n        if m == 1 {\\n            // state 2,3,4\\n            return 3\\n        }\\n        // state 1,2,3,4\\n        return 4\\n    }\\n    // n \\u2265 3 here\\n    switch m {\\n    case 1:\\n        // state 2,3,4,6\\n        return 4\\n    case 2:\\n        // state 1,2,3,4,5,7,8\\n        return 7\\n    }\\n    return 8\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812466,
                "title": "solution-without-enumerating-each-case-generalized-for-this-kind-of-question",
                "content": "At the first glance, the question seems to be quite trivial since for n larger than some number, the answer will be fixed.\\n\\nBut since the question is about dividing something into several groups and do operation for some of these groups. We can generalize it into XOR operation to a initial number.\\n\\nThe detail is:\\n1. We group these bulbs into four groups which can only be changed by operation 2 or 3, or 2,4 or 3,4.\\n2. For each group, we define the initial state as 1 and store it in a set, so the initial state is \\'1111\\' which is 15\\n3. For each operation, we changes state by XOR the current state with a number corresponding to that operation. For example, the operation 2 which flip the even number bulbs can be expressed as \\'1010\\' which means to change the group1 and group3.\\n4. Get all possibilities of the next step and save it as current state.\\n\\n```python\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        if n==0:\\n            return 0\\n        \\n        ops = [15, 10, 5, 3]\\n        status = set([15])\\n        count = 0\\n        while count<m and len(status)<16:\\n            nstatus = set()\\n            for s in status:\\n                for op in ops:\\n                    nstatus.add(s^op)\\n            status = nstatus\\n            count+=1\\n        \\n\\t\\t# focus on the last n bits of the current status\\n        status = set([bin(s)[2:].rjust(4,\\'0\\')[-n:] for s in status])\\n        \\n        return len(status)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        if n==0:\\n            return 0\\n        \\n        ops = [15, 10, 5, 3]\\n        status = set([15])\\n        count = 0\\n        while count<m and len(status)<16:\\n            nstatus = set()\\n            for s in status:\\n                for op in ops:\\n                    nstatus.add(s^op)\\n            status = nstatus\\n            count+=1\\n        \\n\\t\\t# focus on the last n bits of the current status\\n        status = set([bin(s)[2:].rjust(4,\\'0\\')[-n:] for s in status])\\n        \\n        return len(status)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774709,
                "title": "c-with-comments-on-each-base-case",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if ((m == 0) || (n == 0)) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2; // even => noop\\n        }\\n        if (m == 1) {\\n            // n = 2\\n            // |-> 01, 10, 11\\n            // n > 2\\n            // |-> 101, 010, 111, 100\\n            return 3 + (n >= 3);\\n        }\\n        if (n == 2) {\\n            // 10  odd or 3k+1\\n            // 01  even\\n            // 11  full or (even + odd)\\n            // 00  two identical ops\\n            return 3 + (m >= 2);\\n        }\\n        // n >= 3, m >= 2\\n        // |-> 010, 101, 111 \\n        // |-> 000 (two identical ops)\\n        // |-> 110, 011 (combined with 3k+1)\\n        // 100 cannot be done with 2 ops\\n        return 7 + (m >= 3);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if ((m == 0) || (n == 0)) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2; // even => noop\\n        }\\n        if (m == 1) {\\n            // n = 2\\n            // |-> 01, 10, 11\\n            // n > 2\\n            // |-> 101, 010, 111, 100\\n            return 3 + (n >= 3);\\n        }\\n        if (n == 2) {\\n            // 10  odd or 3k+1\\n            // 01  even\\n            // 11  full or (even + odd)\\n            // 00  two identical ops\\n            return 3 + (m >= 2);\\n        }\\n        // n >= 3, m >= 2\\n        // |-> 010, 101, 111 \\n        // |-> 000 (two identical ops)\\n        // |-> 110, 011 (combined with 3k+1)\\n        // 100 cannot be done with 2 ops\\n        return 7 + (m >= 3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491184,
                "title": "python3-find-regular-parttern",
                "content": "```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        n = min(n, 3)\\n        return min(1<<n, 1+m*n)\\n        # Test cases one by one, u can find the regular pattern\\n        # n > 2, m = 1, res = 4; m = 2, res => 7; m >= 3 res = 8.\\n        # n = 2, m = 1, res = 3; m >= 2, res = 4.\\n        # n = 1, m >= 1, re = 2.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        n = min(n, 3)\\n        return min(1<<n, 1+m*n)\\n        # Test cases one by one, u can find the regular pattern\\n        # n > 2, m = 1, res = 4; m = 2, res => 7; m >= 3 res = 8.\\n        # n = 2, m = 1, res = 3; m >= 2, res = 4.\\n        # n = 1, m >= 1, re = 2.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480133,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\n public:\\n  int flipLights(int n, int m) {\\n    if (n == 0) return 0;\\n    if (n >= 1 && m == 0) return 1;\\n    if (n == 1)\\n      return 2;\\n    else if (n == 2 && m == 1)\\n      return 3;\\n    else if (n == 2 && m > 1)\\n      return 4;\\n    else if (n >= 3 && m == 1)\\n      return 4;\\n    else if (n >= 3 && m == 2)\\n      return 7;\\n    else\\n      return 8;\\n  }\\n};\\n```\\n### The idea is :\\n* Every even Flips will cancel each other out\\n* Every Flips 1 = Flips 2 + Flips 3\\n* When n < 3  Flips 3 = Flips 4  \\n### So there are only 8 condition:\\n* even Flips 4\\n* even Flips 4 + Flips 1\\n* even Flips 4 + Flips 2\\n* even Flips 4 + Flips 3\\n* odd Flips 4\\n* odd Flips 4 + Flips 1\\n* odd Flips 4 + Flips 2\\n* odd Flips 4 + Flips 3\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int flipLights(int n, int m) {\\n    if (n == 0) return 0;\\n    if (n >= 1 && m == 0) return 1;\\n    if (n == 1)\\n      return 2;\\n    else if (n == 2 && m == 1)\\n      return 3;\\n    else if (n == 2 && m > 1)\\n      return 4;\\n    else if (n >= 3 && m == 1)\\n      return 4;\\n    else if (n >= 3 && m == 2)\\n      return 7;\\n    else\\n      return 8;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195396,
                "title": "c-o-1-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {        \\n        static const int t[4][4] = {\\n            {},\\n            {1, 2, 2, 2},\\n            {1, 3, 4, 4},\\n            {1, 4, 7, 8}\\n        };\\n        \\n        m = min(3, m);\\n        n = min(3, n);\\n        \\n        return t[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {        \\n        static const int t[4][4] = {\\n            {},\\n            {1, 2, 2, 2},\\n            {1, 3, 4, 4},\\n            {1, 4, 7, 8}\\n        };\\n        \\n        m = min(3, m);\\n        n = min(3, n);\\n        \\n        return t[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165143,
                "title": "c-bit-manipulation-solution-with-comments-somewhat-complex",
                "content": "```\\n    int flipLights(int n, int m) {\\n        \\n        // The bulb operations will always end up the same for each group of 4 bulbs\\n        // Therefore, we have a max of 2^4 possible states or less for smaller n\\n        \\n        int states;\\n        if (n > 3)\\n            states = pow(2, 4);\\n        else\\n            states = pow(2, n);\\n        \\n        // There are 4 possible flips, 15 = 1111, 10 = 1010, 5 = 0101, 1 = 0001\\n        int flips[4] = {15, 10, 5, 1};\\n        \\n        // Initially we have only one state possible out of 16 (for n > 3): 1000000000000000\\n        int lastStates = (1 << (states - 1)), newStates = 0;\\n        \\n        // Iterate through all bulb operations (I think this can be reduced so it doesn\\'t have to go to m)\\n        for (int i = 0; i != m; ++i, lastStates = newStates, newStates = 0)\\n            for (int j = 0; j != states; ++j)\\n                if ((lastStates & (1 << j)) == (1 << j))            // if state j was a possibility in the last iteration\\n                    for (int k = 0; k != 4; ++k)                    // perform each bulb operation and flag that the state is now possible\\n                        newStates  |= (1 << ((states - 1) & (j ^ flips[k])));\\n        \\n        // count up our bits/states\\n        int count = 0;\\n        for (int i = 0; i != states; count += (lastStates & (1 << i)) == (1 << i), ++i);\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int flipLights(int n, int m) {\\n        \\n        // The bulb operations will always end up the same for each group of 4 bulbs\\n        // Therefore, we have a max of 2^4 possible states or less for smaller n\\n        \\n        int states;\\n        if (n > 3)\\n            states = pow(2, 4);\\n        else\\n            states = pow(2, n);\\n        \\n        // There are 4 possible flips, 15 = 1111, 10 = 1010, 5 = 0101, 1 = 0001\\n        int flips[4] = {15, 10, 5, 1};\\n        \\n        // Initially we have only one state possible out of 16 (for n > 3): 1000000000000000\\n        int lastStates = (1 << (states - 1)), newStates = 0;\\n        \\n        // Iterate through all bulb operations (I think this can be reduced so it doesn\\'t have to go to m)\\n        for (int i = 0; i != m; ++i, lastStates = newStates, newStates = 0)\\n            for (int j = 0; j != states; ++j)\\n                if ((lastStates & (1 << j)) == (1 << j))            // if state j was a possibility in the last iteration\\n                    for (int k = 0; k != 4; ++k)                    // perform each bulb operation and flag that the state is now possible\\n                        newStates  |= (1 << ((states - 1) & (j ^ flips[k])));\\n        \\n        // count up our bits/states\\n        int count = 0;\\n        for (int i = 0; i != states; count += (lastStates & (1 << i)) == (1 << i), ++i);\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 157343,
                "title": "explained-literally-just-a-bunch-of-if-statements-because-math",
                "content": "So you start with the state 11111.... (n number of 1\\'s), m = 0\\nThen, there\\'s 4 possible states when m = 1\\n* 00000\\n* 10101\\n* 01010\\n* 01101\\n\\nAnd then, when m = 2, there\\'s 7 states:\\n* 11111\\n* 00000\\n* 10101\\n* 01010\\n* 10010\\n* 00111\\n* 11000\\n\\nAnd then you have 8 total states for the next one, and that wraps up all the states. (There can only be 8, because the sequence repeats itself every 3 numbers)\\n\\nThere you have it, ladies and gentleman.\\n\\n\\n```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        if m == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2 and m == 1:\\n            return 3\\n        if n == 2 and m > 1:\\n            return 4\\n        if m == 1:\\n            return 4\\n        if m == 2:\\n            return 7\\n        return 8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        if m == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2 and m == 1:\\n            return 3\\n        if n == 2 and m > 1:\\n            return 4\\n        if m == 1:\\n            return 4\\n        if m == 2:\\n            return 7\\n        return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107266,
                "title": "lazy-generalizable-o-1-python-solution-with-explanation",
                "content": "Operations:\\n\\n\\n1. toggle all\\n2. toggle even\\n3. toggle odd\\n4. toggle 1+3k\\n\\nSince each operation always toggles the same set of lights, each operation cancels itself out when applied twice (or an even number of times). Thus we can consider each operation to be like a state, which can be \"ON\" or \"OFF\".  There are 4 individual \"operation states\", which combined yield an upper bound of 2^4 \"bulb states\" (since \"bulb states\" are a function of the operation states). \\n\\nBut since operation 1 (toggle all) is equivalent to operations 2+3, (odd+even) it is redundant unless constrained by # of operations, there are only 3 unique operations and 2^3 = 8 possible \"operation states\". (We can only reach 4 unique \"bulb states\" using any number of operations 1,2,3, i.e. the bulb states [\"all off\", \"even on\", \"odd on\", \"all on\"]), .\\n\\nSince we can reach any of the 2^3 \"operation states\" in at most 3 operations, we are free to limit `m` to a max of 3, and consider only the arity of values of `m` >3 (since we need *exactly*, not *at least* `m` operations).\\n\\nBut, again since operations 2+3 (even + odd) are equivalent to operation 1 (toggle all), we can also ignore the arity for  `m>3` values, since we can always change arity of `m` by changing operation 1 with 2+3 or viceversa.\\n\\nFinally, for each of the unique combination of the 2^3 \"operation states\", we can find the 8 sets of integers which it affects (i.e. all the integers in this set will have the same value):\\n\\n* : {}\\n* 1: odd integers\\n* 2: even integers\\n* 1+2: all integers\\n* 3: integers n s.t. n%3==1\\n* 3+1 integers n s.t. n%3==1 and n%2==1\\n* 3+2: integers n s.t. n%3==1 and n%2==0\\n* 3+1+2: integers n s.t. n%3!=1\\n\\n\\nSince when n=3, there is at least one integer represented in each of the sets above, we can restrict n to a max 3 (any higher index will be in an equivalence class represented by one of the numbers <=3 regardless of which \"operation states\" are \"ON\").\\n\\nSince we can limit both n and m to a constant, we can do an exhaustive search in constant time to find the number of unique bulb-states:\\n\\n```\\nclass Solution(object):\\n        \\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        states=set()\\n        n=min(3,n)\\n        m=min(m,3)\\n        def flips(op, i):\\n            return op==0 or\\\\\\n                    (op==1 and i%2==1) or\\\\\\n                    (op==2 and i%2==0) or\\\\\\n                    (op==3 and i%3==0)\\n        \\n        for B in xrange(1<<4):\\n            nflips=sum((B>>i)&1 for i in xrange(1<<4))\\n            if nflips>m or nflips%2 != m%2:\\n                continue\\n            curr=\"\"\\n            for i in xrange(n):\\n                d=sum(flips(op, i) for op in xrange(4) if (B>>op)&1)\\n                curr+=\"01\"[d%2]\\n            states.add(curr)\\n                \\n        return len(states)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n        \\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        states=set()\\n        n=min(3,n)\\n        m=min(m,3)\\n        def flips(op, i):\\n            return op==0 or\\\\\\n                    (op==1 and i%2==1) or\\\\\\n                    (op==2 and i%2==0) or\\\\\\n                    (op==3 and i%3==0)\\n        \\n        for B in xrange(1<<4):\\n            nflips=sum((B>>i)&1 for i in xrange(1<<4))\\n            if nflips>m or nflips%2 != m%2:\\n                continue\\n            curr=\"\"\\n            for i in xrange(n):\\n                d=sum(flips(op, i) for op in xrange(4) if (B>>op)&1)\\n                curr+=\"01\"[d%2]\\n            states.add(curr)\\n                \\n        return len(states)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107280,
                "title": "intuitive-solution",
                "content": "First of all, this solution is not mine, I got it after studying cuiaoxiang's contest solution.\\n\\nThis solution is based on the observation that any result from m > 4 can also be retrieved from a combination while m <= 4. This is because taking a same action twice is same as not taking it, while taking a same action three times is same as taking it one time, etc.\\nWhile m <= 4, we should get 16 different combinations, and we can use a binary number to help us track whether we are taking operation 1), 2), 3) or 4)\\n\\nIn this solution, we will check each of 16 combinations. In each combination, we firstly check how many operations will be taken. If the count > m, then we will not continue in current loop.  If count <= m, then we also need to check if m%2 == count%2. Why? Please see comments in the code....\\nAfter that, We can construct an array with len(n), because n <= 1000, this should not cause any boundary cases. We will apply each operation when the binary number has a 1 in the corresponding digit..\\nWe use a HashSet to catch all possible results and the size of result set should be our output.\\nIt costs me few hours to understand this solution, and I think it is more intuitive for me.....So here it is.\\n```\\npublic int flipLights(int n, int m) {\\n        HashSet<List<Boolean>> hs = new HashSet<>();\\n        \\n        for(int k = 0; k < 16; k++){\\n            //n bulbs\\n            Boolean[] curr = new Boolean[n];\\n            Arrays.fill(curr, false);\\n            int count = 0;\\n            \\n            for(int i = 0; i < 4; i++){\\n                //check how many methods will be used in this loop\\n                if( (k&(1<<i)) > 0 )  count++;  \\n            }\\n            \\n            //if we are going to pick more than m methods, then we skip current loop\\n            if(count > m) continue;\\n            //count < m will also work, since we can apply a same method multiple times\\n            //so that we need to check if m and count are both even or both odd.\\n            //duplicate operations + count = m\\n            //if count = 2, m = 3, then there is no way that we can use 3 operations to achieve the same effect of two operations\\n            //if count = 1, m = 3, then we can apply a method twice to achieve the same result\\n            //if count = 1, m = 2, then there is no way that we can use 1 operation to achieve the same effect of two operations\\n            //if count = 2 or count = 0, m = 2, we can just apply two methods or a method twice to achieve count = 2 or count = 0\\n            if( count%2 != m%2 ) continue;\\n            \\n            if( (k&1) > 0){\\n                for(int i = 0; i < n; i++) curr[i] = !curr[i]; \\n            }\\n            \\n            if( (k&2) > 0){\\n                for(int i = 0; i < n; i+=2) curr[i] = !curr[i];\\n            }\\n            \\n            if( (k&4) > 0){\\n                for(int i = 1; i < n; i+=2) curr[i] = !curr[i];\\n            }\\n            \\n            if( (k&8) > 0){\\n                //3k+1, k = 0,1,2 => now we are 0 based, so it is 3k, k = 0,1,2\\n                for(int i = 0; i < n; i += 3 ) curr[i] = !curr[i];\\n            }            \\n            List<Boolean> list = Arrays.asList(curr);\\n            hs.add(list);\\n        }\\n        \\n        //System.out.println(hs);\\n        return hs.size();\\n }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n        HashSet<List<Boolean>> hs = new HashSet<>();\\n        \\n        for(int k = 0; k < 16; k++){\\n            //n bulbs\\n            Boolean[] curr = new Boolean[n];\\n            Arrays.fill(curr, false);\\n            int count = 0;\\n            \\n            for(int i = 0; i < 4; i++){\\n                //check how many methods will be used in this loop\\n                if( (k&(1<<i)) > 0 )  count++;  \\n            }\\n            \\n            //if we are going to pick more than m methods, then we skip current loop\\n            if(count > m) continue;\\n            //count < m will also work, since we can apply a same method multiple times\\n            //so that we need to check if m and count are both even or both odd.\\n            //duplicate operations + count = m\\n            //if count = 2, m = 3, then there is no way that we can use 3 operations to achieve the same effect of two operations\\n            //if count = 1, m = 3, then we can apply a method twice to achieve the same result\\n            //if count = 1, m = 2, then there is no way that we can use 1 operation to achieve the same effect of two operations\\n            //if count = 2 or count = 0, m = 2, we can just apply two methods or a method twice to achieve count = 2 or count = 0\\n            if( count%2 != m%2 ) continue;\\n            \\n            if( (k&1) > 0){\\n                for(int i = 0; i < n; i++) curr[i] = !curr[i]; \\n            }\\n            \\n            if( (k&2) > 0){\\n                for(int i = 0; i < n; i+=2) curr[i] = !curr[i];\\n            }\\n            \\n            if( (k&4) > 0){\\n                for(int i = 1; i < n; i+=2) curr[i] = !curr[i];\\n            }\\n            \\n            if( (k&8) > 0){\\n                //3k+1, k = 0,1,2 => now we are 0 based, so it is 3k, k = 0,1,2\\n                for(int i = 0; i < n; i += 3 ) curr[i] = !curr[i];\\n            }            \\n            List<Boolean> list = Arrays.asList(curr);\\n            hs.add(list);\\n        }\\n        \\n        //System.out.println(hs);\\n        return hs.size();\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107281,
                "title": "a-c-solution-using-bit-manipulation",
                "content": "My solution does not leverage much math insights into the problem, but rather apply bit manipulation to simulate the process to find all states after m steps.\\n\\nNevertheless, I do use some insights to reduce the number of bits used to represent light state from n to 3. This is because the n lights can be grouped into the following 3 groups. As lights within the same group will not have a different on/off state through out the m operations, their share one bit to represent their states.\\n\\n* group 1: whose with odd index representable as 3k+1, use the last bit in a char.\\n\\n\\n* group 2: whose with even index use the second last bit in a char.\\n\\n* group 3: whose with odd index, but not representable as 3k+1, use the third last bit in a char.\\n\\nWhen a button is pressed, it is flipping the state (and the corresponding bit ) of one or more groups:\\n\\n* button 1 flips all 3 groups, we can do XOR 7 on the old state to get the new state.\\n\\n* button 2 flips group 2, do XOR 2 on the old state to get the new state.\\n\\n* button 3 flips group 1 and group 3, do XOR 5\\n\\n* button 4 flips group 1, do XOR 1\\n\\nFor small n such as 1 and 2, there maybe zero lights in some of the 3 groups, and we setup mask to disregard the corresponding bits every time we simulate the flip.\\n\\nThe finally observation is that the number of states cannot be more than 8, so once we get a set of 8 states at some step, we do not need to simulate all the remaining ones.\\n\\nThe code in C++ is in the following:\\n\\n\\n\\n\\n    int flipLights(int n, int m) {\\n        char s0,mask;\\n        const int maxStates = 8;\\n        vector<char> buttons = {1,2,5,7};\\n\\n        switch(n){\\n            case 1:\\n                s0 = mask = 1;\\n                break;\\n            case 2:\\n                s0 = mask = 3;\\n                break;\\n            default:\\n                s0 = mask = 7;\\n        }\\n        \\n        set<char> states;\\n        states.insert(s0);\\n        for (int i = 1; i<=m && states.size() < maxStates; i++){\\n            set <char> newStates;\\n            for (auto s : states)\\n                for (auto b: buttons) \\n                    newStates.insert(s^b&mask);\\n            states = newStates;\\n        }\\n        \\n        return states.size();\\n    }\\n\\nAlthough this approach is slower than the other ones with pure math insights, it is generic and justifies this problem as a valid coding problem.",
                "solutionTags": [],
                "code": "My solution does not leverage much math insights into the problem, but rather apply bit manipulation to simulate the process to find all states after m steps.\\n\\nNevertheless, I do use some insights to reduce the number of bits used to represent light state from n to 3. This is because the n lights can be grouped into the following 3 groups. As lights within the same group will not have a different on/off state through out the m operations, their share one bit to represent their states.\\n\\n* group 1: whose with odd index representable as 3k+1, use the last bit in a char.\\n\\n\\n* group 2: whose with even index use the second last bit in a char.\\n\\n* group 3: whose with odd index, but not representable as 3k+1, use the third last bit in a char.\\n\\nWhen a button is pressed, it is flipping the state (and the corresponding bit ) of one or more groups:\\n\\n* button 1 flips all 3 groups, we can do XOR 7 on the old state to get the new state.\\n\\n* button 2 flips group 2, do XOR 2 on the old state to get the new state.\\n\\n* button 3 flips group 1 and group 3, do XOR 5\\n\\n* button 4 flips group 1, do XOR 1\\n\\nFor small n such as 1 and 2, there maybe zero lights in some of the 3 groups, and we setup mask to disregard the corresponding bits every time we simulate the flip.\\n\\nThe finally observation is that the number of states cannot be more than 8, so once we get a set of 8 states at some step, we do not need to simulate all the remaining ones.\\n\\nThe code in C++ is in the following:\\n\\n\\n\\n\\n    int flipLights(int n, int m) {\\n        char s0,mask;\\n        const int maxStates = 8;\\n        vector<char> buttons = {1,2,5,7};\\n\\n        switch(n){\\n            case 1:\\n                s0 = mask = 1;\\n                break;\\n            case 2:\\n                s0 = mask = 3;\\n                break;\\n            default:\\n                s0 = mask = 7;\\n        }\\n        \\n        set<char> states;\\n        states.insert(s0);\\n        for (int i = 1; i<=m && states.size() < maxStates; i++){\\n            set <char> newStates;\\n            for (auto s : states)\\n                for (auto b: buttons) \\n                    newStates.insert(s^b&mask);\\n            states = newStates;\\n        }\\n        \\n        return states.size();\\n    }\\n\\nAlthough this approach is slower than the other ones with pure math insights, it is generic and justifies this problem as a valid coding problem.",
                "codeTag": "Unknown"
            },
            {
                "id": 107288,
                "title": "python-o-1-with-detailed-analysis",
                "content": "First of all, we can just discuss the case that `n = 1,2,3,4,5,6`, because the lights repeat the pattern of first 6 bulbs. Remarkably, the 5th and 6th bulb is the same as 4th and 3th respectively, so we just need to discuss the case `n = 1,2,3,4`. When `n>4`, it is the same as `n=4`.\\n\\nIf you are familiar with group theory, this question is quite simple. We now have four operations `A` (flip All), `E` (flip Even), `O` (flip Odd), `K` (flip 3k+1). Here we denote identical operation (the operation that changes nothing) with `I`. It's obvious that all operations are commutative, the order in which they are performed does not matter. Additionally, we have some other basic rules here, such as perform the same operation twice is equal to do nothing, and flipping all and then flipping even is equal to just flipping Odd. Formally, these rule can be written as\\n\\n```python\\nAA=EE=OO=KK=I    # two same operation is equal to Identical operation\\nAE=O             # flipping all and even is equal to flipping odd\\nAO=E             # flipping all and odd is equal to flipping even\\nOE=A             # flipping odd and even is equal to flipping all\\n```\\n\\n## When `n=1`\\nIn this trivial case, the answer is always 2.\\n\\n## When `n=2`\\n\\nIn this case, the operation K is equal to operation O, so we actually have three operations `A, O, E`. \\nIf `m=1`, three status by performing `A, O, E`. We can draw a table to count the status. The table below shows where can we reach from the identical operation (the initial status is equal to having performed an identical operation).\\n```\\n___|_A___O___E_\\n I | A   O   E \\n```\\nIf `m=2`, we draw table below. In the case `m=1`, we can reach `A, O, E`, after performing one more operation we can reach `A, O, E, I`, four status.\\n```\\n___|_A___O___E_\\n A | I   E   O \\n O | E   I   A \\n E | O   A   I \\n```\\nif `m=3`, we show go one operation far from `m=2`. Again, we can reach four status `A, O, E, I `.\\n```\\n___|_A___O___E_\\n A | I   E   O \\n O | E   I   A \\n E | O   A   I \\n I | A   O   E\\n```\\nIf `m>3`, the table will be the same as `m=3`.\\n\\n## When `n>=3`\\nNow we have four distinct operations `A, O, E, K `.\\nIf `m=1`, four kinds of status, `A, O, E, K `\\n```\\n___|_A__O__E__K__\\n I | A  O  E  K \\n```\\nif `m=2`, we have 7 kinds of status, `I, A, O, E, AK, EK, OK`. Here, `AK` means perform operation `A` and `K` in order. `EK, OK` is the same.\\n```\\n___|_A___O___E___K_\\n A | I   E   O   AK\\n O | E   I   A   OK\\n E | O   A   I   EK\\n K | AK  OK  EK  I\\n```\\nif `m=3`, we have 8 kinds of status, `A, O, E, K, I, AK, OK, EK`.\\n```\\n___|_A___O___E___K_\\n A | I   E   O   AK\\n O | E   I   A   OK\\n E | O   A   I   EK\\n I | A   O   E   K\\n- - - - - - - - - -  # Add this line to make it more readable\\nAK | K   EK  OK  A\\nOK | EK  K   AK  A\\nEK | OK  AK  K   A\\n```\\nif `m>3`, the table will be above one with an extra row. But this does not introduce new status. So it is still 8 kinds of status.\\n```\\n___|_A___O___E___K_\\n K | AK  OK  EK  I\\n```\\n## Summary\\nThe reuslts forms this table:\\n```\\nn\\\\m_0_1_2_3_...\\n1|  1 2 2 2 ...\\n2|  1 3 4 4 ...\\n3|  1 4 7 8 ...\\n4|  1 4 7 8 ...\\n.|  . . . .\\n.|  . . . .\\n```\\n## Python Code\\n```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0: \\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if m<2 else 4\\n        else:\\n            if m == 1:\\n                return 4\\n            elif m == 2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "solutionTags": [],
                "code": "```python\\nAA=EE=OO=KK=I    # two same operation is equal to Identical operation\\nAE=O             # flipping all and even is equal to flipping odd\\nAO=E             # flipping all and odd is equal to flipping even\\nOE=A             # flipping odd and even is equal to flipping all\\n```\n```\\n___|_A___O___E_\\n I | A   O   E \\n```\n```\\n___|_A___O___E_\\n A | I   E   O \\n O | E   I   A \\n E | O   A   I \\n```\n```\\n___|_A___O___E_\\n A | I   E   O \\n O | E   I   A \\n E | O   A   I \\n I | A   O   E\\n```\n```\\n___|_A__O__E__K__\\n I | A  O  E  K \\n```\n```\\n___|_A___O___E___K_\\n A | I   E   O   AK\\n O | E   I   A   OK\\n E | O   A   I   EK\\n K | AK  OK  EK  I\\n```\n```\\n___|_A___O___E___K_\\n A | I   E   O   AK\\n O | E   I   A   OK\\n E | O   A   I   EK\\n I | A   O   E   K\\n- - - - - - - - - -  # Add this line to make it more readable\\nAK | K   EK  OK  A\\nOK | EK  K   AK  A\\nEK | OK  AK  K   A\\n```\n```\\n___|_A___O___E___K_\\n K | AK  OK  EK  I\\n```\n```\\nn\\\\m_0_1_2_3_...\\n1|  1 2 2 2 ...\\n2|  1 3 4 4 ...\\n3|  1 4 7 8 ...\\n4|  1 4 7 8 ...\\n.|  . . . .\\n.|  . . . .\\n```\n```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        \"\"\"\\n        :type n: int\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        if m == 0: \\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if m<2 else 4\\n        else:\\n            if m == 1:\\n                return 4\\n            elif m == 2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091720,
                "title": "consider-all-cases-o-1",
                "content": "Straightforward to know that what matters is only n % 6.\\nSuppose we have a,b,c,d operations of 1,2,3,4.\\nBulb1 =  (a+b+d) % 2\\nBulb2 =  (a+c) % 2\\nBulb3 =  (a+b) % 2\\nand bulb 4 same as 1, 5 same as 3, 6 same as 2\\n\\nTherefore, what really matters is only the first three bulbs. \\n\\nIf we have only 1 bulb, in on step we have the two states 0 and 1 reachable. And so on, we just return 2.\\n\\nIn the case where we have 2 bulbs, step 1 would lead us to states 11,10,01 but not 00. After step 2 we can get 00 again, and so on we can reach whaterver we want.\\n\\n3 bulb, draw on your paper and easily we see in one step we got 4 states, and 2 steps we have all 8 states but 100, which can be reached after the 3 step. \\n\\nTherefore, just a few ifelses, O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(3,n)\\n        state = 0\\n        if presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            return 4 if presses > 1 else 3\\n        if n == 3:\\n            if presses > 2:return 8\\n            elif presses == 2: return 7\\n            else: return 4\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(3,n)\\n        state = 0\\n        if presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            return 4 if presses > 1 else 3\\n        if n == 3:\\n            if presses > 2:return 8\\n            elif presses == 2: return 7\\n            else: return 4\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079069,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int flipLights(int n, int presses) {\\n    if (presses == 0) {\\n      return 1;\\n    } else if (presses == 1) {\\n      if (n < 3) {\\n        return n + 1;\\n      } else {\\n        return 4;\\n      }\\n    } else if (presses == 2) {\\n      if (n == 1) {\\n        return 2;\\n      } else if (n == 2) {\\n        return 4;\\n      } else {\\n        return 7;\\n      }\\n    } else if (presses >= 3) {\\n      if (n == 1) {\\n        return 2;\\n      } else if (n == 2) {\\n        return 4;\\n      } else {\\n        return 8;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int flipLights(int n, int presses) {\\n    if (presses == 0) {\\n      return 1;\\n    } else if (presses == 1) {\\n      if (n < 3) {\\n        return n + 1;\\n      } else {\\n        return 4;\\n      }\\n    } else if (presses == 2) {\\n      if (n == 1) {\\n        return 2;\\n      } else if (n == 2) {\\n        return 4;\\n      } else {\\n        return 7;\\n      }\\n    } else if (presses >= 3) {\\n      if (n == 1) {\\n        return 2;\\n      } else if (n == 2) {\\n        return 4;\\n      } else {\\n        return 8;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028188,
                "title": "java-simple-solution-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n          if(presses==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&presses==1) return 3;\\n        if(n==2) return 4;\\n        if(presses==1) return 4;\\n        if(presses==2) return 7;\\n        if(presses>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n          if(presses==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2&&presses==1) return 3;\\n        if(n==2) return 4;\\n        if(presses==1) return 4;\\n        if(presses==2) return 7;\\n        if(presses>=3) return 8;\\n        return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923599,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n\\n    public int flipLights(int n, int p) {\\n        n = Math.min(n, 4); \\n        p = Math.min(p, 4);\\n        int thre = (1<<n)-1;\\n\\n        int[] flips = new int[] {\\n            Integer.parseInt(\"1111\", 2)&thre,\\n            Integer.parseInt(\"0101\", 2)&thre,\\n            Integer.parseInt(\"1010\", 2)&thre,\\n            Integer.parseInt(\"1001\", 2)&thre\\n        };\\n\\n        if(p==0) return 1;\\n\\n        int ans = 0;\\n        boolean[] used = new boolean[(1<<10)+1];\\n\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, 0});\\n\\n        while(!q.isEmpty()){\\n            int[] val = q.remove();\\n            int cur = val[0];\\n            int presses = val[1];\\n\\n            if(presses==p) {\\n                if(!used[cur]) ans++;\\n                used[cur] = true;\\n                continue;\\n            }\\n\\n            for(int flip : flips){\\n                q.add(new int[] {flip ^ cur, presses + 1});\\n            }          \\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n```python3 []\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    fn flip_bit(number: i32, position: u32) -> i32 {\\n        let mask = 1 << position;\\n        let flipped_number = number ^ mask;\\n        flipped_number\\n    }\\n    \\n    fn y_function(x: i32) -> i32 {\\n        3 * x + 1\\n    }\\n    \\n    fn get_neighbors(state: i32, n: i32) -> Vec<i32> {\\n        let mut nbrs: Vec<i32> = vec![];\\n        \\n        let mut curr_num = state;\\n        for i in 1..n {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (1..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (0..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n        \\n        let mut i = 0;\\n        while Solution::y_function(i) < n {\\n            curr_num = Solution::flip_bit(curr_num, Solution::y_function(i) as u32);\\n            i += 1;\\n        }\\n        nbrs.push(curr_num);\\n        \\n        nbrs\\n    }\\n    \\n    // O(n*press) time,\\n    // O(n*space) space,\\n    // Approach: bfs, bit manipulation\\n    fn flip_lights(n: i32, presses: i32) -> i32 {\\n        let mut answer: HashSet<i32> = HashSet::new();\\n        let mut queue: VecDeque<i32> = VecDeque::new();\\n        queue.push_back((2_i32.pow(n as u32) - 1));\\n        answer.insert(queue[0]);\\n        \\n        let mut presses = presses;\\n        \\n        while presses > 0 && !queue.is_empty() {\\n            presses -= 1;\\n            let queue_len = queue.len();\\n            answer = HashSet::new();\\n            for _ in 0..queue_len {\\n                let state = queue.pop_front().unwrap();\\n                let nbrs = Solution::get_neighbors(state, n);\\n                for nbr in nbrs {\\n                    if answer.contains(&nbr) {\\n                        continue;\\n                    }\\n                    answer.insert(nbr);\\n                    queue.push_back(nbr);\\n                }\\n            }\\n        }\\n\\n        answer.len() as i32\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        vector<bitset<1000>> m(4);\\n\\n        for (int i=1;i<n;i+=2) {\\n            m[1].flip(i);\\n            m[2].flip(i-1);\\n        }\\n        if (n%2==1) m[2].flip(n-1);\\n        m[0]=m[1];\\n        m[0]|=m[2];\\n\\n        \\n        for (int i=0;i<n;i+=3) m[3].flip(i);\\n\\n        //for(auto& a:m) cout << a << endl;\\n\\n        unordered_set<bitset<1000>> q;\\n        q.insert(m[0]);\\n\\n        for (int i=0;i<presses;i++){\\n            unordered_set<bitset<1000>> temp;\\n            for (auto& item:q){\\n                for (int j=0;j<4;j++){\\n                    auto t = bitset<1000>{item};\\n                    t ^= m[j];\\n                    temp.insert(t);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return q.size();\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n\\n    public int flipLights(int n, int p) {\\n        n = Math.min(n, 4); \\n        p = Math.min(p, 4);\\n        int thre = (1<<n)-1;\\n\\n        int[] flips = new int[] {\\n            Integer.parseInt(\"1111\", 2)&thre,\\n            Integer.parseInt(\"0101\", 2)&thre,\\n            Integer.parseInt(\"1010\", 2)&thre,\\n            Integer.parseInt(\"1001\", 2)&thre\\n        };\\n\\n        if(p==0) return 1;\\n\\n        int ans = 0;\\n        boolean[] used = new boolean[(1<<10)+1];\\n\\n        Queue<int[]> q = new LinkedList();\\n        q.add(new int[] {0, 0});\\n\\n        while(!q.isEmpty()){\\n            int[] val = q.remove();\\n            int cur = val[0];\\n            int presses = val[1];\\n\\n            if(presses==p) {\\n                if(!used[cur]) ans++;\\n                used[cur] = true;\\n                continue;\\n            }\\n\\n            for(int flip : flips){\\n                q.add(new int[] {flip ^ cur, presses + 1});\\n            }          \\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```python3 []\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    fn flip_bit(number: i32, position: u32) -> i32 {\\n        let mask = 1 << position;\\n        let flipped_number = number ^ mask;\\n        flipped_number\\n    }\\n    \\n    fn y_function(x: i32) -> i32 {\\n        3 * x + 1\\n    }\\n    \\n    fn get_neighbors(state: i32, n: i32) -> Vec<i32> {\\n        let mut nbrs: Vec<i32> = vec![];\\n        \\n        let mut curr_num = state;\\n        for i in 1..n {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (1..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (0..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n        \\n        let mut i = 0;\\n        while Solution::y_function(i) < n {\\n            curr_num = Solution::flip_bit(curr_num, Solution::y_function(i) as u32);\\n            i += 1;\\n        }\\n        nbrs.push(curr_num);\\n        \\n        nbrs\\n    }\\n    \\n    // O(n*press) time,\\n    // O(n*space) space,\\n    // Approach: bfs, bit manipulation\\n    fn flip_lights(n: i32, presses: i32) -> i32 {\\n        let mut answer: HashSet<i32> = HashSet::new();\\n        let mut queue: VecDeque<i32> = VecDeque::new();\\n        queue.push_back((2_i32.pow(n as u32) - 1));\\n        answer.insert(queue[0]);\\n        \\n        let mut presses = presses;\\n        \\n        while presses > 0 && !queue.is_empty() {\\n            presses -= 1;\\n            let queue_len = queue.len();\\n            answer = HashSet::new();\\n            for _ in 0..queue_len {\\n                let state = queue.pop_front().unwrap();\\n                let nbrs = Solution::get_neighbors(state, n);\\n                for nbr in nbrs {\\n                    if answer.contains(&nbr) {\\n                        continue;\\n                    }\\n                    answer.insert(nbr);\\n                    queue.push_back(nbr);\\n                }\\n            }\\n        }\\n\\n        answer.len() as i32\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        vector<bitset<1000>> m(4);\\n\\n        for (int i=1;i<n;i+=2) {\\n            m[1].flip(i);\\n            m[2].flip(i-1);\\n        }\\n        if (n%2==1) m[2].flip(n-1);\\n        m[0]=m[1];\\n        m[0]|=m[2];\\n\\n        \\n        for (int i=0;i<n;i+=3) m[3].flip(i);\\n\\n        //for(auto& a:m) cout << a << endl;\\n\\n        unordered_set<bitset<1000>> q;\\n        q.insert(m[0]);\\n\\n        for (int i=0;i<presses;i++){\\n            unordered_set<bitset<1000>> temp;\\n            for (auto& item:q){\\n                for (int j=0;j<4;j++){\\n                    auto t = bitset<1000>{item};\\n                    t ^= m[j];\\n                    temp.insert(t);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return q.size();\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3896100,
                "title": "c-observational-logic-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis is highly observation based problem. \\nWe can note that if n is 1 we can only have 2 states (0,1) if we have presses>0. \\nWe then can observe that, when we have n = 2, if presses == 1 we will have (11,01,10). But if we have presses == 2 we have all 4 combinations (00,11,01,10).\\n\\nWe then can observe that if n = 3, if we have presses == 1 we will have 4 unique states (111,010,101,100). If presses == 2 we will have ((111,101,010),000,011,110) 7 states and if presses >= 3 we have ((111,101,010),000,011,110,100,001) all 8 possible states.\\n\\nBut now if we observe for n == 4, if presses == 1 we have same 4 states (1111,0101,1010,1001). For presses == 2 we have ((1111,0101,1010),0000,0110,1100,0011). For presses == 3 we have (((1111,0101,1010),0000,0110,1100,0011), 1001) and for presses == 4,5.. we have same states.\\n\\nThis trend continues for any n >= 3. Hence we follow the above code.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if(presses==0)return 1;\\n        if(n==1)return 2;\\n        if(n==2)return presses==1?3:4;\\n        if(presses==1)return 4;\\n        if(presses==2)return 7;\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if(presses==0)return 1;\\n        if(n==1)return 2;\\n        if(n==2)return presses==1?3:4;\\n        if(presses==1)return 4;\\n        if(presses==2)return 7;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860294,
                "title": "c-bitset",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        vector<bitset<1000>> m(4);\\n\\n        for (int i=1;i<n;i+=2) {\\n            m[1].flip(i);\\n            m[2].flip(i-1);\\n        }\\n        if (n%2==1) m[2].flip(n-1);\\n        m[0]=m[1];\\n        m[0]|=m[2];\\n\\n        \\n        for (int i=0;i<n;i+=3) m[3].flip(i);\\n\\n        //for(auto& a:m) cout << a << endl;\\n\\n        unordered_set<bitset<1000>> q;\\n        q.insert(m[0]);\\n\\n        for (int i=0;i<presses;i++){\\n            unordered_set<bitset<1000>> temp;\\n            for (auto& item:q){\\n                for (int j=0;j<4;j++){\\n                    auto t = bitset<1000>{item};\\n                    t ^= m[j];\\n                    temp.insert(t);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return q.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        vector<bitset<1000>> m(4);\\n\\n        for (int i=1;i<n;i+=2) {\\n            m[1].flip(i);\\n            m[2].flip(i-1);\\n        }\\n        if (n%2==1) m[2].flip(n-1);\\n        m[0]=m[1];\\n        m[0]|=m[2];\\n\\n        \\n        for (int i=0;i<n;i+=3) m[3].flip(i);\\n\\n        //for(auto& a:m) cout << a << endl;\\n\\n        unordered_set<bitset<1000>> q;\\n        q.insert(m[0]);\\n\\n        for (int i=0;i<presses;i++){\\n            unordered_set<bitset<1000>> temp;\\n            for (auto& item:q){\\n                for (int j=0;j<4;j++){\\n                    auto t = bitset<1000>{item};\\n                    t ^= m[j];\\n                    temp.insert(t);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return q.size();\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3830675,
                "title": "100-faster-simple-clean-code",
                "content": "# Intuition\\n\\n# Approach\\n1) If same switch repeats itself, it nullifies its effect.\\n2) Switch (1,2,3) form closed loop, i.e., pressing any 2 is equivalent to another\\n3) When (n>2), all switches have unique effect\\n4) At max 8 states possible due to constraint in step-1,2 \\n5) presses==2 : we can\\'t reach a state same as config obtained by switch 4\\n# Complexity\\n- Time complexity:O(1)\\n- Space complexity:O(1)\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n\\n        if(presses==0) return 1;\\n        if(n==1) {\\n            return 2 ;\\n        } \\n        if(n==2){\\n            if(presses==1) return 3 ; \\n            return 4;  \\n        }\\n        if(presses==1) return 4 ; \\n        if(presses==2) return 7 ;   \\n        return 8 ; \\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n\\n        if(presses==0) return 1;\\n        if(n==1) {\\n            return 2 ;\\n        } \\n        if(n==2){\\n            if(presses==1) return 3 ; \\n            return 4;  \\n        }\\n        if(presses==1) return 4 ; \\n        if(presses==2) return 7 ;   \\n        return 8 ; \\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792532,
                "title": "o-1-time-complexity-only-if-else-nothing-other-than-that-beautiful-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if (presses == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2) return (presses == 1) ? 3 : 4;\\n        if (presses == 1) return 4;\\n        return (presses == 2) ? 7 : 8;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if (presses == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2) return (presses == 1) ? 3 : 4;\\n        if (presses == 1) return 4;\\n        return (presses == 2) ? 7 : 8;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685181,
                "title": "scala-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach recursive\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def flipLights(n: Int, presses: Int): Int = {\\n      if (presses == 0 || n == 0) 1\\n      else if (n > 3) flipLights(3, presses)\\n      else flipLights(n - 1, presses - 1) + flipLights(n - 1, presses)\\n    }\\n}\\n```\\n\\n# Approach math\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def flipLights(n: Int, presses: Int): Int = (n, presses) match {\\n      case (_, 0) => 1\\n      case (1, _) => 2\\n      case (2, 1) => 3\\n      case (2, _) => 4\\n      case (_, 1) => 4\\n      case (_, 2) => 7\\n      case (_,_) => 8\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def flipLights(n: Int, presses: Int): Int = {\\n      if (presses == 0 || n == 0) 1\\n      else if (n > 3) flipLights(3, presses)\\n      else flipLights(n - 1, presses - 1) + flipLights(n - 1, presses)\\n    }\\n}\\n```\n```\\nobject Solution {\\n    def flipLights(n: Int, presses: Int): Int = (n, presses) match {\\n      case (_, 0) => 1\\n      case (1, _) => 2\\n      case (2, 1) => 3\\n      case (2, _) => 4\\n      case (_, 1) => 4\\n      case (_, 2) => 7\\n      case (_,_) => 8\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3664452,
                "title": "bit-manipulation-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(m)$$. m is number of different states.\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0:\\n            return 1\\n        length = min(10, n)\\n        state = (1 << length) - 1\\n        buttons = [(1 << length) - 1, 0, 0, 0]\\n        for i in range(length):\\n            if i % 2 != 0:\\n                buttons[1] |= 1 << i\\n            if i % 2 == 0:\\n                buttons[2] |= 1 << i\\n            if 3 * i + 1 < length:\\n                buttons[3] |= 1 << (3 * i)\\n        states = set()\\n        visited = set()\\n        q = deque()\\n        q.append([state, presses])\\n        while q:\\n            for _ in range(len(q)):\\n                currentState, currentPresses = q.popleft()\\n                for button in buttons:\\n                    newState = currentState ^ button\\n                    if newState not in states and (newState, currentPresses - 1) not in visited:\\n                        if currentPresses - 1 > 0:\\n                            q.append([newState, currentPresses - 1])\\n                            visited.add((newState, currentPresses - 1))\\n                        else:\\n                            states.add(newState)\\n        return len(states)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0:\\n            return 1\\n        length = min(10, n)\\n        state = (1 << length) - 1\\n        buttons = [(1 << length) - 1, 0, 0, 0]\\n        for i in range(length):\\n            if i % 2 != 0:\\n                buttons[1] |= 1 << i\\n            if i % 2 == 0:\\n                buttons[2] |= 1 << i\\n            if 3 * i + 1 < length:\\n                buttons[3] |= 1 << (3 * i)\\n        states = set()\\n        visited = set()\\n        q = deque()\\n        q.append([state, presses])\\n        while q:\\n            for _ in range(len(q)):\\n                currentState, currentPresses = q.popleft()\\n                for button in buttons:\\n                    newState = currentState ^ button\\n                    if newState not in states and (newState, currentPresses - 1) not in visited:\\n                        if currentPresses - 1 > 0:\\n                            q.append([newState, currentPresses - 1])\\n                            visited.add((newState, currentPresses - 1))\\n                        else:\\n                            states.add(newState)\\n        return len(states)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608789,
                "title": "bit-manipulation-bfs-rust-and-python3-solution",
                "content": "###  Rust Solution (passes)\\n\\n```\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    fn flip_bit(number: i32, position: u32) -> i32 {\\n        let mask = 1 << position;\\n        let flipped_number = number ^ mask;\\n        flipped_number\\n    }\\n    \\n    fn y_function(x: i32) -> i32 {\\n        3 * x + 1\\n    }\\n    \\n    fn get_neighbors(state: i32, n: i32) -> Vec<i32> {\\n        let mut nbrs: Vec<i32> = vec![];\\n        \\n        let mut curr_num = state;\\n        for i in 1..n {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (1..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (0..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n        \\n        let mut i = 0;\\n        while Solution::y_function(i) < n {\\n            curr_num = Solution::flip_bit(curr_num, Solution::y_function(i) as u32);\\n            i += 1;\\n        }\\n        nbrs.push(curr_num);\\n        \\n        nbrs\\n    }\\n    \\n    // O(n*press) time,\\n    // O(n*space) space,\\n    // Approach: bfs, bit manipulation\\n    fn flip_lights(n: i32, presses: i32) -> i32 {\\n        let mut answer: HashSet<i32> = HashSet::new();\\n        let mut queue: VecDeque<i32> = VecDeque::new();\\n        queue.push_back((2_i32.pow(n as u32) - 1));\\n        answer.insert(queue[0]);\\n        \\n        let mut presses = presses;\\n        \\n        while presses > 0 && !queue.is_empty() {\\n            presses -= 1;\\n            let queue_len = queue.len();\\n            answer = HashSet::new();\\n            for _ in 0..queue_len {\\n                let state = queue.pop_front().unwrap();\\n                let nbrs = Solution::get_neighbors(state, n);\\n                for nbr in nbrs {\\n                    if answer.contains(&nbr) {\\n                        continue;\\n                    }\\n                    answer.insert(nbr);\\n                    queue.push_back(nbr);\\n                }\\n            }\\n        }\\n\\n        answer.len() as i32\\n    }\\n}\\n```\\n\\n### Python3 Solution (TLE)\\n```\\nclass Solution:\\n    \\n    def flipBit(self, number, position):\\n        mask = 1 << position\\n        flipped_number = number ^ mask\\n        return flipped_number\\n        \\n    def yFunction(self, x: int) -> int:\\n        return 3*x + 1\\n    \\n    def getNeighbors(self, state: int, n: int,) -> List[int]:\\n        nbrs = []\\n        \\n        curr_num = state\\n        for i in range(1, n):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n            \\n        curr_num = state\\n        for i in range(1, n, 2):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n            \\n        curr_num = state\\n        for i in range(0, n, 2):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n        \\n        i = 0\\n        while self.yFunction(i) < n:\\n            curr_num = self.flipBit(curr_num, self.yFunction(i))\\n            i += 1\\n        nbrs.append(curr_num)  \\n        \\n        return nbrs\\n            \\n            \\n    # O(n*press) time,\\n    # O(n*space) space,\\n    # Approach: bfs, bit manipulation, \\n    def flipLights(self, n: int, presses: int) -> int:\\n        answer = set()\\n        queue = deque()\\n        queue.append(2**n - 1)\\n        answer.add(queue[0])\\n        \\n        while presses and queue:\\n            presses -= 1\\n            queue_len = len(queue)\\n            answer = set()\\n            for _ in range(queue_len):\\n                state = queue.popleft()\\n                nbrs = self.getNeighbors(state, n)\\n                for nbr in nbrs:\\n                    if nbr in answer:\\n                        continue\\n                    answer.add(nbr)\\n                    queue.append(nbr)\\n\\n        return len(answer)\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::collections::{HashSet, VecDeque};\\n\\nimpl Solution {\\n    fn flip_bit(number: i32, position: u32) -> i32 {\\n        let mask = 1 << position;\\n        let flipped_number = number ^ mask;\\n        flipped_number\\n    }\\n    \\n    fn y_function(x: i32) -> i32 {\\n        3 * x + 1\\n    }\\n    \\n    fn get_neighbors(state: i32, n: i32) -> Vec<i32> {\\n        let mut nbrs: Vec<i32> = vec![];\\n        \\n        let mut curr_num = state;\\n        for i in 1..n {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (1..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n            \\n        curr_num = state;\\n        for i in (0..n).step_by(2) {\\n            curr_num = Solution::flip_bit(curr_num, i as u32);\\n        }\\n        nbrs.push(curr_num);\\n        \\n        let mut i = 0;\\n        while Solution::y_function(i) < n {\\n            curr_num = Solution::flip_bit(curr_num, Solution::y_function(i) as u32);\\n            i += 1;\\n        }\\n        nbrs.push(curr_num);\\n        \\n        nbrs\\n    }\\n    \\n    // O(n*press) time,\\n    // O(n*space) space,\\n    // Approach: bfs, bit manipulation\\n    fn flip_lights(n: i32, presses: i32) -> i32 {\\n        let mut answer: HashSet<i32> = HashSet::new();\\n        let mut queue: VecDeque<i32> = VecDeque::new();\\n        queue.push_back((2_i32.pow(n as u32) - 1));\\n        answer.insert(queue[0]);\\n        \\n        let mut presses = presses;\\n        \\n        while presses > 0 && !queue.is_empty() {\\n            presses -= 1;\\n            let queue_len = queue.len();\\n            answer = HashSet::new();\\n            for _ in 0..queue_len {\\n                let state = queue.pop_front().unwrap();\\n                let nbrs = Solution::get_neighbors(state, n);\\n                for nbr in nbrs {\\n                    if answer.contains(&nbr) {\\n                        continue;\\n                    }\\n                    answer.insert(nbr);\\n                    queue.push_back(nbr);\\n                }\\n            }\\n        }\\n\\n        answer.len() as i32\\n    }\\n}\\n```\n```\\nclass Solution:\\n    \\n    def flipBit(self, number, position):\\n        mask = 1 << position\\n        flipped_number = number ^ mask\\n        return flipped_number\\n        \\n    def yFunction(self, x: int) -> int:\\n        return 3*x + 1\\n    \\n    def getNeighbors(self, state: int, n: int,) -> List[int]:\\n        nbrs = []\\n        \\n        curr_num = state\\n        for i in range(1, n):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n            \\n        curr_num = state\\n        for i in range(1, n, 2):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n            \\n        curr_num = state\\n        for i in range(0, n, 2):\\n            curr_num = self.flipBit(curr_num, i)\\n        nbrs.append(curr_num)\\n        \\n        i = 0\\n        while self.yFunction(i) < n:\\n            curr_num = self.flipBit(curr_num, self.yFunction(i))\\n            i += 1\\n        nbrs.append(curr_num)  \\n        \\n        return nbrs\\n            \\n            \\n    # O(n*press) time,\\n    # O(n*space) space,\\n    # Approach: bfs, bit manipulation, \\n    def flipLights(self, n: int, presses: int) -> int:\\n        answer = set()\\n        queue = deque()\\n        queue.append(2**n - 1)\\n        answer.add(queue[0])\\n        \\n        while presses and queue:\\n            presses -= 1\\n            queue_len = len(queue)\\n            answer = set()\\n            for _ in range(queue_len):\\n                state = queue.popleft()\\n                nbrs = self.getNeighbors(state, n)\\n                for nbr in nbrs:\\n                    if nbr in answer:\\n                        continue\\n                    answer.add(nbr)\\n                    queue.append(nbr)\\n\\n        return len(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574891,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p)\\n     {\\n        if (p == 0)\\n         return 1; \\n        if (n == 1) \\n        return 2;\\n        if (p == 1) \\n        return n > 2 ? 4 : 3; \\n        if (n == 2) \\n        return 4; \\n        return p == 2 ? 7 : 8; \\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p)\\n     {\\n        if (p == 0)\\n         return 1; \\n        if (n == 1) \\n        return 2;\\n        if (p == 1) \\n        return n > 2 ? 4 : 3; \\n        if (n == 2) \\n        return 4; \\n        return p == 2 ? 7 : 8; \\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547953,
                "title": "java-math",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int p) {\\n        // even - 0000, (p>1) 1100, 1010, 1001, 0110, 0101, 0011, 1111 (for p>3)\\n        // odd  - 1000, 0100, 0010, 0001, (p>2) 1110, 1101, 1011, 0111 \\n\\n        //edge cases\\n        if (p ==0) return 1;\\n        if (n==1) return 2;\\n        if (n==2 && p==1) return 3;\\n        if (n==2 && p>1) return 4;\\n\\n        if (p>4) p= (p%2==0)? 4:3;\\n\\n        if (p==1) return 4; // 1000, 0100, 0010, 0001\\n        if (p==2) return 7; //0000, 1100, 1010, 1001, 0110, 0101, 0011\\n        if (p==3) return 8; //1000, 0100, 0010, 0001, 1110, 1101, 1011, 0111 \\n        if (p==4) return 8;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int p) {\\n        // even - 0000, (p>1) 1100, 1010, 1001, 0110, 0101, 0011, 1111 (for p>3)\\n        // odd  - 1000, 0100, 0010, 0001, (p>2) 1110, 1101, 1011, 0111 \\n\\n        //edge cases\\n        if (p ==0) return 1;\\n        if (n==1) return 2;\\n        if (n==2 && p==1) return 3;\\n        if (n==2 && p>1) return 4;\\n\\n        if (p>4) p= (p%2==0)? 4:3;\\n\\n        if (p==1) return 4; // 1000, 0100, 0010, 0001\\n        if (p==2) return 7; //0000, 1100, 1010, 1001, 0110, 0101, 0011\\n        if (p==3) return 8; //1000, 0100, 0010, 0001, 1110, 1101, 1011, 0111 \\n        if (p==4) return 8;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468142,
                "title": "javascript-detailed-explanation-o-1-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSituation 1 `n===1`: Button 1,3,4 are the same, So 2 types of button in total. `t(1) = 2`\\nSituation 2 `n===2`: Button 3,4 are the same, So 3 types of button in total. `t(2) = 3`\\nSituation 3 `n>=3`: 4 button has different outcome. So 4 types of button. `t(n) = 4, n>=3`.\\n\\n**Important:** Based on observation\\n1. Press any button twice equals not press anything.\\n2. The sequence of press button will not impact outcome. Means press `Button 1 -> Button 2` equals `Button 2 -> Button 1`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen `presses == 0 `, no state change, all lights are on. Just `1` status.\\n`flipLights(n, 0) = 1`, when `n >= 1`\\n\\nWhen `presses >= 1`:\\n1. `presses == 1`.\\n\\n`flipLights(n, 1) = t(n)` where `t(1) = 2, t(2) = 3, t(i) = 4 (i>2)`.\\n\\n2. `presses == 2`.\\nSituation 1 `n===1`: `flipLights(1, 2) = C(t(1),2) + flipLights(1, 0) = 1 + 1 = 2`.\\nSituation 2 `n===2`: `flipLights(2, 2) = C(t(2),2) + flipLights(2, 0) = 3 + 1 = 4`.\\nSituation 3 `n>=3`: `flipLights(n, 2) = C(t(n),2) + flipLights(n, 0) = 6 + 1 = 7`.\\n\\n\\n`C(n, r)` is the combination formula, `n` is the size of set, `k` is the size of permutation.\\nFor example, `C(t(3), 2) = C(4, 2)` means, when there are 3 lights, we have 4 different buttons in total, we need to press 2 buttons. So we choose 2 different buttons to press from a total of 4 buttons. That\\'s 6 different combinations.\\n\\n3. `presses >= 3`.\\nWe can have it in general.\\n\\n`flipLights(n, presses) = C(t(n), presses) + flipLights(n, presses-2)`.\\n\\nWhen `t(n) < presses, C(t(n), presses) = 0`, we will get `flipLights(n, presses) = flipLights(n, presses-2)`. It happens when `presses >= 5`. \\n\\nSo all we need to do is to analyse and get the below table.\\n\\nn | presses 0 | presses 1 | presses 2 | presses 3 | presses 4 | presses >= 5| ...\\n--- | --- | --- | --- | --- | --- | --- | ---\\n1 | 1 | 2 | 2 | 2 | 2 | 2 | 2...\\n2 | 1 | 3 | 4 | 4 | 4 | 4 | 4...\\nLarger than 3 | 1 | 4 | 7 | 8 | 8 | 8 | 8...\\n\\n# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} presses\\n * @return {number}\\n */\\nvar flipLights = function(n, presses) {\\n    if (presses === 0) {\\n      return 1;\\n    } else if (n === 1) {\\n      return 2;\\n    } else if (n === 2) {\\n      return presses === 1 ? 3 : 4;\\n    } else {\\n      return presses === 1 ? 4 : presses === 2 ? 7 : 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} presses\\n * @return {number}\\n */\\nvar flipLights = function(n, presses) {\\n    if (presses === 0) {\\n      return 1;\\n    } else if (n === 1) {\\n      return 2;\\n    } else if (n === 2) {\\n      return presses === 1 ? 3 : 4;\\n    } else {\\n      return presses === 1 ? 4 : presses === 2 ? 7 : 8;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3463933,
                "title": "one-image-to-illustrate-the-finite-state-machine",
                "content": "# Intuition\\n1, any two same buttons(operations) lead to the origin state\\ne.g. button1 + button1 = nothing changed\\n2, As to the former 3 operations, any two operations lead to the third operation. e.g. button1 + button2 = button3\\n\\nobserve the image below: \\n![image.png](https://assets.leetcode.com/users/images/e05a58bc-fb9d-44cb-a599-d99672c64fe2_1682698761.0383983.png)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\n// fi + fi = nil, i=1,2,3,4\\n// f1 + f2 = f3, f2 + f3 = f1, f1 + f3 = f2\\n// so, there are 8 situations, which are\\n// nil, f1, f2, f3, f4, f1+f4, f2+f4, f3+f4\\nfunc flipLights(n int, presses int) int {\\n    if presses == 0 {return 1}\\n    if n == 1 {return 2}\\n    if n == 2 {\\n        if presses == 1 {return 3}\\n        return 4\\n    }\\n    if presses == 1 {return 4}\\n    if presses == 2 {return 7}\\n    return 8\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// fi + fi = nil, i=1,2,3,4\\n// f1 + f2 = f3, f2 + f3 = f1, f1 + f3 = f2\\n// so, there are 8 situations, which are\\n// nil, f1, f2, f3, f4, f1+f4, f2+f4, f3+f4\\nfunc flipLights(n int, presses int) int {\\n    if presses == 0 {return 1}\\n    if n == 1 {return 2}\\n    if n == 2 {\\n        if presses == 1 {return 3}\\n        return 4\\n    }\\n    if presses == 1 {return 4}\\n    if presses == 2 {return 7}\\n    return 8\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459452,
                "title": "code-in-5-lines-using-conditional-statement-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2 && m==1) return 3;\\n        if(n==2 || m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2 && m==1) return 3;\\n        if(n==2 || m==1) return 4;\\n        if(m==2) return 7;\\n        if(m>=3) return 8;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459260,
                "title": "very-easy-solution",
                "content": "Please UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] LessThan3 = new int[]{1,3,4};\\n        int[] MoreThan2 = new int[]{1,4,7,8};\\n        if(n<3)\\n            return Math.min(1<<n,LessThan3[Math.min(presses,2)]);            \\n        return MoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int[] LessThan3 = new int[]{1,3,4};\\n        int[] MoreThan2 = new int[]{1,4,7,8};\\n        if(n<3)\\n            return Math.min(1<<n,LessThan3[Math.min(presses,2)]);            \\n        return MoreThan2[Math.min(presses,3)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437936,
                "title": "scala",
                "content": "# Code\\n```\\nobject Solution {\\n  def flipLights(n: Int, presses: Int): Int = {\\n    type Status = Set[Int] // contains indexes of bulbes on\\n    \\n    val allOn: Status = Set.from(1 to n)\\n    \\n    def flip(s: Status)(c: Int => Boolean): Status = allOn.filter {\\n      case b if s(b) => !c(b)\\n      case b => c(b)\\n    }\\n    \\n    def button1(s: Status): Status = flip(s)(_ => true)\\n    def button2(s: Status): Status = flip(s)(_ % 2 == 0)\\n    def button3(s: Status): Status = flip(s)(_ % 2 == 1)\\n    def button4(s: Status): Status = flip(s)(_ % 3 == 1)\\n\\n    val mem = scala.collection.mutable.Map[Status, Set[Status]]()\\n\\n    def statusesFrom(s: Status): Set[Status] = {\\n      mem.getOrElseUpdate(s,\\n        Set(button1(s), button2(s), button3(s), button4(s))\\n      )\\n    }\\n\\n    val statuses = LazyList.iterate(Set(allOn)) {\\n      _.flatMap(statusesFrom)\\n    }\\n\\n    statuses(presses).size\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def flipLights(n: Int, presses: Int): Int = {\\n    type Status = Set[Int] // contains indexes of bulbes on\\n    \\n    val allOn: Status = Set.from(1 to n)\\n    \\n    def flip(s: Status)(c: Int => Boolean): Status = allOn.filter {\\n      case b if s(b) => !c(b)\\n      case b => c(b)\\n    }\\n    \\n    def button1(s: Status): Status = flip(s)(_ => true)\\n    def button2(s: Status): Status = flip(s)(_ % 2 == 0)\\n    def button3(s: Status): Status = flip(s)(_ % 2 == 1)\\n    def button4(s: Status): Status = flip(s)(_ % 3 == 1)\\n\\n    val mem = scala.collection.mutable.Map[Status, Set[Status]]()\\n\\n    def statusesFrom(s: Status): Set[Status] = {\\n      mem.getOrElseUpdate(s,\\n        Set(button1(s), button2(s), button3(s), button4(s))\\n      )\\n    }\\n\\n    val statuses = LazyList.iterate(Set(allOn)) {\\n      _.flatMap(statusesFrom)\\n    }\\n\\n    statuses(presses).size\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3428024,
                "title": "java-intuitive-bfs-with-early-termination-if-converge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. 4 operations are four next states from current state\\n2. each press is one bfs search \\n3. we return the size of the results in the neighbors \\n4. one concern is that if press is big, it soon becomes exponential algorithm and very slow\\n5. will the result become stable?\\n6. let\\'s assume it will be stable, how do we terminate the search once it\\'s stable? Check the result size between each press\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOriginally thought about using int to represent a state, but since n could be large, I decide to go with string.\\nTypical BFS algorithm with some additions:\\na. add a set to check all the children string results to avoid duplicates.\\nb. Between each round of BFS, check the result size, if the size stays the same, it means we reach a stable status, we can return the stable result \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Math.min(4^presses, 4^(n times to stable))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(Math.min(4^presses, 4^(n times to stable))\\n# Code\\n```\\nclass Solution {\\n\\n\\n\\n    public int flipLights(int n, int presses) {\\n\\n        // 4 operations are four next states from current state\\n        // each press is one bfs search \\n        // we return the size of the results in the neighbors \\n        // one concern is that if press is big, it soon becomes exponential algorithm and very slow\\n        // will the result become stable?\\n        // let\\'s assume it will be stable, how do we terminate the search once it\\'s stable?\\n        if(presses == 0) return 1;\\n\\n        String init =  buildOnes(n);\\n    \\n        Queue<String> states = new LinkedList<>();\\n        states.offer(init);\\n\\n        int pressCnt = 0;\\n\\n        HashSet<String> memo = new HashSet<>();\\n\\n     \\n   \\n        while(!states.isEmpty() && pressCnt < presses)\\n        {\\n            int size = states.size();\\n            memo.clear();\\n            for(int i=0; i<size; i++)\\n            {\\n                String cur = states.poll();\\n                for(int j=1; j<=4; j++)\\n                {\\n                    String child = operations(cur, j);\\n                    if(!memo.contains(child))\\n                        {\\n                            memo.add(child);\\n                            states.offer(child);\\n                            //System.out.print(child+\" \");\\n                        }\\n                }\\n                \\n            }\\n            //System.out.println();\\n            if(states.size() == size) return size; // it becomes stable we can return    \\n\\n            pressCnt++;\\n        }\\n\\n        return states.size();\\n\\n    }\\n\\n    private String buildOnes(int n)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            sb.append(\"1\");\\n        return sb.toString();\\n    }\\n\\n    private String operations(String cur, int buttonNum)\\n    {\\n        switch(buttonNum)\\n        {\\n            case 1: return one(cur);\\n            case 2: return two(cur);\\n            case 3: return three(cur);\\n            case 4: return four(cur);\\n            default: break;\\n        }\\n        return cur;\\n    }\\n\\n    private String one(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(char c:cur.toCharArray())\\n        {\\n            if(c==\\'0\\') sb.append(\"1\");\\n            else sb.append(\"0\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    private String two(String cur)\\n    {\\n         StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( (i+1) %2 != 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n    private String three(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( (i+1) %2 == 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n    private String four(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( ((i+1)-1) % 3 != 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n\\n    public int flipLights(int n, int presses) {\\n\\n        // 4 operations are four next states from current state\\n        // each press is one bfs search \\n        // we return the size of the results in the neighbors \\n        // one concern is that if press is big, it soon becomes exponential algorithm and very slow\\n        // will the result become stable?\\n        // let\\'s assume it will be stable, how do we terminate the search once it\\'s stable?\\n        if(presses == 0) return 1;\\n\\n        String init =  buildOnes(n);\\n    \\n        Queue<String> states = new LinkedList<>();\\n        states.offer(init);\\n\\n        int pressCnt = 0;\\n\\n        HashSet<String> memo = new HashSet<>();\\n\\n     \\n   \\n        while(!states.isEmpty() && pressCnt < presses)\\n        {\\n            int size = states.size();\\n            memo.clear();\\n            for(int i=0; i<size; i++)\\n            {\\n                String cur = states.poll();\\n                for(int j=1; j<=4; j++)\\n                {\\n                    String child = operations(cur, j);\\n                    if(!memo.contains(child))\\n                        {\\n                            memo.add(child);\\n                            states.offer(child);\\n                            //System.out.print(child+\" \");\\n                        }\\n                }\\n                \\n            }\\n            //System.out.println();\\n            if(states.size() == size) return size; // it becomes stable we can return    \\n\\n            pressCnt++;\\n        }\\n\\n        return states.size();\\n\\n    }\\n\\n    private String buildOnes(int n)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            sb.append(\"1\");\\n        return sb.toString();\\n    }\\n\\n    private String operations(String cur, int buttonNum)\\n    {\\n        switch(buttonNum)\\n        {\\n            case 1: return one(cur);\\n            case 2: return two(cur);\\n            case 3: return three(cur);\\n            case 4: return four(cur);\\n            default: break;\\n        }\\n        return cur;\\n    }\\n\\n    private String one(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(char c:cur.toCharArray())\\n        {\\n            if(c==\\'0\\') sb.append(\"1\");\\n            else sb.append(\"0\");\\n        }\\n        return sb.toString();\\n    }\\n\\n    private String two(String cur)\\n    {\\n         StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( (i+1) %2 != 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n    private String three(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( (i+1) %2 == 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n    private String four(String cur)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n         char[] arr = cur.toCharArray();\\n         for(int i=0; i<arr.length;i++)\\n         {\\n             if( ((i+1)-1) % 3 != 0 )\\n                sb.append(arr[i]);\\n            else\\n            {\\n                if(arr[i] ==\\'0\\') sb.append(\"1\");\\n                else sb.append(\"0\");\\n            }\\n         }\\n         return sb.toString();\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383937,
                "title": "java-minimum-value-in-a-binary-tree-with-unique-values",
                "content": "# Intuition\\nWe can approach this problem by analyzing the effect of each button press on the bulbs and try to find a pattern that emerges as we perform a certain number of presses.\\n# Approach\\n- If the number of presses is 0, then all bulbs remain turned on, and there is only one possible status.\\n- If there is only one bulb, then we can either turn it off or on, so there are two possible statuses.\\n- If there are two bulbs, then we can either flip both bulbs, flip only the even bulb, flip only the odd bulb, or not flip any bulb. If we have only one press, then we can do any of the four operations, so there are three possible statuses. If we have two presses, then we can do two operations that cancel out each other, so we have four possible statuses.\\n- If there are three or more bulbs, then the fourth button is relevant as it flips bulbs with labels 3k + 1. We can use it to flip all the bulbs in a certain pattern, which can be used to generate all possible statuses.\\n\\nWe can derive the following pattern:\\n\\n- If we press the fourth button, then we flip all bulbs with odd labels.\\n- If we press the first button, then we flip all bulbs.\\n- If we press the second button, then we flip all even bulbs.\\n- If we press the third button, then we flip all odd bulbs.\\n\\nUsing the fourth button, we can generate all possible patterns with only odd bulbs turned on. If n >= 3 and presses >= 2, then we can perform the following sequence of operations:\\n\\n- Press button 4 to turn off all bulbs with labels 1, 4, 7, ...\\n- Press button 2 or 3 to toggle all even or odd bulbs, respectively.\\n- Press button 1 to toggle all bulbs.\\n- Press button 2 or 3 to toggle all even or odd bulbs, respectively.\\n\\nThis generates 8 possible statuses. If we have only one press, then we can do any of the four operations, so there are four possible statuses. If we have two presses but n = 2, then there are only four possible statuses as there are no bulbs with odd labels.\\n# Complexity\\n- Time complexity:\\nO(1). The solution performs a constant number of operations to derive the answer.\\n- Space complexity:\\nO(1). The solution does not use any extra data structures that depend on the input size.\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int flipLights(int n, int presses) {\\n        if (presses == 0) {\\n            return 1;\\n        } else if (n == 1) {\\n            return 2;\\n        } else if (n == 2) {\\n            return presses == 1 ? 3 : 4;\\n        } else {\\n            return presses == 1 ? 4 : (presses == 2 ? 7 : 8);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public int flipLights(int n, int presses) {\\n        if (presses == 0) {\\n            return 1;\\n        } else if (n == 1) {\\n            return 2;\\n        } else if (n == 2) {\\n            return presses == 1 ? 3 : 4;\\n        } else {\\n            return presses == 1 ? 4 : (presses == 2 ? 7 : 8);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383078,
                "title": "dfs-solution-recursion-dp",
                "content": "\\n\\n# Code 1\\n```\\n\\nclass Solution {\\npublic:\\n    set<string>st;\\n        string op(int type,string& s){\\n        if(type==0){\\n            for(int i = 0;i<s.length();i++){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==1){\\n            for(int i = 1;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==2){\\n            for(int i = 0;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else{\\n            for(int k = 0;3*k+1<=s.length();k++){\\n                int i = 3*k;\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n    void solve(string s,int presses,unordered_map<string,unordered_map<int,int>>&dp){\\n        if(presses == 0){\\n            st.insert(s);\\n            return;\\n        }\\n\\n        if(dp.count(s) and dp[s].count(presses)) return;\\n\\n        dp[s][presses] = 1;\\n     \\n        solve(op(0,s),presses-1,dp); \\n        solve(op(1,s),presses-1,dp); \\n        solve(op(2,s),presses-1,dp); \\n        solve(op(3,s),presses-1,dp); \\n    }\\n    int flipLights(int n, int presses) {\\n        string s(n,\\'1\\');\\n        unordered_map<string,unordered_map<int,int>>dp;\\n        solve(s,presses,dp);\\n        return st.size();       \\n    }\\n};\\n```\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return m==1 ? 3 : 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        return 8;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    set<string>st;\\n        string op(int type,string& s){\\n        if(type==0){\\n            for(int i = 0;i<s.length();i++){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==1){\\n            for(int i = 1;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else if(type==2){\\n            for(int i = 0;i<s.length();i+=2){\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        else{\\n            for(int k = 0;3*k+1<=s.length();k++){\\n                int i = 3*k;\\n                if(s[i]==\\'1\\') s[i]=\\'0\\';\\n                else s[i]=\\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n    void solve(string s,int presses,unordered_map<string,unordered_map<int,int>>&dp){\\n        if(presses == 0){\\n            st.insert(s);\\n            return;\\n        }\\n\\n        if(dp.count(s) and dp[s].count(presses)) return;\\n\\n        dp[s][presses] = 1;\\n     \\n        solve(op(0,s),presses-1,dp); \\n        solve(op(1,s),presses-1,dp); \\n        solve(op(2,s),presses-1,dp); \\n        solve(op(3,s),presses-1,dp); \\n    }\\n    int flipLights(int n, int presses) {\\n        string s(n,\\'1\\');\\n        unordered_map<string,unordered_map<int,int>>dp;\\n        solve(s,presses,dp);\\n        return st.size();       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return m==1 ? 3 : 4;\\n        if(m==1) return 4;\\n        if(m==2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296699,
                "title": "bfs",
                "content": "```ruby\\ndef flip_lights n, p\\n    s = Set[[1] * n]\\n    p.times do\\n        t = Set.new\\n        s.each do | x |\\n            a, b, c, d = *4.times.map { x.clone }\\n            for i in 0...n\\n                a[i] ^= 1\\n                i.odd? ? b[i] ^= 1 : c[i] ^= 1\\n                d[i] ^= 1 if i % 3 == 0\\n            end\\n            t += Set[a, b, c, d]\\n        end\\n        s == t ? (break) : s = t\\n    end\\n    s.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef flip_lights n, p\\n    s = Set[[1] * n]\\n    p.times do\\n        t = Set.new\\n        s.each do | x |\\n            a, b, c, d = *4.times.map { x.clone }\\n            for i in 0...n\\n                a[i] ^= 1\\n                i.odd? ? b[i] ^= 1 : c[i] ^= 1\\n                d[i] ^= 1 if i % 3 == 0\\n            end\\n            t += Set[a, b, c, d]\\n        end\\n        s == t ? (break) : s = t\\n    end\\n    s.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3214722,
                "title": "python3-interview-feasible-solution",
                "content": "## Inspired by [awice\\'s post](https://leetcode.com/problems/bulb-switcher-ii/solutions/107267/Python-Straightforward-with-Explanation/)\\n\\n### 1. Observations:\\n1. pressing a button twice ->  nothing happen\\n2. buttons order doesn\\'t matter -> `Button1 + Button2` = `Button2 + Button1` \\n\\n### 2. Thought Processes:\\nFor each of the 4 buttons, it will either be pressed or not pressed at the end (pressing twice equal to nothing happen). \\n\\nHence, we can construct a list of combinations of whether each button is pressed or not, and then validate if we can get that `combination`, like `(1, 0, 0, 1)` meaning `Button1` and `Button4` are pressed. We only have 16 such combinations (2 ** 4)\\n\\nAnd how are we gonna validate the combination? \\n1. `sum(combination) % 2` == `presses % 2` \\n\\n\\tsum of all presses in the combination should be the same as `presses`, ignoring the case pressing the same button even times.\\n\\t\\n\\tLet say testcase `presses=6` and we are validating `combination=(2, 1, 3, 0)`.  We can reduce the combination to `(0, 1, 1, 0)` (`Observation 1`). In this case `sum(combination) % 2` = `presses % 2` = `0`, hence, this should be a potential valid combination.\\n\\t\\n2.  `sum(combination`) <= `presses` \\n\\tif `presses` <= 4, we should not expect more than `presses` buttons being pressed in the combination.\\n\\n\\n\\n#### 3. Code\\n```python\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \"\"\"\\n        https://leetcode.com/problems/bulb-switcher-ii/discuss/107267\\n        \"\"\"\\n        result = set()\\n\\n        # we can find out that the pattern is repeated each 6 bulbs (least common multiple of 2 and 3)\\n        # 1 is light on, and 0 is off for each bulb\\n        # each of the following represents the operation of the 4 buttons\\n        switches = [\\n            int(\\'111111\\'[-n:], 2),\\n            int(\\'101010\\'[-n:], 2),\\n            int(\\'010101\\'[-n:], 2),\\n            int(\\'001001\\'[-n:], 2),\\n        ]\\n\\n        for combination in itertools.product((0, 1), repeat=4):\\n            # validate operation\\n            if sum(combination) % 2 == presses % 2 and sum(combination) <= presses:\\n                # all lights on initially\\n                bulbs = int(\\'111111\\', 2)\\n                for i, op in enumerate(combination):\\n                    if op == 1:\\n                        bulbs ^= switches[i]\\n\\n                result.add(bulbs)\\n        \\n        return len(result)\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \"\"\"\\n        https://leetcode.com/problems/bulb-switcher-ii/discuss/107267\\n        \"\"\"\\n        result = set()\\n\\n        # we can find out that the pattern is repeated each 6 bulbs (least common multiple of 2 and 3)\\n        # 1 is light on, and 0 is off for each bulb\\n        # each of the following represents the operation of the 4 buttons\\n        switches = [\\n            int(\\'111111\\'[-n:], 2),\\n            int(\\'101010\\'[-n:], 2),\\n            int(\\'010101\\'[-n:], 2),\\n            int(\\'001001\\'[-n:], 2),\\n        ]\\n\\n        for combination in itertools.product((0, 1), repeat=4):\\n            # validate operation\\n            if sum(combination) % 2 == presses % 2 and sum(combination) <= presses:\\n                # all lights on initially\\n                bulbs = int(\\'111111\\', 2)\\n                for i, op in enumerate(combination):\\n                    if op == 1:\\n                        bulbs ^= switches[i]\\n\\n                result.add(bulbs)\\n        \\n        return len(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153235,
                "title": "beats-100-0ms-runtime",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int statuses = 0;\\n        if(n==1 && presses > 0){\\n            statuses = n + 1;\\n        }\\n        else if(presses==1 && n < 4){\\n            statuses = n + presses;\\n        }\\n        else if((n == 2 && presses > 0) || (presses == 1 && n >= 4)){\\n            statuses = 4;\\n        }\\n        else if(presses == 2 && n > presses){\\n            statuses = 7;\\n        }\\n        else if(n*presses > 8){\\n            statuses = 8;\\n        }\\n        else if(n*presses < 8 && n > presses){\\n            statuses = n*presses + 1;\\n        }\\n        else if(n*presses <= 8 && n <= presses){\\n            statuses = 4;\\n        }\\n        else{\\n            return statuses = 1;\\n        }\\n        return statuses;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int presses) {\\n        int statuses = 0;\\n        if(n==1 && presses > 0){\\n            statuses = n + 1;\\n        }\\n        else if(presses==1 && n < 4){\\n            statuses = n + presses;\\n        }\\n        else if((n == 2 && presses > 0) || (presses == 1 && n >= 4)){\\n            statuses = 4;\\n        }\\n        else if(presses == 2 && n > presses){\\n            statuses = 7;\\n        }\\n        else if(n*presses > 8){\\n            statuses = 8;\\n        }\\n        else if(n*presses < 8 && n > presses){\\n            statuses = n*presses + 1;\\n        }\\n        else if(n*presses <= 8 && n <= presses){\\n            statuses = 4;\\n        }\\n        else{\\n            return statuses = 1;\\n        }\\n        return statuses;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152375,
                "title": "c-100-beats-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nint flipLights(int n, int presses)\\n{\\n    if(presses==0)  {return 1;}\\n    if(n==1)    {return 2;}\\n    if(n==2 && presses==1)  {return 3;}\\n    if(n==2 || presses==1)  {return 4;}\\n    if(presses==2)  {return 7;}\\n    if(presses>=3)  {return 8;}\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint flipLights(int n, int presses)\\n{\\n    if(presses==0)  {return 1;}\\n    if(n==1)    {return 2;}\\n    if(n==2 && presses==1)  {return 3;}\\n    if(n==2 || presses==1)  {return 4;}\\n    if(presses==2)  {return 7;}\\n    if(presses>=3)  {return 8;}\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152363,
                "title": "c-c-o-1-time-and-space-using-if-condition",
                "content": "\\n# *Complexity*\\n- *Time complexity*:\\n`O(1)`\\n- *Space complexity*:\\n`O(1)`\\n\\n# *Code*\\n```\\nclass Solution\\n{\\npublic:\\n    int flipLights(int x, int y)\\n    {\\n        if(y == 0)\\n        {\\n            return 1;\\n        }\\n        if(x == 1)\\n        {\\n            return 2;\\n        }\\n\\n        if(x == 2 && y == 1)\\n        {\\n            return 3;\\n        }\\n        if(x == 2 || y == 1)\\n        {\\n            return 4;\\n        }\\n        if(y == 2)\\n        {\\n            return 7;\\n        }\\n        if(y >= 3)\\n        {\\n            return 8;\\n        }\\n        return 0;\\n    }\\n};\\n```\\nDo upvote for this\\uD83D\\uDE03\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int flipLights(int x, int y)\\n    {\\n        if(y == 0)\\n        {\\n            return 1;\\n        }\\n        if(x == 1)\\n        {\\n            return 2;\\n        }\\n\\n        if(x == 2 && y == 1)\\n        {\\n            return 3;\\n        }\\n        if(x == 2 || y == 1)\\n        {\\n            return 4;\\n        }\\n        if(y == 2)\\n        {\\n            return 7;\\n        }\\n        if(y >= 3)\\n        {\\n            return 8;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095593,
                "title": "python-one-line-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust try small cases and find a pattern. \\n\\n# Complexity\\n- Time complexity: ```O(1)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self,n,p):\\n        return [[1,1,1],[2,3,4],[2,4,7],[2,4,8]][min(p,3)][min(n-1,2)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```O(1)```\n```O(1)```\n```\\nclass Solution:\\n    def flipLights(self,n,p):\\n        return [[1,1,1],[2,3,4],[2,4,7],[2,4,8]][min(p,3)][min(n-1,2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067989,
                "title": "brute-forcing-2-4-possibilities",
                "content": "```\\nclass Solution {\\npublic:\\n    void fill( vector<string> &allpossi,string &s)\\n    {\\n        if (s.size()==4)\\n        {\\n            allpossi.push_back(s);\\n            return;\\n        }\\n        s.push_back(\\'0\\');\\n        fill(allpossi,s);\\n        s.pop_back();\\n        s.push_back(\\'1\\');\\n        fill(allpossi,s);\\n        s.pop_back();\\n    }\\n    \\n    void change(string &t,int k)\\n    {\\n        if (k==0)\\n        {\\n            for (int i=0;i<t.size();i++)\\n            {\\n                if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n            }\\n        }\\n        else if (k==1)\\n        {\\n            \\n            \\n             for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%2==0)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n        }\\n        else if (k==2)\\n        {\\n            \\n            \\n            \\n            \\n          for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%2==1)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        else if (k==3)\\n        {\\n            for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%3==1)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n        }\\n    \\n    }\\n    \\n    int flipLights(int n, int presses) {\\n        // pressing a specific button two times is equivalent to not pressing it at all\\n        unordered_set<string> ans;\\n\\n        \\n        string s=\"\";\\n        vector<string> allpossi;\\n        fill(allpossi,s);\\n        \\n         s=\"\";\\n         for (int i=0;i<n;i++)\\n        {\\n            s+=\\'1\\';\\n        }\\n       // for (auto x:allpossi)\\n         //   cout<<x<<endl;\\n       \\n      for (int i=0;i<allpossi.size();i++)\\n      {\\n          string temp=s;\\n          string ps=allpossi[i];\\n          int count=0;\\n          for (int k=0;k<ps.size();k++)\\n          {\\n              if (ps[k]==\\'1\\')\\n                  count++;\\n          }\\n          if (count>presses)\\n              continue;\\n          if (count==0)\\n          {\\n              cout<<i<<\" \"<<temp<<endl;\\n              if (presses%2==0)\\n              {\\n                  ans.insert(temp);\\n              }\\n              continue;\\n          }\\n          \\n          for (int k=0;k<ps.size();k++)\\n          {\\n              if (ps[k]==\\'1\\')\\n              {\\n                  change(temp,k);\\n                 \\n              }\\n          }\\n       //   if (count==presses) // this is wrong\\n       //   ans.insert(temp);\\n          \\n          \\n          if (count==presses)\\n          {\\n              ans.insert(temp);\\n              continue;\\n          }  //count<presses\\n          \\n          if (presses%2==0)\\n          {\\n              \\n              if(count%2==0)\\n              {\\n                 ans.insert(temp); \\n              }\\n          }\\n          else\\n          {\\n              \\n              ans.insert(temp);\\n              \\n          }\\n          \\n          \\n          \\n      }\\n        \\n      for (auto x:ans)\\n          cout<<x<<endl;\\n        \\n        \\n        return ans.size();\\n            \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void fill( vector<string> &allpossi,string &s)\\n    {\\n        if (s.size()==4)\\n        {\\n            allpossi.push_back(s);\\n            return;\\n        }\\n        s.push_back(\\'0\\');\\n        fill(allpossi,s);\\n        s.pop_back();\\n        s.push_back(\\'1\\');\\n        fill(allpossi,s);\\n        s.pop_back();\\n    }\\n    \\n    void change(string &t,int k)\\n    {\\n        if (k==0)\\n        {\\n            for (int i=0;i<t.size();i++)\\n            {\\n                if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n            }\\n        }\\n        else if (k==1)\\n        {\\n            \\n            \\n             for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%2==0)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n        }\\n        else if (k==2)\\n        {\\n            \\n            \\n            \\n            \\n          for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%2==1)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        else if (k==3)\\n        {\\n            for (int i=0;i<t.size();i++)\\n            {\\n                if ((i+1)%3==1)\\n                {\\n                    \\n                    if (t[i]==\\'0\\')\\n                    t[i]=\\'1\\';\\n                    else\\n                    t[i]=\\'0\\';\\n                    \\n                }\\n            }\\n            \\n        }\\n    \\n    }\\n    \\n    int flipLights(int n, int presses) {\\n        // pressing a specific button two times is equivalent to not pressing it at all\\n        unordered_set<string> ans;\\n\\n        \\n        string s=\"\";\\n        vector<string> allpossi;\\n        fill(allpossi,s);\\n        \\n         s=\"\";\\n         for (int i=0;i<n;i++)\\n        {\\n            s+=\\'1\\';\\n        }\\n       // for (auto x:allpossi)\\n         //   cout<<x<<endl;\\n       \\n      for (int i=0;i<allpossi.size();i++)\\n      {\\n          string temp=s;\\n          string ps=allpossi[i];\\n          int count=0;\\n          for (int k=0;k<ps.size();k++)\\n          {\\n              if (ps[k]==\\'1\\')\\n                  count++;\\n          }\\n          if (count>presses)\\n              continue;\\n          if (count==0)\\n          {\\n              cout<<i<<\" \"<<temp<<endl;\\n              if (presses%2==0)\\n              {\\n                  ans.insert(temp);\\n              }\\n              continue;\\n          }\\n          \\n          for (int k=0;k<ps.size();k++)\\n          {\\n              if (ps[k]==\\'1\\')\\n              {\\n                  change(temp,k);\\n                 \\n              }\\n          }\\n       //   if (count==presses) // this is wrong\\n       //   ans.insert(temp);\\n          \\n          \\n          if (count==presses)\\n          {\\n              ans.insert(temp);\\n              continue;\\n          }  //count<presses\\n          \\n          if (presses%2==0)\\n          {\\n              \\n              if(count%2==0)\\n              {\\n                 ans.insert(temp); \\n              }\\n          }\\n          else\\n          {\\n              \\n              ans.insert(temp);\\n              \\n          }\\n          \\n          \\n          \\n      }\\n        \\n      for (auto x:ans)\\n          cout<<x<<endl;\\n        \\n        \\n        return ans.size();\\n            \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3044902,
                "title": "identify-the-states-of-bulb-for-n-1-2-3-o-1",
                "content": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \"\"\"\\n        the trick to problem is that only 3 bulbs are indicative of all the n bulbs\\n        this is because, sequence repeats every 3 bulbs\\n\\n        if n>3, then we can consider sequence of 3 bubls since that will reprsent the \\n        entire sequence\\n\\n        (1, 1, 1) -> (0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 1) [for n>=3, k=1, ans=4]\\n\\n        (0, 0, 0) -> (1, 1, 1), (1, 0, 1), (0, 1, 0), (1, 0, 0)\\n        (0, 1, 0) -> (1, 0, 1), (1, 1, 1), (0, 0, 0), (1, 1, 0)\\n        (1, 0, 1) -> (0, 1, 0), (0, 0, 0), (1, 1, 1), (0, 0, 1)\\n        (0, 1, 1) -> (1, 0, 0), (1, 1, 0), (0, 0, 1), (1, 1, 1) [for n>=3, k=2, ans=7]\\n\\n        for n>=3, k>=3, there will be one more state added i.e. (0, 1, 1)\\n        along with the other 7 states, so ans=8\\n\\n        when n = 1, k>=1\\n        (1) -> (0), (1), (0), (0) [for n=1, for every k, ans=2]\\n\\n        when n=2, k=1\\n        (1,1) -> (0, 0), (1, 0), (0, 1), (0, 1) [for n=2, k=1, ans=3]\\n\\n        (0, 0) -> (1, 1), (1, 0), (0, 1), (0, 0)\\n        (1, 0) -> (0, 1), (1, 1), (0, 0), (0, 0)\\n        (0, 1) -> (1, 0), (1, 1), (0, 0), (1, 1) [for n=2, k>=2, ans=4]\\n        \"\"\"\\n        if presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if presses==1:\\n                return 3\\n            else:\\n                return 4\\n        if n >= 3:\\n            if presses == 1:\\n                return 4\\n            elif presses == 2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \"\"\"\\n        the trick to problem is that only 3 bulbs are indicative of all the n bulbs\\n        this is because, sequence repeats every 3 bulbs\\n\\n        if n>3, then we can consider sequence of 3 bubls since that will reprsent the \\n        entire sequence\\n\\n        (1, 1, 1) -> (0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 1) [for n>=3, k=1, ans=4]\\n\\n        (0, 0, 0) -> (1, 1, 1), (1, 0, 1), (0, 1, 0), (1, 0, 0)\\n        (0, 1, 0) -> (1, 0, 1), (1, 1, 1), (0, 0, 0), (1, 1, 0)\\n        (1, 0, 1) -> (0, 1, 0), (0, 0, 0), (1, 1, 1), (0, 0, 1)\\n        (0, 1, 1) -> (1, 0, 0), (1, 1, 0), (0, 0, 1), (1, 1, 1) [for n>=3, k=2, ans=7]\\n\\n        for n>=3, k>=3, there will be one more state added i.e. (0, 1, 1)\\n        along with the other 7 states, so ans=8\\n\\n        when n = 1, k>=1\\n        (1) -> (0), (1), (0), (0) [for n=1, for every k, ans=2]\\n\\n        when n=2, k=1\\n        (1,1) -> (0, 0), (1, 0), (0, 1), (0, 1) [for n=2, k=1, ans=3]\\n\\n        (0, 0) -> (1, 1), (1, 0), (0, 1), (0, 0)\\n        (1, 0) -> (0, 1), (1, 1), (0, 0), (0, 0)\\n        (0, 1) -> (1, 0), (1, 1), (0, 0), (1, 1) [for n=2, k>=2, ans=4]\\n        \"\"\"\\n        if presses == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if presses==1:\\n                return 3\\n            else:\\n                return 4\\n        if n >= 3:\\n            if presses == 1:\\n                return 4\\n            elif presses == 2:\\n                return 7\\n            else:\\n                return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979329,
                "title": "python3-o-1-time-and-space-complexity",
                "content": "I claim that, if presses and n are both at least 3, the return is always 8.\\n\\nWith buttons 1, 2, and 3 we have 4 obvious possible states:\\n\\n- all off\\n- all on\\n- evens only\\n- odds only\\n\\nIf we apply button 4 to each of the above we can get:\\n- [3k + 1] are on\\n- [3k + 1] are off\\n- [3k + 1] are on for odds only; other evens are lit\\n- [3k + 1] are on for evens only; other odds are lit\\n\\nFrom each of these states, it is clear that pressing \\'4\\' from here will just return to the state before it was pressed. Under each of the four conditions, what happens when button 1, 2, or 3 is pressed?\\n\\n- first condition above:\\n    - Button 1: toggles to second condition\\n    - Button 2: toggles to the third condition\\n    - Button 3: toggles to the fourth condition\\n- second condition:\\n    - Button 1: toggles to first condition\\n    - Button 2: toggles to fourth condition\\n    - Button 3: toggles to third condition\\n- third condition:\\n    - Button 1: toggles to fourth condition\\n    - Button 2: toggles to first condition\\n    - Button 3: toggles to second condition\\n- fourth condition:\\n    - Button 1: toggles to third condition\\n    - Button 2: toggles to second condition\\n    - Button 3: toggles to the first conditions\\n\\nSo there are 8 possible states achievable given any number of button presses (at least 3) when there are at least 3 bulbs. Per the above, each of these states can be achieved by at most 3 presses.\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0: return 1\\n        if n == 1: return 2\\n        elif n == 2: \\n            if presses == 1:\\n                return 3\\n            else: \\n                return 4\\n        elif presses == 1: return 4\\n        elif presses == 2: return 7\\n        else: return 8\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0: return 1\\n        if n == 1: return 2\\n        elif n == 2: \\n            if presses == 1:\\n                return 3\\n            else: \\n                return 4\\n        elif presses == 1: return 4\\n        elif presses == 2: return 7\\n        else: return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881799,
                "title": "python3-modified-bfs",
                "content": "# Intuition\\nRepresent \"state\" with 4 lightbulbs, then just flip them and see what we get.  If there\\'s less lightbulbs than 4, then just hide them with a bitmask (bm)\\n\\nPresses bumps up against the pidgeonhole problem.  The 5th toggle, necessarily is going to be reverting a previous button press, therefore we can infer that any state achieved by an EVEN number >=4 can also be achieved by exactly 4 and any odd number higher than 4 can be represented by 5.  So there\\'s no need to go further than that.\\n\\nops variable represents bits corresponding to which lightbulbs will be toggled with each button press.  4 buttons = 4 operations\\n\\n# Note\\nYes, I am aware I could copy my output and put it into a lookup table for O(1), I just don\\'t find that as interesting\\n\\n# Code\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(4, n)\\n        if presses > 4:\\n            presses = 4 + presses % 2\\n\\n        ops = [15, 5, 10, 9]\\n\\n        items = [(0, 0)]\\n        \\n        found = set()\\n\\n        bm = (1<<n) - 1\\n\\n        while items:\\n            p, s = items.pop(0)\\n            if p == presses:\\n                found.add(s & bm)\\n            else:\\n                for o in ops:\\n                    items.append((p+1, s^o))\\n        \\n        return len(found)\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(4, n)\\n        if presses > 4:\\n            presses = 4 + presses % 2\\n\\n        ops = [15, 5, 10, 9]\\n\\n        items = [(0, 0)]\\n        \\n        found = set()\\n\\n        bm = (1<<n) - 1\\n\\n        while items:\\n            p, s = items.pop(0)\\n            if p == presses:\\n                found.add(s & bm)\\n            else:\\n                for o in ops:\\n                    items.append((p+1, s^o))\\n        \\n        return len(found)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694529,
                "title": "python-o-1-solution-faster-than-84",
                "content": "```\\n\\'\\'\\'\\nWe only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8.\\nThe four buttons:\\n\\nFlip all the lights.\\nFlip lights with even numbers.\\nFlip lights with odd numbers.\\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n1 + 2 --> 3, 1 + 3 --> 2, 2 + 3 --> 1\\nSo, there are only 8 cases.\\n\\nAll_on, 1, 2, 3, 4, 1+4, 2+4, 3+4\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0: \\n            return 1\\n        if n == 1: \\n            return 2\\n        if n == 2 and presses == 1: \\n            return 3\\n        if n == 2: \\n            return 4\\n        if presses == 1: \\n            return 4\\n        if presses == 2: \\n            return 7\\n        if presses >= 3: \\n            return 8\\n        return 8\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\'\\'\\'\\nWe only need to consider special cases which n<=2 and m < 3. When n >2 and m >=3, the result is 8.\\nThe four buttons:\\n\\nFlip all the lights.\\nFlip lights with even numbers.\\nFlip lights with odd numbers.\\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\nIf we use button 1 and 2, it equals to use button 3.\\nSimilarly...\\n\\n1 + 2 --> 3, 1 + 3 --> 2, 2 + 3 --> 1\\nSo, there are only 8 cases.\\n\\nAll_on, 1, 2, 3, 4, 1+4, 2+4, 3+4\\n\\nAnd we can get all the cases, when n>2 and m>=3.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        if presses == 0: \\n            return 1\\n        if n == 1: \\n            return 2\\n        if n == 2 and presses == 1: \\n            return 3\\n        if n == 2: \\n            return 4\\n        if presses == 1: \\n            return 4\\n        if presses == 2: \\n            return 7\\n        if presses >= 3: \\n            return 8\\n        return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631375,
                "title": "c-amazing-question-with-ad-hoc-o-1-solution",
                "content": "Great question indeed.\\n\\nHere\\'s the logic:\\n\\nLet 0 = switched off, 1 = switched on.\\n\\n* You don\\'t have to simulate the entire process (e.g. press buttons 1000 times, for each time, randomly select button 1 to 4).\\n\\n* Instead, notice the **base cases**: \\n\\n\\t1. If you press 1 button **even** number of times (e.g. 0, 2, 4, ...), **the effect cancelled out**. (on->off->on->off...->on->off). So, the initial state (all switched off) = \"00...000\" is possible.\\n\\t2. In contrast, If you press 1 button **odd** number of times, it is **equivalent to pressing 1 of the four buttons 1 time.**\\n\\n* Next, you shall notice that you can press 2, 3 or 4 **distinct** buttons odd number of times to create **distinct** states. The exact figure of pressing button one to four is irrelevant.\\n\\n\\t* For example, if you have a press sequence like \"11233223321244\", that\\'s equivalent to pressing \"12\". \\n\\n* Also, Recall simple combination, 4C2 = 6, 4C3 = 4, 4C4 = 1.\\n\\n* And notices that:\\n\\n\\t1. If the **even number of counts >= 2**, then you can press two buttons odd number of times.\\n\\ta. For example, if number of counts = 4, you can press one button 3 times, and the second button 1 time.\\n\\nBased on all those rules, you can derive the conditionals easily.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    set<string> res;\\n    string opt1(string s) {\\n        for (int i = 0; i < s.length(); i++) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt2(string s) {\\n        for (int i = 0; i < s.length(); i+=2) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt3(string s) {\\n        for (int i = 1; i < s.length(); i+=2) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt4(string s) {\\n        int k;\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) { k = 3 * i; if (k >= len) { break; } s[k] = s[k] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    int flipLights(int n, int p) {\\n        string init(n, \\'0\\');\\n        res.clear();\\n        if (p == 0)\\n            return 1;\\n        if ((p & 1) == 0) {\\n            res.insert(init);\\n        }\\n        if ((p & 1) != 0) {\\n            res.insert(opt1(init));\\n            res.insert(opt2(init));\\n            res.insert(opt3(init));\\n            res.insert(opt4(init));\\n        }\\n        if (p >= 2) {\\n            if ((p >= 2 && p % 2 == 0 && ((p / 2) & 1) != 0) || \\n                (p >= 4 && ((p - 2) & 1) == 0) ||\\n                (p >= 6 && ((p - 4) & 1) == 0)) {\\n                res.insert(opt2(opt1(init)));\\n                res.insert(opt3(opt1(init)));\\n                res.insert(opt4(opt1(init)));\\n                res.insert(opt3(opt2(init)));\\n                res.insert(opt4(opt2(init)));\\n                res.insert(opt4(opt3(init)));\\n            }\\n        }\\n        if (p >= 3 && (p & 1) != 0) {\\n            res.insert(opt3(opt2(opt1(init))));\\n            res.insert(opt4(opt2(opt1(init))));\\n            res.insert(opt4(opt3(opt1(init))));\\n            res.insert(opt4(opt3(opt2(init))));            \\n        }\\n        if (p >= 4) {\\n            if ((p % 4 == 0 && ((p / 4) & 1) != 0) ||\\n                (((p - 3) & 1) != 0) ||\\n                (((p - 2) & 1) == 0) ||\\n                (((p - 1) & 1) != 0)) {\\n                res.insert(opt4(opt3(opt2(opt1(init)))));\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    set<string> res;\\n    string opt1(string s) {\\n        for (int i = 0; i < s.length(); i++) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt2(string s) {\\n        for (int i = 0; i < s.length(); i+=2) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt3(string s) {\\n        for (int i = 1; i < s.length(); i+=2) { s[i] = s[i] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    string opt4(string s) {\\n        int k;\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) { k = 3 * i; if (k >= len) { break; } s[k] = s[k] == \\'0\\' ? \\'1\\' : \\'0\\'; }\\n        return s;\\n    }\\n    int flipLights(int n, int p) {\\n        string init(n, \\'0\\');\\n        res.clear();\\n        if (p == 0)\\n            return 1;\\n        if ((p & 1) == 0) {\\n            res.insert(init);\\n        }\\n        if ((p & 1) != 0) {\\n            res.insert(opt1(init));\\n            res.insert(opt2(init));\\n            res.insert(opt3(init));\\n            res.insert(opt4(init));\\n        }\\n        if (p >= 2) {\\n            if ((p >= 2 && p % 2 == 0 && ((p / 2) & 1) != 0) || \\n                (p >= 4 && ((p - 2) & 1) == 0) ||\\n                (p >= 6 && ((p - 4) & 1) == 0)) {\\n                res.insert(opt2(opt1(init)));\\n                res.insert(opt3(opt1(init)));\\n                res.insert(opt4(opt1(init)));\\n                res.insert(opt3(opt2(init)));\\n                res.insert(opt4(opt2(init)));\\n                res.insert(opt4(opt3(init)));\\n            }\\n        }\\n        if (p >= 3 && (p & 1) != 0) {\\n            res.insert(opt3(opt2(opt1(init))));\\n            res.insert(opt4(opt2(opt1(init))));\\n            res.insert(opt4(opt3(opt1(init))));\\n            res.insert(opt4(opt3(opt2(init))));            \\n        }\\n        if (p >= 4) {\\n            if ((p % 4 == 0 && ((p / 4) & 1) != 0) ||\\n                (((p - 3) & 1) != 0) ||\\n                (((p - 2) & 1) == 0) ||\\n                (((p - 1) & 1) != 0)) {\\n                res.insert(opt4(opt3(opt2(opt1(init)))));\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615933,
                "title": "python-top-down-dp",
                "content": "```\\nfrom functools import cache\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        state = tuple([True]*min(6, n))\\n        states = set()\\n        def flip(v, idxs):\\n            for i in idxs:\\n                v[i] = not v[i]\\n        @cache\\n        def dfs(v, press_cnt):\\n            if press_cnt == presses:\\n                if v not in states: \\n                    states.add(v)\\n                return\\n            w = list(v)\\n            flip(w, range(len(w)))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(0,len(w),2))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(1,len(w),2))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(0,len(w),3))\\n            dfs(tuple(w), press_cnt + 1)\\n        dfs(state, 0)\\n        return len(states)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        state = tuple([True]*min(6, n))\\n        states = set()\\n        def flip(v, idxs):\\n            for i in idxs:\\n                v[i] = not v[i]\\n        @cache\\n        def dfs(v, press_cnt):\\n            if press_cnt == presses:\\n                if v not in states: \\n                    states.add(v)\\n                return\\n            w = list(v)\\n            flip(w, range(len(w)))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(0,len(w),2))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(1,len(w),2))\\n            dfs(tuple(w), press_cnt + 1)\\n            w = list(v)\\n            flip(w, range(0,len(w),3))\\n            dfs(tuple(w), press_cnt + 1)\\n        dfs(state, 0)\\n        return len(states)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2586762,
                "title": "bulb-switcher-easy-easy-approch-best-solution",
                "content": "class Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 3 + (p > 1);\\n        }\\n        if (p == 1) {\\n            return 4;\\n        }\\n        if (p == 2) {\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2448655,
                "title": "bulb-switcher-ii-0ms",
                "content": "\\n    public int flipLights(int n, int p) {\\n    if (p == 0) \\n      return 1;\\n    if (n == 1)\\n      return 2;\\n    if (n == 2){\\n        if(p==1)\\n            return 3;\\n        return 4;\\n    }\\n    if (p== 1)\\n      return 4;\\n    else{\\n        if(p==2)\\n            return 7;\\n        return 8;\\n    }\\n  }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int flipLights(int n, int p) {\\n    if (p == 0) \\n      return 1;\\n    if (n == 1)\\n      return 2;\\n    if (n == 2){\\n        if(p==1)\\n            return 3;\\n        return 4;\\n    }\\n    if (p== 1)\\n      return 4;\\n    else{\\n        if(p==2)\\n            return 7;\\n        return 8;\\n    }\\n  }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2437696,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 3 + (p > 1);\\n        }\\n        if (p == 1) {\\n            return 4;\\n        }\\n        if (p == 2) {\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int p) {\\n        if (p == 0) {\\n            return 1;\\n        }\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 3 + (p > 1);\\n        }\\n        if (p == 1) {\\n            return 4;\\n        }\\n        if (p == 2) {\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426754,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  int flipLights(const int n, const int presses) {\\n    if (presses == 0) {\\n      /**\\n       * all bulbs are turned on\\n       */\\n      return 1;\\n    }\\n    if (n == 1) {\\n      /**\\n       * the only bulb is turned on or off, since any button can be pressed at least once\\n       */\\n      return 2;\\n    }\\n    if (n == 2) {\\n      /**\\n       * 1. if `presses` is `1`, pressing button 3 and pressing button 4 have the same effect,\\n       *    so the number of different possible statuses after performing one button press is 3,\\n       *    that is i) press the button 1, ii) press the button 2, iii) press the button 3\\n       * 2. if `presses` is `2`, all 4 different possible statuses can be achieved finally.\\n       */\\n      return presses == 1 ? 3 : 4;\\n    }\\n    if (presses == 1) {\\n      /**\\n       * 1. press button 1 once\\n       * 2. press button 2 once\\n       * 3. press button 3 once\\n       * 4. press button 4 once\\n       */\\n      return 4;\\n    }\\n    /**\\n     * there are 8 possible statuses\\n     * 1. all bulbs are turned on\\n     * 2. press button 1\\n     * 3. press button 2\\n     * 4. press button 3\\n     * 5. press button 4\\n     * 6. press button 1 and 4\\n     * 7. press button 2 and 4\\n     * 8. press button 3 and 4\\n     *\\n     * a) if `presses` is 2, all 8 possible statuses except `5` can be achieved\\n     * b) if `presses` is greater than 2, all 8 possible statuses can be achieved\\n     */\\n    return presses == 2 ? 7 : 8;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  int flipLights(const int n, const int presses) {\\n    if (presses == 0) {\\n      /**\\n       * all bulbs are turned on\\n       */\\n      return 1;\\n    }\\n    if (n == 1) {\\n      /**\\n       * the only bulb is turned on or off, since any button can be pressed at least once\\n       */\\n      return 2;\\n    }\\n    if (n == 2) {\\n      /**\\n       * 1. if `presses` is `1`, pressing button 3 and pressing button 4 have the same effect,\\n       *    so the number of different possible statuses after performing one button press is 3,\\n       *    that is i) press the button 1, ii) press the button 2, iii) press the button 3\\n       * 2. if `presses` is `2`, all 4 different possible statuses can be achieved finally.\\n       */\\n      return presses == 1 ? 3 : 4;\\n    }\\n    if (presses == 1) {\\n      /**\\n       * 1. press button 1 once\\n       * 2. press button 2 once\\n       * 3. press button 3 once\\n       * 4. press button 4 once\\n       */\\n      return 4;\\n    }\\n    /**\\n     * there are 8 possible statuses\\n     * 1. all bulbs are turned on\\n     * 2. press button 1\\n     * 3. press button 2\\n     * 4. press button 3\\n     * 5. press button 4\\n     * 6. press button 1 and 4\\n     * 7. press button 2 and 4\\n     * 8. press button 3 and 4\\n     *\\n     * a) if `presses` is 2, all 8 possible statuses except `5` can be achieved\\n     * b) if `presses` is greater than 2, all 8 possible statuses can be achieved\\n     */\\n    return presses == 2 ? 7 : 8;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352345,
                "title": "beats-100-solns-state-diagram-for-understanding",
                "content": "```\\n---------------------------STATE DIAGRAM --------------------------\\n\\na* means a some p times (aaa...a)\\n\\n0* --on step 1-->1*\\n0* --on step 2-->(01)*\\n0* --on step 3-->(10)*\\n0* --on step 4-->(100)*\\n\\n1* --on step 1-->0*\\n1* --on step 2-->(10)*\\n1* --on step 3-->(01)*\\n1* --on step 4-->(011)*\\n\\n(01)* --on step 1-->(10)*\\n(01)* --on step 2-->(0)*\\n(01)* --on step 3-->(1)*\\n(01)* --on step 4-->(110001)*\\n\\n(10)* --on step 1-->(01)*\\n(10)* --on step 2-->(1)*\\n(10)* --on step 3-->(0)*\\n(10)* --on step 4-->(001110)*\\n\\n(011)* --on step 1-->(100)*\\n(011)* --on step 2-->(001110)*\\n(011)* --on step 3-->(110001)*\\n(011)* --on step 4-->(1)*\\n\\n(100)* --on step 1-->(011)*\\n(100)* --on step 2-->(110001)*\\n(100)* --on step 3-->(001110)*\\n(100)* --on step 4-->(0)*\\n\\n(110001)* --on step 1-->(001110)*\\n(110001)* --on step 2-->(100)*\\n(110001)* --on step 3-->(011)*\\n(110001)* --on step 4-->(01)*\\n\\n(001110)* --on step 1-->(110001)*\\n(001110)* --on step 2-->(011)*\\n(001110)* --on step 3-->(100)*\\n(001110)* --on step 4-->(10)*\\n\\n\\n\\nso there a 8 states => 0, 1, 01, 10, 100, 011, 110001, 001110\\n\\nif n==1\\n\\t0 = 01 = 011 = 001110\\n\\t1 = 10 = 100 = 110001\\nif n==2\\n\\t0 = 001110\\n\\t1 = 110001\\n\\t01, 10, 100, 011 are distinct states\\nif n>=3\\n\\tall states are different\\nif presses == 0\\n\\tthere is only 1 state i.e 0*\\nif presses == 1\\n\\tu can reach 4 states from 0*\\nif presses == 2\\n\\tu can reach 7 states from 0*\\nif presses == 3\\n\\tu can reach all 8 states from 0*\\nbut remember among these s states some may be common depending on n value as stated above. Have fun!!\\n\\n```\\n\\n```\\n/*code*/\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k == 0){\\n            return 1;\\n        }\\n        if(n == 1){\\n            return 2;\\n        } else if(n == 2){\\n            if(k == 1){\\n                return 3;\\n            } else {\\n                return 4;                \\n            }\\n        } else {\\n            if(k == 1){\\n                return 4;\\n            } else if(k == 2){\\n                return 7;\\n            }else {\\n                return 8;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n---------------------------STATE DIAGRAM --------------------------\\n\\na* means a some p times (aaa...a)\\n\\n0* --on step 1-->1*\\n0* --on step 2-->(01)*\\n0* --on step 3-->(10)*\\n0* --on step 4-->(100)*\\n\\n1* --on step 1-->0*\\n1* --on step 2-->(10)*\\n1* --on step 3-->(01)*\\n1* --on step 4-->(011)*\\n\\n(01)* --on step 1-->(10)*\\n(01)* --on step 2-->(0)*\\n(01)* --on step 3-->(1)*\\n(01)* --on step 4-->(110001)*\\n\\n(10)* --on step 1-->(01)*\\n(10)* --on step 2-->(1)*\\n(10)* --on step 3-->(0)*\\n(10)* --on step 4-->(001110)*\\n\\n(011)* --on step 1-->(100)*\\n(011)* --on step 2-->(001110)*\\n(011)* --on step 3-->(110001)*\\n(011)* --on step 4-->(1)*\\n\\n(100)* --on step 1-->(011)*\\n(100)* --on step 2-->(110001)*\\n(100)* --on step 3-->(001110)*\\n(100)* --on step 4-->(0)*\\n\\n(110001)* --on step 1-->(001110)*\\n(110001)* --on step 2-->(100)*\\n(110001)* --on step 3-->(011)*\\n(110001)* --on step 4-->(01)*\\n\\n(001110)* --on step 1-->(110001)*\\n(001110)* --on step 2-->(011)*\\n(001110)* --on step 3-->(100)*\\n(001110)* --on step 4-->(10)*\\n\\n\\n\\nso there a 8 states => 0, 1, 01, 10, 100, 011, 110001, 001110\\n\\nif n==1\\n\\t0 = 01 = 011 = 001110\\n\\t1 = 10 = 100 = 110001\\nif n==2\\n\\t0 = 001110\\n\\t1 = 110001\\n\\t01, 10, 100, 011 are distinct states\\nif n>=3\\n\\tall states are different\\nif presses == 0\\n\\tthere is only 1 state i.e 0*\\nif presses == 1\\n\\tu can reach 4 states from 0*\\nif presses == 2\\n\\tu can reach 7 states from 0*\\nif presses == 3\\n\\tu can reach all 8 states from 0*\\nbut remember among these s states some may be common depending on n value as stated above. Have fun!!\\n\\n```\n```\\n/*code*/\\nclass Solution {\\npublic:\\n    int flipLights(int n, int k) {\\n        if(k == 0){\\n            return 1;\\n        }\\n        if(n == 1){\\n            return 2;\\n        } else if(n == 2){\\n            if(k == 1){\\n                return 3;\\n            } else {\\n                return 4;                \\n            }\\n        } else {\\n            if(k == 1){\\n                return 4;\\n            } else if(k == 2){\\n                return 7;\\n            }else {\\n                return 8;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342649,
                "title": "simple-swift-solution-with-explanation-beats-100",
                "content": "## Code \\n\\n```\\nclass Solution {\\n    func flipLights(_ n: Int, _ presses: Int) -> Int {\\n        if n < 3 {\\n            return min(1 << n, [1, 3, 4][min(presses, 2)])\\n        }\\n        return [1, 4, 7, 8][min(presses, 3)]\\n    }\\n}\\n```\\n\\n## Explanation\\n\\n1. If n < 3, then the answer is the minimum of the two possible answers:\\n    a. 1 << n, which is the number of lights that are on if all are off\\n    b. [1, 3, 4][min(presses, 2)], which is the number of lights that are on if only the first and last are off\\n2. If n >= 3, then the answer is the minimum of the three possible answers:\\n    a. [1, 4, 7, 8][min(presses, 3)], which is the number of lights that are on if only the first, second, and last are off\\n    b. 1 << n, which is the number of lights that are on if all are off\\n    c. [1, 3, 4][min(presses, 2)], which is the number of lights that are on if only the first and last are off",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func flipLights(_ n: Int, _ presses: Int) -> Int {\\n        if n < 3 {\\n            return min(1 << n, [1, 3, 4][min(presses, 2)])\\n        }\\n        return [1, 4, 7, 8][min(presses, 3)]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339209,
                "title": "c-simulation-no-math-alternative-solution-0ms",
                "content": "# C++ Simulation, no math, alternative solution\\n\\nI do like the pure math solutions. \\nHere, I just want to show that we have an alternative (to the math ones), and that the plain old simulation method works, and it also runs fast in 0ms.\\n\\n```\\n// Idea / Approach: simulation we need only 4 bulbs 1..4 to cover all cases.\\nclass Solution { // _Simulation\\n    static unordered_set<uint8_t> simulateStep(const unordered_set<uint8_t>& states, uint8_t mask) {\\n        auto op1 = [](uint8_t x) { return x ^ 0x0f; };\\n        auto op2 = [](uint8_t x) { return x ^ 0b1010; };\\n        auto op3 = [](uint8_t x) { return x ^ 0b0101; };\\n        auto op4 = [](uint8_t x) { return x ^ 0b1001; };\\n\\n        unordered_set<uint8_t> res;\\n        for (auto x : states) {\\n            res.insert(op1(x) & mask);\\n            res.insert(op2(x) & mask);\\n            res.insert(op3(x) & mask);\\n            res.insert(op4(x) & mask);\\n        }\\n        return res;\\n    }\\n\\npublic:\\n    int flipLights(int n, int presses) {\\n        if (presses == 0) {\\n            return 1;\\n        }\\n\\n        uint8_t mask = 0x0F;\\n        if (n == 1) {\\n            mask = 1;\\n        } else if (n == 2) {\\n            mask = 0b11;\\n        } else if (n == 3) {\\n            mask = 0b111;\\n        }\\n        unordered_set<uint8_t> reached; // reached states\\n        reached.insert(0x0F & mask);\\n\\t\\t// if presses > 4, then there must be p-4 presses that are cancelling each other, and not\\n        // creating new states.\\n        // so we can max it out at 4.\\n        for (int i = 0; i < min(4, presses); ++i) {\\n            reached = simulateStep(reached, mask);\\n        }\\n        return reached.size();\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n// Idea / Approach: simulation we need only 4 bulbs 1..4 to cover all cases.\\nclass Solution { // _Simulation\\n    static unordered_set<uint8_t> simulateStep(const unordered_set<uint8_t>& states, uint8_t mask) {\\n        auto op1 = [](uint8_t x) { return x ^ 0x0f; };\\n        auto op2 = [](uint8_t x) { return x ^ 0b1010; };\\n        auto op3 = [](uint8_t x) { return x ^ 0b0101; };\\n        auto op4 = [](uint8_t x) { return x ^ 0b1001; };\\n\\n        unordered_set<uint8_t> res;\\n        for (auto x : states) {\\n            res.insert(op1(x) & mask);\\n            res.insert(op2(x) & mask);\\n            res.insert(op3(x) & mask);\\n            res.insert(op4(x) & mask);\\n        }\\n        return res;\\n    }\\n\\npublic:\\n    int flipLights(int n, int presses) {\\n        if (presses == 0) {\\n            return 1;\\n        }\\n\\n        uint8_t mask = 0x0F;\\n        if (n == 1) {\\n            mask = 1;\\n        } else if (n == 2) {\\n            mask = 0b11;\\n        } else if (n == 3) {\\n            mask = 0b111;\\n        }\\n        unordered_set<uint8_t> reached; // reached states\\n        reached.insert(0x0F & mask);\\n\\t\\t// if presses > 4, then there must be p-4 presses that are cancelling each other, and not\\n        // creating new states.\\n        // so we can max it out at 4.\\n        for (int i = 0; i < min(4, presses); ++i) {\\n            reached = simulateStep(reached, mask);\\n        }\\n        return reached.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309835,
                "title": "c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n    //Regardless how many n lightbulbs there are with initial state ON=>only 1 state\\n        if (presses==0) return 1;   \\n    //[ flip all, flip odd, or flip 3k+1 ] is OFF.\\n    //[ flip even ] is ON \\n        if (n==1)\\n    //Either this one lightbulb is ON or OFF after m=1 operations. Any additional operations revert the lightbulb to a previous state\\n            if (presses>=1) return 2;\\n                 /*  0 0 ( after 1 operation: flip all )\\n                     0 1 ( after 1 operation: flip odd or 3k+1 )\\n                     1 0 ( after 1 operation: flip even )\\n                  */\\n        if (n==2){\\n            if (presses==1) return 3;\\n            /*\\n               00 or 01 or 10 or 11 possible \\n            */\\n            if (presses>=2) return 4;\\n        }\\n        if (n>=3){\\n            //000 or 010 or 011 or 101\\n            if (presses==1) return 4;\\n            //000 or 001 or 010 or 100 or 101 or 110 or 111\\n            if (presses==2) return 7;\\n            //000 or 001 or 010 or 011 or 100 or 101 or 110 or 111\\n            if (presses>=3) return 8;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n    //Regardless how many n lightbulbs there are with initial state ON=>only 1 state\\n        if (presses==0) return 1;   \\n    //[ flip all, flip odd, or flip 3k+1 ] is OFF.\\n    //[ flip even ] is ON \\n        if (n==1)\\n    //Either this one lightbulb is ON or OFF after m=1 operations. Any additional operations revert the lightbulb to a previous state\\n            if (presses>=1) return 2;\\n                 /*  0 0 ( after 1 operation: flip all )\\n                     0 1 ( after 1 operation: flip odd or 3k+1 )\\n                     1 0 ( after 1 operation: flip even )\\n                  */\\n        if (n==2){\\n            if (presses==1) return 3;\\n            /*\\n               00 or 01 or 10 or 11 possible \\n            */\\n            if (presses>=2) return 4;\\n        }\\n        if (n>=3){\\n            //000 or 010 or 011 or 101\\n            if (presses==1) return 4;\\n            //000 or 001 or 010 or 100 or 101 or 110 or 111\\n            if (presses==2) return 7;\\n            //000 or 001 or 010 or 011 or 100 or 101 or 110 or 111\\n            if (presses>=3) return 8;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214239,
                "title": "python-simple-logic",
                "content": "\\n    def flipLights(self, n, presses):\\n        if presses == 0:\\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if presses<2 else 4\\n        else:\\n            if presses == 1:\\n                return 4\\n            if presses == 2:\\n                return 7\\n            else:\\n                return 8",
                "solutionTags": [],
                "code": "\\n    def flipLights(self, n, presses):\\n        if presses == 0:\\n            return 1\\n        elif n == 1:\\n            return 2\\n        elif n == 2:\\n            return 3 if presses<2 else 4\\n        else:\\n            if presses == 1:\\n                return 4\\n            if presses == 2:\\n                return 7\\n            else:\\n                return 8",
                "codeTag": "Python3"
            },
            {
                "id": 2110980,
                "title": "c-o-1-beats-100",
                "content": "![image](https://assets.leetcode.com/users/images/c73cf10c-367d-4de6-a1fa-eb26b123bd99_1654369307.6417487.png)\\n\\n```\\nint flipLights(int n, int m) {\\n\\tif (m==0) return 1;\\n\\tif(n==1) return 2;\\n\\tif(n==2) return m==1?3:4;\\n\\treturn m==1?4:m==2?7:8;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint flipLights(int n, int m) {\\n\\tif (m==0) return 1;\\n\\tif(n==1) return 2;\\n\\tif(n==2) return m==1?3:4;\\n\\treturn m==1?4:m==2?7:8;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028988,
                "title": "bulb-switcher-python-implementation",
                "content": "class Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \\n        # when there are no presses, the status will stay\\n        if presses == 0: return 1\\n        \\n        # when there is one bulb, whatever be the no. of presses : possibilities = [off, on]\\n        if n == 1: return 2\\n        \\n        # when there are two bulbs, if no. of presses is 1 : possibilities = [(on,off), (off,on),(off,off)]\\n        # when there are two bulbs, if no. of presses is not 1 : possibilities = [(on, off), (off, on), (off, off), (on, on)]\\n        if n == 2:\\n            if presses == 1:\\n                return 3\\n            return 4\\n        \\n        # when there are three bulbs, if no. of presses is 1: possibilities = [(off, off, off), (on, off, on), (off, on, off), (off, on, on)]\\n        # this status remains the same for bulbs greater than 4 (check it out with n = 4)\\n        if presses == 1: return 4\\n        \\n        # when there are more than 2 bulbs with 2 presses, it will have 7 possibilities (check it out with n = 3 and presses = 2)\\n        if presses == 2:\\n            return 7\\n        # else\\n        return 8",
                "solutionTags": [],
                "code": "class Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        \\n        # when there are no presses, the status will stay\\n        if presses == 0: return 1\\n        \\n        # when there is one bulb, whatever be the no. of presses : possibilities = [off, on]\\n        if n == 1: return 2\\n        \\n        # when there are two bulbs, if no. of presses is 1 : possibilities = [(on,off), (off,on),(off,off)]\\n        # when there are two bulbs, if no. of presses is not 1 : possibilities = [(on, off), (off, on), (off, off), (on, on)]\\n        if n == 2:\\n            if presses == 1:\\n                return 3\\n            return 4\\n        \\n        # when there are three bulbs, if no. of presses is 1: possibilities = [(off, off, off), (on, off, on), (off, on, off), (off, on, on)]\\n        # this status remains the same for bulbs greater than 4 (check it out with n = 4)\\n        if presses == 1: return 4\\n        \\n        # when there are more than 2 bulbs with 2 presses, it will have 7 possibilities (check it out with n = 3 and presses = 2)\\n        if presses == 2:\\n            return 7\\n        # else\\n        return 8",
                "codeTag": "Java"
            },
            {
                "id": 2024121,
                "title": "rust-solution-with-pattern-match",
                "content": "```rust\\nimpl Solution {\\n    pub fn flip_lights(n: i32, presses: i32) -> i32 {\\n        match (n, presses) {\\n            (_, 0) => 1,\\n            (1, _) => 2,\\n            (2, 1) => 3,\\n            (2, _) => 4,\\n            (_, 1) => 4,\\n            (_, 2) => 7,\\n            (_, presses @ _) if presses > 3 => 8,\\n            (_, _) => 8,\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn flip_lights(n: i32, presses: i32) -> i32 {\\n        match (n, presses) {\\n            (_, 0) => 1,\\n            (1, _) => 2,\\n            (2, 1) => 3,\\n            (2, _) => 4,\\n            (_, 1) => 4,\\n            (_, 2) => 7,\\n            (_, presses @ _) if presses > 3 => 8,\\n            (_, _) => 8,\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008515,
                "title": "kotlin-brute-force-and-math-solution",
                "content": "Please, let me know if you have any questions.\\n\\n```\\nclass Solution {\\n    class BruteForceSolution {\\n        // This was the first idea: generate all possible combinations of button presses\\n        // and simulate it on given bulbs. Clearly it does\\'t fit any time limits :D\\n        fun flipLights(n: Int, presses: Int): Int {\\n            val states = HashSet<MutableList<Boolean>>()\\n\\n            val combinations = mutableListOf<MutableList<Int>>()\\n            generatePressesCombinations(combinations, MutableList(presses) { -1 }, presses)\\n\\n            for (combination in combinations) {\\n                val lights = MutableList(n) { true }\\n                for (button in combination) {\\n                    when (button) {\\n                        1 -> {\\n                            for (i in 1..lights.size) {\\n                                toggle(lights, i)\\n                            }\\n                        }\\n                        2 -> {\\n                            for (i in 1..lights.size) {\\n                                if (i % 2 == 0) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                        3 -> {\\n                            for (i in 1..lights.size) {\\n                                if (i % 2 == 1) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                        4 -> {\\n                            for (i in 1..lights.size) {\\n                                if ((i - 1) % 3 == 0) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                states.add(lights)\\n            }\\n\\n            return states.count()\\n        }\\n\\n        private fun toggle(lights: MutableList<Boolean>, i: Int) {\\n            lights[i - 1] = lights[i - 1].not()\\n        }\\n\\n        private fun generatePressesCombinations(\\n            combinations: MutableList<MutableList<Int>>,\\n            combination: MutableList<Int>,\\n            pressesRemaining: Int\\n        ) {\\n            if (pressesRemaining > 0) {\\n                for (button in 1..4) {\\n                    val tempCombination = mutableListOf(*combination.toTypedArray())\\n                    tempCombination[tempCombination.size - pressesRemaining] = button\\n                    generatePressesCombinations(combinations, tempCombination, pressesRemaining - 1)\\n                }\\n            } else {\\n                combinations.add(combination)\\n            }\\n        }\\n    }\\n\\n    class GodHelpMeSolution { // I\\'m crying xD\\n        // This solution came to my mind when I realised there is a finite number of states for given bulbs for every n.\\n        // For different n it is different. So I built a table/graph representing this state machine.\\n        // What bulbs are switched on:\\n        // A - all\\n        // N - none\\n        // E - evens\\n        // O - odds\\n        // A# - all but thirds\\n        // N# - none but thirds\\n        // E# - evens except thirds\\n        // O# - odds except thirds\\n        // ___| 1B | 2B | 3B | 4B |\\n        // A  | N  | O  | E  | A# |\\n        // N  | A  | E  | O  | N# |\\n        // O  | E  | N  | A  | O# |\\n        // E  | O  | A  | N  | E# |\\n        // A# | N# | O# | E# | A  |\\n        // N# | A# | E# | O# | N  |\\n        // O# | E# | N# | A# | O  |\\n        // E# | O# | A# | N# | E  |\\n        // Starting from 3 bulbs and 3 presses this system can be in 8 different states described in this table.\\n        // When bulbs and presses are lower than 3 we can count number of states we can reach with use of table above.\\n        fun flipLights(bulbs: Int, presses: Int): Int {\\n            return when (bulbs) {\\n                0 -> 1\\n                1 -> when (presses) {\\n                    0 -> 1\\n                    else -> 2\\n                }\\n                2 -> when (presses) {\\n                    0 -> 1\\n                    1 -> 3\\n                    else -> 4\\n                }\\n                else -> when (presses) {\\n                    0 -> 1\\n                    1 -> 4\\n                    2 -> 7\\n                    else -> 8\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    class BruteForceSolution {\\n        // This was the first idea: generate all possible combinations of button presses\\n        // and simulate it on given bulbs. Clearly it does\\'t fit any time limits :D\\n        fun flipLights(n: Int, presses: Int): Int {\\n            val states = HashSet<MutableList<Boolean>>()\\n\\n            val combinations = mutableListOf<MutableList<Int>>()\\n            generatePressesCombinations(combinations, MutableList(presses) { -1 }, presses)\\n\\n            for (combination in combinations) {\\n                val lights = MutableList(n) { true }\\n                for (button in combination) {\\n                    when (button) {\\n                        1 -> {\\n                            for (i in 1..lights.size) {\\n                                toggle(lights, i)\\n                            }\\n                        }\\n                        2 -> {\\n                            for (i in 1..lights.size) {\\n                                if (i % 2 == 0) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                        3 -> {\\n                            for (i in 1..lights.size) {\\n                                if (i % 2 == 1) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                        4 -> {\\n                            for (i in 1..lights.size) {\\n                                if ((i - 1) % 3 == 0) {\\n                                    toggle(lights, i)\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                states.add(lights)\\n            }\\n\\n            return states.count()\\n        }\\n\\n        private fun toggle(lights: MutableList<Boolean>, i: Int) {\\n            lights[i - 1] = lights[i - 1].not()\\n        }\\n\\n        private fun generatePressesCombinations(\\n            combinations: MutableList<MutableList<Int>>,\\n            combination: MutableList<Int>,\\n            pressesRemaining: Int\\n        ) {\\n            if (pressesRemaining > 0) {\\n                for (button in 1..4) {\\n                    val tempCombination = mutableListOf(*combination.toTypedArray())\\n                    tempCombination[tempCombination.size - pressesRemaining] = button\\n                    generatePressesCombinations(combinations, tempCombination, pressesRemaining - 1)\\n                }\\n            } else {\\n                combinations.add(combination)\\n            }\\n        }\\n    }\\n\\n    class GodHelpMeSolution { // I\\'m crying xD\\n        // This solution came to my mind when I realised there is a finite number of states for given bulbs for every n.\\n        // For different n it is different. So I built a table/graph representing this state machine.\\n        // What bulbs are switched on:\\n        // A - all\\n        // N - none\\n        // E - evens\\n        // O - odds\\n        // A# - all but thirds\\n        // N# - none but thirds\\n        // E# - evens except thirds\\n        // O# - odds except thirds\\n        // ___| 1B | 2B | 3B | 4B |\\n        // A  | N  | O  | E  | A# |\\n        // N  | A  | E  | O  | N# |\\n        // O  | E  | N  | A  | O# |\\n        // E  | O  | A  | N  | E# |\\n        // A# | N# | O# | E# | A  |\\n        // N# | A# | E# | O# | N  |\\n        // O# | E# | N# | A# | O  |\\n        // E# | O# | A# | N# | E  |\\n        // Starting from 3 bulbs and 3 presses this system can be in 8 different states described in this table.\\n        // When bulbs and presses are lower than 3 we can count number of states we can reach with use of table above.\\n        fun flipLights(bulbs: Int, presses: Int): Int {\\n            return when (bulbs) {\\n                0 -> 1\\n                1 -> when (presses) {\\n                    0 -> 1\\n                    else -> 2\\n                }\\n                2 -> when (presses) {\\n                    0 -> 1\\n                    1 -> 3\\n                    else -> 4\\n                }\\n                else -> when (presses) {\\n                    0 -> 1\\n                    1 -> 4\\n                    2 -> 7\\n                    else -> 8\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934254,
                "title": "simple-c",
                "content": "\\tpublic class Solution {\\n    public int FlipLights(int n, int m) {\\n\\n         if (n == 1 && m > 0) {\\n                return 2;\\n            } else if (n == 2 && m == 1) {\\n                return 3;\\n            } else if ((n > 2 && m == 1) || (n == 2 && m > 1)) {\\n                return 4;\\n            } else if (n > 2 && m == 2) {\\n                return 7;\\n            } else if (n > 2 && m > 2) {\\n                return 8;\\n            } else {\\n                return 1;\\n            }\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int FlipLights(int n, int m) {\\n\\n         if (n == 1 && m > 0) {\\n                return 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1817884,
                "title": "is-it-just-me-or-anyone-feel-this-problem-should-be-hard",
                "content": "I feel this problem is pretty hard to be medium, lots of brain power, no typical algo/DS",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1449424,
                "title": "javascript-simple-4-line-logic",
                "content": "```\\nvar flipLights = function(n, presses) {\\n    if (presses === 0) return 1;\\n    if (presses === 1) return n <= 2 ? n + 1 : 4;\\n    if (n <= 2) return 2 * n;\\n    return 7 + (presses >= 3);\\n};",
                "solutionTags": [],
                "code": "```\\nvar flipLights = function(n, presses) {\\n    if (presses === 0) return 1;\\n    if (presses === 1) return n <= 2 ? n + 1 : 4;\\n    if (n <= 2) return 2 * n;\\n    return 7 + (presses >= 3);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1371395,
                "title": "simple-math-c-solution",
                "content": "Problem is similar to Bul Switcher 1 in the aspect, that we can work out a pattern in the bulbs and presses. If n==0 or presses == 0, there is only 1 state = all ON.\\nIf n == 1, then (as we have already accounted for presses==0), then with atleast 1 press, that one bulb can be ON or OFF. \\nIf n==2, if presses==1, the odd switch and 3k+1 switch will produce same result and hence, will give 2^2 - 1 = 3 patters. If presses is >=1, then states can be 4.\\nNow for any n>2, if presses = 1, there can be 4 states (each switch producing different states). If presses=2, we there can be only 7 unique states and for presses>2, there can be 8.\\nThere cant be any more unique states for the sequence as patterns are repeated between bulbs and if presses are >=3, then we are guaranteed atleast one of the bulb toggled by previous operations will return back to same state, hence keeping number of unique states same as before.\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if(presses==0 || n==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return (presses==1)?3:4;\\n        if(presses==1) return 4;\\n        return (presses==2)?7:8;\\n    }\\n};\\n```\\nTime complexity = O(1)\\nSpace complexity = O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int presses) {\\n        if(presses==0 || n==0) return 1;\\n        if(n==1) return 2;\\n        if(n==2) return (presses==1)?3:4;\\n        if(presses==1) return 4;\\n        return (presses==2)?7:8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307308,
                "title": "sollution-in-c",
                "content": "```\\nint flipLights(int n, int presses){\\n    int val = n >=3 ? 3 : n;\\n    if (presses == 0){\\n        return 1;\\n    } else if (presses == 1){\\n        return val == 1 ? 2 : val == 2 ? 3 : 4;\\n    } else if (presses == 2){\\n        return val == 1 ? 2 : val == 2 ? 4 : 7;\\n    } \\n    return val == 1? 2 : val == 2 ? 4 : 8;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint flipLights(int n, int presses){\\n    int val = n >=3 ? 3 : n;\\n    if (presses == 0){\\n        return 1;\\n    } else if (presses == 1){\\n        return val == 1 ? 2 : val == 2 ? 3 : 4;\\n    } else if (presses == 2){\\n        return val == 1 ? 2 : val == 2 ? 4 : 7;\\n    } \\n    return val == 1? 2 : val == 2 ? 4 : 8;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291782,
                "title": "javascript-set-thinking-faster-than-100",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar flipLights = function(n, m) {\\n    if (m === 0)    return 1\\n\\n    \\n    const sets = {\\n        NONE: \\'\\',\\n        A: \\'A\\',\\n        B: \\'B\\',\\n        C: \\'C\\',\\n        D: \\'D\\',\\n    }\\n    if (n === 1) {\\n        sets.B = sets.A\\n    }\\n    if (n <= 2) {\\n        sets.D = sets.B\\n    }\\n    \\n    \\n    function getSet(...list) {\\n        let set = new Set()\\n        for (const ch of list) {\\n            if (set.has(ch))    set.delete(ch)\\n            else set.add(ch)\\n        }\\n        \\n        const chs = [...set]\\n        chs.sort()\\n        \\n        return chs.join(\\'\\')\\n    }\\n    \\n    \\n    const results = []\\n    results[0] = new Set([sets.NONE])\\n    results[1] = new Set([sets.A, sets.B, sets.C, sets.D])\\n    results[2] = new Set([...results[0], getSet(sets.A, sets.B), getSet(sets.A, sets.C), getSet(sets.A, sets.D), getSet(sets.B, sets.C), getSet(sets.B, sets.D), getSet(sets.C, sets.D)])\\n    results[3] = new Set([...results[1], getSet(sets.A, sets.B, sets.C), getSet(sets.A, sets.B, sets.D), getSet(sets.A, sets.C, sets.D), getSet(sets.B, sets.C, sets.D)])\\n    results[4] = new Set([...results[2], getSet(sets.A, sets.B, sets.C, sets.D)])\\n    \\n    \\n    let result\\n    if (m <= 4) result = results[m]\\n    else {\\n        if (m & 1)  result = results[3]\\n        else result = results[4]\\n    }\\n    \\n\\n    result = result.size\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar flipLights = function(n, m) {\\n    if (m === 0)    return 1\\n\\n    \\n    const sets = {\\n        NONE: \\'\\',\\n        A: \\'A\\',\\n        B: \\'B\\',\\n        C: \\'C\\',\\n        D: \\'D\\',\\n    }\\n    if (n === 1) {\\n        sets.B = sets.A\\n    }\\n    if (n <= 2) {\\n        sets.D = sets.B\\n    }\\n    \\n    \\n    function getSet(...list) {\\n        let set = new Set()\\n        for (const ch of list) {\\n            if (set.has(ch))    set.delete(ch)\\n            else set.add(ch)\\n        }\\n        \\n        const chs = [...set]\\n        chs.sort()\\n        \\n        return chs.join(\\'\\')\\n    }\\n    \\n    \\n    const results = []\\n    results[0] = new Set([sets.NONE])\\n    results[1] = new Set([sets.A, sets.B, sets.C, sets.D])\\n    results[2] = new Set([...results[0], getSet(sets.A, sets.B), getSet(sets.A, sets.C), getSet(sets.A, sets.D), getSet(sets.B, sets.C), getSet(sets.B, sets.D), getSet(sets.C, sets.D)])\\n    results[3] = new Set([...results[1], getSet(sets.A, sets.B, sets.C), getSet(sets.A, sets.B, sets.D), getSet(sets.A, sets.C, sets.D), getSet(sets.B, sets.C, sets.D)])\\n    results[4] = new Set([...results[2], getSet(sets.A, sets.B, sets.C, sets.D)])\\n    \\n    \\n    let result\\n    if (m <= 4) result = results[m]\\n    else {\\n        if (m & 1)  result = results[3]\\n        else result = results[4]\\n    }\\n    \\n\\n    result = result.size\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1257539,
                "title": "c-using-a-bit-of-thinking",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        int val = min(3,n);\\n        if(m == 0)\\n        {\\n           return 1; \\n        }\\n        else if(m==1)\\n        {\\n            return val == 1?2:val == 2?3:4;\\n        }\\n        else if(m == 2)\\n            return val == 1?2:val == 2?4:7;\\n        return val == 1?2:val == 2?4:8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        int val = min(3,n);\\n        if(m == 0)\\n        {\\n           return 1; \\n        }\\n        else if(m==1)\\n        {\\n            return val == 1?2:val == 2?3:4;\\n        }\\n        else if(m == 2)\\n            return val == 1?2:val == 2?4:7;\\n        return val == 1?2:val == 2?4:8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253549,
                "title": "not-much-thinking-required-just-do-it-in-python",
                "content": "Observation 1. Order of button pressing is irrelevant.\\nObservation 2. Pressing a button two times is exactly equivalent of pressing it zero times. So, we must only consider pressing each button either 0 or 1 times. As we have 4 buttons, we need to consider 16 combinations. We\\'ll use bitmasks for that.\\nObservation 3. We only need to simulate no more than 6 first bulbs, beacause it\\'s a repeating pattern after that.\\nObservation 4. Starting from presses==3, the only thing we need to know is whether presses is even or odd number.\\n```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(n, 6)\\n        Possibilities = {\\n            0: {0},\\n            1: {1},\\n            2: {0,2},\\n            3: {1,3},\\n            4: {0,2,4}\\n        }\\n        if presses>4:\\n            presses = 4-presses%2\\n        on_counts = Possibilities[presses]\\n        outcomes = set()\\n        for x in range(16):\\n            cnt = bool(x&1)+bool(x&2)+bool(x&4)+bool(x&8)\\n            if cnt not in on_counts:\\n                continue\\n            state = [0]*n\\n            if x&1:\\n                # press button 1\\n                state = [v^1 for v in state]\\n            if x&2:\\n                # press button 2\\n                state = [v^(i&1) for i,v in enumerate(state)]\\n            if x&4:\\n                # press button 3\\n                state = [v^(i&1)^1 for i,v in enumerate(state)]\\n            if x&8:\\n                # press button 4\\n                if n>0: state[0] ^= 1\\n                if n>3: state[3] ^= 1\\n            \\n            outcomes.add(tuple(state))\\n        return len(outcomes)\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n: int, presses: int) -> int:\\n        n = min(n, 6)\\n        Possibilities = {\\n            0: {0},\\n            1: {1},\\n            2: {0,2},\\n            3: {1,3},\\n            4: {0,2,4}\\n        }\\n        if presses>4:\\n            presses = 4-presses%2\\n        on_counts = Possibilities[presses]\\n        outcomes = set()\\n        for x in range(16):\\n            cnt = bool(x&1)+bool(x&2)+bool(x&4)+bool(x&8)\\n            if cnt not in on_counts:\\n                continue\\n            state = [0]*n\\n            if x&1:\\n                # press button 1\\n                state = [v^1 for v in state]\\n            if x&2:\\n                # press button 2\\n                state = [v^(i&1) for i,v in enumerate(state)]\\n            if x&4:\\n                # press button 3\\n                state = [v^(i&1)^1 for i,v in enumerate(state)]\\n            if x&8:\\n                # press button 4\\n                if n>0: state[0] ^= 1\\n                if n>3: state[3] ^= 1\\n            \\n            outcomes.add(tuple(state))\\n        return len(outcomes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104036,
                "title": "c-solution-0ms",
                "content": "Run-time is `O(1)`, space is `O(1)`. \\n\\nThis is just a counting problem where you first realize that there is limited possibilities then you just check what is possible for different combinations of `n` and `m`. \\n\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        else if(m == 1) {\\n            switch(n) {\\n                case 1: return 2;\\n                case 2: return 3;\\n                default: return 4;\\n            }\\n        } else if(m == 2) {\\n            switch(n) {\\n                case 1: return 2;\\n                case 2: return 4;\\n                default: return 7;\\n            }\\n        }\\n        \\n        if(n == 1) return 2;\\n        else if(n == 2) return 4;      \\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        else if(m == 1) {\\n            switch(n) {\\n                case 1: return 2;\\n                case 2: return 3;\\n                default: return 4;\\n            }\\n        } else if(m == 2) {\\n            switch(n) {\\n                case 1: return 2;\\n                case 2: return 4;\\n                default: return 7;\\n            }\\n        }\\n        \\n        if(n == 1) return 2;\\n        else if(n == 2) return 4;      \\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057233,
                "title": "c-o-1",
                "content": "```\\nclass Solution {\\n    /*\\n        4=>4\\n        44=>44\\n        444=>4\\n        4444=>44\\n        ....\\n        (combinations of 4 => only 44 and 4)\\n        \\n        2=>2\\n        22=>3\\n        222=>2\\n        ....\\n        \\n        3=>3\\n        33=>2\\n        333=>3\\n        ...\\n\\t\\t(combinations of 2 and 3 => only 2 and 3)\\n        (for any odd m and even m  2 or 3 can be used)\\n   \\n        13=>2\\n        12=>3\\n        (1,3) will be combined to (2)\\n        (2,3) will be combined to (3)\\n\\t\\t(so don\\'t consider 13 or 23 case)\\n        11=>cancel\\n     -------------------------------------------------------   \\n        summary\\n        if m is odd \\n                consider 1,2,3,4\\n            if (m,n>=3)\\n                consider 42,43,442,443,441 (duplicated 1 so only add extra 4 count)\\n        if m is even\\n                consider 2,3,11\\n            if (m,n>=2)\\n                condsider 44 42 43 41\\n            if (m,n>=3)\\n                consider 442 443 (duplicated 1 so only add extra 1 count)\\n      -------------------------------------------------------   \\n    */\\npublic:\\n    int flipLights(int n, int m) {\\n        int c = 0;\\n        if (m==0) return 1;\\n        if (n==1) return 2;\\n        if (n==2) return m == 1?3:4;\\n        if (m%2 == 0)\\n        {\\n            c += 3;\\n            if (m>=2)\\n                c+=4;\\n            if (m>=3)\\n                c+=1;\\n        }\\n        else\\n        {\\n            c += 4;\\n            if (m>=3)\\n                c+=4;\\n        }\\n        return c;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n        4=>4\\n        44=>44\\n        444=>4\\n        4444=>44\\n        ....\\n        (combinations of 4 => only 44 and 4)\\n        \\n        2=>2\\n        22=>3\\n        222=>2\\n        ....\\n        \\n        3=>3\\n        33=>2\\n        333=>3\\n        ...\\n\\t\\t(combinations of 2 and 3 => only 2 and 3)\\n        (for any odd m and even m  2 or 3 can be used)\\n   \\n        13=>2\\n        12=>3\\n        (1,3) will be combined to (2)\\n        (2,3) will be combined to (3)\\n\\t\\t(so don\\'t consider 13 or 23 case)\\n        11=>cancel\\n     -------------------------------------------------------   \\n        summary\\n        if m is odd \\n                consider 1,2,3,4\\n            if (m,n>=3)\\n                consider 42,43,442,443,441 (duplicated 1 so only add extra 4 count)\\n        if m is even\\n                consider 2,3,11\\n            if (m,n>=2)\\n                condsider 44 42 43 41\\n            if (m,n>=3)\\n                consider 442 443 (duplicated 1 so only add extra 1 count)\\n      -------------------------------------------------------   \\n    */\\npublic:\\n    int flipLights(int n, int m) {\\n        int c = 0;\\n        if (m==0) return 1;\\n        if (n==1) return 2;\\n        if (n==2) return m == 1?3:4;\\n        if (m%2 == 0)\\n        {\\n            c += 3;\\n            if (m>=2)\\n                c+=4;\\n            if (m>=3)\\n                c+=1;\\n        }\\n        else\\n        {\\n            c += 4;\\n            if (m>=3)\\n                c+=4;\\n        }\\n        return c;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905612,
                "title": "rust-0-ms-but-i-feel-it-is-too-verbose",
                "content": "```\\nimpl Solution {\\n    pub fn flip_lights(n: i32, m: i32) -> i32 {\\n        let mut real_n = std::cmp::min(3,n);\\n    if m == 0 {\\n        return 1;\\n    } else if m == 1 {\\n        real_n= if real_n == 1 {\\n            2\\n        } else if real_n == 2 {\\n            3\\n        } else {\\n            4\\n        };\\n        return real_n;\\n    } else if m == 2 {\\n        real_n = if real_n == 1 {\\n            2\\n        } else if real_n == 2 {\\n            4\\n        } else {\\n            7\\n        };\\n        return real_n;\\n    }\\n    real_n = if real_n == 1 {\\n        2\\n    } else if real_n == 2 {\\n        4\\n    } else {\\n        8\\n    };\\n    real_n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn flip_lights(n: i32, m: i32) -> i32 {\\n        let mut real_n = std::cmp::min(3,n);\\n    if m == 0 {\\n        return 1;\\n    } else if m == 1 {\\n        real_n= if real_n == 1 {\\n            2\\n        } else if real_n == 2 {\\n            3\\n        } else {\\n            4\\n        };\\n        return real_n;\\n    } else if m == 2 {\\n        real_n = if real_n == 1 {\\n            2\\n        } else if real_n == 2 {\\n            4\\n        } else {\\n            7\\n        };\\n        return real_n;\\n    }\\n    real_n = if real_n == 1 {\\n        2\\n    } else if real_n == 2 {\\n        4\\n    } else {\\n        8\\n    };\\n    real_n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883263,
                "title": "single-line-c-solution",
                "content": "\\n\\nint flipLights(int n, int m){\\n    return m==0?1:(n>2?(m==1?4:(m==2)?7:8):(n==1)?2:(m==1?3:4));   \\n}",
                "solutionTags": [],
                "code": "\\n\\nint flipLights(int n, int m){\\n    return m==0?1:(n>2?(m==1?4:(m==2)?7:8):(n==1)?2:(m==1?3:4));   \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 760639,
                "title": "python-slow-solution-but-accepted",
                "content": "```\\ndef f(x,m,d,h,n):\\n    s=int(x,2)\\n    if m==0:\\n        h.add(s)\\n        return\\n    if (s,m) in d:return\\n    a,b,c,e=\\'\\',\\'\\',\\'\\',\\'\\'\\n    g={\\'0\\':\\'1\\',\\'1\\':\\'0\\'}\\n    for i in range(min(4,n)):\\n        if i%2==0:a+=g[x[i]]\\n        else:a+=x[i]\\n        if i%2==1:b+=g[x[i]]\\n        else:b+=x[i]\\n        c+=g[x[i]]\\n        if i in (0,3):e+=g[x[i]]\\n        else:e+=x[i]\\n    f(a,m-1,d,h,n),f(b,m-1,d,h,n),f(c,m-1,d,h,n),f(e,m-1,d,h,n)\\n    d.add((s,m))\\n    return \\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        d=set()\\n        h=set()\\n        x=\"1\"*min(4,n)\\n        f(x,m,d,h,n)\\n        return len(h)\\n```",
                "solutionTags": [],
                "code": "```\\ndef f(x,m,d,h,n):\\n    s=int(x,2)\\n    if m==0:\\n        h.add(s)\\n        return\\n    if (s,m) in d:return\\n    a,b,c,e=\\'\\',\\'\\',\\'\\',\\'\\'\\n    g={\\'0\\':\\'1\\',\\'1\\':\\'0\\'}\\n    for i in range(min(4,n)):\\n        if i%2==0:a+=g[x[i]]\\n        else:a+=x[i]\\n        if i%2==1:b+=g[x[i]]\\n        else:b+=x[i]\\n        c+=g[x[i]]\\n        if i in (0,3):e+=g[x[i]]\\n        else:e+=x[i]\\n    f(a,m-1,d,h,n),f(b,m-1,d,h,n),f(c,m-1,d,h,n),f(e,m-1,d,h,n)\\n    d.add((s,m))\\n    return \\nclass Solution:\\n    def flipLights(self, n: int, m: int) -> int:\\n        d=set()\\n        h=set()\\n        x=\"1\"*min(4,n)\\n        f(x,m,d,h,n)\\n        return len(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678466,
                "title": "c-simple-100-faster-solution-with-explation",
                "content": "```\\n/*x:the times use button1, y:the times use button2 z: the times use button3 w: the times use button4\\nthe order do not infulence the ans ;and the first 4 light will decide the ans; \\n\\nfor the light1 is always the same as light7 , light2 is always the same as light8... under different operations,\\nso we concentrate on the first 6 light ,but light2 is always the same as light6, light3 is always the same as 5,\\nso we only concentrate on the first 4 light;\\n\\nwe can list the equations:\\nx+y+z+w=m  \\nx+z+w=k1(mod2) (k1%2 decide the ans on light1)\\nx+y = k2(mod2) (k2%2 the ans on light2)\\nx+z=k3(mod2)  (k3%2 decide the ans on light3) \\nx+y+w=k4(mod2) (k4%2 decide the ans on light4) \\nso we can fix x,y,z(mod2), to get w(mod2) , and statistics the different ans of tuple [k1,k2,k3] !\\n*/\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        n=(n>4)?4:n;\\n        std::set<int> set;\\n        for(int i = 0;i<8;++i)\\n        {\\n            int x=i&1;\\n            int y=(i>>1)&1;\\n            int z = (i>>2)&1;\\n            int w=m-x-y-z;\\n            if(w>=0)\\n            {\\n                w=w%2;\\n                int b[4]={(x+z+w)%2,(x+y)%2,(x+z)%2,(x+y+w)%2};\\n                int k=0;\\n                for(int t=0;t<n;++t)\\n                {\\n                    k+=(b[t]<<t);\\n                }\\n                set.insert(k);\\n            }\\n        }\\n        return set.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*x:the times use button1, y:the times use button2 z: the times use button3 w: the times use button4\\nthe order do not infulence the ans ;and the first 4 light will decide the ans; \\n\\nfor the light1 is always the same as light7 , light2 is always the same as light8... under different operations,\\nso we concentrate on the first 6 light ,but light2 is always the same as light6, light3 is always the same as 5,\\nso we only concentrate on the first 4 light;\\n\\nwe can list the equations:\\nx+y+z+w=m  \\nx+z+w=k1(mod2) (k1%2 decide the ans on light1)\\nx+y = k2(mod2) (k2%2 the ans on light2)\\nx+z=k3(mod2)  (k3%2 decide the ans on light3) \\nx+y+w=k4(mod2) (k4%2 decide the ans on light4) \\nso we can fix x,y,z(mod2), to get w(mod2) , and statistics the different ans of tuple [k1,k2,k3] !\\n*/\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        n=(n>4)?4:n;\\n        std::set<int> set;\\n        for(int i = 0;i<8;++i)\\n        {\\n            int x=i&1;\\n            int y=(i>>1)&1;\\n            int z = (i>>2)&1;\\n            int w=m-x-y-z;\\n            if(w>=0)\\n            {\\n                w=w%2;\\n                int b[4]={(x+z+w)%2,(x+y)%2,(x+z)%2,(x+y+w)%2};\\n                int k=0;\\n                for(int t=0;t<n;++t)\\n                {\\n                    k+=(b[t]<<t);\\n                }\\n                set.insert(k);\\n            }\\n        }\\n        return set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674865,
                "title": "c-simple-100-faster-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(m==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 2;\\n        }\\n        if(n==2){\\n            if(m==1){\\n                return 3;\\n            }\\n            return 4;\\n        }\\n        if(m==1){\\n            return 4;\\n        }\\n        if(m==2){\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(m==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 2;\\n        }\\n        if(n==2){\\n            if(m==1){\\n                return 3;\\n            }\\n            return 4;\\n        }\\n        if(m==1){\\n            return 4;\\n        }\\n        if(m==2){\\n            return 7;\\n        }\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590061,
                "title": "java-math",
                "content": "```\\n    public int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        if(n == 1) return 2;\\n        if(n == 2) {\\n            if(m == 1) return 3;\\n            else return 4;\\n        }\\n        if(n >= 3) {\\n            if(m == 1) return 4;\\n            if(m == 2) return 6 + 1;\\n            if(m % 1 == 1) return 4 + 4;\\n        }\\n        return 8;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int flipLights(int n, int m) {\\n        if(m == 0) return 1;\\n        if(n == 1) return 2;\\n        if(n == 2) {\\n            if(m == 1) return 3;\\n            else return 4;\\n        }\\n        if(n >= 3) {\\n            if(m == 1) return 4;\\n            if(m == 2) return 6 + 1;\\n            if(m % 1 == 1) return 4 + 4;\\n        }\\n        return 8;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 573296,
                "title": "c-bit-manipulation-kind-silly-but-more-general-i-think",
                "content": "I didn\\'t think much about the swithes and their relations, therefore I came up with this.\\nBut I think for switches like: \\n```\\n\\tswitch1: flip lights k+1 (k in {0,1,2,3...}\\n\\tswitch2: flip lights 2k+1\\n\\tswitch3: flip lights 3k+1\\n\\t......\\n\\tswitchx: flip lights xk+1\\n```\\nmy idea should still work:\\n```c++\\nclass Solution {\\n private:\\n  // lights are numbered from right to left: 3..1\\n  // 1 means the swither can flip that light\\n  vector<int> switchers = {0b111, 0b010, 0b101, 0b001};\\n  int cnt_bits(int x) {\\n    int res = 0;\\n    while (x) {\\n      res += x & 1;\\n      x >>= 1;\\n    }\\n    return res;\\n  }\\n\\n public:\\n  // n and m both fit in range [0, 1000].\\n  int flipLights(int n, int m) {\\n    if (m == 0 || n == 0) return 1;\\n    // allocate m to four switchers/plates (only need to know the number is even\\n    // or odd) [0, 2**4) 0 0 0 0 ~ 1 1 1 1 printArr(switchers);\\n\\n    // for n, only need to consider n <= 3 \\n    int lights = 0b111;\\n    // if n less than 3, just consider n lights\\n    if (n < 3) lights = (1 << n) - 1;\\n    // if can reach status i (lights = i), statuses[i] = true\\n    vector<bool> statuses(lights + 1);\\n    for (int i = 0; i < 16; ++i) {\\n      int bit_cnt = cnt_bits(i);\\n      if (bit_cnt > m || (m - bit_cnt) & 1) continue;\\n      int switcher = 0;\\n      // total four switchers, combine the switches (which will be used odd\\n      // times)\\n      for (int j = 0; j < 4; ++j) {\\n        if ((1 << j) & i) switcher ^= switchers[j];\\n      }\\n      // flip lights use the combined swither, set the lights\\' status to true\\n      statuses[(lights ^ switcher) & lights] = true;\\n    }\\n\\n    int res = 0;\\n    for (bool status : statuses) {\\n      res += status;\\n    }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tswitch1: flip lights k+1 (k in {0,1,2,3...}\\n\\tswitch2: flip lights 2k+1\\n\\tswitch3: flip lights 3k+1\\n\\t......\\n\\tswitchx: flip lights xk+1\\n```\n```c++\\nclass Solution {\\n private:\\n  // lights are numbered from right to left: 3..1\\n  // 1 means the swither can flip that light\\n  vector<int> switchers = {0b111, 0b010, 0b101, 0b001};\\n  int cnt_bits(int x) {\\n    int res = 0;\\n    while (x) {\\n      res += x & 1;\\n      x >>= 1;\\n    }\\n    return res;\\n  }\\n\\n public:\\n  // n and m both fit in range [0, 1000].\\n  int flipLights(int n, int m) {\\n    if (m == 0 || n == 0) return 1;\\n    // allocate m to four switchers/plates (only need to know the number is even\\n    // or odd) [0, 2**4) 0 0 0 0 ~ 1 1 1 1 printArr(switchers);\\n\\n    // for n, only need to consider n <= 3 \\n    int lights = 0b111;\\n    // if n less than 3, just consider n lights\\n    if (n < 3) lights = (1 << n) - 1;\\n    // if can reach status i (lights = i), statuses[i] = true\\n    vector<bool> statuses(lights + 1);\\n    for (int i = 0; i < 16; ++i) {\\n      int bit_cnt = cnt_bits(i);\\n      if (bit_cnt > m || (m - bit_cnt) & 1) continue;\\n      int switcher = 0;\\n      // total four switchers, combine the switches (which will be used odd\\n      // times)\\n      for (int j = 0; j < 4; ++j) {\\n        if ((1 << j) & i) switcher ^= switchers[j];\\n      }\\n      // flip lights use the combined swither, set the lights\\' status to true\\n      statuses[(lights ^ switcher) & lights] = true;\\n    }\\n\\n    int res = 0;\\n    for (bool status : statuses) {\\n      res += status;\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538057,
                "title": "my-solution-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\nint flipLights(int n, int m) {\\n    int count = 0;\\n    set<string> s;\\n    string str;\\n    str.clear();\\n    for (int a = 0; a <= 1; ++a) {\\n        for (int b = 0; b <= 1; ++b) {\\n            for (int c = 0; c <= 1; ++c) {\\n                for (int d = 0; d <= 1; ++d) {\\n                    count = a + b + c + d;\\n                    if ((count % 2) != (m % 2) || count > m) continue;\\n                    if (n >= 1) {\\n                        str.append(to_string((a+c+d)%2)).append(\"_\");\\n                        if (n >= 2) {\\n                            str.append(to_string((a+b)%2)).append(\"_\");\\n                            if (n >= 3) {\\n                                str.append(to_string((a+c)%2)).append(\"_\");\\n                                if (n >= 4) {\\n                                    str.append(to_string((a+b+d)%2)).append(\"_\");\\n                                }\\n                            }\\n                        }\\n                    }\\n                    if (!str.empty()) {\\n                        s.insert(str);\\n                        str.clear();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return s.size();\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint flipLights(int n, int m) {\\n    int count = 0;\\n    set<string> s;\\n    string str;\\n    str.clear();\\n    for (int a = 0; a <= 1; ++a) {\\n        for (int b = 0; b <= 1; ++b) {\\n            for (int c = 0; c <= 1; ++c) {\\n                for (int d = 0; d <= 1; ++d) {\\n                    count = a + b + c + d;\\n                    if ((count % 2) != (m % 2) || count > m) continue;\\n                    if (n >= 1) {\\n                        str.append(to_string((a+c+d)%2)).append(\"_\");\\n                        if (n >= 2) {\\n                            str.append(to_string((a+b)%2)).append(\"_\");\\n                            if (n >= 3) {\\n                                str.append(to_string((a+c)%2)).append(\"_\");\\n                                if (n >= 4) {\\n                                    str.append(to_string((a+b+d)%2)).append(\"_\");\\n                                }\\n                            }\\n                        }\\n                    }\\n                    if (!str.empty()) {\\n                        s.insert(str);\\n                        str.clear();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return s.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524764,
                "title": "javascript-bitwize",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar flipLights = function (n, m) {\\n  // fist a*6 bulps always the same, we only need remember 1*6\\n  let total = n > 6 ? n % 6 + 6 : n, states = new Set()\\n  let inital = parseInt(\\'\\'.padEnd(total, \\'1\\'), 2),\\n    even = parseInt(\\'\\'.padEnd(total, \\'10\\'), 2),\\n    odd = parseInt(\\'\\'.padEnd(total, \\'01\\'), 2),\\n    k3p1 = parseInt(\\'\\'.padEnd(total, \\'100\\'), 2),\\n    all = inital, traveled = {}\\n\\n  r(inital, m)\\n  return states.size\\n\\n  function r(cur, left) {\\n    let key = cur + \\'_\\' + left\\n    if (traveled[key]) return\\n    traveled[key] = true\\n    if (left === 0) {\\n      states.add(cur)\\n      return\\n    }\\n    r(cur ^ all, left - 1)\\n    r(cur ^ even, left - 1)\\n    r(cur ^ odd, left - 1)\\n    r(cur ^ k3p1, left - 1)\\n  }\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} m\\n * @return {number}\\n */\\nvar flipLights = function (n, m) {\\n  // fist a*6 bulps always the same, we only need remember 1*6\\n  let total = n > 6 ? n % 6 + 6 : n, states = new Set()\\n  let inital = parseInt(\\'\\'.padEnd(total, \\'1\\'), 2),\\n    even = parseInt(\\'\\'.padEnd(total, \\'10\\'), 2),\\n    odd = parseInt(\\'\\'.padEnd(total, \\'01\\'), 2),\\n    k3p1 = parseInt(\\'\\'.padEnd(total, \\'100\\'), 2),\\n    all = inital, traveled = {}\\n\\n  r(inital, m)\\n  return states.size\\n\\n  function r(cur, left) {\\n    let key = cur + \\'_\\' + left\\n    if (traveled[key]) return\\n    traveled[key] = true\\n    if (left === 0) {\\n      states.add(cur)\\n      return\\n    }\\n    r(cur ^ all, left - 1)\\n    r(cur ^ even, left - 1)\\n    r(cur ^ odd, left - 1)\\n    r(cur ^ k3p1, left - 1)\\n  }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 403028,
                "title": "c-easy-to-understand-simple-solution",
                "content": "Assuming we have infinite bulbs and we operate infinite times.\\n* Without any operations, we can get 1 state:\\n\\t*  {all bulbs open}*(state 0)*\\n* In the first operation, we can get 4 different states by 4 different buttons:\\n\\t* {all bulbs close}*(state 1)*, *by button 1*\\n\\t*  {even bulbs close}*(state 2)*, *by button 2*\\n\\t*  {odd bulbs close}*(state 3)*, *by button 3*\\n\\t*  {3k+1 bulbs close}*(state 4)*, *by button 4*\\n* In the second operation, we can get another 3 states which do not appear in above:\\n\\t* {(odd\\u2229{3k+1})\\u222A(even - even\\u2229{3k+1})bulbs close}*(state 5)*, *by button 4 from state 2*\\n\\t* {(even\\u2229{3k+1})\\u222A(odd - odd\\u2229{3k+1})bulbs close}*(state 6)*, *by button 3 from state 3*\\n\\t* {3k+1 bulbs open}*(state 7)*, *by button 4 from state 1 OR  by button 1 from state 4*\\n\\tIn the second operation, we can get another 4 states which appear in above:\\n\\t* We can get back to the state 0 in the second operation by button {1,2,3,4} from state{1,2,3,4}\\n\\t* We can also get back to the state 1 in the second operation by button {2,3} from state{3,2}\\n\\t* We can also get back to the state 2 in the second operation by button 3 from state 1\\n\\t* We can also get back to the state 3 in the second operation by button 2 from state 1\\n* In the 3+ operation, we can get at most 8 states which appear in above:\\n\\tThere are no more states besides above which means at most we can get 8 states.\\n\\tMeanwhile, we can get state 4 by button {1,2,3,4} from state {7,5,6,0} so we can get at most all states when we operate more than twice .\\n```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0){ // if there are no bulbs\\n            return 1; //  only 1 state\\n        }else if(m == 1){ // if there is at least one bulb & we operate only once\\n            return min(n+1,4); // we can get no more than 4 status (n+1 from the description which shows operate 1, 2, 3 bulbs once means 2, 3, 4 states)\\n        }else{ //if there is at least one bulb and we operate more than once\\n            int sum = 1;\\n            for(int i = 0; i < n && i < 3; i++){// we can get no more than pow(2,n) states (i < 3 means we do not need to calculate when i >= 3 because sum is more than 8 in that time)\\n                sum *=2;\\n            }\\n            int minn = 7; // if we operate only twice , we can NOT get one of 8 states. That state we cannot get  back in the second time , 7 = 8 - 1\\n            if(m > 2){\\n\\t\\t\\t\\t\\tminn = 8; // we can get no more than 8 states\\n            }\\n            return min(sum,minn);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(m==0){ // if there are no bulbs\\n            return 1; //  only 1 state\\n        }else if(m == 1){ // if there is at least one bulb & we operate only once\\n            return min(n+1,4); // we can get no more than 4 status (n+1 from the description which shows operate 1, 2, 3 bulbs once means 2, 3, 4 states)\\n        }else{ //if there is at least one bulb and we operate more than once\\n            int sum = 1;\\n            for(int i = 0; i < n && i < 3; i++){// we can get no more than pow(2,n) states (i < 3 means we do not need to calculate when i >= 3 because sum is more than 8 in that time)\\n                sum *=2;\\n            }\\n            int minn = 7; // if we operate only twice , we can NOT get one of 8 states. That state we cannot get  back in the second time , 7 = 8 - 1\\n            if(m > 2){\\n\\t\\t\\t\\t\\tminn = 8; // we can get no more than 8 states\\n            }\\n            return min(sum,minn);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400425,
                "title": "bfs",
                "content": "bfs\\n1. careful about the lights being 1 indexed (turnoff every 3 and every 2 and every 1 could be a way to describe it)\\n2. repeats it self at minimal common multiple (tough point to visualize I find personally)\\n```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        if n > 6: n = 6 + n % 6\\n        q = set([tuple([0] * n)])\\n        for _ in range(m):  q = set([n for e in q for n in self.neighbours(e)])\\n        #O(mn) = O(11m) = O(m)\\n        #the constant being < 11\\n        return len(q)\\n    def neighbours(self,el):\\n        return set([tuple([1 - e for e in el]), tuple([1 - e if i % 2 == 0 else e for i,e in enumerate(el)]),  tuple([e if i % 2 == 0 else 1 - e for i,e in enumerate(el)]), tuple([1 - e if i % 3 == 0 else e for i,e in enumerate(el)])])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        if n > 6: n = 6 + n % 6\\n        q = set([tuple([0] * n)])\\n        for _ in range(m):  q = set([n for e in q for n in self.neighbours(e)])\\n        #O(mn) = O(11m) = O(m)\\n        #the constant being < 11\\n        return len(q)\\n    def neighbours(self,el):\\n        return set([tuple([1 - e for e in el]), tuple([1 - e if i % 2 == 0 else e for i,e in enumerate(el)]),  tuple([e if i % 2 == 0 else 1 - e for i,e in enumerate(el)]), tuple([1 - e if i % 3 == 0 else e for i,e in enumerate(el)])])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390418,
                "title": "cpp-o-1-case-analysis",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if (m==0) return 1;\\n        if (n==1)\\n            if (m>0)return 2;\\n\\n        if(n==2)\\n            if(m==1)return 3;\\n            else return 4;\\n        \\n        if (m==1)return 4;\\n        if(m==2)return 7;\\n            return 8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if (m==0) return 1;\\n        if (n==1)\\n            if (m>0)return 2;\\n\\n        if(n==2)\\n            if(m==1)return 3;\\n            else return 4;\\n        \\n        if (m==1)return 4;\\n        if(m==2)return 7;\\n            return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357812,
                "title": "same-input-passes-in-test-case-but-not-on-submission-n-3-m-1",
                "content": "```vector<string> result;\\n\\nvoid checkPresence(string s){\\n    vector<string> ::iterator it;\\n    it = find(result.begin(), result.end(), s);\\n    if(it == result.end()){\\n        // std::cout<<\"Entering String : \"<<s<<endl;\\n        result.push_back(s);\\n    }\\n}\\n\\n\\nvoid makePossible(int cases, string s){\\n    switch(cases){\\n        case 1:\\n            for(int i =0; i < s.length(); i++){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 2 :\\n            for(int i = 1; i< s.length(); i+=2){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 3 :\\n            for(int i = 0; i< s.length(); i+=2){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 4 :\\n            for(int i= 0; i <s.length(); i+=3){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n    }\\n    checkPresence(s);\\n}\\n\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n == 1){\\n            return 2;\\n        }\\n        string s = \"\";\\n        while(n > 0){\\n            char ch = 1 + \\'0\\';\\n            s += ch;\\n            n--;\\n        }\\n        result.push_back(s);\\n        while(m){\\n            // std::cout<<\"Here\\\\n\";\\n            for(auto a : result){\\n                makePossible(1, a);\\n                makePossible(2, a);\\n                makePossible(3, a);\\n                makePossible(4, a);\\n            }\\n            m--;\\n        }\\n        return result.size() - 1  ;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```vector<string> result;\\n\\nvoid checkPresence(string s){\\n    vector<string> ::iterator it;\\n    it = find(result.begin(), result.end(), s);\\n    if(it == result.end()){\\n        // std::cout<<\"Entering String : \"<<s<<endl;\\n        result.push_back(s);\\n    }\\n}\\n\\n\\nvoid makePossible(int cases, string s){\\n    switch(cases){\\n        case 1:\\n            for(int i =0; i < s.length(); i++){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 2 :\\n            for(int i = 1; i< s.length(); i+=2){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 3 :\\n            for(int i = 0; i< s.length(); i+=2){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n        case 4 :\\n            for(int i= 0; i <s.length(); i+=3){\\n                s[i] = s[i] == \\'1\\' ? \\'0\\' : \\'1\\';\\n            }\\n            break;\\n    }\\n    checkPresence(s);\\n}\\n\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n == 1){\\n            return 2;\\n        }\\n        string s = \"\";\\n        while(n > 0){\\n            char ch = 1 + \\'0\\';\\n            s += ch;\\n            n--;\\n        }\\n        result.push_back(s);\\n        while(m){\\n            // std::cout<<\"Here\\\\n\";\\n            for(auto a : result){\\n                makePossible(1, a);\\n                makePossible(2, a);\\n                makePossible(3, a);\\n                makePossible(4, a);\\n            }\\n            m--;\\n        }\\n        return result.size() - 1  ;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 253846,
                "title": "do-you-like-for-in-javascript-here-it-is",
                "content": "```javascript\\nvar flipAll = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if(newLights[i] === 1) newLights[i] = 0;\\n        else newLights[i] = 1;\\n    }\\n    return newLights;\\n};\\n\\nvar flipEven = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 2 === 0) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar flipOdd = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 2 !== 0) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar flipNumber = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 3 === 1) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar deleteDuplicatedCase = function(cases) {\\n    var newCases = cases.slice();\\n    for(let i = 0; i < newCases.length; i++) {\\n        for(let j = i + 1; j < newCases.length; j++) {\\n            let isSame = true;\\n            for(let index = 0; index < newCases[i].length; index++) {\\n                if(newCases[i][index] !== newCases[j][index]) {\\n                    isSame = false;\\n                }\\n            }\\n            if(isSame) {\\n                newCases.splice(j, 1);\\n                j--;\\n            }\\n        }\\n    }\\n    return newCases;\\n};\\n\\nvar flipLights = function(n, m) {\\n    var lights = []\\n    var cases = []\\n    if(m === 0) {\\n        return 1;\\n    }\\n    for(let i = 0; i < n; i++) {\\n        lights.push(1);\\n    }\\n    for(let i = 0; i < m; i++) {\\n        const casesLength = cases.length\\n        if(i === 0) {\\n            cases.push(flipAll(lights));\\n            cases.push(flipEven(lights));\\n            cases.push(flipOdd(lights));\\n            cases.push(flipNumber(lights));\\n        } else {\\n            for(let j = 0; j < casesLength; j++) {\\n                cases.push(flipAll(cases[j]));\\n                cases.push(flipEven(cases[j]));\\n                cases.push(flipOdd(cases[j]));\\n                cases.push(flipNumber(cases[j]));\\n            }\\n        }\\n        cases.splice(0, casesLength)\\n        cases = deleteDuplicatedCase(cases).slice();\\n    }\\n    return cases.length;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```javascript\\nvar flipAll = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if(newLights[i] === 1) newLights[i] = 0;\\n        else newLights[i] = 1;\\n    }\\n    return newLights;\\n};\\n\\nvar flipEven = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 2 === 0) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar flipOdd = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 2 !== 0) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar flipNumber = function(lights) {\\n    var newLights = lights.slice();\\n    for(let i = 0; i < newLights.length; i++) {\\n        if((i + 1) % 3 === 1) {\\n            if(newLights[i] === 1) newLights[i] = 0;\\n            else newLights[i] = 1;\\n        }\\n    }\\n    return newLights;\\n};\\n\\nvar deleteDuplicatedCase = function(cases) {\\n    var newCases = cases.slice();\\n    for(let i = 0; i < newCases.length; i++) {\\n        for(let j = i + 1; j < newCases.length; j++) {\\n            let isSame = true;\\n            for(let index = 0; index < newCases[i].length; index++) {\\n                if(newCases[i][index] !== newCases[j][index]) {\\n                    isSame = false;\\n                }\\n            }\\n            if(isSame) {\\n                newCases.splice(j, 1);\\n                j--;\\n            }\\n        }\\n    }\\n    return newCases;\\n};\\n\\nvar flipLights = function(n, m) {\\n    var lights = []\\n    var cases = []\\n    if(m === 0) {\\n        return 1;\\n    }\\n    for(let i = 0; i < n; i++) {\\n        lights.push(1);\\n    }\\n    for(let i = 0; i < m; i++) {\\n        const casesLength = cases.length\\n        if(i === 0) {\\n            cases.push(flipAll(lights));\\n            cases.push(flipEven(lights));\\n            cases.push(flipOdd(lights));\\n            cases.push(flipNumber(lights));\\n        } else {\\n            for(let j = 0; j < casesLength; j++) {\\n                cases.push(flipAll(cases[j]));\\n                cases.push(flipEven(cases[j]));\\n                cases.push(flipOdd(cases[j]));\\n                cases.push(flipNumber(cases[j]));\\n            }\\n        }\\n        cases.splice(0, casesLength)\\n        cases = deleteDuplicatedCase(cases).slice();\\n    }\\n    return cases.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237966,
                "title": "c-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n==0||m==0) return 1;\\n        else if(n==1)return 2;\\n        else if(n==2) return m==1?3:4;\\n        else if(m==1) return 4;\\n        else return m==2?7:8;     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        if(n==0||m==0) return 1;\\n        else if(n==1)return 2;\\n        else if(n==2) return m==1?3:4;\\n        else if(m==1) return 4;\\n        else return m==2?7:8;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 223202,
                "title": "pointless-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        return \"1111122213441478\"[(min(n, 3) * 4) + min(m, 3)] - \\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int flipLights(int n, int m) {\\n        return \"1111122213441478\"[(min(n, 3) * 4) + min(m, 3)] - \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133044,
                "title": "built-recursion-tree-tle",
                "content": "**Idea**\\nI believe this question is more of a Math problem than programming. I tried building a recursion tree without realizing the pattern.\\nAlthough the following approach resulted in TLE, just wanted to put it out there in case if there are no patterns in the solution.\\nPlease comment if you find any pruning I can do for this recursion tree.\\n\\n```\\n    Set<Integer> seen = new HashSet<>();\\n    public int flipLights(int n, int m) {\\n        int[] lights = new int[n+1];\\n        flipLights(lights, 0, m);\\n        return seen.size();\\n    }\\n    private void flipLights(int[] lights, int count, int m){\\n        if(count == m){\\n            seen.add(toInteger(lights));\\n            return;\\n        }\\n        for(int i=1; i <= 4; i++){\\n            int[] tmp = Arrays.copyOf(lights, lights.length);\\n            perform(lights, i);\\n            flipLights(lights, count+1, m);\\n            //reset for new recursion path\\n            lights = Arrays.copyOf(tmp, tmp.length);\\n        }\\n    }\\n    private void perform(int[] lights, int op){\\n        if(op == 1)\\n            for(int i=1; i < lights.length; i++)\\n                lights[i] ^= 1;\\n        else if(op == 2)\\n            for(int i=2; i < lights.length; i+=2)\\n                lights[i] ^= 1;\\n        else if(op == 3)\\n            for(int i=1; i < lights.length; i+=2)\\n                lights[i] ^= 1;\\n        else\\n            for(int k=0; 3*k+1 < lights.length; k++)\\n                lights[3*k+1] ^= 1;\\n    }\\n    private int toInteger(int[] nums){\\n        int sum = 0;\\n        for(int i=1; i < nums.length; i++)\\n            sum = sum*2+nums[i];\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Set<Integer> seen = new HashSet<>();\\n    public int flipLights(int n, int m) {\\n        int[] lights = new int[n+1];\\n        flipLights(lights, 0, m);\\n        return seen.size();\\n    }\\n    private void flipLights(int[] lights, int count, int m){\\n        if(count == m){\\n            seen.add(toInteger(lights));\\n            return;\\n        }\\n        for(int i=1; i <= 4; i++){\\n            int[] tmp = Arrays.copyOf(lights, lights.length);\\n            perform(lights, i);\\n            flipLights(lights, count+1, m);\\n            //reset for new recursion path\\n            lights = Arrays.copyOf(tmp, tmp.length);\\n        }\\n    }\\n    private void perform(int[] lights, int op){\\n        if(op == 1)\\n            for(int i=1; i < lights.length; i++)\\n                lights[i] ^= 1;\\n        else if(op == 2)\\n            for(int i=2; i < lights.length; i+=2)\\n                lights[i] ^= 1;\\n        else if(op == 3)\\n            for(int i=1; i < lights.length; i+=2)\\n                lights[i] ^= 1;\\n        else\\n            for(int k=0; 3*k+1 < lights.length; k++)\\n                lights[3*k+1] ^= 1;\\n    }\\n    private int toInteger(int[] nums){\\n        int sum = 0;\\n        for(int i=1; i < nums.length; i++)\\n            sum = sum*2+nums[i];\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128006,
                "title": "python-o-1-beat-100",
                "content": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        if m == 0: return 1\\n        if n == 1: return 2\\n        if n == 2:\\n            if m == 1: return 3\\n            return 4\\n        if n >= 3:\\n            if m == 1: return 4\\n            if m == 2: return 7        \\n    \\n        return 8\\n        ",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipLights(self, n, m):\\n        if m == 0: return 1\\n        if n == 1: return 2\\n        if n == 2:\\n            if m == 1: return 3\\n            return 4\\n        if n >= 3:\\n            if m == 1: return 4\\n            if m == 2: return 7        \\n    \\n        return 8\\n        ",
                "codeTag": "Java"
            },
            {
                "id": 123343,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (n == 0 || m == 0) return 1;\\n        if (n == 1) return 2;\\n        else if (n == 2) return (m == 1) ? 3 : 4;\\n        else  return (m == 1) ? 4 : (m == 2) ? 7 : 8;\\n    }\\n}\\n\\n/** 1 + 2 -> 3;\\n *  1 + 3 -> 2;\\n *  2 + 3 -> 1;\\n *  so all cases are: all_on, 1, 2, 3, 4, 1+4, 2+4, 3+4;\\n *  when m == 1, can only have 4 states ( 1, 2, 3, 4)\\n *  when m == 2, can only have 7states (all_on, 1, 2, 3, 1+4, 2+4, 3+4)\\n *  when m == 3, can get all 8 states\\n *  special case analysis required when n < 3;\\n */",
                "solutionTags": [],
                "code": "class Solution {\\n    public int flipLights(int n, int m) {\\n        if (n == 0 || m == 0) return 1;\\n        if (n == 1) return 2;\\n        else if (n == 2) return (m == 1) ? 3 : 4;\\n        else  return (m == 1) ? 4 : (m == 2) ? 7 : 8;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 116911,
                "title": "why-is-n-before-m-in-the-function-signature",
                "content": "Is it just me or would it be better practice to put them in alphabetical order, or call them something more informative like `n.lights` and `n.operations`?\n\n```\n    def flipLights(self, n, m):\n```",
                "solutionTags": [],
                "code": "```\n    def flipLights(self, n, m):\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113976,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nint flipLights(int n, int m) {\\n    if(m==0){return 1;}\\n    if(n==1){return 2;}\\n    if(n==2&&m==1){return 3;}\\n    if(n==2){return 4;}\\n    if(m==1){return 4;}\\n    if(m==2){return 7;}\\n    if(m>=3){return 8;}\\n    return 0;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nint flipLights(int n, int m) {\\n    if(m==0){return 1;}\\n    if(n==1){return 2;}\\n    if(n==2&&m==1){return 3;}\\n    if(n==2){return 4;}\\n    if(m==1){return 4;}\\n    if(m==2){return 7;}\\n    if(m>=3){return 8;}\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107268,
                "title": "java-o-1-solution-detail-explaination",
                "content": "for four switches , there are 16 combinations:\\n0000\\n0001\\n0010\\n0011\\n....\\n1110\\n1111\\n\\nas @woshifumingyuan have explained 1+2 = 3, 1+3 = 2, 2+3 = 1\\n\\nso :\\n1. all on        0000 = 1110\\n2. turn on 4   0001 = 1111\\n3. turn on 3   0010 = 1100\\n4. turn on 2   0100 = 1010\\n5.turn on 2+4      0101 = 1011\\n 6.turn on 1         0110 = 1000\\n7.turn on 1+4     0111 = 1001\\n 8.turn on 1+4     0011 = 1101\\ntotally, there are only 8 cases. we reduce 16 cases into 8 cases. \\n\\nbut n <= 2 and m < 3 cases needed to be considered individually because:\\n1. when there is only one light, there will be two status: on and off\\n2. when there are two lights:\\n                                            1. m = 1, only have 3 status: off off, off, on, off on\\n   2 . m >= 2, will have four status: off off, off on, on off, off off.\\n3. when n > 2 && m == 1, will have four status: 0001, 0010, 0100, 1000\\n4. when n > 2 && m == 2, will have 7 status: 0000, 1100, 1010, 0101, 0110, 1001, 0001\\n5. other cases will have 8 status.\\n```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (n == 0) return 0;\\n        if (m == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2 && m == 1) return 3;\\n        if (n == 2) return 4;\\n        if (m == 1) return 4;\\n        if (m == 2) return 7;\\n       return 8;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        if (n == 0) return 0;\\n        if (m == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2 && m == 1) return 3;\\n        if (n == 2) return 4;\\n        if (m == 1) return 4;\\n        if (m == 2) return 7;\\n       return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107275,
                "title": "simple-thought-process-code",
                "content": "It seems that there are many states resulted from different operation sequences, however, if we look at operation sequences more closely(denoted 1,2,3,4 for each operation, 0 for \"no change\"):\\n\\nWhen m = 1:\\n1=1,2=2,3=3,4=4\\n\\nWhen m = 2:\\n11=0,12=3,13=2,14=14\\n21=3,22=0,23=1,24=24\\n31=2,32=1,33=0,34=34\\n41=14,42=24,43=34,44=0\\n\\nso actually, when m = 2:\\n0,1,2,3,4,14,24,34\\n\\nWhen m >=3:\\nI try out when m=3, the sequences are also 0,1,2,3,4,14,24,34, after cancelling the same operations(like 12=3 etc). I then made a guess when m > 3 the case would be the same. \\n\\nAnd also list out some corner cases when n < 3 and m < 3, we get:\\n\\n```\\nclass Solution {\\npublic:\\n    // 1,2,3,4,11=22=33=44,14,24,34\\n    int flipLights(int n, int m) \\n    {\\n        if (!m) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2 && m == 1) return 3;\\n        if (n == 2 && m >= 2) return 4;\\n        if (m == 1) return 4;\\n        if (m == 2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // 1,2,3,4,11=22=33=44,14,24,34\\n    int flipLights(int n, int m) \\n    {\\n        if (!m) return 1;\\n        if (n == 1) return 2;\\n        if (n == 2 && m == 1) return 3;\\n        if (n == 2 && m >= 2) return 4;\\n        if (m == 1) return 4;\\n        if (m == 2) return 7;\\n        return 8;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107276,
                "title": "python-hard-code-o-1-solution",
                "content": "```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        if m == 0 or n == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if m == 1:\\n                return 3\\n            return 4\\n        if n > 2:\\n            if m == 1:\\n                return 4\\n            elif m == 2:\\n                return 7\\n            return 8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipLights(self, n, m):\\n        if m == 0 or n == 0:\\n            return 1\\n        if n == 1:\\n            return 2\\n        if n == 2:\\n            if m == 1:\\n                return 3\\n            return 4\\n        if n > 2:\\n            if m == 1:\\n                return 4\\n            elif m == 2:\\n                return 7\\n            return 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107283,
                "title": "java-verbose-solution-using-hashmap-just-do-the-flip-step-by-step",
                "content": "The idea is to use hashmap to store the visited pattern of the bulbs. So you do not need to do the 4 different flips again. And the usage of set can make sure there is no duplicates.\\n\\n    public int flipLights(int n, int m) {     \\n        StringBuilder status = new StringBuilder();\\n        Map<String, String[]> memo = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            status.append(1);\\n        }\\n        Queue<String> current = new LinkedList<>();\\n        current.offer(status.toString());\\n        for (int i = 0; i < m; i++) {\\n            Set<String> visited = new HashSet<>();\\n            while (current.peek() != null) {\\n                String cs = current.poll();\\n                if (memo.containsKey(cs)) {\\n                    for (int j = 0; j < 4; j++) {\\n                        visited.add(memo.get(cs)[j]);\\n                    }\\n                }\\n                else {\\n                    char[] c1 = cs.toCharArray();\\n                    char[] c2 = cs.toCharArray();\\n                    char[] c3 = cs.toCharArray();\\n                    char[] c4 = cs.toCharArray();\\n                    for (int j = 0; j < n; j++) {\\n                        c1[j] = flip(c1[j]);\\n                        if (j%2 == 0) {\\n                            c2[j] = flip(c2[j]);\\n                        }\\n                        if (j%2 == 1) {\\n                            c3[j] = flip(c3[j]);\\n                        }\\n                        if ( j % 3 == 0) {\\n                            c4[j] = flip(c4[j]);\\n                        }\\n                    }\\n                    StringBuilder s1 = new StringBuilder();\\n                    StringBuilder s2 = new StringBuilder();\\n                    StringBuilder s3 = new StringBuilder();\\n                    StringBuilder s4 = new StringBuilder();\\n                    for (int j = 0; j < n; j++) {\\n                        s1.append(c1[j]);\\n                        s2.append(c2[j]);\\n                        s3.append(c3[j]);\\n                        s4.append(c4[j]);\\n                    }\\n                    visited.add(s1.toString());\\n                    visited.add(s2.toString());\\n                    visited.add(s3.toString());\\n                    visited.add(s4.toString());\\n                    String[] temp = {s1.toString(),s2.toString(),s3.toString(),s4.toString()};\\n                    memo.put(cs, temp);\\n                }\\n            }\\n            for (String str: visited) {\\n                current.offer(str);\\n            }\\n        }\\n        return current.size();\\n    }\\n    private char flip(char i) {\\n        if (i == '1') return '0';\\n        else return '1';\\n    }",
                "solutionTags": [],
                "code": "The idea is to use hashmap to store the visited pattern of the bulbs. So you do not need to do the 4 different flips again. And the usage of set can make sure there is no duplicates.\\n\\n    public int flipLights(int n, int m) {     \\n        StringBuilder status = new StringBuilder();\\n        Map<String, String[]> memo = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            status.append(1);\\n        }\\n        Queue<String> current = new LinkedList<>();\\n        current.offer(status.toString());\\n        for (int i = 0; i < m; i++) {\\n            Set<String> visited = new HashSet<>();\\n            while (current.peek() != null) {\\n                String cs = current.poll();\\n                if (memo.containsKey(cs)) {\\n                    for (int j = 0; j < 4; j++) {\\n                        visited.add(memo.get(cs)[j]);\\n                    }\\n                }\\n                else {\\n                    char[] c1 = cs.toCharArray();\\n                    char[] c2 = cs.toCharArray();\\n                    char[] c3 = cs.toCharArray();\\n                    char[] c4 = cs.toCharArray();\\n                    for (int j = 0; j < n; j++) {\\n                        c1[j] = flip(c1[j]);\\n                        if (j%2 == 0) {\\n                            c2[j] = flip(c2[j]);\\n                        }\\n                        if (j%2 == 1) {\\n                            c3[j] = flip(c3[j]);\\n                        }\\n                        if ( j % 3 == 0) {\\n                            c4[j] = flip(c4[j]);\\n                        }\\n                    }\\n                    StringBuilder s1 = new StringBuilder();\\n                    StringBuilder s2 = new StringBuilder();\\n                    StringBuilder s3 = new StringBuilder();\\n                    StringBuilder s4 = new StringBuilder();\\n                    for (int j = 0; j < n; j++) {\\n                        s1.append(c1[j]);\\n                        s2.append(c2[j]);\\n                        s3.append(c3[j]);\\n                        s4.append(c4[j]);\\n                    }\\n                    visited.add(s1.toString());\\n                    visited.add(s2.toString());\\n                    visited.add(s3.toString());\\n                    visited.add(s4.toString());\\n                    String[] temp = {s1.toString(),s2.toString(),s3.toString(),s4.toString()};\\n                    memo.put(cs, temp);\\n                }\\n            }\\n            for (String str: visited) {\\n                current.offer(str);\\n            }\\n        }\\n        return current.size();\\n    }\\n    private char flip(char i) {\\n        if (i == '1') return '0';\\n        else return '1';\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 107284,
                "title": "java-o-1-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        // for the 4 operations(labeled 1-4, also suppose the original condition is 0):\\n        // 1 + 2 -> 3\\n        // 1 + 3 -> 2\\n        // 2 + 3 -> 1\\n        // So if n <= 2 and m == 1, the conditions are 1,2,3\\n        // if m >= 2, the conditions are 0,1,2,3\\n        // if n > 2, we need to also count condition 4\\n        // if m == 1, the conditions are 1,2,3,4\\n        // if m == 2, the conditions are 0,1,2,3,1+4,2+4,3+4\\n        // if m > 2, the conditions are 0,1,2,3,0+4,1+4,2+4,3+4\\n        if (n == 0) return 0;\\n        if (m == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n <= 2) {\\n            if (m == 1) return 3;\\n            else return 4;\\n        }\\n        else if (m == 1) return 4;\\n        else if (m == 2) return 7;\\n        else return 8;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int flipLights(int n, int m) {\\n        // for the 4 operations(labeled 1-4, also suppose the original condition is 0):\\n        // 1 + 2 -> 3\\n        // 1 + 3 -> 2\\n        // 2 + 3 -> 1\\n        // So if n <= 2 and m == 1, the conditions are 1,2,3\\n        // if m >= 2, the conditions are 0,1,2,3\\n        // if n > 2, we need to also count condition 4\\n        // if m == 1, the conditions are 1,2,3,4\\n        // if m == 2, the conditions are 0,1,2,3,1+4,2+4,3+4\\n        // if m > 2, the conditions are 0,1,2,3,0+4,1+4,2+4,3+4\\n        if (n == 0) return 0;\\n        if (m == 0) return 1;\\n        if (n == 1) return 2;\\n        if (n <= 2) {\\n            if (m == 1) return 3;\\n            else return 4;\\n        }\\n        else if (m == 1) return 4;\\n        else if (m == 2) return 7;\\n        else return 8;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107285,
                "title": "java-solution",
                "content": "Analysis the operations at first:\\n0. Do nothing (dummy rules)\\n1. Flip all the lights.\\n2. Flip lights with even numbers.\\n3. Flip lights with odd numbers.\\n4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...\\n\\nWe can found some rules:\\n1. Do the same operations twice means we do nothing.\\n1 + 1 = 2 + 2 = 3 + 3 = 4 + 4 = 0\\n2. Operations 1, 2, 3 have the relationship:\\n1 + 2 = 3, 1 + 3 = 2, 2 + 3 = 1\\ne..g, we do operations 1 and 2, the result is the same as we just do operation 3.\\n3. Operations 4 is independantly.\\n\\nLet's say n is the number of lights, m is the number of operations.\\nWhen n <= 2, actually operation 4 equals to operation 3. When n = 3, op4 is different with any other operations. So if n > 3, we can just consider as n = 3.\\nWhen m >= 3, whatever the operations are, the results cannot contains any two of operation [0, 1, 2, 3] because of the rule 2. e.g., if the operations are {1, 2, 4}, it would just equal to [3, 4].\\nAll the possible results can be listed : [0+4, 1+4, 2+4, 3+4, 0, 1, 2, 3]. So the result is 8.\\nWhen m == 2, the operation 0+4 cannot happened. So the result is 7.\\n\\n```\\npublic int flipLights(int n, int m) {\\n    int[][] tab = new int[][]{\\n            {1, 1, 1, 1},\\n            {1, 2, 2, 2},\\n            {1, 3, 4, 4},\\n            {1, 4, 7, 8}};\\n    if (n > 3) n = 3;\\n    if (m > 3) m = 3;\\n    return tab[n][m];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n    int[][] tab = new int[][]{\\n            {1, 1, 1, 1},\\n            {1, 2, 2, 2},\\n            {1, 3, 4, 4},\\n            {1, 4, 7, 8}};\\n    if (n > 3) n = 3;\\n    if (m > 3) m = 3;\\n    return tab[n][m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107286,
                "title": "dfs-bfs-swift",
                "content": "```\\nclass Solution {\\n    func flipLights_BFS(_ n: Int, _ m: Int) -> Int {\\n        if n <= 0 || m <= 0 {\\n            return 1\\n        }\\n        \\n        let status = [String](repeatElement(\"1\", count: n))\\n        var queue = [[String]]()\\n        var level = 0\\n        var result = 0\\n        \\n        queue.append(status)\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var visited = Set<String>()\\n            level += 1\\n            for _ in 0..<count {\\n                let status = queue.removeFirst()\\n                let statusArray = [action1(status), action2(status), action3(status), action4(status)]\\n                \\n                for status in statusArray {\\n                    if !visited.contains(status.joined()) {\\n                        if level != m {\\n                            queue.append(status)\\n                        }\\n                        visited.insert(status.joined())\\n                    }\\n                }\\n                \\n                if level == m {\\n                    result = visited.count\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func flipLights_DFS(_ n: Int, _ m: Int) -> Int {\\n        if n <= 0 || m <= 0 {\\n            return 1\\n        }\\n        \\n        let status = [String](repeatElement(\"1\", count: n))\\n        var kinds = Set<String>()\\n        var cache = Set<String>()\\n        \\n        helper(m, status, &kinds, &cache)\\n        \\n        return kinds.count\\n    }\\n    \\n    private func helper(_ remain: Int, _ status: [String], _ kinds: inout Set<String>, _ cache: inout Set<String>) {\\n        if remain == 0 {\\n            kinds.insert(status.joined())\\n            return\\n        }\\n        \\n        let statusArray = [action1(status), action2(status), action3(status), action4(status)]\\n        \\n        for status in statusArray {\\n            if !cache.contains(\"\\\\(remain)_\\\\(status.joined())\") {\\n                helper(remain - 1, status, &kinds, &cache)\\n                cache.insert(\"\\\\(remain)_\\\\(status.joined())\")\\n            }\\n        }\\n    }\\n    \\n    private func action1(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            result.append(flip(status[i]))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action2(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 2 == 0 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action3(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 2 == 1 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action4(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 3 == 1 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func flip(_ status: String) -> String {\\n        return status == \"1\" ? \"0\" : \"1\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func flipLights_BFS(_ n: Int, _ m: Int) -> Int {\\n        if n <= 0 || m <= 0 {\\n            return 1\\n        }\\n        \\n        let status = [String](repeatElement(\"1\", count: n))\\n        var queue = [[String]]()\\n        var level = 0\\n        var result = 0\\n        \\n        queue.append(status)\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var visited = Set<String>()\\n            level += 1\\n            for _ in 0..<count {\\n                let status = queue.removeFirst()\\n                let statusArray = [action1(status), action2(status), action3(status), action4(status)]\\n                \\n                for status in statusArray {\\n                    if !visited.contains(status.joined()) {\\n                        if level != m {\\n                            queue.append(status)\\n                        }\\n                        visited.insert(status.joined())\\n                    }\\n                }\\n                \\n                if level == m {\\n                    result = visited.count\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func flipLights_DFS(_ n: Int, _ m: Int) -> Int {\\n        if n <= 0 || m <= 0 {\\n            return 1\\n        }\\n        \\n        let status = [String](repeatElement(\"1\", count: n))\\n        var kinds = Set<String>()\\n        var cache = Set<String>()\\n        \\n        helper(m, status, &kinds, &cache)\\n        \\n        return kinds.count\\n    }\\n    \\n    private func helper(_ remain: Int, _ status: [String], _ kinds: inout Set<String>, _ cache: inout Set<String>) {\\n        if remain == 0 {\\n            kinds.insert(status.joined())\\n            return\\n        }\\n        \\n        let statusArray = [action1(status), action2(status), action3(status), action4(status)]\\n        \\n        for status in statusArray {\\n            if !cache.contains(\"\\\\(remain)_\\\\(status.joined())\") {\\n                helper(remain - 1, status, &kinds, &cache)\\n                cache.insert(\"\\\\(remain)_\\\\(status.joined())\")\\n            }\\n        }\\n    }\\n    \\n    private func action1(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            result.append(flip(status[i]))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action2(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 2 == 0 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action3(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 2 == 1 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func action4(_ status: [String]) -> [String] {\\n        var result = [String]()\\n        \\n        for i in 0..<status.count {\\n            if (i + 1) % 3 == 1 {\\n                result.append(flip(status[i]))\\n            } else {\\n                result.append(status[i])\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func flip(_ status: String) -> String {\\n        return status == \"1\" ? \"0\" : \"1\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107287,
                "title": "o-1-java-bit-operation",
                "content": "Java O(1) solution:\\n\\nExplain: \\n\\n*  for n > 3, result is same as n = 3, if same series of operations apply on 3 bulbs generate k distinct result, apply them on more than 3 bulbs would also generate k distinct result.\\n*  only even and odd matters for each operation. So the total possible op series would be [0,0,0,0], [0,0,0,1]...to [1,1,1,1], 16 total\\n*  order of operations doesn't matter\\n\\n```\\npublic int flipLights(int n, int m) {\\n        int odd = 0b101;\\n        int even = 0b010;\\n        int three = 0b001;\\n        if (n > 3) n = 3;\\n        Set<Integer> res = new HashSet<>();\\n        for (int i = 0; i < 16; ++i) {\\n            int cnt = 0;\\n\\n            for (int k = 0; k < 4; ++k) if ((i&(1<<k)) != 0)++cnt;\\n            if (cnt % 2 != m % 2 || m < cnt) continue;\\n            int v = (1 << n) - 1;\\n            int mask = v;\\n            if ((i & 1) != 0) v = ~v;\\n            if ((i & 2) != 0) v = even&~v|v&~even;\\n            if ((i & 4) != 0) v = odd&~v|v&~odd;\\n            if ((i & 8) != 0) v = three&~v|v&~three;\\n            res.add(v&mask);\\n        }\\n        return res.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int flipLights(int n, int m) {\\n        int odd = 0b101;\\n        int even = 0b010;\\n        int three = 0b001;\\n        if (n > 3) n = 3;\\n        Set<Integer> res = new HashSet<>();\\n        for (int i = 0; i < 16; ++i) {\\n            int cnt = 0;\\n\\n            for (int k = 0; k < 4; ++k) if ((i&(1<<k)) != 0)++cnt;\\n            if (cnt % 2 != m % 2 || m < cnt) continue;\\n            int v = (1 << n) - 1;\\n            int mask = v;\\n            if ((i & 1) != 0) v = ~v;\\n            if ((i & 2) != 0) v = even&~v|v&~even;\\n            if ((i & 4) != 0) v = odd&~v|v&~odd;\\n            if ((i & 8) != 0) v = three&~v|v&~three;\\n            res.add(v&mask);\\n        }\\n        return res.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107289,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int FlipLights(int n, int m) {\\n        if(m == 0)\\n            return 1;\\n        if(n == 0)\\n            return 1;\\n        else if(n == 1)\\n            return 2;\\n        \\n        if(n > 4)\\n            n=4;\\n        \\n        HashSet<int> pool = new HashSet<int>();\\n        int max = 1 << n;\\n        pool.Add(max-1);\\n        int b1 = 15 >> (4-n);\\n        int b2 = 10 >> (4-n);\\n        int b3 = 5 >> (4-n);\\n        int b4 = 9 >> (4-n);\\n        while(m > 0 && pool.Count() < max){\\n            HashSet<int> newpool = new HashSet<int>();\\n            foreach(var item in pool){\\n                newpool.Add(item ^ b1);\\n                newpool.Add(item ^ b2);\\n                newpool.Add(item ^ b3);\\n                newpool.Add(item ^ b4);\\n            }\\n            pool = newpool;\\n            m--;\\n        }\\n        \\n        return pool.Count();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FlipLights(int n, int m) {\\n        if(m == 0)\\n            return 1;\\n        if(n == 0)\\n            return 1;\\n        else if(n == 1)\\n            return 2;\\n        \\n        if(n > 4)\\n            n=4;\\n        \\n        HashSet<int> pool = new HashSet<int>();\\n        int max = 1 << n;\\n        pool.Add(max-1);\\n        int b1 = 15 >> (4-n);\\n        int b2 = 10 >> (4-n);\\n        int b3 = 5 >> (4-n);\\n        int b4 = 9 >> (4-n);\\n        while(m > 0 && pool.Count() < max){\\n            HashSet<int> newpool = new HashSet<int>();\\n            foreach(var item in pool){\\n                newpool.Add(item ^ b1);\\n                newpool.Add(item ^ b2);\\n                newpool.Add(item ^ b3);\\n                newpool.Add(item ^ b4);\\n            }\\n            pool = newpool;\\n            m--;\\n        }\\n        \\n        return pool.Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565085,
                "content": [
                    {
                        "username": "gunax",
                        "content": "So it\\'s a somewhat interesting problem, but only if you think of it as a math problem. As a programming problem, i think it\\'s lame.\\n\\nGiven a set of operations, what state would the lights end up in?\\nLet\\'s call f(a) the new state of the lights after performing a\\n\\nLet\\'s add another switch, switch 0, the identity switch (switch 0 does nothing).\\nl1: f(0a) = f(a)\\n\\nFirst, note that flipping is commutative: order does not matter.\\nl2: f(ab) = f(ba)\\n\\nsecond, each function is an inverse of itself:\\nl3: f(aa) = f(0)\\n\\nfinally, note that there flipping odds and evens is the same as flipping all:\\nl4: f(23) = f(1)\\n\\tf(12) = f(3)\\n\\tf(13) = f(2)\\n\\nNow we can reduce any sequence to something much simpler.\\ntake a sequence like:\\n14342\\nby lemma 2 we can re-order:\\n12344\\nusing l4:\\n1144\\nthen by l3:\\n00\\nwhich is just the starting position.\\n\\nIt turns out that we only care then if there is an even or odd number of each flip. The total enumeration of states is:\\n0\\n1\\n2\\n3\\n4\\n12\\n13\\n14\\n23\\n24\\n34\\n123\\n124\\n134\\n234\\n1234\\n\\n16 states... but wait, using lemma 4, some of these are the same (eg 134 = 24). Removing the redundancies from the list above:\\n0\\n1\\n2\\n3\\n4\\n14\\n24\\n34\\n\\nwe get 8 states.\\nSo for a sufficiently high m (turns out its >= 3), we get:\\nflipLights(0) = 1;\\nflipLights(1) = 4\\nflipLights(2+) = 8\\n\\nI am done. This was a waste."
                    },
                    {
                        "username": "yorkshire",
                        "content": "I guess it ought to be, with expected zero output.\nNo lights can have no status.\nBut the OJ seems to output a positive integer eg n = 0, m = 3 outputs 4."
                    },
                    {
                        "username": "awice",
                        "content": "**Firstly, we may take `n = min(n, 3)`.**  The sequence of lights clearly repeats every 6, so the first 6 lights are representative of the whole sequence, as we can construct eg. the 7th light (it's equal to the 1st).\\n\\nActually, the first 3 lights are representative of the whole sequence.  If the operations are a, b, c, d; then modulo 2:\\n\\n* Light 1 = 1 + a + c + d\\n* Light 2 = 1 + a + b\\n* Light 3 = 1 + a + c\\n* Light 4 = 1 + a + b + d\\n* Light 5 = 1 + a + c\\n* Light 6 = 1 + a + b\\n\\nSo that (modulo 2):\\n* Light 4 = (Light 1) + (Light 2) + (Light 3)\\n* Light 5 = Light 3, and \\n* Light 6 = Light 2.\\n\\n---\\n\\nNow, we can do cases on `m`, and analyze the possible lightbulb states for `n >= 3`.  The transitions are to XOR by (1, 1, 1), (0, 1, 0), (1, 0, 1), or (1, 0, 0).\\n\\n* If `m = 0` there is only one state `(1, 1, 1)`.\\n* If `m = 1` then we could get `(0, 0, 0), (1, 0, 1), (0, 1, 0), (0, 1, 1)`.\\n* If `m = 2` we could get all 8 possibilities except `(0, 1, 1)`.\\n* If `m = 3` we can get every possibility.\\n\\nThis reduced the problem to knowing the answer for `m <= 3, n <= 3`.  The final answer is:\\n\\n* When `n == 1`, the answer is 1 if `m == 0`, else 2.\\n* When `n == 2`, the answer is 1 if `m == 0`, 3 if `m == 1`, else 4.\\n* When `n >= 3`, the answer is 1 if `m == 0`, 4 if `m == 1`, 7 if `m == 2`, else 8."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "pretty hard for a med lol"
                    }
                ]
            },
            {
                "id": 1568010,
                "content": [
                    {
                        "username": "gunax",
                        "content": "So it\\'s a somewhat interesting problem, but only if you think of it as a math problem. As a programming problem, i think it\\'s lame.\\n\\nGiven a set of operations, what state would the lights end up in?\\nLet\\'s call f(a) the new state of the lights after performing a\\n\\nLet\\'s add another switch, switch 0, the identity switch (switch 0 does nothing).\\nl1: f(0a) = f(a)\\n\\nFirst, note that flipping is commutative: order does not matter.\\nl2: f(ab) = f(ba)\\n\\nsecond, each function is an inverse of itself:\\nl3: f(aa) = f(0)\\n\\nfinally, note that there flipping odds and evens is the same as flipping all:\\nl4: f(23) = f(1)\\n\\tf(12) = f(3)\\n\\tf(13) = f(2)\\n\\nNow we can reduce any sequence to something much simpler.\\ntake a sequence like:\\n14342\\nby lemma 2 we can re-order:\\n12344\\nusing l4:\\n1144\\nthen by l3:\\n00\\nwhich is just the starting position.\\n\\nIt turns out that we only care then if there is an even or odd number of each flip. The total enumeration of states is:\\n0\\n1\\n2\\n3\\n4\\n12\\n13\\n14\\n23\\n24\\n34\\n123\\n124\\n134\\n234\\n1234\\n\\n16 states... but wait, using lemma 4, some of these are the same (eg 134 = 24). Removing the redundancies from the list above:\\n0\\n1\\n2\\n3\\n4\\n14\\n24\\n34\\n\\nwe get 8 states.\\nSo for a sufficiently high m (turns out its >= 3), we get:\\nflipLights(0) = 1;\\nflipLights(1) = 4\\nflipLights(2+) = 8\\n\\nI am done. This was a waste."
                    },
                    {
                        "username": "yorkshire",
                        "content": "I guess it ought to be, with expected zero output.\nNo lights can have no status.\nBut the OJ seems to output a positive integer eg n = 0, m = 3 outputs 4."
                    },
                    {
                        "username": "awice",
                        "content": "**Firstly, we may take `n = min(n, 3)`.**  The sequence of lights clearly repeats every 6, so the first 6 lights are representative of the whole sequence, as we can construct eg. the 7th light (it's equal to the 1st).\\n\\nActually, the first 3 lights are representative of the whole sequence.  If the operations are a, b, c, d; then modulo 2:\\n\\n* Light 1 = 1 + a + c + d\\n* Light 2 = 1 + a + b\\n* Light 3 = 1 + a + c\\n* Light 4 = 1 + a + b + d\\n* Light 5 = 1 + a + c\\n* Light 6 = 1 + a + b\\n\\nSo that (modulo 2):\\n* Light 4 = (Light 1) + (Light 2) + (Light 3)\\n* Light 5 = Light 3, and \\n* Light 6 = Light 2.\\n\\n---\\n\\nNow, we can do cases on `m`, and analyze the possible lightbulb states for `n >= 3`.  The transitions are to XOR by (1, 1, 1), (0, 1, 0), (1, 0, 1), or (1, 0, 0).\\n\\n* If `m = 0` there is only one state `(1, 1, 1)`.\\n* If `m = 1` then we could get `(0, 0, 0), (1, 0, 1), (0, 1, 0), (0, 1, 1)`.\\n* If `m = 2` we could get all 8 possibilities except `(0, 1, 1)`.\\n* If `m = 3` we can get every possibility.\\n\\nThis reduced the problem to knowing the answer for `m <= 3, n <= 3`.  The final answer is:\\n\\n* When `n == 1`, the answer is 1 if `m == 0`, else 2.\\n* When `n == 2`, the answer is 1 if `m == 0`, 3 if `m == 1`, else 4.\\n* When `n >= 3`, the answer is 1 if `m == 0`, 4 if `m == 1`, 7 if `m == 2`, else 8."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "pretty hard for a med lol"
                    }
                ]
            },
            {
                "id": 1569148,
                "content": [
                    {
                        "username": "gunax",
                        "content": "So it\\'s a somewhat interesting problem, but only if you think of it as a math problem. As a programming problem, i think it\\'s lame.\\n\\nGiven a set of operations, what state would the lights end up in?\\nLet\\'s call f(a) the new state of the lights after performing a\\n\\nLet\\'s add another switch, switch 0, the identity switch (switch 0 does nothing).\\nl1: f(0a) = f(a)\\n\\nFirst, note that flipping is commutative: order does not matter.\\nl2: f(ab) = f(ba)\\n\\nsecond, each function is an inverse of itself:\\nl3: f(aa) = f(0)\\n\\nfinally, note that there flipping odds and evens is the same as flipping all:\\nl4: f(23) = f(1)\\n\\tf(12) = f(3)\\n\\tf(13) = f(2)\\n\\nNow we can reduce any sequence to something much simpler.\\ntake a sequence like:\\n14342\\nby lemma 2 we can re-order:\\n12344\\nusing l4:\\n1144\\nthen by l3:\\n00\\nwhich is just the starting position.\\n\\nIt turns out that we only care then if there is an even or odd number of each flip. The total enumeration of states is:\\n0\\n1\\n2\\n3\\n4\\n12\\n13\\n14\\n23\\n24\\n34\\n123\\n124\\n134\\n234\\n1234\\n\\n16 states... but wait, using lemma 4, some of these are the same (eg 134 = 24). Removing the redundancies from the list above:\\n0\\n1\\n2\\n3\\n4\\n14\\n24\\n34\\n\\nwe get 8 states.\\nSo for a sufficiently high m (turns out its >= 3), we get:\\nflipLights(0) = 1;\\nflipLights(1) = 4\\nflipLights(2+) = 8\\n\\nI am done. This was a waste."
                    },
                    {
                        "username": "yorkshire",
                        "content": "I guess it ought to be, with expected zero output.\nNo lights can have no status.\nBut the OJ seems to output a positive integer eg n = 0, m = 3 outputs 4."
                    },
                    {
                        "username": "awice",
                        "content": "**Firstly, we may take `n = min(n, 3)`.**  The sequence of lights clearly repeats every 6, so the first 6 lights are representative of the whole sequence, as we can construct eg. the 7th light (it's equal to the 1st).\\n\\nActually, the first 3 lights are representative of the whole sequence.  If the operations are a, b, c, d; then modulo 2:\\n\\n* Light 1 = 1 + a + c + d\\n* Light 2 = 1 + a + b\\n* Light 3 = 1 + a + c\\n* Light 4 = 1 + a + b + d\\n* Light 5 = 1 + a + c\\n* Light 6 = 1 + a + b\\n\\nSo that (modulo 2):\\n* Light 4 = (Light 1) + (Light 2) + (Light 3)\\n* Light 5 = Light 3, and \\n* Light 6 = Light 2.\\n\\n---\\n\\nNow, we can do cases on `m`, and analyze the possible lightbulb states for `n >= 3`.  The transitions are to XOR by (1, 1, 1), (0, 1, 0), (1, 0, 1), or (1, 0, 0).\\n\\n* If `m = 0` there is only one state `(1, 1, 1)`.\\n* If `m = 1` then we could get `(0, 0, 0), (1, 0, 1), (0, 1, 0), (0, 1, 1)`.\\n* If `m = 2` we could get all 8 possibilities except `(0, 1, 1)`.\\n* If `m = 3` we can get every possibility.\\n\\nThis reduced the problem to knowing the answer for `m <= 3, n <= 3`.  The final answer is:\\n\\n* When `n == 1`, the answer is 1 if `m == 0`, else 2.\\n* When `n == 2`, the answer is 1 if `m == 0`, 3 if `m == 1`, else 4.\\n* When `n >= 3`, the answer is 1 if `m == 0`, 4 if `m == 1`, 7 if `m == 2`, else 8."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "pretty hard for a med lol"
                    }
                ]
            },
            {
                "id": 2042249,
                "content": [
                    {
                        "username": "gunax",
                        "content": "So it\\'s a somewhat interesting problem, but only if you think of it as a math problem. As a programming problem, i think it\\'s lame.\\n\\nGiven a set of operations, what state would the lights end up in?\\nLet\\'s call f(a) the new state of the lights after performing a\\n\\nLet\\'s add another switch, switch 0, the identity switch (switch 0 does nothing).\\nl1: f(0a) = f(a)\\n\\nFirst, note that flipping is commutative: order does not matter.\\nl2: f(ab) = f(ba)\\n\\nsecond, each function is an inverse of itself:\\nl3: f(aa) = f(0)\\n\\nfinally, note that there flipping odds and evens is the same as flipping all:\\nl4: f(23) = f(1)\\n\\tf(12) = f(3)\\n\\tf(13) = f(2)\\n\\nNow we can reduce any sequence to something much simpler.\\ntake a sequence like:\\n14342\\nby lemma 2 we can re-order:\\n12344\\nusing l4:\\n1144\\nthen by l3:\\n00\\nwhich is just the starting position.\\n\\nIt turns out that we only care then if there is an even or odd number of each flip. The total enumeration of states is:\\n0\\n1\\n2\\n3\\n4\\n12\\n13\\n14\\n23\\n24\\n34\\n123\\n124\\n134\\n234\\n1234\\n\\n16 states... but wait, using lemma 4, some of these are the same (eg 134 = 24). Removing the redundancies from the list above:\\n0\\n1\\n2\\n3\\n4\\n14\\n24\\n34\\n\\nwe get 8 states.\\nSo for a sufficiently high m (turns out its >= 3), we get:\\nflipLights(0) = 1;\\nflipLights(1) = 4\\nflipLights(2+) = 8\\n\\nI am done. This was a waste."
                    },
                    {
                        "username": "yorkshire",
                        "content": "I guess it ought to be, with expected zero output.\nNo lights can have no status.\nBut the OJ seems to output a positive integer eg n = 0, m = 3 outputs 4."
                    },
                    {
                        "username": "awice",
                        "content": "**Firstly, we may take `n = min(n, 3)`.**  The sequence of lights clearly repeats every 6, so the first 6 lights are representative of the whole sequence, as we can construct eg. the 7th light (it's equal to the 1st).\\n\\nActually, the first 3 lights are representative of the whole sequence.  If the operations are a, b, c, d; then modulo 2:\\n\\n* Light 1 = 1 + a + c + d\\n* Light 2 = 1 + a + b\\n* Light 3 = 1 + a + c\\n* Light 4 = 1 + a + b + d\\n* Light 5 = 1 + a + c\\n* Light 6 = 1 + a + b\\n\\nSo that (modulo 2):\\n* Light 4 = (Light 1) + (Light 2) + (Light 3)\\n* Light 5 = Light 3, and \\n* Light 6 = Light 2.\\n\\n---\\n\\nNow, we can do cases on `m`, and analyze the possible lightbulb states for `n >= 3`.  The transitions are to XOR by (1, 1, 1), (0, 1, 0), (1, 0, 1), or (1, 0, 0).\\n\\n* If `m = 0` there is only one state `(1, 1, 1)`.\\n* If `m = 1` then we could get `(0, 0, 0), (1, 0, 1), (0, 1, 0), (0, 1, 1)`.\\n* If `m = 2` we could get all 8 possibilities except `(0, 1, 1)`.\\n* If `m = 3` we can get every possibility.\\n\\nThis reduced the problem to knowing the answer for `m <= 3, n <= 3`.  The final answer is:\\n\\n* When `n == 1`, the answer is 1 if `m == 0`, else 2.\\n* When `n == 2`, the answer is 1 if `m == 0`, 3 if `m == 1`, else 4.\\n* When `n >= 3`, the answer is 1 if `m == 0`, 4 if `m == 1`, 7 if `m == 2`, else 8."
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "pretty hard for a med lol"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Longest Increasing Subsequence",
        "question_content": "<p>Given an integer array&nbsp;<code>nums</code>, return <em>the number of longest increasing subsequences.</em></p>\n\n<p><strong>Notice</strong> that the sequence has to be <strong>strictly</strong> increasing.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,4,7]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 107293,
                "title": "java-c-simple-dp-solution-with-explanation",
                "content": "The idea is to use two arrays ```len[n]``` and ```cnt[n]``` to record the maximum length of Increasing Subsequence and the coresponding number of these sequence which ends with ```nums[i]```, respectively. That is:\\n\\n```len[i]```: the length of the Longest Increasing Subsequence which ends with ```nums[i]```.\\n```cnt[i]```: the number of the Longest Increasing Subsequence which ends with ```nums[i]```.\\n\\nThen, the result is the sum of each ```cnt[i]``` while its corresponding ```len[i]``` is the maximum length.\\n\\nJava version:\\n```\\npublic int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, res = 0, max_len = 0;\\n        int[] len =  new int[n], cnt = new int[n];\\n        for(int i = 0; i<n; i++){\\n            len[i] = cnt[i] = 1;\\n            for(int j = 0; j <i ; j++){\\n                if(nums[i] > nums[j]){\\n                    if(len[i] == len[j] + 1)cnt[i] += cnt[j];\\n                    if(len[i] < len[j] + 1){\\n                        len[i] = len[j] + 1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                }\\n            }\\n            if(max_len == len[i])res += cnt[i];\\n            if(max_len < len[i]){\\n                max_len = len[i];\\n                res = cnt[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nC++ version: (use ```vector<pair<int, int>> dp``` to combine ```len[]``` and ```cnt[]```)\\n```\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), res = 0, max_len = 0;\\n        vector<pair<int,int>> dp(n,{1,1});            //dp[i]: {length, number of LIS which ends with nums[i]}\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j <i ; j++){\\n                if(nums[i] > nums[j]){\\n                    if(dp[i].first == dp[j].first + 1)dp[i].second += dp[j].second;\\n                    if(dp[i].first < dp[j].first + 1)dp[i] = {dp[j].first + 1, dp[j].second};\\n                }\\n            }\\n            if(max_len == dp[i].first)res += dp[i].second;\\n            if(max_len < dp[i].first){\\n                max_len = dp[i].first;\\n                res = dp[i].second;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```len[n]```\n```cnt[n]```\n```nums[i]```\n```len[i]```\n```nums[i]```\n```cnt[i]```\n```nums[i]```\n```cnt[i]```\n```len[i]```\n```\\npublic int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, res = 0, max_len = 0;\\n        int[] len =  new int[n], cnt = new int[n];\\n        for(int i = 0; i<n; i++){\\n            len[i] = cnt[i] = 1;\\n            for(int j = 0; j <i ; j++){\\n                if(nums[i] > nums[j]){\\n                    if(len[i] == len[j] + 1)cnt[i] += cnt[j];\\n                    if(len[i] < len[j] + 1){\\n                        len[i] = len[j] + 1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                }\\n            }\\n            if(max_len == len[i])res += cnt[i];\\n            if(max_len < len[i]){\\n                max_len = len[i];\\n                res = cnt[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\n```vector<pair<int, int>> dp```\n```len[]```\n```cnt[]```\n```\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), res = 0, max_len = 0;\\n        vector<pair<int,int>> dp(n,{1,1});            //dp[i]: {length, number of LIS which ends with nums[i]}\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j <i ; j++){\\n                if(nums[i] > nums[j]){\\n                    if(dp[i].first == dp[j].first + 1)dp[i].second += dp[j].second;\\n                    if(dp[i].first < dp[j].first + 1)dp[i] = {dp[j].first + 1, dp[j].second};\\n                }\\n            }\\n            if(max_len == dp[i].first)res += dp[i].second;\\n            if(max_len < dp[i].first){\\n                max_len = dp[i].first;\\n                res = dp[i].second;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1230468,
                "title": "c-clean-dp-solution-easy-and-explained",
                "content": "Let\\'s have a look on the implementation-\\n\\n\\u2714**C++ Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> lis(n,1);  // stores length of longest sequence till i-th position\\n        vector<int> count(n,1);  // stores count of longest sequence of length lis[i]\\n        int maxLen = 1;  // maximum length of lis\\n\\t\\t\\n\\t\\t// O(N^2) DP Solution\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(lis[j] + 1 > lis[i]){ // strictly increasing\\n                        lis[i] = lis[j] + 1;\\n                        count[i] = count[j];\\n                    } \\n\\t\\t\\t\\t\\t // this means there are more subsequences of same length ending at length lis[i]\\n\\t\\t\\t\\t\\telse if(lis[j]+1 == lis[i]){ \\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLen = max(maxLen,lis[i]);\\n        }\\n        \\n        int numOfLIS = 0;\\n        // count all the subseq of length maxLen\\n        for(int i=0;i<n;i++){\\n            if(lis[i]==maxLen)\\n                numOfLIS += count[i];\\n        }\\n            \\n        return numOfLIS;\\n    }\\n};\\n```\\n\\n# Kindly Upvote :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> lis(n,1);  // stores length of longest sequence till i-th position\\n        vector<int> count(n,1);  // stores count of longest sequence of length lis[i]\\n        int maxLen = 1;  // maximum length of lis\\n\\t\\t\\n\\t\\t// O(N^2) DP Solution\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(lis[j] + 1 > lis[i]){ // strictly increasing\\n                        lis[i] = lis[j] + 1;\\n                        count[i] = count[j];\\n                    } \\n\\t\\t\\t\\t\\t // this means there are more subsequences of same length ending at length lis[i]\\n\\t\\t\\t\\t\\telse if(lis[j]+1 == lis[i]){ \\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLen = max(maxLen,lis[i]);\\n        }\\n        \\n        int numOfLIS = 0;\\n        // count all the subseq of length maxLen\\n        for(int i=0;i<n;i++){\\n            if(lis[i]==maxLen)\\n                numOfLIS += count[i];\\n        }\\n            \\n        return numOfLIS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107295,
                "title": "9ms-c-explanation-dp-binary-search-prefix-sums-o-nlogn-time-o-n-space",
                "content": "The idea is to modify classic [LIS solution which uses binary search]( https://en.wikipedia.org/wiki/Longest_increasing_subsequence) to find the \"insertion point\" of a currently processed value. At ```dyn[k]``` we **don\\'t store** a single number representing the smallest value such that there exists a LIS of length ```k+1``` as in classic LIS solution. Instead, at ```dyn[k]``` we store all such values that were once endings of a ```k+1``` LIS (so we keep the history as well). \\nThese values are held in the first part of the pairs in  ```vector<pair<int,int>>``` which we get by indexing ```dyn``` vector. So for example in a pair ```x = {a, b}``` the first part -- ```a```, indicates that there exists a LIS of length ```k+1``` such that it ends with a value ```a```. The second part -- ```b```, represents the number of possible options for which LIS of length ```k+1``` ends with a value equal to or greater than ```a```. This is the place where we use prefix sums. \\nIf we want to know how many options do we have to end a LIS of length ```m``` with value ```y```, we just binary search for the index ```i``` of a pair with first part strictly less than ```y``` in ```dyn[m-2]```. Then the number of options is ```dyn[m-2].back().second - dyn[m-2][i-1].second``` or just ```dyn[m-2].back()``` if ```i``` is ```0```.\\nThat is the basic idea, the running time is O(NlogN), because we just do 2 binary searches for every element of the input. Space complexity is O(N), as every element of the input will be contained in the ```dyn``` vector exactly once.\\nFeel free to post any corrections or simpler explanations :)\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if (nums.empty())\\n            return 0;\\n        \\n        vector<vector<pair<int, int>>> dyn(nums.size() + 1);\\n        int max_so_far = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // bsearch insertion point\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (dyn[mid].back().first < nums[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            \\n            // bsearch number of options\\n            int options = 1;\\n            int row = l - 1;\\n            if (row >= 0) {\\n                int l1 = 0, r1 = dyn[row].size();\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (dyn[row][mid].first < nums[i]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                \\n                options = dyn[row].back().second;\\n                options -= (l1 == 0) ? 0 : dyn[row][l1 - 1].second;\\n            }\\n            \\n            \\n            dyn[l].push_back({nums[i], (dyn[l].empty() ? options : dyn[l].back().second + options)});\\n            if (l == max_so_far) {\\n                max_so_far++;\\n            }\\n        }\\n        \\n        return dyn[max_so_far-1].back().second;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```dyn[k]```\n```k+1```\n```dyn[k]```\n```k+1```\n```vector<pair<int,int>>```\n```dyn```\n```x = {a, b}```\n```a```\n```k+1```\n```a```\n```b```\n```k+1```\n```a```\n```m```\n```y```\n```i```\n```y```\n```dyn[m-2]```\n```dyn[m-2].back().second - dyn[m-2][i-1].second```\n```dyn[m-2].back()```\n```i```\n```0```\n```dyn```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if (nums.empty())\\n            return 0;\\n        \\n        vector<vector<pair<int, int>>> dyn(nums.size() + 1);\\n        int max_so_far = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // bsearch insertion point\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (dyn[mid].back().first < nums[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            \\n            // bsearch number of options\\n            int options = 1;\\n            int row = l - 1;\\n            if (row >= 0) {\\n                int l1 = 0, r1 = dyn[row].size();\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (dyn[row][mid].first < nums[i]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                \\n                options = dyn[row].back().second;\\n                options -= (l1 == 0) ? 0 : dyn[row][l1 - 1].second;\\n            }\\n            \\n            \\n            dyn[l].push_back({nums[i], (dyn[l].empty() ? options : dyn[l].back().second + options)});\\n            if (l == max_so_far) {\\n                max_so_far++;\\n            }\\n        }\\n        \\n        return dyn[max_so_far-1].back().second;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835323,
                "title": "python-3-dp-explanation",
                "content": "### Intuition\\n- To find the frequency of the longest increasing sequence, we need \\n\\t- First, know how long is the longest increasing sequence\\n\\t- Second, count the frequency\\n- Thus, we create 2 lists with length `n`\\n\\t- `dp[i]`: meaning length of longest increasing sequence\\n\\t- `cnt[i]`: meaning frequency of longest increasing sequence\\n- If `dp[i] < dp[j] + 1` meaning we found a longer sequence and `dp[i]` need to be updated, then `cnt[i]` need to be updated to `cnt[j]`\\n- If `dp[i] == dp[j] + 1` meaning `dp[j] + 1` is one way to reach longest increasing sequence to `i`, so simple increment by `cnt[j]` like this `cnt[i] = cnt[i] + cnt[j]`\\n- Finally, sum up `cnt` of all longest increase sequence will be the solution\\n- This is a pretty standard DP question. Just like most sequence type of DP question, we need to loop over each element and check all previous stored information to update current. \\n- Time complexity is `O(n*n)`\\n### Implementation\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        n = len(nums)\\n        m, dp, cnt = 0, [1] * n, [1] * n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]\\n                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]\\n            m = max(m, dp[i])                        \\n        return sum(c for l, c in zip(dp, cnt) if l == m)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        n = len(nums)\\n        m, dp, cnt = 0, [1] * n, [1] * n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]\\n                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]\\n            m = max(m, dp[i])                        \\n        return sum(c for l, c in zip(dp, cnt) if l == m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916196,
                "title": "python-short-o-n-log-n-solution-beats-100-explained",
                "content": "The idea of my solution is to use so-called Patience sort: https://en.wikipedia.org/wiki/Patience_sorting\\n\\nThe idea is to keep several `decks`, where numbers in each deck are decreasing. Also when we see new card, we need to put it to the end of the leftest possible deck. Also we have `paths`: corresponing number of LIS, ending with given `num`. That is in `paths[0]` we keep number of LIS with length `1`, in `paths[k]` we keep number of LIS with length `k+1`. (we keep cumulative sums) Also we keep `ends_decks` list to have quick access to end of our decks.\\n\\n**Property**: It can be proved, that each LIS can be formed as choosing not more than one number from each deck and choosing them, looking at decks from left to right.\\n\\nImagine, that we have `nums = [1,3,5,4,7,10,8,2,8]`, then we have the following `decks` and `paths` step by step:\\n\\n`decks =  [[-1]] paths =  [[0, 1]]`\\n`decks =  [[-1], [-3]] paths =  [[0, 1], [0, 1]]`\\n`decks =  [[-1], [-3], [-5]] paths =  [[0, 1], [0, 1], [0, 1]]`\\n`decks =  [[-1], [-3], [-5, -4]] paths =  [[0, 1], [0, 1], [0, 1, 2]]`\\n`decks =  [[-1], [-3], [-5, -4], [-7]] paths =  [[0, 1], [0, 1], [0, 1, 2], [0, 2]]`\\n`decks =  [[-1], [-3], [-5, -4], [-7], [-10]] paths =  [[0, 1], [0, 1], [0, 1, 2], [0, 2], [0, 2]]`\\n`decks =  [[-1], [-3], [-5, -4], [-7], [-10, -8]] paths =  [[0, 1], [0, 1], [0, 1, 2], [0, 2], [0, 2, 4]]`\\n`decks =  [[-1], [-3, -2], [-5, -4], [-7], [-10, -8]] paths =  [[0, 1], [0, 1, 2], [0, 1, 2], [0, 2], [0, 2, 4]]`\\n`decks =  [[-1], [-3, -2], [-5, -4], [-7], [-10, -8, -8]] paths =  [[0, 1], [0, 1, 2], [0, 1, 2], [0, 2], [0, 2, 4, 6]]`\\n\\n\\nWe use negative numbers, so each deck is sorted in increasing way instead of decreasing.\\n\\nWhen we see new `num`, then we first find `deck_idx`: number of deck we need to put this `num`. Now, we want to find number of LIS, ending with this `num`: for this we need to look at previous deck and find the place of `num` inside this deck: here we use our **property**, we update our `n_path`.\\n\\nNow, we need to decide where we put this number:\\n1. If our `deck_idx` is equal to `len(decks)`, it means, that we need to create new `deck`: we create new deck with one element, update `ends_decks` and also append `n_paths` to our `paths`.\\n2. In opposite case, we need to add `nums` to the end of corresponding deck, again update `ends_decks`  and update our `pathcs[deck_idx]`: it will consist of two parts: `n_paths`: number of paths, such that previous element is from previous or before decks. Also we have `paths[deck_idx][-1]`, because we keep cumulative sums inside.\\n\\nFinally, we return `paths[-1][-1]`, it is number of LIS with the biggest length.\\n\\n**Complexity** is `O(n log n)`, because for each new `num` we process it in `O(log n)`. Space complexity is `O(n)`. When I run it, i have times, I have times from 60ms to 72ms, where `60`ms beats 100% of python solutions.\\n\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n    \\n        decks, ends_decks, paths = [], [], []\\n        for num in nums:\\n            deck_idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if deck_idx > 0:\\n                l = bisect.bisect(decks[deck_idx-1], -num)\\n                n_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n                \\n            if deck_idx == len(decks):\\n                decks.append([-num])\\n                ends_decks.append(num)\\n                paths.append([0,n_paths])\\n            else:\\n                decks[deck_idx].append(-num)\\n                ends_decks[deck_idx] = num\\n                paths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n              \\n        return paths[-1][-1]\\n```\\n\\n**Shorter version** it can be written in shorter version, if we prefill our `decks`, `decks_ends` and `paths` first. However I do no know if we can do binary search in python by **key**: if we can, we can remove `ends_decks` at all and simplify it even more. Can somebody help me with it?\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n        n = len(nums) + 1\\n    \\n        decks, ends_decks, paths = [[] for _ in range(n)], [float(\"inf\")]*n, [[0] for _ in range(n)]\\n        for num in nums:\\n            idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if idx > 0:\\n                l = bisect.bisect(decks[idx-1], -num)\\n                n_paths = paths[idx-1][-1] - paths[idx-1][l]\\n            \\n            decks[idx].append(-num)\\n            ends_decks[idx] = num\\n            paths[idx].append(n_paths + paths[idx][-1])\\n                \\n        return paths[paths.index([0]) - 1][-1]\\n```\\n\\n\\n**PS**: see also my solution of problem 300: Longest Increasing Subsequence: https://leetcode.com/problems/longest-increasing-subsequence/discuss/667975/Python-3-Lines-dp-with-binary-search-explained\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n    \\n        decks, ends_decks, paths = [], [], []\\n        for num in nums:\\n            deck_idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if deck_idx > 0:\\n                l = bisect.bisect(decks[deck_idx-1], -num)\\n                n_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n                \\n            if deck_idx == len(decks):\\n                decks.append([-num])\\n                ends_decks.append(num)\\n                paths.append([0,n_paths])\\n            else:\\n                decks[deck_idx].append(-num)\\n                ends_decks[deck_idx] = num\\n                paths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n              \\n        return paths[-1][-1]\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n        n = len(nums) + 1\\n    \\n        decks, ends_decks, paths = [[] for _ in range(n)], [float(\"inf\")]*n, [[0] for _ in range(n)]\\n        for num in nums:\\n            idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if idx > 0:\\n                l = bisect.bisect(decks[idx-1], -num)\\n                n_paths = paths[idx-1][-1] - paths[idx-1][l]\\n            \\n            decks[idx].append(-num)\\n            ends_decks[idx] = num\\n            paths[idx].append(n_paths + paths[idx][-1])\\n                \\n        return paths[paths.index([0]) - 1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107318,
                "title": "c-dp-with-explanation-o-n-2",
                "content": "The solution is based on DP. \\n```\\nFor a sequence of numbers,\\ncnt[k] is total number of longest subsequence ending with nums[k];\\nlen[k] is the length of longest subsequence ending with nums[k];\\n```\\nThen we have following equations \\n```\\nlen[k+1] = max(len[k+1], len[i]+1) for all i <= k and nums[i] < nums[k+1];\\ncnt[k+1] = sum(cnt[i]) for all i <= k and nums[i] < nums[k+1] and len[i] = len[k+1]-1;\\n```\\nStarting case and default case: cnt[0] = len[0] = 1;\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxlen = 1, ans = 0;\\n        vector<int> cnt(n, 1), len(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (len[j]+1 > len[i]) {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    else if (len[j]+1 == len[i]) \\n                        cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, len[i]);\\n        }\\n        // find the longest increasing subsequence of the whole sequence\\n       // sum valid counts\\n        for (int i = 0; i < n; i++) \\n            if (len[i] == maxlen) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nFor a sequence of numbers,\\ncnt[k] is total number of longest subsequence ending with nums[k];\\nlen[k] is the length of longest subsequence ending with nums[k];\\n```\n```\\nlen[k+1] = max(len[k+1], len[i]+1) for all i <= k and nums[i] < nums[k+1];\\ncnt[k+1] = sum(cnt[i]) for all i <= k and nums[i] < nums[k+1] and len[i] = len[k+1]-1;\\n```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxlen = 1, ans = 0;\\n        vector<int> cnt(n, 1), len(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (len[j]+1 > len[i]) {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    else if (len[j]+1 == len[i]) \\n                        cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, len[i]);\\n        }\\n        // find the longest increasing subsequence of the whole sequence\\n       // sum valid counts\\n        for (int i = 0; i < n; i++) \\n            if (len[i] == maxlen) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107320,
                "title": "python-dp-with-explanation-beats-88",
                "content": "If you have not solved the [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) problem, you should do so before attempting this question. The approach is very similar and only requires augmentation of the DP array.\\n\\nIn the Longest Increasing Subsequence problem, the DP array simply had to store the longest length. In this variant, each element in the DP array needs to store two things: (1) Length of longest subsequence ending at this index and (2) Number of longest subsequences that end at this index. I use a two element list for this purpose.\\n\\nIn each loop as we build up the DP array, find the longest length for this index and then sum up the numbers at these indices that contribute to this longest length.\\n\\nHere I provide two versions: (1) A slower but easier to understand version and (2) Much faster and optimized version\\n\\n**\\uD83D\\uDCAF Check out https://techinterviewhandbook.org for more tips and tricks to ace your technical interview \\uD83D\\uDCAF**\\n\\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n^2)\\n        # Space: O(n)\\n        dp, longest = [[1, 1] for i in range(len(nums))], 1\\n        for i, num in enumerate(nums):\\n            curr_longest, count = 1, 0\\n            for j in range(i):\\n                if nums[j] < num:\\n                    curr_longest = max(curr_longest, dp[j][0] + 1)\\n            for j in range(i):\\n                if dp[j][0] == curr_longest - 1 and nums[j] < num:\\n                    count += dp[j][1]\\n            dp[i] = [curr_longest, max(count, dp[i][1])]\\n            longest = max(curr_longest, longest)\\n        return sum([item[1] for item in dp if item[0] == longest])\\n```\\n\\nThe counting step can be optimized such that we don\\'t count from the start when we find a longer `max_len`. This improved the speed from 10% to 88%.\\n\\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1, 1] for i in range(len(nums))]\\n        max_for_all = 1\\n        for i, num in enumerate(nums):\\n            max_len, count = 1, 0\\n            for j in range(i):\\n                if nums[j] < num:\\n                    if dp[j][0] + 1 > max_len:\\n                        max_len = dp[j][0] + 1\\n                        count = 0 \\n                    if dp[j][0] == max_len - 1:\\n                        count += dp[j][1]\\n            dp[i] = [max_len, max(count, dp[i][1])]\\n            max_for_all = max(max_len, max_for_all)\\n        return sum([item[1] for item in dp if item[0] == max_for_all])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n^2)\\n        # Space: O(n)\\n        dp, longest = [[1, 1] for i in range(len(nums))], 1\\n        for i, num in enumerate(nums):\\n            curr_longest, count = 1, 0\\n            for j in range(i):\\n                if nums[j] < num:\\n                    curr_longest = max(curr_longest, dp[j][0] + 1)\\n            for j in range(i):\\n                if dp[j][0] == curr_longest - 1 and nums[j] < num:\\n                    count += dp[j][1]\\n            dp[i] = [curr_longest, max(count, dp[i][1])]\\n            longest = max(curr_longest, longest)\\n        return sum([item[1] for item in dp if item[0] == longest])\\n```\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1, 1] for i in range(len(nums))]\\n        max_for_all = 1\\n        for i, num in enumerate(nums):\\n            max_len, count = 1, 0\\n            for j in range(i):\\n                if nums[j] < num:\\n                    if dp[j][0] + 1 > max_len:\\n                        max_len = dp[j][0] + 1\\n                        count = 0 \\n                    if dp[j][0] == max_len - 1:\\n                        count += dp[j][1]\\n            dp[i] = [max_len, max(count, dp[i][1])]\\n            max_for_all = max(max_len, max_for_all)\\n        return sum([item[1] for item in dp if item[0] == max_for_all])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794723,
                "title": "efficient-dp-solution-lis-beats-98-4",
                "content": "# Intuition\\nThe given problem can be efficiently solved using a dynamic programming approach. We maintain two arrays, dp and count, to keep track of the length of the longest increasing subsequence and the count of such subsequences, respectively. The idea is to iterate through the input array, updating these arrays as we go along.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the dp and count arrays with all elements set to 1, as each element is a valid subsequence of length 1.\\n2. For each element at index i in the input array, iterate through all elements before it (index j from 0 to i-1).\\n3. Compare the values of nums[i] and nums[j]:\\n    - If nums[i] is greater than nums[j], we have a potential increasing subsequence.\\n    - Check if dp[j] + 1 (the length of the LIS ending at index j plus the current element) is greater than dp[i] (the current length of the LIS ending at index i). If so, update dp[i] to dp[j] + 1, and set count[i] to count[j] since we have found a new longer subsequence ending at i.\\n    - If dp[j] + 1 is equal to dp[i], it means we have found another subsequence with the same length as the one ending at i. In this case, we add count[j] to the existing count[i], as we have multiple ways to form subsequences with the same length.\\n4. Keep track of the maxLength of the LIS encountered during the process.\\n5. Finally, iterate through the dp array again, and for each index i, if dp[i] equals maxLength, add the corresponding count[i] to the result.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n\\n        int[] dp = new int[n]; \\n        int[] count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n\\n        int maxLength = 1; \\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLength) {\\n                result += count[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) return 0;\\n\\n        vector<int> lengths(n, 1); \\n        vector<int> counts(n, 1); \\n        vector<int> bit(n + 1, 0); \\n\\n        int max_length = 1; \\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] > nums[j]) {\\n                    if (lengths[j] + 1 > lengths[i]) {\\n                        lengths[i] = lengths[j] + 1;\\n                        counts[i] = counts[j];\\n                    } else if (lengths[j] + 1 == lengths[i]) {\\n                        counts[i] += counts[j];\\n                    }\\n                }\\n            }\\n            max_length = max(max_length, lengths[i]);\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (lengths[i] == max_length) {\\n                result += counts[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n <= 1:\\n            return n\\n\\n        lengths = [1] * n\\n        counts = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        max_length = max(lengths)\\n        return sum(count for length, count in zip(lengths, counts) if length == max_length)\\n\\n```\\n```C []\\nint findNumberOfLIS(int* nums, int numsSize) {\\n    if (numsSize == 0) return 0;\\n\\n    int dp[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        dp[i] = 1;\\n    }\\n\\n    int maxLength = 1;\\n    int result = 0;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[i] > nums[j]) {\\n                if (dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        if (dp[i] > maxLength) {\\n            maxLength = dp[i];\\n        }\\n    }\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (dp[i] == maxLength) {\\n            result++;\\n        }\\n    }\\n\\n    return result;\\n}\\n```\\n\\n> If you find my solution helpful, I would greatly appreciate your one upvote.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) return 0;\\n\\n        int[] dp = new int[n]; \\n        int[] count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n\\n        int maxLength = 1; \\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLength) {\\n                result += count[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) return 0;\\n\\n        vector<int> lengths(n, 1); \\n        vector<int> counts(n, 1); \\n        vector<int> bit(n + 1, 0); \\n\\n        int max_length = 1; \\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] > nums[j]) {\\n                    if (lengths[j] + 1 > lengths[i]) {\\n                        lengths[i] = lengths[j] + 1;\\n                        counts[i] = counts[j];\\n                    } else if (lengths[j] + 1 == lengths[i]) {\\n                        counts[i] += counts[j];\\n                    }\\n                }\\n            }\\n            max_length = max(max_length, lengths[i]);\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (lengths[i] == max_length) {\\n                result += counts[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\n```Python3 []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n <= 1:\\n            return n\\n\\n        lengths = [1] * n\\n        counts = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        max_length = max(lengths)\\n        return sum(count for length, count in zip(lengths, counts) if length == max_length)\\n\\n```\n```C []\\nint findNumberOfLIS(int* nums, int numsSize) {\\n    if (numsSize == 0) return 0;\\n\\n    int dp[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        dp[i] = 1;\\n    }\\n\\n    int maxLength = 1;\\n    int result = 0;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (nums[i] > nums[j]) {\\n                if (dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        if (dp[i] > maxLength) {\\n            maxLength = dp[i];\\n        }\\n    }\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (dp[i] == maxLength) {\\n            result++;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643753,
                "title": "python-o-nlogn-solution-w-detailed-explanation-of-how-to-develop-a-binary-search-solution-from-300",
                "content": "Though it is rather easier to get a DP solution with O(n^2), I\\'ve been thinking for days how to develop an answer based on Binary Search solution for leetcode 300: https://leetcode.com/problems/longest-increasing-subsequence/. I\\'ve read several post to help develop the thoughts but some are not very intuitive to understand. After thinking more on my own, I finally got a comprehensive understanding. So I\\'m writing the post to share a Python O(nlogn) solution based on Binary Search with detailed explanation how I develop the thought, and hope it will help people that have the same confusion as me.\\n\\nReferences:\\nhttps://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/107295/9ms-C%2B%2B-Explanation%3A-DP-%2B-Binary-search-%2B-prefix-sums-O(NlogN)-time-O(N)-space\\n\\nTo come up with the solution, we need to answer a few questions.\\n\\n\\n# Quesiton 1: how to record all the possible paths based on the original sub_list array for Leetcode 300?\\n\\n\\nThe first important idea is: \\n**Instead of \"updating\" when we find the idx by binary search, we record every time when trying to update a position.**\\n*(Another way to understand this thought: previously at each position i, the number works as a \"snapshot\", now we want to get a time serie of how the number get updated)*\\n\\nConsider an example:  [1, 3, 2, 5, 4, 7]\\n![image](https://assets.leetcode.com/users/images/7452a6ec-8f7b-4817-a7ca-5b61ebf0768f_1641368843.5299492.png)\\n\\n\\nIt is easy to figure out, we change each position as an array, which records the updated value each time when a new element comes in. \\n**In this pocess, we only care about the last element of each array, which redueces the dimensions of this new array to exactly the same as LIS problem. **\\n\\nFor instance, as for step 4, we know 5 > 2, so it should be inserted in a new array at position 1.\\n\\nSo here, we can define: \\nbuild an array called `sub_list`, where `sub_list[k + 1]` records all the elements that can be a tail of an increasing subsequence with length k.\\nFor instance, in the example above, [3, 2] at position 1 records element = 3 or 2, that can form an increasing subsequence of length 2\\n\\nHowever, based on this example, we will find there is another problem: \\n**an element can be a tail of mutiple increasing subsequence with the same length**. \\n\\nFor this example, [1, 3, 2, 5, 4, 7]\\nWe will actually find the answer is 4:\\n`[1, 3, 5, 7], [1, 3, 4, 7], [1, 2, 5, 7], [1, 2, 4, 7]`\\nAnd this is hard to be directly figured out from the array `sub_list`.\\n\\n\\nHere we come to next question:\\n# Question 2: how to handle this situation of an element can be a tail of multiple lists?\\nTo solve this problem, we add another dimension for each element: a number record how many increasing subsequence is ended by this particular element.\\nThen for this example, we will get:\\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, 1)], \\n     [ (5, 2), (4, 2)], \\n     [ (7, 4) ] \\n] \\n```\\nFor instance, 5 follows with a number 2 since there are actually 2 increasing subsequences ended with 5: `[1, 3, 5], [1, 2, 5]`\\n\\n\\nBased on this design, we get to our 3rd qustion:\\n# Qustion 3: how could we update to get this number?\\n*(As described above, this added number represents the total number of possible increasing subsequence ending with a particular value)*\\n\\nHere we use a thought similar to the **dynamic programing** solution: \\nTo get current status, we can use the status getting from the previous loop. \\nI.E, when updating at position `k` for element `x`, we only need to sum the count of subsequence ending with smaller elements at position` k - 1`, or previous row. \\n\\nOK, based on these steps, we can actually write a solution that with a similar structure to the answer of Leetcode#300 now:\\n\\n```Python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        if not nums or len(nums) == 0:\\n            return 0\\n        \\n        def find_pos(sub, val):\\n            left, right = 0, len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                if sub[mid] >= val: \\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n        \\n    \\n        sub_list = []\\n        \\n        for val in nums:\\n            if len(sub_list) == 0 or val > sub_list[-1][-1][0]:\\n                # should append a new element at the end\\n                cur_count = sum([x[1] for x in sub_list[-1] if val > x[0]]) if len(sub_list) != 0 else 1\\n                sub_list.append([(val, cur_count)])\\n            else:\\n                # get the last number to turn it back to a LIS problem\\n                cur_sub = [array[-1][0] for array in sub_list]\\n                pos = find_pos(cur_sub, val)\\n                # if pos == 0, means it is smallest, no need to look the previous level and set it to be 1\\n                cur_count = sum([x[1] for x in sub_list[pos - 1] if val > x[0]]) if pos > 0 else 1\\n                sub_list[pos].append((val, cur_count))\\n      \\n        return sum([x[1] for x in sub_list[-1]])\\n```\\n\\nNote: unless other posts, here I use the exactly the same Binary Search implementation for 1-d array, to emphasize the connection of this solution to the original method. As it has been pointed out in Qustion 1:\\n> we only care about the last element of each array, which redueces the dimensions of this new array to exactly the same as LIS problem. \\n\\nHowever, this is not the final version, since we will find another problem:\\nthough it is `O(logn)` for find_pos, the process of going to the previous level and seach for `val > x[0]`,  is still an `O(n)` operation, which causes the total complexity is still O(n^2). \\n\\n\\nIt leads to a 4th question:\\n# Question 4: How could we possibly optimze this process, to find the elements smaller than current element? \\n\\nTo answer this question, we need to realize there is an important property of previously defined `sub_list`:\\n\\n**For every ` 0 <= k < len(sub_list)`,  the value of elements in `sub_list[k]` should form a non-increasing array.**\\n\\nStill take this example:\\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, 1)], \\n     [ (5, 2), (4, 2)], \\n     [ (7, 4) ] \\n] \\n```\\nWe can notice that `[1]`, `[3, 2]`, `[5, 4]`, `[7]` are all non-increasing arrays. This property comes from how we update each position, since we target at forming a longer increasing array. And it also is easy to use contradictionay to prove: \\n>if we get an array like [3, 2, 5] at position 1, it is obviously wrong since 5 can form a longer subsequence.\\n\\nSince these arrays are all in order, we can use Binary Search to figure out how many elements are strictly smaller than current value.\\n\\nBefore we can further develop the solution, we\\'ll find here is another problem: we need to get the `sum` of all the elements smaller than current value from the previous status. So here is our 5th question to answer:\\n\\n\\n# Question 5: how to get the sum of all the possible increasing subsequence of the smaller elements than current value? \\n\\nHere we use the concept of **prefix sum**:\\nWe change the number at the second dimension to represent counts of increasing subsequences ending at all elements **equal or greater than current element**.\\nThat is to say, assume we have tuple `(a, x)` at position `k + 1,` where` x = sum( number_of_IS(bi) )` where `bi >= a`, and `bi` can be the tails of these increasing subsequences that has length `k`\\n\\n\\nFor instance, the previous example will change to:\\n\\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, ** 2 **)],  \\n     [ (5, 2), (4, **4**)], \\n     [ (7, 4) ] \\n] \\n```\\n\\nSo if we know on the previous row, we can get an `idx` where `[0, \\u2026 idx - 1]` are all `number >= current_val`, and `[idx, \\u2026. n]` is all `number < current_val`,\\nThen we can get the number of path by:\\n`Sequence_number_greater_or_equal_to(n) - Sequence_number_greater_or_euqal_to(idx - 1)`\\n\\nIf this is not clear enough, we can use another way to explain this process: \\n\\nRemebering that as previous definition, we make the second dimension represents** number of increasing subsequences ending with an element**. \\nNow since we know at each row, the element list shoud be **non-increasing**, so we can make the second dimension updated to represent number of increasing subsequences ending with **great or equal to current element** by building a prefix sum array:\\n\\n```\\nfor i in range(1, len(row)):\\n    prefix_sum[i][1] = prefix_sum[i - 1][1] + row[i][1]\\n```\\n\\nSo, if we want to know `row[idx] + row[idx + 1] + \\u2026 + row[n]`:\\nSince \\n```\\nprefix_sum[i][n] = prefix_sum[i][idx - 1] + row[idx] + row[idx + 1] + ... + row[n]\\n```\\n\\nTherefore, \\n```\\nrow[idx] + row[idx + 1] + ... + row[n] = prefix_sum[i][n] - prefix_sum[i][idx - 1]\\n```\\n\\nCertainly, if `idx = 0`, the value prefix_sum[i][n] should directly be the answer .\\n\\nHere is also an example to help understand this thought of \\u201Cprefix sum\":\\n\\n> Assume we\\'re looking at a previous row like: [(5, n0), (4, n1), (2, n2), (1, n3)] \\nAnd we have a current value as val = 3, \\nBased on previous thought, we want to know the sum of path smaller than 3.\\nWe can use Binary Search to get an idx = 2: when idx < 2 or equally idx <= 1, we have elements >= current_val, which can not form an increasing list; and when idx >= 2, here we get the number we want, so the actual value is n3 - n1. \\n\\nBy far, we got the solution and we can modify our previous solution implemented in Question 3 to optimze the process of searching for smaller numbers to `O(logn)`:\\n```Python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        if not nums or len(nums) == 0:\\n            return 0\\n        \\n        def find_pos(sub, val):\\n            left, right = 0, len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                if sub[mid] >= val: \\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n        \\n        \\n        def find_smaller(sub, val):\\n            left = 0\\n            right = len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                # [x > val | x = val | x < val]\\n                if sub[mid] < val: # find the first point < val\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n                    \\n    \\n        sub_list = []\\n        \\n        for val in nums:\\n            if len(sub_list) == 0 or val > sub_list[-1][-1][0]:\\n                # should append a new element at the end\\n                cur_count = 1\\n                if len(sub_list) > 0:\\n                    last_row = [x[0] for x in sub_list[-1]]\\n                    idx = find_smaller(last_row, val)\\n                    cur_count = sub_list[-1][-1][1] - sub_list[-1][idx - 1][1] if idx > 0 \\\\\\n                                else sub_list[-1][-1][1]\\n                    \\n                # since there is no element in this current row, no need to add previous counts\\n                sub_list.append([(val, cur_count)])\\n            else:\\n                # get the last number to turn it back to a LIS problem\\n                cur_sub = [array[-1][0] for array in sub_list]\\n                pos = find_pos(cur_sub, val)\\n                cur_count = 1\\n                if pos > 0:\\n                    last_row = [x[0] for x in sub_list[pos - 1]]\\n                    idx = find_smaller(last_row, val)\\n                    cur_count = sub_list[pos - 1][-1][1] - sub_list[pos - 1][idx - 1][1] if idx > 0 \\\\\\n                                else sub_list[pos - 1][-1][1]\\n                \\n                # if current row is not empty, add previous value, else set it to be current count\\n                sub_list[pos].append((val, cur_count + sub_list[pos][-1][1] if len(sub_list[pos]) > 0 else cur_count))\\n        \\n        return sub_list[-1][-1][1]\\n```\\n\\nWe can further optimize the for-loop part to avoid duplications:\\n\\n```Python\\nfor val in nums:\\n    if len(sub_list) == 0:\\n        sub_list.append([(val, 1)])\\n    else: \\n        pos = 0\\n        if val > sub_list[-1][-1][0]:\\n            # init a new line \\n            sub_list.append([]) \\n            pos = len(sub_list) - 1\\n        else:\\n            cur_sub = [arr[-1][0] for arr in sub_list]\\n            pos = find_pos(cur_sub, val)\\n            \\n        cur_count = 1\\n        if pos > 0:\\n            last_row = [x[0] for x in sub_list[pos - 1]]\\n            idx = find_smaller(last_row, val)\\n            cur_count = sub_list[pos - 1][-1][1] - sub_list[pos - 1][idx - 1][1] if idx > 0 \\\\\\n                        else sub_list[pos - 1][-1][1]\\n        \\n        # if current row is not empty, add previous value, else set it to be current count\\n        sub_list[pos].append((val, cur_count + sub_list[pos][-1][1] if len(sub_list[pos]) > 0 \\\\\\n                                else cur_count))\\nreturn sub_list[-1][-1][1]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, 1)], \\n     [ (5, 2), (4, 2)], \\n     [ (7, 4) ] \\n] \\n```\n```Python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        if not nums or len(nums) == 0:\\n            return 0\\n        \\n        def find_pos(sub, val):\\n            left, right = 0, len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                if sub[mid] >= val: \\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n        \\n    \\n        sub_list = []\\n        \\n        for val in nums:\\n            if len(sub_list) == 0 or val > sub_list[-1][-1][0]:\\n                # should append a new element at the end\\n                cur_count = sum([x[1] for x in sub_list[-1] if val > x[0]]) if len(sub_list) != 0 else 1\\n                sub_list.append([(val, cur_count)])\\n            else:\\n                # get the last number to turn it back to a LIS problem\\n                cur_sub = [array[-1][0] for array in sub_list]\\n                pos = find_pos(cur_sub, val)\\n                # if pos == 0, means it is smallest, no need to look the previous level and set it to be 1\\n                cur_count = sum([x[1] for x in sub_list[pos - 1] if val > x[0]]) if pos > 0 else 1\\n                sub_list[pos].append((val, cur_count))\\n      \\n        return sum([x[1] for x in sub_list[-1]])\\n```\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, 1)], \\n     [ (5, 2), (4, 2)], \\n     [ (7, 4) ] \\n] \\n```\n```\\n[   \\n     [ (1, 1) ], \\n     [ (3, 1), (2, ** 2 **)],  \\n     [ (5, 2), (4, **4**)], \\n     [ (7, 4) ] \\n] \\n```\n```\\nfor i in range(1, len(row)):\\n    prefix_sum[i][1] = prefix_sum[i - 1][1] + row[i][1]\\n```\n```\\nprefix_sum[i][n] = prefix_sum[i][idx - 1] + row[idx] + row[idx + 1] + ... + row[n]\\n```\n```\\nrow[idx] + row[idx + 1] + ... + row[n] = prefix_sum[i][n] - prefix_sum[i][idx - 1]\\n```\n```Python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        if not nums or len(nums) == 0:\\n            return 0\\n        \\n        def find_pos(sub, val):\\n            left, right = 0, len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                if sub[mid] >= val: \\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n        \\n        \\n        def find_smaller(sub, val):\\n            left = 0\\n            right = len(sub) - 1\\n            while left < right:\\n                mid = (left + right) >> 1\\n                # [x > val | x = val | x < val]\\n                if sub[mid] < val: # find the first point < val\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            return left \\n                    \\n    \\n        sub_list = []\\n        \\n        for val in nums:\\n            if len(sub_list) == 0 or val > sub_list[-1][-1][0]:\\n                # should append a new element at the end\\n                cur_count = 1\\n                if len(sub_list) > 0:\\n                    last_row = [x[0] for x in sub_list[-1]]\\n                    idx = find_smaller(last_row, val)\\n                    cur_count = sub_list[-1][-1][1] - sub_list[-1][idx - 1][1] if idx > 0 \\\\\\n                                else sub_list[-1][-1][1]\\n                    \\n                # since there is no element in this current row, no need to add previous counts\\n                sub_list.append([(val, cur_count)])\\n            else:\\n                # get the last number to turn it back to a LIS problem\\n                cur_sub = [array[-1][0] for array in sub_list]\\n                pos = find_pos(cur_sub, val)\\n                cur_count = 1\\n                if pos > 0:\\n                    last_row = [x[0] for x in sub_list[pos - 1]]\\n                    idx = find_smaller(last_row, val)\\n                    cur_count = sub_list[pos - 1][-1][1] - sub_list[pos - 1][idx - 1][1] if idx > 0 \\\\\\n                                else sub_list[pos - 1][-1][1]\\n                \\n                # if current row is not empty, add previous value, else set it to be current count\\n                sub_list[pos].append((val, cur_count + sub_list[pos][-1][1] if len(sub_list[pos]) > 0 else cur_count))\\n        \\n        return sub_list[-1][-1][1]\\n```\n```Python\\nfor val in nums:\\n    if len(sub_list) == 0:\\n        sub_list.append([(val, 1)])\\n    else: \\n        pos = 0\\n        if val > sub_list[-1][-1][0]:\\n            # init a new line \\n            sub_list.append([]) \\n            pos = len(sub_list) - 1\\n        else:\\n            cur_sub = [arr[-1][0] for arr in sub_list]\\n            pos = find_pos(cur_sub, val)\\n            \\n        cur_count = 1\\n        if pos > 0:\\n            last_row = [x[0] for x in sub_list[pos - 1]]\\n            idx = find_smaller(last_row, val)\\n            cur_count = sub_list[pos - 1][-1][1] - sub_list[pos - 1][idx - 1][1] if idx > 0 \\\\\\n                        else sub_list[pos - 1][-1][1]\\n        \\n        # if current row is not empty, add previous value, else set it to be current count\\n        sub_list[pos].append((val, cur_count + sub_list[pos][-1][1] if len(sub_list[pos]) > 0 \\\\\\n                                else cur_count))\\nreturn sub_list[-1][-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389782,
                "title": "heavily-commented-easy-to-read-faster-than-93",
                "content": "Hi All,\\nI found a most of the javascript solutions posted in discussion board a bit hard to understand so I decided to heavily commment my solution to make it easier to follow why each decision was made. \\nHope this helps!\\n\\n```\\nvar findNumberOfLIS = function(nums) {\\n    // We initialize an array named \"tracker\" to track the longest increasing subsequence ending at each\\n    // index and initialize all positions with 1 as each item in nums can be considered as subsequence in\\n    // itself.\\n    let tracker = new Array(nums.length).fill(1);\\n    \\n    \\n    // While tracking, we will realize that at times there is more than one set of preceding items in nums\\n    // that can make the longest increasing subsequence that end at the index we are currently processing.\\n    // The best way to track this is in a seperate array called frequency. Each element will here is\\n    // initialized to 1. This signifies that initially, there can only be a single longest\\n    // subsequence ending at any index.\\n    let frequency = new Array(nums.length).fill(1);\\n    \\n    // Now let\\'s start processing from left to right, starting with the second element at index 1\\n    // Skipping first element as we cannot find a subsequence longer than 1 that can end at index 0.\\n    for(let i = 0; i < nums.length; i++){\\n        // Now let\\'s compare it with every element before it\\n        for(let j = 0; j < i; j++){\\n\\n            // VERIFY: Quick verification that j can be a part of a strictly increasing subsequence ending\\n            // at i\\n            if(nums[j] < nums[i]){\\n\\n                // CASE 1: Is Connecting i to the subsequence ending at j makes a subsequence larger that\\n                // any other subsequence that has ended at i. This increases the subsequence ending at j\\n                // by just 1 hence the addition.\\n                if(tracker[i] < tracker[j]+1){\\n                    // we update longest subsequence ending at i\\n                    tracker[i] = tracker[j]  + 1;\\n                    \\n                    // The new longest subsequence length is created by any and every path that could have\\n                    // ended at the jth index. Hence we set i\\'s frequency same as j.\\n                    frequency[i] = frequency[j];\\n                } else if(tracker[i] === tracker[j]  + 1){\\n\\n                    // CASE 2: This means this is not the first time we found a j that helps make the\\n                    // longest subsequence ending at i. Since length of subsequence itself didn\\'t change,\\n                    // no updates have to be made to the tracker array.\\n                    \\n                    // But this still needs to be tracked in our frequency array. So we add frequency of\\n                    // all longest subsequences that end at j to our frequency tracker for i.\\n                    frequency[i] += frequency[j];\\n                }\\n            }\\n        }\\n    }\\n    \\n    // FINALLY: \\n    // 1. We find the longest path we ever saw using our tracker array\\n    const longestPath = Math.max(...tracker);\\n    \\n    // 2. For each index/element that had the longest path end at it, we add it\\'s frequency to our \\n    // overall result\\n    let result = 0;\\n    for(let k = 0; k < nums.length; k++){\\n        if(tracker[k] === longestPath) result += frequency[k];\\n    }\\n    \\n    return result;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar findNumberOfLIS = function(nums) {\\n    // We initialize an array named \"tracker\" to track the longest increasing subsequence ending at each\\n    // index and initialize all positions with 1 as each item in nums can be considered as subsequence in\\n    // itself.\\n    let tracker = new Array(nums.length).fill(1);\\n    \\n    \\n    // While tracking, we will realize that at times there is more than one set of preceding items in nums\\n    // that can make the longest increasing subsequence that end at the index we are currently processing.\\n    // The best way to track this is in a seperate array called frequency. Each element will here is\\n    // initialized to 1. This signifies that initially, there can only be a single longest\\n    // subsequence ending at any index.\\n    let frequency = new Array(nums.length).fill(1);\\n    \\n    // Now let\\'s start processing from left to right, starting with the second element at index 1\\n    // Skipping first element as we cannot find a subsequence longer than 1 that can end at index 0.\\n    for(let i = 0; i < nums.length; i++){\\n        // Now let\\'s compare it with every element before it\\n        for(let j = 0; j < i; j++){\\n\\n            // VERIFY: Quick verification that j can be a part of a strictly increasing subsequence ending\\n            // at i\\n            if(nums[j] < nums[i]){\\n\\n                // CASE 1: Is Connecting i to the subsequence ending at j makes a subsequence larger that\\n                // any other subsequence that has ended at i. This increases the subsequence ending at j\\n                // by just 1 hence the addition.\\n                if(tracker[i] < tracker[j]+1){\\n                    // we update longest subsequence ending at i\\n                    tracker[i] = tracker[j]  + 1;\\n                    \\n                    // The new longest subsequence length is created by any and every path that could have\\n                    // ended at the jth index. Hence we set i\\'s frequency same as j.\\n                    frequency[i] = frequency[j];\\n                } else if(tracker[i] === tracker[j]  + 1){\\n\\n                    // CASE 2: This means this is not the first time we found a j that helps make the\\n                    // longest subsequence ending at i. Since length of subsequence itself didn\\'t change,\\n                    // no updates have to be made to the tracker array.\\n                    \\n                    // But this still needs to be tracked in our frequency array. So we add frequency of\\n                    // all longest subsequences that end at j to our frequency tracker for i.\\n                    frequency[i] += frequency[j];\\n                }\\n            }\\n        }\\n    }\\n    \\n    // FINALLY: \\n    // 1. We find the longest path we ever saw using our tracker array\\n    const longestPath = Math.max(...tracker);\\n    \\n    // 2. For each index/element that had the longest path end at it, we add it\\'s frequency to our \\n    // overall result\\n    let result = 0;\\n    for(let k = 0; k < nums.length; k++){\\n        if(tracker[k] === longestPath) result += frequency[k];\\n    }\\n    \\n    return result;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107302,
                "title": "python-dp-solution",
                "content": "```\\ndef findNumberOfLIS(nums):\\n    # dp solution, 2 arrays\\n    # length[i] stores the longest length ending at nums[i]\\n    # count[i] counts the number of paths with length length[i]\\n\\n    if not nums:\\n        return 0\\n\\n    n = len(nums)\\n    length = [1] * n\\n    count  = [1] * n\\n\\n    for i in range(1, n):\\n        for j in range(i):\\n            if nums[i] > nums[j]:\\n                # length[i] = max(length[j]+1, length[i]) \\n                # but we need to compute count also\\n                if length[i] == length[j]:\\n                    length[i] = length[j]+1\\n                    count[i]  = count[j]\\n                elif length[i] == length[j]+1:\\n                    count[i] += count[j]\\n\\n    maxLength = max(length)\\n    return sum([count[i] for i in range(n) if length[i] == maxLength])\\n```",
                "solutionTags": [],
                "code": "```\\ndef findNumberOfLIS(nums):\\n    # dp solution, 2 arrays\\n    # length[i] stores the longest length ending at nums[i]\\n    # count[i] counts the number of paths with length length[i]\\n\\n    if not nums:\\n        return 0\\n\\n    n = len(nums)\\n    length = [1] * n\\n    count  = [1] * n\\n\\n    for i in range(1, n):\\n        for j in range(i):\\n            if nums[i] > nums[j]:\\n                # length[i] = max(length[j]+1, length[i]) \\n                # but we need to compute count also\\n                if length[i] == length[j]:\\n                    length[i] = length[j]+1\\n                    count[i]  = count[j]\\n                elif length[i] == length[j]+1:\\n                    count[i] += count[j]\\n\\n    maxLength = max(length)\\n    return sum([count[i] for i in range(n) if length[i] == maxLength])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3794724,
                "title": "lis-beats-99-with-single-array-easy-to-understand-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDp lis standard problem.But,here Here we are also storing how many longest increasing subsequence is present at particular index at last we are iterating all over the frequency array (fq) and counting the how many inceasing subsequence is of max size .\\n\\nps: You can also use one array of pair instead of two array.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/NlKS8wFiWHE\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n\\n1. Initialize the necessary variables:\\n   - `n`: The size of the input vector `nums`.\\n   - `lisfq`: A vector of pairs, where each pair represents the length of the LIS ending at the index `i` (first element) and the count of such LIS (second element).\\n   - Initialize the first element of `lisfq` at index 0 with 1 as the LIS ending at index 0 with length 1 is just the element itself, and the count is 1.\\n   - Initialize `lo` (longest LIS length found so far) with 1.\\n\\n2. Iterate through the elements of the input vector `nums` starting from index 1.\\n   - For each element at index `i`, initialize `mx` to 0 (maximum LIS length found so far) and `c` to 1 (count of LIS ending at index `i`).\\n   - Compare the current element with all the elements before it (from index 0 to index `i - 1`).\\n   - If an element at index `j` is smaller than the element at index `i`, check if the LIS ending at index `j` has a longer length (`lisfq[j].first > mx`). If it does, update `mx` and `c` accordingly.\\n   - If the LIS ending at index `j` has the same length as the current maximum (`lisfq[j].first == mx`), add its count `lisfq[j].second` to `c`.\\n\\n3. Update `lisfq[i]` with the found maximum length `mx + 1` and the count `c`. This represents the LIS ending at index `i`.\\n\\n4. Update the longest LIS length found so far (`lo`) if the LIS ending at index `i` has a longer length.\\n\\n5. After iterating through all elements, we have `lo`, the length of the longest LIS found in the entire vector.\\n\\n6. Finally, iterate through the `lisfq` vector again and count the number of LIS that have a length equal to `lo`. Accumulate the counts to get the total number of longest increasing subsequences.\\n\\n7. Return the total count, which represents the number of longest increasing subsequences in the given vector.\\n\\nThe approach utilizes dynamic programming to efficiently calculate the length and count of LIS for each index in the vector `nums`. By doing so, the algorithm avoids redundant calculations and provides an optimal solution to the problem.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code 1(Single Array)\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n          int n=nums.size();\\n          vector<pair<int,int>>lisfq(n);\\n        lisfq[0].first=1;\\n        lisfq[0].second=1;\\n        int lo=1;\\n        for(int i=1;i<nums.size();i++){\\n            int mx=0;\\n            int c=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lisfq[j].first>mx){\\n                        mx=lisfq[j].first;\\n                        c=lisfq[j].second;\\n                    }\\n                    else if(lisfq[j].first==mx){\\n                      c=c+lisfq[j].second;\\n                    }\\n                }\\n            }\\n           lisfq[i].second=c;\\n            lisfq[i].first=mx+1;\\n            if(lo<lisfq[i].first){\\n               lo=lisfq[i].first; \\n            }\\n        }\\n        int count=0;\\n     \\n        for(int i=0;i<nums.size();i++){\\n            if(lisfq[i].first==lo){\\n                count+=lisfq[i].second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The solution uses two arrays, `lis` and `fq`, to keep track of the length of the longest increasing subsequence ending at each index and the count of such subsequences respectively.\\n\\n2. Initialize the `lis` array with all elements set to 0, and set the first element of `lis` and `fq` to 1 since the LIS for a single element is always 1, and there is one such subsequence.\\n\\n3. Iterate through the `nums` vector from index 1 to the end:\\n\\n   a. For each element at index `i`, find the maximum length of the LIS ending at index `i` and store it in `lis[i]`. Also, keep track of the count of such LIS in the `fq[i]` array.\\n\\n   b. To find `lis[i]` and `fq[i]`, loop through the elements before index `i` (j varies from 0 to `i-1`):\\n\\n      - If the element at index `j` is less than the element at index `i`, it means we can form a longer LIS ending at index `i` by appending the element at index `i` to the LIS ending at index `j`.\\n      \\n      - Update `lis[i]` and `fq[i]` based on the maximum LIS found so far and the count of LIS ending at index `j`.\\n\\n      - If the LIS ending at index `j` has the same length as the current maximum (`lis[j] == mx`), update the count of LIS ending at index `i` by adding the count of LIS ending at index `j`.\\n\\n4. After the iteration, the variable `lo` will store the length of the longest increasing subsequence present in the given vector `nums`.\\n\\n5. Iterate through the `lis` array again to find the count of LIS with length `lo`, and accumulate the count in the `count` variable.\\n\\n6. Return the value of `count` as the final result, representing the number of Longest Increasing Subsequences in the input vector.\\n\\nOverall, the solution uses dynamic programming to efficiently compute the count of Longest Increasing Subsequences. It finds the length of the LIS and its count for each element in the `nums` vector, and then calculates the total count of the longest increasing subsequences with the maximum length. \\n\\n# Code 2\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n          int n=nums.size();\\n          vector<int>lis(n,0),fq(n,0);\\n        lis[0]=1;\\n        fq[0]=1;\\n        int lo=1;\\n        for(int i=1;i<nums.size();i++){\\n            int mx=0;\\n            int c=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lis[j]>mx){\\n                        mx=lis[j];\\n                        c=fq[j];\\n                    }\\n                    else if(lis[j]==mx){\\n                      c=c+fq[j];\\n                    }\\n                }\\n            }\\n           fq[i]=c;\\n            lis[i]=mx+1;\\n            if(lo<lis[i]){\\n               lo=lis[i]; \\n            }\\n        }\\n        int count=0;\\n     \\n        for(int i=0;i<nums.size();i++){\\n            if(lis[i]==lo){\\n                count+=fq[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] lis = new int[n];\\n        int[] fq = new int[n];\\n        lis[0] = 1;\\n        fq[0] = 1;\\n        int lo = 1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int mx = 0;\\n            int c = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    if (lis[j] > mx) {\\n                        mx = lis[j];\\n                        c = fq[j];\\n                    } else if (lis[j] == mx) {\\n                        c += fq[j];\\n                    }\\n                }\\n            }\\n            fq[i] = c;\\n            lis[i] = mx + 1;\\n            if (lo < lis[i]) {\\n                lo = lis[i];\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (lis[i] == lo) {\\n                count += fq[i];\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        n = len(nums)\\n        lis = [0] * n\\n        fq = [0] * n\\n        lis[0] = 1\\n        fq[0] = 1\\n        lo = 1\\n\\n        for i in range(1, len(nums)):\\n            mx = 0\\n            c = 1\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if lis[j] > mx:\\n                        mx = lis[j]\\n                        c = fq[j]\\n                    elif lis[j] == mx:\\n                        c += fq[j]\\n            fq[i] = c\\n            lis[i] = mx + 1\\n            if lo < lis[i]:\\n                lo = lis[i]\\n\\n        count = 0\\n        for i in range(len(nums)):\\n            if lis[i] == lo:\\n                count += fq[i]\\n\\n        return count\\n\\n```\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n          int n=nums.size();\\n          vector<pair<int,int>>lisfq(n);\\n        lisfq[0].first=1;\\n        lisfq[0].second=1;\\n        int lo=1;\\n        for(int i=1;i<nums.size();i++){\\n            int mx=0;\\n            int c=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lisfq[j].first>mx){\\n                        mx=lisfq[j].first;\\n                        c=lisfq[j].second;\\n                    }\\n                    else if(lisfq[j].first==mx){\\n                      c=c+lisfq[j].second;\\n                    }\\n                }\\n            }\\n           lisfq[i].second=c;\\n            lisfq[i].first=mx+1;\\n            if(lo<lisfq[i].first){\\n               lo=lisfq[i].first; \\n            }\\n        }\\n        int count=0;\\n     \\n        for(int i=0;i<nums.size();i++){\\n            if(lisfq[i].first==lo){\\n                count+=lisfq[i].second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n          int n=nums.size();\\n          vector<int>lis(n,0),fq(n,0);\\n        lis[0]=1;\\n        fq[0]=1;\\n        int lo=1;\\n        for(int i=1;i<nums.size();i++){\\n            int mx=0;\\n            int c=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lis[j]>mx){\\n                        mx=lis[j];\\n                        c=fq[j];\\n                    }\\n                    else if(lis[j]==mx){\\n                      c=c+fq[j];\\n                    }\\n                }\\n            }\\n           fq[i]=c;\\n            lis[i]=mx+1;\\n            if(lo<lis[i]){\\n               lo=lis[i]; \\n            }\\n        }\\n        int count=0;\\n     \\n        for(int i=0;i<nums.size();i++){\\n            if(lis[i]==lo){\\n                count+=fq[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] lis = new int[n];\\n        int[] fq = new int[n];\\n        lis[0] = 1;\\n        fq[0] = 1;\\n        int lo = 1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int mx = 0;\\n            int c = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    if (lis[j] > mx) {\\n                        mx = lis[j];\\n                        c = fq[j];\\n                    } else if (lis[j] == mx) {\\n                        c += fq[j];\\n                    }\\n                }\\n            }\\n            fq[i] = c;\\n            lis[i] = mx + 1;\\n            if (lo < lis[i]) {\\n                lo = lis[i];\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (lis[i] == lo) {\\n                count += fq[i];\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        n = len(nums)\\n        lis = [0] * n\\n        fq = [0] * n\\n        lis[0] = 1\\n        fq[0] = 1\\n        lo = 1\\n\\n        for i in range(1, len(nums)):\\n            mx = 0\\n            c = 1\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if lis[j] > mx:\\n                        mx = lis[j]\\n                        c = fq[j]\\n                    elif lis[j] == mx:\\n                        c += fq[j]\\n            fq[i] = c\\n            lis[i] = mx + 1\\n            if lo < lis[i]:\\n                lo = lis[i]\\n\\n        count = 0\\n        for i in range(len(nums)):\\n            if lis[i] == lo:\\n                count += fq[i]\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500880,
                "title": "java-dp-with-explanation",
                "content": "````\\n\\tpublic int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, max = 0; \\n        \\n        // the longest increasing subsequence that ends at i\\n        int[] len = new int[n];\\n        \\n        // the number of the longest increasing subsequence that ends at i\\n        int[] cnt = new int[n];        \\n        \\n        for (int i = 0; i < n; i++) {             \\n            for (int j = i-1; j >= 0; j--) {\\n                \\n                // if combining with i makes an increasing subsequence\\n                if (nums[j] < nums[i]) {\\n                    \\n                    // if combining with i makes a longer increasing subsequence\\n                    if (len[j]+1 > len[i]) {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    // if combining with i makes another longest increasing subsequence\\n                    else if (len[j]+1 == len[i]) {\\n                        cnt[i] += cnt[j];    \\n                    }                                        \\n                }\\n            }\\n            \\n            // if the current nums[i] is the minimum value so far\\n            if (len[i] == 0) {\\n                len[i] = 1;\\n                cnt[i] = 1;\\n            }\\n            \\n            // update the longest length\\n            max = Math.max(max, len[i]);            \\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (len[i] == max) {\\n                res += cnt[i];\\n            }\\n        }\\n        return res;                \\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, max = 0; \\n        \\n        // the longest increasing subsequence that ends at i\\n        int[] len = new int[n];\\n        \\n        // the number of the longest increasing subsequence that ends at i\\n        int[] cnt = new int[n];        \\n        \\n        for (int i = 0; i < n; i++) {             \\n            for (int j = i-1; j >= 0; j--) {\\n                \\n                // if combining with i makes an increasing subsequence\\n                if (nums[j] < nums[i]) {\\n                    \\n                    // if combining with i makes a longer increasing subsequence\\n                    if (len[j]+1 > len[i]) {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    // if combining with i makes another longest increasing subsequence\\n                    else if (len[j]+1 == len[i]) {\\n                        cnt[i] += cnt[j];    \\n                    }                                        \\n                }\\n            }\\n            \\n            // if the current nums[i] is the minimum value so far\\n            if (len[i] == 0) {\\n                len[i] = 1;\\n                cnt[i] = 1;\\n            }\\n            \\n            // update the longest length\\n            max = Math.max(max, len[i]);            \\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (len[i] == max) {\\n                res += cnt[i];\\n            }\\n        }\\n        return res;                \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199093,
                "title": "short-python-50ms-beats-100-with-binary-search",
                "content": "the idea is basicly the same with LIS prolem, create one extra hashtable, dp[k][x]  will help us store the number of LIS  (which has a length of k) ends with number x. So each time after we found the index to replace the current number x in table by binary search just increase the number of lcs which ends with current number and has a length of index + 1 equal to sum(dp[index-1][j]  for j in dp[index-1] if j < x).\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        dp = collections.defaultdict(collections.Counter)\\n        dp[-1][-1e9] = 1\\n        table = []\\n        for i in nums:\\n            index = bisect.bisect_left(table, i)\\n            if index == len(table):\\n                table.append(i)\\n            else:\\n                table[index] = i \\n            dp[index][i] += sum(dp[index-1][j] for j in dp[index-1] if j < i)\\n        return sum(dp[max(0, len(table)-1)].values()) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        dp = collections.defaultdict(collections.Counter)\\n        dp[-1][-1e9] = 1\\n        table = []\\n        for i in nums:\\n            index = bisect.bisect_left(table, i)\\n            if index == len(table):\\n                table.append(i)\\n            else:\\n                table[index] = i \\n            dp[index][i] += sum(dp[index-1][j] for j in dp[index-1] if j < i)\\n        return sum(dp[max(0, len(table)-1)].values()) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341428,
                "title": "c-easy-simple-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<pair<int,int>>dp; // dp[i]={a,b} represents that if we take ith element of nums as the last element in a increasing sequence then a is the length of the biggest sequence and there can be b such sequence of length a and last element as nums[i]\\n        dp.push_back({1,1});     //base case\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int len=0;\\n            int count=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])  // to make sure that sequence is increasing\\n                {                                         //this part can be written in more readable way .this is basically to find the maximum length subsequence and find how many such sequences are possible\\n                    if(len==dp[j].first)   //if max length we found till now is equal to current length\\n                    {\\n                        count+=dp[j].second;// we increment count( no. of combinations)\\n                    }\\n                    else if(dp[j].first>len) //if greater len is found\\n                    {\\n                        count=dp[j].second; \\n                        len=dp[j].first;         //then we set count to this seq count and len(maximum len) to its length \\n                    }\\n                }\\n            }\\n            if(count==0)//  in case we dont find any smaller element before it \\n            {\\n                dp.push_back({len+1,1});\\n            }\\n            else \\n                dp.push_back({len+1,count});\\n        }\\n        int len=0;\\n        int count=0;\\n        for(int i=0;i<dp.size();i++)// answer would be number of maximum length sequences    \\n        {\\n            if(len<dp[i].first)\\n            {\\n                len=dp[i].first;\\n                count=dp[i].second;\\n            }\\n            else if(len==dp[i].first)\\n            {\\n                count+=dp[i].second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nAll explanation is done in comments in the code itself",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<pair<int,int>>dp; // dp[i]={a,b} represents that if we take ith element of nums as the last element in a increasing sequence then a is the length of the biggest sequence and there can be b such sequence of length a and last element as nums[i]\\n        dp.push_back({1,1});     //base case\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int len=0;\\n            int count=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])  // to make sure that sequence is increasing\\n                {                                         //this part can be written in more readable way .this is basically to find the maximum length subsequence and find how many such sequences are possible\\n                    if(len==dp[j].first)   //if max length we found till now is equal to current length\\n                    {\\n                        count+=dp[j].second;// we increment count( no. of combinations)\\n                    }\\n                    else if(dp[j].first>len) //if greater len is found\\n                    {\\n                        count=dp[j].second; \\n                        len=dp[j].first;         //then we set count to this seq count and len(maximum len) to its length \\n                    }\\n                }\\n            }\\n            if(count==0)//  in case we dont find any smaller element before it \\n            {\\n                dp.push_back({len+1,1});\\n            }\\n            else \\n                dp.push_back({len+1,count});\\n        }\\n        int len=0;\\n        int count=0;\\n        for(int i=0;i<dp.size();i++)// answer would be number of maximum length sequences    \\n        {\\n            if(len<dp[i].first)\\n            {\\n                len=dp[i].first;\\n                count=dp[i].second;\\n            }\\n            else if(len==dp[i].first)\\n            {\\n                count+=dp[i].second;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697315,
                "title": "java-simple-dp-solution-with-explanataion",
                "content": "A tricky problem :)\\n\\nIn LIS problem, we maintain the length of LIS at any index \\'i\\' by comparing the elements at index \\'i\\' to all the elements occuring before it(index \\'0\\' to index \\'i-1\\'). We\\'ll use the same approach for this problem too, except now we will try to maintain a count of subsequences ending with element nums[i].\\n\\nWhile you\\'re iterating over all the elements from \\'0\\' to \\'i-1\\',\\n\\nFirst check whether the addition of the current element will form a LIS or not.\\n*(This statements denotes to check condition of nums[i] > nums[j])*\\n\\nIf a LIS is forming with the inclusion of element nums[i], then only a simple problem remains - **Whether a subsequece of an equal length is already present or not.**\\n\\nTo resolve this problem, check whether you\\'ve already acheived a LIS of that length or not by simply comparing with the count[i]. \\n\\n1. If yes, the count all the subsequences that have been formed at index \\'j\\' and add them to the subsequences formed without subsequences ending at nums[j].\\n*(This statement denotes - length[j] + 1 == length[i])*\\n\\n2. If not, then count all the subsequences formed with the subsequences ending at nums[j]\\n*(This statement denotes - length[j] + 1 > length[i])*\\n\\nOnce you have this much data, simply find the length of longest LIS and then find all the subsequences of that length and adding thier count.\\n\\nA rough explanation can be found at this video - https://www.youtube.com/watch?v=2m0NxgW2_pc\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int N = nums.length;\\n\\n        int[] length = new int[N];\\n        int[] count = new int[N];\\n        \\n        Arrays.fill(length,1);//each number is a subsequence\\n        Arrays.fill(count,1);//since each number is a subsequence, the LIS for a single element array is 1\\n\\n        for(int i = 1 ; i < nums.length; ++i){\\n            for(int j = 0; j < i; ++j){\\n                if(nums[i] > nums[j]){\\n                    if(1 + length[j] > length[i]){\\n                        length[i] = 1 + length[j];\\n                        count[i] = count[j];\\n                    }else if(1 + length[j] == length[i]){\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i: length){\\n            max = Math.max(i,max);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < N; ++i){\\n            if(length[i] == max){\\n                ans += count[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int N = nums.length;\\n\\n        int[] length = new int[N];\\n        int[] count = new int[N];\\n        \\n        Arrays.fill(length,1);//each number is a subsequence\\n        Arrays.fill(count,1);//since each number is a subsequence, the LIS for a single element array is 1\\n\\n        for(int i = 1 ; i < nums.length; ++i){\\n            for(int j = 0; j < i; ++j){\\n                if(nums[i] > nums[j]){\\n                    if(1 + length[j] > length[i]){\\n                        length[i] = 1 + length[j];\\n                        count[i] = count[j];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3795225,
                "title": "simple-c-memoization-recursion-code-lis-variant-commented-dp",
                "content": "**Simple C++ Memoization+Recursion**\\n\\nUpvote if you like my Solution... ;)\\n```\\nclass Solution\\n{\\n    public:\\n\\n pair<int, int> f(vector<int>& nums, int i, int prev,vector<vector<pair<int, int>>>& dp) {\\n    if (i >= nums.size())\\n        return {0, 1}; // The length of LIS is 0, and there is one such LIS (an empty LIS).\\n\\n    if (dp[prev + 1][i].first != -1)\\n        return dp[prev + 1][i];\\n     \\n//    in this qn. we are storing in \\'a\\' is by taking that value and storing the length of the subsequence in a.first\\n     // and storing the frequency of that suseq. in a.second\\n     \\n//   and \\'b\\' is storing the then length of subseq. in b.first and freq. of that subseq. in b.second by not taking that value (means by skipping) ... \\n\\n    std::pair<int, int> a = {0, 0}, b = {0, 0};\\n\\n    if (prev == -1 || nums[i] > nums[prev]) {\\n        a = f(nums, i + 1, i, dp);\\n        a.first++;\\n    }\\n\\n    b = f(nums, i + 1, prev, dp);\\n     \\n     \\n//   in this condn. if my length of longest subseq. by taking ele. and not taking that ele. are equal then we just add up the freq.   \\n    if (a.first == b.first) {\\n        dp[prev + 1][i] = {a.first, a.second + b.second};\\n    }\\n//   if a has longest subseq. lenght then we take a   \\n     else if (a.first > b.first) {\\n        dp[prev + 1][i] = a;\\n    } else {\\n        dp[prev + 1][i] = b;\\n    }\\n\\n    return dp[prev + 1][i];\\n}\\n\\nint findNumberOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n\\n    vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(n, {-1, -1}));\\n\\n    return f(nums, 0, -1, dp).second;\\n}\\n\\n   \\n    \\n    \\n\\n\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3155f22d-f957-49bb-9d23-ff276e1e3a08_1689926729.3244627.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n\\n pair<int, int> f(vector<int>& nums, int i, int prev,vector<vector<pair<int, int>>>& dp) {\\n    if (i >= nums.size())\\n        return {0, 1}; // The length of LIS is 0, and there is one such LIS (an empty LIS).\\n\\n    if (dp[prev + 1][i].first != -1)\\n        return dp[prev + 1][i];\\n     \\n//    in this qn. we are storing in \\'a\\' is by taking that value and storing the length of the subsequence in a.first\\n     // and storing the frequency of that suseq. in a.second\\n     \\n//   and \\'b\\' is storing the then length of subseq. in b.first and freq. of that subseq. in b.second by not taking that value (means by skipping) ... \\n\\n    std::pair<int, int> a = {0, 0}, b = {0, 0};\\n\\n    if (prev == -1 || nums[i] > nums[prev]) {\\n        a = f(nums, i + 1, i, dp);\\n        a.first++;\\n    }\\n\\n    b = f(nums, i + 1, prev, dp);\\n     \\n     \\n//   in this condn. if my length of longest subseq. by taking ele. and not taking that ele. are equal then we just add up the freq.   \\n    if (a.first == b.first) {\\n        dp[prev + 1][i] = {a.first, a.second + b.second};\\n    }\\n//   if a has longest subseq. lenght then we take a   \\n     else if (a.first > b.first) {\\n        dp[prev + 1][i] = a;\\n    } else {\\n        dp[prev + 1][i] = b;\\n    }\\n\\n    return dp[prev + 1][i];\\n}\\n\\nint findNumberOfLIS(vector<int>& nums) {\\n    int n = nums.size();\\n\\n    vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(n, {-1, -1}));\\n\\n    return f(nums, 0, -1, dp).second;\\n}\\n\\n   \\n    \\n    \\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639132,
                "title": "c-dp-lis-variant-using-pair-of-count-and-length",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n         /* count and length */\\n        vector<pair<int, int>>LIS(n, {1, 1}); \\n        int maxlen = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (LIS[i].second == 1 + LIS[j].second) {\\n                        LIS[i].first += LIS[j].first;\\n                    } else if (LIS[i].second < 1 + LIS[j].second) {\\n                        LIS[i].first = LIS[j].first;\\n                        LIS[i].second = 1 + LIS[j].second;\\n                    }\\n                }\\n            }\\n            maxlen = max(maxlen, LIS[i].second);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (LIS[i].second == maxlen)\\n                ans += LIS[i].first;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n         /* count and length */\\n        vector<pair<int, int>>LIS(n, {1, 1}); \\n        int maxlen = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (LIS[i].second == 1 + LIS[j].second) {\\n                        LIS[i].first += LIS[j].first;\\n                    } else if (LIS[i].second < 1 + LIS[j].second) {\\n                        LIS[i].first = LIS[j].first;\\n                        LIS[i].second = 1 + LIS[j].second;\\n                    }\\n                }\\n            }\\n            maxlen = max(maxlen, LIS[i].second);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (LIS[i].second == maxlen)\\n                ans += LIS[i].first;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228019,
                "title": "c-sorting-and-segment-tree-solution-with-explanation",
                "content": "```\\n/*Preparation:\\nfor example, nums={1, 3, 5, 4, 7}\\nFor every index i of nums, we will consider the longest increasing subsequence(LIS) up to nums[i].\\nWe will capture (1) number of these LISs up to nums[i], and (2) there length. Let \\n    acc[i] = largest accumulated length of an increasing sequence up to nums[i]\\n    ways[i] = number of ways getting a LIS up to nums[i]\\n\\nIn the above case, \\n    {1(acc=1, ways=1), 3(acc=2, ways=1), 5(acc=3, ways=1), 4(acc=3, ways=1), 7(acc=4, ways=2)}\\nFinding number of LIS in this problem would mean finding the maximal \"acc\", \\nand then return its total \"ways\" as answer\\n*/\\n\\n/*Using segment tree to solve for acc\\'s and ways\\'s\\ne.g. nums={1, 3, 5, 2 ,4, 7}\\nsort nums in ascending order => v={1, 2, 3, 4, 5, 7}\\nthe new index of nums[i] is given by indexMap={0, 2, 4, 1, 3, 5}\\n\\ncreate a segment tree (sgTree) of vector v.\\nA leaf node of sgTree captures the pair (acc, ways) of the number v[j].\\nAn interior node tree[x] has two children, tree[2*x] and tree[2*x+1].\\n    if the acc\\'s of tree[2*x] and tree[2*x+1] differ from the other, \\n    tree[x]= (larger acc, the corresponding ways) between tree[2*x] & tree[2*x+1],\\n    since only the longest LIS\\'s concern us.\\n    \\n    if (tree[2*x].first==tree[2*x+1]), we get to tree[x]=(acc[2*x], ways[2*x]+ways[2*x+1])\\n    since number of ways would add up in this case\\n    \\n(i=0) sgTree is of nodes written in (acc/ways) as in the following diagram.\\nFrom left to right, each leaf node represents an entry v[i] of vector v.\\n\\n                  (0/0)\\n               /         \\\\\\n            (0/0)        (0/0)\\n             /  \\\\         /  \\\\\\n         (0/0)  (0/0)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (0/0)   (0/0)  (0/0)  (0/0)\\n\\nx=nums[0]=1=v[0] => acc/ways=1/1. We update the first leaf node (j=0):\\n\\n                  (1/1)\\n               /         \\\\\\n            (1/1)        (0/0)\\n             /  \\\\         /  \\\\\\n         (1/1)  (0/0)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (0/0)\\n\\n--------------------------------------------------------------------------------\\n(i=1) x=nums[1]=3=v[2]\\nTo find acc/ways of nums[1], we consider all visited previous leaf nodes of value<x.\\nSo, acc = maximum acc[j] of these leaf nodes,\\nways = sum of ways[j]\\'s of leaf nodes having the maximal acc[j] (as above).\\nIn practice, we trace from the root of sgTree following these principles:\\n\\n(1) when tree[x] represents the range [left, right] of v,\\nif v[right]<x, then every leaf node in [left, right] is of value<x\\n=> take tree[x]=(acc[x], ways[x]) into consideration directly\\n\\n(2) the children of tree[x] are tree[2*x] and tree[2*x+1], \\nrepresenting the ranges [left,mid] and [mid+1,right] respectively.\\nIf (x<=v[mid]), we pass to tree[2*x] directly\\nif (x>v[mid]), every leaf node under tree[2*x] is of value<x\\n    so we have to look at tree[2*x]=(acc[2*x], ways[2*x])\\n    and then compare it with what we get from query at tree[2*x+1].\\n\\nin this case, x=3 means that we look at ...\\n    the range [0,1]: tree[x] = (1, 1)\\n=> acc=1+1, ways=1 (i.e. {1,3})=> update the 3rd leaf node (j=2) by 2/1:\\n\\n                  (2/1)\\n               /         \\\\\\n            (2/1)        (0/0)\\n             /  \\\\         /  \\\\\\n         (1/1)  (2/1)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (0/0)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n(i=2) x=5=nums[2]=v[4]\\nquery: v[2]=3<x => range [0,2]: tree[x]=(2, 1)\\n       v[3]=4<x => range [3]: tree[x]=(0, 0) \\n=> acc=3, ways=1, i.e. {1,3,5}\\nupdate:\\n                  (3/1)\\n               /         \\\\\\n            (2/1)        (3/1)\\n             /  \\\\         /  \\\\\\n         (1/1)  (2/1)  (3/1)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (3/1)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n(i=3) x=2=nums[3]=v[1]\\nquery: v[0]=1<x => range [0]: tree[x]=(1,1)\\n=> acc=2, ways=1, i.e. {1,2}\\nupdate:\\n                  (3/1)\\n               /         \\\\\\n            (2/2)        (3/1)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/1)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (0/0)  (3/1)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n\\n(i=4) x=4=nums[4]=v[3]\\nquery: v[2]=3<4 => range [0,2]: tree[x]=(2, 2)\\n=> acc=3, ways=2, i.e. {1,2,4} and {1,3,4}\\nupdate:\\n                  (3/3)\\n               /         \\\\\\n            (2/2)        (3/3)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/3)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (3/2)  (3/1)\\n\\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n\\n(i=5) x=7=nums[5]=v[5]\\nquery: v[2]=3<7 => range [0,2]: tree[x]=(2,2)\\nquery: v[4]=5<7 => range [3,4]: tree[x]=(3,3)\\n=> acc=4, ways=3, i.e. {1,3,4,7}, {1,2,4,7}, {1,3,5,7}\\nupdate: \\n                  (4/3)\\n               /         \\\\\\n            (2/2)        (4/3)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/3)  (4/3)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (3/2)  (3/1)\\n--------------------------------------------------------------------------------\\n\\nreturn the information of tree[1] as result\\n*/\\n\\nstruct segmentTree{\\n    std::vector<std::pair<int,int>> tree;\\n    //tree[x] = {acc[x], ways[x]}\\n    std::vector<int> u;\\n    int N;\\n    segmentTree(std::vector<int>& v){\\n        N = v.size();\\n        tree.resize(4*N, std::pair<int,int>(0,0));\\n        for (int i=0; i<N; i++)\\n            u.push_back(v[i]);\\n        return;\\n    }\\n    \\n    void update(int x, int left, int right, int index, int acc, int ways){\\n        if (left==right){\\n            tree[x].first = acc;\\n            tree[x].second = ways;\\n            return;\\n        }\\n        int mid = (left+right)/2;\\n        if (index<=mid){\\n            update(2*x, left, mid, index, acc, ways);\\n        }else{\\n            update(2*x+1, mid+1, right, index, acc, ways);\\n        }\\n        if (tree[2*x].first>tree[2*x+1].first){\\n            tree[x] = tree[2*x];\\n        }else if (tree[2*x+1].first>tree[2*x].first){\\n            tree[x] = tree[2*x+1];\\n        }else{\\n            tree[x].first = tree[2*x].first;\\n            tree[x].second = tree[2*x].second + tree[2*x+1].second;\\n        }\\n        return;\\n    }\\n    \\n    std::pair<int,int> query(int x, int left, int right, int value){\\n        if (u[right]<value){\\n            return tree[x];\\n        }\\n        if (value<=u[left]){\\n            return std::pair<int,int>(0,0);\\n        }\\n        \\n        int mid = (left+right)/2;\\n        std::pair<int, int> temp;\\n        std::pair<int, int> result;\\n        \\n        if (value<=u[mid]){\\n            result = query(2*x, left, mid, value);\\n            \\n        }else{\\n            temp = query(2*x+1, mid+1, right, value);\\n            if (temp.first>tree[2*x].first){\\n                result.first = temp.first;\\n                result.second = temp.second;\\n                \\n            }else if (tree[2*x].first>temp.first){\\n                result.first = tree[2*x].first;\\n                result.second = tree[2*x].second;\\n            \\n            }else{\\n                result.first = tree[2*x].first;\\n                result.second = tree[2*x].second + temp.second;\\n            }\\n        }        \\n        return result;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        std::vector<std::pair<int,int>> numsPair;\\n        std::vector<int> indexMap(n, 0);\\n        std::vector<int> v(n, 0);\\n        for (int i=0; i<n; i++){\\n            numsPair.push_back(std::make_pair(nums[i], i));\\n        }\\n        std::sort(numsPair.begin(), numsPair.end());\\n        for (int j=0; j<n; j++){\\n            v[j] = numsPair[j].first;\\n            indexMap[numsPair[j].second] = j;\\n        }\\n        \\n        segmentTree sgTree = segmentTree(v);\\n        std::pair<int, int> myPair;\\n        int acc, ways;\\n        // i=0\\n        sgTree.update(1, 0, n-1, indexMap[0], 1, 1);\\n        \\n        for (int i=1; i<n; i++){\\n            myPair = sgTree.query(1, 0, n-1, nums[i]);\\n            acc = myPair.first+1;\\n            ways = std::max(1, myPair.second);\\n            //std::cout<<\"acc=\"<<acc<<\", ways=\"<<ways<<\"\\\\n\";\\n            sgTree.update(1, 0, n-1, indexMap[i], acc, ways);\\n        }\\n        \\n        //std::cout<<\"(\"<<sgTree.tree[1].first<<\", \"<<sgTree.tree[1].second<<\")\\\\n\";\\n        return sgTree.tree[1].second;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Sorting"
                ],
                "code": "```\\n/*Preparation:\\nfor example, nums={1, 3, 5, 4, 7}\\nFor every index i of nums, we will consider the longest increasing subsequence(LIS) up to nums[i].\\nWe will capture (1) number of these LISs up to nums[i], and (2) there length. Let \\n    acc[i] = largest accumulated length of an increasing sequence up to nums[i]\\n    ways[i] = number of ways getting a LIS up to nums[i]\\n\\nIn the above case, \\n    {1(acc=1, ways=1), 3(acc=2, ways=1), 5(acc=3, ways=1), 4(acc=3, ways=1), 7(acc=4, ways=2)}\\nFinding number of LIS in this problem would mean finding the maximal \"acc\", \\nand then return its total \"ways\" as answer\\n*/\\n\\n/*Using segment tree to solve for acc\\'s and ways\\'s\\ne.g. nums={1, 3, 5, 2 ,4, 7}\\nsort nums in ascending order => v={1, 2, 3, 4, 5, 7}\\nthe new index of nums[i] is given by indexMap={0, 2, 4, 1, 3, 5}\\n\\ncreate a segment tree (sgTree) of vector v.\\nA leaf node of sgTree captures the pair (acc, ways) of the number v[j].\\nAn interior node tree[x] has two children, tree[2*x] and tree[2*x+1].\\n    if the acc\\'s of tree[2*x] and tree[2*x+1] differ from the other, \\n    tree[x]= (larger acc, the corresponding ways) between tree[2*x] & tree[2*x+1],\\n    since only the longest LIS\\'s concern us.\\n    \\n    if (tree[2*x].first==tree[2*x+1]), we get to tree[x]=(acc[2*x], ways[2*x]+ways[2*x+1])\\n    since number of ways would add up in this case\\n    \\n(i=0) sgTree is of nodes written in (acc/ways) as in the following diagram.\\nFrom left to right, each leaf node represents an entry v[i] of vector v.\\n\\n                  (0/0)\\n               /         \\\\\\n            (0/0)        (0/0)\\n             /  \\\\         /  \\\\\\n         (0/0)  (0/0)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (0/0)   (0/0)  (0/0)  (0/0)\\n\\nx=nums[0]=1=v[0] => acc/ways=1/1. We update the first leaf node (j=0):\\n\\n                  (1/1)\\n               /         \\\\\\n            (1/1)        (0/0)\\n             /  \\\\         /  \\\\\\n         (1/1)  (0/0)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (0/0)\\n\\n--------------------------------------------------------------------------------\\n(i=1) x=nums[1]=3=v[2]\\nTo find acc/ways of nums[1], we consider all visited previous leaf nodes of value<x.\\nSo, acc = maximum acc[j] of these leaf nodes,\\nways = sum of ways[j]\\'s of leaf nodes having the maximal acc[j] (as above).\\nIn practice, we trace from the root of sgTree following these principles:\\n\\n(1) when tree[x] represents the range [left, right] of v,\\nif v[right]<x, then every leaf node in [left, right] is of value<x\\n=> take tree[x]=(acc[x], ways[x]) into consideration directly\\n\\n(2) the children of tree[x] are tree[2*x] and tree[2*x+1], \\nrepresenting the ranges [left,mid] and [mid+1,right] respectively.\\nIf (x<=v[mid]), we pass to tree[2*x] directly\\nif (x>v[mid]), every leaf node under tree[2*x] is of value<x\\n    so we have to look at tree[2*x]=(acc[2*x], ways[2*x])\\n    and then compare it with what we get from query at tree[2*x+1].\\n\\nin this case, x=3 means that we look at ...\\n    the range [0,1]: tree[x] = (1, 1)\\n=> acc=1+1, ways=1 (i.e. {1,3})=> update the 3rd leaf node (j=2) by 2/1:\\n\\n                  (2/1)\\n               /         \\\\\\n            (2/1)        (0/0)\\n             /  \\\\         /  \\\\\\n         (1/1)  (2/1)  (0/0)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (0/0)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n(i=2) x=5=nums[2]=v[4]\\nquery: v[2]=3<x => range [0,2]: tree[x]=(2, 1)\\n       v[3]=4<x => range [3]: tree[x]=(0, 0) \\n=> acc=3, ways=1, i.e. {1,3,5}\\nupdate:\\n                  (3/1)\\n               /         \\\\\\n            (2/1)        (3/1)\\n             /  \\\\         /  \\\\\\n         (1/1)  (2/1)  (3/1)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (0/0)  (0/0)  (3/1)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n(i=3) x=2=nums[3]=v[1]\\nquery: v[0]=1<x => range [0]: tree[x]=(1,1)\\n=> acc=2, ways=1, i.e. {1,2}\\nupdate:\\n                  (3/1)\\n               /         \\\\\\n            (2/2)        (3/1)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/1)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (0/0)  (3/1)\\n     \\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n\\n(i=4) x=4=nums[4]=v[3]\\nquery: v[2]=3<4 => range [0,2]: tree[x]=(2, 2)\\n=> acc=3, ways=2, i.e. {1,2,4} and {1,3,4}\\nupdate:\\n                  (3/3)\\n               /         \\\\\\n            (2/2)        (3/3)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/3)  (0/0)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (3/2)  (3/1)\\n\\n v={1, 2, 3, 4, 5, 7}\\n--------------------------------------------------------------------------------\\n\\n(i=5) x=7=nums[5]=v[5]\\nquery: v[2]=3<7 => range [0,2]: tree[x]=(2,2)\\nquery: v[4]=5<7 => range [3,4]: tree[x]=(3,3)\\n=> acc=4, ways=3, i.e. {1,3,4,7}, {1,2,4,7}, {1,3,5,7}\\nupdate: \\n                  (4/3)\\n               /         \\\\\\n            (2/2)        (4/3)\\n             /  \\\\         /  \\\\\\n         (2/1)  (2/1)  (3/3)  (4/3)\\n         /   \\\\         /   \\\\\\n     (1/1)   (2/1)  (3/2)  (3/1)\\n--------------------------------------------------------------------------------\\n\\nreturn the information of tree[1] as result\\n*/\\n\\nstruct segmentTree{\\n    std::vector<std::pair<int,int>> tree;\\n    //tree[x] = {acc[x], ways[x]}\\n    std::vector<int> u;\\n    int N;\\n    segmentTree(std::vector<int>& v){\\n        N = v.size();\\n        tree.resize(4*N, std::pair<int,int>(0,0));\\n        for (int i=0; i<N; i++)\\n            u.push_back(v[i]);\\n        return;\\n    }\\n    \\n    void update(int x, int left, int right, int index, int acc, int ways){\\n        if (left==right){\\n            tree[x].first = acc;\\n            tree[x].second = ways;\\n            return;\\n        }\\n        int mid = (left+right)/2;\\n        if (index<=mid){\\n            update(2*x, left, mid, index, acc, ways);\\n        }else{\\n            update(2*x+1, mid+1, right, index, acc, ways);\\n        }\\n        if (tree[2*x].first>tree[2*x+1].first){\\n            tree[x] = tree[2*x];\\n        }else if (tree[2*x+1].first>tree[2*x].first){\\n            tree[x] = tree[2*x+1];\\n        }else{\\n            tree[x].first = tree[2*x].first;\\n            tree[x].second = tree[2*x].second + tree[2*x+1].second;\\n        }\\n        return;\\n    }\\n    \\n    std::pair<int,int> query(int x, int left, int right, int value){\\n        if (u[right]<value){\\n            return tree[x];\\n        }\\n        if (value<=u[left]){\\n            return std::pair<int,int>(0,0);\\n        }\\n        \\n        int mid = (left+right)/2;\\n        std::pair<int, int> temp;\\n        std::pair<int, int> result;\\n        \\n        if (value<=u[mid]){\\n            result = query(2*x, left, mid, value);\\n            \\n        }else{\\n            temp = query(2*x+1, mid+1, right, value);\\n            if (temp.first>tree[2*x].first){\\n                result.first = temp.first;\\n                result.second = temp.second;\\n                \\n            }else if (tree[2*x].first>temp.first){\\n                result.first = tree[2*x].first;\\n                result.second = tree[2*x].second;\\n            \\n            }else{\\n                result.first = tree[2*x].first;\\n                result.second = tree[2*x].second + temp.second;\\n            }\\n        }        \\n        return result;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        std::vector<std::pair<int,int>> numsPair;\\n        std::vector<int> indexMap(n, 0);\\n        std::vector<int> v(n, 0);\\n        for (int i=0; i<n; i++){\\n            numsPair.push_back(std::make_pair(nums[i], i));\\n        }\\n        std::sort(numsPair.begin(), numsPair.end());\\n        for (int j=0; j<n; j++){\\n            v[j] = numsPair[j].first;\\n            indexMap[numsPair[j].second] = j;\\n        }\\n        \\n        segmentTree sgTree = segmentTree(v);\\n        std::pair<int, int> myPair;\\n        int acc, ways;\\n        // i=0\\n        sgTree.update(1, 0, n-1, indexMap[0], 1, 1);\\n        \\n        for (int i=1; i<n; i++){\\n            myPair = sgTree.query(1, 0, n-1, nums[i]);\\n            acc = myPair.first+1;\\n            ways = std::max(1, myPair.second);\\n            //std::cout<<\"acc=\"<<acc<<\", ways=\"<<ways<<\"\\\\n\";\\n            sgTree.update(1, 0, n-1, indexMap[i], acc, ways);\\n        }\\n        \\n        //std::cout<<\"(\"<<sgTree.tree[1].first<<\", \"<<sgTree.tree[1].second<<\")\\\\n\";\\n        return sgTree.tree[1].second;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 917456,
                "title": "python-dp-memo",
                "content": "\\uD83D\\uDEA8 It\\'s not a fast enough solution. (But at least it\\'s easy for me to explain and implement in an interview.)\\n\\nThe idea is similar to [another bottom-up DP solution](https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/107303/python-DP-solution-with-DETAILED-explanation). We need to keep track **length** and **times**. **length** is the same as [LIS](https://leetcode.com/problems/longest-increasing-subsequence/). In addition, we need to track **times**, everytime we meet at the same length from both take and not take, we combine their times.\\n\\nFor example, for case `[1,3,6,8,4,5]`, when traversing to 3...\\n* if taking 6, it ends to be also taking 8 and done with length 2 (from 3\\'s pseceptive).\\n* if not taking 6, it ends to be not taking 8 but taking 4 and 5 with length 2 too.\\nSince the length is same, we combine the **times** of `[6, 8]` and `[4, 5]` for 3.\\n\\n```\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def helper(self, idx, hold):\\n        if idx == len(self.nums):\\n            return 0, 1\\n        elif hold is None or hold < self.nums[idx]:\\n            # take\\n            length1, times1 = self.helper(idx+1, self.nums[idx])\\n            length1 += 1\\n            \\n            # not take\\n            length2, times2 = self.helper(idx+1, hold)\\n            \\n            # if both take and not take are same length, pick both\\n            # otherwise, pick the longer LIS one\\n            if length1 == length2:\\n                return length2, times1 + times2\\n            elif length1 > length2:\\n                return length1, times1\\n            else:\\n                return length2, times2\\n        else:\\n            return self.helper(idx+1, hold)\\n    \\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0  # special case, no LIS\\n        self.nums = nums\\n        return self.helper(0, None)[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def helper(self, idx, hold):\\n        if idx == len(self.nums):\\n            return 0, 1\\n        elif hold is None or hold < self.nums[idx]:\\n            # take\\n            length1, times1 = self.helper(idx+1, self.nums[idx])\\n            length1 += 1\\n            \\n            # not take\\n            length2, times2 = self.helper(idx+1, hold)\\n            \\n            # if both take and not take are same length, pick both\\n            # otherwise, pick the longer LIS one\\n            if length1 == length2:\\n                return length2, times1 + times2\\n            elif length1 > length2:\\n                return length1, times1\\n            else:\\n                return length2, times2\\n        else:\\n            return self.helper(idx+1, hold)\\n    \\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0  # special case, no LIS\\n        self.nums = nums\\n        return self.helper(0, None)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470089,
                "title": "java-7ms-beats-99-83-tc-o-nlogn-sc-o-n-dp-binary-search-prefix-sums",
                "content": "# Why this work\\nDon\\'t ask me(Built on top of nlogn solution of problem 300):\\n[[Python] Short O(n log n) solution, beats 100%, explained](https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/916196/Python-Short-O(n-log-n)-solution-beats-100-explained)\\n[9ms [C++] Explanation: DP + Binary search + prefix sums O(NlogN) time; O(N) space](https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/107295/9ms-C%2B%2B-Explanation%3A-DP-%2B-Binary-search-%2B-prefix-sums-O(NlogN)-time-O(N)-space)\\n[Patience sorting on wikipedia](https://en.wikipedia.org/wiki/Patience_sorting)\\n\\n```java\\nclass Solution {\\n    public int findNumberOfLIS(int[] a) {\\n        int n = a.length, max = 1;\\n        // need to maintain list of decks for each length\\n        // in the list we need list of ending values (bottom up descending), and its counts prefix sum (bottom up)\\n        List<List<int[]>> decks = new ArrayList<>(); // int[0]: tail value, int[1]: count\\'s prefix sum\\n\\n        // step1 push\\n        for (int i = 0; i < n; i++) {\\n            int idx4insert = bs(a[i], decks); // key logic of 300, find where I(a[i]) belongs\\n\\n            // find cnt from previous list\\n            int cnt = idx4insert == 0 ? 1 : getCount(decks.get(idx4insert-1), a[i]);\\n\\n            // create the new element\\n            int[] cur = new int[] {a[i], cnt};\\n            List<int[]> deck;\\n            if (idx4insert == decks.size()) {\\n                decks.add(deck = new ArrayList<>());\\n            } else {\\n                deck = decks.get(idx4insert); // find the right deck\\n                cur[1] += deck.get(deck.size() - 1)[1]; // [1] is prefix sum of count\\n            }\\n            deck.add(cur);\\n        }\\n\\n        // System.out.printf(\"Input Array:\\\\n%s\\\\nDecks:\\\\n%s\\\\n\", Arrays.toString(a), toString(decks));\\n\\n        var deck = decks.get(decks.size() - 1);\\n        return deck.get(deck.size() - 1)[1];\\n    }\\n\\n    private int getCount(List<int[]> deck, int x) { // in a descending order list find largest smaller (no equal) 5 4 4 3: 4        \\n        int l = 0, r = deck.size();\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (deck.get(m)[0] >= x) l = m + 1;\\n            else r = m;\\n        }\\n        if (l == deck.size()) return 1; // first # of LIS, so count is 1;\\n        return deck.get(deck.size() - 1)[1] - (l == 0 ? 0 : deck.get(l-1)[1]);\\n    }\\n\\n    private int bs(int x, List<List<int[]>> decks) { // smallest >=, i.e. insertion index, 1 3 4 4 5: 4\\n        int l = 0, r = decks.size();\\n        while (l < r) { // find smallest larger\\n            int m = l + (r - l) / 2;\\n            var deck = decks.get(m);\\n            int cur = deck.get(deck.size() - 1)[0];\\n            if (cur < x) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n\\n    private StringBuilder toString(List<List<int[]>> decks) {\\n        return toString(decks, 1);\\n    }\\n    private StringBuilder toString(List<List<int[]>> decks, int w) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\"[\\\\n\");\\n        for (var deck : decks)\\n            sb.append(decktosb(deck, w));\\n\\n        sb.append(\"]\\\\n\");\\n        return sb;\\n    }\\n\\n    private StringBuilder decktosb(List<int[]> deck) {\\n        return decktosb(deck, 1);\\n    }\\n\\n    private StringBuilder decktosb(List<int[]> deck, int w) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'[\\');\\n        for (var arr : deck)\\n            sb.append(String.format(\"[%\"+ w + \"d, %\"+ w + \"d], \", arr[0], arr[1]));\\n\\n        sb.setLength(sb.length() - 2);\\n        return sb.append(\"]\\\\n\");\\n    }\\n}\\n```\\n\\nI printed out the decks for a few examples for better understanding:\\n```\\nInput Array:\\n[1, 3, 5, 4, 7]\\nDecks:\\n[\\n[[1, 1]]\\n[[3, 1]]\\n[[5, 1], [4, 2]]\\n[[7, 2]]\\n]\\n\\nInput Array:\\n[1, 3, 5, 4, 7, 5, 6, 2]\\nDecks:\\n[\\n[[1, 1]]\\n[[3, 1], [2, 2]]\\n[[5, 1], [4, 2]]\\n[[7, 2], [5, 3]]\\n[[6, 1]]\\n]\\n\\nInput Array:\\n[1, 2, 4, 3, 5, 4, 7, 2]\\nDecks:\\n[\\n[[1, 1]]\\n[[2, 1], [2, 2]]\\n[[4, 1], [3, 2]]\\n[[5, 2], [4, 3]]\\n[[7, 3]]\\n]\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int findNumberOfLIS(int[] a) {\\n        int n = a.length, max = 1;\\n        // need to maintain list of decks for each length\\n        // in the list we need list of ending values (bottom up descending), and its counts prefix sum (bottom up)\\n        List<List<int[]>> decks = new ArrayList<>(); // int[0]: tail value, int[1]: count\\'s prefix sum\\n\\n        // step1 push\\n        for (int i = 0; i < n; i++) {\\n            int idx4insert = bs(a[i], decks); // key logic of 300, find where I(a[i]) belongs\\n\\n            // find cnt from previous list\\n            int cnt = idx4insert == 0 ? 1 : getCount(decks.get(idx4insert-1), a[i]);\\n\\n            // create the new element\\n            int[] cur = new int[] {a[i], cnt};\\n            List<int[]> deck;\\n            if (idx4insert == decks.size()) {\\n                decks.add(deck = new ArrayList<>());\\n            } else {\\n                deck = decks.get(idx4insert); // find the right deck\\n                cur[1] += deck.get(deck.size() - 1)[1]; // [1] is prefix sum of count\\n            }\\n            deck.add(cur);\\n        }\\n\\n        // System.out.printf(\"Input Array:\\\\n%s\\\\nDecks:\\\\n%s\\\\n\", Arrays.toString(a), toString(decks));\\n\\n        var deck = decks.get(decks.size() - 1);\\n        return deck.get(deck.size() - 1)[1];\\n    }\\n\\n    private int getCount(List<int[]> deck, int x) { // in a descending order list find largest smaller (no equal) 5 4 4 3: 4        \\n        int l = 0, r = deck.size();\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (deck.get(m)[0] >= x) l = m + 1;\\n            else r = m;\\n        }\\n        if (l == deck.size()) return 1; // first # of LIS, so count is 1;\\n        return deck.get(deck.size() - 1)[1] - (l == 0 ? 0 : deck.get(l-1)[1]);\\n    }\\n\\n    private int bs(int x, List<List<int[]>> decks) { // smallest >=, i.e. insertion index, 1 3 4 4 5: 4\\n        int l = 0, r = decks.size();\\n        while (l < r) { // find smallest larger\\n            int m = l + (r - l) / 2;\\n            var deck = decks.get(m);\\n            int cur = deck.get(deck.size() - 1)[0];\\n            if (cur < x) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n\\n    private StringBuilder toString(List<List<int[]>> decks) {\\n        return toString(decks, 1);\\n    }\\n    private StringBuilder toString(List<List<int[]>> decks, int w) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\"[\\\\n\");\\n        for (var deck : decks)\\n            sb.append(decktosb(deck, w));\\n\\n        sb.append(\"]\\\\n\");\\n        return sb;\\n    }\\n\\n    private StringBuilder decktosb(List<int[]> deck) {\\n        return decktosb(deck, 1);\\n    }\\n\\n    private StringBuilder decktosb(List<int[]> deck, int w) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'[\\');\\n        for (var arr : deck)\\n            sb.append(String.format(\"[%\"+ w + \"d, %\"+ w + \"d], \", arr[0], arr[1]));\\n\\n        sb.setLength(sb.length() - 2);\\n        return sb.append(\"]\\\\n\");\\n    }\\n}\\n```\n```\\nInput Array:\\n[1, 3, 5, 4, 7]\\nDecks:\\n[\\n[[1, 1]]\\n[[3, 1]]\\n[[5, 1], [4, 2]]\\n[[7, 2]]\\n]\\n\\nInput Array:\\n[1, 3, 5, 4, 7, 5, 6, 2]\\nDecks:\\n[\\n[[1, 1]]\\n[[3, 1], [2, 2]]\\n[[5, 1], [4, 2]]\\n[[7, 2], [5, 3]]\\n[[6, 1]]\\n]\\n\\nInput Array:\\n[1, 2, 4, 3, 5, 4, 7, 2]\\nDecks:\\n[\\n[[1, 1]]\\n[[2, 1], [2, 2]]\\n[[4, 1], [3, 2]]\\n[[5, 2], [4, 3]]\\n[[7, 3]]\\n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795760,
                "title": "recursion-memoization-easy-to-understand-beginner-friendly-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)\\n\\n# Approach\\n\\n### Feel free to post you doubts in the comments\\n<!-- Describe your approach to solving the problem. -->\\n1. **solveMem Function**:\\nThe solveMem function is a recursive function that uses memoization to avoid redundant calculations. It takes the following parameters:\\nnums: The input array of integers representing the sequence.\\ncurr: The current index in the nums array that we are considering.\\nprev: The index of the previous element in the current potential LIS.\\ndp: A 2D vector used for memoization. dp[curr][prev + 1] stores the memoized result for the current state.\\nThe function returns a pair of integers: the length of the LIS ending at the current index curr and the count of such subsequences.\\n\\n2. **Base Case**:\\nThe **base case** of the recursion is when **curr == nums.size()**, which means we have reached the end of the array. In this case, we return make_pair(0, 1) to indicate that we have found a valid LIS of length 0 and count 1.\\n\\n3. **Memoization**:\\nBefore making any recursive calls, the function checks if the result for the current state (dp[curr][prev + 1]) is already computed. If so, it directly returns the stored result, avoiding redundant calculations.\\n\\n4. **Recursive Calls**:\\nThe function considers two possibilities to form a LIS:\\n- Include the current element (nums[curr]) in the LIS if it is greater than the previous element (nums[prev]). We make a recursive call to solveMem with **curr + 1 as the new index and curr as the new previous index**.\\n- Exclude the current element from the LIS. We make a recursive call to solveMem with **curr + 1 as the new index and prev remains the same**.\\nWe store the returned results from both recursive calls in variables include and exclude.\\n\\n5. **Update Length and Count**:\\nAfter the recursive calls, we compare the lengths of the LIS from both inclusion and exclusion cases. If the length from the inclusion case is greater than the current LIS length, we **update the current LIS length and reset the count**. If the lengths are the same, we **accumulate the count**.\\n\\n6. **Memoization and Return**:\\nWe store the calculated LIS length and count in the memoization table dp[curr][prev + 1]. Finally, the function returns the pair (length, count).\\n\\n7. **countLIS Function**:\\nThe countLIS function acts as a wrapper function. It initializes the variables curr and prev, creates a memoization table dp, and makes a call to the solveMem function with the initial parameters. The function then returns the count of LIS for the entire array.\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(2^n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n^2)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> solveMem(vector<int>& nums, int curr, int prev, vector<vector<pair<int, int>>>& dp) {\\n        if (curr == nums.size()) return make_pair(0, 1);\\n\\n        if (dp[curr][prev + 1].first != -1) return dp[curr][prev + 1];\\n\\n        int length = 0, count = 0;\\n\\n        if (prev == -1 || nums[prev] < nums[curr]){\\n            pair<int, int> include = solveMem(nums, curr + 1, curr, dp);\\n            int includeLength = 1 + include.first;\\n            if (includeLength > length){\\n                length = includeLength;\\n                count = include.second;\\n            } \\n            else if (includeLength == length){\\n                count += include.second;\\n            }\\n        }\\n\\n        pair<int, int> exclude = solveMem(nums, curr + 1, prev, dp);\\n        if (exclude.first > length){\\n            length = exclude.first;\\n            count = exclude.second;\\n        } \\n        else if (exclude.first == length){\\n            count += exclude.second;\\n        }\\n\\n        dp[curr][prev + 1] = make_pair(length, count);\\n\\n        return dp[curr][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int curr = 0, prev = -1;\\n        vector<vector<pair<int, int>>> dp(nums.size(), vector<pair<int, int>>(nums.size() + 1, make_pair(-1, -1)));\\n        pair<int, int> result = solveMem(nums, curr, prev, dp);\\n        return result.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> solveMem(vector<int>& nums, int curr, int prev, vector<vector<pair<int, int>>>& dp) {\\n        if (curr == nums.size()) return make_pair(0, 1);\\n\\n        if (dp[curr][prev + 1].first != -1) return dp[curr][prev + 1];\\n\\n        int length = 0, count = 0;\\n\\n        if (prev == -1 || nums[prev] < nums[curr]){\\n            pair<int, int> include = solveMem(nums, curr + 1, curr, dp);\\n            int includeLength = 1 + include.first;\\n            if (includeLength > length){\\n                length = includeLength;\\n                count = include.second;\\n            } \\n            else if (includeLength == length){\\n                count += include.second;\\n            }\\n        }\\n\\n        pair<int, int> exclude = solveMem(nums, curr + 1, prev, dp);\\n        if (exclude.first > length){\\n            length = exclude.first;\\n            count = exclude.second;\\n        } \\n        else if (exclude.first == length){\\n            count += exclude.second;\\n        }\\n\\n        dp[curr][prev + 1] = make_pair(length, count);\\n\\n        return dp[curr][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int curr = 0, prev = -1;\\n        vector<vector<pair<int, int>>> dp(nums.size(), vector<pair<int, int>>(nums.size() + 1, make_pair(-1, -1)));\\n        pair<int, int> result = solveMem(nums, curr, prev, dp);\\n        return result.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450979,
                "title": "python-dp-solution-with-explanation",
                "content": "Define `dp_l(i)` as the length of the longest increasing subsequence in `nums[:i + 1]`.\\nAlso, define `dp_c(i)` as the number of the longest increasing subsequence in `nums[:i + 1]`.\\nThen we\\'ll get the recursion below:\\n`dp_l(i) = max(dp_l(j) + 1, dp_l(i)) for j in range(i)`\\n`dp_c(i) += dp_c(j) if dp_l(i) == dp_l(j) + 1`\\n\\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        n = len(nums)\\n        dp_l = [1] * n\\n        dp_c = [1] * n\\n        for i, num in enumerate(nums):\\n            for j in range(i):\\n                if nums[i] <= nums[j]:\\n                    continue\\n                if dp_l[j] + 1 > dp_l[i]:\\n                    dp_l[i] = dp_l[j] + 1\\n                    dp_c[i] = dp_c[j]\\n                elif dp_l[j] + 1 == dp_l[i]:\\n                    dp_c[i] += dp_c[j]\\n        max_length = max(x for x in dp_l)\\n        count = 0\\n        for l, c in zip(dp_l, dp_c):\\n            if l == max_length:\\n                count += c\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        n = len(nums)\\n        dp_l = [1] * n\\n        dp_c = [1] * n\\n        for i, num in enumerate(nums):\\n            for j in range(i):\\n                if nums[i] <= nums[j]:\\n                    continue\\n                if dp_l[j] + 1 > dp_l[i]:\\n                    dp_l[i] = dp_l[j] + 1\\n                    dp_c[i] = dp_c[j]\\n                elif dp_l[j] + 1 == dp_l[i]:\\n                    dp_c[i] += dp_c[j]\\n        max_length = max(x for x in dp_l)\\n        count = 0\\n        for l, c in zip(dp_l, dp_c):\\n            if l == max_length:\\n                count += c\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107303,
                "title": "python-dp-solution-with-detailed-explanation",
                "content": "Well this question is based on problem [#300 Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) problem. In problem #300, dp solution is quite easy to come forward, which can be written as follow:\\n\\n```\\nclass Solution(object):\\n    def lengthOfLIS(self, nums):\\n        if not nums:\\n            return 0\\n        dp,ans = [1]* len(nums),1\\n        for i in range(1,len(nums)):\\n            dp[i]=max([dp[j]+1 for j in range(i) if nums[i]>nums[j]]+[1])\\n            ans=max(ans,dp[i])\\n        return ans\\n```\\n\\nHere ```dp[i]``` represents ```the length of the longest subsequence  in nums[:i+1] && ended with index i```. And when I calculate array ```dp```, I just update the result, stored in ```ans```.\\n\\nSo now let's back to this problem, the biggest difference here is that **we also need to find the number of the longest subsequence**. A basic idea is to use another array to memorize the number, so the code is as follow:\\n\\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        dp1,dp2 = [1]* len(nums),[1]*len(nums)\\n        count,maxval=1,1\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    if dp1[j]+1>dp1[i]:\\n                        dp1[i],dp2[i]=dp1[j]+1,dp2[j]\\n                    elif dp1[j]+1==dp1[i]:\\n                        dp2[i]+=dp2[j]\\n\\n            if dp1[i]>maxval:\\n                maxval,count=dp1[i],dp2[i]\\n            elif dp1[i]==maxval:\\n                count+=dp2[i]\\n\\n        return count\\n\\n```\\n ```dp1```  works the same as  ```dp```  in problem #300: it represents ```the length of the longest subsequence  in nums[:i+1] && ended with index i```. \\n\\n```dp2``` represents ```the number of the subsequences which are satisfied the conditions mentioned in above```.\\n\\nAnd also as problem #300, I also update the final result, stored in ```count``` in the loop.\\n\\n```maxval``` represents ```the length of the longest increasing subsequence```.\\n\\n```count``` represents ```the number of the increasing subsequence with length equals to maxval```.\\n\\nThe time complexity is O(n^2)---time,O(n)---space.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lengthOfLIS(self, nums):\\n        if not nums:\\n            return 0\\n        dp,ans = [1]* len(nums),1\\n        for i in range(1,len(nums)):\\n            dp[i]=max([dp[j]+1 for j in range(i) if nums[i]>nums[j]]+[1])\\n            ans=max(ans,dp[i])\\n        return ans\\n```\n```dp[i]```\n```the length of the longest subsequence  in nums[:i+1] && ended with index i```\n```dp```\n```ans```\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        dp1,dp2 = [1]* len(nums),[1]*len(nums)\\n        count,maxval=1,1\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    if dp1[j]+1>dp1[i]:\\n                        dp1[i],dp2[i]=dp1[j]+1,dp2[j]\\n                    elif dp1[j]+1==dp1[i]:\\n                        dp2[i]+=dp2[j]\\n\\n            if dp1[i]>maxval:\\n                maxval,count=dp1[i],dp2[i]\\n            elif dp1[i]==maxval:\\n                count+=dp2[i]\\n\\n        return count\\n\\n```\n```dp1```\n```dp```\n```the length of the longest subsequence  in nums[:i+1] && ended with index i```\n```dp2```\n```the number of the subsequences which are satisfied the conditions mentioned in above```\n```count```\n```maxval```\n```the length of the longest increasing subsequence```\n```count```\n```the number of the increasing subsequence with length equals to maxval```",
                "codeTag": "Java"
            },
            {
                "id": 3794936,
                "title": "video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/-VJeXNH3gAQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int [] dp = new int[n];\\n        int [] count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count,1);\\n        int max = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                        if (dp[j] + 1 > dp[i]) {\\n                            dp[i] = dp[j] + 1;\\n                            count[i] = count[j];\\n                        } else if (dp[j] + 1 == dp[i]) {\\n                            count[i] += count[j];\\n                        }\\n                max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == max) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1);\\n        vector<int> count(n, 1);\\n        int maxLen = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n                maxLen = max(maxLen, dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLen) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        count = [1] * n\\n        maxLen = 1\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if dp[j] + 1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        count[i] = count[j]\\n                    elif dp[j] + 1 == dp[i]:\\n                        count[i] += count[j]\\n                maxLen = max(maxLen, dp[i])\\n\\n        ans = 0\\n        for i in range(n):\\n            if dp[i] == maxLen:\\n                ans += count[i]\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int [] dp = new int[n];\\n        int [] count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count,1);\\n        int max = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                        if (dp[j] + 1 > dp[i]) {\\n                            dp[i] = dp[j] + 1;\\n                            count[i] = count[j];\\n                        } else if (dp[j] + 1 == dp[i]) {\\n                            count[i] += count[j];\\n                        }\\n                max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == max) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1);\\n        vector<int> count(n, 1);\\n        int maxLen = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n                maxLen = max(maxLen, dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLen) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        count = [1] * n\\n        maxLen = 1\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if dp[j] + 1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        count[i] = count[j]\\n                    elif dp[j] + 1 == dp[i]:\\n                        count[i] += count[j]\\n                maxLen = max(maxLen, dp[i])\\n\\n        ans = 0\\n        for i in range(n):\\n            if dp[i] == maxLen:\\n                ans += count[i]\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367666,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int[] c=new int[n];\\n        \\n        Arrays.fill(dp,1);\\n        Arrays.fill(c,1);\\n        \\n        int max=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                   if(dp[j]+1 > dp[i])//same subsequence\\n                   {\\n                       dp[i]=dp[j]+1;\\n                       c[i]=c[j];\\n                   }\\n                    else if(dp[j]+1==dp[i])//different subsequence\\n                    {\\n                        c[i]+=c[j];\\n                    }\\n                        \\n                }\\n            }\\n            max=Math.max(dp[i],max);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n            if(dp[i]==max)\\n                count+=c[i];\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int[] c=new int[n];\\n        \\n        Arrays.fill(dp,1);\\n        Arrays.fill(c,1);\\n        \\n        int max=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                   if(dp[j]+1 > dp[i])//same subsequence\\n                   {\\n                       dp[i]=dp[j]+1;\\n                       c[i]=c[j];\\n                   }\\n                    else if(dp[j]+1==dp[i])//different subsequence\\n                    {\\n                        c[i]+=c[j];\\n                    }\\n                        \\n                }\\n            }\\n            max=Math.max(dp[i],max);\\n        }\\n        \\n        int count=0;\\n        for(int i=0;i<n;i++)\\n            if(dp[i]==max)\\n                count+=c[i];\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921821,
                "title": "python-by-2d-dp-w-video",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u984C\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=ya4r7LZRl7E)\\n\\nPython by 2D DP\\n\\n---\\n\\n**Implementation** by 2D DP\\n\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n\\n        if not nums:\\n            # Quick response for empty list\\n            return 0\\n        \\n        n = len(nums)\\n        \\n        # record of length of increasing subsequence\\n        length = [1 for _ in range(n)]\\n        \\n        # record the path count of increasing subsequence\\n        count = [1 for _ in range(n)]\\n            \\n        # scan each number, where increasing subsequence ending in nums[i]\\n        for i in range(n):\\n            \\n            # for every number before nums[i]\\n            for k in range(i):\\n                \\n                \\n                if nums[k] < nums[i]:\\n                    # nums[k] can add to increasing subsequence ending in nums[i]\\n                    \\n                    if (length[k] + 1) > length[i]:\\n                        # nums[k] make it longer to increasing subsequence ending in nums[i]\\n                        length[i], count[i] = length[k]+1, count[k]\\n                \\n                    elif (length[k] + 1) == length[i]:\\n                        # nums[k] add some new paths of increasing subsequence ending in nums[i]\\n                        count[i] += count[k]\\n        \\n        \\n\\t\\t# get the length of lonest increasing subsequence\\n        max_length = max(length)\\n        \\n        # report total path count of longest increasing subsequence\\n        return sum( count for length, count in zip(length, count) if length == max_length )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n\\n        if not nums:\\n            # Quick response for empty list\\n            return 0\\n        \\n        n = len(nums)\\n        \\n        # record of length of increasing subsequence\\n        length = [1 for _ in range(n)]\\n        \\n        # record the path count of increasing subsequence\\n        count = [1 for _ in range(n)]\\n            \\n        # scan each number, where increasing subsequence ending in nums[i]\\n        for i in range(n):\\n            \\n            # for every number before nums[i]\\n            for k in range(i):\\n                \\n                \\n                if nums[k] < nums[i]:\\n                    # nums[k] can add to increasing subsequence ending in nums[i]\\n                    \\n                    if (length[k] + 1) > length[i]:\\n                        # nums[k] make it longer to increasing subsequence ending in nums[i]\\n                        length[i], count[i] = length[k]+1, count[k]\\n                \\n                    elif (length[k] + 1) == length[i]:\\n                        # nums[k] add some new paths of increasing subsequence ending in nums[i]\\n                        count[i] += count[k]\\n        \\n        \\n\\t\\t# get the length of lonest increasing subsequence\\n        max_length = max(length)\\n        \\n        # report total path count of longest increasing subsequence\\n        return sum( count for length, count in zip(length, count) if length == max_length )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740365,
                "title": "java-easy-and-clean-code-with-comments",
                "content": "Runtime: 17 ms, faster than 91.22% of Java online submissions for Number of Longest Increasing Subsequence.\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        //dp[i] will store the length of Longest Increasing Subsequence, ending at nums[i].\\n        int[] dp = new int[n];\\n        //count[i] will store the total number of Longest Increasing Subsequences, ending at nums[i].\\n        int[] count = new int[n];\\n        \\n        //lis : length of Longest Increasing Subsequence.\\n        int lis = 0;\\n        //res : total number of subsequences of length lis.\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = 1;\\n            count[i] = 1;\\n            \\n            //Checking it\\'s previous values.\\n            for (int j = 0; j < i; j++) {\\n                //If any previous value of nums[i] is less than it, then only it can be appended(as we know the \\n\\t\\t\\t\\t//subsequence would have ended at nums[j]).\\n                if (nums[j] < nums[i]) {\\n                    //If dp[i] is equal to dp[j] + 1, meaning a different sequence has been found of same \\n\\t\\t\\t\\t\\t//length, so increase count[i] by count[j].\\n                    if (dp[i] == dp[j] + 1) {\\n                        count[i] += count[j];\\n                    }\\n                    //Else, if dp[i] is less than dp[j] + 1, meaning length will increase as sequence will have a \\n\\t\\t\\t\\t\\t//new element, so store dp[j] + 1 in dp[i] and count[j] in count[i].\\n                    else if (dp[i] < dp[j] + 1) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    }\\n                }\\n            }\\n            \\n            //If lis is equal to dp[i], meaning a new sequence is found of same length, so add count[i] in res.\\n            if (lis == dp[i]) {\\n                res += count[i];\\n            }\\n            //Else if lis is less than dp[i], meaning a new sequence is formed of greater length, so store the \\n\\t\\t\\t//new increased length in lis and count[i] in res.\\n            else if (lis < dp[i]) {\\n                lis = dp[i];\\n                res = count[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        //dp[i] will store the length of Longest Increasing Subsequence, ending at nums[i].\\n        int[] dp = new int[n];\\n        //count[i] will store the total number of Longest Increasing Subsequences, ending at nums[i].\\n        int[] count = new int[n];\\n        \\n        //lis : length of Longest Increasing Subsequence.\\n        int lis = 0;\\n        //res : total number of subsequences of length lis.\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = 1;\\n            count[i] = 1;\\n            \\n            //Checking it\\'s previous values.\\n            for (int j = 0; j < i; j++) {\\n                //If any previous value of nums[i] is less than it, then only it can be appended(as we know the \\n\\t\\t\\t\\t//subsequence would have ended at nums[j]).\\n                if (nums[j] < nums[i]) {\\n                    //If dp[i] is equal to dp[j] + 1, meaning a different sequence has been found of same \\n\\t\\t\\t\\t\\t//length, so increase count[i] by count[j].\\n                    if (dp[i] == dp[j] + 1) {\\n                        count[i] += count[j];\\n                    }\\n                    //Else, if dp[i] is less than dp[j] + 1, meaning length will increase as sequence will have a \\n\\t\\t\\t\\t\\t//new element, so store dp[j] + 1 in dp[i] and count[j] in count[i].\\n                    else if (dp[i] < dp[j] + 1) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    }\\n                }\\n            }\\n            \\n            //If lis is equal to dp[i], meaning a new sequence is found of same length, so add count[i] in res.\\n            if (lis == dp[i]) {\\n                res += count[i];\\n            }\\n            //Else if lis is less than dp[i], meaning a new sequence is formed of greater length, so store the \\n\\t\\t\\t//new increased length in lis and count[i] in res.\\n            else if (lis < dp[i]) {\\n                lis = dp[i];\\n                res = count[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357851,
                "title": "c-o-n-logn-binary-searches",
                "content": "There are lots of O(n^2) solutions posted in the discussion forum. **I wonder if the interviewer woud really expect the optimal solution.** I am providing the O(n log(n)) solution here, with binary seaches on indexes. There are a lot of tricks played here.\\n\\nThe idea is simple; we keep track of the longest increasing sequence (LIS) as well as the number of LIS sequences ending with the current element. \\n\\nFor example, [1, 3, 5, 4, 7]\\nI assume it is easy to see LIS for the first 3 elements is [1, 3, 5].\\nWhen we see 4, we can update LIS to have [1,3,4], but we should not discard the sequence [1, 3, 5] since it may contribute to later LIS sequences. This LIS has a length 3 (maximum index is 2), so we keep a vector:\\ntable[2] = {[5,1], [4,1]}, indicating at LIS index 2 we could have 1 sequence ending with 5, and another sequence ending with 4.\\n\\nThen we see 7. We see 7 has to be added to the end of the previous LIS, but it could be added to the LIS ending with 5 or 4. So we will have table[3] = {[7, 2]}.\\n\\nIn general, for any current element, we will need to find out the index just before its insert point in LIS. In the previous example, for number 7 to be inserted at index 3, we need to check table[2] to update the number of possible paths for the current number. In my program, this is what `k` is.\\n\\nAlso, for each LIS insertion at index i, we are inserting it in desceding order, so it would be easy to find out the exact place in table[i] using binary search. In my program, I used negative number for easy binary search.\\n\\nAnother trick is I am only keeping the prefix sum of all paths for table[i]. In this way, the number of paths `k` can be obtained in O(1).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> table(n, vector<int>{});\\n        vector<vector<int>> paths;\\n        vector<int> lis;\\n        int i, j, k, ans = 0;\\n        for (auto num: nums){\\n            i = lower_bound(lis.begin(), \\n                            lis.end(),\\n                            num) - lis.begin();\\n            k = 1;\\n            if (i > 0){\\n                j = upper_bound(table[i-1].begin(), \\n                                table[i-1].end(), \\n                                -num) - table[i-1].begin();\\n                k = paths[i-1].back() - paths[i-1][j];\\n            }\\n\\n            table[i].push_back(-num);\\n\\n            if (i == lis.size()){\\n                lis.push_back(num);\\n                paths.push_back({0, k});\\n            }\\n            else {\\n                lis[i] = num;\\n                paths[i].push_back(paths[i].back() + k);\\n            }\\n        }\\n        return paths.back().back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> table(n, vector<int>{});\\n        vector<vector<int>> paths;\\n        vector<int> lis;\\n        int i, j, k, ans = 0;\\n        for (auto num: nums){\\n            i = lower_bound(lis.begin(), \\n                            lis.end(),\\n                            num) - lis.begin();\\n            k = 1;\\n            if (i > 0){\\n                j = upper_bound(table[i-1].begin(), \\n                                table[i-1].end(), \\n                                -num) - table[i-1].begin();\\n                k = paths[i-1].back() - paths[i-1][j];\\n            }\\n\\n            table[i].push_back(-num);\\n\\n            if (i == lis.size()){\\n                lis.push_back(num);\\n                paths.push_back({0, k});\\n            }\\n            else {\\n                lis[i] = num;\\n                paths[i].push_back(paths[i].back() + k);\\n            }\\n        }\\n        return paths.back().back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469612,
                "title": "java-o-n-log-n-solution-with-explanation-ft-patience-sorting",
                "content": "It took me several days to fully understand and grasp all the concepts, so don\\'t be overwhelmed when you don\\'t understand others\\' solutions at one go. I used patience sorting strategy to solve the problem. https://en.wikipedia.org/wiki/Patience_sorting\\n\\nI tried to be as verbose as possible, defining each Card/Pile class to help those of you who are having difficulties understanding the problem understand, while using available helper functions when needed. (e.g. I used java\\'s `Collections.binarySearch` to avoid implementing searching logic).\\n\\nPlease let me know if this solution helped you understanding the problem.\\n\\n```\\nclass Solution {\\n    //Use patience sorting algorithm to find all available LIS.\\n    \\n    //Patience sorting in a nutshell:\\n    //1. Initially, there are no piles. The first card dealt forms a new pile consisting of the single card.\\n    //2. Each subsequent card is placed on the leftmost existing pile whose top card has a value greater than or \\n    //   equal to the new card\\'s value, or to the right of all of the existing piles, thus forming a new pile.\\n    //3. When there are no more cards remaining to deal, the game ends.\\n    //4. When the game ends, # of piles is equal to the length of the LIS.\\n    \\n    // In our case, we are also adding a concept of `counts` to each card in order to track total number of LIS.\\n    \\n    class Card implements Comparable<Card> {\\n        //Num represents\\' card\\'s value.\\n        int num;\\n        \\n        //Counts represents cumulative counts, or LIS encountered so far for this card.\\n        //Card always belongs to a pile of cards, and top card will have cumulative counts for all cards below. (e.g. prefix sum)\\n        int counts;\\n        \\n        public Card(int num, int counts) {\\n            this.num = num;\\n            this.counts = counts;\\n        }\\n        \\n        // Overriden in order to use `Collections.binarySearch` for objects.\\n        @Override\\n        public int compareTo(Card o) {\\n            // By definition of patience sorting, smaller card will be placed on top of a greater card, so return negative value.\\n            // In some other solutions, people use negative value as card value to do something similar. This is doing the same thing.\\n            return o.num-num;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return \"{\"+num+\",\"+counts+\"}\";\\n        }\\n    }\\n    \\n    class Pile implements Comparable<Pile> {\\n        //You can think of cards as a stack of cards where the last element is on the top of cards, \\n\\t\\t//and the first element is at the bottom of cards.\\n        public List<Card> cards = new ArrayList<>();\\n        \\n        // Pile has at least one card with it.\\n        public Pile(Card first){\\n            cards.add(first);\\n        }\\n        \\n        // Helper method to return the last card (top card) in the pile.\\n        public Card getLastCard(){\\n            if(cards.isEmpty()){ //should never happen.\\n                return null;\\n            } else {\\n                return cards.get(cards.size()-1);\\n            }\\n        }\\n        \\n        // Get cumulative counts in the current pile that is smaller than provided number.\\n        // When a new card A is added to the pile after this pile instance, this function\\n        // can be invoked to fetch the cumulative counts for the card A.\\n\\n        // e.g. [Pile[Card(4,1),Card(1,2)], Pile[Card(3,?)]] - where x is number and y is counts in Card(x,y) format.\\n\\t\\t// In above case, when Card(3,?) is put on to a second pile, `?`\\'s value should be 2-1, which is 1.\\n        public int getCounts(int smallerThan) {\\n\\t\\t    //Build a card stub to use it in the search.\\n\\t\\t\\t//`compareTo` doesn\\'t use counts, so 0 for counts is fine.\\n            Card card = new Card(smallerThan, 0);\\n\\t\\t\\t\\n            int limitIdx = Collections.binarySearch(cards, card);\\n            int x = getLastCard().counts; //Top card\\'s count, which is cumulative counts for this whole pile.\\n            int y = 0; //y will hold a count of a card whose value is equal or greater than `smallerThan`.\\n            if(limitIdx < 0) {\\n                //Negative idx means exact match was not found, so insertion point was returned instead.\\n                //Negating the negative value gives us an index which has value that is greater than what we searched for.\\n                limitIdx = ~limitIdx;\\n                if(limitIdx > 0) {\\n                    y = cards.get(limitIdx-1).counts;\\n                }\\n            } else { \\n                //Exact match was found. \\n                //This means that There exists a card in this pile whose value is equal to `smallerThan`.\\n                //So we just need to subtract that found card\\'s counts from the top card\\'s count.\\n                //This is because we are interested in strictly increasing subsequence.\\n                y = cards.get(limitIdx).counts;\\n            }\\n            // We subtract counts of a card that is not smaller than the provided `smallerThan` arg from the top card\\'s count\\n            return x-y;\\n        }\\n        \\n        // Overriden in order to use `Collections.binarySearch` for objects.\\n        @Override\\n        public int compareTo(Pile o) {\\n            // Piles can be compared/sorted based on what is on the top of the cards in each pile.\\n            return getLastCard().num - o.getLastCard().num;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            // We are only interested in cards contents.\\n            return cards.toString();\\n        }\\n    }\\n    \\n    public int findNumberOfLIS(int[] nums) {\\n        \\n        //There are multiple piles in the deck where each pile\\'s last card (top card) is always greater than previous piles\\' last cards.\\n\\t\\t//and those last cards in the piles are in strictly increasing order.\\n        List<Pile> deck = new ArrayList<>();\\n        for(int i=0; i < nums.length;i++) {\\n            \\n            // Build a stub pile/card. a.k.a current card.\\n            Card card = new Card(nums[i], 1);\\n            // A stub pile that may/may not be added to the deck.\\n            Pile pile = new Pile(card);\\n            \\n            // Let\\'s find a location/index in the deck where this pile has to be put in.\\n            int idx = Collections.binarySearch(deck, pile);\\n            \\n            if(idx < 0) {\\n                //No exact match found, which means none of the piles in the deck has the top card value that is equivalent to the current card\\'s value.\\n                //Instead, insertion point has been returned in two\\'s complement, aka negative value.\\n\\t\\t\\t\\t//Read JavaDoc for `Collections binarysearch` for better understanding if needed.\\n                \\n                //Negate to insertion point value to get the index in the list where above card/pile has to be put in.\\n                idx = ~idx;\\n            }\\n            \\n            if(idx == deck.size()){ \\n                // Deck\\'s last element should have index of (deck.size()-1) as array/list index starts at 0 in computer science.\\n                // However, if result of `Collections.binarySearch` is equal to (deck.size()) which is nonexistent index, \\n                // that means that new pile has to be added to the deck.\\n                // It also means that current card\\'s number is greater than all other piles\\' top card.\\n                \\n                if(idx > 0) {\\n                    //If there exists a prev pile, get prev pile (currently last pile, but soon to be second to the last after this pile gets added)\\n                    //and fetch counts from the prev pile.\\n                    Pile prevPile = deck.get(idx-1);\\n                    \\n                    //Assign counts from the prev pile to the current card.\\n                    card.counts = prevPile.getCounts(card.num);\\n                }\\n                deck.add(pile);\\n            } else { \\n                //There exists a pile where card can be added to.\\n                pile = deck.get(idx);\\n                Card lastCard = pile.getLastCard();\\n                \\n                //The last card (top card) in the pile is always the smallest card in the given pile by definition of patience sorting.\\n                //Therefore, compare if the last card\\'s number is greater than the current card\\'s number or equal to the current card\\'number.\\n                \\n                //The last card will never be smaller than the current card\\'s number because `Collections.binarySearch` should have given us\\n                //an index of a pile whose top card is greater than or equal to the current card.\\n                if(lastCard.num > card.num) {\\n                    //Last card is greater than current card. \\n                    //This means that we just need to add current card to the top of a pile following patience sorting algorithm.\\n                    \\n                    if(idx == 0) {\\n                        //If current pile is the first pile in the deck, there is no previous pile and no counts to fetch from the previous pile\\'s top card.\\n                        //Therefore, set the card\\'s initial count to 1.\\n                        card.counts = 1;\\n                    } else {\\n                        //Otherwise, get counts from previous pile.\\n                        card.counts = deck.get(idx-1).getCounts(card.num);    \\n                    }\\n                    // Also add the pile\\'s current last card\\'s count to the current card, since we want to keep cumulative counts.\\n                    card.counts += pile.getLastCard().counts;\\n                    \\n                    // Add a new card to the cards in the deck like a stack.\\n                    pile.cards.add(card);\\n                } else { \\n                    //Last card\\'s num is equal to the current card.\\n                    //This means that we only need to update the card\\'s counts.\\n                    if(idx > 0) {\\n                        //If there is a previous pile, add counts from the previous pile.\\n                        lastCard.counts += deck.get(idx-1).getCounts(lastCard.num);\\n                    } else {\\n                        //Otherwise, just add one more count.\\n                        lastCard.counts +=1;\\n                    }\\n                }\\n            }\\n        }\\n        //At the end of patience sorting algorithm, length of the piles is equal to the length of the longest increasing subsequence.\\n        //And it is possible to get longest LIS by putting backward pointers to the previous pile\\'s top card whenever new card is put onto a pile.\\n        \\n        //In our case, we have been tracking cumulative LIS counts whenever we put a new card into a pile, (instead of putting back-pointers)\\n        //Therefore, last pile, the pile with the longest increasing subsequence, will contain all possible LIS, and the top card in the last pile will have a cumulative counts for \\n        //all possible LIS.\\n        return deck.get(deck.size()-1).getLastCard().counts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //Use patience sorting algorithm to find all available LIS.\\n    \\n    //Patience sorting in a nutshell:\\n    //1. Initially, there are no piles. The first card dealt forms a new pile consisting of the single card.\\n    //2. Each subsequent card is placed on the leftmost existing pile whose top card has a value greater than or \\n    //   equal to the new card\\'s value, or to the right of all of the existing piles, thus forming a new pile.\\n    //3. When there are no more cards remaining to deal, the game ends.\\n    //4. When the game ends, # of piles is equal to the length of the LIS.\\n    \\n    // In our case, we are also adding a concept of `counts` to each card in order to track total number of LIS.\\n    \\n    class Card implements Comparable<Card> {\\n        //Num represents\\' card\\'s value.\\n        int num;\\n        \\n        //Counts represents cumulative counts, or LIS encountered so far for this card.\\n        //Card always belongs to a pile of cards, and top card will have cumulative counts for all cards below. (e.g. prefix sum)\\n        int counts;\\n        \\n        public Card(int num, int counts) {\\n            this.num = num;\\n            this.counts = counts;\\n        }\\n        \\n        // Overriden in order to use `Collections.binarySearch` for objects.\\n        @Override\\n        public int compareTo(Card o) {\\n            // By definition of patience sorting, smaller card will be placed on top of a greater card, so return negative value.\\n            // In some other solutions, people use negative value as card value to do something similar. This is doing the same thing.\\n            return o.num-num;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return \"{\"+num+\",\"+counts+\"}\";\\n        }\\n    }\\n    \\n    class Pile implements Comparable<Pile> {\\n        //You can think of cards as a stack of cards where the last element is on the top of cards, \\n\\t\\t//and the first element is at the bottom of cards.\\n        public List<Card> cards = new ArrayList<>();\\n        \\n        // Pile has at least one card with it.\\n        public Pile(Card first){\\n            cards.add(first);\\n        }\\n        \\n        // Helper method to return the last card (top card) in the pile.\\n        public Card getLastCard(){\\n            if(cards.isEmpty()){ //should never happen.\\n                return null;\\n            } else {\\n                return cards.get(cards.size()-1);\\n            }\\n        }\\n        \\n        // Get cumulative counts in the current pile that is smaller than provided number.\\n        // When a new card A is added to the pile after this pile instance, this function\\n        // can be invoked to fetch the cumulative counts for the card A.\\n\\n        // e.g. [Pile[Card(4,1),Card(1,2)], Pile[Card(3,?)]] - where x is number and y is counts in Card(x,y) format.\\n\\t\\t// In above case, when Card(3,?) is put on to a second pile, `?`\\'s value should be 2-1, which is 1.\\n        public int getCounts(int smallerThan) {\\n\\t\\t    //Build a card stub to use it in the search.\\n\\t\\t\\t//`compareTo` doesn\\'t use counts, so 0 for counts is fine.\\n            Card card = new Card(smallerThan, 0);\\n\\t\\t\\t\\n            int limitIdx = Collections.binarySearch(cards, card);\\n            int x = getLastCard().counts; //Top card\\'s count, which is cumulative counts for this whole pile.\\n            int y = 0; //y will hold a count of a card whose value is equal or greater than `smallerThan`.\\n            if(limitIdx < 0) {\\n                //Negative idx means exact match was not found, so insertion point was returned instead.\\n                //Negating the negative value gives us an index which has value that is greater than what we searched for.\\n                limitIdx = ~limitIdx;\\n                if(limitIdx > 0) {\\n                    y = cards.get(limitIdx-1).counts;\\n                }\\n            } else { \\n                //Exact match was found. \\n                //This means that There exists a card in this pile whose value is equal to `smallerThan`.\\n                //So we just need to subtract that found card\\'s counts from the top card\\'s count.\\n                //This is because we are interested in strictly increasing subsequence.\\n                y = cards.get(limitIdx).counts;\\n            }\\n            // We subtract counts of a card that is not smaller than the provided `smallerThan` arg from the top card\\'s count\\n            return x-y;\\n        }\\n        \\n        // Overriden in order to use `Collections.binarySearch` for objects.\\n        @Override\\n        public int compareTo(Pile o) {\\n            // Piles can be compared/sorted based on what is on the top of the cards in each pile.\\n            return getLastCard().num - o.getLastCard().num;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            // We are only interested in cards contents.\\n            return cards.toString();\\n        }\\n    }\\n    \\n    public int findNumberOfLIS(int[] nums) {\\n        \\n        //There are multiple piles in the deck where each pile\\'s last card (top card) is always greater than previous piles\\' last cards.\\n\\t\\t//and those last cards in the piles are in strictly increasing order.\\n        List<Pile> deck = new ArrayList<>();\\n        for(int i=0; i < nums.length;i++) {\\n            \\n            // Build a stub pile/card. a.k.a current card.\\n            Card card = new Card(nums[i], 1);\\n            // A stub pile that may/may not be added to the deck.\\n            Pile pile = new Pile(card);\\n            \\n            // Let\\'s find a location/index in the deck where this pile has to be put in.\\n            int idx = Collections.binarySearch(deck, pile);\\n            \\n            if(idx < 0) {\\n                //No exact match found, which means none of the piles in the deck has the top card value that is equivalent to the current card\\'s value.\\n                //Instead, insertion point has been returned in two\\'s complement, aka negative value.\\n\\t\\t\\t\\t//Read JavaDoc for `Collections binarysearch` for better understanding if needed.\\n                \\n                //Negate to insertion point value to get the index in the list where above card/pile has to be put in.\\n                idx = ~idx;\\n            }\\n            \\n            if(idx == deck.size()){ \\n                // Deck\\'s last element should have index of (deck.size()-1) as array/list index starts at 0 in computer science.\\n                // However, if result of `Collections.binarySearch` is equal to (deck.size()) which is nonexistent index, \\n                // that means that new pile has to be added to the deck.\\n                // It also means that current card\\'s number is greater than all other piles\\' top card.\\n                \\n                if(idx > 0) {\\n                    //If there exists a prev pile, get prev pile (currently last pile, but soon to be second to the last after this pile gets added)\\n                    //and fetch counts from the prev pile.\\n                    Pile prevPile = deck.get(idx-1);\\n                    \\n                    //Assign counts from the prev pile to the current card.\\n                    card.counts = prevPile.getCounts(card.num);\\n                }\\n                deck.add(pile);\\n            } else { \\n                //There exists a pile where card can be added to.\\n                pile = deck.get(idx);\\n                Card lastCard = pile.getLastCard();\\n                \\n                //The last card (top card) in the pile is always the smallest card in the given pile by definition of patience sorting.\\n                //Therefore, compare if the last card\\'s number is greater than the current card\\'s number or equal to the current card\\'number.\\n                \\n                //The last card will never be smaller than the current card\\'s number because `Collections.binarySearch` should have given us\\n                //an index of a pile whose top card is greater than or equal to the current card.\\n                if(lastCard.num > card.num) {\\n                    //Last card is greater than current card. \\n                    //This means that we just need to add current card to the top of a pile following patience sorting algorithm.\\n                    \\n                    if(idx == 0) {\\n                        //If current pile is the first pile in the deck, there is no previous pile and no counts to fetch from the previous pile\\'s top card.\\n                        //Therefore, set the card\\'s initial count to 1.\\n                        card.counts = 1;\\n                    } else {\\n                        //Otherwise, get counts from previous pile.\\n                        card.counts = deck.get(idx-1).getCounts(card.num);    \\n                    }\\n                    // Also add the pile\\'s current last card\\'s count to the current card, since we want to keep cumulative counts.\\n                    card.counts += pile.getLastCard().counts;\\n                    \\n                    // Add a new card to the cards in the deck like a stack.\\n                    pile.cards.add(card);\\n                } else { \\n                    //Last card\\'s num is equal to the current card.\\n                    //This means that we only need to update the card\\'s counts.\\n                    if(idx > 0) {\\n                        //If there is a previous pile, add counts from the previous pile.\\n                        lastCard.counts += deck.get(idx-1).getCounts(lastCard.num);\\n                    } else {\\n                        //Otherwise, just add one more count.\\n                        lastCard.counts +=1;\\n                    }\\n                }\\n            }\\n        }\\n        //At the end of patience sorting algorithm, length of the piles is equal to the length of the longest increasing subsequence.\\n        //And it is possible to get longest LIS by putting backward pointers to the previous pile\\'s top card whenever new card is put onto a pile.\\n        \\n        //In our case, we have been tracking cumulative LIS counts whenever we put a new card into a pile, (instead of putting back-pointers)\\n        //Therefore, last pile, the pile with the longest increasing subsequence, will contain all possible LIS, and the top card in the last pile will have a cumulative counts for \\n        //all possible LIS.\\n        return deck.get(deck.size()-1).getLastCard().counts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849276,
                "title": "c-dp-o-n-2-solution-with-comments",
                "content": "Runtime: 68 ms, faster than 86.74% of C++ online submissions for Number of Longest Increasing Subsequence.\\nMemory Usage: 12.8 MB, less than 72.33% of C++ online submissions for Number of Longest Increasing Subsequence.\\n\\n`TestCase : [1,3,5,4,4,6,7,8,9,1,3,5,4,4,6,7,8,10,9]\\nAnswer : 7`\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        if(n==0) return 0;\\n        \\n        // DP list tracks the LIS of nums from start to ith index\\n        // Every value in nums has LIS 1\\n        vector<int>dp(n,1);\\n        \\n        // Stores the count of the number of LIS of nums from start to ith index\\n        // Every value in nums has LIS 1 and they have at least 1 combination of LIS \\n        vector<int>count(n,1);\\n        \\n         // Max LIS length\\n        int maxL = 1;\\n        \\n        // Final result of number of max LIS\\n        int res = 0;\\n        \\n        int current = 0;\\n        \\n        // Loop through the elements starting from second element\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            // Stores the LIS length till ith index in DP which statisfies below conditions\\n            current = 0;\\n            \\n            // Compare all values from start till the current index\\n            for(int j=0;j<i;j++)\\n            {\\n                // Check if the jth index value is less than the current index value cause it satisfies the\\n                // condition for IS and if so then check whether the jth index LIS value is greater than \\n                // or equal current LIS value, if yes then update current LIS with dp[j] cause we want to get the maxLength LIS\\n                \\n                // If above condition satisfied, we also update count[i] with count[j] if dp[j] > current \\n                // cause we got larger LIS value so we need to update the number of LIS of \\n                // jth index to ith index which is count[i] = count[j];\\n                // Otherwise we add count[j] with count[i] because we found another LIS equal to current LIS\\n                // which can generate another combination of max LIS till ith index\\n                \\n                if(nums[j]<nums[i] && dp[j] >= current)\\n                {\\n                    if(dp[j]==current)count[i]+=count[j];\\n                    else count[i] = count[j];\\n                    current = dp[j];                    \\n                }                \\n            }\\n                     \\n            // We add 1 with current cause current holds the LIS till the current index and as \\n            // current index is included we add 1 with it \\n            dp[i] = current + 1;\\n            maxL = max(maxL,dp[i]);\\n        }\\n        \\n\\n        // We go through the dp list and check ith index which has value of max LIS \\n        // and we add their number of LIS of ith index from count list with the result\\n        for(int i=0;i<nums.size();i++)\\n            if(dp[i]==maxL)res+=count[i];            \\n\\n        return res;\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        if(n==0) return 0;\\n        \\n        // DP list tracks the LIS of nums from start to ith index\\n        // Every value in nums has LIS 1\\n        vector<int>dp(n,1);\\n        \\n        // Stores the count of the number of LIS of nums from start to ith index\\n        // Every value in nums has LIS 1 and they have at least 1 combination of LIS \\n        vector<int>count(n,1);\\n        \\n         // Max LIS length\\n        int maxL = 1;\\n        \\n        // Final result of number of max LIS\\n        int res = 0;\\n        \\n        int current = 0;\\n        \\n        // Loop through the elements starting from second element\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            // Stores the LIS length till ith index in DP which statisfies below conditions\\n            current = 0;\\n            \\n            // Compare all values from start till the current index\\n            for(int j=0;j<i;j++)\\n            {\\n                // Check if the jth index value is less than the current index value cause it satisfies the\\n                // condition for IS and if so then check whether the jth index LIS value is greater than \\n                // or equal current LIS value, if yes then update current LIS with dp[j] cause we want to get the maxLength LIS\\n                \\n                // If above condition satisfied, we also update count[i] with count[j] if dp[j] > current \\n                // cause we got larger LIS value so we need to update the number of LIS of \\n                // jth index to ith index which is count[i] = count[j];\\n                // Otherwise we add count[j] with count[i] because we found another LIS equal to current LIS\\n                // which can generate another combination of max LIS till ith index\\n                \\n                if(nums[j]<nums[i] && dp[j] >= current)\\n                {\\n                    if(dp[j]==current)count[i]+=count[j];\\n                    else count[i] = count[j];\\n                    current = dp[j];                    \\n                }                \\n            }\\n                     \\n            // We add 1 with current cause current holds the LIS till the current index and as \\n            // current index is included we add 1 with it \\n            dp[i] = current + 1;\\n            maxL = max(maxL,dp[i]);\\n        }\\n        \\n\\n        // We go through the dp list and check ith index which has value of max LIS \\n        // and we add their number of LIS of ith index from count list with the result\\n        for(int i=0;i<nums.size();i++)\\n            if(dp[i]==maxL)res+=count[i];            \\n\\n        return res;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194561,
                "title": "tc-o-n-n-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,1),curr(n,1);\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int prev=0;prev<i;prev++)\\n            {\\n                if(nums[i]>nums[prev] && 1+dp[prev]>dp[i])\\n                {\\n                    dp[i]=1+dp[prev];\\n                    curr[i]=curr[prev];\\n                }\\n                else if(nums[prev]<nums[i] && dp[prev]+1==dp[i])\\n                {\\n                    curr[i]+=curr[prev];\\n                }   \\n            }\\n            maxi=max(maxi,dp[i]);\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==maxi)\\n                count+=curr[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Indexed Tree",
                    "Segment Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,1),curr(n,1);\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int prev=0;prev<i;prev++)\\n            {\\n                if(nums[i]>nums[prev] && 1+dp[prev]>dp[i])\\n                {\\n                    dp[i]=1+dp[prev];\\n                    curr[i]=curr[prev];\\n                }\\n                else if(nums[prev]<nums[i] && dp[prev]+1==dp[i])\\n                {\\n                    curr[i]+=curr[prev];\\n                }   \\n            }\\n            maxi=max(maxi,dp[i]);\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==maxi)\\n                count+=curr[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572950,
                "title": "c-fast-comprehensible-o-nlogn-time-o-n-space",
                "content": "Link to the submission stats:\\nhttps://leetcode.com/submissions/detail/799176896/\\n\\nYou can uncomment the code and look for the detailed run. I can also explain concept and code flow if required.\\nPlease Upvote! \\nThanks :)\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n         int n = nums.size();\\n        vector<pair<int, int>> v[n + 1];\\n        vector<int> vv;\\n        int len = 0;\\n        for (int x : nums) {\\n            if (vv.size()) {\\n                if (x > vv.back()) {\\n                    len++; vv.push_back(x);\\n                    //v[len].emplace_back(x, v[len - 1].back().second);\\n                    int lo = 0, hi = v[len - 1].size() - 1;\\n                    while (lo < hi) {\\n                        int mid = (lo + hi) / 2;\\n                        if (v[len - 1][mid].first >= x) {\\n                            lo = mid + 1;\\n                        }\\n                        else {\\n                            hi = mid;\\n                        }\\n                    }\\n                    v[len].emplace_back(x, v[len - 1].back().second - (hi > 0 ? v[len - 1][hi - 1].second : 0) );\\n                }\\n                else {\\n                    int it = lower_bound(vv.begin(), vv.end(), x) - vv.begin();\\n                    vv[it] = x;\\n                    int val = 0;\\n                    //calculate val\\n                    if (it == 0) {\\n                        val = 1;\\n                    }\\n                    else {\\n                        int lo = 0, hi = v[it].size() - 1;\\n                        while (lo < hi) {\\n                            int mid = (lo + hi) / 2;\\n                            if (v[it][mid].first >= x) {\\n                                lo = mid + 1;\\n                            }\\n                            else {\\n                                hi = mid;\\n                            }\\n                        }\\n                        //cout << it << endl;\\n                        val = v[it].back().second - (hi > 0 ? v[it][hi - 1].second : 0);\\n                    }\\n                    v[it + 1].emplace_back(x, val + v[it + 1].back().second);\\n                }\\n            }\\n            else {\\n                len++;\\n                vv.push_back(x);\\n                v[len].emplace_back(x, 1);\\n            }\\n            /*       for (int xx : vv) {\\n                       cout << xx << \" \";\\n                   }\\n                   cout << endl;*/\\n        }\\n        /*    for (int i = 1; i <= vv.size(); i++) {\\n                for (auto it : v[i]) {\\n                    cout << it.first << \" \" << it.second << endl;\\n                }\\n                cout << endl;\\n            }*/\\n        return v[vv.size()].back().second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n         int n = nums.size();\\n        vector<pair<int, int>> v[n + 1];\\n        vector<int> vv;\\n        int len = 0;\\n        for (int x : nums) {\\n            if (vv.size()) {\\n                if (x > vv.back()) {\\n                    len++; vv.push_back(x);\\n                    //v[len].emplace_back(x, v[len - 1].back().second);\\n                    int lo = 0, hi = v[len - 1].size() - 1;\\n                    while (lo < hi) {\\n                        int mid = (lo + hi) / 2;\\n                        if (v[len - 1][mid].first >= x) {\\n                            lo = mid + 1;\\n                        }\\n                        else {\\n                            hi = mid;\\n                        }\\n                    }\\n                    v[len].emplace_back(x, v[len - 1].back().second - (hi > 0 ? v[len - 1][hi - 1].second : 0) );\\n                }\\n                else {\\n                    int it = lower_bound(vv.begin(), vv.end(), x) - vv.begin();\\n                    vv[it] = x;\\n                    int val = 0;\\n                    //calculate val\\n                    if (it == 0) {\\n                        val = 1;\\n                    }\\n                    else {\\n                        int lo = 0, hi = v[it].size() - 1;\\n                        while (lo < hi) {\\n                            int mid = (lo + hi) / 2;\\n                            if (v[it][mid].first >= x) {\\n                                lo = mid + 1;\\n                            }\\n                            else {\\n                                hi = mid;\\n                            }\\n                        }\\n                        //cout << it << endl;\\n                        val = v[it].back().second - (hi > 0 ? v[it][hi - 1].second : 0);\\n                    }\\n                    v[it + 1].emplace_back(x, val + v[it + 1].back().second);\\n                }\\n            }\\n            else {\\n                len++;\\n                vv.push_back(x);\\n                v[len].emplace_back(x, 1);\\n            }\\n            /*       for (int xx : vv) {\\n                       cout << xx << \" \";\\n                   }\\n                   cout << endl;*/\\n        }\\n        /*    for (int i = 1; i <= vv.size(); i++) {\\n                for (auto it : v[i]) {\\n                    cout << it.first << \" \" << it.second << endl;\\n                }\\n                cout << endl;\\n            }*/\\n        return v[vv.size()].back().second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1122110,
                "title": "c-segment-tree-o-nlogn-12ms-99-89-faster",
                "content": "It\\'s a litter bit hard to understand the offical solution explaining. \\n### Before we use the Segment tree\\nI think the logic is simple:\\nWe need to build an array x so that x[i] record two number which is lenth of LIS ending on value \\u201C**i**\\u201D(value, not the index in nums) and the number of such LIS. \\nTo build this array **x**,  we can update the array **x** when we visit the original array **nums** from left to right.\\n\\nWhen we visit nums[i], \\nwe need to update x[num[i]] = 1 + max(x[i]) (from x[min(nums)] to x[nums[i]-1])  (To be noticed again, this is different with dp array normally we used to solve LIS in N^2)\\n\\nYeah, so that\\'s it, then we just need to maintain this array x in the segment tree way. So that every operation done in log time.\\n\\n### Meaning of the node \\nSo basically our segment tree node if his range is from value \"l\" to value \"r\", then it will record length of the longest LIS ending in \"i\"( l<=i <= r) \\n(It\\'s easy to misunderstand that the node is representing the LIS within the range from l to r, that not correct, only the ending point is within that range)\\n\\n### For speed \\nDon\\'t forget to make it discrete first otherwise the NlogN  \\'s N will be 10^6 not the 2005\\n```\\n#define ll long long\\n#define lc (u<<1)\\n#define rc (u<<1|1)\\nconst int maxn = 2005;\\n\\ntypedef struct V {\\n    ll len, cnt;\\n}V;\\n\\ntypedef struct node {\\n    ll l, r; \\n    V v;\\n}node;\\nnode tree[maxn << 2];\\n\\nstruct IntervalTree {\\n    void build(ll u, ll l, ll r) {\\n        tree[u].l = l, tree[u].r = r; tree[u].v = (V) {0, 1};\\n        if (l == r) {\\n            tree[u].v.len = 0, tree[u].v.cnt = 1; return ;\\n        }\\n        ll m = l + (r - l) / 2;\\n        build(lc, l, m); build(rc, m+1, r);\\n    }\\n    \\n    V merge(V v1, V v2) {\\n        if (v2.len == v1.len) {\\n            if (v1.len == 0) return (V) {0, 1};\\n            return (V) {v1.len, v1.cnt + v2.cnt};\\n        }\\n        return v1.len > v2.len ? v1 : v2;\\n    }\\n    \\n    void update(ll u, int l, int r, V v) {\\n        if (tree[u].l > r || tree[u].r < l) return;\\n        if (l <= tree[u].l && tree[u].r <= r) {\\n            tree[u].v = merge(v, tree[u].v); return;\\n        }\\n        update(lc, l, r, v), update(rc, l, r, v);\\n        tree[u].v = merge(tree[lc].v, tree[rc].v);\\n    }\\n    \\n    V query(ll u, ll l, ll r) {\\n        if (r < tree[u].l || l > tree[u].r) return (V) {0, 1};\\n        if (l <= tree[u].l && tree[u].r <= r) return tree[u].v;\\n        return merge(query(lc, l, r), query(rc, l, r));\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        // make it discrete\\n        vector<pair<int, int>> a;\\n        for (int i = 0; i < nums.size(); ++i) a.push_back(make_pair(nums[i], i));\\n        sort(a.begin(), a.end());  \\n        int end = unique(a.begin(), a.end()) - a.begin();\\n        unordered_map<int, int> rec;\\n        for (int i = 0; i < end; ++i) rec[a[i].first] = i; \\n        for (int i = 0; i < nums.size(); ++i) nums[i] = rec[nums[i]];\\n        \\n        // interval tree update and query\\n        int minn = nums[0], maxx = nums[0];\\n        for (auto &num : nums) minn = min(minn, num), maxx = max(maxx, num);\\n        IntervalTree t;\\n        t.build(1, minn, maxx);\\n        for (auto &num : nums) {\\n            V v = t.query(1, minn, num-1);\\n            t.update(1, num, num, (V){v.len+1, v.cnt});\\n        }\\n        return tree[1].v.cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define lc (u<<1)\\n#define rc (u<<1|1)\\nconst int maxn = 2005;\\n\\ntypedef struct V {\\n    ll len, cnt;\\n}V;\\n\\ntypedef struct node {\\n    ll l, r; \\n    V v;\\n}node;\\nnode tree[maxn << 2];\\n\\nstruct IntervalTree {\\n    void build(ll u, ll l, ll r) {\\n        tree[u].l = l, tree[u].r = r; tree[u].v = (V) {0, 1};\\n        if (l == r) {\\n            tree[u].v.len = 0, tree[u].v.cnt = 1; return ;\\n        }\\n        ll m = l + (r - l) / 2;\\n        build(lc, l, m); build(rc, m+1, r);\\n    }\\n    \\n    V merge(V v1, V v2) {\\n        if (v2.len == v1.len) {\\n            if (v1.len == 0) return (V) {0, 1};\\n            return (V) {v1.len, v1.cnt + v2.cnt};\\n        }\\n        return v1.len > v2.len ? v1 : v2;\\n    }\\n    \\n    void update(ll u, int l, int r, V v) {\\n        if (tree[u].l > r || tree[u].r < l) return;\\n        if (l <= tree[u].l && tree[u].r <= r) {\\n            tree[u].v = merge(v, tree[u].v); return;\\n        }\\n        update(lc, l, r, v), update(rc, l, r, v);\\n        tree[u].v = merge(tree[lc].v, tree[rc].v);\\n    }\\n    \\n    V query(ll u, ll l, ll r) {\\n        if (r < tree[u].l || l > tree[u].r) return (V) {0, 1};\\n        if (l <= tree[u].l && tree[u].r <= r) return tree[u].v;\\n        return merge(query(lc, l, r), query(rc, l, r));\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        // make it discrete\\n        vector<pair<int, int>> a;\\n        for (int i = 0; i < nums.size(); ++i) a.push_back(make_pair(nums[i], i));\\n        sort(a.begin(), a.end());  \\n        int end = unique(a.begin(), a.end()) - a.begin();\\n        unordered_map<int, int> rec;\\n        for (int i = 0; i < end; ++i) rec[a[i].first] = i; \\n        for (int i = 0; i < nums.size(); ++i) nums[i] = rec[nums[i]];\\n        \\n        // interval tree update and query\\n        int minn = nums[0], maxx = nums[0];\\n        for (auto &num : nums) minn = min(minn, num), maxx = max(maxx, num);\\n        IntervalTree t;\\n        t.build(1, minn, maxx);\\n        for (auto &num : nums) {\\n            V v = t.query(1, minn, num-1);\\n            t.update(1, num, num, (V){v.len+1, v.cnt});\\n        }\\n        return tree[1].v.cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916236,
                "title": "c-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if (nums.size() <= 1)\\n            return nums.size();\\n        \\n        vector<int> dp_len(n, 1);\\n        vector<int> dp_count(n, 1);\\n        \\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    if (dp_len[i] <= dp_len[j]){\\n                        dp_len[i] = dp_len[j]+1;\\n                        dp_count[i] = dp_count[j];\\n                    }\\n                    else if (dp_len[j]+1 == dp_len[i])\\n                        dp_count[i] += dp_count[j];\\n                }\\n            }\\n        }\\n        \\n        int max_length = *max_element(dp_len.begin(), dp_len.end());\\n        int res = 0;\\n        for (int i=0; i<n; i++) {\\n            if (dp_len[i] == max_length)\\n                res += dp_count[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if (nums.size() <= 1)\\n            return nums.size();\\n        \\n        vector<int> dp_len(n, 1);\\n        vector<int> dp_count(n, 1);\\n        \\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    if (dp_len[i] <= dp_len[j]){\\n                        dp_len[i] = dp_len[j]+1;\\n                        dp_count[i] = dp_count[j];\\n                    }\\n                    else if (dp_len[j]+1 == dp_len[i])\\n                        dp_count[i] += dp_count[j];\\n                }\\n            }\\n        }\\n        \\n        int max_length = *max_element(dp_len.begin(), dp_len.end());\\n        int res = 0;\\n        for (int i=0; i<n; i++) {\\n            if (dp_len[i] == max_length)\\n                res += dp_count[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228153,
                "title": "c-8ms-o-n-log-n-beats-100-queue-easy-to-understand",
                "content": "Here is how it works. Suppose the input array is **A** (not using **nums** to make code shorter), and the length of the input array is **m**. Using LIS algorithm, when sweeping the **A** from left to right, we can calculate the length of longest LIS eding at each index **i**. Assume the longest LIS ending at **i** is **L[i]**, and the number of LISs ending at **i** with length being **L[i]** is **F[i]**. \\nThen **F[i]**  is a summation of all **F[j]**\\'s such that **j<i** and **A[j]<A[i]** and **L[j]**=**L[i]-1**. As you can see that here we are imposing three constraints simulataneously. A naive DP method would run **j** from 0 to **i-1** so that to calculate **F[i]**. The trick that makes my algorithm diverge from the naive method is to define a vector of queues, i.e. vector<queue<int>> **vq**. The length of **vq** when we are sweeping at **i** is the length of the longest LISs we have got so far (not necessary **L[i]**). **vq[len-1]** is a queue of indices such that the length of longest LISs ending at these indices is **len**. Since we are sweeping **i** from **0** to **m-1**, the indices in the queue have an increasing order, but the values of **A** at these indices are decreasing. This stems from the fact that if **i<j** and **L[i]==L[j]**, then we must have **A[i]>=A[j]**. Since all the queues are used to store indices, therefore the total memory for **vq** is O(N).\\nLet **sumq** be an arrary, **sumq[len-1]** is the summation of all **F[k]** such that **k** runs over the indices stored within the queue denoted by **vq[len-1]**. At index **i**, our LIS length is **len**, to calculate **F[i]**, we need to sum up **vq[len-2]**. We may have to pop the front element in **vq[len-2]** since **A[vq[len-2].front()]** may be no smaller than **A[i]**. Because the queue is monotonic, the popped indices will never need to come back, that why this algorithm is faster. \\nThe other part of the code is easily understandable. After having **F[i]**, we push **i** as an index into **vq[len-1]**, and it contributes to **sumq[len-1]**.\\n\\nHaving run through the array **A**, we just need to return the last element of **sumq**, which is by definition the number of longest LISs in the array.\\n\\n    int helper(const vector<int> & A){\\n        const int m = A.size();\\n        if(m<2)\\n            return m;\\n        \\n        vector<int> B;\\n        vector<int> F(m,0);\\n        vector<int> sumq;\\n        vector<queue<int>> vq;\\n        \\n        for(int i = 0; i < m; i++){\\n            int len = 0;\\n            auto it = lower_bound(B.begin(),B.end(),A[i]);\\n            if(it==B.end())\\n                B.push_back(A[i]), len = B.size();\\n            else\\n                *it = A[i], len = (int)(it-B.begin())+1;\\n            \\n            if(len>vq.size())\\n                vq.push_back(queue<int>()), sumq.push_back(0);\\n            \\n            while(len>1&&A[vq[len-2].front()]>=A[i])\\n                sumq[len-2]-=F[vq[len-2].front()],vq[len-2].pop();\\n            F[i] = (len==1)? 1 : sumq[len-2];\\n            vq[len-1].push(i);\\n            sumq[len-1] += F[i];\\n        }\\n        \\n        return sumq.back();\\n    }",
                "solutionTags": [],
                "code": "Here is how it works. Suppose the input array is **A** (not using **nums** to make code shorter), and the length of the input array is **m**. Using LIS algorithm, when sweeping the **A** from left to right, we can calculate the length of longest LIS eding at each index **i**. Assume the longest LIS ending at **i** is **L[i]**, and the number of LISs ending at **i** with length being **L[i]** is **F[i]**. \\nThen **F[i]**  is a summation of all **F[j]**\\'s such that **j<i** and **A[j]<A[i]** and **L[j]**=**L[i]-1**. As you can see that here we are imposing three constraints simulataneously. A naive DP method would run **j** from 0 to **i-1** so that to calculate **F[i]**. The trick that makes my algorithm diverge from the naive method is to define a vector of queues, i.e. vector<queue<int>> **vq**. The length of **vq** when we are sweeping at **i** is the length of the longest LISs we have got so far (not necessary **L[i]**). **vq[len-1]** is a queue of indices such that the length of longest LISs ending at these indices is **len**. Since we are sweeping **i** from **0** to **m-1**, the indices in the queue have an increasing order, but the values of **A** at these indices are decreasing. This stems from the fact that if **i<j** and **L[i]==L[j]**, then we must have **A[i]>=A[j]**. Since all the queues are used to store indices, therefore the total memory for **vq** is O(N).\\nLet **sumq** be an arrary, **sumq[len-1]** is the summation of all **F[k]** such that **k** runs over the indices stored within the queue denoted by **vq[len-1]**. At index **i**, our LIS length is **len**, to calculate **F[i]**, we need to sum up **vq[len-2]**. We may have to pop the front element in **vq[len-2]** since **A[vq[len-2].front()]** may be no smaller than **A[i]**. Because the queue is monotonic, the popped indices will never need to come back, that why this algorithm is faster. \\nThe other part of the code is easily understandable. After having **F[i]**, we push **i** as an index into **vq[len-1]**, and it contributes to **sumq[len-1]**.\\n\\nHaving run through the array **A**, we just need to return the last element of **sumq**, which is by definition the number of longest LISs in the array.\\n\\n    int helper(const vector<int> & A){\\n        const int m = A.size();\\n        if(m<2)\\n            return m;\\n        \\n        vector<int> B;\\n        vector<int> F(m,0);\\n        vector<int> sumq;\\n        vector<queue<int>> vq;\\n        \\n        for(int i = 0; i < m; i++){\\n            int len = 0;\\n            auto it = lower_bound(B.begin(),B.end(),A[i]);\\n            if(it==B.end())\\n                B.push_back(A[i]), len = B.size();\\n            else\\n                *it = A[i], len = (int)(it-B.begin())+1;\\n            \\n            if(len>vq.size())\\n                vq.push_back(queue<int>()), sumq.push_back(0);\\n            \\n            while(len>1&&A[vq[len-2].front()]>=A[i])\\n                sumq[len-2]-=F[vq[len-2].front()],vq[len-2].pop();\\n            F[i] = (len==1)? 1 : sumq[len-2];\\n            vq[len-1].push(i);\\n            sumq[len-1] += F[i];\\n        }\\n        \\n        return sumq.back();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3794819,
                "title": "c-recursive-iterative-dp-beats-81-1-92-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlone LIS is easy, but the number of LIS is much harder. Use DP to solve! It needs 2 arrays. One for LIS, the other for counting!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe recursive solution is not slow and beats 81.1%. The iterative one is a little bit faster, beats 92.9%.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp; //dp[i]=length of the LIS ending at index i\\n    vector<int> count;// # of LIS with length=dp[i]\\n\\n    void LIS(int i, vector<int>& nums){\\n        if (i==0){\\n            dp[0]=1;\\n            count[0]=1;\\n            return ;\\n        }\\n        if (count[i]!=-1) return;\\n        dp[i]=1;\\n        count[i]=1;\\n        for(int j=0; j<i; j++){\\n            if(nums[i]>nums[j]){\\n                LIS(j, nums);\\n                if (dp[i]<dp[j]+1) {\\n                    dp[i]=dp[j]+1;\\n                    count[i]=count[j];\\n                }\\n                else if (dp[i]==dp[j]+1){\\n                    count[i]+=count[j];   \\n                }    \\n            }      \\n        }\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        dp.assign(n,-1);\\n        count.assign(n, -1);\\n        for(int i=0; i<n; i++)\\n            LIS(i, nums);\\n        int M=*max_element(dp.begin(), dp.end());\\n    //    cout<<M<<endl;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n    //        cout<<dp[i]<<\",\";\\n            if (M==dp[i])\\n                ans+=count[i];\\n        }   \\n    //    cout<<\"\\\\n---\\\\nans=\"<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```\\n# code for buttom up solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp; //dp[i]=length of the LIS ending at index i\\n    vector<int> count;// # of LIS with length=dp[i]\\n\\n    void LIS_bottom_up(vector<int>& nums, int n){\\n        dp.assign(n, 1);\\n        count.assign(n, 1);\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]>nums[j]){\\n                    if (dp[i]<dp[j]+1) {\\n                        dp[i]=dp[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if (dp[i]==dp[j]+1){\\n                        count[i]+=count[j];   \\n                    }    \\n                }      \\n            }\\n        } \\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        LIS_bottom_up(nums, n);\\n\\n        int M=*max_element(dp.begin(), dp.end());\\n    //    cout<<M<<endl;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n    //        cout<<dp[i]<<\",\";\\n            if (M==dp[i])\\n                ans+=count[i];\\n        }   \\n    //    cout<<\"\\\\n---\\\\nans=\"<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp; //dp[i]=length of the LIS ending at index i\\n    vector<int> count;// # of LIS with length=dp[i]\\n\\n    void LIS(int i, vector<int>& nums){\\n        if (i==0){\\n            dp[0]=1;\\n            count[0]=1;\\n            return ;\\n        }\\n        if (count[i]!=-1) return;\\n        dp[i]=1;\\n        count[i]=1;\\n        for(int j=0; j<i; j++){\\n            if(nums[i]>nums[j]){\\n                LIS(j, nums);\\n                if (dp[i]<dp[j]+1) {\\n                    dp[i]=dp[j]+1;\\n                    count[i]=count[j];\\n                }\\n                else if (dp[i]==dp[j]+1){\\n                    count[i]+=count[j];   \\n                }    \\n            }      \\n        }\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        dp.assign(n,-1);\\n        count.assign(n, -1);\\n        for(int i=0; i<n; i++)\\n            LIS(i, nums);\\n        int M=*max_element(dp.begin(), dp.end());\\n    //    cout<<M<<endl;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n    //        cout<<dp[i]<<\",\";\\n            if (M==dp[i])\\n                ans+=count[i];\\n        }   \\n    //    cout<<\"\\\\n---\\\\nans=\"<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp; //dp[i]=length of the LIS ending at index i\\n    vector<int> count;// # of LIS with length=dp[i]\\n\\n    void LIS_bottom_up(vector<int>& nums, int n){\\n        dp.assign(n, 1);\\n        count.assign(n, 1);\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]>nums[j]){\\n                    if (dp[i]<dp[j]+1) {\\n                        dp[i]=dp[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if (dp[i]==dp[j]+1){\\n                        count[i]+=count[j];   \\n                    }    \\n                }      \\n            }\\n        } \\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        LIS_bottom_up(nums, n);\\n\\n        int M=*max_element(dp.begin(), dp.end());\\n    //    cout<<M<<endl;\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n    //        cout<<dp[i]<<\",\";\\n            if (M==dp[i])\\n                ans+=count[i];\\n        }   \\n    //    cout<<\"\\\\n---\\\\nans=\"<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3317146,
                "title": "673-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize two arrays, dp and count, of length equal to the length of nums, with values of 1.\\n2. Iterate over each index i in the range 0 to the length of nums.\\n3. For each index i, iterate over all indices j before i in the range 0 to i.\\n4. Check if the element at index i in nums is greater than the element at index j in nums.\\n5. If the element at index i is greater than the element at index j, check if the length of the longest increasing subsequence ending at j plus 1 is greater than the length of the longest increasing subsequence ending at i. If it is, update the length of the longest increasing subsequence ending at i to dp[j] + 1 and update the number of such subsequences ending at i to count[j].\\n6. If the length of the longest increasing subsequence ending at j plus 1 is equal to the length of the longest increasing subsequence ending at i, add the number of such subsequences ending at j to the number of such subsequences ending at i.\\n7. Find the maximum value in the dp array and assign it to the variable max_len.\\n8. Return the sum of the values in the count array for all indices i where dp[i] is equal to max_len.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findNumberOfLIS(self, nums: List[int]) -> int:\\n    # initialize two arrays to store the length of the longest increasing subsequence\\n    # and the number of such subsequences ending at each index\\n    dp = [1] * len(nums)\\n    count = [1] * len(nums)\\n    # iterate over the input array\\n    for i in range(len(nums)):\\n        # iterate over all indices before i\\n        for j in range(i):\\n            # check if the current element at i is greater than the element at j\\n            if nums[i] > nums[j]:\\n                # if the length of the LIS ending at j plus 1 is greater than\\n                # the length of the LIS ending at i, update the length of the LIS ending at i\\n                if dp[j] + 1 > dp[i]:\\n                    dp[i] = dp[j] + 1\\n                    # update the number of subsequences ending at i\\n                    count[i] = count[j]\\n                # if the length of the LIS ending at j plus 1 is equal to\\n                # the length of the LIS ending at i, add the number of subsequences\\n                # ending at j to the number of subsequences ending at i\\n                elif dp[j] + 1 == dp[i]:\\n                    count[i] += count[j]\\n\\n    # find the length of the longest increasing subsequence\\n    max_len = max(dp)\\n    # find the number of subsequences with length equal to the length of the longest increasing subsequence\\n    return sum([count[i] for i in range(len(nums)) if dp[i] == max_len])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution:\\n  def findNumberOfLIS(self, nums: List[int]) -> int:\\n    # initialize two arrays to store the length of the longest increasing subsequence\\n    # and the number of such subsequences ending at each index\\n    dp = [1] * len(nums)\\n    count = [1] * len(nums)\\n    # iterate over the input array\\n    for i in range(len(nums)):\\n        # iterate over all indices before i\\n        for j in range(i):\\n            # check if the current element at i is greater than the element at j\\n            if nums[i] > nums[j]:\\n                # if the length of the LIS ending at j plus 1 is greater than\\n                # the length of the LIS ending at i, update the length of the LIS ending at i\\n                if dp[j] + 1 > dp[i]:\\n                    dp[i] = dp[j] + 1\\n                    # update the number of subsequences ending at i\\n                    count[i] = count[j]\\n                # if the length of the LIS ending at j plus 1 is equal to\\n                # the length of the LIS ending at i, add the number of subsequences\\n                # ending at j to the number of subsequences ending at i\\n                elif dp[j] + 1 == dp[i]:\\n                    count[i] += count[j]\\n\\n    # find the length of the longest increasing subsequence\\n    max_len = max(dp)\\n    # find the number of subsequences with length equal to the length of the longest increasing subsequence\\n    return sum([count[i] for i in range(len(nums)) if dp[i] == max_len])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099341,
                "title": "dp-with-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        // vector dp stores length of lonegst inc subseq ending with nums[i]\\n        // vector cnt stores the number of subsequences of length dp[i]\\n        vector<int>dp(nums.size(),1),cnt(nums.size(),1);\\n        int mxLen=1,res=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            for(int j = 0; j < i; j++){\\n                \\n                // if nums[j] < nums[i] we are sure that we can append nums[i] \\n                if(nums[i] > nums[j]){\\n                    \\n                    // append nums[i] only if length is incresed\\n                    if(dp[j]+1 > dp[i]){\\n                    dp[i] = dp[j]+1;\\n                    cnt[i] = cnt[j];\\n                    }\\n                    // if appending nums[i] after nums[j] gives length equal to dp[i] -> means there exists more number of ways to design subseq of this length so adding them to cnt[i]\\n                    else if(dp[j]+1 == dp[i])\\n                        cnt[i] += cnt[j];\\n                    }\\n            }\\n            // to store maxLen\\n            mxLen = max(mxLen, dp[i]);\\n        }\\n        //counting total number of ways to design subseq of length mxLen\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i] == mxLen)\\n                res += cnt[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        // vector dp stores length of lonegst inc subseq ending with nums[i]\\n        // vector cnt stores the number of subsequences of length dp[i]\\n        vector<int>dp(nums.size(),1),cnt(nums.size(),1);\\n        int mxLen=1,res=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            for(int j = 0; j < i; j++){\\n                \\n                // if nums[j] < nums[i] we are sure that we can append nums[i] \\n                if(nums[i] > nums[j]){\\n                    \\n                    // append nums[i] only if length is incresed\\n                    if(dp[j]+1 > dp[i]){\\n                    dp[i] = dp[j]+1;\\n                    cnt[i] = cnt[j];\\n                    }\\n                    // if appending nums[i] after nums[j] gives length equal to dp[i] -> means there exists more number of ways to design subseq of this length so adding them to cnt[i]\\n                    else if(dp[j]+1 == dp[i])\\n                        cnt[i] += cnt[j];\\n                    }\\n            }\\n            // to store maxLen\\n            mxLen = max(mxLen, dp[i]);\\n        }\\n        //counting total number of ways to design subseq of length mxLen\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i] == mxLen)\\n                res += cnt[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107298,
                "title": "java-with-explanation-easy-to-understand",
                "content": "\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return 0;\\n        int[] maxLens = new int[nums.length];// length of longest increasing sequence start from i\\n        int[] counts = new int[nums.length]; // number of length of longest increasing sequence start from i\\n        int maxLen = 1; // length of longest increasing subsequnce\\n        maxLens[nums.length-1] = 1;\\n        counts[nums.length-1] = 1;\\n\\n        for(int i = nums.length -2; i>=0; i--){//Backward iteration, i is used as the first character\\n            int curMax = 1;\\n            int count = 1;\\n            for(int j = i+1; j < nums.length; j++) {//j is used as the second character\\n                if(nums[i] < nums[j]){//increasing number\\n                    if (curMax == maxLens[j]+1)//means have another way to reach the same max length increasing sequence\\n                        count += counts[j];  //Important: not ++\\n                    else if (curMax < maxLens[j]+1){\\n                        count = counts[j]; \\n                        curMax = maxLens[j]+1; \\n                    }\\n                }\\n            }\\n            maxLens[i] = curMax;\\n            counts[i] = count;\\n            maxLen = Math.max(maxLen, curMax);\\n        }\\n        int count = 0;\\n        for(int i = 0; i< maxLens.length; i++){//check each possible start position\\n            if (maxLens[i] == maxLen)\\n                count += counts[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return 0;\\n        int[] maxLens = new int[nums.length];// length of longest increasing sequence start from i\\n        int[] counts = new int[nums.length]; // number of length of longest increasing sequence start from i\\n        int maxLen = 1; // length of longest increasing subsequnce\\n        maxLens[nums.length-1] = 1;\\n        counts[nums.length-1] = 1;\\n\\n        for(int i = nums.length -2; i>=0; i--){//Backward iteration, i is used as the first character\\n            int curMax = 1;\\n            int count = 1;\\n            for(int j = i+1; j < nums.length; j++) {//j is used as the second character\\n                if(nums[i] < nums[j]){//increasing number\\n                    if (curMax == maxLens[j]+1)//means have another way to reach the same max length increasing sequence\\n                        count += counts[j];  //Important: not ++\\n                    else if (curMax < maxLens[j]+1){\\n                        count = counts[j]; \\n                        curMax = maxLens[j]+1; \\n                    }\\n                }\\n            }\\n            maxLens[i] = curMax;\\n            counts[i] = count;\\n            maxLen = Math.max(maxLen, curMax);\\n        }\\n        int count = 0;\\n        for(int i = 0; i< maxLens.length; i++){//check each possible start position\\n            if (maxLens[i] == maxLen)\\n                count += counts[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798081,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing Dynamic Programming to keep longest subsequences every iteration.\\nThis solution beats 97%. \\n\\n![Screen Shot 2023-07-22 at 2.26.47.png](https://assets.leetcode.com/users/images/4be94a80-06ec-46af-980a-56e4df41c2f0_1689960430.558125.png)\\n\\n---\\n\\n# Solution Video\\n*** Please upvote for this article. *** \\n\\nhttps://youtu.be/EP4CeEoxkwY\\n\\n# Subscribe to my channel from here. I have 226 videos as of July 22th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python code. Other languages might be different.\\n\\n1. Initialize the `dp` dictionary with a `defaultdict` of `Counter`. This dictionary will store the number of increasing subsequences (LIS) of different lengths, and each LIS length will be associated with a Counter object that counts the occurrences of different ending numbers for that LIS length.\\n\\n2. Initialize `dp[-1][-float(\"inf\")] = 1`. This is a special entry in the `dp` dictionary to handle the case when the LIS length is 0. Here, `-float(\"inf\")` is used as a unique key to represent LIS length 0, and the count is set to 1, as there is only one empty LIS.\\n\\n3. Initialize an empty list `sorted_nums`. This list will be used to keep track of the elements of the input `nums` list in sorted order, to find the correct insertion position for each number.\\n\\n4. Loop through each number `num` in the `nums` list:\\n   a. Find the index `insert_index` using `bisect.bisect_left(sorted_nums, num)` where `sorted_nums` is treated as a sorted list. This index represents the correct position to insert the current number `num` to maintain the sorted order.\\n   b. If `insert_index` is equal to the length of `sorted_nums`, it means the current number is greater than all elements in `sorted_nums`, so we append it to the end of `sorted_nums`.\\n   c. Otherwise, if `insert_index` is within the range of `sorted_nums`, it means the current number needs to be inserted at a specific position in `sorted_nums`, so we update the element at `insert_index` with the current number.\\n   d. Initialize `total` to 0, which will be used to store the count of all possible LIS of length `insert_index` ending with the current number `num`.\\n   e. Loop through each previous number `prev_num` in the LIS of length `insert_index - 1`:\\n      - If `prev_num` is less than the current number `num`, then it can be a valid ending number for the LIS of length `insert_index`.\\n      - We add the count of LIS of length `insert_index - 1` ending with `prev_num` to the `total`.\\n   f. Update the `dp[insert_index][num]` entry by adding the `total` to it. This represents the count of LIS of length `insert_index` ending with the current number `num`.\\n\\n5. Finally, return the sum of all values in the `dp` dictionary for the last length `len(sorted_nums) - 1`, which represents the total count of all possible LIS of the longest length.\\n\\nIn summary, the algorithm dynamically computes the number of increasing subsequences of different lengths using a combination of `sorted_nums` to find the correct position for each number and the `dp` dictionary to store the counts. The approach efficiently calculates the number of LIS by considering the increasing property and reusing the counts of shorter subsequences to determine the counts of longer subsequences.\\n\\n# Complexity\\nThis is based on Python code. Other languages might be different.\\n\\n- Time complexity: O(n log n) or O(n^2)\\nTheoretically, O(n^2) but in reality O(n log n). I didn\\'t come up with O(n^2) case. Let me know if you find the case.\\n\\n- Space complexity: O(n)\\nThere is possiblity that I put data into dp and sorted_nums at most n.\\n\\n```python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = defaultdict(Counter)\\n        dp[-1][-float(\"inf\")] = 1\\n        sorted_nums = []\\n\\n        for num in nums:\\n            insert_index = bisect.bisect_left(sorted_nums, num)\\n            if insert_index == len(sorted_nums):\\n                sorted_nums.append(num)\\n            else:\\n                sorted_nums[insert_index] = num\\n\\n            total = 0\\n            for prev_num in dp[insert_index - 1]:\\n                if prev_num < num:\\n                    total += dp[insert_index - 1][prev_num]\\n            \\n            dp[insert_index][num] += total\\n        \\n        return sum(dp[len(sorted_nums) - 1].values())\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNumberOfLIS = function(nums) {\\n    var dp = new Map();\\n    dp.set(-1, new Map());\\n    dp.get(-1).set(-Infinity, 1);\\n    var sortedNums = [];\\n\\n    for (var num of nums) {\\n        var insertIndex = bisectLeft(sortedNums, num);\\n        if (insertIndex === sortedNums.length) {\\n            sortedNums.push(num);\\n        } else {\\n            sortedNums[insertIndex] = num;\\n        }\\n\\n        var total = 0;\\n        for (var [prevNum, count] of dp.get(insertIndex - 1).entries()) {\\n            if (prevNum < num) {\\n                total += count;\\n            }\\n        }\\n        dp.set(insertIndex, dp.get(insertIndex) || new Map());\\n        dp.get(insertIndex).set(num, (dp.get(insertIndex).get(num) || 0) + total);\\n    }\\n\\n    var result = 0;\\n    for (var count of dp.get(sortedNums.length - 1).values()) {\\n        result += count;\\n    }\\n    return result;    \\n};\\n\\nvar bisectLeft = function(arr, target) {\\n    var left = 0;\\n    var right = arr.length;\\n\\n    while (left < right) {\\n        var mid = Math.floor((left + right) / 2);\\n        if (arr[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n\\n    return left;\\n};\\n```\\n```java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        Map<Integer, Map<Integer, Integer>> dp = new HashMap<>();\\n        dp.put(-1, new HashMap<>());\\n        dp.get(-1).put(Integer.MIN_VALUE, 1);\\n        List<Integer> sortedNums = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            int insertIndex = bisectLeft(sortedNums, num);\\n            if (insertIndex == sortedNums.size()) {\\n                sortedNums.add(num);\\n            } else {\\n                sortedNums.set(insertIndex, num);\\n            }\\n\\n            int total = 0;\\n            for (Map.Entry<Integer, Integer> entry : dp.getOrDefault(insertIndex - 1, new HashMap<>()).entrySet()) {\\n                int prevNum = entry.getKey();\\n                int count = entry.getValue();\\n                if (prevNum < num) {\\n                    total += count;\\n                }\\n            }\\n            dp.putIfAbsent(insertIndex, new HashMap<>());\\n            dp.get(insertIndex).put(num, dp.getOrDefault(insertIndex, new HashMap<>()).getOrDefault(num, 0) + total);\\n        }\\n\\n        int result = 0;\\n        for (int count : dp.getOrDefault(sortedNums.size() - 1, new HashMap<>()).values()) {\\n            result += count;\\n        }\\n        return result; \\n    }\\n\\n    private int bisectLeft(List<Integer> arr, int target) {\\n        int left = 0;\\n        int right = arr.size();\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr.get(mid) < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }  \\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        std::unordered_map<int, std::map<int, int>> dp;\\n        dp[-1][-INT_MAX] = 1;\\n        std::vector<int> sortedNums;\\n\\n        for (int num : nums) {\\n            int insertIndex = bisectLeft(sortedNums, num);\\n            if (insertIndex == sortedNums.size()) {\\n                sortedNums.push_back(num);\\n            } else {\\n                sortedNums[insertIndex] = num;\\n            }\\n\\n            int total = 0;\\n            for (const auto& entry : dp[insertIndex - 1]) {\\n                int prevNum = entry.first;\\n                int count = entry.second;\\n                if (prevNum < num) {\\n                    total += count;\\n                }\\n            }\\n            dp[insertIndex][num] += total;\\n        }\\n\\n        int result = 0;\\n        for (const auto& entry : dp[sortedNums.size() - 1]) {\\n            result += entry.second;\\n        }\\n        return result;        \\n    }\\n\\nprivate:\\n    int bisectLeft(const std::vector<int>& arr, int target) {\\n        int left = 0;\\n        int right = arr.size();\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = defaultdict(Counter)\\n        dp[-1][-float(\"inf\")] = 1\\n        sorted_nums = []\\n\\n        for num in nums:\\n            insert_index = bisect.bisect_left(sorted_nums, num)\\n            if insert_index == len(sorted_nums):\\n                sorted_nums.append(num)\\n            else:\\n                sorted_nums[insert_index] = num\\n\\n            total = 0\\n            for prev_num in dp[insert_index - 1]:\\n                if prev_num < num:\\n                    total += dp[insert_index - 1][prev_num]\\n            \\n            dp[insert_index][num] += total\\n        \\n        return sum(dp[len(sorted_nums) - 1].values())\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNumberOfLIS = function(nums) {\\n    var dp = new Map();\\n    dp.set(-1, new Map());\\n    dp.get(-1).set(-Infinity, 1);\\n    var sortedNums = [];\\n\\n    for (var num of nums) {\\n        var insertIndex = bisectLeft(sortedNums, num);\\n        if (insertIndex === sortedNums.length) {\\n            sortedNums.push(num);\\n        } else {\\n            sortedNums[insertIndex] = num;\\n        }\\n\\n        var total = 0;\\n        for (var [prevNum, count] of dp.get(insertIndex - 1).entries()) {\\n            if (prevNum < num) {\\n                total += count;\\n            }\\n        }\\n        dp.set(insertIndex, dp.get(insertIndex) || new Map());\\n        dp.get(insertIndex).set(num, (dp.get(insertIndex).get(num) || 0) + total);\\n    }\\n\\n    var result = 0;\\n    for (var count of dp.get(sortedNums.length - 1).values()) {\\n        result += count;\\n    }\\n    return result;    \\n};\\n\\nvar bisectLeft = function(arr, target) {\\n    var left = 0;\\n    var right = arr.length;\\n\\n    while (left < right) {\\n        var mid = Math.floor((left + right) / 2);\\n        if (arr[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n\\n    return left;\\n};\\n```\n```java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        Map<Integer, Map<Integer, Integer>> dp = new HashMap<>();\\n        dp.put(-1, new HashMap<>());\\n        dp.get(-1).put(Integer.MIN_VALUE, 1);\\n        List<Integer> sortedNums = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            int insertIndex = bisectLeft(sortedNums, num);\\n            if (insertIndex == sortedNums.size()) {\\n                sortedNums.add(num);\\n            } else {\\n                sortedNums.set(insertIndex, num);\\n            }\\n\\n            int total = 0;\\n            for (Map.Entry<Integer, Integer> entry : dp.getOrDefault(insertIndex - 1, new HashMap<>()).entrySet()) {\\n                int prevNum = entry.getKey();\\n                int count = entry.getValue();\\n                if (prevNum < num) {\\n                    total += count;\\n                }\\n            }\\n            dp.putIfAbsent(insertIndex, new HashMap<>());\\n            dp.get(insertIndex).put(num, dp.getOrDefault(insertIndex, new HashMap<>()).getOrDefault(num, 0) + total);\\n        }\\n\\n        int result = 0;\\n        for (int count : dp.getOrDefault(sortedNums.size() - 1, new HashMap<>()).values()) {\\n            result += count;\\n        }\\n        return result; \\n    }\\n\\n    private int bisectLeft(List<Integer> arr, int target) {\\n        int left = 0;\\n        int right = arr.size();\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr.get(mid) < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }  \\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        std::unordered_map<int, std::map<int, int>> dp;\\n        dp[-1][-INT_MAX] = 1;\\n        std::vector<int> sortedNums;\\n\\n        for (int num : nums) {\\n            int insertIndex = bisectLeft(sortedNums, num);\\n            if (insertIndex == sortedNums.size()) {\\n                sortedNums.push_back(num);\\n            } else {\\n                sortedNums[insertIndex] = num;\\n            }\\n\\n            int total = 0;\\n            for (const auto& entry : dp[insertIndex - 1]) {\\n                int prevNum = entry.first;\\n                int count = entry.second;\\n                if (prevNum < num) {\\n                    total += count;\\n                }\\n            }\\n            dp[insertIndex][num] += total;\\n        }\\n\\n        int result = 0;\\n        for (const auto& entry : dp[sortedNums.size() - 1]) {\\n            result += entry.second;\\n        }\\n        return result;        \\n    }\\n\\nprivate:\\n    int bisectLeft(const std::vector<int>& arr, int target) {\\n        int left = 0;\\n        int right = arr.size();\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795913,
                "title": "0-1-knapsack-dp-memoization-java-clean-code",
                "content": "# Approach\\nSubsequence problems can be done by pick or not-pick approach. I found everyone solving it using tabulation so I gave memoiation a try. It worked. Do upvote if you understood.\\n\\n# Complexity\\n- Time complexity: $$O(n * n)$$ (Recursion)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * n * 2)$$ (DP) + $$O(n)$$ (Stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private record Pair(int length, int count) {}\\n    private int n;\\n    private Pair[][] dp;\\n\\n    public int findNumberOfLIS(int[] nums) {\\n        n = nums.length;\\n        dp = new Pair[n][n+1];\\n        return solve(0, -1, nums).count();\\n    }\\n\\n    private Pair solve(int idx, int prev, int[] nums) {\\n        if(idx == n) return new Pair(0, 1);\\n        if(dp[idx][prev + 1] != null) return dp[idx][prev + 1];\\n        Pair notPick = solve(idx + 1, prev, nums);\\n        int notPickLen = notPick.length();\\n        int notPickCount = notPick.count();\\n        int pickLen = 0;\\n        int pickCount = 0;\\n        if(prev == -1 || nums[idx] > nums[prev]) {\\n            Pair pick = solve(idx + 1, idx, nums);\\n            pickLen = pick.length() + 1;\\n            pickCount = pick.count();\\n        }\\n        Pair res = null;\\n        if(pickLen == notPickLen) {\\n            res = new Pair(pickLen, pickCount + notPickCount);\\n        }\\n        else if(pickLen > notPickLen) {\\n            res = new Pair(pickLen, pickCount);\\n        }\\n        else {\\n            res = new Pair(notPickLen, notPickCount);\\n        }\\n        return dp[idx][prev + 1] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private record Pair(int length, int count) {}\\n    private int n;\\n    private Pair[][] dp;\\n\\n    public int findNumberOfLIS(int[] nums) {\\n        n = nums.length;\\n        dp = new Pair[n][n+1];\\n        return solve(0, -1, nums).count();\\n    }\\n\\n    private Pair solve(int idx, int prev, int[] nums) {\\n        if(idx == n) return new Pair(0, 1);\\n        if(dp[idx][prev + 1] != null) return dp[idx][prev + 1];\\n        Pair notPick = solve(idx + 1, prev, nums);\\n        int notPickLen = notPick.length();\\n        int notPickCount = notPick.count();\\n        int pickLen = 0;\\n        int pickCount = 0;\\n        if(prev == -1 || nums[idx] > nums[prev]) {\\n            Pair pick = solve(idx + 1, idx, nums);\\n            pickLen = pick.length() + 1;\\n            pickCount = pick.count();\\n        }\\n        Pair res = null;\\n        if(pickLen == notPickLen) {\\n            res = new Pair(pickLen, pickCount + notPickCount);\\n        }\\n        else if(pickLen > notPickLen) {\\n            res = new Pair(pickLen, pickCount);\\n        }\\n        else {\\n            res = new Pair(notPickLen, notPickCount);\\n        }\\n        return dp[idx][prev + 1] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795332,
                "title": "c-easy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every index store the longest subsequence & also the count of all ways to reach that index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGo to every index (1st loop) and look for the longest subsequence from the start (2nd loop). Check for the strictly increasing number and store the longest count (up until that index) in dp. (Every time we get a better length, increase the dp count by 1) And in count, store number of ways to reach that count (this shows number of subsequences can be formed). Keep track of the longest subsequence and update it and store the total number in your answer and return.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1);\\n        vector<int> count(n, 1);\\n        int maxLen = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n                maxLen = max(maxLen, dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLen) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1);\\n        vector<int> count(n, 1);\\n        int maxLen = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j] + 1 > dp[i]) {\\n                        dp[i] = dp[j] + 1;\\n                        count[i] = count[j];\\n                    } else if (dp[j] + 1 == dp[i]) {\\n                        count[i] += count[j];\\n                    }\\n                }\\n                maxLen = max(maxLen, dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == maxLen) {\\n                ans += count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008255,
                "title": "simple-java-solution-using-lis-logic-with-comments",
                "content": "Can refer for classic lis ->\\nhttps://leetcode.com/problems/longest-increasing-subsequence/solutions/1778046/detailed-java-solution-from-brute-force-to-iterative-with-explaination/\\n\\nFor this problem ->\\ndp[i]: the length of the Longest Increasing Subsequence which ends with nums[i].\\ndp array will work as similar to lis.\\n\\ncount[i]: the number of the Longest Increasing Subsequence which ends with nums[i].\\n\\nmaxLength will hold overall length of the Longest Increasing Subsequence.\\n\\nIdea is to prepare count array side by side and at last once both loop finishes, we have maxLength ready. just count the values present at ith index which has maxLength in dp array.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        int[] count = new int[nums.length];\\n        int maxLength=0;\\n        for(int i=0;i<nums.length;i++) {\\n            dp[i]=1;\\n            count[i]=1;\\n            for(int j=0;j<i;j++) {\\n                if(nums[i]>nums[j]) {\\n                    //if current element can be added to dp array.\\n                    if(dp[i]<dp[j]+1) {\\n                        dp[i]=dp[j]+1;\\n                        //count is copied directly bcz, it is creating new sequence by adding jth element. and hence whatever the count of lis j has, now i will also has\\n                        count[i]=count[j];\\n                    } else if(dp[i]==dp[j]+1) {\\n                        //it means same length lis found again. hence update count wih total occurence of jth element.\\n                        count[i]+=count[j];\\n                    } \\n                }\\n            }\\n            //hold overall max length lis\\n            maxLength=Math.max(maxLength,dp[i]);\\n        }\\n    //once we have maxLength ready. we can check which indexes has same max length. and just add count of such indexes.\\n        int ans=0;\\n        for(int i=0;i<dp.length;i++) {\\n            if(dp[i]==maxLength) {\\n                ans+=count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nCan refer below video for detail explaination ->\\n\\nhttps://www.youtube.com/watch?v=cKVl1TFdNXg",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        int[] count = new int[nums.length];\\n        int maxLength=0;\\n        for(int i=0;i<nums.length;i++) {\\n            dp[i]=1;\\n            count[i]=1;\\n            for(int j=0;j<i;j++) {\\n                if(nums[i]>nums[j]) {\\n                    //if current element can be added to dp array.\\n                    if(dp[i]<dp[j]+1) {\\n                        dp[i]=dp[j]+1;\\n                        //count is copied directly bcz, it is creating new sequence by adding jth element. and hence whatever the count of lis j has, now i will also has\\n                        count[i]=count[j];\\n                    } else if(dp[i]==dp[j]+1) {\\n                        //it means same length lis found again. hence update count wih total occurence of jth element.\\n                        count[i]+=count[j];\\n                    } \\n                }\\n            }\\n            //hold overall max length lis\\n            maxLength=Math.max(maxLength,dp[i]);\\n        }\\n    //once we have maxLength ready. we can check which indexes has same max length. and just add count of such indexes.\\n        int ans=0;\\n        for(int i=0;i<dp.length;i++) {\\n            if(dp[i]==maxLength) {\\n                ans+=count[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182375,
                "title": "detailed-line-by-line-explanation-with-comments-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    public:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size(); //finding the size of nums\\n        \\n        if(n <= 1) return n; //less than one length return n\\n        \\n        vector<int> dp(n+1, 1); //will count the length of the LIS till the current index\\n        vector<int> cnt(n+1, 1);// number of LIS till this index\\n        \\n        dp[0] = 1; //the length can be only 1 until the first element obviously\\n        int maxLen = 1; //maximum length will start at 1\\n        \\n        for(int i = 1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n        \\n                if(nums[j] < nums[i]) //from j to i is an increasing subsequence\\n                {\\n                    if(dp[j] == dp[i]) //lenght of lis ill j is same as length of lis till i as of yet\\n                    {\\n                        \\n                        dp[i] = dp[j] + 1; //this is one length extra since i is a new element now included in the lis uptill j to becoome lis till i\\n                        cnt[i] = cnt[j];\\n                        //the lis till j will be same as lis till i as this is not a new lis but an extension of lis till j, a new element is added in the same lis\\n                    }\\n                    else if (dp[j] + 1 == dp[i])\\n                    {\\n                        cnt[i] += cnt[j];\\n                        //all this lis till j will now be lis till i since this is a new lis not just an addition to previous lis, the lis uptill i wasof some length from some other jth element, this is another addition to the same lis\\n                    }                      \\n                }\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n;i++){\\n            if(dp[i] == maxLen) ans+= cnt[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    public:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size(); //finding the size of nums\\n        \\n        if(n <= 1) return n; //less than one length return n\\n        \\n        vector<int> dp(n+1, 1); //will count the length of the LIS till the current index\\n        vector<int> cnt(n+1, 1);// number of LIS till this index\\n        \\n        dp[0] = 1; //the length can be only 1 until the first element obviously\\n        int maxLen = 1; //maximum length will start at 1\\n        \\n        for(int i = 1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n        \\n                if(nums[j] < nums[i]) //from j to i is an increasing subsequence\\n                {\\n                    if(dp[j] == dp[i]) //lenght of lis ill j is same as length of lis till i as of yet\\n                    {\\n                        \\n                        dp[i] = dp[j] + 1; //this is one length extra since i is a new element now included in the lis uptill j to becoome lis till i\\n                        cnt[i] = cnt[j];\\n                        //the lis till j will be same as lis till i as this is not a new lis but an extension of lis till j, a new element is added in the same lis\\n                    }\\n                    else if (dp[j] + 1 == dp[i])\\n                    {\\n                        cnt[i] += cnt[j];\\n                        //all this lis till j will now be lis till i since this is a new lis not just an addition to previous lis, the lis uptill i wasof some length from some other jth element, this is another addition to the same lis\\n                    }                      \\n                }\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n;i++){\\n            if(dp[i] == maxLen) ans+= cnt[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397031,
                "title": "intuitive-o-n-2-dp-solution-w-detailed-comments",
                "content": "```py\\nclass Solution:\\n    # well-commented version, study it \\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\n        len_ = len(nums)\\n\\n        # lens[i]: record the length of LIS (might not be the global longest one)\\n        # that ends at nums[i]\\n        lens = [1] * len_\\n\\n        # counts[i]: record the number of LIS (whose length is lens[i]) that ends\\n        # at nums[i]\\n        counts = [1] * len_\\n\\n        # keep track of length of global LIS\\n        max_lis_len = 1\\n        # keep track of number of such global LIS\\n        count = 1\\n\\n        for i in range(1, len_):\\n            curr = nums[i]\\n            # total: number of LIS ending at nums[i] seen so far\\n            # l: length of LIS ending at nums[i] seen so far\\n            total, l = 0, 0\\n            # go to check all values before current value\\n            for j in range(i):\\n                prev = nums[j]\\n\\n                # in case previous value >= current value, no IS can be formed\\n                if prev >= curr:\\n                    continue\\n\\n                # in case current IS\\'s length > length of LIS seen so far\\n                if lens[j] + 1 > l:\\n                    l = lens[j] + 1\\n                    total = counts[j]\\n\\n                # in case current IS\\'s length == length of LIS seen so far\\n                elif lens[j] + 1 == l:\\n                    total += counts[j]\\n\\n            # update lens[i] and counts[i]\\n            lens[i] = max(1, l)\\n            counts[i] = max(1, total)\\n\\n            # update global LIS and count\\n            if lens[i] > max_lis_len:\\n                max_lis_len = lens[i]\\n                count = counts[i]\\n            elif lens[i] == max_lis_len:\\n                count += counts[i]\\n\\n        return count\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    # well-commented version, study it \\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\n        len_ = len(nums)\\n\\n        # lens[i]: record the length of LIS (might not be the global longest one)\\n        # that ends at nums[i]\\n        lens = [1] * len_\\n\\n        # counts[i]: record the number of LIS (whose length is lens[i]) that ends\\n        # at nums[i]\\n        counts = [1] * len_\\n\\n        # keep track of length of global LIS\\n        max_lis_len = 1\\n        # keep track of number of such global LIS\\n        count = 1\\n\\n        for i in range(1, len_):\\n            curr = nums[i]\\n            # total: number of LIS ending at nums[i] seen so far\\n            # l: length of LIS ending at nums[i] seen so far\\n            total, l = 0, 0\\n            # go to check all values before current value\\n            for j in range(i):\\n                prev = nums[j]\\n\\n                # in case previous value >= current value, no IS can be formed\\n                if prev >= curr:\\n                    continue\\n\\n                # in case current IS\\'s length > length of LIS seen so far\\n                if lens[j] + 1 > l:\\n                    l = lens[j] + 1\\n                    total = counts[j]\\n\\n                # in case current IS\\'s length == length of LIS seen so far\\n                elif lens[j] + 1 == l:\\n                    total += counts[j]\\n\\n            # update lens[i] and counts[i]\\n            lens[i] = max(1, l)\\n            counts[i] = max(1, total)\\n\\n            # update global LIS and count\\n            if lens[i] > max_lis_len:\\n                max_lis_len = lens[i]\\n                count = counts[i]\\n            elif lens[i] == max_lis_len:\\n                count += counts[i]\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107307,
                "title": "python-dp-segment-tree-o-nlogn",
                "content": "First, calculate the length of LIS endswith index i, we call it dp[n].\\ndp[i]  = max{dp[j]} + 1 where j < i and a[j] < a[i]. We can use a segment tree to make dp transfer faster.\\nMoreover, for counting job, we just save it in segment tree, so we can solve the problem in O(nlogn) time-complexity.\\n```\\ndef merge(x, y):\\n    if x[0] == y[0]:\\n        if x[0] == 0:\\n            return (0, 1)\\n        return (x[0], x[1] + y[1])\\n    return max(x, y)\\n\\nclass TreeNode(object):\\n    def __init__(self, start, end):\\n        self.left = start\\n        self.right = end\\n        self._lchild = self._rchild = None\\n        self.max_val = 0\\n        self.max_cnt = 1\\n    def push_up(self):\\n        self.val_tuple = merge(self.lchild.val_tuple, self.rchild.val_tuple)\\n    @property\\n    def mid(self):\\n        return (self.left + self.right) / 2\\n    @property\\n    def val_tuple(self):\\n        return (self.max_val, self.max_cnt)\\n    @val_tuple.setter\\n    def val_tuple(self, val):\\n        self.max_val, self.max_cnt = val\\n    @property\\n    def lchild(self):\\n        if not self._lchild:\\n            self._lchild = TreeNode(self.left, self.mid)\\n        return self._lchild\\n    @property\\n    def rchild(self):\\n        if not self._rchild:\\n            self._rchild = TreeNode(self.mid + 1, self.right)\\n        return self._rchild\\nclass SegmentTree(object):\\n    def __init__(self, start, end):\\n        self.root = TreeNode(start, end)\\n\\n    def query(self, key, cur):\\n        if cur.right <= key:\\n            return cur.val_tuple\\n        elif cur.left > key:\\n            return (0, 1)\\n        else:\\n            return merge(self.query(key, cur.lchild), self.query(key, cur.rchild))\\n\\n    def insert(self, key, val, val_cnt, cur):\\n        if cur.left == cur.right:\\n            cur.val_tuple = merge((val, val_cnt), cur.val_tuple)\\n            return\\n        if key <= cur.mid:\\n            self.insert(key, val, val_cnt, cur.lchild)\\n        else:\\n            self.insert(key, val, val_cnt, cur.rchild)\\n        cur.push_up()\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        st = SegmentTree(min(nums), max(nums))\\n        for num in nums:\\n            res = st.query(num - 1, st.root)\\n            st.insert(num, res[0] + 1, res[1], st.root)\\n        return st.root.max_cnt\\n```",
                "solutionTags": [],
                "code": "```\\ndef merge(x, y):\\n    if x[0] == y[0]:\\n        if x[0] == 0:\\n            return (0, 1)\\n        return (x[0], x[1] + y[1])\\n    return max(x, y)\\n\\nclass TreeNode(object):\\n    def __init__(self, start, end):\\n        self.left = start\\n        self.right = end\\n        self._lchild = self._rchild = None\\n        self.max_val = 0\\n        self.max_cnt = 1\\n    def push_up(self):\\n        self.val_tuple = merge(self.lchild.val_tuple, self.rchild.val_tuple)\\n    @property\\n    def mid(self):\\n        return (self.left + self.right) / 2\\n    @property\\n    def val_tuple(self):\\n        return (self.max_val, self.max_cnt)\\n    @val_tuple.setter\\n    def val_tuple(self, val):\\n        self.max_val, self.max_cnt = val\\n    @property\\n    def lchild(self):\\n        if not self._lchild:\\n            self._lchild = TreeNode(self.left, self.mid)\\n        return self._lchild\\n    @property\\n    def rchild(self):\\n        if not self._rchild:\\n            self._rchild = TreeNode(self.mid + 1, self.right)\\n        return self._rchild\\nclass SegmentTree(object):\\n    def __init__(self, start, end):\\n        self.root = TreeNode(start, end)\\n\\n    def query(self, key, cur):\\n        if cur.right <= key:\\n            return cur.val_tuple\\n        elif cur.left > key:\\n            return (0, 1)\\n        else:\\n            return merge(self.query(key, cur.lchild), self.query(key, cur.rchild))\\n\\n    def insert(self, key, val, val_cnt, cur):\\n        if cur.left == cur.right:\\n            cur.val_tuple = merge((val, val_cnt), cur.val_tuple)\\n            return\\n        if key <= cur.mid:\\n            self.insert(key, val, val_cnt, cur.lchild)\\n        else:\\n            self.insert(key, val, val_cnt, cur.rchild)\\n        cur.push_up()\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        st = SegmentTree(min(nums), max(nums))\\n        for num in nums:\\n            res = st.query(num - 1, st.root)\\n            st.insert(num, res[0] + 1, res[1], st.root)\\n        return st.root.max_cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794904,
                "title": "simple-dp-solution-c-o-n-2",
                "content": "# Intution\\nWe can see that this is a subsequence question, and there are 2^n subsequences in an array, and here according to constraints, we have to do it in O(n^2), So DP is the way to think towards.\\n# Approach\\nNow Here in my answer with each ```dp[i] pair```, in the ```first``` value I stored the ```longest subsequence length ending at ith index```, and in ```second``` value I stored the ```freq of subsequences with dp[i].first length(basically the longest)``` and ending at ith index.\\nAn unordered map is used to store all the relevant required subsequences frequency. We keep track of the longest subsequence length also.\\nIn the end just ```return the longest subsequence length from the map```. Easy.\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int max_seq = 1;\\n        unordered_map<int,int> mp;\\n        vector<pair<int,int>> dp(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int sub_ans = 0; //longest subsequence ending at i index\\n            int f = 1; // freq of the longest subsequences ending at i index\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]){\\n                    if(sub_ans<dp[j].first){\\n                        sub_ans = dp[j].first;\\n                        f = dp[j].second; \\n                    }\\n                    else if(sub_ans==dp[j].first) f+=dp[j].second;\\n                }\\n            }\\n            dp[i] = {1+sub_ans,f};\\n            mp[dp[i].first] += f; //adding the relevant freq in map\\n            max_seq = max(max_seq,dp[i].first);\\n        }\\n        return mp[max_seq];\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please upvote for your continuous support \\uD83D\\uDE0A. If you have any doubt feel free to comment down below, I will try my best to reply and explain. Thank you for reading my answer.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```dp[i] pair```\n```first```\n```longest subsequence length ending at ith index```\n```second```\n```freq of subsequences with dp[i].first length(basically the longest)```\n```return the longest subsequence length from the map```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int max_seq = 1;\\n        unordered_map<int,int> mp;\\n        vector<pair<int,int>> dp(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int sub_ans = 0; //longest subsequence ending at i index\\n            int f = 1; // freq of the longest subsequences ending at i index\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]){\\n                    if(sub_ans<dp[j].first){\\n                        sub_ans = dp[j].first;\\n                        f = dp[j].second; \\n                    }\\n                    else if(sub_ans==dp[j].first) f+=dp[j].second;\\n                }\\n            }\\n            dp[i] = {1+sub_ans,f};\\n            mp[dp[i].first] += f; //adding the relevant freq in map\\n            max_seq = max(max_seq,dp[i].first);\\n        }\\n        return mp[max_seq];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794877,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[1]*n\\n        count=[1]*n\\n        for i in range(1,n):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    if 1+dp[j]>dp[i]:\\n                        dp[i]=dp[j]+1\\n\\n                        count[i]=count[j]\\n\\n                    elif dp[j]+1==dp[i]:\\n                        count[i]+=count[j]\\n        longest_len=max(dp)\\n        return sum([count[i] for i in range(n) if dp[i]==longest_len])                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[1]*n\\n        count=[1]*n\\n        for i in range(1,n):\\n            for j in range(i):\\n                if nums[i]>nums[j]:\\n                    if 1+dp[j]>dp[i]:\\n                        dp[i]=dp[j]+1\\n\\n                        count[i]=count[j]\\n\\n                    elif dp[j]+1==dp[i]:\\n                        count[i]+=count[j]\\n        longest_len=max(dp)\\n        return sum([count[i] for i in range(n) if dp[i]==longest_len])                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794797,
                "title": "c-o-n-2-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& a) {\\n        int n=a.size();\\n        \\n        vector<int> dp(n,1), count(n,1);\\n        int max_len=0;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(a[i]>a[j]){\\n                    if(dp[i]<1+dp[j]){ // longer subsequence is possible than just inc in 1 by addition of a[i]\\n                        count[i]=count[j]; // becoming part of this new subsequence\\n                    }else if(dp[i]==1+dp[j]){\\n                        count[i]+=count[j]; // summing up all possible subequences ending at a[i] with same length\\n                    }\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            max_len=max(max_len,dp[i]);\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==max_len) c += count[i];\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& a) {\\n        int n=a.size();\\n        \\n        vector<int> dp(n,1), count(n,1);\\n        int max_len=0;\\n\\t\\t\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(a[i]>a[j]){\\n                    if(dp[i]<1+dp[j]){ // longer subsequence is possible than just inc in 1 by addition of a[i]\\n                        count[i]=count[j]; // becoming part of this new subsequence\\n                    }else if(dp[i]==1+dp[j]){\\n                        count[i]+=count[j]; // summing up all possible subequences ending at a[i] with same length\\n                    }\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            max_len=max(max_len,dp[i]);\\n        }\\n        \\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==max_len) c += count[i];\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197544,
                "title": "c-easy-solution-dynamic-programming",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n,1),c(n,1);\\n        int maxi=1;\\n        // sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            for(int prev=0;prev<i;prev++){\\n                if(arr[i]>arr[prev] && dp[i]<1+dp[prev]){\\n                    dp[i]=1+dp[prev];\\n                    c[i]=c[prev];\\n                }\\n                else if(dp[i]==(1+dp[prev])){\\n                    c[i]+=c[prev];\\n                }\\n            }\\n            if(maxi<dp[i]){\\n                    maxi=dp[i];\\n                }\\n            // cout<<dp[i]<<\" \";\\n        }\\n        // cout<<endl;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==maxi) \\n            res+=c[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n,1),c(n,1);\\n        int maxi=1;\\n        // sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            for(int prev=0;prev<i;prev++){\\n                if(arr[i]>arr[prev] && dp[i]<1+dp[prev]){\\n                    dp[i]=1+dp[prev];\\n                    c[i]=c[prev];\\n                }\\n                else if(dp[i]==(1+dp[prev])){\\n                    c[i]+=c[prev];\\n                }\\n            }\\n            if(maxi<dp[i]){\\n                    maxi=dp[i];\\n                }\\n            // cout<<dp[i]<<\" \";\\n        }\\n        // cout<<endl;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==maxi) \\n            res+=c[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2805203,
                "title": "dfs-different-approach-dp-o-n-2-simple",
                "content": "\\nRuntime: 150 ms, faster than 92.49% of C++ online submissions for Number of Longest Increasing Subsequence.\\n# *Intuition:*\\n\\n**Finding LIS:**\\nFirst of all we need to find the LIS of the given array. For that need to iterate from left to right.\\nLets Take a number (suppose index i ). As we are trying to find Longest Strictly increasing Subsequence, we will try to place our number after every number from index 0 to i-1 which is less than our current number.Then we choose the index which gives us the longest chain of number and store that number in that particular index and the path in the Route vector.\\n\\n**EXAMPLE:**\\n\\n**nums = [1,3,5,4,7]**\\n**dp = [0,0,0,0,0]**\\n**Route vector:\\n0- >\\n1 ->\\n2 ->\\n3 ->\\n4 ->**\\n\\n1. We take 1, as it is the first number we can\\'t put it after any number. So, we put value = 1 in 0th index.\\n **nums = [1,3,5,4,7]**\\n **dp = [1,0,0,0,0]**\\n **Route vector (Index -> Path):\\n0- >\\n1 ->\\n2 ->\\n3 ->\\n4 ->**\\n \\n2. We take 3. As 3 is greater than 1, we can place it after 1. So, our value of **1st index = 0th index + 1 = 2** and we **push 0 in the 1st index** of the Route vector because this is our desired path to current LIS.\\n **dp = [1,2,0,0,0]**\\n **nums = [1,3,5,4,7]**\\n **Route vector (Index -> Path):\\n0- >\\n1 -> 0\\n2 ->\\n3 ->\\n4 ->**\\n \\n3. We take 5 and try to place after 3. As 3<5 we can place it and our value of **2nd index = 1st index + 1 = 3** and** push 1 in the 2nd index** of the Route vector. Now we try to place it before 1. As 1<5, we can place it their and our value will become **0th index + 1 = 2** . As we already have value = 3 in our current index, we will not take the new value.\\n**dp = [1,2,3,0,0]**\\n**nums = [1,3,5,4,7]**\\n**Route vector (Index -> Path):\\n0- >\\n1 ->0\\n2 ->1\\n3 ->\\n4 ->**\\n\\n 4. We take 4 and try to place it after 5. As 5>4 we can\\'t place it here. \\nThen we take 3. As 3<4, we can place it here and the new value becomes **1st index + 1 = 2+1 = 3** and we **push 1 in the 3rd index** of the Route vector.\\n Then we take 1. As 1 < 4 we can place it here and the new value will be = 1+1 = 2. As we already have value = 3, we won\\'t take anything smaller than our current value.\\n**dp = [1,2,3,3,0]**\\n**nums = [1,3,5,4,7]**\\n**Route vector (Index -> Path):\\n0- >\\n1 ->0\\n2 ->1\\n3 ->1\\n4 ->**\\n \\n5. We take 7 and try to place it after 4. As 4<7 we can place it here and the new value becomes **3rd index + 1 = 3+1 = 4** and we **push 3 in the 4th index** of the Route vector. \\nThen we take 5 and as 5<7 we can place our number after it and the value becomes **2nd index + 1 = 3+1 = 4.** As our **curr value = new found value** so we won\\'t be updating our answer but we will **push 2 in in the 4th index** of our Route vector. After that we take 3 , 1 one by one but none of them will give us greater or equal value compare to our current value.\\n**dp = [1,2,3,3,4]**\\n**nums = [1,3,5,4,7]**\\n**Route vector (Index -> Path):\\n0- >\\n1 ->0\\n2 ->1\\n3 ->1\\n4 -> 3 -> 2**\\n\\n\\n**DFS:**\\n\\nNow from our dp array we know that, our LIS is 4. So will iterate through our dp array and if we find any LIS value = 4 , we can certain say that a **Longest strictly increasing subsequence ends here**. So, as we already created a graph using our **route vector**, we can start a dfs taking the **index value of dp as a root**.\\n\\n![image](https://assets.leetcode.com/users/images/57f1d9c5-f734-40cd-bc53-bf752c71494c_1668220623.598379.png)\\n\\nAs running a dfs will be time consuming, we will be storing (**memoization**) the value of the subtree in a array named SAVE. Using this save array, we won\\'t have to go through the same subtree again. The code will provide a better and clear view.\\n\\n# CODE (C++):\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int>Route_vector[2002];\\n    \\n    int save[2003];\\n    int dfs(int x){\\n        if(Route_vector[x].size() == 0) // We cant go any further, so thats a complete path\\n            return 1;\\n        \\n        if(save[x]!=0) // We already went through this subPath earlier, so we saved it\\n            return save[x];\\n        \\n        for(int i=0;i<Route_vector[x].size();i++)\\n            save[x]+=dfs(Route_vector[x][i]); \\n        return save[x];\\n    }\\n    \\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        int ans = 0;\\n     \\n        for(int i=0;i<n;i++){\\n            dp[i] = 1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]) // We found a number which is less than our choosen number\\n                {\\n                    if(dp[i] == dp[j]+1) // If our current dp[] value is equal to new value, we will just update our path\\n                        Route_vector[i].push_back(j);\\n                    \\n                    else if(dp[j]+1>dp[i]){ // If our current dp[] value is less than new value, we erase our path and start a new path\\n                        dp[i] = dp[j]+1;\\n                        Route_vector[i].clear();\\n                        Route_vector[i].push_back(j);\\n                    }\\n                }    \\n            }\\n            ans = max(ans,dp[i]); // Keeping track of the maximum LIS length\\n        }\\n        int res = 0;\\n        for(int i=0;i<n;i++)\\n            if(dp[i] == ans) // we will run dfs and take iTH index as a root if dp[i] = longest LIS\\n                res+=dfs(i);\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>Route_vector[2002];\\n    \\n    int save[2003];\\n    int dfs(int x){\\n        if(Route_vector[x].size() == 0) // We cant go any further, so thats a complete path\\n            return 1;\\n        \\n        if(save[x]!=0) // We already went through this subPath earlier, so we saved it\\n            return save[x];\\n        \\n        for(int i=0;i<Route_vector[x].size();i++)\\n            save[x]+=dfs(Route_vector[x][i]); \\n        return save[x];\\n    }\\n    \\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        int ans = 0;\\n     \\n        for(int i=0;i<n;i++){\\n            dp[i] = 1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]) // We found a number which is less than our choosen number\\n                {\\n                    if(dp[i] == dp[j]+1) // If our current dp[] value is equal to new value, we will just update our path\\n                        Route_vector[i].push_back(j);\\n                    \\n                    else if(dp[j]+1>dp[i]){ // If our current dp[] value is less than new value, we erase our path and start a new path\\n                        dp[i] = dp[j]+1;\\n                        Route_vector[i].clear();\\n                        Route_vector[i].push_back(j);\\n                    }\\n                }    \\n            }\\n            ans = max(ans,dp[i]); // Keeping track of the maximum LIS length\\n        }\\n        int res = 0;\\n        for(int i=0;i<n;i++)\\n            if(dp[i] == ans) // we will run dfs and take iTH index as a root if dp[i] = longest LIS\\n                res+=dfs(i);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779914,
                "title": "pure-recursion-java-need-to-write-dp-based-for-this",
                "content": "Intution here is for every number you can have 2 choices\\n1) Select it and increase your count\\n2) ignore the current number\\n\\nso basically your solution comes to \\nrecusrion(len+1, i+1) --> decided to select the current number and increase the length by 1\\nrecursion(len, i+1) --> decided to ignore the current number, so length wont increase.\\n\\nHowever the trick here is, we dont need the max length. Instead we want number of possible max lengths. so store the lengths in an array every time. so we will get counts of each length  \\n\\n``` public static int findNumberOfLIS(int[] nums) {\\n    int[] count = new int[nums.length + 1];\\n    recursion(nums, 0, Integer.MIN_VALUE, count, 0);\\n\\t// once we found counts for all the possible lengths, return the maximum length count\\n    for (int i = count.length - 1; i >= 0; i--) {\\n      if (count[i] > 0) return count[i];\\n    }\\n    return 0;\\n  }\\n\\n  static void recursion(int[] nums, int i, int curMax, int[] count, int ans) {\\n  // exit condition also store the length count\\n    if (i >= nums.length) {\\n      count[ans] = count[ans] + 1;\\n      return;\\n    }\\n\\t// if your value is greater than prevoius value continue with ans++\\n    if (curMax < nums[i]) {\\n      recursion(nums, i + 1, nums[i], count, ans + 1);\\n    }\\n\\t//just continue with prevoius values\\n    recursion(nums, i + 1, curMax, count, ans);\\n  }\\n  ```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` public static int findNumberOfLIS(int[] nums) {\\n    int[] count = new int[nums.length + 1];\\n    recursion(nums, 0, Integer.MIN_VALUE, count, 0);\\n\\t// once we found counts for all the possible lengths, return the maximum length count\\n    for (int i = count.length - 1; i >= 0; i--) {\\n      if (count[i] > 0) return count[i];\\n    }\\n    return 0;\\n  }\\n\\n  static void recursion(int[] nums, int i, int curMax, int[] count, int ans) {\\n  // exit condition also store the length count\\n    if (i >= nums.length) {\\n      count[ans] = count[ans] + 1;\\n      return;\\n    }\\n\\t// if your value is greater than prevoius value continue with ans++\\n    if (curMax < nums[i]) {\\n      recursion(nums, i + 1, nums[i], count, ans + 1);\\n    }\\n\\t//just continue with prevoius values\\n    recursion(nums, i + 1, curMax, count, ans);\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1779673,
                "title": "python-dp-o-n-2",
                "content": "Use tuple to keep track of (length, number of subsequences).\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        record = [(1,1)]*len(nums)\\n\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[j]<nums[i]:\\n                    if record[j][0]+1 > record[i][0]:\\n                        record[i] = (record[j][0]+1, record[j][1])\\n                    elif record[j][0]+1 == record[i][0]:\\n                        record[i] = (record[i][0], record[j][1]+record[i][1])\\n        \\n        longest = max(length for length, _ in record)\\n        longest_count = 0\\n        for length, count in record:\\n            if length==longest:\\n                longest_count += count\\n        return longest_count\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        record = [(1,1)]*len(nums)\\n\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[j]<nums[i]:\\n                    if record[j][0]+1 > record[i][0]:\\n                        record[i] = (record[j][0]+1, record[j][1])\\n                    elif record[j][0]+1 == record[i][0]:\\n                        record[i] = (record[i][0], record[j][1]+record[i][1])\\n        \\n        longest = max(length for length, _ in record)\\n        longest_count = 0\\n        for length, count in record:\\n            if length==longest:\\n                longest_count += count\\n        return longest_count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516922,
                "title": "python-dp-solution-with-explanation-and-execution-examples",
                "content": "Python Solution\\n```\\nclass Solution:\\n    \"\"\"\\n    Longest Increasing Subsequence: LIS\\n    \"\"\"\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        ls = len(nums)\\n        \\n        # length, count: record lengths and counts of LIS ending at index i inclusive\\n        length, count = [1] * ls, [1] * ls\\n        \\n        # scan each number where IS ending at nums[i]\\n        for i in range(ls):\\n            # for each number before nums[i]\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    # nums[j] can add to IS ending at nums[i]\\n                    \\n                    # case 1. nums[j] makes it longer to IS ending at nums[i]\\n                    if length[j] + 1 > length[i]:\\n                        length[i], count[i] = length[j] + 1, count[j]\\n                     \\n                    # case 2. nums[j] adds some new paths of IS ending in nums[i]\\n                    elif length[j] + 1 == length[i]:\\n                        count[i] += count[j]\\n        max_length = max(length)\\n        \\n        return sum(cnt for l, cnt in zip(length, count) if l == max_length)\\n                        \\n```\\n\\nSee also these problems:\\n\\n435.\\xA0Non-overlapping Intervals\\n(https://leetcode.com/problems/non-overlapping-intervals/)\\n\\n300.\\xA0Longest Increasing Subsequence\\n(https://leetcode.com/problems/longest-increasing-subsequence/)\\n\\n646.\\xA0Maximum Length of Pair Chain\\n(https://leetcode.com/problems/maximum-length-of-pair-chain/)\\n\\n452.\\xA0Minimum Number of Arrows to Burst Balloons\\n(https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)\\n\\n\\n674.\\xA0Longest Continuous Increasing Subsequence [Easy]\\n(https://leetcode.com/problems/longest-continuous-increasing-subsequence/)\\n\\n\\n\\n673.\\xA0Number of Longest Increasing Subsequence\\n(https://leetcode.com/problems/number-of-longest-increasing-subsequence/)\\n\\n\\n\\nExecution Procedure:\\n```\\nnums = [1,3,5,4,7]\\n\\nIteration i = 0:\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 1:\\nSubiteration j = 0:\\ni=1 and j=0:\\nlength: [1, 2, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 2:\\nSubiteration j = 0:\\ni=2 and j=0:\\nlength: [1, 2, 2, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=2 and j=1:\\nlength: [1, 2, 3, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 3, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 3:\\nSubiteration j = 0:\\ni=3 and j=0:\\nlength: [1, 2, 3, 2, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=3 and j=1:\\nlength: [1, 2, 3, 3, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=3 and j=2:\\nlength: [1, 2, 3, 3, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 3, 3, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 4:\\nSubiteration j = 0:\\ni=4 and j=0:\\nlength: [1, 2, 3, 3, 2]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=4 and j=1:\\nlength: [1, 2, 3, 3, 3]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=4 and j=2:\\nlength: [1, 2, 3, 3, 4]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 3:\\ni=4 and j=3:\\nlength: [1, 2, 3, 3, 4]\\ncount: [1, 1, 1, 1, 2]\\nlength: [1, 2, 3, 3, 4]; count: [1, 1, 1, 1, 2]\\n\\n---\\n```\\n\\n```\\nIteration i = 0:\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 1:\\nSubiteration j = 0:\\ni=1 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 2:\\nSubiteration j = 0:\\ni=2 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=2 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 3:\\nSubiteration j = 0:\\ni=3 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=3 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=3 and j=2:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 4:\\nSubiteration j = 0:\\ni=4 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=4 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=4 and j=2:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 3:\\ni=4 and j=3:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Longest Increasing Subsequence: LIS\\n    \"\"\"\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        ls = len(nums)\\n        \\n        # length, count: record lengths and counts of LIS ending at index i inclusive\\n        length, count = [1] * ls, [1] * ls\\n        \\n        # scan each number where IS ending at nums[i]\\n        for i in range(ls):\\n            # for each number before nums[i]\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    # nums[j] can add to IS ending at nums[i]\\n                    \\n                    # case 1. nums[j] makes it longer to IS ending at nums[i]\\n                    if length[j] + 1 > length[i]:\\n                        length[i], count[i] = length[j] + 1, count[j]\\n                     \\n                    # case 2. nums[j] adds some new paths of IS ending in nums[i]\\n                    elif length[j] + 1 == length[i]:\\n                        count[i] += count[j]\\n        max_length = max(length)\\n        \\n        return sum(cnt for l, cnt in zip(length, count) if l == max_length)\\n                        \\n```\n```\\nnums = [1,3,5,4,7]\\n\\nIteration i = 0:\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 1:\\nSubiteration j = 0:\\ni=1 and j=0:\\nlength: [1, 2, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 2:\\nSubiteration j = 0:\\ni=2 and j=0:\\nlength: [1, 2, 2, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=2 and j=1:\\nlength: [1, 2, 3, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 3, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 3:\\nSubiteration j = 0:\\ni=3 and j=0:\\nlength: [1, 2, 3, 2, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=3 and j=1:\\nlength: [1, 2, 3, 3, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=3 and j=2:\\nlength: [1, 2, 3, 3, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 2, 3, 3, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 4:\\nSubiteration j = 0:\\ni=4 and j=0:\\nlength: [1, 2, 3, 3, 2]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=4 and j=1:\\nlength: [1, 2, 3, 3, 3]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=4 and j=2:\\nlength: [1, 2, 3, 3, 4]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 3:\\ni=4 and j=3:\\nlength: [1, 2, 3, 3, 4]\\ncount: [1, 1, 1, 1, 2]\\nlength: [1, 2, 3, 3, 4]; count: [1, 1, 1, 1, 2]\\n\\n---\\n```\n```\\nIteration i = 0:\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 1:\\nSubiteration j = 0:\\ni=1 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 2:\\nSubiteration j = 0:\\ni=2 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=2 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 3:\\nSubiteration j = 0:\\ni=3 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=3 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=3 and j=2:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\nIteration i = 4:\\nSubiteration j = 0:\\ni=4 and j=0:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 1:\\ni=4 and j=1:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 2:\\ni=4 and j=2:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nSubiteration j = 3:\\ni=4 and j=3:\\nlength: [1, 1, 1, 1, 1]\\ncount: [1, 1, 1, 1, 1]\\nlength: [1, 1, 1, 1, 1]; count: [1, 1, 1, 1, 1]\\n\\n---\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230585,
                "title": "c-easy-dp",
                "content": "116 ms\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n  \\n        int n=nums.size();   \\n        if(n == 0) return 0;       \\n        vector<int> length(n+1 ,1);\\n        vector<int> count(n +1,1);\\n        int maxlen = 1;\\n        \\n                \\n        for(int i= 1;i<n;i++)\\n        {\\n            for( int j = 0 ; j < i ; j++){\\n                \\n                if(nums[i] > nums[j]){   \\n                    \\n                    if(length[j]+1 > length[i]){ // adding one to j will improve the length    \\n                        length[i] = length[i]+1;  // length[i] = max (length[i],length[j]+1)  \\n                        count[i] = count[j];         \\n                    }\\n                    \\n                    //means we are ruuning a loop and some other value is also smaller than this i value \\n                    // so just inc the count as they are having the same length \\n                    // length is updated in the above once\\n                    // if same length appers again then we have to inc the count\\n                    else if(length[j]+1 == length[i]){ \\n                         count[i] += count[j];\\n                    }\\n                }\\n            }       \\n           maxlen = max(maxlen,length[i]);\\n        }\\n       int ans = 0;\\n     \\n\\n    for(int i = 0 ; i < n ; i++){\\n        if(length[i] == maxlen){\\n            ans+= count[i];     // How many have same max lengths\\n            \\n        }\\n    }\\n         return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n  \\n        int n=nums.size();   \\n        if(n == 0) return 0;       \\n        vector<int> length(n+1 ,1);\\n        vector<int> count(n +1,1);\\n        int maxlen = 1;\\n        \\n                \\n        for(int i= 1;i<n;i++)\\n        {\\n            for( int j = 0 ; j < i ; j++){\\n                \\n                if(nums[i] > nums[j]){   \\n                    \\n                    if(length[j]+1 > length[i]){ // adding one to j will improve the length    \\n                        length[i] = length[i]+1;  // length[i] = max (length[i],length[j]+1)  \\n                        count[i] = count[j];         \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1206526,
                "title": "easy-dp-js-solution",
                "content": "```\\nvar findNumberOfLIS = function(nums) {  \\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    // dp[i] is the length of longest increasing subsequence ending at index i\\n    let dp = new Array(nums.length);\\n    // freq[i] is the number of LISs ending at index i\\n    let freq = new Array(nums.length);\\n    for (let i = 0; i < nums.length; i++) {\\n        // Obtain length of LISs ending at i\\n        let lenOfLIS = 1;\\n        for (let j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                lenOfLIS = Math.max(lenOfLIS, dp[j] + 1);\\n            }\\n        }\\n        \\n        // Obtain number of LISs ending at i\\n        let freqAtI = 0\\n        for (let j = 0; j < i; j++) {\\n            if (nums[j] < nums[i] && dp[j] + 1 === lenOfLIS) {\\n                freqAtI += freq[j];\\n            }\\n        }\\n        \\n        // Record them to arrays\\n        dp[i] = lenOfLIS;\\n        freq[i] = freqAtI === 0 ? 1 : freqAtI;\\n    }\\n\\n    // Obtain the length of LIS out of all possible increasing sequences\\n    let maxLen = Math.max(...dp);\\n    \\n    // Obtain the total number of LISs\\n    let maxFreq = 0;\\n    for (let i = 0; i < dp.length; i++) {\\n        if (dp[i] === maxLen) {\\n            maxFreq += freq[i];\\n        }\\n    }\\n    return maxFreq;\\n    // T.C: O(N^2)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findNumberOfLIS = function(nums) {  \\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    // dp[i] is the length of longest increasing subsequence ending at index i\\n    let dp = new Array(nums.length);\\n    // freq[i] is the number of LISs ending at index i\\n    let freq = new Array(nums.length);\\n    for (let i = 0; i < nums.length; i++) {\\n        // Obtain length of LISs ending at i\\n        let lenOfLIS = 1;\\n        for (let j = 0; j < i; j++) {\\n            if (nums[j] < nums[i]) {\\n                lenOfLIS = Math.max(lenOfLIS, dp[j] + 1);\\n            }\\n        }\\n        \\n        // Obtain number of LISs ending at i\\n        let freqAtI = 0\\n        for (let j = 0; j < i; j++) {\\n            if (nums[j] < nums[i] && dp[j] + 1 === lenOfLIS) {\\n                freqAtI += freq[j];\\n            }\\n        }\\n        \\n        // Record them to arrays\\n        dp[i] = lenOfLIS;\\n        freq[i] = freqAtI === 0 ? 1 : freqAtI;\\n    }\\n\\n    // Obtain the length of LIS out of all possible increasing sequences\\n    let maxLen = Math.max(...dp);\\n    \\n    // Obtain the total number of LISs\\n    let maxFreq = 0;\\n    for (let i = 0; i < dp.length; i++) {\\n        if (dp[i] === maxLen) {\\n            maxFreq += freq[i];\\n        }\\n    }\\n    return maxFreq;\\n    // T.C: O(N^2)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1100297,
                "title": "c-dp-with-production-level-variable-naming-for-easier-understanding",
                "content": "This problem is an absolute monster, and I\\'m actually amazed I solved it because I\\'m horrible at DP so I\\'m insanely proud of this one.\\n\\nMost solutions in Leetcode have really non descriptive variable names which makes it tough to figure out what is happening (although granted everyone writing those solutions is absolutely brilliant, and I\\'m also nearly always guilty of this in LC). But after finishing the algorithm this time I rewrote it with proper variable naming so that if anyone does come across this post, there\\'s hopefully more clarity provided in the different relationships between variables and how the logic comes into place.\\n\\n```\\nint findNumberOfLIS(vector<int>& nums) {\\n\\tconst int SIZE = nums.size();\\n\\tvector<int> longestSubsetAtIndex(SIZE, 1), longestSubsetCountsAtIndex(SIZE, 1);\\n\\tint longestSubset = 1, prevLongest, newLongest, longestSubsetCount = 0;\\n\\tfor (int i = 1; i < SIZE; i++) {\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\tprevLongest = longestSubsetAtIndex[i];\\n\\t\\t\\t\\tnewLongest = longestSubsetAtIndex[j] + 1;\\n\\t\\t\\t\\tif (prevLongest == newLongest) {\\n\\t\\t\\t\\t\\tlongestSubsetCountsAtIndex[i] += longestSubsetCountsAtIndex[j];                        \\n\\t\\t\\t\\t} else if (newLongest > prevLongest) {\\n\\t\\t\\t\\t\\tif (prevLongest == longestSubset)\\n\\t\\t\\t\\t\\t\\tlongestSubset = newLongest;\\n\\t\\t\\t\\t\\tlongestSubsetAtIndex[i] = newLongest;\\n\\t\\t\\t\\t\\tlongestSubsetCountsAtIndex[i] = longestSubsetCountsAtIndex[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 0; i < SIZE; i++) {\\n\\t\\tif (longestSubsetAtIndex[i] == longestSubset)\\n\\t\\t\\tlongestSubsetCount += longestSubsetCountsAtIndex[i];\\n\\t}\\n\\treturn longestSubsetCount;\\n}\\n```\\n\\nAnd if you suck at DP as much as I do, go through this: https://leetcode.com/discuss/general-discussion/662866/dp-for-beginners-problems-patterns-sample-solutions/870893\\n\\nIt\\'s a brilliant post that I\\'ve been working through in order that allowed me to solve this, hopefully this all helps someone.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint findNumberOfLIS(vector<int>& nums) {\\n\\tconst int SIZE = nums.size();\\n\\tvector<int> longestSubsetAtIndex(SIZE, 1), longestSubsetCountsAtIndex(SIZE, 1);\\n\\tint longestSubset = 1, prevLongest, newLongest, longestSubsetCount = 0;\\n\\tfor (int i = 1; i < SIZE; i++) {\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\tprevLongest = longestSubsetAtIndex[i];\\n\\t\\t\\t\\tnewLongest = longestSubsetAtIndex[j] + 1;\\n\\t\\t\\t\\tif (prevLongest == newLongest) {\\n\\t\\t\\t\\t\\tlongestSubsetCountsAtIndex[i] += longestSubsetCountsAtIndex[j];                        \\n\\t\\t\\t\\t} else if (newLongest > prevLongest) {\\n\\t\\t\\t\\t\\tif (prevLongest == longestSubset)\\n\\t\\t\\t\\t\\t\\tlongestSubset = newLongest;\\n\\t\\t\\t\\t\\tlongestSubsetAtIndex[i] = newLongest;\\n\\t\\t\\t\\t\\tlongestSubsetCountsAtIndex[i] = longestSubsetCountsAtIndex[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor (int i = 0; i < SIZE; i++) {\\n\\t\\tif (longestSubsetAtIndex[i] == longestSubset)\\n\\t\\t\\tlongestSubsetCount += longestSubsetCountsAtIndex[i];\\n\\t}\\n\\treturn longestSubsetCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076562,
                "title": "12ms-99-fenwick-tree-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, a[2001];\\n    pair<int, int> bit[2001];\\n\\n    void Update(int i, int len, int cnt) {\\n        while (i <= n) {\\n            if (bit[i].first < len) {\\n                bit[i] = {len, cnt};\\n            }\\n            else if (bit[i].first == len) {\\n                bit[i].second += cnt;\\n            }\\n            i += i & -i;\\n        }\\n    }\\n\\n    pair<int, int> Get(int i) {\\n        pair<int, int> ans = {0, 0};\\n        while (i > 0) {\\n            if (ans.first < bit[i].first) {\\n                ans = bit[i];\\n            }\\n            else if (bit[i].first == ans.first) {\\n                ans.second += bit[i].second;\\n            }\\n            i -= i & -i;\\n        }\\n        return ans;\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        n = nums.size();\\n        for (int i = 1; i <= n; ++i) {\\n            a[i] = nums[i - 1];\\n        }\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1; i <= n; ++i) {\\n            a[i] = lower_bound(nums.begin(), nums.end(), a[i]) - nums.begin() + 1;\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            auto [len, cnt] = Get(a[i] - 1);\\n            if (len == 0) {\\n                cnt = 1;\\n            }\\n            Update(a[i], ++len, cnt);\\n        }\\n        return Get(n).second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, a[2001];\\n    pair<int, int> bit[2001];\\n\\n    void Update(int i, int len, int cnt) {\\n        while (i <= n) {\\n            if (bit[i].first < len) {\\n                bit[i] = {len, cnt};\\n            }\\n            else if (bit[i].first == len) {\\n                bit[i].second += cnt;\\n            }\\n            i += i & -i;\\n        }\\n    }\\n\\n    pair<int, int> Get(int i) {\\n        pair<int, int> ans = {0, 0};\\n        while (i > 0) {\\n            if (ans.first < bit[i].first) {\\n                ans = bit[i];\\n            }\\n            else if (bit[i].first == ans.first) {\\n                ans.second += bit[i].second;\\n            }\\n            i -= i & -i;\\n        }\\n        return ans;\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        n = nums.size();\\n        for (int i = 1; i <= n; ++i) {\\n            a[i] = nums[i - 1];\\n        }\\n        sort(nums.begin(), nums.end());\\n        for (int i = 1; i <= n; ++i) {\\n            a[i] = lower_bound(nums.begin(), nums.end(), a[i]) - nums.begin() + 1;\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            auto [len, cnt] = Get(a[i] - 1);\\n            if (len == 0) {\\n                cnt = 1;\\n            }\\n            Update(a[i], ++len, cnt);\\n        }\\n        return Get(n).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916531,
                "title": "c-dp-and-2-pointer-scan",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n<2) return  n;\\n        vector<int> lens(n, 1); // lens[i]: length of LIS ends with nums[i]\\n        vector<int> cnts(n, 1); // cnts[i]: counts of LIS ends with nums[i]\\n        for(int i = 1; i < n; i++)    // i: right pointer\\n            for(int j = 0; j < i; j++) // j: left pointer\\n                if(nums[j] < nums[i]){ // left_item < right_item\\n                    if(lens[j] + 1 > lens[i]){//key point: if newly longer subsequence ending with nums[i] found, then\\n                        lens[i] = lens[j] + 1;\\n                        cnts[i] = cnts[j];\\n                    }else if(lens[j] + 1 == lens[i]){\\n                        cnts[i] += cnts[j];\\n                    }\\n                }\\n        int maxLen = *max_element(lens.begin(), lens.end());        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            if(lens[i] == maxLen)\\n                ans += cnts[i];\\n        return ans;\\n    }\\n};\\n```\\n//inpsired by huahua",
                "solutionTags": [
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        if(n<2) return  n;\\n        vector<int> lens(n, 1); // lens[i]: length of LIS ends with nums[i]\\n        vector<int> cnts(n, 1); // cnts[i]: counts of LIS ends with nums[i]\\n        for(int i = 1; i < n; i++)    // i: right pointer\\n            for(int j = 0; j < i; j++) // j: left pointer\\n                if(nums[j] < nums[i]){ // left_item < right_item\\n                    if(lens[j] + 1 > lens[i]){//key point: if newly longer subsequence ending with nums[i] found, then\\n                        lens[i] = lens[j] + 1;\\n                        cnts[i] = cnts[j];\\n                    }else if(lens[j] + 1 == lens[i]){\\n                        cnts[i] += cnts[j];\\n                    }\\n                }\\n        int maxLen = *max_element(lens.begin(), lens.end());        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            if(lens[i] == maxLen)\\n                ans += cnts[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394534,
                "title": "clean-c-dp-o-n-2-time-o-n-space-with-comments",
                "content": "```cpp\\n    int findNumberOfLIS(vector<int>& nums) {\\n      int n = nums.size();\\n      if (n == 0) return 0;\\n      \\n      vector<int> len(n, 1); // len[i]: length of LIS ending with nums[i]\\n      vector<int> cnt(n, 1); // cnt[i]: number of LIS ending with nums[i]\\n      \\n      // len[i] = max(len[j]+1: j<i && nums[j]<nums[i])\\n      // cnt[i] = sum(cnt[j]:   j<i && nums[j]<nums[i] && len[j]==len[i]+1)      \\n      for (int i = 1; i < n; ++i) {\\n        for (int j = 0; j < i ; ++j) {\\n          if (nums[j] < nums[i]) {\\n            if (len[i] < len[j]+1) {\\n              len[i] = len[j]+1;\\n              cnt[i] = cnt[j];\\n            }\\n            else if (len[i] == len[j]+1) {\\n              cnt[i] += cnt[j];\\n            }\\n          }\\n        }        \\n      }\\n      \\n      // find length of LIS for nums[]\\n      int maxLen = *max_element(len.begin(), len.end());\\n      \\n      // compute number of LIS for nums[]\\n      // cnt_maxLen = sum(len[i]: if len[i] == maxLen)\\n      int cnt_maxLen = 0;\\n      for (int i = 0; i < n; ++i)\\n        if (len[i] == maxLen) cnt_maxLen += cnt[i];\\n      \\n      return cnt_maxLen;        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n    int findNumberOfLIS(vector<int>& nums) {\\n      int n = nums.size();\\n      if (n == 0) return 0;\\n      \\n      vector<int> len(n, 1); // len[i]: length of LIS ending with nums[i]\\n      vector<int> cnt(n, 1); // cnt[i]: number of LIS ending with nums[i]\\n      \\n      // len[i] = max(len[j]+1: j<i && nums[j]<nums[i])\\n      // cnt[i] = sum(cnt[j]:   j<i && nums[j]<nums[i] && len[j]==len[i]+1)      \\n      for (int i = 1; i < n; ++i) {\\n        for (int j = 0; j < i ; ++j) {\\n          if (nums[j] < nums[i]) {\\n            if (len[i] < len[j]+1) {\\n              len[i] = len[j]+1;\\n              cnt[i] = cnt[j];\\n            }\\n            else if (len[i] == len[j]+1) {\\n              cnt[i] += cnt[j];\\n            }\\n          }\\n        }        \\n      }\\n      \\n      // find length of LIS for nums[]\\n      int maxLen = *max_element(len.begin(), len.end());\\n      \\n      // compute number of LIS for nums[]\\n      // cnt_maxLen = sum(len[i]: if len[i] == maxLen)\\n      int cnt_maxLen = 0;\\n      for (int i = 0; i < n; ++i)\\n        if (len[i] == maxLen) cnt_maxLen += cnt[i];\\n      \\n      return cnt_maxLen;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796196,
                "title": "easiest-c-code-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& a) {\\n         int i,j,k,c=0,s=0,ml=1,ans=0;\\n        int n=a.size();\\n        int  l[n];\\n        int b[n];\\n        for(i=0;i<n;i++)\\n        {\\n            l[i]=1;\\n            b[i]=1;\\n        }\\n        \\n        for(i=1;i<a.size();i++)\\n        {\\n            \\n            for(j=0;j<i;j++)\\n            {\\n                if(a[i]>a[j] and l[j]+1>l[i])\\n                {\\n                    l[i]=l[j]+1;\\n                    b[i]=b[j];\\n                }\\n                else if(a[i]>a[j] and l[j]+1==l[i])\\n                {\\n                    b[i]+=b[j];\\n                }\\n            }\\n            ml=max(ml,l[i]);\\n\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(l[i]==ml){\\n            c+=b[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& a) {\\n         int i,j,k,c=0,s=0,ml=1,ans=0;\\n        int n=a.size();\\n        int  l[n];\\n        int b[n];\\n        for(i=0;i<n;i++)\\n        {\\n            l[i]=1;\\n            b[i]=1;\\n        }\\n        \\n        for(i=1;i<a.size();i++)\\n        {\\n            \\n            for(j=0;j<i;j++)\\n            {\\n                if(a[i]>a[j] and l[j]+1>l[i])\\n                {\\n                    l[i]=l[j]+1;\\n                    b[i]=b[j];\\n                }\\n                else if(a[i]>a[j] and l[j]+1==l[i])\\n                {\\n                    b[i]+=b[j];\\n                }\\n            }\\n            ml=max(ml,l[i]);\\n\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(l[i]==ml){\\n            c+=b[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795160,
                "title": "python3-dp-time-o-n-2-space-o-n-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use dynamic programming to break down the problem into smaller subproblems, find the length and count of LIS ending at each index, and then combine this information to find the total number of longest increasing subsequences in the given array \\'nums\\'.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function findNumberOfLIS takes an array nums as input and returns the number of longest increasing subsequences.\\n2. We initialize a variable n to store the length of the input array nums.\\n3. The variable dp is a 2D list to store the dynamic programming results. Each element dp[i] represents the information for the subsequence ending at index i. It is a list containing two values: [length, cnt], where length represents the length of the longest increasing subsequence ending at index i, and cnt represents the count of such subsequences.\\n4. We initialize max_length to 0 to keep track of the length of the longest increasing subsequence found so far.\\n5. We iterate over each index i in the range [0, n-1]:\\n    - Initialize dp[i] as [1, 1] (length 1 and count 1) because every element is an LIS of length 1 by itself.\\n    - For each index j in the range [0, i-1]:\\n        - If the element at j is less than the element at i (nums[j] < nums[i]), we have found a potential longer subsequence.\\n        - Compare the length of the LIS ending at j with the current length of LIS ending at i. If dp[j][0] + 1 is greater than dp[i][0], it means we have found a longer subsequence ending at i, so we update dp[i] accordingly. If dp[j][0] + 1 is equal to dp[i][0], it means we have found another subsequence with the same length as the current longest one, so we increment the count dp[i][1] by dp[j][1].\\n    - Update max_length to be the maximum of the current max_length and the length of the LIS ending at index i.\\n6. After finding the max_length, we iterate over dp again to count the number of longest increasing subsequences. We add the count dp[i][1] to res for each index i where the length of LIS is equal to max_length.\\n7. Finally, we return the value of res, which represents the number of longest increasing subsequences.\\n\\n### Time Complexity:\\n- The outer loop runs for n iterations, and the inner loop runs for at most i iterations for each index i. Therefore, the total number of comparisons and updates done in the inner loop is roughly proportional to the sum of the first n positive integers, which is O(n^2).\\n- The subsequent loop that counts the number of longest increasing subsequences also runs in O(n) time.\\n- Overall, the time complexity of the algorithm is O(n^2).\\n\\n### Space Complexity:\\n- The space complexity is O(n) to store the dp list.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[1, 1] for _ in range(n)] # length, cnt\\n        max_length = 0\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[j][0] + 1 > dp[i][0]:\\n                        dp[i] = [dp[j][0] + 1, dp[j][1]]\\n                    elif dp[j][0] + 1 == dp[i][0]:\\n                        dp[i][1] = dp[i][1] + dp[j][1]\\n            max_length = max(max_length, dp[i][0])\\n        res = 0\\n        for idx, (length, cnt) in enumerate(dp):\\n            if length == max_length:\\n                res += cnt\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[1, 1] for _ in range(n)] # length, cnt\\n        max_length = 0\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[j][0] + 1 > dp[i][0]:\\n                        dp[i] = [dp[j][0] + 1, dp[j][1]]\\n                    elif dp[j][0] + 1 == dp[i][0]:\\n                        dp[i][1] = dp[i][1] + dp[j][1]\\n            max_length = max(max_length, dp[i][0])\\n        res = 0\\n        for idx, (length, cnt) in enumerate(dp):\\n            if length == max_length:\\n                res += cnt\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794898,
                "title": "recursion-top-down-bottom-up-c",
                "content": "## RECURSION [TLE]\\n```\\nclass Solution {\\npublic:\\n    //LIS for each call will be longest increasing subsequence starting from \"currIdx\"\\n    //returns the {LISLen, LISCount}  [LISCount = no. of subsequences with len = LISLen]\\n    pair<int, int> solve(vector<int>&nums, int currIdx)\\n    {   \\n        int LISLen = 1, LISCount = 1;\\n        //============================================================================\\n        for (int i = currIdx + 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] > nums[currIdx])\\n            {\\n                pair<int, int>nextLenCount = solve(nums, i);\\n                \\n                int currLen = 1 + nextLenCount.first; //1 + nextLen\\n                if (currLen > LISLen)\\n                {\\n                    LISLen = currLen;\\n                    LISCount = nextLenCount.second; //nextCount\\n                }\\n                else if (currLen == LISLen) \\n                    LISCount = LISCount + nextLenCount.second;\\n            }\\n        }\\n        //=================================================================================\\n        return {LISLen, LISCount};\\n    }\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        unordered_map<int, int>mp;\\n        //===============================================================\\n        for (int start = 0; start < n; start++)  //LISLen and LISCount for subsequences starting at \"start\"\\n        {\\n            pair<int, int>lenCountPair  = solve(nums, start);\\n            int LISLen = lenCountPair.first, LISCount = lenCountPair.second;\\n            mp[LISLen] += LISCount;\\n            maxLISLen = max(maxLISLen, LISLen);\\n        }\\n        //=================================================================\\n        return mp[maxLISLen];\\n        \\n    }\\n};\\n```\\n//=============================================================================================================\\n## TOP-DOWN [MEMOIZATION]\\n```\\nclass Solution {\\npublic:\\n    //LIS for each call will be longest increasing subsequence starting from \"currIdx\"\\n    //returns the {LISLen, LISCount}  [LISCount = no. of subsequences with len = LISLen]\\n    pair<int, int> solve(vector<int>&nums, vector<int>&length, vector<int>&count, int currIdx)\\n    {\\n        if (length[currIdx] != -1) return {length[currIdx], count[currIdx]};\\n        \\n        int LISLen = 1, LISCount = 1;\\n        //============================================================================\\n        for (int i = currIdx + 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] > nums[currIdx])\\n            {\\n                pair<int, int>nextLenCount = solve(nums, length, count, i);\\n                \\n                int currLen = 1 + nextLenCount.first; //1 + nextLen\\n                if (currLen > LISLen)\\n                {\\n                    LISLen = currLen;\\n                    LISCount = nextLenCount.second; //nextCount\\n                }\\n                else if (currLen == LISLen) \\n                    LISCount = LISCount + nextLenCount.second;\\n            }\\n        }\\n        //=================================================================================\\n        length[currIdx] = LISLen; count[currIdx] = LISCount;\\n        return {LISLen, LISCount};\\n    }\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        unordered_map<int, int>mp;\\n        vector<int>length(n, -1), count(n, -1);\\n        //===============================================================\\n        for (int start = 0; start < n; start++) //LISLen and LISCount for subsequences starting at \"start\"\\n        {\\n            pair<int, int>lenCountPair  = solve(nums, length, count, start);\\n            int LISLen = lenCountPair.first, LISCount = lenCountPair.second;\\n            mp[LISLen] += LISCount;\\n            maxLISLen = max(maxLISLen, LISLen);\\n        }\\n        //=================================================================\\n        return mp[maxLISLen];\\n        \\n    }\\n};\\n```\\n//=============================================================================================================\\n## BOTTOM UP \\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        vector<int>length(n, -1), count(n, -1); //DP\\n        //===================================================================================\\n        for (int start = n - 1; start >= 0; start--)\\n        {\\n            int LISLen = 1, LISCount = 1;\\n            //=======================================================\\n            for (int i = start + 1; i < nums.size(); i++)\\n            {\\n                if (nums[i] > nums[start])\\n                {\\n                    int currLen = 1 + length[i]; //1 + nextLen\\n                    if (currLen > LISLen)\\n                    {\\n                        LISLen = currLen;\\n                        LISCount = count[i]; //nextCount\\n                    }\\n                    else if (currLen == LISLen) \\n                        LISCount = LISCount + count[i];\\n                }\\n            }\\n            //=============================================================\\n            length[start] = LISLen; \\n            count[start] = LISCount;\\n            maxLISLen = max(maxLISLen, length[start]);\\n        }\\n        //========================================================================================\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (length[i] == maxLISLen) \\n                ans += count[i];\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //LIS for each call will be longest increasing subsequence starting from \"currIdx\"\\n    //returns the {LISLen, LISCount}  [LISCount = no. of subsequences with len = LISLen]\\n    pair<int, int> solve(vector<int>&nums, int currIdx)\\n    {   \\n        int LISLen = 1, LISCount = 1;\\n        //============================================================================\\n        for (int i = currIdx + 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] > nums[currIdx])\\n            {\\n                pair<int, int>nextLenCount = solve(nums, i);\\n                \\n                int currLen = 1 + nextLenCount.first; //1 + nextLen\\n                if (currLen > LISLen)\\n                {\\n                    LISLen = currLen;\\n                    LISCount = nextLenCount.second; //nextCount\\n                }\\n                else if (currLen == LISLen) \\n                    LISCount = LISCount + nextLenCount.second;\\n            }\\n        }\\n        //=================================================================================\\n        return {LISLen, LISCount};\\n    }\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        unordered_map<int, int>mp;\\n        //===============================================================\\n        for (int start = 0; start < n; start++)  //LISLen and LISCount for subsequences starting at \"start\"\\n        {\\n            pair<int, int>lenCountPair  = solve(nums, start);\\n            int LISLen = lenCountPair.first, LISCount = lenCountPair.second;\\n            mp[LISLen] += LISCount;\\n            maxLISLen = max(maxLISLen, LISLen);\\n        }\\n        //=================================================================\\n        return mp[maxLISLen];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //LIS for each call will be longest increasing subsequence starting from \"currIdx\"\\n    //returns the {LISLen, LISCount}  [LISCount = no. of subsequences with len = LISLen]\\n    pair<int, int> solve(vector<int>&nums, vector<int>&length, vector<int>&count, int currIdx)\\n    {\\n        if (length[currIdx] != -1) return {length[currIdx], count[currIdx]};\\n        \\n        int LISLen = 1, LISCount = 1;\\n        //============================================================================\\n        for (int i = currIdx + 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] > nums[currIdx])\\n            {\\n                pair<int, int>nextLenCount = solve(nums, length, count, i);\\n                \\n                int currLen = 1 + nextLenCount.first; //1 + nextLen\\n                if (currLen > LISLen)\\n                {\\n                    LISLen = currLen;\\n                    LISCount = nextLenCount.second; //nextCount\\n                }\\n                else if (currLen == LISLen) \\n                    LISCount = LISCount + nextLenCount.second;\\n            }\\n        }\\n        //=================================================================================\\n        length[currIdx] = LISLen; count[currIdx] = LISCount;\\n        return {LISLen, LISCount};\\n    }\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        unordered_map<int, int>mp;\\n        vector<int>length(n, -1), count(n, -1);\\n        //===============================================================\\n        for (int start = 0; start < n; start++) //LISLen and LISCount for subsequences starting at \"start\"\\n        {\\n            pair<int, int>lenCountPair  = solve(nums, length, count, start);\\n            int LISLen = lenCountPair.first, LISCount = lenCountPair.second;\\n            mp[LISLen] += LISCount;\\n            maxLISLen = max(maxLISLen, LISLen);\\n        }\\n        //=================================================================\\n        return mp[maxLISLen];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size(), maxLISLen = 1;\\n        \\n        vector<int>length(n, -1), count(n, -1); //DP\\n        //===================================================================================\\n        for (int start = n - 1; start >= 0; start--)\\n        {\\n            int LISLen = 1, LISCount = 1;\\n            //=======================================================\\n            for (int i = start + 1; i < nums.size(); i++)\\n            {\\n                if (nums[i] > nums[start])\\n                {\\n                    int currLen = 1 + length[i]; //1 + nextLen\\n                    if (currLen > LISLen)\\n                    {\\n                        LISLen = currLen;\\n                        LISCount = count[i]; //nextCount\\n                    }\\n                    else if (currLen == LISLen) \\n                        LISCount = LISCount + count[i];\\n                }\\n            }\\n            //=============================================================\\n            length[start] = LISLen; \\n            count[start] = LISCount;\\n            maxLISLen = max(maxLISLen, length[start]);\\n        }\\n        //========================================================================================\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (length[i] == maxLISLen) \\n                ans += count[i];\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241697,
                "title": "java-dynamic-programming-solution-with-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Number of Longest Increasing Subsequence involves finding the total number of longest increasing subsequence in a given sequence of numbers.\\n\\nThere are also more advance algorithms, such as the Patience Sorting, that can solve the problem in $$O(n*log(n))$$ time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne common approach to solve this problem is Dynamic Programming. We create 2 auxiliary arrays `dp` and `count` of the same length as the input array. `dp[i]` will store the length of the longest increasing subsequence ending at index i of the given array, and `count[i]` will store the number of longest increasing subsequences ending at index i.\\n\\nWe then fill the auxiliary arrays by comparing each element in the sequence to all preceding elements, and updating the value in both arrays as needed. The length of the longest increasing subsequence can then be found by taking the maximum value in the `dp` array.\\n\\nFinally, using the maximum value in the `dp` array, we traverse the `count` array to find the sum of all elements where `dp[i]` is equal to the maximum value.\\n\\n\\n#### \\u2705 Iterative - Tabulation - Bottom Up \\u2705\\n\\nHere\\'s the steps to solve this problem:\\n\\n1. Initialize two arrays `dp and count` of the same size as the given array. `dp[k]` will store the length of the longest increasing subsequence ending at index `k`, and `count[k]` will store the number of longest increasing subsequences ending at index `k`.\\n\\n2. Initialize all elements of `dp and count` to 1, as every element is a longest increasing subsequence of length 1, and there is only one longest increasing subsequence ending at each index.\\n\\n3. Traverse the array, and for each index `k`, traverse the subarray from `0 to k-1`. \\n\\n4. If the element at index `j` is less than the element at index `k` and `dp[j] + 1 > dp[k]`, means that we can extend the subsequence ending at `nums[j]`, set `dp[k]` to the maximum of `dp[j] + 1` and `dp[k]`.\\n\\n\\n5. If the element at index `j` is less than the element at index `k` and `dp[j]+1 == dp[i]`, means that there is a new longest increasing subsequence that ends at `nums[k]`. We then add `count[j]` to `count[k]`.\\n\\n6. We keep track of the maximum length of the LIS in the variable `maxLen`, which is update in each iteration. \\n\\n7. Finally, we initialize a variable call `result = 0`. Then iterate over all elements in `count` array to check if the current value is equal to `maxLen`, it it does, add to `result`, means that we found more combination of LIS.\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int maxLen = 1;\\n        //Step 1\\n        int [] dp = new int[nums.length];\\n        int [] count = new int[nums.length];\\n\\n        //Step 2\\n        Arrays.fill(dp,1);\\n        Arrays.fill(count,1);\\n\\n        //Step 3\\n        for(int k = 1; k < nums.length; k++)\\n        {\\n            for(int j = 0; j < k; j++)\\n            {\\n                if(nums[k] > nums[j])\\n                {\\n                    //Step 4\\n                    if(dp[k] < dp[j] + 1)\\n                    {\\n                        dp[k] = dp[j] + 1;\\n                        count[k] = count[j];\\n                    }\\n\\n                    //Step 5\\n                    else if(dp[k] == dp[j] + 1)\\n                    {\\n                        count[k] += count[j];\\n                    }\\n                }\\n            }\\n            //Step 6\\n            maxLen = Math.max(maxLen,dp[k]);\\n        }\\n\\n        //Step 7\\n        int result = 0;\\n        for(int k = 0; k < nums.length;k++)\\n        {\\n            if(maxLen == dp[k]) result += count[k];\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ where n is the length of the input array. As we need to iterate through the input array twice.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ as we using 2 arrays of length nums.length to store the results.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n###### The Number of Longest Increasing Subsequence problem have several real-life applications, including the following: \\n\\n1. Game theory: analyze the optimal strategy in a sequential decision-making game. This involves identifying the longest increasing subsequence of optimal decisions, which can help to determine the best course of action in various scenarios, such as in a game of chess or poker.\\n\\n2. Stock Market Analysis: Analyzing stock prices over a period of time to make a profitable investment opportunity.\\n\\n3. Image processing: help identify objects and shapes, and can also help in image compression.\\n\\n4. Speech recognition: identify patterns in speech, and can also be used to improve the accuracy of speech recognition algorithms.\\n\\n5. Computer graphics: Identify the longest increasing subsequence of vertices in a graph can help in constructing smooth and aesthetically pleasing curves and surfaces.\\n\\n6. DNA sequencing: determine the longest common subsequence (LCS) of two DNA sequences, which provides information about genetic similarities between two organisms.\\n\\n7. Text analysis: identify the longest increasing subsequence of characters, words, or phrases in a text corpus. This can help in various natural language processing tasks such as sentiment analysis, summarization, and topic modeling.\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int maxLen = 1;\\n        //Step 1\\n        int [] dp = new int[nums.length];\\n        int [] count = new int[nums.length];\\n\\n        //Step 2\\n        Arrays.fill(dp,1);\\n        Arrays.fill(count,1);\\n\\n        //Step 3\\n        for(int k = 1; k < nums.length; k++)\\n        {\\n            for(int j = 0; j < k; j++)\\n            {\\n                if(nums[k] > nums[j])\\n                {\\n                    //Step 4\\n                    if(dp[k] < dp[j] + 1)\\n                    {\\n                        dp[k] = dp[j] + 1;\\n                        count[k] = count[j];\\n                    }\\n\\n                    //Step 5\\n                    else if(dp[k] == dp[j] + 1)\\n                    {\\n                        count[k] += count[j];\\n                    }\\n                }\\n            }\\n            //Step 6\\n            maxLen = Math.max(maxLen,dp[k]);\\n        }\\n\\n        //Step 7\\n        int result = 0;\\n        for(int k = 0; k < nums.length;k++)\\n        {\\n            if(maxLen == dp[k]) result += count[k];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934074,
                "title": "easy-to-understand-c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> p;\\n    \\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<p> memo(n+1, make_pair(-1, -1));\\n        return helper(nums, memo, 0, -1).second;\\n    }\\nprivate:\\n    p helper(vector<int>& nums, vector<p>& memo, int idx, int prev)\\n    {\\n        if (idx == nums.size()) return make_pair(0, 1);\\n        if (memo[prev+1] != make_pair(-1, -1)) return memo[prev+1];\\n        p a = make_pair(0, 0), b = make_pair(0, 0);\\n        if (prev==-1 || nums[idx] > nums[prev]) \\n        {\\n            a = helper(nums, memo, idx+1, idx);\\n            a.first++;\\n        }\\n        b = helper(nums, memo, idx+1, prev);\\n        if (a.first == b.first) return memo[prev+1] = make_pair(a.first, a.second+b.second);\\n        else if (a.first > b.first) return memo[prev+1] = a;\\n        return memo[prev+1] = b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> p;\\n    \\n    int findNumberOfLIS(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<p> memo(n+1, make_pair(-1, -1));\\n        return helper(nums, memo, 0, -1).second;\\n    }\\nprivate:\\n    p helper(vector<int>& nums, vector<p>& memo, int idx, int prev)\\n    {\\n        if (idx == nums.size()) return make_pair(0, 1);\\n        if (memo[prev+1] != make_pair(-1, -1)) return memo[prev+1];\\n        p a = make_pair(0, 0), b = make_pair(0, 0);\\n        if (prev==-1 || nums[idx] > nums[prev]) \\n        {\\n            a = helper(nums, memo, idx+1, idx);\\n            a.first++;\\n        }\\n        b = helper(nums, memo, idx+1, prev);\\n        if (a.first == b.first) return memo[prev+1] = make_pair(a.first, a.second+b.second);\\n        else if (a.first > b.first) return memo[prev+1] = a;\\n        return memo[prev+1] = b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580705,
                "title": "java-96-faster",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        int count[]=new int[nums.length];\\n        dp[0]=1;\\n        count[0]=1;\\n        int result=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            dp[i]=1;\\n            count[i]=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]){\\n                    if(dp[i]<dp[j]+1)\\n                    {\\n                        dp[i]=dp[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(dp[i]==dp[j]+1)\\n                    {\\n                        count[i]+=count[j];\\n                    }\\n                        \\n                }\\n            }\\n            \\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(max<dp[i])\\n            {\\n                result=count[i];\\n                max=dp[i];\\n            }\\n            else if(max==dp[i])\\n                result+=count[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        int count[]=new int[nums.length];\\n        dp[0]=1;\\n        count[0]=1;\\n        int result=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            dp[i]=1;\\n            count[i]=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]){\\n                    if(dp[i]<dp[j]+1)\\n                    {\\n                        dp[i]=dp[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(dp[i]==dp[j]+1)\\n                    {\\n                        count[i]+=count[j];\\n                    }\\n                        \\n                }\\n            }\\n            \\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(max<dp[i])\\n            {\\n                result=count[i];\\n                max=dp[i];\\n            }\\n            else if(max==dp[i])\\n                result+=count[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557324,
                "title": "java-o-n-2-time-o-n-space-with-comments",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        // in dp we store the LIS if last number of seq is i\\n        int[] dp = new int[nums.length];\\n        // in mul we store in how many ways we can obtain the LIS with last element i\\n        int[] mul = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++){\\n            dp[i] = 1;\\n            mul[i] = 1;\\n            for(int j = 0; j < i; j++)\\n                if(nums[j] < nums[i]){ \\n                    // if equals: we have found a new way to obtain max mult\\n                    if(dp[j] + 1 == dp[i]) mul[i] += mul[j];\\n                    // else we need to rethink: there is a longest subsequence\\n                    else if(dp[j] + 1 > dp[i]){\\n                        mul[i] = mul[j];\\n                        dp[i] = dp[j] + 1;\\n                    }\\n                }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            if(dp[i] > max) max = dp[i];\\n        }\\n        int sol = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            if(dp[i] == max) sol += mul[i];\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        // in dp we store the LIS if last number of seq is i\\n        int[] dp = new int[nums.length];\\n        // in mul we store in how many ways we can obtain the LIS with last element i\\n        int[] mul = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++){\\n            dp[i] = 1;\\n            mul[i] = 1;\\n            for(int j = 0; j < i; j++)\\n                if(nums[j] < nums[i]){ \\n                    // if equals: we have found a new way to obtain max mult\\n                    if(dp[j] + 1 == dp[i]) mul[i] += mul[j];\\n                    // else we need to rethink: there is a longest subsequence\\n                    else if(dp[j] + 1 > dp[i]){\\n                        mul[i] = mul[j];\\n                        dp[i] = dp[j] + 1;\\n                    }\\n                }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            if(dp[i] > max) max = dp[i];\\n        }\\n        int sol = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            if(dp[i] == max) sol += mul[i];\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505027,
                "title": "python-simple",
                "content": "O(N^2) - 2 nested loops\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int]) -> int:\\n        N, max_len = len(A), 1\\n        dp, counts = [1] * N, [1] * N\\n        \\n        for i in range(1, N):\\n            for j in range(i, -1, -1):\\n                if A[i] > A[j]:\\n                    if 1 + dp[j] > dp[i]:\\n                        dp[i] = 1 + dp[j]\\n                        counts[i] = counts[j]\\n                    elif 1 + dp[j] == dp[i]:\\n                        counts[i] += counts[j]\\n        \\n            max_len = max(max_len, dp[i])\\n\\n        \\n        return sum(counts[i] for i in range(N) if dp[i] == max_len)\\n```\\nO(NlogN) - modified LIS\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int]) -> int:\\n        N = len(A)     \\n        lis = []\\n        frequency_of_this_length = defaultdict(list)\\n        frequency_of_this_length[-1].append((1, -math.inf))\\n        \\n        max_len = 1\\n\\n        for val in A:\\n            \\n            length = bisect_left(lis, val)\\n\\n            if length >= len(lis): \\n                lis.append(val)\\n            else: \\n                lis[length] = val\\n\\n            curr_lis_count = 0\\n            \\n\\n            for count, a in frequency_of_this_length[length-1]:\\n                if val > a: \\n                    curr_lis_count += count\\n            \\n            frequency_of_this_length[length].append((curr_lis_count, val))\\n            \\n            max_len = max(max_len, length)\\n       \\n        if len(lis) == 1: return N\\n        \\n        return sum(count for count, _ in frequency_of_this_length[max_len])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int]) -> int:\\n        N, max_len = len(A), 1\\n        dp, counts = [1] * N, [1] * N\\n        \\n        for i in range(1, N):\\n            for j in range(i, -1, -1):\\n                if A[i] > A[j]:\\n                    if 1 + dp[j] > dp[i]:\\n                        dp[i] = 1 + dp[j]\\n                        counts[i] = counts[j]\\n                    elif 1 + dp[j] == dp[i]:\\n                        counts[i] += counts[j]\\n        \\n            max_len = max(max_len, dp[i])\\n\\n        \\n        return sum(counts[i] for i in range(N) if dp[i] == max_len)\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int]) -> int:\\n        N = len(A)     \\n        lis = []\\n        frequency_of_this_length = defaultdict(list)\\n        frequency_of_this_length[-1].append((1, -math.inf))\\n        \\n        max_len = 1\\n\\n        for val in A:\\n            \\n            length = bisect_left(lis, val)\\n\\n            if length >= len(lis): \\n                lis.append(val)\\n            else: \\n                lis[length] = val\\n\\n            curr_lis_count = 0\\n            \\n\\n            for count, a in frequency_of_this_length[length-1]:\\n                if val > a: \\n                    curr_lis_count += count\\n            \\n            frequency_of_this_length[length].append((curr_lis_count, val))\\n            \\n            max_len = max(max_len, length)\\n       \\n        if len(lis) == 1: return N\\n        \\n        return sum(count for count, _ in frequency_of_this_length[max_len])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492606,
                "title": "python-2-solutions-dp-binary-search-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: DP**\\n- Let `dp[i]` (where 0 <= i < n) be the longest increasing subsequence ends at `nums[i]`.\\n- Let `cnt[i]` (where 0 <= i < n) be the number of longest subsequence ends at `nums[i]`.\\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        cnt = [1] * n\\n        maxLen = 1\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if dp[i] < dp[j] + 1:\\n                        dp[i] = dp[j] + 1\\n                        cnt[i] = cnt[j]\\n                    elif dp[i] == dp[j] + 1:\\n                        cnt[i] += cnt[j]\\n                        \\n            maxLen = max(maxLen, dp[i])\\n        \\n        return sum(cnt[i] for i in range(n) if dp[i] == maxLen)\\n```\\nComplexity:\\n- Time: `O(N^2)`, where `N <= 2000` is the number of elements in `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Binary Search**\\n```python\\n# Todo implementation!\\n```\\nComplexity:\\n- Time: `O(NlogN)`, where `N <= 2000` is the number of elements in `nums` array.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        cnt = [1] * n\\n        maxLen = 1\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if dp[i] < dp[j] + 1:\\n                        dp[i] = dp[j] + 1\\n                        cnt[i] = cnt[j]\\n                    elif dp[i] == dp[j] + 1:\\n                        cnt[i] += cnt[j]\\n                        \\n            maxLen = max(maxLen, dp[i])\\n        \\n        return sum(cnt[i] for i in range(n) if dp[i] == maxLen)\\n```\n```python\\n# Todo implementation!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467477,
                "title": "easy-c-solution-o-n-2-solution-explained-beautifully",
                "content": "class Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n         \\n        int n = nums.size(), length = 0, ans = 0;\\n        \\n        // Now if we are given an array of size 0 , then no of subsequence formed is 0\\n        // with one element its 1\\n        \\n        vector< int > DP( n, 1 );\\n        vector< int > Count( n, 1 );\\n        \\n        // DP[ i ] -> Length of longest subsequence ending at ith index\\n        // Count[ i ] -> Count of no of subsequences ending at ith index\\n    \\n        for( int i=0; i<n ; i++ ){\\n            \\n            for( int j=0 ; j<i ; j++ ){\\n                \\n                if( nums[j] < nums[i] ){\\n                    \\n                    // Now 2 situations arises\\n                    //   i) The i-th element gets added to the subsequence at index j\\n                    \\n                    if( DP[ j ]+1 > DP[i] ){\\n                        \\n                        DP[ i ] = 1 + DP[ j ];\\n                        Count[ i ] = Count[ j ];\\n                    }\\n                    \\n                    //  ii) Increases the number of subsequences as the length of that longest subsequence already achieved for that element\\n                    \\n                    else if( DP[ j ]+1 == DP[ i ] )\\n                        Count[ i ] += Count[j];\\n                }\\n            }\\n          \\n            length = max( length , DP[ i ] );\\n        }\\n        \\n        // count of all longest increasing subsequence that end with ith indexes\\n        for( int i=0 ; i<n ; i++ ){\\n            \\n            if( length==DP[i] )\\n                 ans += Count[ i ];\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n         \\n        int n = nums.size(), length = 0, ans = 0;\\n        \\n        // Now if we are given an array of size 0 , then no of subsequence formed is 0\\n        // with one element its 1\\n        \\n        vector< int > DP( n, 1 );\\n        vector< int > Count( n, 1 );\\n        \\n        // DP[ i ] -> Length of longest subsequence ending at ith index\\n        // Count[ i ] -> Count of no of subsequences ending at ith index\\n    \\n        for( int i=0; i<n ; i++ ){\\n            \\n            for( int j=0 ; j<i ; j++ ){\\n                \\n                if( nums[j] < nums[i] ){\\n                    \\n                    // Now 2 situations arises\\n                    //   i) The i-th element gets added to the subsequence at index j\\n                    \\n                    if( DP[ j ]+1 > DP[i] ){\\n                        \\n                        DP[ i ] = 1 + DP[ j ];\\n                        Count[ i ] = Count[ j ];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1308609,
                "title": "java-n-2-solution-dp",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if(nums==null || nums.length==0) return 0;\\n        \\n        int n=nums.length;\\n        \\n        int length[]=new int [n];\\n        int count[]=new int [n];\\n        \\n        Arrays.fill(length,1);\\n        Arrays.fill(count,1);\\n        \\n        int maxLen=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(length[j]+1>length[i]){\\n                        length[i]=length[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(length[i]==length[j]+1){\\n                        count[i]+=count[j];\\n                    }\\n                }\\n            }\\n            maxLen=Math.max(maxLen,length[i]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(length[i]==maxLen) ans+=count[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if(nums==null || nums.length==0) return 0;\\n        \\n        int n=nums.length;\\n        \\n        int length[]=new int [n];\\n        int count[]=new int [n];\\n        \\n        Arrays.fill(length,1);\\n        Arrays.fill(count,1);\\n        \\n        int maxLen=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(length[j]+1>length[i]){\\n                        length[i]=length[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(length[i]==length[j]+1){\\n                        count[i]+=count[j];\\n                    }\\n                }\\n            }\\n            maxLen=Math.max(maxLen,length[i]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(length[i]==maxLen) ans+=count[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262254,
                "title": "java-dp-solution-with-clean-code",
                "content": "I believe this question should be hard level. At least for me!\\n\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, res = 0, maxLen = 0;\\n\\n        // len[i] denote the length of the longest increasing subsequence which ends with nums[i]\\n        int[] len = new int[n];\\n        // cnt[i] denote the number of the longest increasing subsequence which ends with nums[i]\\n        int[] cnt = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            len[i] = cnt[i] = 1; // init\\n\\n            for (int j = 0; j < i; j++) {\\n                // if combining with i makes an increasing subsequence\\n                if (nums[j] < nums[i]) { // find a valid pattern\\n                    \\n                    // if combining with i makes a longer increasing subsequence\\n                    if (len[j] + 1 > len[i]) {\\n                        len[i] = len[j] + 1;\\n                        cnt[i] = cnt[j];\\n                    } \\n                    // if combining with i makes another longest increasing subsequence\\n                    else if (len[j] + 1 == len[i]) {\\n                        cnt[i] += cnt[j];\\n                    }\\n                }\\n            }\\n\\n            // update res and maxLen\\n            if (maxLen < len[i]) {\\n                maxLen = len[i];\\n                res = cnt[i];\\n            } else if (maxLen == len[i]) {\\n                res += cnt[i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, res = 0, maxLen = 0;\\n\\n        // len[i] denote the length of the longest increasing subsequence which ends with nums[i]\\n        int[] len = new int[n];\\n        // cnt[i] denote the number of the longest increasing subsequence which ends with nums[i]\\n        int[] cnt = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            len[i] = cnt[i] = 1; // init\\n\\n            for (int j = 0; j < i; j++) {\\n                // if combining with i makes an increasing subsequence\\n                if (nums[j] < nums[i]) { // find a valid pattern\\n                    \\n                    // if combining with i makes a longer increasing subsequence\\n                    if (len[j] + 1 > len[i]) {\\n                        len[i] = len[j] + 1;\\n                        cnt[i] = cnt[j];\\n                    } \\n                    // if combining with i makes another longest increasing subsequence\\n                    else if (len[j] + 1 == len[i]) {\\n                        cnt[i] += cnt[j];\\n                    }\\n                }\\n            }\\n\\n            // update res and maxLen\\n            if (maxLen < len[i]) {\\n                maxLen = len[i];\\n                res = cnt[i];\\n            } else if (maxLen == len[i]) {\\n                res += cnt[i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225374,
                "title": "simple-dp-solution-o-n-2-built-upon-lis-problem",
                "content": "This problem is based on Longest Increasing Subsequence, and uses the same DP technique. Instead of 1D array used in LIS, here we make use of an array currMax with 2 columns - one for storing the LIS including current element and other for storing the count of such subsequences. \\nFor instance currMax[2] = [2,1] means that including nums[2], we get an LIS of length 2 and the number of such subsequences of length 2 is 1.\\n\\nEach time the length of LIS is updated, the corresponding count column also gets updated.\\n\\nThe code is :\\n```\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        currMax = [[1 , 1] for _ in range(len(nums))]\\n        \\n        for i in range(1 , len(nums)):\\n            for j in range(i) :\\n                \\n                if nums[i] > nums[j] :\\n                    if currMax[i][0] < currMax[j][0] + 1 :\\n                        currMax[i][0] = currMax[j][0] + 1\\n                        currMax[i][1] = currMax[j][1]\\n                    elif currMax[i][0] == currMax[j][0] + 1:\\n                        currMax[i][1] += currMax[j][1]\\n                        \\n        result = 0\\n        \\n        maxlength = max(currMax, key = lambda x: x[0])[0]\\n\\n        for i in range(len(nums)):\\n            if currMax[i][0] == maxlength :\\n                result = result + currMax[i][1]\\n            \\n        return result\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        \\n        currMax = [[1 , 1] for _ in range(len(nums))]\\n        \\n        for i in range(1 , len(nums)):\\n            for j in range(i) :\\n                \\n                if nums[i] > nums[j] :\\n                    if currMax[i][0] < currMax[j][0] + 1 :\\n                        currMax[i][0] = currMax[j][0] + 1\\n                        currMax[i][1] = currMax[j][1]\\n                    elif currMax[i][0] == currMax[j][0] + 1:\\n                        currMax[i][1] += currMax[j][1]\\n                        \\n        result = 0\\n        \\n        maxlength = max(currMax, key = lambda x: x[0])[0]\\n\\n        for i in range(len(nums)):\\n            if currMax[i][0] == maxlength :\\n                result = result + currMax[i][1]\\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1091864,
                "title": "c-dp-solution-using-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& v) {\\n        // finding length of LIS\\n        \\n        vector<int> dp(v.size());\\n        int lis = 1;\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<dp.size(); i++){\\n            int currMax = 0;\\n            \\n            for(int j=0; j<i; j++){\\n                if(v[j] < v[i]){\\n                    currMax = max(currMax, dp[j]);\\n                }\\n            }\\n            \\n            dp[i] = currMax + 1;\\n            lis = max(lis, dp[i]);\\n        }\\n        \\n        // counting number of LIS\\n        \\n        // create a count vector to count number of subseqeunces\\n        vector<int> count(dp.size());\\n        \\n        for(int i=0; i<count.size(); i++){\\n            if(dp[i] == 1) count[i] = 1;\\n            else{\\n                for(int j=0; j<i; j++){\\n                    if(dp[j] + 1 == dp[i] and v[j] < v[i]){\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // add number of subsequences that has length equal to LIS length\\n        int ores = 0;\\n        for(int i=0; i<dp.size(); i++){\\n            if(dp[i] == lis){\\n                ores += count[i];\\n            }\\n        }\\n        \\n        return ores;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& v) {\\n        // finding length of LIS\\n        \\n        vector<int> dp(v.size());\\n        int lis = 1;\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<dp.size(); i++){\\n            int currMax = 0;\\n            \\n            for(int j=0; j<i; j++){\\n                if(v[j] < v[i]){\\n                    currMax = max(currMax, dp[j]);\\n                }\\n            }\\n            \\n            dp[i] = currMax + 1;\\n            lis = max(lis, dp[i]);\\n        }\\n        \\n        // counting number of LIS\\n        \\n        // create a count vector to count number of subseqeunces\\n        vector<int> count(dp.size());\\n        \\n        for(int i=0; i<count.size(); i++){\\n            if(dp[i] == 1) count[i] = 1;\\n            else{\\n                for(int j=0; j<i; j++){\\n                    if(dp[j] + 1 == dp[i] and v[j] < v[i]){\\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // add number of subsequences that has length equal to LIS length\\n        int ores = 0;\\n        for(int i=0; i<dp.size(); i++){\\n            if(dp[i] == lis){\\n                ores += count[i];\\n            }\\n        }\\n        \\n        return ores;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050444,
                "title": "straightforward-javascript-dp-solution-faster-than-90-time-and-space",
                "content": "```\\n/**\\n* @param {number[]} nums\\n* @return {number}\\n*/\\nvar findNumberOfLIS = function(nums) {\\n    let dp = Array(nums.length).fill(1);\\n    let count = Array(nums.length).fill(1);\\n    \\n    let maxLen = 0;\\n    for(let i = 0; i < nums.length; i++) { // current one\\n        for(let j = 0; j < i; j++) { // compare to previous ones\\n            if(nums[j] < nums[i] && dp[j]+1 > dp[i]) {\\n                dp[i] = dp[j]+1;\\n                count[i] = count[j];\\n            } else if(nums[j] < nums[i] && dp[j]+1 === dp[i]) {\\n                count[i] += count[j];\\n            } \\n        }\\n        maxLen = Math.max(dp[i], maxLen);\\n    }\\n    \\n    let res = 0;\\n    for(let i = 0; i < count.length; i++) {\\n        if(dp[i] === maxLen) res += count[i];\\n    }\\n    \\n    return res;\\n};\\n```\\n\\nComplexity:\\ntime: O(N^2)\\nspace: O(N)\\n\\nSimilar to https://leetcode.com/problems/longest-increasing-subsequence/.\\n\\n**Basic Idea:** Compare each index i with each previous index j\\n1. Find the longest increasing subsequence\\n\\t\\n\\ta. At each interaction, check whether the longest subsequence ending up with index j is \\'extendable\\', i.e. whether nums[j] < nums[i]\\n\\t\\n\\tb. If so, then dp[i] = Math.max(dp[j]+1, dp[i])\\n\\n2. Count the number of longest increasing subsequence\\n\\t\\n\\ta. At each interation, if the dp[i] can be updated to a greater value, that means we have longer increasing subsequence(s) by extending from index j. The number of them is equal to the number of subsequence at j, i.e. count[i] = count[j].\\n\\t\\n\\tb. If the dp[i] is equal to \\'the greatest value\\' we currently have, then count[i] += count[j]\\n\\t\\n\\tc. The total count is equal to the sum of count of longest increasing subsequence\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n* @param {number[]} nums\\n* @return {number}\\n*/\\nvar findNumberOfLIS = function(nums) {\\n    let dp = Array(nums.length).fill(1);\\n    let count = Array(nums.length).fill(1);\\n    \\n    let maxLen = 0;\\n    for(let i = 0; i < nums.length; i++) { // current one\\n        for(let j = 0; j < i; j++) { // compare to previous ones\\n            if(nums[j] < nums[i] && dp[j]+1 > dp[i]) {\\n                dp[i] = dp[j]+1;\\n                count[i] = count[j];\\n            } else if(nums[j] < nums[i] && dp[j]+1 === dp[i]) {\\n                count[i] += count[j];\\n            } \\n        }\\n        maxLen = Math.max(dp[i], maxLen);\\n    }\\n    \\n    let res = 0;\\n    for(let i = 0; i < count.length; i++) {\\n        if(dp[i] === maxLen) res += count[i];\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924013,
                "title": "fast-12ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(const vector<int>& nums) {\\n        if (nums.empty())\\n            return 0;\\n        \\n        int n = nums.size();\\n\\n        vector<vector<int>> deck(n + 1);\\n        vector<vector<int>> path(n + 1);\\n\\n        int max_so_far = 0;\\n        for (int i = 0; i < n; ++i) {\\n            // bsearch insertion point\\n            // sorted from l to r\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (nums[i] > deck[mid].back()) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            \\n            // bsearch number of options\\n            int options = 1;\\n            int row = l - 1; // closest row with elements not greater than nums[i]\\n            if (row >= 0) {\\n                int l1 = 0, r1 = deck[row].size();\\n                // sorted from r to l\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (nums[i] > deck[row][mid]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                \\n                options = path[row].back();\\n                if (l1 != 0) // in a row was found element greater than nums[i]\\n                    options -= path[row][l1 - 1];\\n                //cout << nums[i] << \\' \\' << options << \\' \\' << l1 << endl;\\n            }\\n            \\n            deck[l].push_back(nums[i]);\\n            if (path[l].empty())\\n                path[l].push_back(options);\\n            else\\n                path[l].push_back(path[l].back() + options);\\n            \\n            if (l == max_so_far)\\n                max_so_far++;\\n        }\\n\\n        return path[max_so_far - 1].back();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findNumberOfLIS(const vector<int>& nums) {\\n        if (nums.empty())\\n            return 0;\\n        \\n        int n = nums.size();\\n\\n        vector<vector<int>> deck(n + 1);\\n        vector<vector<int>> path(n + 1);\\n\\n        int max_so_far = 0;\\n        for (int i = 0; i < n; ++i) {\\n            // bsearch insertion point\\n            // sorted from l to r\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (nums[i] > deck[mid].back()) {\\n                    l = mid + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 916696,
                "title": "the-art-of-dynamic-programming",
                "content": "**Synopsis:**\\n\\n[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nThese solutions incrementally build upon the previous [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/385203/The-ART-of-Dynamic-Programming) solutions.  Track the `best` LIS candidate `cand` ending at each index `j` of the input array `A`.  And also track the count `cnt` of each LIS ending at each index `j` of the input array `A`.  Whenever a new LIS candidate `cand` is found to be the `best` candidate ending at `j`, then we add onto the count of best LIS ending at `j` the count of best LIS ending at `i`, ie. `cnt[j] += cnt[i]`.  Return the highest `hi` count of the LIS.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        fun go(j: Int): Int {\\n            if (j == 0)\\n                return 1\\n            var best = 1\\n            for (i in 0 until j) {\\n                if (A[i] < A[j]) {\\n                    var cand = 1 + go(i)\\n                    if (best < cand) {\\n                        best = cand\\n                        cnt[j] = 0\\n                    }\\n                    if (best == cand)\\n                        cnt[j] += cnt[i]\\n                }\\n            }\\n            return best\\n        }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            var cand = go(j)\\n            if (best < cand) {\\n                best = cand\\n                hi = 0\\n            }\\n            if (best == cand)\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        fun go(j: Int): Int {\\n            if (j == 0)\\n                return 1\\n            if (!m.contains(j)) {\\n                var best = 1\\n                for (i in 0 until j) {\\n                    if (A[i] < A[j]) {\\n                        var cand = 1 + go(i)\\n                        if (best < cand) {\\n                            best = cand\\n                            cnt[j] = 0\\n                        }\\n                        if (best == cand)\\n                            cnt[j] += cnt[i]\\n                    }\\n                }\\n                m[j] = best\\n            }\\n            return m[j]!!\\n        }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            var cand = go(j)\\n            if (best < cand) {\\n                best = cand\\n                hi = 0\\n            }\\n            if (best == cand)\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        var dp = IntArray(N) { 1 }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            for (i in 0 until j) {\\n                if (A[i] < A[j]) {\\n                    if (dp[j] < 1 + dp[i]) {\\n                        dp[j] = 1 + dp[i]\\n                        cnt[j] = 0\\n                    }\\n                    if (dp[j] == 1 + dp[i])\\n                        cnt[j] += cnt[i]\\n                }\\n            }\\n            if (best < dp[j]) {\\n                best = dp[j]\\n                hi = 0\\n            }\\n            if (best == dp[j])\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet findNumberOfLIS = (A, best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let go = (j, best = 1) => {\\n        for (let i = 0; i < j; ++i) {\\n            if (A[i] < A[j]) {\\n                let cand = 1 + go(i);\\n                if (best < cand) {\\n                    best = cand;\\n                    cnt[j] = 0;\\n                }\\n                if (best == cand)\\n                    cnt[j] += cnt[i];\\n            }\\n        }\\n        return best;\\n    };\\n    for (let j = 0; j < N; ++j) {\\n        let cand = go(j);\\n        if (best < cand) {\\n            best = cand;\\n            hi = 0;\\n        }\\n        if (best == cand)\\n            hi += cnt[j];\\n    }\\n    return hi;\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet findNumberOfLIS = (A, m = new Map(), best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let go = j => {\\n        if (!j)\\n            return 1;\\n        if (!m.has(j)) {\\n            let best = 1;\\n            for (let i = 0; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    let cand = 1 + go(i);\\n                    if (best < cand) {\\n                        best = cand;\\n                        cnt[j] = 0;\\n                    }\\n                    if (best == cand)\\n                        cnt[j] += cnt[i];\\n                }\\n            }\\n            m.set(j, best);\\n        }\\n        return m.get(j);\\n    };\\n    for (let j = 0; j < N; ++j) {\\n        let cand = go(j);\\n        if (best < cand) {\\n            best = cand;\\n            hi = 0;\\n        }\\n        if (best == cand)\\n            hi += cnt[j];\\n    }\\n    return hi;\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet findNumberOfLIS = (A, best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let dp = Array(N).fill(1);\\n    for (let j = 0; j < N; ++j) {\\n        for (let i = 0; i < j; ++i) {\\n            if (A[i] < A[j]) {\\n                if (dp[j] < 1 + dp[i]) {\\n                    dp[j] = 1 + dp[i];\\n                    cnt[j] = 0;\\n                }\\n                if (dp[j] == 1 + dp[i])\\n                    cnt[j] += cnt[i];\\n            }\\n        }\\n        if (best < dp[j]) {\\n            best = dp[j];\\n            hi = 0;\\n        }\\n        if (best == dp[j])\\n            hi += cnt[j]\\n    }\\n    return hi;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        def go(j, best = 1):\\n            nonlocal cnt\\n            if j == 0:\\n                return 1\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    cand = 1 + go(i)\\n                    if best < cand:\\n                        best = cand\\n                        cnt[j] = 0\\n                    if best == cand:\\n                        cnt[j] += cnt[i]\\n            return best\\n        for j in range(N):\\n            cand = go(j)\\n            if best < cand:\\n                best = cand\\n                hi = 0\\n            if best == cand:\\n                hi += cnt[j]\\n        return hi\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        @cache\\n        def go(j, best = 1):\\n            nonlocal cnt\\n            if j == 0:\\n                return 1\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    cand = 1 + go(i)\\n                    if best < cand:\\n                        best = cand\\n                        cnt[j] = 0\\n                    if best == cand:\\n                        cnt[j] += cnt[i]\\n            return best\\n        for j in range(N):\\n            cand = go(j)\\n            if best < cand:\\n                best = cand\\n                hi = 0\\n            if best == cand:\\n                hi += cnt[j]\\n        return hi\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        dp = [1] * N\\n        for j in range(0, N):\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    if dp[j] < 1 + dp[i]:\\n                        dp[j] = 1 + dp[i]\\n                        cnt[j] = 0\\n                    if dp[j] == 1 + dp[i]:\\n                        cnt[j] += cnt[i]\\n            if best < dp[j]:\\n                best = dp[j]\\n                hi = 0\\n            if best == dp[j]:\\n                hi += cnt[j]\\n        return hi\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int findNumberOfLIS(VI& A, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        fun go = [&](auto j) {\\n            if (!j)\\n                return 1;\\n            auto best = 1;\\n            for (auto i{ 0 }; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    auto cand = 1 + go(i);\\n                    if (best < cand) {\\n                        best = cand;\\n                        cnt[j] = 0;\\n                    }\\n                    if (best == cand) {\\n                        cnt[j] += cnt[i];\\n                    }\\n                }\\n            }\\n            return best;\\n        };\\n        for (auto j{ 0 }; j < N; ++j) {\\n            auto cand = go(j);\\n            if (best < cand) {\\n                best = cand;\\n                hi = 0;\\n            }\\n            if (best == cand)\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int findNumberOfLIS(VI& A, Map m = {}, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        fun go = [&](auto j) {\\n            if (!j)\\n                return 1;\\n            if (m.find(j) == m.end()) {\\n                auto best = 1;\\n                for (auto i{ 0 }; i < j; ++i) {\\n                    if (A[i] < A[j]) {\\n                        auto cand = 1 + go(i);\\n                        if (best < cand) {\\n                            best = cand;\\n                            cnt[j] = 0;\\n                        }\\n                        if (best == cand) {\\n                            cnt[j] += cnt[i];\\n                        }\\n                    }\\n                }\\n                m[j] = best;\\n            }\\n            return m[j];\\n        };\\n        for (auto j{ 0 }; j < N; ++j) {\\n            auto cand = go(j);\\n            if (best < cand) {\\n                best = cand;\\n                hi = 0;\\n            }\\n            if (best == cand)\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findNumberOfLIS(VI& A, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        VI dp(N, 1);\\n        for (auto j{ 0 }; j < N; ++j) {\\n            for (auto i{ 0 }; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    if (dp[j] < 1 + dp[i]) {\\n                        dp[j] = 1 + dp[i];\\n                        cnt[j] = 0;\\n                    }\\n                    if (dp[j] == 1 + dp[i])\\n                        cnt[j] += cnt[i];\\n                }\\n            }\\n            if (best < dp[j]) {\\n                best = dp[j];\\n                hi = 0;\\n            }\\n            if (best == dp[j])\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        fun go(j: Int): Int {\\n            if (j == 0)\\n                return 1\\n            var best = 1\\n            for (i in 0 until j) {\\n                if (A[i] < A[j]) {\\n                    var cand = 1 + go(i)\\n                    if (best < cand) {\\n                        best = cand\\n                        cnt[j] = 0\\n                    }\\n                    if (best == cand)\\n                        cnt[j] += cnt[i]\\n                }\\n            }\\n            return best\\n        }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            var cand = go(j)\\n            if (best < cand) {\\n                best = cand\\n                hi = 0\\n            }\\n            if (best == cand)\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        fun go(j: Int): Int {\\n            if (j == 0)\\n                return 1\\n            if (!m.contains(j)) {\\n                var best = 1\\n                for (i in 0 until j) {\\n                    if (A[i] < A[j]) {\\n                        var cand = 1 + go(i)\\n                        if (best < cand) {\\n                            best = cand\\n                            cnt[j] = 0\\n                        }\\n                        if (best == cand)\\n                            cnt[j] += cnt[i]\\n                    }\\n                }\\n                m[j] = best\\n            }\\n            return m[j]!!\\n        }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            var cand = go(j)\\n            if (best < cand) {\\n                best = cand\\n                hi = 0\\n            }\\n            if (best == cand)\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findNumberOfLIS(A: IntArray): Int {\\n        var N = A.size\\n        var cnt = IntArray(N) { 1 }\\n        var dp = IntArray(N) { 1 }\\n        var (best, hi) = listOf(0, 0)\\n        for (j in 0 until N) {\\n            for (i in 0 until j) {\\n                if (A[i] < A[j]) {\\n                    if (dp[j] < 1 + dp[i]) {\\n                        dp[j] = 1 + dp[i]\\n                        cnt[j] = 0\\n                    }\\n                    if (dp[j] == 1 + dp[i])\\n                        cnt[j] += cnt[i]\\n                }\\n            }\\n            if (best < dp[j]) {\\n                best = dp[j]\\n                hi = 0\\n            }\\n            if (best == dp[j])\\n                hi += cnt[j]\\n        }\\n        return hi\\n    }\\n}\\n```\n```\\nlet findNumberOfLIS = (A, best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let go = (j, best = 1) => {\\n        for (let i = 0; i < j; ++i) {\\n            if (A[i] < A[j]) {\\n                let cand = 1 + go(i);\\n                if (best < cand) {\\n                    best = cand;\\n                    cnt[j] = 0;\\n                }\\n                if (best == cand)\\n                    cnt[j] += cnt[i];\\n            }\\n        }\\n        return best;\\n    };\\n    for (let j = 0; j < N; ++j) {\\n        let cand = go(j);\\n        if (best < cand) {\\n            best = cand;\\n            hi = 0;\\n        }\\n        if (best == cand)\\n            hi += cnt[j];\\n    }\\n    return hi;\\n};\\n```\n```\\nlet findNumberOfLIS = (A, m = new Map(), best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let go = j => {\\n        if (!j)\\n            return 1;\\n        if (!m.has(j)) {\\n            let best = 1;\\n            for (let i = 0; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    let cand = 1 + go(i);\\n                    if (best < cand) {\\n                        best = cand;\\n                        cnt[j] = 0;\\n                    }\\n                    if (best == cand)\\n                        cnt[j] += cnt[i];\\n                }\\n            }\\n            m.set(j, best);\\n        }\\n        return m.get(j);\\n    };\\n    for (let j = 0; j < N; ++j) {\\n        let cand = go(j);\\n        if (best < cand) {\\n            best = cand;\\n            hi = 0;\\n        }\\n        if (best == cand)\\n            hi += cnt[j];\\n    }\\n    return hi;\\n};\\n```\n```\\nlet findNumberOfLIS = (A, best = 0, hi = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(1);\\n    let dp = Array(N).fill(1);\\n    for (let j = 0; j < N; ++j) {\\n        for (let i = 0; i < j; ++i) {\\n            if (A[i] < A[j]) {\\n                if (dp[j] < 1 + dp[i]) {\\n                    dp[j] = 1 + dp[i];\\n                    cnt[j] = 0;\\n                }\\n                if (dp[j] == 1 + dp[i])\\n                    cnt[j] += cnt[i];\\n            }\\n        }\\n        if (best < dp[j]) {\\n            best = dp[j];\\n            hi = 0;\\n        }\\n        if (best == dp[j])\\n            hi += cnt[j]\\n    }\\n    return hi;\\n};\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        def go(j, best = 1):\\n            nonlocal cnt\\n            if j == 0:\\n                return 1\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    cand = 1 + go(i)\\n                    if best < cand:\\n                        best = cand\\n                        cnt[j] = 0\\n                    if best == cand:\\n                        cnt[j] += cnt[i]\\n            return best\\n        for j in range(N):\\n            cand = go(j)\\n            if best < cand:\\n                best = cand\\n                hi = 0\\n            if best == cand:\\n                hi += cnt[j]\\n        return hi\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        @cache\\n        def go(j, best = 1):\\n            nonlocal cnt\\n            if j == 0:\\n                return 1\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    cand = 1 + go(i)\\n                    if best < cand:\\n                        best = cand\\n                        cnt[j] = 0\\n                    if best == cand:\\n                        cnt[j] += cnt[i]\\n            return best\\n        for j in range(N):\\n            cand = go(j)\\n            if best < cand:\\n                best = cand\\n                hi = 0\\n            if best == cand:\\n                hi += cnt[j]\\n        return hi\\n```\n```\\nclass Solution:\\n    def findNumberOfLIS(self, A: List[int], hi = 0, best = 0) -> int:\\n        N = len(A)\\n        cnt = [1] * N\\n        dp = [1] * N\\n        for j in range(0, N):\\n            for i in range(j):\\n                if A[i] < A[j]:\\n                    if dp[j] < 1 + dp[i]:\\n                        dp[j] = 1 + dp[i]\\n                        cnt[j] = 0\\n                    if dp[j] == 1 + dp[i]:\\n                        cnt[j] += cnt[i]\\n            if best < dp[j]:\\n                best = dp[j]\\n                hi = 0\\n            if best == dp[j]:\\n                hi += cnt[j]\\n        return hi\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int findNumberOfLIS(VI& A, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        fun go = [&](auto j) {\\n            if (!j)\\n                return 1;\\n            auto best = 1;\\n            for (auto i{ 0 }; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    auto cand = 1 + go(i);\\n                    if (best < cand) {\\n                        best = cand;\\n                        cnt[j] = 0;\\n                    }\\n                    if (best == cand) {\\n                        cnt[j] += cnt[i];\\n                    }\\n                }\\n            }\\n            return best;\\n        };\\n        for (auto j{ 0 }; j < N; ++j) {\\n            auto cand = go(j);\\n            if (best < cand) {\\n                best = cand;\\n                hi = 0;\\n            }\\n            if (best == cand)\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int findNumberOfLIS(VI& A, Map m = {}, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        fun go = [&](auto j) {\\n            if (!j)\\n                return 1;\\n            if (m.find(j) == m.end()) {\\n                auto best = 1;\\n                for (auto i{ 0 }; i < j; ++i) {\\n                    if (A[i] < A[j]) {\\n                        auto cand = 1 + go(i);\\n                        if (best < cand) {\\n                            best = cand;\\n                            cnt[j] = 0;\\n                        }\\n                        if (best == cand) {\\n                            cnt[j] += cnt[i];\\n                        }\\n                    }\\n                }\\n                m[j] = best;\\n            }\\n            return m[j];\\n        };\\n        for (auto j{ 0 }; j < N; ++j) {\\n            auto cand = go(j);\\n            if (best < cand) {\\n                best = cand;\\n                hi = 0;\\n            }\\n            if (best == cand)\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findNumberOfLIS(VI& A, int hi = 0, int best = 0) {\\n        int N = A.size();\\n        VI cnt(N, 1);\\n        VI dp(N, 1);\\n        for (auto j{ 0 }; j < N; ++j) {\\n            for (auto i{ 0 }; i < j; ++i) {\\n                if (A[i] < A[j]) {\\n                    if (dp[j] < 1 + dp[i]) {\\n                        dp[j] = 1 + dp[i];\\n                        cnt[j] = 0;\\n                    }\\n                    if (dp[j] == 1 + dp[i])\\n                        cnt[j] += cnt[i];\\n                }\\n            }\\n            if (best < dp[j]) {\\n                best = dp[j];\\n                hi = 0;\\n            }\\n            if (best == dp[j])\\n                hi += cnt[j];\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480476,
                "title": "c-recursive-top-down-with-memoization-and-iterative-bottom-up-dp",
                "content": "Top Down :- \\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp;\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if(!nums.size()) return 0;\\n        dp.resize(nums.size(),{-1,1});\\n        int LIS = 0,ans = 0;\\n        f(nums.size() - 1,nums);\\n        for(auto x:dp) LIS = max(LIS,x.first);\\n        for(auto x:dp) if(x.first == LIS) ans += x.second;\\n        return ans;\\n    }\\n    \\n    int f(int i,vector<int>& nums){\\n        if(dp[i].first != -1) return dp[i].first;\\n        int ans = 1;\\n        for(int j = 0;j < i;j++){\\n            int val = f(j,nums);\\n            if(nums[i] > nums[j] and ans <= val + 1){\\n                if(ans == val + 1){\\n                    dp[i].second += dp[j].second;\\n                }\\n                else{\\n                    ans = val + 1;\\n                    dp[i].second = dp[j].second;\\n                }\\n            }\\n        }\\n        return dp[i].first = ans;\\n    }\\n};\\n```\\n\\nBottom Up :-\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<pair<int,int>>dp(nums.size(),{1,1});\\n        int maxSize = 1,ans = 0;\\n        for(int i = 0;i < nums.size();i++){\\n            for(int j = 0;j < i;j++){\\n                if(nums[j] < nums[i] and dp[i].first <= dp[j].first + 1){\\n                    if(dp[i].first == dp[j].first + 1) dp[i].second += dp[j].second;\\n                    else{\\n                        dp[i].first = dp[j].first + 1;\\n                        dp[i].second = dp[j].second;\\n                    }\\n                }\\n            }\\n            maxSize = max(maxSize,dp[i].first);\\n        }\\n        for(auto x:dp) if(x.first == maxSize) ans += x.second;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp;\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if(!nums.size()) return 0;\\n        dp.resize(nums.size(),{-1,1});\\n        int LIS = 0,ans = 0;\\n        f(nums.size() - 1,nums);\\n        for(auto x:dp) LIS = max(LIS,x.first);\\n        for(auto x:dp) if(x.first == LIS) ans += x.second;\\n        return ans;\\n    }\\n    \\n    int f(int i,vector<int>& nums){\\n        if(dp[i].first != -1) return dp[i].first;\\n        int ans = 1;\\n        for(int j = 0;j < i;j++){\\n            int val = f(j,nums);\\n            if(nums[i] > nums[j] and ans <= val + 1){\\n                if(ans == val + 1){\\n                    dp[i].second += dp[j].second;\\n                }\\n                else{\\n                    ans = val + 1;\\n                    dp[i].second = dp[j].second;\\n                }\\n            }\\n        }\\n        return dp[i].first = ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<pair<int,int>>dp(nums.size(),{1,1});\\n        int maxSize = 1,ans = 0;\\n        for(int i = 0;i < nums.size();i++){\\n            for(int j = 0;j < i;j++){\\n                if(nums[j] < nums[i] and dp[i].first <= dp[j].first + 1){\\n                    if(dp[i].first == dp[j].first + 1) dp[i].second += dp[j].second;\\n                    else{\\n                        dp[i].first = dp[j].first + 1;\\n                        dp[i].second = dp[j].second;\\n                    }\\n                }\\n            }\\n            maxSize = max(maxSize,dp[i].first);\\n        }\\n        for(auto x:dp) if(x.first == maxSize) ans += x.second;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294274,
                "title": "stupid-solution-but-work-p",
                "content": "Stupid solution, but work ;p\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        \\n        // populate longest dp\\n        int[] dp = new int[nums.length + 1];\\n        Arrays.fill(dp, 1);\\n        \\n        int[] counts = new int[nums.length + 1];\\n        counts[0] = 1;\\n        \\n        int longest = 1;\\n        for (int i = 1; i < nums.length; ++ i) {\\n            for (int j = 0; j < i; ++ j) {\\n                if (nums[j] < nums[i]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    longest = Math.max(longest, dp[i]);\\n                }\\n            }\\n            // init counts\\n            if (dp[i] == 1) {\\n                counts[i] = 1;\\n            }\\n        }\\n        \\n        // populate longest path count\\n        dp[nums.length] = longest + 1;\\n        \\n        for (int i = 1; i < dp.length; ++ i) {\\n            for (int j = 0; j < i; ++ j) {\\n                if (dp[j] + 1 == dp[i] \\n                    && (i == nums.length || nums[j] < nums[i])) {\\n                    counts[i] += counts[j];\\n                }\\n            }\\n        }\\n        return counts[nums.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        \\n        // populate longest dp\\n        int[] dp = new int[nums.length + 1];\\n        Arrays.fill(dp, 1);\\n        \\n        int[] counts = new int[nums.length + 1];\\n        counts[0] = 1;\\n        \\n        int longest = 1;\\n        for (int i = 1; i < nums.length; ++ i) {\\n            for (int j = 0; j < i; ++ j) {\\n                if (nums[j] < nums[i]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                    longest = Math.max(longest, dp[i]);\\n                }\\n            }\\n            // init counts\\n            if (dp[i] == 1) {\\n                counts[i] = 1;\\n            }\\n        }\\n        \\n        // populate longest path count\\n        dp[nums.length] = longest + 1;\\n        \\n        for (int i = 1; i < dp.length; ++ i) {\\n            for (int j = 0; j < i; ++ j) {\\n                if (dp[j] + 1 == dp[i] \\n                    && (i == nums.length || nums[j] < nums[i])) {\\n                    counts[i] += counts[j];\\n                }\\n            }\\n        }\\n        return counts[nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259427,
                "title": "c-dp-solution-updating-both-dp-length-and-dp-frequency",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size<2) return size;\\n        \\n        int result = 0;\\n        int longest = 0;\\n        vector<int> dp(size,1);\\n        vector<int> dpfreq(size,1);\\n        \\n        for (int i=1 ; i<size ; i++) {\\n            int freq = 1;\\n            for (int j=0 ; j<i ; j++) {\\n                if (nums[i]>nums[j]) {\\n                    if (dp[i]==dp[j]+1) {\\n                        dpfreq[i] += dpfreq[j];\\n                    }\\n                    else if (dp[i]<dp[j]+1) {\\n                        dp[i] = dp[j]+1;\\n                        dpfreq[i] = dpfreq[j];\\n                    }\\n                }\\n            }\\n            if (longest==dp[i]) {\\n                result+=dpfreq[i];\\n            }\\n            else if (longest<dp[i]) {\\n                longest = dp[i];\\n                result = dpfreq[i];\\n            }\\n        }\\n        if (longest==1) \\n            return size;\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size<2) return size;\\n        \\n        int result = 0;\\n        int longest = 0;\\n        vector<int> dp(size,1);\\n        vector<int> dpfreq(size,1);\\n        \\n        for (int i=1 ; i<size ; i++) {\\n            int freq = 1;\\n            for (int j=0 ; j<i ; j++) {\\n                if (nums[i]>nums[j]) {\\n                    if (dp[i]==dp[j]+1) {\\n                        dpfreq[i] += dpfreq[j];\\n                    }\\n                    else if (dp[i]<dp[j]+1) {\\n                        dp[i] = dp[j]+1;\\n                        dpfreq[i] = dpfreq[j];\\n                    }\\n                }\\n            }\\n            if (longest==dp[i]) {\\n                result+=dpfreq[i];\\n            }\\n            else if (longest<dp[i]) {\\n                longest = dp[i];\\n                result = dpfreq[i];\\n            }\\n        }\\n        if (longest==1) \\n            return size;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987207,
                "title": "time-o-n-logn-dp-with-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEX: a1= [1,3,5,4,7]\\n   normalise this to a2= [0,1,3,2,4]\\nanswer for a1 = answer for a2 .\\nwhy? because only quantity changed,but not relative order.\\nconsider this a part 1.\\nuse sorting, map to normalise.\\nNow u have part 1 .\\nlet us define our dp state.\\n   dp[i]= stores  two values \\n      1) len of longest strictly increasing subsequence ending at i.\\n      2) How many sequences of this above length are there, which    are ending at index i.\\n\\nHow to fill this dp table .\\n  two ways \\n   1) O(n*n)  , for each i , check the dp[j] \\'s where 0<=j<i and a2[j]<a2[i].  and fill correspondingly.,\\n   2) O(n*logn) , use segment tree \\n     \\n    for dp[i] , find(the max len and count of those max len sequences. which are ending with value strictly less than a2[i])\\n\\n\\nLastly why even part1?\\n   i am storing their values in segment trees , so to minimise the space of segment trees.\\n\\nThis is the idea.\\n  think for a minute and implement yourself in you way.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsegment trees to fill dp[i] in log(n)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*logn)$$\\n \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*logn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   static const int N=4*2*1e3;\\n    pair<int,int> seg[N];\\n    vector<int> arr;\\n    pair<int,int> helperUpdateMax(pair<int,int> a, pair<int,int> b)\\n    {\\n        if(a.first>b.first)\\n           return a;\\n        else if(a.first==b.first)\\n          {\\n              a.second+= b.second;\\n              return a;\\n          }\\n          return b;\\n    }\\n    void update(int i,int lo,int hi, int ind, pair<int,int> x)\\n    {\\n        if(ind<lo || ind>hi) return;\\n        if(lo==hi && lo==ind)\\n        {\\n            seg[i]=helperUpdateMax(seg[i],x);\\n            return;\\n        }\\n        int mid= (lo+hi)/2;\\n        update(2*i+1,lo,mid,ind,x);\\n        update(2*i+2,mid+1,hi,ind,x);\\n        seg[i]=helperUpdateMax(seg[2*i+1],seg[2*i+2]);\\n    \\n    }\\n    pair<int,int>  sum(int i,int lo,int hi , int l, int r)\\n    {\\n        if(l<=lo && r>=hi)\\n        {\\n            return seg[i];\\n        }\\n        if(r<lo || l>hi) return make_pair(0,0);\\n        int mid= (lo+hi)/2;\\n        return helperUpdateMax(sum(2*i+1,lo,mid,l,r),sum(2*i+2,mid+1,hi,l,r));\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n      \\n        vector<int> vec=nums;\\n        sort(vec.begin(),vec.end());\\n        map<int,int> mp;\\n        int ind=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(vec[i])==mp.end())\\n            {\\n                 mp[vec[i]]=ind++;\\n            }\\n        \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=mp[nums[i]];\\n        }\\n        for(int i=0;i<4*ind;i++)\\n        {\\n            seg[i]=make_pair(0,0);\\n        }\\n        int mx=1;\\n         pair<int,int> dp[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n             pair<int,int> x=sum(0,0,ind-1,0,nums[i]-1);\\n            dp[i]=x;\\n            dp[i].first++;\\n            if(dp[i].second==0) dp[i].second=1;\\n\\n            }\\n            else\\n            {\\n                dp[i]={1,1};\\n            }\\n            mx=max(mx,dp[i].first);\\n            update(0,0,ind-1,nums[i],dp[i]);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i].first==mx) cnt+=dp[i].second;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static const int N=4*2*1e3;\\n    pair<int,int> seg[N];\\n    vector<int> arr;\\n    pair<int,int> helperUpdateMax(pair<int,int> a, pair<int,int> b)\\n    {\\n        if(a.first>b.first)\\n           return a;\\n        else if(a.first==b.first)\\n          {\\n              a.second+= b.second;\\n              return a;\\n          }\\n          return b;\\n    }\\n    void update(int i,int lo,int hi, int ind, pair<int,int> x)\\n    {\\n        if(ind<lo || ind>hi) return;\\n        if(lo==hi && lo==ind)\\n        {\\n            seg[i]=helperUpdateMax(seg[i],x);\\n            return;\\n        }\\n        int mid= (lo+hi)/2;\\n        update(2*i+1,lo,mid,ind,x);\\n        update(2*i+2,mid+1,hi,ind,x);\\n        seg[i]=helperUpdateMax(seg[2*i+1],seg[2*i+2]);\\n    \\n    }\\n    pair<int,int>  sum(int i,int lo,int hi , int l, int r)\\n    {\\n        if(l<=lo && r>=hi)\\n        {\\n            return seg[i];\\n        }\\n        if(r<lo || l>hi) return make_pair(0,0);\\n        int mid= (lo+hi)/2;\\n        return helperUpdateMax(sum(2*i+1,lo,mid,l,r),sum(2*i+2,mid+1,hi,l,r));\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n      \\n        vector<int> vec=nums;\\n        sort(vec.begin(),vec.end());\\n        map<int,int> mp;\\n        int ind=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(vec[i])==mp.end())\\n            {\\n                 mp[vec[i]]=ind++;\\n            }\\n        \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=mp[nums[i]];\\n        }\\n        for(int i=0;i<4*ind;i++)\\n        {\\n            seg[i]=make_pair(0,0);\\n        }\\n        int mx=1;\\n         pair<int,int> dp[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n             pair<int,int> x=sum(0,0,ind-1,0,nums[i]-1);\\n            dp[i]=x;\\n            dp[i].first++;\\n            if(dp[i].second==0) dp[i].second=1;\\n\\n            }\\n            else\\n            {\\n                dp[i]={1,1};\\n            }\\n            mx=max(mx,dp[i].first);\\n            update(0,0,ind-1,nums[i],dp[i]);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i].first==mx) cnt+=dp[i].second;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803164,
                "title": "top-down-dfs-caching",
                "content": "\\n\\n# Brute Force\\n```python\\nclass Solution:\\n    freq = 0\\n    longest = 0\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        cnt = defaultdict(int)\\n        dp = {}\\n        def dfs(i, prev, length, ignored):\\n            if not ignored:\\n                cnt[length] += 1\\n            # Base case\\n            if i >= len(nums):\\n                return 0\\n            # can only choose if s-increasing\\n            choose = 0\\n            if nums[i] > prev:\\n                choose = 1 + dfs(i+1, nums[i], length + 1, 0)\\n            ignore = dfs(i+1, prev, length, 1)\\n            return max(ignore, choose)\\n        \\n        ans = dfs(0, -float(\\'inf\\'), 0, 0)\\n        return cnt[ans]\\n```\\n# Optimal(Caching)\\n```\\nclass Solution:\\n    freq = 0\\n    longest = 0\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        @cache\\n        def dfs(i, prev):\\n            # Base cases\\n            if i >= len(nums):\\n                return 0, 1\\n            # can only choose if s-increasing\\n            choose, choose_cnt = 0, 0\\n            if nums[i] > prev:\\n                choose, choose_cnt = dfs(i+1, nums[i])\\n                choose += 1\\n            ignore, ignore_cnt = dfs(i+1, prev)\\n            if ignore == choose:\\n                return choose, choose_cnt + ignore_cnt\\n            elif choose > ignore:\\n                return choose, choose_cnt\\n            return ignore, ignore_cnt\\n        \\n        ans, ans_cnt = dfs(0, -float(\\'inf\\'))\\n        return ans_cnt\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    freq = 0\\n    longest = 0\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        cnt = defaultdict(int)\\n        dp = {}\\n        def dfs(i, prev, length, ignored):\\n            if not ignored:\\n                cnt[length] += 1\\n            # Base case\\n            if i >= len(nums):\\n                return 0\\n            # can only choose if s-increasing\\n            choose = 0\\n            if nums[i] > prev:\\n                choose = 1 + dfs(i+1, nums[i], length + 1, 0)\\n            ignore = dfs(i+1, prev, length, 1)\\n            return max(ignore, choose)\\n        \\n        ans = dfs(0, -float(\\'inf\\'), 0, 0)\\n        return cnt[ans]\\n```\n```\\nclass Solution:\\n    freq = 0\\n    longest = 0\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        @cache\\n        def dfs(i, prev):\\n            # Base cases\\n            if i >= len(nums):\\n                return 0, 1\\n            # can only choose if s-increasing\\n            choose, choose_cnt = 0, 0\\n            if nums[i] > prev:\\n                choose, choose_cnt = dfs(i+1, nums[i])\\n                choose += 1\\n            ignore, ignore_cnt = dfs(i+1, prev)\\n            if ignore == choose:\\n                return choose, choose_cnt + ignore_cnt\\n            elif choose > ignore:\\n                return choose, choose_cnt\\n            return ignore, ignore_cnt\\n        \\n        ans, ans_cnt = dfs(0, -float(\\'inf\\'))\\n        return ans_cnt\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797231,
                "title": "best-python-solution-full-explanation-100",
                "content": "# Intuition\\n\\nTo solve this problem, we can use dynamic programming to find the number of longest increasing subsequences (LIS) in the input list nums. We can maintain two arrays, dp1 and dp2, where dp1[i] represents the length of the LIS ending at index i, and dp2[i] represents the count of such LIS. We initialize both arrays with all 1\\'s, as the minimum length of an LIS is 1, and each element can form an LIS of length 1.\\n\\n# Approach\\n\\nInitialize two arrays, dp1 and dp2, with all 1\\'s to store the length and count of LIS respectively.\\nInitialize count and maxval variables to track the maximum length and count of LIS found so far.\\nLoop through the elements of the nums list starting from the second element.\\nCompare the current element with all the previous elements (from 0 to i-1).\\nIf the current element is greater than a previous element, it can be part of an increasing subsequence. Update the dp1 and dp2 arrays accordingly to keep track of the length and count of LIS ending at each index.\\nTrack the maximum length of LIS (maxval) and the count of LIS of that length (count) found so far.\\nIf we encounter an LIS of greater length, update maxval and reset the count to the count of LIS for the current element. If we encounter an LIS of the same length, add the count of LIS for the current element to the existing count.\\nFinally, return the final count of longest increasing subsequences, which is stored in the count variable.\\nComplexity\\n\\n# Time complexity: The time complexity of this approach is O(n^2), where n is the length of the input list nums. This is because we have nested loops to compare each element with all previous elements.\\nSpace complexity: The space complexity is O(n) since we use two arrays, dp1 and dp2, to store the length and count of LIS, each of size n.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        # Check if the input list \\'nums\\' is empty\\n        if not nums:\\n            return 0\\n        \\n        # Initialize two arrays, dp1 and dp2, with all 1\\'s to store the length and count of LIS respectively\\n        dp1, dp2 = [1] * len(nums), [1] * len(nums)\\n        \\n        # Initialize \\'count\\' and \\'maxval\\' variables to track the maximum length and count of LIS found so far\\n        count, maxval = 1, 1\\n        \\n        # Loop through the \\'nums\\' list starting from the second element\\n        for i in range(1, len(nums)):\\n            # Compare the current element with all the previous elements (from 0 to i-1)\\n            for j in range(i):\\n                # If the current element is greater than the previous element, it can be part of the LIS\\n                if nums[i] > nums[j]:\\n                    # If the LIS ending at the current element (i) is longer than the LIS ending at the previous element (j),\\n                    # update the length and count of LIS for the current element (i)\\n                    if dp1[j] + 1 > dp1[i]:\\n                        dp1[i], dp2[i] = dp1[j] + 1, dp2[j]\\n                    # If the LIS ending at the current element (i) has the same length as the LIS ending at the previous element (j),\\n                    # add the count of LIS ending at the previous element (j) to the count of LIS for the current element (i)\\n                    elif dp1[j] + 1 == dp1[i]:\\n                        dp2[i] += dp2[j]\\n\\n            # Update \\'maxval\\' and \\'count\\' if the length of LIS for the current element (i) is greater than or equal to \\'maxval\\'\\n            if dp1[i] > maxval:\\n                maxval, count = dp1[i], dp2[i]\\n            elif dp1[i] == maxval:\\n                count += dp2[i]\\n\\n        # Return the final count of longest increasing subsequences\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        # Check if the input list \\'nums\\' is empty\\n        if not nums:\\n            return 0\\n        \\n        # Initialize two arrays, dp1 and dp2, with all 1\\'s to store the length and count of LIS respectively\\n        dp1, dp2 = [1] * len(nums), [1] * len(nums)\\n        \\n        # Initialize \\'count\\' and \\'maxval\\' variables to track the maximum length and count of LIS found so far\\n        count, maxval = 1, 1\\n        \\n        # Loop through the \\'nums\\' list starting from the second element\\n        for i in range(1, len(nums)):\\n            # Compare the current element with all the previous elements (from 0 to i-1)\\n            for j in range(i):\\n                # If the current element is greater than the previous element, it can be part of the LIS\\n                if nums[i] > nums[j]:\\n                    # If the LIS ending at the current element (i) is longer than the LIS ending at the previous element (j),\\n                    # update the length and count of LIS for the current element (i)\\n                    if dp1[j] + 1 > dp1[i]:\\n                        dp1[i], dp2[i] = dp1[j] + 1, dp2[j]\\n                    # If the LIS ending at the current element (i) has the same length as the LIS ending at the previous element (j),\\n                    # add the count of LIS ending at the previous element (j) to the count of LIS for the current element (i)\\n                    elif dp1[j] + 1 == dp1[i]:\\n                        dp2[i] += dp2[j]\\n\\n            # Update \\'maxval\\' and \\'count\\' if the length of LIS for the current element (i) is greater than or equal to \\'maxval\\'\\n            if dp1[i] > maxval:\\n                maxval, count = dp1[i], dp2[i]\\n            elif dp1[i] == maxval:\\n                count += dp2[i]\\n\\n        # Return the final count of longest increasing subsequences\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796953,
                "title": "beats-99-4-video-cracking-the-code-dp-longest-increasing-subsequences",
                "content": "# Intuition\\nUpon seeing this problem, I realized that it was a classic dynamic programming problem. It\\'s about finding the number of longest strictly increasing subsequences in an array. A sequence is increasing if every number is larger than the one before. The intuition here was to keep track of two lists: one for the length of the longest increasing subsequence ending at each index, and another for the count of such subsequences.\\n\\nhttps://youtu.be/yqAwQtoT9jk\\n\\n# Approach\\nMy approach involves initializing two lists: `dp` and `count`, both filled initially with ones, representing the length and count of the longest subsequence ending at each index. \\n\\nThen, using a nested loop, every pair of indices are compared. If a number larger than the current one is found, it means we can extend the subsequence. In this case, `dp` and `count` lists are updated accordingly. \\n\\nFinally, the maximum length of the subsequences is found using the `max` function on the `dp` list. Then the counts of subsequences that have this maximum length are summed up, which yields our final answer.\\n\\n# Complexity\\n- Time complexity: \\nThe time complexity for this approach is O(n^2), where n is the size of the input list. This is due to the nested loop comparing each pair of indices.\\n\\n- Space complexity: \\nThe space complexity is O(n), which is used to store the `dp` and `count` lists.\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = [1] * len(nums) \\n        count = [1] * len(nums) \\n        for i in range(len(nums)): \\n            for j in range(i): \\n                if nums[i] > nums[j]: \\n                    if dp[j] >= dp[i]: \\n                        dp[i] = dp[j] + 1  \\n                        count[i] = count[j]  \\n                    elif dp[j] + 1 == dp[i]:  \\n                        count[i] += count[j]  \\n        max_length = max(dp) \\n        return sum(c for d, c in zip(dp, count) if d == max_length)\\n```\\n``` JavaScript []\\nvar findNumberOfLIS = function(nums) {\\n    let n = nums.length, res = 0, max_len = 0; \\n    let len = new Array(n).fill(0), cnt = new Array(n).fill(0); \\n    for(let i = 0; i < n; i++){ \\n            len[i] = cnt[i] = 1; \\n        for(let j = 0; j < i; j++){ \\n            if(nums[i] > nums[j]){ \\n                if(len[i] == len[j] + 1) \\n                    cnt[i] += cnt[j]; \\n                if(len[i] < len[j] + 1){ \\n                    len[i] = len[j] + 1; \\n                    cnt[i] = cnt[j]; \\n                } \\n            } \\n        } \\n        if(max_len == len[i]) \\n            res += cnt[i]; \\n        if(max_len < len[i]){ \\n            max_len = len[i]; \\n            res = cnt[i]; \\n        } \\n    } \\n    return res;            \\n};\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n\\n        int n = nums.size(), res = 0, max_len = 0; \\n        vector<int> len(n, 0), cnt(n, 0); \\n        for(int i=0; i<n; i++){ \\n            len[i] = cnt[i] = 1; \\n            for(int j=0; j <i; j++){ \\n                if(nums[i] > nums[j]){ \\n                    if(len[i] == len[j] + 1) \\n                        cnt[i] += cnt[j]; \\n                    if(len[i] < len[j] + 1){ \\n                        len[i] = len[j] + 1; \\n                        cnt[i] = cnt[j]; \\n                    } \\n                } \\n            } \\n            if(max_len == len[i]) \\n                res += cnt[i]; \\n            if(max_len < len[i]){ \\n                max_len = len[i]; \\n                res = cnt[i]; \\n            } \\n        } \\n        return res; \\n                                                                                                                                                                                                                                                                                                                                              \\n    }\\n};\\n```\\nI hope this approach provides a clear solution to the problem. Please comment below if you have any questions!",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = [1] * len(nums) \\n        count = [1] * len(nums) \\n        for i in range(len(nums)): \\n            for j in range(i): \\n                if nums[i] > nums[j]: \\n                    if dp[j] >= dp[i]: \\n                        dp[i] = dp[j] + 1  \\n                        count[i] = count[j]  \\n                    elif dp[j] + 1 == dp[i]:  \\n                        count[i] += count[j]  \\n        max_length = max(dp) \\n        return sum(c for d, c in zip(dp, count) if d == max_length)\\n```\n``` JavaScript []\\nvar findNumberOfLIS = function(nums) {\\n    let n = nums.length, res = 0, max_len = 0; \\n    let len = new Array(n).fill(0), cnt = new Array(n).fill(0); \\n    for(let i = 0; i < n; i++){ \\n            len[i] = cnt[i] = 1; \\n        for(let j = 0; j < i; j++){ \\n            if(nums[i] > nums[j]){ \\n                if(len[i] == len[j] + 1) \\n                    cnt[i] += cnt[j]; \\n                if(len[i] < len[j] + 1){ \\n                    len[i] = len[j] + 1; \\n                    cnt[i] = cnt[j]; \\n                } \\n            } \\n        } \\n        if(max_len == len[i]) \\n            res += cnt[i]; \\n        if(max_len < len[i]){ \\n            max_len = len[i]; \\n            res = cnt[i]; \\n        } \\n    } \\n    return res;            \\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n\\n        int n = nums.size(), res = 0, max_len = 0; \\n        vector<int> len(n, 0), cnt(n, 0); \\n        for(int i=0; i<n; i++){ \\n            len[i] = cnt[i] = 1; \\n            for(int j=0; j <i; j++){ \\n                if(nums[i] > nums[j]){ \\n                    if(len[i] == len[j] + 1) \\n                        cnt[i] += cnt[j]; \\n                    if(len[i] < len[j] + 1){ \\n                        len[i] = len[j] + 1; \\n                        cnt[i] = cnt[j]; \\n                    } \\n                } \\n            } \\n            if(max_len == len[i]) \\n                res += cnt[i]; \\n            if(max_len < len[i]){ \\n                max_len = len[i]; \\n                res = cnt[i]; \\n            } \\n        } \\n        return res; \\n                                                                                                                                                                                                                                                                                                                                              \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796150,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn this problem, we are given an integer array nums, we need to return the number of longest increasing subsequences. We use dynamic programming to find the number of longest increasing subsequences (LIS) in the vector nums. We do this by maintaining two vectors, length and count, to track the length and count of LIS ending at each index. The solution then finds the maximum length and counts the number of subsequences with that length.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe explanation is as follows:\\n- Create two vectors length and count, both of size n, initialized with 1.\\n- Iterate through nums to update length and count for each index by considering previous elements.\\n- Find the maxLength of the LIS by taking the maximum value from the length vector.\\n- Count the number of subsequences with length equal to maxLength.\\n- Return the count of longest increasing subsequences.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> length(n,1);\\n        vector<int> count(n,1);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(length[j]+1>length[i]){\\n                        length[i]=length[j]+1;\\n                        count[i]=0;\\n                    }\\n                    if(length[j]+1==length[i]) count[i]+=count[j];\\n                }\\n            }\\n        }\\n        int maxLength= *max_element(length.begin(),length.end());\\n        int result=0;\\n        for(int i=0;i<n;i++){\\n            if(length[i]==maxLength) result+=count[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> length(n,1);\\n        vector<int> count(n,1);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(length[j]+1>length[i]){\\n                        length[i]=length[j]+1;\\n                        count[i]=0;\\n                    }\\n                    if(length[j]+1==length[i]) count[i]+=count[j];\\n                }\\n            }\\n        }\\n        int maxLength= *max_element(length.begin(),length.end());\\n        int result=0;\\n        for(int i=0;i<n;i++){\\n            if(length[i]==maxLength) result+=count[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794909,
                "title": "c-solution-for-number-of-longest-increasing-subsequence-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find the number of longest increasing subsequences. We can use dynamic programming to solve this problem efficiently. The idea is to maintain two arrays to track the length of the longest increasing subsequence ending at each index and the count of such subsequences. By updating these arrays while iterating through the array, we can find the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize two arrays lengths and counts of the same length as the input array nums. These arrays will be used to track the length of the longest increasing subsequence ending at each index and the count of such subsequences.\\n- Initialize each element in both arrays to 1, as each element itself is an increasing subsequence of length 1.\\n- Iterate through the array nums starting from the second element (index 1).\\n- For each element nums[i], compare it with all the previous elements in the array (indices 0 to i-1).\\n- If nums[i] is greater than the previous element nums[j], it can be part of a longer increasing subsequence. We update lengths[i] and counts[i] accordingly:\\n1. If lengths[j] + 1 > lengths[i], it means we found a longer increasing subsequence ending at nums[i]. So, update lengths[i] = lengths[j] + 1 and set counts[i] = counts[j].\\n1. If lengths[j] + 1 == lengths[i], it means we found another increasing subsequence of the same length as the current longest ending at nums[i]. So, increment counts[i] by counts[j].\\n- Keep track of the maximum length found so far (maxLength).\\n- After iterating through the array, we will have the length of the longest increasing subsequence (maxLength). Now, iterate through the lengths array again to count the number of subsequences with length equal to maxLength. Sum up the counts for such subsequences to get the final result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(n^2), where n is the length of the input array nums. This is because we use two nested loops to compare each element with all previous elements.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) as we use two arrays of size n (lengths and counts) to keep track of the length of subsequences and their counts.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        int n = nums.Length;\\n        if (n == 0) return 0;\\n        \\n        int[] lengths = new int[n]; // To store the length of the longest increasing subsequence ending at each index\\n        int[] counts = new int[n];  // To store the count of such subsequences\\n        \\n        // Initialize lengths and counts arrays with default values\\n        for (int i = 0; i < n; i++) {\\n            lengths[i] = 1; // Each element is an increasing subsequence of length 1\\n            counts[i] = 1;  // Each element itself is a subsequence\\n        }\\n        \\n        int maxLength = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (lengths[j] + 1 > lengths[i]) {\\n                        lengths[i] = lengths[j] + 1;\\n                        counts[i] = counts[j];\\n                    } else if (lengths[j] + 1 == lengths[i]) {\\n                        counts[i] += counts[j];\\n                    }\\n                }\\n            }\\n            maxLength = Math.Max(maxLength, lengths[i]);\\n        }\\n        \\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (lengths[i] == maxLength) {\\n                result += counts[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        int n = nums.Length;\\n        if (n == 0) return 0;\\n        \\n        int[] lengths = new int[n]; // To store the length of the longest increasing subsequence ending at each index\\n        int[] counts = new int[n];  // To store the count of such subsequences\\n        \\n        // Initialize lengths and counts arrays with default values\\n        for (int i = 0; i < n; i++) {\\n            lengths[i] = 1; // Each element is an increasing subsequence of length 1\\n            counts[i] = 1;  // Each element itself is a subsequence\\n        }\\n        \\n        int maxLength = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                    if (lengths[j] + 1 > lengths[i]) {\\n                        lengths[i] = lengths[j] + 1;\\n                        counts[i] = counts[j];\\n                    } else if (lengths[j] + 1 == lengths[i]) {\\n                        counts[i] += counts[j];\\n                    }\\n                }\\n            }\\n            maxLength = Math.Max(maxLength, lengths[i]);\\n        }\\n        \\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (lengths[i] == maxLength) {\\n                result += counts[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794850,
                "title": "c-dp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n       int n=nums.size();\\n\\n       vector<int>dp(n,1),ct(n,1); \\n       int mx_len=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=i-1;j>=0;j--){\\n               if(nums[i]>nums[j]){\\n                   if(dp[i]<1+dp[j]){\\n                       ct[i]=ct[j];\\n                   }else if(dp[i]==1+dp[j]){\\n                       ct[i]+=ct[j];\\n                   }\\n                   dp[i]=max(dp[i],1+dp[j]);\\n               }\\n           }\\n           mx_len=max(mx_len,dp[i]);\\n       }\\n       int ans=0;\\n       for(int i=0;i<n;i++)if(dp[i]==mx_len)ans+=ct[i];\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n       int n=nums.size();\\n\\n       vector<int>dp(n,1),ct(n,1); \\n       int mx_len=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=i-1;j>=0;j--){\\n               if(nums[i]>nums[j]){\\n                   if(dp[i]<1+dp[j]){\\n                       ct[i]=ct[j];\\n                   }else if(dp[i]==1+dp[j]){\\n                       ct[i]+=ct[j];\\n                   }\\n                   dp[i]=max(dp[i],1+dp[j]);\\n               }\\n           }\\n           mx_len=max(mx_len,dp[i]);\\n       }\\n       int ans=0;\\n       for(int i=0;i<n;i++)if(dp[i]==mx_len)ans+=ct[i];\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606978,
                "title": "longest-increasing-subsequence-variant",
                "content": "# Intuition\\nThe problem asks us to find the number of longest increasing subsequences in the given array. To solve this problem efficiently, we can use dynamic programming.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), where n is the size of the input array nums. The outer loop runs for n iterations, and the inner loop also runs for a maximum of n iterations.\\n\\n- Space complexity:\\nThe space complexity is O(n) since we are using two additional vectors, dp and cnt, both of size n, to store the lengths of subsequences and their counts.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;  // maximum length of lis\\n        vector<int> dp(n,1);            // stores length of longest sequence till i-th position\\n        vector<int> cnt(n,1);           // stores count of longest sequence of length dp[ind]\\n        for(int ind = 0;ind<n;ind++){\\n            for(int j = 0;j<ind;j++){\\n\\n                if(nums[j]<nums[ind]){\\n                    if(1+dp[j]>dp[ind]){    // strictly increasing\\n                        dp[ind] = 1+dp[j];\\n                        cnt[ind] = cnt[j];\\n                    }else if(1+dp[j]==dp[ind]){ // if there are more subsequences of same length ending at length dp[ind]\\n                        cnt[ind] += cnt[j];\\n                    }\\n                }\\n            }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n\\n        int nos = 0; // count all the LIS of length maxi\\n        for(int i = 0;i<n;i++){\\n            if(dp[i]==maxi) nos+=cnt[i];\\n        }\\n        return nos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;  // maximum length of lis\\n        vector<int> dp(n,1);            // stores length of longest sequence till i-th position\\n        vector<int> cnt(n,1);           // stores count of longest sequence of length dp[ind]\\n        for(int ind = 0;ind<n;ind++){\\n            for(int j = 0;j<ind;j++){\\n\\n                if(nums[j]<nums[ind]){\\n                    if(1+dp[j]>dp[ind]){    // strictly increasing\\n                        dp[ind] = 1+dp[j];\\n                        cnt[ind] = cnt[j];\\n                    }else if(1+dp[j]==dp[ind]){ // if there are more subsequences of same length ending at length dp[ind]\\n                        cnt[ind] += cnt[j];\\n                    }\\n                }\\n            }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n\\n        int nos = 0; // count all the LIS of length maxi\\n        for(int i = 0;i<n;i++){\\n            if(dp[i]==maxi) nos+=cnt[i];\\n        }\\n        return nos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426984,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if (nums.empty()) {\\n            return 0;\\n        }\\n        vector<vector<pair<int, int>>> dyn(nums.size() + 1);\\n        int max_so_far = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (dyn[mid].back().first < nums[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            int options = 1;\\n            int row = l - 1;\\n            if (row >= 0) {\\n                int l1 = 0, r1 = dyn[row].size();\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (dyn[row][mid].first < nums[i]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                options = dyn[row].back().second; \\n                options -= (l1 == 0) ? 0 : dyn[row][l1 - 1].second;\\n            }\\n            dyn[l].push_back({nums[i], (dyn[l].empty() ? options : dyn[l].back().second + options)});\\n            if (l == max_so_far) {\\n                max_so_far++;\\n            }\\n        }\\n        return dyn[max_so_far-1].back().second;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom typing import List\\nimport bisect\\n\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n    \\n        decks, ends_decks, paths = [], [], []\\n        for num in nums:\\n            deck_idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if deck_idx > 0:\\n                l = bisect.bisect(decks[deck_idx-1], -num)\\n                n_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n                \\n            if deck_idx == len(decks):\\n                decks.append([-num])\\n                ends_decks.append(num)\\n                paths.append([0,n_paths])\\n            else:\\n                decks[deck_idx].append(-num)\\n                ends_decks[deck_idx] = num\\n                paths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n              \\n        return paths[-1][-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n       int num = nums.length;\\n       List<int[]>[] len = new ArrayList[num];\\n       for(int i = 0; i< num ; i++){\\n           len[i] = new ArrayList<>();\\n       }\\n       int size = 0;\\n       for(int n : nums){\\n           int index = bSearchLength(len,size,n);\\n           int count = 1;\\n\\n           if(index > 0){\\n               List<int[]> t = len[index-1];\\n               int p = bSearchIndex(t,n);\\n               count = t.get(t.size()-1)[1] - (p == 0 ? 0 : t.get(p-1)[1]);\\n           }\\n           if(len[index].size()==0){\\n               len[index].add(new int[]{n,count});\\n               size++;\\n           } else {\\n               List<int[]> t = len[index];\\n               int[] last = t.get(t.size()-1);\\n               int ch = last[1]+count;\\n               if(last[0] == n){\\n                   last[1]+=count;\\n               } else {\\n                   t.add(new int[]{n,last[1]+count});\\n               }\\n           }\\n       }\\n       return len[size-1].get(len[size-1].size()-1)[1];\\n    }\\n    public int bSearchLength(List<int[]>[] len,int right,int n){\\n        int left = 0;\\n         while(left<right){\\n                int mid = (left+right)/2;\\n                if(n > len[mid].get(len[mid].size()-1)[0])\\n                    left = mid + 1;\\n                else\\n                    right = mid;\\n        }\\n        return left;\\n    }\\n    public int bSearchIndex(List<int[]> t,int num){\\n        int left = 0 , right = t.size()-1;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            if(num <= t.get(mid)[0])\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if (nums.empty()) {\\n            return 0;\\n        }\\n        vector<vector<pair<int, int>>> dyn(nums.size() + 1);\\n        int max_so_far = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            int l = 0, r = max_so_far;\\n            while (l < r) {\\n                int mid = l + (r - l) / 2;\\n                if (dyn[mid].back().first < nums[i]) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            int options = 1;\\n            int row = l - 1;\\n            if (row >= 0) {\\n                int l1 = 0, r1 = dyn[row].size();\\n                while (l1 < r1) {\\n                    int mid = l1 + (r1 - l1) / 2;\\n                    if (dyn[row][mid].first < nums[i]) {\\n                        r1 = mid;\\n                    } else {\\n                        l1 = mid + 1;\\n                    }\\n                }\\n                options = dyn[row].back().second; \\n                options -= (l1 == 0) ? 0 : dyn[row][l1 - 1].second;\\n            }\\n            dyn[l].push_back({nums[i], (dyn[l].empty() ? options : dyn[l].back().second + options)});\\n            if (l == max_so_far) {\\n                max_so_far++;\\n            }\\n        }\\n        return dyn[max_so_far-1].back().second;\\n    }\\n};\\n```\n```Python3 []\\nfrom typing import List\\nimport bisect\\n\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n    \\n        decks, ends_decks, paths = [], [], []\\n        for num in nums:\\n            deck_idx = bisect.bisect_left(ends_decks, num)\\n            n_paths = 1\\n            if deck_idx > 0:\\n                l = bisect.bisect(decks[deck_idx-1], -num)\\n                n_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n                \\n            if deck_idx == len(decks):\\n                decks.append([-num])\\n                ends_decks.append(num)\\n                paths.append([0,n_paths])\\n            else:\\n                decks[deck_idx].append(-num)\\n                ends_decks[deck_idx] = num\\n                paths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n              \\n        return paths[-1][-1]\\n```\n```Java []\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n       int num = nums.length;\\n       List<int[]>[] len = new ArrayList[num];\\n       for(int i = 0; i< num ; i++){\\n           len[i] = new ArrayList<>();\\n       }\\n       int size = 0;\\n       for(int n : nums){\\n           int index = bSearchLength(len,size,n);\\n           int count = 1;\\n\\n           if(index > 0){\\n               List<int[]> t = len[index-1];\\n               int p = bSearchIndex(t,n);\\n               count = t.get(t.size()-1)[1] - (p == 0 ? 0 : t.get(p-1)[1]);\\n           }\\n           if(len[index].size()==0){\\n               len[index].add(new int[]{n,count});\\n               size++;\\n           } else {\\n               List<int[]> t = len[index];\\n               int[] last = t.get(t.size()-1);\\n               int ch = last[1]+count;\\n               if(last[0] == n){\\n                   last[1]+=count;\\n               } else {\\n                   t.add(new int[]{n,last[1]+count});\\n               }\\n           }\\n       }\\n       return len[size-1].get(len[size-1].size()-1)[1];\\n    }\\n    public int bSearchLength(List<int[]>[] len,int right,int n){\\n        int left = 0;\\n         while(left<right){\\n                int mid = (left+right)/2;\\n                if(n > len[mid].get(len[mid].size()-1)[0])\\n                    left = mid + 1;\\n                else\\n                    right = mid;\\n        }\\n        return left;\\n    }\\n    public int bSearchIndex(List<int[]> t,int num){\\n        int left = 0 , right = t.size()-1;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            if(num <= t.get(mid)[0])\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311369,
                "title": "c-dp-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n, 1), cnt(n, 1);\\n        int maxi=1, ans=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]>nums[j] && dp[i]<dp[j]+1){\\n                    dp[i]=1+dp[j];\\n                    cnt[i]=cnt[j];\\n                }\\n                else if(nums[i]>nums[j] && dp[i]==1+dp[j]){\\n                    cnt[i]+=cnt[j];\\n                }\\n            }\\n            maxi=max(maxi, dp[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(dp[i]==maxi){\\n                ans+=cnt[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n, 1), cnt(n, 1);\\n        int maxi=1, ans=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]>nums[j] && dp[i]<dp[j]+1){\\n                    dp[i]=1+dp[j];\\n                    cnt[i]=cnt[j];\\n                }\\n                else if(nums[i]>nums[j] && dp[i]==1+dp[j]){\\n                    cnt[i]+=cnt[j];\\n                }\\n            }\\n            maxi=max(maxi, dp[i]);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(dp[i]==maxi){\\n                ans+=cnt[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288914,
                "title": "c-simplest-solution-lis-pattern-dp-striver",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), cut(n, 1);\\n        int maxi = INT_MIN;\\n        int ans = 0;\\n        for (int ind=0; ind<n; ind++) {\\n            for (int prev=0; prev<ind; prev++) {\\n                if (arr[prev] < arr[ind] && 1 + dp[prev] > dp[ind]) {\\n                    dp[ind] = 1 + dp[prev];\\n                    cut[ind] = cut[prev];\\n                }\\n                else if(arr[prev] < arr[ind] && 1 + dp[prev] == dp[ind]) {\\n                    cut[ind] += cut[prev];\\n                }\\n            }\\n            maxi = max(maxi, dp[ind]);\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] == maxi) ans += cut[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), cut(n, 1);\\n        int maxi = INT_MIN;\\n        int ans = 0;\\n        for (int ind=0; ind<n; ind++) {\\n            for (int prev=0; prev<ind; prev++) {\\n                if (arr[prev] < arr[ind] && 1 + dp[prev] > dp[ind]) {\\n                    dp[ind] = 1 + dp[prev];\\n                    cut[ind] = cut[prev];\\n                }\\n                else if(arr[prev] < arr[ind] && 1 + dp[prev] == dp[ind]) {\\n                    cut[ind] += cut[prev];\\n                }\\n            }\\n            maxi = max(maxi, dp[ind]);\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] == maxi) ans += cut[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217439,
                "title": "binary-indexed-tree-fenwick-tree-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://leetcode.com/problems/number-of-longest-increasing-subsequence/solutions/112521/c-short-binary-indexed-tree-beats-98-54-with-comments/\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n\\n        class BIT:\\n            # There are 2 binary index trees\\n            # one to store the longest increasing subsequence up until a given index\\n            # second to store the count of this lic at given index \\n            def __init__(self, size) -> None:\\n                self.size = size + 1\\n                self.lic = [0] * self.size\\n                self.count = [0] * self.size\\n\\n            def update(self, idx, lic, count):\\n                idx += 1\\n                while idx < self.size:\\n                    if self.lic[idx] == lic:\\n                        self.count[idx] += count\\n                    elif self.lic[idx] < lic:\\n                        self.lic[idx] = lic\\n                        self.count[idx] = count\\n                    idx += idx & (-idx)\\n\\n            def query(self, idx):\\n                lic = 0\\n                count = 0\\n                idx += 1\\n                while idx > 0:\\n                    if self.lic[idx] == lic:\\n                        count += self.count[idx]\\n                    elif self.lic[idx] > lic:\\n                        lic = self.lic[idx]\\n                        count = self.count[idx]\\n                    idx -= idx & (-idx)\\n                return lic, count \\n\\n        def solve(nums):\\n            temp = sorted(set(nums))\\n            n = len(temp)\\n            bit = BIT(n)\\n            maxlength = 0\\n            total = 0\\n            for num in nums:\\n                idx = bisect.bisect_left(temp, num)\\n                # get the values up until this index\\n                lic, count = bit.query(idx - 1)\\n                # add the inclusion of this iterated value in its lic\\n                lic += 1\\n                if lic == 1:\\n                    count = 1\\n                if lic == maxlength:\\n                    total += count\\n                elif lic > maxlength:\\n                    maxlength = lic\\n                    total = count\\n                bit.update(idx, lic, count)\\n            return total\\n\\n        return solve(nums)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n\\n        class BIT:\\n            # There are 2 binary index trees\\n            # one to store the longest increasing subsequence up until a given index\\n            # second to store the count of this lic at given index \\n            def __init__(self, size) -> None:\\n                self.size = size + 1\\n                self.lic = [0] * self.size\\n                self.count = [0] * self.size\\n\\n            def update(self, idx, lic, count):\\n                idx += 1\\n                while idx < self.size:\\n                    if self.lic[idx] == lic:\\n                        self.count[idx] += count\\n                    elif self.lic[idx] < lic:\\n                        self.lic[idx] = lic\\n                        self.count[idx] = count\\n                    idx += idx & (-idx)\\n\\n            def query(self, idx):\\n                lic = 0\\n                count = 0\\n                idx += 1\\n                while idx > 0:\\n                    if self.lic[idx] == lic:\\n                        count += self.count[idx]\\n                    elif self.lic[idx] > lic:\\n                        lic = self.lic[idx]\\n                        count = self.count[idx]\\n                    idx -= idx & (-idx)\\n                return lic, count \\n\\n        def solve(nums):\\n            temp = sorted(set(nums))\\n            n = len(temp)\\n            bit = BIT(n)\\n            maxlength = 0\\n            total = 0\\n            for num in nums:\\n                idx = bisect.bisect_left(temp, num)\\n                # get the values up until this index\\n                lic, count = bit.query(idx - 1)\\n                # add the inclusion of this iterated value in its lic\\n                lic += 1\\n                if lic == 1:\\n                    count = 1\\n                if lic == maxlength:\\n                    total += count\\n                elif lic > maxlength:\\n                    maxlength = lic\\n                    total = count\\n                bit.update(idx, lic, count)\\n            return total\\n\\n        return solve(nums)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093617,
                "title": "c-dp-solution-with-explanation-in-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int sol(vector<int>& nums,int n){\\n        vector<int>list(n);//lenght of LIS ending at index i\\n        vector<int>count(n,1);//number of LIS that can be generated at index i\\n        list[0]=1;\\n        for(int i=1;i<n;i++){\\n            list[i]=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && list[i]<list[j]+1)\\n                {\\n                    list[i]=list[j]+1;//Since we are encountering a new LIS  we will not increase the count\\n                    count[i]=count[j];\\n                }   \\n                else if(nums[i]>nums[j] && list[i]==list[j]+1){\\n                    //we are getting more than one lis since we already have a lenght of that particular lis present in our list array\\n                    count[i]=count[j]+count[i];//count array will store no of lis ending at i possible\\n//list array will store the length of lis ending at index i so count will store no of ways to get that particular LIS\\n                }\\n            }\\n    }\\n    \\n   int maxi=*max_element(list.begin(),list.end());\\n   int q=0;\\n   for(int i=0;i<list.size();i++){\\n       if(list[i]==maxi)\\n       q+=count[i];\\n   }\\n    return q;\\n}\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        return sol(nums,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sol(vector<int>& nums,int n){\\n        vector<int>list(n);//lenght of LIS ending at index i\\n        vector<int>count(n,1);//number of LIS that can be generated at index i\\n        list[0]=1;\\n        for(int i=1;i<n;i++){\\n            list[i]=1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && list[i]<list[j]+1)\\n                {\\n                    list[i]=list[j]+1;//Since we are encountering a new LIS  we will not increase the count\\n                    count[i]=count[j];\\n                }   \\n                else if(nums[i]>nums[j] && list[i]==list[j]+1){\\n                    //we are getting more than one lis since we already have a lenght of that particular lis present in our list array\\n                    count[i]=count[j]+count[i];//count array will store no of lis ending at i possible\\n//list array will store the length of lis ending at index i so count will store no of ways to get that particular LIS\\n                }\\n            }\\n    }\\n    \\n   int maxi=*max_element(list.begin(),list.end());\\n   int q=0;\\n   for(int i=0;i<list.size();i++){\\n       if(list[i]==maxi)\\n       q+=count[i];\\n   }\\n    return q;\\n}\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        return sol(nums,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863465,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> lis(n,1);  \\n        vector<int> count(n,1);  \\n        int maxLen = 1;  \\n\\t\\t\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(lis[j] + 1 > lis[i]){ \\n                        lis[i] = lis[j] + 1;\\n                        count[i] = count[j];\\n                    } \\n\\t\\t\\t\\t\\telse if(lis[j]+1 == lis[i]){ \\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLen = max(maxLen,lis[i]);\\n        }\\n        \\n        int numOfLIS = 0;\\n        for(int i=0;i<n;i++){\\n            if(lis[i]==maxLen)\\n                numOfLIS += count[i];\\n        }\\n            \\n        return numOfLIS;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findNumberOfLIS(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> lis(n,1);  \\n        vector<int> count(n,1);  \\n        int maxLen = 1;  \\n\\t\\t\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j]){\\n                    if(lis[j] + 1 > lis[i]){ \\n                        lis[i] = lis[j] + 1;\\n                        count[i] = count[j];\\n                    } \\n\\t\\t\\t\\t\\telse if(lis[j]+1 == lis[i]){ \\n                        count[i] += count[j];\\n                    }\\n                }\\n            }\\n            maxLen = max(maxLen,lis[i]);\\n        }\\n        \\n        int numOfLIS = 0;\\n        for(int i=0;i<n;i++){\\n            if(lis[i]==maxLen)\\n                numOfLIS += count[i];\\n        }\\n            \\n        return numOfLIS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718014,
                "title": "easy-and-explained-in-detail-java-solution-with-a-small-tweak-in-lis-must-refer",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] a) {\\n        int size = a.length;\\n        int[] dp = new int[size];\\n        int[] count = new int[size];\\n        Arrays.fill(dp , 1);\\n        Arrays.fill(count , 1);\\n        int maxLen = 0;\\n        \\n        for( int i=0 ; i<size ; i++ ){\\n            for( int prev=0 ; prev<i ; prev++ ){\\n                if(a[i] > a[prev]){\\n                    if(1 + dp[prev] > dp[i]){\\n                       dp[i] = 1 + dp[prev];\\n                       count[i] = count[prev]; // As LIS till i is now adding the LIS till prev. So no. of LIS of this length till i will become the no. of LIS at prev . Since count[prev] is holding the no. of LIS of length dp[prev] till prev index and we are just adding a[i] in our LIS till i. So count[i] becomes equal to count[prev]\\n                    }else if(1 + dp[prev] == dp[i]){  \\n                        count[i] += count[prev] ; // Since, no of LIS of this length \"1 + dp[prev]\" is already here at count[i]. Therefore count of LIS of this length increases by no of LIS of that length at count[prev].\\n                    }\\n                }\\n            }\\n            \\n            if(dp[i] > maxLen){\\n                maxLen = dp[i];\\n            }\\n        }\\n        \\n        int noOfLIS = 0;\\n        for( int i=0 ; i<size ; i++ ){\\n            if(dp[i] == maxLen) noOfLIS += count[i];\\n        }\\n        \\n        return noOfLIS;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] a) {\\n        int size = a.length;\\n        int[] dp = new int[size];\\n        int[] count = new int[size];\\n        Arrays.fill(dp , 1);\\n        Arrays.fill(count , 1);\\n        int maxLen = 0;\\n        \\n        for( int i=0 ; i<size ; i++ ){\\n            for( int prev=0 ; prev<i ; prev++ ){\\n                if(a[i] > a[prev]){\\n                    if(1 + dp[prev] > dp[i]){\\n                       dp[i] = 1 + dp[prev];\\n                       count[i] = count[prev]; // As LIS till i is now adding the LIS till prev. So no. of LIS of this length till i will become the no. of LIS at prev . Since count[prev] is holding the no. of LIS of length dp[prev] till prev index and we are just adding a[i] in our LIS till i. So count[i] becomes equal to count[prev]\\n                    }else if(1 + dp[prev] == dp[i]){  \\n                        count[i] += count[prev] ; // Since, no of LIS of this length \"1 + dp[prev]\" is already here at count[i]. Therefore count of LIS of this length increases by no of LIS of that length at count[prev].\\n                    }\\n                }\\n            }\\n            \\n            if(dp[i] > maxLen){\\n                maxLen = dp[i];\\n            }\\n        }\\n        \\n        int noOfLIS = 0;\\n        for( int i=0 ; i<size ; i++ ){\\n            if(dp[i] == maxLen) noOfLIS += count[i];\\n        }\\n        \\n        return noOfLIS;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584413,
                "title": "java-lis-technique-easy-intuitive",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n];\\n        int cnt[]=new int[n]; /*For count array*/\\n        Arrays.fill(dp,1);\\n        Arrays.fill(cnt,1);\\n        int max=1;\\n        int res=0;\\n        for(int ind=0;ind<n;ind++){\\n            for(int prev=0;prev<ind;prev++){\\n                if(nums[ind]>nums[prev] && 1+dp[prev]>dp[ind]){\\n                    dp[ind]=1+dp[prev];\\n                    cnt[ind]=cnt[prev]; /*If its largest then inherit or copy the count\\n\\t\\t\\t\\t\\t                      from previous element*/\\n                }\\n                else if(nums[ind]>nums[prev] && 1+dp[prev]==dp[ind]){\\n                    cnt[ind]=cnt[ind]+cnt[prev]; /*If the lis length is same then count the \\n\\t\\t\\t\\t\\t                               different occurences of same length by adding \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   the current count and previous count so that \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   we can know the number of occurences \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   of same length. */\\n                }\\n            }\\n            if(dp[ind]>max){\\n                max=dp[ind];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==max) /*After finding the length of lis which is in max, we just traverse the dp array \\n\\t\\t\\t                 and whichever element has same max length, their corresponding \\n\\t\\t\\t\\t\\t\\t\\t count from cnt will be added.*/ \\n                res+=cnt[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n];\\n        int cnt[]=new int[n]; /*For count array*/\\n        Arrays.fill(dp,1);\\n        Arrays.fill(cnt,1);\\n        int max=1;\\n        int res=0;\\n        for(int ind=0;ind<n;ind++){\\n            for(int prev=0;prev<ind;prev++){\\n                if(nums[ind]>nums[prev] && 1+dp[prev]>dp[ind]){\\n                    dp[ind]=1+dp[prev];\\n                    cnt[ind]=cnt[prev]; /*If its largest then inherit or copy the count\\n\\t\\t\\t\\t\\t                      from previous element*/\\n                }\\n                else if(nums[ind]>nums[prev] && 1+dp[prev]==dp[ind]){\\n                    cnt[ind]=cnt[ind]+cnt[prev]; /*If the lis length is same then count the \\n\\t\\t\\t\\t\\t                               different occurences of same length by adding \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   the current count and previous count so that \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   we can know the number of occurences \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   of same length. */\\n                }\\n            }\\n            if(dp[ind]>max){\\n                max=dp[ind];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==max) /*After finding the length of lis which is in max, we just traverse the dp array \\n\\t\\t\\t                 and whichever element has same max length, their corresponding \\n\\t\\t\\t\\t\\t\\t\\t count from cnt will be added.*/ \\n                res+=cnt[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314035,
                "title": "c-dp-lis-variation",
                "content": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n\\tint findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n=nums.size(), maxi=1;\\n        vector<int> dp(n,1), cnt(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                \\n                if(nums[j]<nums[i] && dp[j]+1>dp[i]){\\n                    dp[i]=dp[j]+1;\\n                    cnt[i]=cnt[j];\\n                }\\n                else if(nums[j]<nums[i] && dp[i]==dp[j]+1){\\n                    cnt[i]+=cnt[j];\\n                }\\n            }\\n            maxi=max(maxi,dp[i]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==maxi){\\n                ans+=cnt[i];\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!!***\\n\\t\\n\\tint findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n=nums.size(), maxi=1;\\n        vector<int> dp(n,1), cnt(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                \\n                if(nums[j]<nums[i] && dp[j]+1>dp[i]){\\n                    dp[i]=dp[j]+1;\\n                    cnt[i]=cnt[j];\\n                }\\n                else if(nums[j]<nums[i] && dp[i]==dp[j]+1){\\n                    cnt[i]+=cnt[j];\\n                }\\n            }\\n            maxi=max(maxi,dp[i]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==maxi){\\n                ans+=cnt[i];\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2188960,
                "title": "c-dp-solution-longest-increasing-subsequence-array-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // O(N^2) DP Solution\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;  // maximum length of lis\\n        vector<int> dp(n,1);            // stores length of longest sequence till i-th position\\n        vector<int> cnt(n,1);           // stores count of longest sequence of length dp[ind]\\n        for(int ind = 0;ind<n;ind++){\\n            for(int j = 0;j<ind;j++){\\n\\n                if(nums[j]<nums[ind]){\\n                    if(1+dp[j]>dp[ind]){    // strictly increasing\\n                        dp[ind] = 1+dp[j];\\n                        cnt[ind] = cnt[j];\\n                    }else if(1+dp[j]==dp[ind]){ // if there are more subsequences of same length ending at length dp[ind]\\n                        cnt[ind] += cnt[j];\\n                    }\\n                }\\n            }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n\\n        int nos = 0; // count all the LIS of length maxi\\n        for(int i = 0;i<n;i++){\\n            if(dp[i]==maxi) nos+=cnt[i];\\n        }\\n        return nos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(N^2) DP Solution\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;  // maximum length of lis\\n        vector<int> dp(n,1);            // stores length of longest sequence till i-th position\\n        vector<int> cnt(n,1);           // stores count of longest sequence of length dp[ind]\\n        for(int ind = 0;ind<n;ind++){\\n            for(int j = 0;j<ind;j++){\\n\\n                if(nums[j]<nums[ind]){\\n                    if(1+dp[j]>dp[ind]){    // strictly increasing\\n                        dp[ind] = 1+dp[j];\\n                        cnt[ind] = cnt[j];\\n                    }else if(1+dp[j]==dp[ind]){ // if there are more subsequences of same length ending at length dp[ind]\\n                        cnt[ind] += cnt[j];\\n                    }\\n                }\\n            }\\n            maxi = max(maxi,dp[ind]);\\n        }\\n\\n        int nos = 0; // count all the LIS of length maxi\\n        for(int i = 0;i<n;i++){\\n            if(dp[i]==maxi) nos+=cnt[i];\\n        }\\n        return nos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881188,
                "title": "python-dp-solution-explained",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = [1] * len(nums)\\n        ct = [1] * len(nums)\\n        maxLen, maxCt = 0, 0\\n        \\n        # same as the LIS code, iterate\\n        # over all the elements once and then\\n        # from 0 -> i again to compute LISs\\n        for i in range(len(nums)):\\n            for j in range(i):\\n                # If it\\'s a valid LIS\\n                if nums[i] > nums[j]:\\n                    # and if the length\\n                    # of LIS at i wrt j\\n                    # is going to be increased\\n                    # update the length dp\\n                    # and since this is just one\\n                    # continous LIS, count of i\\n                    # will become same as that of j\\n                    if dp[j]+1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        ct[i] = ct[j]\\n                    # if on the other hand, the\\n                    # length of the LIS at i becomes\\n                    # the same as it was, it means\\n                    # there\\'s another LIS of this same\\n                    # length, in this case, add the LIS\\n                    # count of j to i, because the current\\n                    # LIS count at i consists of ways to get\\n                    # to this LIS from another path, and now\\n                    # we\\'re at a new path, so sum thse up\\n                    # there\\'s no point\\n                    # in updating the length LIS here.\\n                    elif dp[i] == dp[j] + 1:\\n                        ct[i] += ct[j]\\n            \\n            # at any point, keep track\\n            # of the maxLen and maxCt\\n            # we\\'ll use it to compute our result\\n            if dp[i] > maxLen:\\n                maxLen = dp[i]\\n                \\n        # now, we have the maxLength\\n        # of the given nums, we can iterate\\n        # over all 3 arrays (hypothetically)\\n        # and just add up the count of all those\\n        # LIS which are the longest (maxLen)\\n        # and that\\'s the result\\n        for i in range(len(nums)):\\n            if maxLen == dp[i]:\\n                maxCt += ct[i]\\n    \\n \\n        return maxCt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        dp = [1] * len(nums)\\n        ct = [1] * len(nums)\\n        maxLen, maxCt = 0, 0\\n        \\n        # same as the LIS code, iterate\\n        # over all the elements once and then\\n        # from 0 -> i again to compute LISs\\n        for i in range(len(nums)):\\n            for j in range(i):\\n                # If it\\'s a valid LIS\\n                if nums[i] > nums[j]:\\n                    # and if the length\\n                    # of LIS at i wrt j\\n                    # is going to be increased\\n                    # update the length dp\\n                    # and since this is just one\\n                    # continous LIS, count of i\\n                    # will become same as that of j\\n                    if dp[j]+1 > dp[i]:\\n                        dp[i] = dp[j] + 1\\n                        ct[i] = ct[j]\\n                    # if on the other hand, the\\n                    # length of the LIS at i becomes\\n                    # the same as it was, it means\\n                    # there\\'s another LIS of this same\\n                    # length, in this case, add the LIS\\n                    # count of j to i, because the current\\n                    # LIS count at i consists of ways to get\\n                    # to this LIS from another path, and now\\n                    # we\\'re at a new path, so sum thse up\\n                    # there\\'s no point\\n                    # in updating the length LIS here.\\n                    elif dp[i] == dp[j] + 1:\\n                        ct[i] += ct[j]\\n            \\n            # at any point, keep track\\n            # of the maxLen and maxCt\\n            # we\\'ll use it to compute our result\\n            if dp[i] > maxLen:\\n                maxLen = dp[i]\\n                \\n        # now, we have the maxLength\\n        # of the given nums, we can iterate\\n        # over all 3 arrays (hypothetically)\\n        # and just add up the count of all those\\n        # LIS which are the longest (maxLen)\\n        # and that\\'s the result\\n        for i in range(len(nums)):\\n            if maxLen == dp[i]:\\n                maxCt += ct[i]\\n    \\n \\n        return maxCt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853678,
                "title": "c-easy-to-understand-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0)\\n            return 0;\\n        vector<int>dp(n,1);\\n        vector<int>count(n,1);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(1+dp[j]>dp[i])\\n                    {\\n                        dp[i]=1+dp[j];\\n                        count[i]=count[j];\\n                    }\\n                    else if(1+dp[j]==dp[i])\\n                        count[i]+=count[j];     \\n                }\\n                    \\n            }\\n            ans = max(ans,dp[i]);\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==ans)\\n                res+=count[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\nThe main idea is that we have to count no. of ways to get the max value of LIS.For that we will traverse our dp array.Search for all the places where max lis is.Also we will keep a count array and when we check nums[i]>nums[j],there we also check the dp value.If 1+dp[j]==dp[i] then we will add the count of j to count of i.\\nCode is simple to understand.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0)\\n            return 0;\\n        vector<int>dp(n,1);\\n        vector<int>count(n,1);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(1+dp[j]>dp[i])\\n                    {\\n                        dp[i]=1+dp[j];\\n                        count[i]=count[j];\\n                    }\\n                    else if(1+dp[j]==dp[i])\\n                        count[i]+=count[j];     \\n                }\\n                    \\n            }\\n            ans = max(ans,dp[i]);\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==ans)\\n                res+=count[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853107,
                "title": "python-dp-basically-another-climbing-stairs",
                "content": "We have two goals: \\n1. For a position i in nums, we want to first know which position j (could be many of them) has the longest subsequence for j < i and nums[j] < nums[i]. This follows the idea from #300 longest increasing subsequence https://leetcode.com/problems/longest-increasing-subsequence/ \\n2. Then I want to know like climbing stairs, for each j, how many ways are there to get to j from the begining, adding these ways up gives me the ways to get to i with longest steps. Here we are not limited by \"taking 1 or 2 stairs at a time\" like in climbing stairs, instead we find out steps possible by looking at positions having the longest subsequence \\n\\nTo do this we create two dp list: \\n1. dpl for the length of longest subsequence ending on index i\\n2. dpw for number of ways to generate longest subsequence ending on index i\\n\\n\\n\\t\\tdef findNumberOfLIS(self, nums: List[int]) -> int:\\n\\t\\t\\tdpl = [1 for _ in range(len(nums))] # length  \\n\\t\\t\\tdpw = [0 for _ in range(len(nums))] # ways \\n\\t\\t\\tdpw[0] = 1 \\n\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\t# create a list for all the lengths before i\\n\\t\\t\\t\\tpredpl = [dpl[j] if nums[j] < nums[i] else 0 for j in range(i)] \\n\\t\\t\\t\\tpremax = max(predpl)\\n\\t\\t\\t\\tdpl[i] = premax + 1\\n\\n\\t\\t\\t\\tif premax == 0: # handle the edge case where there is no possible j before i\\n\\t\\t\\t\\t\\tdpw[i] = 1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tfor j in range(len(predpl)):\\n\\t\\t\\t\\t\\t\\t# find the longest subsequence and add up their \"ways\"\\n\\t\\t\\t\\t\\t\\t# similar to climb_stair(n) = climb_stair(n-1) + climb_stair(n-2) \\n\\t\\t\\t\\t\\t\\tif predpl[j] == premax: \\n\\t\\t\\t\\t\\t\\t\\tdpw[i] += dpw[j]\\n\\n\\t\\t\\tdpmax = max(dpl)\\n\\t\\t\\tcounter = 0 \\n\\t\\t\\tfor i in range(len(dpl)): \\n\\t\\t\\t\\tif dpl[i] == dpmax: \\n\\t\\t\\t\\t\\tcounter += dpw[i]\\n\\n\\t\\t\\treturn counter",
                "solutionTags": [],
                "code": "We have two goals: \\n1. For a position i in nums, we want to first know which position j (could be many of them) has the longest subsequence for j < i and nums[j] < nums[i]. This follows the idea from #300 longest increasing subsequence https://leetcode.com/problems/longest-increasing-subsequence/ \\n2. Then I want to know like climbing stairs, for each j, how many ways are there to get to j from the begining, adding these ways up gives me the ways to get to i with longest steps. Here we are not limited by \"taking 1 or 2 stairs at a time\" like in climbing stairs, instead we find out steps possible by looking at positions having the longest subsequence \\n\\nTo do this we create two dp list: \\n1. dpl for the length of longest subsequence ending on index i\\n2. dpw for number of ways to generate longest subsequence ending on index i\\n\\n\\n\\t\\tdef findNumberOfLIS(self, nums: List[int]) -> int:\\n\\t\\t\\tdpl = [1 for _ in range(len(nums))] # length  \\n\\t\\t\\tdpw = [0 for _ in range(len(nums))] # ways \\n\\t\\t\\tdpw[0] = 1 \\n\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\t# create a list for all the lengths before i\\n\\t\\t\\t\\tpredpl = [dpl[j] if nums[j] < nums[i] else 0 for j in range(i)] \\n\\t\\t\\t\\tpremax = max(predpl)\\n\\t\\t\\t\\tdpl[i] = premax + 1\\n\\n\\t\\t\\t\\tif premax == 0: # handle the edge case where there is no possible j before i\\n\\t\\t\\t\\t\\tdpw[i] = 1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tfor j in range(len(predpl)):\\n\\t\\t\\t\\t\\t\\t# find the longest subsequence and add up their \"ways\"\\n\\t\\t\\t\\t\\t\\t# similar to climb_stair(n) = climb_stair(n-1) + climb_stair(n-2) \\n\\t\\t\\t\\t\\t\\tif predpl[j] == premax: \\n\\t\\t\\t\\t\\t\\t\\tdpw[i] += dpw[j]\\n\\n\\t\\t\\tdpmax = max(dpl)\\n\\t\\t\\tcounter = 0 \\n\\t\\t\\tfor i in range(len(dpl)): \\n\\t\\t\\t\\tif dpl[i] == dpmax: \\n\\t\\t\\t\\t\\tcounter += dpw[i]\\n\\n\\t\\t\\treturn counter",
                "codeTag": "Python3"
            },
            {
                "id": 1603381,
                "title": "recursion-python",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        memo = {}\\n        def helper(prev_num=float(\\'-inf\\'), curr_i=0):\\n            if curr_i == len(nums):\\n                return 0, 1\\n            if (prev_num, curr_i) in memo:\\n                return memo[(prev_num, curr_i)]\\n            if prev_num == float(\\'-inf\\') or prev_num < nums[curr_i]:\\n                length_1, count_1 = helper(nums[curr_i], curr_i + 1)\\n                length_2, count_2 = helper(prev_num, curr_i + 1)\\n                if length_1 + 1 > length_2:\\n                    memo[(prev_num, curr_i)] = length_1 + 1, count_1\\n                elif length_2 > length_1 + 1:\\n                    memo[(prev_num, curr_i)] = length_2, count_2\\n                else:\\n                    memo[(prev_num, curr_i)] = length_2, count_1 + count_2\\n\\n            else:\\n                memo[(prev_num, curr_i)] = helper(prev_num, curr_i + 1)\\n            return memo[(prev_num, curr_i)]\\n\\n        l, c = helper()\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        memo = {}\\n        def helper(prev_num=float(\\'-inf\\'), curr_i=0):\\n            if curr_i == len(nums):\\n                return 0, 1\\n            if (prev_num, curr_i) in memo:\\n                return memo[(prev_num, curr_i)]\\n            if prev_num == float(\\'-inf\\') or prev_num < nums[curr_i]:\\n                length_1, count_1 = helper(nums[curr_i], curr_i + 1)\\n                length_2, count_2 = helper(prev_num, curr_i + 1)\\n                if length_1 + 1 > length_2:\\n                    memo[(prev_num, curr_i)] = length_1 + 1, count_1\\n                elif length_2 > length_1 + 1:\\n                    memo[(prev_num, curr_i)] = length_2, count_2\\n                else:\\n                    memo[(prev_num, curr_i)] = length_2, count_1 + count_2\\n\\n            else:\\n                memo[(prev_num, curr_i)] = helper(prev_num, curr_i + 1)\\n            return memo[(prev_num, curr_i)]\\n\\n        l, c = helper()\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596517,
                "title": "c-lis-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int> lis(nums.size(),1),f(nums.size(),1);\\n        int mx=1,ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lis[i]<lis[j]+1){\\n                        lis[i]=1+lis[j];\\n                        f[i]=f[j];\\n                    }\\n                    else if(lis[i]==1+lis[j])f[i]+=f[j];\\n                }\\n            }\\n            mx=max(mx,lis[i]);\\n        }\\n        for(int j=0;j<nums.size();j++)if(lis[j]==mx)ans+=f[j];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int> lis(nums.size(),1),f(nums.size(),1);\\n        int mx=1,ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    if(lis[i]<lis[j]+1){\\n                        lis[i]=1+lis[j];\\n                        f[i]=f[j];\\n                    }\\n                    else if(lis[i]==1+lis[j])f[i]+=f[j];\\n                }\\n            }\\n            mx=max(mx,lis[i]);\\n        }\\n        for(int j=0;j<nums.size();j++)if(lis[j]==mx)ans+=f[j];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518162,
                "title": "c-clean-solution-dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int> len(nums.size(),1),times(nums.size(),1);\\n        int maxlen=0;\\n        for(int i=1;i<nums.size();++i){\\n            for(int j=0;j<i;++j){\\n                if(nums[j] < nums[i]){\\n                    if(len[j]+1 > len[i]){\\n                        len[i]=len[j]+1;\\n                        times[i] = times[j];\\n                    }\\n                    else if(len[j]+1 ==len[i])\\n                        times[i]+=times[j];\\n                }\\n                maxlen=max(maxlen,len[i]);\\n            }\\n        }\\n       int count=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(len[i] == maxlen)\\n                count+=times[i];\\n        }\\n        if(count==0) return 1;\\n        return count;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int> len(nums.size(),1),times(nums.size(),1);\\n        int maxlen=0;\\n        for(int i=1;i<nums.size();++i){\\n            for(int j=0;j<i;++j){\\n                if(nums[j] < nums[i]){\\n                    if(len[j]+1 > len[i]){\\n                        len[i]=len[j]+1;\\n                        times[i] = times[j];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1493942,
                "title": "java-o-n-logn-segment-tree-array-based-and-tree-based-versions-beats-98",
                "content": "Tree-based version (6 ms):\\n```\\nclass Solution {\\n\\n    public int findNumberOfLIS(int[] nums) {\\n        Segment root = new Segment((int) -1e6, (int) 1e6);\\n        for (int num : nums) {\\n            Sequence s = root.query(num - 1);\\n            root.update(num, new Sequence(s.length + 1, s.count));\\n        }\\n        return root.sequence.count;\\n    }\\n\\n    private static class Segment {\\n        final int left;\\n        final int middle;\\n        final int right;\\n        \\n        Segment leftChild;\\n        Segment rightChild;\\n        \\n        Sequence sequence = Sequence.EMPTY;\\n        \\n        Segment(int left, int right) {\\n            this.left = left;\\n            this.middle = left + (right - left) / 2;\\n            this.right = right;\\n        }\\n        \\n        void update(int value, Sequence s) {\\n            this.sequence = this.sequence.merge(s);\\n            \\n            if (this.left == this.middle) {\\n                return;\\n            }\\n            \\n            if (value < this.middle) {\\n                if (this.leftChild == null) {\\n                    this.leftChild = new Segment(this.left, this.middle);\\n                }\\n                this.leftChild.update(value, s);\\n            } else {\\n                if (this.rightChild == null) {\\n                    this.rightChild = new Segment(this.middle, this.right);\\n                }\\n                this.rightChild.update(value, s);\\n            }\\n        }\\n        \\n        Sequence query(int value) {\\n            if (this.left == this.middle) {\\n                return this.sequence;\\n            }\\n            \\n            if (value < this.middle) {\\n                return this.leftChild != null ? this.leftChild.query(value) : Sequence.EMPTY;\\n\\n            } else {\\n                Sequence left = this.leftChild != null ? this.leftChild.sequence : Sequence.EMPTY;\\n                Sequence right = this.rightChild != null ? this.rightChild.query(value) : Sequence.EMPTY;\\n                return left.merge(right);\\n            }\\n        }\\n    }\\n\\n    private static class Sequence {\\n        final int length;\\n        final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n        \\n        Sequence merge(Sequence other) {\\n            if (other.length > this.length) {\\n                return other;\\n            }\\n            if (other.length < this.length) {\\n                return this;\\n            }\\n            return new Sequence(length, this.count + other.count);\\n        }\\n        \\n        static final Sequence EMPTY = new Sequence(0, 1) {\\n            Sequence merge(Sequence other) {\\n                return other.length > this.length ? other : this;\\n            }\\n        };\\n    }\\n}\\n```\\n\\nArray-based version (with coordinate compression, 9ms):\\n```\\nclass Solution {\\n    \\n    public int findNumberOfLIS(int[] nums) {\\n\\t\\t// first coordinate compression\\n        int n = nums.length;\\n        Integer[] indexes = new Integer[n];\\n        for (int i = 0; i < n; i++) {\\n            indexes[i] = i;\\n        }\\n        \\n        Arrays.sort(indexes, Comparator.comparingInt(i -> nums[i]));\\n        \\n        int coordinate = 1;\\n        int[] coordinates = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            while (i < n - 1 && nums[indexes[i]] == nums[indexes[i + 1]]) {\\n                coordinates[indexes[i++]] = coordinate;\\n            }\\n            coordinates[indexes[i]] = coordinate++;\\n        }\\n        \\n\\t\\t// then using compressed coordinates to build the tree\\n        SegmentTree tree = new SegmentTree(coordinate);\\n        for (int i = 0; i < n; i++) {\\n            Sequence s = tree.query(coordinates[i] - 1);\\n            tree.update(coordinates[i], new Sequence(s.length + 1, s.count));\\n        }\\n        return tree.query(coordinate - 1).count;\\n    }\\n    \\n    private static class SegmentTree {\\n        \\n        private final int n;\\n        private final Sequence[] tree;\\n        \\n        SegmentTree(int n) {\\n            this.n = n;\\n            this.tree = new Sequence[n * 2];\\n            Arrays.fill(tree, Sequence.EMPTY);\\n        }\\n        \\n        void update(int idx, Sequence s) {\\n            idx += n;\\n            tree[idx] = tree[idx].merge(s);\\n            \\n            while (idx > 1) {\\n                tree[idx >> 1] = tree[idx].merge(tree[idx ^ 1]);\\n                idx >>= 1;\\n            }\\n        }\\n        \\n        Sequence query(int r) {\\n            int l = n;\\n            r += n;\\n\\n            Sequence s = Sequence.EMPTY;\\n            while (l <= r) {\\n                if ((l & 1) == 1) {\\n                    s = s.merge(tree[l++]);\\n                }\\n                if ((r & 1) == 0) {\\n                    s = s.merge(tree[r--]);\\n                }\\n                l >>= 1;\\n                r >>= 1;\\n            }\\n            return s;\\n        }\\n    }\\n\\n    private static class Sequence {\\n        final int length;\\n        final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n        \\n        Sequence merge(Sequence other) {\\n            if (other.length > this.length) {\\n                return other;\\n            }\\n            if (other.length < this.length) {\\n                return this;\\n            }\\n            return new Sequence(length, this.count + other.count);\\n        }\\n        \\n        static final Sequence EMPTY = new Sequence(0, 1) {\\n            Sequence merge(Sequence other) {\\n                return other.length > this.length ? other : this;\\n            }\\n        };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int findNumberOfLIS(int[] nums) {\\n        Segment root = new Segment((int) -1e6, (int) 1e6);\\n        for (int num : nums) {\\n            Sequence s = root.query(num - 1);\\n            root.update(num, new Sequence(s.length + 1, s.count));\\n        }\\n        return root.sequence.count;\\n    }\\n\\n    private static class Segment {\\n        final int left;\\n        final int middle;\\n        final int right;\\n        \\n        Segment leftChild;\\n        Segment rightChild;\\n        \\n        Sequence sequence = Sequence.EMPTY;\\n        \\n        Segment(int left, int right) {\\n            this.left = left;\\n            this.middle = left + (right - left) / 2;\\n            this.right = right;\\n        }\\n        \\n        void update(int value, Sequence s) {\\n            this.sequence = this.sequence.merge(s);\\n            \\n            if (this.left == this.middle) {\\n                return;\\n            }\\n            \\n            if (value < this.middle) {\\n                if (this.leftChild == null) {\\n                    this.leftChild = new Segment(this.left, this.middle);\\n                }\\n                this.leftChild.update(value, s);\\n            } else {\\n                if (this.rightChild == null) {\\n                    this.rightChild = new Segment(this.middle, this.right);\\n                }\\n                this.rightChild.update(value, s);\\n            }\\n        }\\n        \\n        Sequence query(int value) {\\n            if (this.left == this.middle) {\\n                return this.sequence;\\n            }\\n            \\n            if (value < this.middle) {\\n                return this.leftChild != null ? this.leftChild.query(value) : Sequence.EMPTY;\\n\\n            } else {\\n                Sequence left = this.leftChild != null ? this.leftChild.sequence : Sequence.EMPTY;\\n                Sequence right = this.rightChild != null ? this.rightChild.query(value) : Sequence.EMPTY;\\n                return left.merge(right);\\n            }\\n        }\\n    }\\n\\n    private static class Sequence {\\n        final int length;\\n        final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n        \\n        Sequence merge(Sequence other) {\\n            if (other.length > this.length) {\\n                return other;\\n            }\\n            if (other.length < this.length) {\\n                return this;\\n            }\\n            return new Sequence(length, this.count + other.count);\\n        }\\n        \\n        static final Sequence EMPTY = new Sequence(0, 1) {\\n            Sequence merge(Sequence other) {\\n                return other.length > this.length ? other : this;\\n            }\\n        };\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int findNumberOfLIS(int[] nums) {\\n\\t\\t// first coordinate compression\\n        int n = nums.length;\\n        Integer[] indexes = new Integer[n];\\n        for (int i = 0; i < n; i++) {\\n            indexes[i] = i;\\n        }\\n        \\n        Arrays.sort(indexes, Comparator.comparingInt(i -> nums[i]));\\n        \\n        int coordinate = 1;\\n        int[] coordinates = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            while (i < n - 1 && nums[indexes[i]] == nums[indexes[i + 1]]) {\\n                coordinates[indexes[i++]] = coordinate;\\n            }\\n            coordinates[indexes[i]] = coordinate++;\\n        }\\n        \\n\\t\\t// then using compressed coordinates to build the tree\\n        SegmentTree tree = new SegmentTree(coordinate);\\n        for (int i = 0; i < n; i++) {\\n            Sequence s = tree.query(coordinates[i] - 1);\\n            tree.update(coordinates[i], new Sequence(s.length + 1, s.count));\\n        }\\n        return tree.query(coordinate - 1).count;\\n    }\\n    \\n    private static class SegmentTree {\\n        \\n        private final int n;\\n        private final Sequence[] tree;\\n        \\n        SegmentTree(int n) {\\n            this.n = n;\\n            this.tree = new Sequence[n * 2];\\n            Arrays.fill(tree, Sequence.EMPTY);\\n        }\\n        \\n        void update(int idx, Sequence s) {\\n            idx += n;\\n            tree[idx] = tree[idx].merge(s);\\n            \\n            while (idx > 1) {\\n                tree[idx >> 1] = tree[idx].merge(tree[idx ^ 1]);\\n                idx >>= 1;\\n            }\\n        }\\n        \\n        Sequence query(int r) {\\n            int l = n;\\n            r += n;\\n\\n            Sequence s = Sequence.EMPTY;\\n            while (l <= r) {\\n                if ((l & 1) == 1) {\\n                    s = s.merge(tree[l++]);\\n                }\\n                if ((r & 1) == 0) {\\n                    s = s.merge(tree[r--]);\\n                }\\n                l >>= 1;\\n                r >>= 1;\\n            }\\n            return s;\\n        }\\n    }\\n\\n    private static class Sequence {\\n        final int length;\\n        final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n        \\n        Sequence merge(Sequence other) {\\n            if (other.length > this.length) {\\n                return other;\\n            }\\n            if (other.length < this.length) {\\n                return this;\\n            }\\n            return new Sequence(length, this.count + other.count);\\n        }\\n        \\n        static final Sequence EMPTY = new Sequence(0, 1) {\\n            Sequence merge(Sequence other) {\\n                return other.length > this.length ? other : this;\\n            }\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491691,
                "title": "java-o-n-logn-binary-indexed-tree-beats-98",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n\\t\\t// first the coordinate compression\\n        int n = nums.length;\\n        Integer[] indexes = new Integer[n];\\n        for (int i = 0; i < n; i++) {\\n            indexes[i] = i;\\n        }\\n\\n        Arrays.sort(indexes, Comparator.comparingInt(i -> nums[i]));\\n        \\n        int coordinate = 0;\\n        int[] coordinates = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            while (i < n - 1 && nums[indexes[i]] == nums[indexes[i + 1]]) {\\n                coordinates[indexes[i]] = coordinate;\\n                i++;\\n            }\\n            coordinates[indexes[i]] = coordinate++;\\n        }\\n        \\n\\t\\t// then using compressed coordinates in a BIT\\n        BinaryIndexedTree bit = new BinaryIndexedTree(coordinate);\\n        for (int i = 0; i < n; i++) {\\n            Sequence s = bit.query(coordinates[i] - 1);\\n            bit.update(coordinates[i], new Sequence(s.length + 1, s.count));\\n        }\\n    \\n        return bit.query(coordinate - 1).count;\\n    }\\n    \\n    private static final class BinaryIndexedTree {\\n        private final Sequence[] a;\\n        \\n        BinaryIndexedTree(int n) {\\n            this.a = new Sequence[n + 1];\\n        }\\n        \\n        void update(int idx, Sequence s) {\\n            idx++;\\n            \\n            while (idx < a.length) {\\n                if (a[idx] == null || a[idx].length < s.length) {\\n                    a[idx] = s;\\n                } else if (a[idx].length == s.length) {\\n                    a[idx] = new Sequence(s.length, s.count + a[idx].count);\\n                }\\n                idx += idx & -idx;\\n            }\\n        }\\n        \\n        Sequence query(int idx) {\\n            idx++;\\n            Sequence s = new Sequence(0, 1);\\n            \\n            while (idx > 0) {\\n                if (a[idx] != null) {\\n                    if (a[idx].length > s.length) {\\n                        s = a[idx];\\n                    } else if (a[idx].length == s.length) {\\n                        s = new Sequence(s.length, s.count + a[idx].count);\\n                    }\\n                }\\n                idx -= idx & -idx;\\n            }\\n            \\n            return s;\\n        }\\n    }\\n    \\n    private static final class Sequence {\\n        private final int length;\\n        private final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n\\t\\t// first the coordinate compression\\n        int n = nums.length;\\n        Integer[] indexes = new Integer[n];\\n        for (int i = 0; i < n; i++) {\\n            indexes[i] = i;\\n        }\\n\\n        Arrays.sort(indexes, Comparator.comparingInt(i -> nums[i]));\\n        \\n        int coordinate = 0;\\n        int[] coordinates = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            while (i < n - 1 && nums[indexes[i]] == nums[indexes[i + 1]]) {\\n                coordinates[indexes[i]] = coordinate;\\n                i++;\\n            }\\n            coordinates[indexes[i]] = coordinate++;\\n        }\\n        \\n\\t\\t// then using compressed coordinates in a BIT\\n        BinaryIndexedTree bit = new BinaryIndexedTree(coordinate);\\n        for (int i = 0; i < n; i++) {\\n            Sequence s = bit.query(coordinates[i] - 1);\\n            bit.update(coordinates[i], new Sequence(s.length + 1, s.count));\\n        }\\n    \\n        return bit.query(coordinate - 1).count;\\n    }\\n    \\n    private static final class BinaryIndexedTree {\\n        private final Sequence[] a;\\n        \\n        BinaryIndexedTree(int n) {\\n            this.a = new Sequence[n + 1];\\n        }\\n        \\n        void update(int idx, Sequence s) {\\n            idx++;\\n            \\n            while (idx < a.length) {\\n                if (a[idx] == null || a[idx].length < s.length) {\\n                    a[idx] = s;\\n                } else if (a[idx].length == s.length) {\\n                    a[idx] = new Sequence(s.length, s.count + a[idx].count);\\n                }\\n                idx += idx & -idx;\\n            }\\n        }\\n        \\n        Sequence query(int idx) {\\n            idx++;\\n            Sequence s = new Sequence(0, 1);\\n            \\n            while (idx > 0) {\\n                if (a[idx] != null) {\\n                    if (a[idx].length > s.length) {\\n                        s = a[idx];\\n                    } else if (a[idx].length == s.length) {\\n                        s = new Sequence(s.length, s.count + a[idx].count);\\n                    }\\n                }\\n                idx -= idx & -idx;\\n            }\\n            \\n            return s;\\n        }\\n    }\\n    \\n    private static final class Sequence {\\n        private final int length;\\n        private final int count;\\n        \\n        Sequence(int length, int count) {\\n            this.length = length;\\n            this.count = count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445893,
                "title": "c-dp-pairs",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<pair<int,int>>dp(n,{1,1});\\n        \\n        dp[0].first=1;\\n        dp[0].second=1;\\n        int l=1,r=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(dp[i].first<1+dp[j].first)\\n                    {\\n                        dp[i].first=1+dp[j].first;\\n                        dp[i].second=dp[j].second;\\n                    }\\n                    else if(dp[i].first==dp[j].first+1)\\n                    {\\n                        dp[i].second+=dp[j].second;\\n                    }\\n                }\\n            }\\n            if(dp[i].first>l)\\n            {\\n                l=dp[i].first;\\n                r=dp[i].second;\\n            }\\n            else if(dp[i].first==l)\\n            {\\n                r+=dp[i].second;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<pair<int,int>>dp(n,{1,1});\\n        \\n        dp[0].first=1;\\n        dp[0].second=1;\\n        int l=1,r=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(dp[i].first<1+dp[j].first)\\n                    {\\n                        dp[i].first=1+dp[j].first;\\n                        dp[i].second=dp[j].second;\\n                    }\\n                    else if(dp[i].first==dp[j].first+1)\\n                    {\\n                        dp[i].second+=dp[j].second;\\n                    }\\n                }\\n            }\\n            if(dp[i].first>l)\\n            {\\n                l=dp[i].first;\\n                r=dp[i].second;\\n            }\\n            else if(dp[i].first==l)\\n            {\\n                r+=dp[i].second;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307093,
                "title": "number-of-lis-o-nlogn-c-100-explained",
                "content": "Before you read this, please make sure you already know the LIS O(NlogN) solution!\\n\\nRefer : https://leetcode.com/problems/longest-increasing-subsequence/discuss/1303416/longest-increasing-subsequence-in-onlogn\\n\\nSo in the O(NlogN) solution, we created a DP array where the index at which we landed on using lower_bound function gave us the length of the Longest Increasing Subsequence ending current element.\\n\\nNow Here, we will modify this approach to solve for number of LIS by (read this carefully) : Storing the counts of LIS ending at current element.  \\n\\nSuppose the current element is 4 and lower_bound gives us 3, that mean LIS of length 3 can be formed by ending at 4. To get count, We know that we can place 4 after any of the LIS of length 2 that end with an element smaller than 4. \\n\\nWe can create a List of List of Pairs, vector<vector< pair<int,int> >> LISbylen(N+1); in which we store the ( count of LIS end at current element, and the current element ). So to get the count we can add up the counts of LIS of len-1 where the last element is smaller than current element.\\n\\n\\t\\n\\tint findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> dp(n+1, INT_MAX);\\n        vector<vector< pair<int,int> >> LISbylen(n+1);\\n        \\n        dp[0] = INT_MIN;\\n        LISbylen[0] = { {1, INT_MIN} };\\n        \\n        int max_len = 1;\\n        for(auto &ele: nums){\\n            \\n            int len = lower_bound(dp.begin(), dp.end(), ele) - dp.begin();\\n            dp[len] = ele;\\n            \\n            int ele_count = 0;\\n            for(auto &[count, last]: LISbylen[len-1])\\n                if(ele>last) ele_count+=count;\\n            \\n            LISbylen[len].push_back({ele_count, ele});\\n            max_len = max(max_len, len);\\n            \\n        }\\n        \\n        int num_lis = 0;\\n        for(auto &[count, last]: LISbylen[max_len])\\n            num_lis += count;\\n        \\n        return num_lis;\\n        \\n    }",
                "solutionTags": [],
                "code": "Before you read this, please make sure you already know the LIS O(NlogN) solution!\\n\\nRefer : https://leetcode.com/problems/longest-increasing-subsequence/discuss/1303416/longest-increasing-subsequence-in-onlogn\\n\\nSo in the O(NlogN) solution, we created a DP array where the index at which we landed on using lower_bound function gave us the length of the Longest Increasing Subsequence ending current element.\\n\\nNow Here, we will modify this approach to solve for number of LIS by (read this carefully) : Storing the counts of LIS ending at current element.  \\n\\nSuppose the current element is 4 and lower_bound gives us 3, that mean LIS of length 3 can be formed by ending at 4. To get count, We know that we can place 4 after any of the LIS of length 2 that end with an element smaller than 4. \\n\\nWe can create a List of List of Pairs, vector<vector< pair<int,int> >> LISbylen(N+1); in which we store the ( count of LIS end at current element, and the current element ). So to get the count we can add up the counts of LIS of len-1 where the last element is smaller than current element.\\n\\n\\t\\n\\tint findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> dp(n+1, INT_MAX);\\n        vector<vector< pair<int,int> >> LISbylen(n+1);\\n        \\n        dp[0] = INT_MIN;\\n        LISbylen[0] = { {1, INT_MIN} };\\n        \\n        int max_len = 1;\\n        for(auto &ele: nums){\\n            \\n            int len = lower_bound(dp.begin(), dp.end(), ele) - dp.begin();\\n            dp[len] = ele;\\n            \\n            int ele_count = 0;\\n            for(auto &[count, last]: LISbylen[len-1])\\n                if(ele>last) ele_count+=count;\\n            \\n            LISbylen[len].push_back({ele_count, ele});\\n            max_len = max(max_len, len);\\n            \\n        }\\n        \\n        int num_lis = 0;\\n        for(auto &[count, last]: LISbylen[max_len])\\n            num_lis += count;\\n        \\n        return num_lis;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1284688,
                "title": "swift-o-nlogn-100-dp-bs-prefix-sum",
                "content": "Based on this [wonderful post](https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/107295/9ms-C%2B%2B-Explanation%3A-DP-%2B-Binary-search-%2B-prefix-sums-O(NlogN)-time-O(N)-space).\\n\\nIf you\\'re trying to solve it in O(nlogn), this problem would be one of the craziest, in a good way, problem in Leetcode.\\n\\n**DP(Patience Sorting) + BS + Prefix Sum**\\n\\n```\\nclass Solution {\\n    func findNumberOfLIS(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 0 else { return 0 }\\n        var list = [[(Int, Int)]]()\\n\\t\\t// by inserting the first number, list.first & list.last becomes much easier\\n        list.append([(nums[0], 1)])\\n        for n in nums[1..<nums.count] {\\n\\t\\t\\t// if the n and the last pile of value is the same, we merge them so we can BS easier\\n            var index = bs(list, n)\\n\\t\\t\\t// no need to caculate because it is the first element of sequence.\\n            if index == 0 {\\n                if list.first!.last!.0 == n {\\n                    list[0][list[index].count - 1].1 += 1\\n                } else {\\n                    list[0].append((n, list.first!.last!.1 + 1))\\n                }\\n                continue\\n            }\\n            var before = list[index - 1]\\n            var index2 = bs2(before, n)\\n\\t\\t\\t// prefix sum. sum(a~b) = sum(b~0) - sum(a-1~0)\\n            var sum = before.last!.1 - (index2 == -1 ? 0 : before[index2].1)\\n            if index < list.count  {\\n                if list[index].last!.0 == n {\\n                    list[index][list[index].count - 1].1 += sum\\n                } else {\\n                    list[index].append((n, list[index].last!.1 + sum))\\n                }\\n            } else {\\n                list.append([(n, sum)])\\n            }\\n        }\\n\\t\\t// last is already the sum of possible options so no need to sum up\\n        return list.last!.last!.1\\n    }\\n\\t\\n    // BS for prefix sum. decreasing order\\n    func bs2(_ nums:[(Int, Int)], _ target: Int) -> Int {\\n        var m = 0\\n        var M = nums.count\\n        while m < M {\\n            var mid = (m + M) >> 1\\n            if nums[mid].0 == target {\\n\\t\\t\\t    // if the target is in this array, \\n                // we have to minus the value because the sequence is strictly increasing\\n                return mid\\n            } else if nums[mid].0 < target {\\n                M = mid\\n            } else {\\n                m = mid + 1\\n            }\\n        }\\n\\t\\t// if we dont have the target, we need index - 1. think and let it sink in\\n        return m - 1\\n    }\\n\\t\\n    // normal BS for patience sorting. increasing order\\n    func bs(_ nums:[[(Int, Int)]], _ target: Int) -> Int {\\n        var m = 0\\n        var M = nums.count\\n        while m < M {\\n            var mid = (m + M) >> 1\\n            if nums[mid].last!.0 == target {\\n                return mid\\n            } else if nums[mid].last!.0 < target {\\n                m = mid + 1\\n            } else {\\n                M = mid\\n            }\\n        }\\n        return m\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findNumberOfLIS(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 0 else { return 0 }\\n        var list = [[(Int, Int)]]()\\n\\t\\t// by inserting the first number, list.first & list.last becomes much easier\\n        list.append([(nums[0], 1)])\\n        for n in nums[1..<nums.count] {\\n\\t\\t\\t// if the n and the last pile of value is the same, we merge them so we can BS easier\\n            var index = bs(list, n)\\n\\t\\t\\t// no need to caculate because it is the first element of sequence.\\n            if index == 0 {\\n                if list.first!.last!.0 == n {\\n                    list[0][list[index].count - 1].1 += 1\\n                } else {\\n                    list[0].append((n, list.first!.last!.1 + 1))\\n                }\\n                continue\\n            }\\n            var before = list[index - 1]\\n            var index2 = bs2(before, n)\\n\\t\\t\\t// prefix sum. sum(a~b) = sum(b~0) - sum(a-1~0)\\n            var sum = before.last!.1 - (index2 == -1 ? 0 : before[index2].1)\\n            if index < list.count  {\\n                if list[index].last!.0 == n {\\n                    list[index][list[index].count - 1].1 += sum\\n                } else {\\n                    list[index].append((n, list[index].last!.1 + sum))\\n                }\\n            } else {\\n                list.append([(n, sum)])\\n            }\\n        }\\n\\t\\t// last is already the sum of possible options so no need to sum up\\n        return list.last!.last!.1\\n    }\\n\\t\\n    // BS for prefix sum. decreasing order\\n    func bs2(_ nums:[(Int, Int)], _ target: Int) -> Int {\\n        var m = 0\\n        var M = nums.count\\n        while m < M {\\n            var mid = (m + M) >> 1\\n            if nums[mid].0 == target {\\n\\t\\t\\t    // if the target is in this array, \\n                // we have to minus the value because the sequence is strictly increasing\\n                return mid\\n            } else if nums[mid].0 < target {\\n                M = mid\\n            } else {\\n                m = mid + 1\\n            }\\n        }\\n\\t\\t// if we dont have the target, we need index - 1. think and let it sink in\\n        return m - 1\\n    }\\n\\t\\n    // normal BS for patience sorting. increasing order\\n    func bs(_ nums:[[(Int, Int)]], _ target: Int) -> Int {\\n        var m = 0\\n        var M = nums.count\\n        while m < M {\\n            var mid = (m + M) >> 1\\n            if nums[mid].last!.0 == target {\\n                return mid\\n            } else if nums[mid].last!.0 < target {\\n                m = mid + 1\\n            } else {\\n                M = mid\\n            }\\n        }\\n        return m\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932836,
                "title": "c-dp-readable-and-easy-to-understand-i-mean-it",
                "content": "The core concept is the same as everyone, the only difference is that this code is more READABLE which makes it easy to understand.\\n\\n```\\n        public static int FindNumberOfLIS(int[] nums)\\n        {\\n\\n            int[] lisLength = new int[nums.Length];\\n            int[] countOfLIS = new int[nums.Length];\\n            int longestSequenceLength = 0;\\n            int numberOfLIS = 0;\\n\\n            for(var right = 0; right < nums.Length; right++)\\n            {\\n                lisLength[right] = 1;\\n                countOfLIS[right] = 1;\\n\\n                for(var left = right - 1; left >= 0; left--)\\n                {\\n                    if(nums[left] < nums[right])\\n                    {\\n                        if (lisLength[right] < lisLength[left] + 1)\\n                        {\\n                            lisLength[right] = lisLength[left] + 1;\\n                            countOfLIS[right] = countOfLIS[left];\\n                        }\\n                        else if(lisLength[right] == lisLength[left] + 1)\\n                        {\\n                            countOfLIS[right] += countOfLIS[left];\\n                        }\\n                    }\\n                }\\n\\n                if (lisLength[right] > longestSequenceLength)\\n                {\\n                    longestSequenceLength = lisLength[right];\\n                    numberOfLIS = countOfLIS[right];\\n                }\\n                else if (lisLength[right] == longestSequenceLength)\\n                    numberOfLIS += countOfLIS[right];                                                 \\n            }\\n\\n            return numberOfLIS;\\n        }\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n        public static int FindNumberOfLIS(int[] nums)\\n        {\\n\\n            int[] lisLength = new int[nums.Length];\\n            int[] countOfLIS = new int[nums.Length];\\n            int longestSequenceLength = 0;\\n            int numberOfLIS = 0;\\n\\n            for(var right = 0; right < nums.Length; right++)\\n            {\\n                lisLength[right] = 1;\\n                countOfLIS[right] = 1;\\n\\n                for(var left = right - 1; left >= 0; left--)\\n                {\\n                    if(nums[left] < nums[right])\\n                    {\\n                        if (lisLength[right] < lisLength[left] + 1)\\n                        {\\n                            lisLength[right] = lisLength[left] + 1;\\n                            countOfLIS[right] = countOfLIS[left];\\n                        }\\n                        else if(lisLength[right] == lisLength[left] + 1)\\n                        {\\n                            countOfLIS[right] += countOfLIS[left];\\n                        }\\n                    }\\n                }\\n\\n                if (lisLength[right] > longestSequenceLength)\\n                {\\n                    longestSequenceLength = lisLength[right];\\n                    numberOfLIS = countOfLIS[right];\\n                }\\n                else if (lisLength[right] == longestSequenceLength)\\n                    numberOfLIS += countOfLIS[right];                                                 \\n            }\\n\\n            return numberOfLIS;\\n        }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919430,
                "title": "top-down-dp-based-on-brute-force",
                "content": "The idea is simple just try every single possibility in every index and re-use the value.\\n\\n```\\npublic static int findNumberOfLIS(int[] nums) {\\n        // first index for the subsequence max length and second is for total combination\\n        int [] result = new int[]{0,0};\\n        int [][] memo = new int[nums.length][2];\\n        // Try at index\\n        for (int x = 0; x < nums.length; x++){\\n            int [] temp = findNumberOfLISHelper(nums, memo, x);\\n            if (temp[0] > result[0]){\\n                result = temp;\\n                continue;\\n            }\\n            if (temp[0] == result[0])\\n                result[1] += temp[1];\\n        }\\n\\n        return result[1];\\n    }\\n\\n    public static int[] findNumberOfLISHelper(int [] nums, int [][]memo, int index){\\n        if (memo[index][0] != 0)\\n            return memo[index];\\n        // set the base value\\n        int [] currentLIS = new int[]{0,1};\\n        for (int x = index+1; x < nums.length; x++){\\n            if (nums[index] < nums[x]){\\n                int[] temp = findNumberOfLISHelper(nums, memo, x);\\n                // if the dfs result is bigger need to change the value\\n                // use new array to avoid reference in java\\n                if (temp[0] > currentLIS[0]){\\n                    currentLIS = new int[]{temp[0], temp[1]};\\n                    continue;\\n                }\\n                // add it if the length is the same\\n                if (temp[0] ==currentLIS[0])\\n                    currentLIS[1] += temp[1];\\n            }\\n        }\\n        // increase the length\\n        currentLIS[0] += 1;\\n        return memo[index] = currentLIS;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int findNumberOfLIS(int[] nums) {\\n        // first index for the subsequence max length and second is for total combination\\n        int [] result = new int[]{0,0};\\n        int [][] memo = new int[nums.length][2];\\n        // Try at index\\n        for (int x = 0; x < nums.length; x++){\\n            int [] temp = findNumberOfLISHelper(nums, memo, x);\\n            if (temp[0] > result[0]){\\n                result = temp;\\n                continue;\\n            }\\n            if (temp[0] == result[0])\\n                result[1] += temp[1];\\n        }\\n\\n        return result[1];\\n    }\\n\\n    public static int[] findNumberOfLISHelper(int [] nums, int [][]memo, int index){\\n        if (memo[index][0] != 0)\\n            return memo[index];\\n        // set the base value\\n        int [] currentLIS = new int[]{0,1};\\n        for (int x = index+1; x < nums.length; x++){\\n            if (nums[index] < nums[x]){\\n                int[] temp = findNumberOfLISHelper(nums, memo, x);\\n                // if the dfs result is bigger need to change the value\\n                // use new array to avoid reference in java\\n                if (temp[0] > currentLIS[0]){\\n                    currentLIS = new int[]{temp[0], temp[1]};\\n                    continue;\\n                }\\n                // add it if the length is the same\\n                if (temp[0] ==currentLIS[0])\\n                    currentLIS[1] += temp[1];\\n            }\\n        }\\n        // increase the length\\n        currentLIS[0] += 1;\\n        return memo[index] = currentLIS;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 903156,
                "title": "python-easy-to-understand-top-down-o-n-2",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        self.memo = {}\\n        max_len, count = 0, 0\\n        for i in range(len(nums)):\\n            curr_max, curr_count = self.helper(i, nums)\\n            if curr_max == max_len:\\n                count += curr_count\\n            elif curr_max > max_len:\\n                max_len = curr_max\\n                count = curr_count\\n        return count\\n    \\n    def helper(self, i, nums):\\n        if i in self.memo:\\n            return self.memo[i]\\n        \\n        max_length = 1; count = 0\\n        \\n        for j in range(i+1, len(nums)):\\n            if nums[j] > nums[i]:\\n                \\n                max_length_j, count_j = self.helper(j, nums)\\n                \\n                if max_length == 1 + max_length_j:\\n                    count += count_j\\n                \\n                elif 1 + max_length_j > max_length:\\n                    count = count_j\\n                    max_length = 1 + max_length_j\\n        \\n        count = max(1, count)\\n        self.memo[i] = (max_length, count)\\n        return self.memo[i]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        self.memo = {}\\n        max_len, count = 0, 0\\n        for i in range(len(nums)):\\n            curr_max, curr_count = self.helper(i, nums)\\n            if curr_max == max_len:\\n                count += curr_count\\n            elif curr_max > max_len:\\n                max_len = curr_max\\n                count = curr_count\\n        return count\\n    \\n    def helper(self, i, nums):\\n        if i in self.memo:\\n            return self.memo[i]\\n        \\n        max_length = 1; count = 0\\n        \\n        for j in range(i+1, len(nums)):\\n            if nums[j] > nums[i]:\\n                \\n                max_length_j, count_j = self.helper(j, nums)\\n                \\n                if max_length == 1 + max_length_j:\\n                    count += count_j\\n                \\n                elif 1 + max_length_j > max_length:\\n                    count = count_j\\n                    max_length = 1 + max_length_j\\n        \\n        count = max(1, count)\\n        self.memo[i] = (max_length, count)\\n        return self.memo[i]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 901593,
                "title": "99-31-o-n-log-n-solution-in-python",
                "content": "Please, first take a look at my solution for [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/901573/O(n-log-n)-Solution-in-Python) as we build upon it here. In that question, we kept a `dp` array to remember the length of the longest possible subsequeces.\\n\\nHere, we use the same `dp` array and employ the same binary search algorithm to remember the length of the longest subsequences. Furthermore, here we introudce a new data structure `num_sequences_of_length` that remembers:\\n\\n- the number of sequences *that matter* at a length\\n- and the largest i.e. tha last number of those sequences\\n\\n\\n```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        dp = []\\n        num_sequences_of_length = collections.defaultdict(list)\\n        for i in range(len(nums)):\\n            pos = bisect_left(dp, nums[i])\\n            if pos == len(dp):\\n                dp.append(nums[i])\\n            else:\\n                dp[pos] = nums[i]\\n            total = 0\\n            for count, last in num_sequences_of_length[pos]:\\n                if last < nums[i]:\\n                    total += count\\n            num_sequences_of_length[pos+1].append((max(1, total), nums[i]))\\n        return sum([count for count,_ in num_sequences_of_length[len(dp)-1]])\\n```\\n\\nFor example for `[1,3,5,4,7]` input `num_sequences_of_length` will be as\\n```\\n1: [(1, 1)]\\n2: [(1, 3)]\\n3: [(1, 5), (1, 4)]\\n4: [(2, 7)]\\n```\\nbecause there\\'s\\n- 1 possible subsequence of length 1 and it ends with 1 i.e. [1] *that matter*\\n- 1 possible subsequence of length 2 and it ends with 1 i.e. [1, 3] *that matter*\\n- 2 possible subsequence of length 3 and those end with 4 i.e. [1, 3, 4] and 5 i.e. [1, 3, 5] *that matter*\\n- 2 possible subsequence of length 4 and those end with 7 i.e. [1, 3, 4, 7] and [1, 3, 5, 7] *that matter*\\n\\nAs you may noticed in above example, the somewhat mystic criteria of \"matter\"ing is actually based on enabling longer subsequences later.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        dp = []\\n        num_sequences_of_length = collections.defaultdict(list)\\n        for i in range(len(nums)):\\n            pos = bisect_left(dp, nums[i])\\n            if pos == len(dp):\\n                dp.append(nums[i])\\n            else:\\n                dp[pos] = nums[i]\\n            total = 0\\n            for count, last in num_sequences_of_length[pos]:\\n                if last < nums[i]:\\n                    total += count\\n            num_sequences_of_length[pos+1].append((max(1, total), nums[i]))\\n        return sum([count for count,_ in num_sequences_of_length[len(dp)-1]])\\n```\n```\\n1: [(1, 1)]\\n2: [(1, 3)]\\n3: [(1, 5), (1, 4)]\\n4: [(2, 7)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815161,
                "title": "c-dp-o-n-2",
                "content": "```csharp\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        var dp = nums.Select(_ => new[] {1, 1}).ToArray(); //[0]: length, [1]: count\\n        var max = 1;\\n        for (int i = 1; i < nums.Length; i++) \\n            for (int j = 0, last = 0; j < i; j++) {\\n                if (nums[i] <= nums[j] || dp[j][0] + 1 < dp[i][0]) continue;\\n                if (last == dp[j][0]) dp[i][1] += dp[j][1];\\n                else dp[i] = new [] { dp[j][0] + 1, dp[j][1] };\\n                (max, last) = (Math.Max(max, dp[i][0]), dp[j][0]);\\n            }\\n        return dp.Sum(e => e[0] == max ? e[1] : 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        var dp = nums.Select(_ => new[] {1, 1}).ToArray(); //[0]: length, [1]: count\\n        var max = 1;\\n        for (int i = 1; i < nums.Length; i++) \\n            for (int j = 0, last = 0; j < i; j++) {\\n                if (nums[i] <= nums[j] || dp[j][0] + 1 < dp[i][0]) continue;\\n                if (last == dp[j][0]) dp[i][1] += dp[j][1];\\n                else dp[i] = new [] { dp[j][0] + 1, dp[j][1] };\\n                (max, last) = (Math.Max(max, dp[i][0]), dp[j][0]);\\n            }\\n        return dp.Sum(e => e[0] == max ? e[1] : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789878,
                "title": "c-dp-intuitive-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int maxlen = 1, ret = 0;\\n        vector<int> cnt(nums.size(), 1), dp(nums.size(), 1);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j]+1 > dp[i]) dp[i] = dp[j]+1, cnt[i] = cnt[j];\\n                    else if (dp[i] == dp[j]+1) cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, dp[i]);\\n        }\\n        for (int i=0;i < dp.size();++i) \\n            if (dp[i] == maxlen) ret += cnt[i];\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int maxlen = 1, ret = 0;\\n        vector<int> cnt(nums.size(), 1), dp(nums.size(), 1);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] > nums[j]) {\\n                    if (dp[j]+1 > dp[i]) dp[i] = dp[j]+1, cnt[i] = cnt[j];\\n                    else if (dp[i] == dp[j]+1) cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, dp[i]);\\n        }\\n        for (int i=0;i < dp.size();++i) \\n            if (dp[i] == maxlen) ret += cnt[i];\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770271,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \\n        if not nums:\\n            return 0\\n        \\n        longest = [1] * len(nums)\\n        number = [1] * len(nums)\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if longest[j] + 1 > longest[i]:\\n                        longest[i] = longest[j] + 1\\n                        number[i] = number[j]\\n                    elif longest[j] + 1 == longest[i]:\\n                        number[i] += number[j]\\n        \\n        longestSub = max(longest)\\n        ans = 0\\n        for num in range(len(number)):\\n            if longest[num] == longestSub:\\n                ans+=number[num]\\n    \\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        \\n        if not nums:\\n            return 0\\n        \\n        longest = [1] * len(nums)\\n        number = [1] * len(nums)\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if longest[j] + 1 > longest[i]:\\n                        longest[i] = longest[j] + 1\\n                        number[i] = number[j]\\n                    elif longest[j] + 1 == longest[i]:\\n                        number[i] += number[j]\\n        \\n        longestSub = max(longest)\\n        ans = 0\\n        for num in range(len(number)):\\n            if longest[num] == longestSub:\\n                ans+=number[num]\\n    \\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743049,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if(!nums.size()) return 0;\\n        vector<pair<int, int>> dp(nums.size(), {1,1});\\n        int res = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    if( dp[j].first + 1 > dp[i].first) {\\n                        dp[i].first = dp[j].first + 1;\\n                        dp[i].second = dp[j].second;\\n                    }\\n                    else if (dp[j].first + 1 == dp[i].first) {\\n                        dp[i].second += dp[j].second;\\n                    }\\n                }\\n                res = max(res, dp[i].first);\\n            }\\n        }\\n        int count = 0;\\n        for(auto &pair : dp) {\\n            if(res == pair.first)\\n                count += pair.second;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        if(!nums.size()) return 0;\\n        vector<pair<int, int>> dp(nums.size(), {1,1});\\n        int res = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    if( dp[j].first + 1 > dp[i].first) {\\n                        dp[i].first = dp[j].first + 1;\\n                        dp[i].second = dp[j].second;\\n                    }\\n                    else if (dp[j].first + 1 == dp[i].first) {\\n                        dp[i].second += dp[j].second;\\n                    }\\n                }\\n                res = max(res, dp[i].first);\\n            }\\n        }\\n        int count = 0;\\n        for(auto &pair : dp) {\\n            if(res == pair.first)\\n                count += pair.second;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721640,
                "title": "python-o-nlogn-patience-sort-beats-97-84ms",
                "content": "```\\ndef findNumberOfLIS(self, nums: List[int]) -> int:\\n\\tif not nums:\\n\\t\\treturn 0\\n\\t# decks is the typical list of list of int used in patience sort\\n\\t# paths is the number of paths of each element in decks\\n\\tdecks, paths = [], []\\n\\tfor n in nums:\\n\\t    # binary search to find deck to append to\\n\\t\\tl, r = 0, len(decks)-1\\n\\t\\twhile l <= r:\\n\\t\\t\\tm = (l+r)//2\\n\\t\\t\\tif decks[m][-1] < n:\\n\\t\\t\\t\\tl = m+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m-1\\n\\t\\tdeck_idx = l\\n\\t\\tif deck_idx > 0:\\n\\t\\t    # binary search to find position within deck[deck_idx] below which all values are less than n\\n\\t\\t\\tl, r = 0, len(decks[deck_idx-1])-1\\n\\t\\t\\twhile l <= r:\\n\\t\\t\\t\\tm = (l+r)//2\\n\\t\\t\\t\\tif decks[deck_idx-1][m] >= n:\\n\\t\\t\\t\\t\\tl = m+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = m-1\\n\\t\\t\\tn_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n\\t\\telse:\\n\\t\\t\\tn_paths = 1\\n\\t\\tif deck_idx == len(decks):\\n\\t\\t\\tdecks.append([n])\\n\\t\\t\\tpaths.append([0,n_paths])\\n\\t\\telse:\\n\\t\\t\\tdecks[deck_idx].append(n)\\n\\t\\t\\tpaths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n\\treturn paths[-1][-1]\\n```\\n\\n[1] Patience Sort explained on youtube: https://www.youtube.com/watch?v=22s1xxRvy28",
                "solutionTags": [],
                "code": "```\\ndef findNumberOfLIS(self, nums: List[int]) -> int:\\n\\tif not nums:\\n\\t\\treturn 0\\n\\t# decks is the typical list of list of int used in patience sort\\n\\t# paths is the number of paths of each element in decks\\n\\tdecks, paths = [], []\\n\\tfor n in nums:\\n\\t    # binary search to find deck to append to\\n\\t\\tl, r = 0, len(decks)-1\\n\\t\\twhile l <= r:\\n\\t\\t\\tm = (l+r)//2\\n\\t\\t\\tif decks[m][-1] < n:\\n\\t\\t\\t\\tl = m+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m-1\\n\\t\\tdeck_idx = l\\n\\t\\tif deck_idx > 0:\\n\\t\\t    # binary search to find position within deck[deck_idx] below which all values are less than n\\n\\t\\t\\tl, r = 0, len(decks[deck_idx-1])-1\\n\\t\\t\\twhile l <= r:\\n\\t\\t\\t\\tm = (l+r)//2\\n\\t\\t\\t\\tif decks[deck_idx-1][m] >= n:\\n\\t\\t\\t\\t\\tl = m+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = m-1\\n\\t\\t\\tn_paths = paths[deck_idx-1][-1] - paths[deck_idx-1][l]\\n\\t\\telse:\\n\\t\\t\\tn_paths = 1\\n\\t\\tif deck_idx == len(decks):\\n\\t\\t\\tdecks.append([n])\\n\\t\\t\\tpaths.append([0,n_paths])\\n\\t\\telse:\\n\\t\\t\\tdecks[deck_idx].append(n)\\n\\t\\t\\tpaths[deck_idx].append(n_paths + paths[deck_idx][-1])\\n\\treturn paths[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 625925,
                "title": "self-explanatory-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        int ind=0;\\n        int dp[n]; dp[0]=1;\\n        int mx=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            mx=max(mx,dp[i]);\\n        }\\n        if(mx==1) return n;\\n        vector<int> ways(n,0); ways[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(dp[i]==1) ways[i]=1;\\n            else\\n            {\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(dp[j]==dp[i]-1&&nums[j]<nums[i])\\n                        ways[i]+=ways[j];\\n                }\\n            }\\n        }\\n        \\n        int tot_ways=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==mx)\\n                tot_ways+=ways[i];\\n        }\\n        \\n        return tot_ways;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        int ind=0;\\n        int dp[n]; dp[0]=1;\\n        int mx=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    dp[i]=max(dp[i],1+dp[j]);\\n                }\\n            }\\n            mx=max(mx,dp[i]);\\n        }\\n        if(mx==1) return n;\\n        vector<int> ways(n,0); ways[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(dp[i]==1) ways[i]=1;\\n            else\\n            {\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(dp[j]==dp[i]-1&&nums[j]<nums[i])\\n                        ways[i]+=ways[j];\\n                }\\n            }\\n        }\\n        \\n        int tot_ways=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i]==mx)\\n                tot_ways+=ways[i];\\n        }\\n        \\n        return tot_ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603110,
                "title": "lengthy-descriptive-javascript-solution",
                "content": "```\\n\\nvar findNumberOfLIS = function(nums) {\\n    // saftey check that nums has length and is not null\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    \\n    // initialise array to record the length of the longest increasing subsequence at each i\\n    const LISRecord = new Array(nums.length).fill(1);\\n\\n    // initialise array to record the number of LIS of length LISRecord[i]\\n    const numberOfLISRecord = new Array(nums.length).fill(1);\\n\\n    // iterate i from 0 to nums.length\\n    for(let i=0; i<nums.length; i++) {\\n        // for each i in nums, iterate j from 0 up to i-1\\n        for(let j=0; j<i; j++) {\\n\\n            // if nums[i] is greater than nums[j]\\n            // i.e. putting nums[i] after nums[j] would continue a increasing subsequence\\n            if (nums[i] > nums[j]) {\\n\\n                // if the longest possible subsequence up to nums[i] is less than that up to nums[j]+1\\n                // which it will be in the first iteration at least because all of LISRecord is initialised\\n                // to 1\\n                if (LISRecord[i] < LISRecord[j] + 1) {\\n                    // since nums[i] is less than nums[j] the possible longest increasing subsequence to\\n                    // i is atleast one longer\\n                    LISRecord[i] = LISRecord[j] + 1;\\n                    // and how ever many ways there were to make LISRecord[j] \\n                    // there are an equal many ways to make LISRecrod[i]\\n                    numberOfLISRecord[i] = numberOfLISRecord[j];\\n                }\\n                // if i is a LIS one larger than j - meaning the longest possible subsequence up\\n                // to nums[i] is one larger than nums[j+1]\\n                else if(LISRecord[i] === LISRecord[j] + 1) {\\n                    // then the amount of ways of of making LISRecord[i] is the number of ways of\\n                    // making LISRecord[i] that we have already calculated plus\\n                    // the number of ways of making LISRecord[j] since\\n                    // nums[j] is less than nums[i] and thus all the sequences that end\\n                    // at nums[j] can be extended by one to end at nums[i]\\n                    numberOfLISRecord[i] = numberOfLISRecord[i] + numberOfLISRecord[j];\\n                }\\n            }\\n        }\\n    }\\n\\n    // then using the information we have tabulated it is easy to to find the answer\\n    // the number of ways of creating the longest increasing subsequence is\\n    // the sum of the values in numberOfLISRecord at each i, where i is the largest\\n    // number in LISRecord\\n    // i.e. LISRecord - shows us the LIS we can make - and numberOFLISRecord tells us\\n    // how many ways to make that\\n    // so for each occurrence of the LIS in LISrecord, we just get the corresponding number\\n    // from numberOfLISRecord (recorded at the same index)\\n    let longestLIS = Math.max(...LISRecord, 0);\\n    let occurrencesOfLongestLIS = 0;\\n    for(let index=0; index<numberOfLISRecord.length; index++) {\\n        if (LISRecord[index] === longestLIS) {\\n            occurrencesOfLongestLIS = occurrencesOfLongestLIS + numberOfLISRecord[index];\\n        }\\n    }\\n\\n    // console.log(nums);\\n    // console.log(LISRecord);\\n    // console.log(numberOfLISRecord);\\n    return occurrencesOfLongestLIS;\\n};\\n\\nconsole.log(\\n    findNumberOfLIS(\\n        [2,2,2,2,2]\\n    )\\n);\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar findNumberOfLIS = function(nums) {\\n    // saftey check that nums has length and is not null\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    \\n    // initialise array to record the length of the longest increasing subsequence at each i\\n    const LISRecord = new Array(nums.length).fill(1);\\n\\n    // initialise array to record the number of LIS of length LISRecord[i]\\n    const numberOfLISRecord = new Array(nums.length).fill(1);\\n\\n    // iterate i from 0 to nums.length\\n    for(let i=0; i<nums.length; i++) {\\n        // for each i in nums, iterate j from 0 up to i-1\\n        for(let j=0; j<i; j++) {\\n\\n            // if nums[i] is greater than nums[j]\\n            // i.e. putting nums[i] after nums[j] would continue a increasing subsequence\\n            if (nums[i] > nums[j]) {\\n\\n                // if the longest possible subsequence up to nums[i] is less than that up to nums[j]+1\\n                // which it will be in the first iteration at least because all of LISRecord is initialised\\n                // to 1\\n                if (LISRecord[i] < LISRecord[j] + 1) {\\n                    // since nums[i] is less than nums[j] the possible longest increasing subsequence to\\n                    // i is atleast one longer\\n                    LISRecord[i] = LISRecord[j] + 1;\\n                    // and how ever many ways there were to make LISRecord[j] \\n                    // there are an equal many ways to make LISRecrod[i]\\n                    numberOfLISRecord[i] = numberOfLISRecord[j];\\n                }\\n                // if i is a LIS one larger than j - meaning the longest possible subsequence up\\n                // to nums[i] is one larger than nums[j+1]\\n                else if(LISRecord[i] === LISRecord[j] + 1) {\\n                    // then the amount of ways of of making LISRecord[i] is the number of ways of\\n                    // making LISRecord[i] that we have already calculated plus\\n                    // the number of ways of making LISRecord[j] since\\n                    // nums[j] is less than nums[i] and thus all the sequences that end\\n                    // at nums[j] can be extended by one to end at nums[i]\\n                    numberOfLISRecord[i] = numberOfLISRecord[i] + numberOfLISRecord[j];\\n                }\\n            }\\n        }\\n    }\\n\\n    // then using the information we have tabulated it is easy to to find the answer\\n    // the number of ways of creating the longest increasing subsequence is\\n    // the sum of the values in numberOfLISRecord at each i, where i is the largest\\n    // number in LISRecord\\n    // i.e. LISRecord - shows us the LIS we can make - and numberOFLISRecord tells us\\n    // how many ways to make that\\n    // so for each occurrence of the LIS in LISrecord, we just get the corresponding number\\n    // from numberOfLISRecord (recorded at the same index)\\n    let longestLIS = Math.max(...LISRecord, 0);\\n    let occurrencesOfLongestLIS = 0;\\n    for(let index=0; index<numberOfLISRecord.length; index++) {\\n        if (LISRecord[index] === longestLIS) {\\n            occurrencesOfLongestLIS = occurrencesOfLongestLIS + numberOfLISRecord[index];\\n        }\\n    }\\n\\n    // console.log(nums);\\n    // console.log(LISRecord);\\n    // console.log(numberOfLISRecord);\\n    return occurrencesOfLongestLIS;\\n};\\n\\nconsole.log(\\n    findNumberOfLIS(\\n        [2,2,2,2,2]\\n    )\\n);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197067,
                "title": "my-o-n-2-java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length], counts = new int[nums.length];\\n        int max = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int temp = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    temp = Math.max(temp, dp[j] + 1); // get the temp max length until this position\\n                }\\n            }\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i] && temp == dp[j] + 1) {\\n                    counts[i] += counts[j]; // get the ways to get this temp max length\\n                }\\n            }\\n            dp[i] = temp;\\n            counts[i] = Math.max(counts[i], 1);\\n            max = Math.max(max, temp); // get the global max\\n        }\\n        int result = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            if (dp[i] == max) {\\n                result += counts[i]; // if we get global max, add the ways to get that length on our result\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int[] dp = new int[nums.length], counts = new int[nums.length];\\n        int max = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            int temp = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    temp = Math.max(temp, dp[j] + 1); // get the temp max length until this position\\n                }\\n            }\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i] && temp == dp[j] + 1) {\\n                    counts[i] += counts[j]; // get the ways to get this temp max length\\n                }\\n            }\\n            dp[i] = temp;\\n            counts[i] = Math.max(counts[i], 1);\\n            max = Math.max(max, temp); // get the global max\\n        }\\n        int result = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            if (dp[i] == max) {\\n                result += counts[i]; // if we get global max, add the ways to get that length on our result\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196685,
                "title": "python-100",
                "content": "```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n        m=min(nums)-1\\n        a,b=[{m:1}],[m]\\n        for x in nums:\\n            i,t=bisect_left(b,x)-1,0\\n            if i==len(a)-1:\\n                a.append({})\\n                b.append(x)\\n            for y in list(a[i].keys()):\\n                if y<x: t+=a[i][y]\\n                else: del a[i][y]\\n            a[i+1][x]=a[i+1].get(x,0)+t\\n            b[i+1]=min(b[i+1],x)\\n        return sum(a[-1].values())\\n```\\n\\nBased on O(n log n) solution of 300. Longest Increasing Subsequence (https://leetcode.com/problems/longest-increasing-subsequence/description/). \\n```\\nfrom bisect import bisect_left\\n    def lengthOfLIS(self, nums):\\n        a=[]\\n        for x in nums:\\n            i=bisect_left(a,x)\\n            if i==len(a): a.append(x)\\n            else: a[i]=x\\n        return len(a)\\n```\\n\\nHere a[i] is a dict, where i is the length of increasing subsequence, the same as question 300. Keys of a[i] are different ending integers, and the corresponding values are the number of increasing subsequence ended with that interger. \\n\\nA key optimization is\\n```\\nelse: del a[i][y]\\n```\\nwhere redundant keys are deleted, so that they would no longer be further looped.\\n\\nFor example, nums=[1,8,5,7,6]\\n```\\nprint(x,i,a,b)\\n```\\nadded at the end of the loop. It would output\\n\\n1 0 [{0: 1}, {1: 1}] [0, 1]\\n8 1 [{0: 1}, {1: 1}, {8: 1}] [0, 1, 8]\\n5 1 [{0: 1}, {1: 1}, {8: 1, 5: 1}] [0, 1, 5]\\n7 2 [{0: 1}, {1: 1}, {5: 1}, {7: 1}] [0, 1, 5, 7]\\n6 2 [{0: 1}, {1: 1}, {5: 1}, {6: 1, 7: 1}] [0, 1, 5, 6]\\n\\nNote that when x==7, 8:1 in a[2] was deleted, which would no longer be unnecessarily checked when x==6.",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findNumberOfLIS(self, nums):\\n        if not nums: return 0\\n        m=min(nums)-1\\n        a,b=[{m:1}],[m]\\n        for x in nums:\\n            i,t=bisect_left(b,x)-1,0\\n            if i==len(a)-1:\\n                a.append({})\\n                b.append(x)\\n            for y in list(a[i].keys()):\\n                if y<x: t+=a[i][y]\\n                else: del a[i][y]\\n            a[i+1][x]=a[i+1].get(x,0)+t\\n            b[i+1]=min(b[i+1],x)\\n        return sum(a[-1].values())\\n```\n```\\nfrom bisect import bisect_left\\n    def lengthOfLIS(self, nums):\\n        a=[]\\n        for x in nums:\\n            i=bisect_left(a,x)\\n            if i==len(a): a.append(x)\\n            else: a[i]=x\\n        return len(a)\\n```\n```\\nelse: del a[i][y]\\n```\n```\\nprint(x,i,a,b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147870,
                "title": "c-easy-to-understand-solution-with-explanation-accepted",
                "content": "**Basic Idea:**\\n* Great [Video](https://www.youtube.com/watch?v=Ns4LCeeOFS4).\\n* The idea is to use two arrays lengthOfLisAtIndex[n] and numberOfLisAtIndex[n] to record the maximum length of Increasing Subsequence and the coresponding number of these sequence which ends with nums[i], respectively. \\n* That is:\\n\\t* lengthOfLisAtIndex[i]: the length of the Longest Increasing Subsequence which ends with nums[i].\\n\\t* numberOfLisAtIndex[i]: the number of the Longest Increasing Subsequence which ends with nums[i].\\n* Then, the result is the sum of each numberOfLisAtIndex[i] while its corresponding lengthOfLisAtIndex[i] is the maximum length.\\n```\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        if (null == nums || nums.Length == 0) return 0;\\n        int[] lengthOfLisAtIndex = new int[nums.Length];   //Length of the Longest Increasing Subsequence which ends with nums[i].\\n        int[] numberOfLisAtIndex = new int[nums.Length];   //Number of the Longest Increasing Subsequence which ends with nums[i].\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            lengthOfLisAtIndex[i] = 1;\\n            numberOfLisAtIndex[i] = 1;\\n        }\\n\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (nums[j] < nums[i])\\n                {\\n                    if (lengthOfLisAtIndex[j] + 1 > lengthOfLisAtIndex[i])\\n                    {\\n                        lengthOfLisAtIndex[i] = lengthOfLisAtIndex[j] + 1;\\n                        numberOfLisAtIndex[i] = numberOfLisAtIndex[j];\\n                    }\\n                    else if (lengthOfLisAtIndex[j] + 1 == lengthOfLisAtIndex[i])\\n                    {\\n                        numberOfLisAtIndex[i] += numberOfLisAtIndex[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int maxlen = lengthOfLisAtIndex.Max();\\n        int ans = 0;\\n        for (int i = 0; i < lengthOfLisAtIndex.Length; i++)\\n            if (lengthOfLisAtIndex[i] == maxlen)\\n                ans += numberOfLisAtIndex[i];\\n\\n        return ans; \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindNumberOfLIS(int[] nums) {\\n        if (null == nums || nums.Length == 0) return 0;\\n        int[] lengthOfLisAtIndex = new int[nums.Length];   //Length of the Longest Increasing Subsequence which ends with nums[i].\\n        int[] numberOfLisAtIndex = new int[nums.Length];   //Number of the Longest Increasing Subsequence which ends with nums[i].\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            lengthOfLisAtIndex[i] = 1;\\n            numberOfLisAtIndex[i] = 1;\\n        }\\n\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (nums[j] < nums[i])\\n                {\\n                    if (lengthOfLisAtIndex[j] + 1 > lengthOfLisAtIndex[i])\\n                    {\\n                        lengthOfLisAtIndex[i] = lengthOfLisAtIndex[j] + 1;\\n                        numberOfLisAtIndex[i] = numberOfLisAtIndex[j];\\n                    }\\n                    else if (lengthOfLisAtIndex[j] + 1 == lengthOfLisAtIndex[i])\\n                    {\\n                        numberOfLisAtIndex[i] += numberOfLisAtIndex[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int maxlen = lengthOfLisAtIndex.Max();\\n        int ans = 0;\\n        for (int i = 0; i < lengthOfLisAtIndex.Length; i++)\\n            if (lengthOfLisAtIndex[i] == maxlen)\\n                ans += numberOfLisAtIndex[i];\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112522,
                "title": "java-cleanest-dp",
                "content": "```\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        if(n == 0)\\n            return 0;\\n        \\n        int[] len = new int[n + 1];\\n        int[] cnt = new int[n + 1];\\n        \\n        for(int i = 0; i <= n; i++) {\\n            cnt[i] = 1;\\n            len[i] = 1;\\n            \\n            for(int j = 0; j < i; j++) {\\n                if(len[j] + 1 < len[i])\\n                    continue;\\n                \\n                if(i != n && nums[i] <= nums[j])\\n                    continue;\\n                \\n                if(len[j] + 1 > len[i])\\n                    cnt[i] = 0;\\n                \\n                len[i] = len[j] + 1;\\n                cnt[i] += cnt[j];\\n            }\\n        }\\n        \\n        return cnt[n];\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        if(n == 0)\\n            return 0;\\n        \\n        int[] len = new int[n + 1];\\n        int[] cnt = new int[n + 1];\\n        \\n        for(int i = 0; i <= n; i++) {\\n            cnt[i] = 1;\\n            len[i] = 1;\\n            \\n            for(int j = 0; j < i; j++) {\\n                if(len[j] + 1 < len[i])\\n                    continue;\\n                \\n                if(i != n && nums[i] <= nums[j])\\n                    continue;\\n                \\n                if(len[j] + 1 > len[i])\\n                    cnt[i] = 0;\\n                \\n                len[i] = len[j] + 1;\\n                cnt[i] += cnt[j];\\n            }\\n        }\\n        \\n        return cnt[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 107331,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Number of Longest Increasing Subsequence** https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/\\n\\n**DP Solution**\\n* Use the DP solution for LIS. Maintain an array called LIS and cnt. LIS[i] is the length of longest subsequence ending at index i. cnt[i] is the number of longest subsequences ending at index i.\\n* When we find a new LIS for index i, update cnt[i] with cnt[j]. Otherwise if the LIS[i] is the same as LIS[j]+1, simply add cnt[j] to cnt[i].\\n* Return the sum of frequencies of the maximum LIS.\\n* Time complexity is O(N^2) and Space complexity is O(N).\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if nums == []:\\n            return 0\\n        LIS, cnt = [1]*len(nums), [1]*len(nums)\\n        for i in range(1, len(nums)):\\n            for j in range(0,i):\\n                if nums[i] > nums[j]:\\n                    if LIS[i] == LIS[j]+1:\\n                        cnt[i] += cnt[j]\\n                    elif LIS[i] < LIS[j]+1:\\n                        cnt[i] = cnt[j]\\n                        LIS[i] = LIS[j]+1\\n        return sum((y for x,y in zip(LIS, cnt) if x==max(LIS)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if nums == []:\\n            return 0\\n        LIS, cnt = [1]*len(nums), [1]*len(nums)\\n        for i in range(1, len(nums)):\\n            for j in range(0,i):\\n                if nums[i] > nums[j]:\\n                    if LIS[i] == LIS[j]+1:\\n                        cnt[i] += cnt[j]\\n                    elif LIS[i] < LIS[j]+1:\\n                        cnt[i] = cnt[j]\\n                        LIS[i] = LIS[j]+1\\n        return sum((y for x,y in zip(LIS, cnt) if x==max(LIS)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107299,
                "title": "java-solution-dp",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int n = nums.length;\\n        \\n        int[] dp = new int[n];\\n        int[] next = new int[n];\\n        dp[n - 1] = 1; next[n - 1] = 1;\\n        int len = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            int max = 0, cnt = 0;\\n            for (int j = i + 1; j < n; j++){\\n                if (nums[j] > nums[i]){\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n            dp[i] = max + 1;\\n            len = Math.max(len, dp[i]);\\n            if (dp[i] == 1) next[i] = 1;\\n            else {\\n                for(int j = i + 1; j < n; ++j){\\n                    if(nums[j] > nums[i] && dp[j] == max){\\n                        next[i] += next[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == len){\\n                res += next[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int n = nums.length;\\n        \\n        int[] dp = new int[n];\\n        int[] next = new int[n];\\n        dp[n - 1] = 1; next[n - 1] = 1;\\n        int len = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            int max = 0, cnt = 0;\\n            for (int j = i + 1; j < n; j++){\\n                if (nums[j] > nums[i]){\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n            dp[i] = max + 1;\\n            len = Math.max(len, dp[i]);\\n            if (dp[i] == 1) next[i] = 1;\\n            else {\\n                for(int j = i + 1; j < n; ++j){\\n                    if(nums[j] > nums[i] && dp[j] == max){\\n                        next[i] += next[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == len){\\n                res += next[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981425,
                "title": "c-clean-code-space-95-speed-75",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int ans = INT_MIN, n = nums.size();\\n        vector<pair<int, int>> dp (n, {1, 1});\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    if(dp[i].first < dp[j].first + 1) dp[i].second = 0;\\n                    \\n                    dp[i].first = max(dp[i].first, dp[j].first + 1);\\n                    if(dp[i].first <= dp[j].first + 1) dp[i].second += dp[j].second;\\n\\n                    ans = max(ans, dp[i].first);\\n                }\\n            }\\n        }\\n    \\n        if(ans == INT_MIN) return nums.size(); \\n        int res = 0;\\n      \\n        for(auto [sub, count]: dp) \\n            if(sub == ans) res += count;\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int ans = INT_MIN, n = nums.size();\\n        vector<pair<int, int>> dp (n, {1, 1});\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    if(dp[i].first < dp[j].first + 1) dp[i].second = 0;\\n                    \\n                    dp[i].first = max(dp[i].first, dp[j].first + 1);\\n                    if(dp[i].first <= dp[j].first + 1) dp[i].second += dp[j].second;\\n\\n                    ans = max(ans, dp[i].first);\\n                }\\n            }\\n        }\\n    \\n        if(ans == INT_MIN) return nums.size(); \\n        int res = 0;\\n      \\n        for(auto [sub, count]: dp) \\n            if(sub == ans) res += count;\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940178,
                "title": "python-using-the-concept-of-lis-easy",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)           \\n        dp=[1]*n\\n        maxi=1\\n        ct=[1]*n\\n        c=0\\n        for i in range(1,n):\\n            for prev in range(i): \\n                if nums[i]>nums[prev] and dp[prev]+1>dp[i]:\\n                    dp[i]=dp[prev]+1\\n                    ct[i]=ct[prev]\\n                elif nums[i]>nums[prev] and dp[prev]+1==dp[i]:\\n                    ct[i]+=ct[prev]\\n            maxi=max(maxi,dp[i])\\n        for i in range(n):\\n            if dp[i]==maxi:\\n                c+=ct[i]\\n        return c\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)           \\n        dp=[1]*n\\n        maxi=1\\n        ct=[1]*n\\n        c=0\\n        for i in range(1,n):\\n            for prev in range(i): \\n                if nums[i]>nums[prev] and dp[prev]+1>dp[i]:\\n                    dp[i]=dp[prev]+1\\n                    ct[i]=ct[prev]\\n                elif nums[i]>nums[prev] and dp[prev]+1==dp[i]:\\n                    ct[i]+=ct[prev]\\n            maxi=max(maxi,dp[i])\\n        for i in range(n):\\n            if dp[i]==maxi:\\n                c+=ct[i]\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915533,
                "title": "o-n-logn-solution-100-faster-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Binary search\\n\\n# Complexity\\n- Time complexity:O(N * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Create DP array to track smallest ending element of increasing subsequences\\n        vector<int> dp(n+1, INT_MAX);\\n        \\n        // Create 2D vector to store information about increasing subsequences of different lengths\\n        vector<vector<pair<int,int>>> LISbylen(n+1);//count,last ele of that len\\n        \\n        // Initialize base case for DP and LISbylen\\n        dp[0] = INT_MIN;\\n        LISbylen[0] = {{1, INT_MIN}};\\n        \\n        int max_len = 1; // Track the maximum length of increasing subsequences\\n        \\n        // Iterate through each element in the input array\\n        for(auto &ele: nums){\\n            // Find the length of the LIS ending at ele\\n            int len = lower_bound(dp.begin(), dp.end(), ele) - dp.begin();\\n            dp[len] = ele; // Update the DP array\\n            \\n            int ele_count = 0; // Count of subsequences ending at ele\\n            \\n            // Iterate through previous subsequences of length len-1\\n            for(auto &[count, last]: LISbylen[len-1]){\\n                if(ele > last) {\\n                    ele_count += count; // Increment count for valid extensions\\n                }\\n            }\\n            \\n            // Store the information about the new subsequence ending at ele\\n            LISbylen[len].push_back({ele_count, ele});\\n            \\n            // Update the maximum length of increasing subsequences\\n            max_len = max(max_len, len);\\n        }\\n        \\n        int num_lis = 0; // Total number of Longest Increasing Subsequences\\n        \\n        // Count the number of LIS by summing counts of subsequences of maximum length\\n        for(auto &[count, last]: LISbylen[max_len]){\\n            num_lis += count;\\n        }\\n        \\n        return num_lis;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Create DP array to track smallest ending element of increasing subsequences\\n        vector<int> dp(n+1, INT_MAX);\\n        \\n        // Create 2D vector to store information about increasing subsequences of different lengths\\n        vector<vector<pair<int,int>>> LISbylen(n+1);//count,last ele of that len\\n        \\n        // Initialize base case for DP and LISbylen\\n        dp[0] = INT_MIN;\\n        LISbylen[0] = {{1, INT_MIN}};\\n        \\n        int max_len = 1; // Track the maximum length of increasing subsequences\\n        \\n        // Iterate through each element in the input array\\n        for(auto &ele: nums){\\n            // Find the length of the LIS ending at ele\\n            int len = lower_bound(dp.begin(), dp.end(), ele) - dp.begin();\\n            dp[len] = ele; // Update the DP array\\n            \\n            int ele_count = 0; // Count of subsequences ending at ele\\n            \\n            // Iterate through previous subsequences of length len-1\\n            for(auto &[count, last]: LISbylen[len-1]){\\n                if(ele > last) {\\n                    ele_count += count; // Increment count for valid extensions\\n                }\\n            }\\n            \\n            // Store the information about the new subsequence ending at ele\\n            LISbylen[len].push_back({ele_count, ele});\\n            \\n            // Update the maximum length of increasing subsequences\\n            max_len = max(max_len, len);\\n        }\\n        \\n        int num_lis = 0; // Total number of Longest Increasing Subsequences\\n        \\n        // Count the number of LIS by summing counts of subsequences of maximum length\\n        for(auto &[count, last]: LISbylen[max_len]){\\n            num_lis += count;\\n        }\\n        \\n        return num_lis;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798520,
                "title": "python-short-and-clean-3-solutions-o-n-log-n-functional-programming",
                "content": "# Approach 1: Recursive DP\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: list[int]) -> int:\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf # To avoid using nums.append(inf)\\n\\n        @cache\\n        def lis_len_count(i: int) -> tuple[int, int]: # Index -> (LIS length, LIS count) ending at Index\\n            len_counts = [lis_len_count(j) for j in range(min(i, n)) if get(nums, j) < get(nums, i)]\\n            m_len = max(len_counts, default=(0, 0))[0]\\n            return m_len + 1, max(sum(c for l, c in len_counts if l == m_len), 1)\\n        \\n        return lis_len_count(n)[1]\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: Iterative DP\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf # To avoid using nums.append(inf)\\n\\n        lis_len_count = [(0, 0)] * (n + 1) # Index -> (LIS length, LIS count) ending at Index\\n        lis_len_count[0] = (1, 1)\\n\\n        for i in range(n + 1):\\n            len_counts = [lis_len_count[j] for j in range(min(i, n)) if get(nums, j) < get(nums, i)]\\n            m_len = max(len_counts, default=(0, 0))[0]\\n            lis_len_count[i] = (m_len + 1, max(sum(c for l, c in len_counts if l == m_len), 1))\\n        \\n        return lis_len_count[-1][1]\\n\\n\\n```\\n\\n---\\n\\n# Approach 3: Segment tree\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\cdot log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n\\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        default_value = (0, 1) # (lts_length, lts_count)\\n        \\n        def merge(x, y):\\n            return (x[0], x[1] + y[1]) if x[0] == y[0] and x[0] != 0 else max(x, y)\\n \\n        if not nums: return 0\\n        \\n        start, end = min(nums), max(nums)\\n        st = SegmentTree(start, end, default_value, merge)\\n        for num in nums:\\n            res = st.query(start, num - 1)\\n            st.insert(num, (res[0] + 1, res[1]))\\n        return st.root.value[1]\\n        \\n\\nfrom typing import Callable, TypeVar\\n\\nT = TypeVar(\"T\")\\n\\n\\nclass SegmentTree:\\n    class Node:\\n        def __init__(self, value: T, start: int, end: int, left=None, right=None):\\n            self.value = value\\n            self.start = start\\n            self.end = end\\n            self.left = left\\n            self.right = right\\n\\n        @property\\n        def mid(self):\\n            return (self.start + self.end) // 2\\n\\n    def __init__(\\n        self, start: int, end: int, default_value: T, func: Callable[[T, T], T]\\n    ):\\n        self.func = func\\n        self.default_value = default_value\\n        self.root = SegmentTree.Node(default_value, start, end)\\n\\n    def safe_left(self, node: Node):\\n        node.left = (\\n            node.left\\n            if node.left\\n            else SegmentTree.Node(self.default_value, node.start, node.mid)\\n        )\\n        return node.left\\n\\n    def safe_right(self, node: Node):\\n        node.right = (\\n            node.right\\n            if node.right\\n            else SegmentTree.Node(self.default_value, node.mid + 1, node.end)\\n        )\\n        return node.right\\n\\n    def insert(self, key: int, value: T) -> None:\\n        def insert_segment(node: SegmentTree.Node):\\n            if node.start == node.end:\\n                node.value = self.func(value, node.value)\\n                return\\n\\n            if key <= node.mid:\\n                insert_segment(self.safe_left(node))\\n            elif key > node.mid:\\n                insert_segment(self.safe_right(node))\\n\\n            node.value = self.func(\\n                self.safe_left(node).value, self.safe_right(node).value\\n            )\\n\\n        insert_segment(self.root)\\n\\n    def update(self, key: int, value: T) -> None:\\n        self.insert(key, value)\\n\\n    def query(self, start: int, end: int) -> int:\\n        def query_segment(node: SegmentTree.Node):\\n            if start <= node.start <= node.end <= end:\\n                return node.value\\n\\n            if end < start or end < node.start or node.end < start:\\n                return self.default_value\\n\\n            left_value = query_segment(self.safe_left(node))\\n            right_value = query_segment(self.safe_right(node))\\n\\n            return self.func(left_value, right_value)\\n\\n        return query_segment(self.root)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: list[int]) -> int:\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf # To avoid using nums.append(inf)\\n\\n        @cache\\n        def lis_len_count(i: int) -> tuple[int, int]: # Index -> (LIS length, LIS count) ending at Index\\n            len_counts = [lis_len_count(j) for j in range(min(i, n)) if get(nums, j) < get(nums, i)]\\n            m_len = max(len_counts, default=(0, 0))[0]\\n            return m_len + 1, max(sum(c for l, c in len_counts if l == m_len), 1)\\n        \\n        return lis_len_count(n)[1]\\n\\n\\n```\n```python\\n        n = len(nums)\\n        get = lambda xs, i: xs[i] if i < n else inf # To avoid using nums.append(inf)\\n\\n        lis_len_count = [(0, 0)] * (n + 1) # Index -> (LIS length, LIS count) ending at Index\\n        lis_len_count[0] = (1, 1)\\n\\n        for i in range(n + 1):\\n            len_counts = [lis_len_count[j] for j in range(min(i, n)) if get(nums, j) < get(nums, i)]\\n            m_len = max(len_counts, default=(0, 0))[0]\\n            lis_len_count[i] = (m_len + 1, max(sum(c for l, c in len_counts if l == m_len), 1))\\n        \\n        return lis_len_count[-1][1]\\n\\n\\n```\n```python\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        default_value = (0, 1) # (lts_length, lts_count)\\n        \\n        def merge(x, y):\\n            return (x[0], x[1] + y[1]) if x[0] == y[0] and x[0] != 0 else max(x, y)\\n \\n        if not nums: return 0\\n        \\n        start, end = min(nums), max(nums)\\n        st = SegmentTree(start, end, default_value, merge)\\n        for num in nums:\\n            res = st.query(start, num - 1)\\n            st.insert(num, (res[0] + 1, res[1]))\\n        return st.root.value[1]\\n        \\n\\nfrom typing import Callable, TypeVar\\n\\nT = TypeVar(\"T\")\\n\\n\\nclass SegmentTree:\\n    class Node:\\n        def __init__(self, value: T, start: int, end: int, left=None, right=None):\\n            self.value = value\\n            self.start = start\\n            self.end = end\\n            self.left = left\\n            self.right = right\\n\\n        @property\\n        def mid(self):\\n            return (self.start + self.end) // 2\\n\\n    def __init__(\\n        self, start: int, end: int, default_value: T, func: Callable[[T, T], T]\\n    ):\\n        self.func = func\\n        self.default_value = default_value\\n        self.root = SegmentTree.Node(default_value, start, end)\\n\\n    def safe_left(self, node: Node):\\n        node.left = (\\n            node.left\\n            if node.left\\n            else SegmentTree.Node(self.default_value, node.start, node.mid)\\n        )\\n        return node.left\\n\\n    def safe_right(self, node: Node):\\n        node.right = (\\n            node.right\\n            if node.right\\n            else SegmentTree.Node(self.default_value, node.mid + 1, node.end)\\n        )\\n        return node.right\\n\\n    def insert(self, key: int, value: T) -> None:\\n        def insert_segment(node: SegmentTree.Node):\\n            if node.start == node.end:\\n                node.value = self.func(value, node.value)\\n                return\\n\\n            if key <= node.mid:\\n                insert_segment(self.safe_left(node))\\n            elif key > node.mid:\\n                insert_segment(self.safe_right(node))\\n\\n            node.value = self.func(\\n                self.safe_left(node).value, self.safe_right(node).value\\n            )\\n\\n        insert_segment(self.root)\\n\\n    def update(self, key: int, value: T) -> None:\\n        self.insert(key, value)\\n\\n    def query(self, start: int, end: int) -> int:\\n        def query_segment(node: SegmentTree.Node):\\n            if start <= node.start <= node.end <= end:\\n                return node.value\\n\\n            if end < start or end < node.start or node.end < start:\\n                return self.default_value\\n\\n            left_value = query_segment(self.safe_left(node))\\n            right_value = query_segment(self.safe_right(node))\\n\\n            return self.func(left_value, right_value)\\n\\n        return query_segment(self.root)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798495,
                "title": "easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int findNumberOfLIS(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>dp(n,1);\\n        int mx=1;\\n        vector<int>ct(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(v[i]>v[j]){\\n                    if(dp[i]<dp[j]+1){\\n                        dp[i]=dp[j]+1;\\n                        ct[i]=ct[j];\\n                    }\\n                    else if(dp[i]==dp[j]+1){\\n                        ct[i]+=ct[j];\\n                    }\\n                }\\n                mx=max(mx,dp[i]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            cout<<ct[i]<<\" \";\\n            if(dp[i]==mx)ans+=ct[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int findNumberOfLIS(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>dp(n,1);\\n        int mx=1;\\n        vector<int>ct(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(v[i]>v[j]){\\n                    if(dp[i]<dp[j]+1){\\n                        dp[i]=dp[j]+1;\\n                        ct[i]=ct[j];\\n                    }\\n                    else if(dp[i]==dp[j]+1){\\n                        ct[i]+=ct[j];\\n                    }\\n                }\\n                mx=max(mx,dp[i]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            cout<<ct[i]<<\" \";\\n            if(dp[i]==mx)ans+=ct[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3798321,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int max=1;\\n        Arrays.fill(arr,1);\\n        int count[]=new int[nums.length];\\n        Arrays.fill(count , 1);\\n        int ans=0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[j]<nums[i]){\\n                    if(arr[i]==arr[j]+1){\\n                        count[i]+=count[j];\\n                    }else if(arr[i]<arr[j]+1){\\n                        arr[i]=arr[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            max=Math.max(arr[i] , max);\\n        }\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]==max){\\n                ans=count[i]+ans;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int max=1;\\n        Arrays.fill(arr,1);\\n        int count[]=new int[nums.length];\\n        Arrays.fill(count , 1);\\n        int ans=0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[j]<nums[i]){\\n                    if(arr[i]==arr[j]+1){\\n                        count[i]+=count[j];\\n                    }else if(arr[i]<arr[j]+1){\\n                        arr[i]=arr[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<arr.length; i++){\\n            max=Math.max(arr[i] , max);\\n        }\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]==max){\\n                ans=count[i]+ans;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797844,
                "title": "python3-92-faster-beats-984ms-different-from-other-popular-answers",
                "content": "![image.png](https://assets.leetcode.com/users/images/f9924688-f2d5-4df7-a5b6-45f4a5904fb2_1689959631.708924.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        ct = defaultdict(list)\\n        ct[0] = [1,1]\\n        length,longest,ans = len(nums),1,1\\n\\n        for right in range(1,length):\\n            map,cur_longest = defaultdict(lambda:1),1\\n            for left in range(right-1,-1,-1):\\n                if nums[right] > nums[left] and ct[left][0]+1>=cur_longest:\\n                    temp_long,temp_ct = ct[left]\\n                    cur_longest = temp_long+1\\n                    map[cur_longest] += temp_ct\\n            if map:\\n                map[cur_longest]-=1\\n                ct[right] = [cur_longest,map[cur_longest]]\\n            else:\\n                ct[right] = ct[0]\\n            if cur_longest > longest:\\n                longest,ans = cur_longest,map[cur_longest]\\n            elif cur_longest == longest:\\n                ans += map[cur_longest]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        ct = defaultdict(list)\\n        ct[0] = [1,1]\\n        length,longest,ans = len(nums),1,1\\n\\n        for right in range(1,length):\\n            map,cur_longest = defaultdict(lambda:1),1\\n            for left in range(right-1,-1,-1):\\n                if nums[right] > nums[left] and ct[left][0]+1>=cur_longest:\\n                    temp_long,temp_ct = ct[left]\\n                    cur_longest = temp_long+1\\n                    map[cur_longest] += temp_ct\\n            if map:\\n                map[cur_longest]-=1\\n                ct[right] = [cur_longest,map[cur_longest]]\\n            else:\\n                ct[right] = ct[0]\\n            if cur_longest > longest:\\n                longest,ans = cur_longest,map[cur_longest]\\n            elif cur_longest == longest:\\n                ans += map[cur_longest]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797763,
                "title": "easy-dp-solution-in-c-java-javascript",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1), count(n, 1);\\n        int res = 0, maxi = 1;\\n\\n        for(int i = 0; i < n; ++i){\\n            for(int prev = 0; prev < i; ++prev){\\n                if(nums[prev] < nums[i] && 1 + dp[prev] > dp[i]){\\n                    dp[i] = 1 + dp[prev];\\n                    count[i] = count[prev];\\n                } else if(nums[prev] < nums[i] && 1 + dp[prev] == dp[i]) count[i] += count[prev];\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n\\n        for(int i = 0; i < n; ++i)\\n            if(dp[i] == maxi)\\n                res += count[i];\\n\\n        return res;\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n], count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n        int res = 0, maxi = 1;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int prev = 0; prev < i; ++prev) {\\n                if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                    count[i] = count[prev];\\n                } else if (nums[prev] < nums[i] && 1 + dp[prev] == dp[i])\\n                    count[i] += count[prev];\\n            }\\n            maxi = Math.max(maxi, dp[i]);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == maxi)\\n                res += count[i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n# JAVASCRIPT\\n```\\nvar findNumberOfLIS = function (nums) {\\n    let n = nums.length;\\n    let dp = new Array(n).fill(1), count = new Array(n).fill(1);\\n    let res = 0, maxi = 1;\\n\\n    for (let i = 0; i < n; ++i) {\\n        for (let prev = 0; prev < i; ++prev) {\\n            if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                dp[i] = 1 + dp[prev];\\n                count[i] = count[prev];\\n            } else if (nums[prev] < nums[i] && 1 + dp[prev] == dp[i]) count[i] += count[prev];\\n        }\\n        maxi = Math.max(maxi, dp[i]);\\n    }\\n\\n    for (let i = 0; i < n; ++i) {\\n        if (maxi == dp[i])\\n            res += count[i];\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1), count(n, 1);\\n        int res = 0, maxi = 1;\\n\\n        for(int i = 0; i < n; ++i){\\n            for(int prev = 0; prev < i; ++prev){\\n                if(nums[prev] < nums[i] && 1 + dp[prev] > dp[i]){\\n                    dp[i] = 1 + dp[prev];\\n                    count[i] = count[prev];\\n                } else if(nums[prev] < nums[i] && 1 + dp[prev] == dp[i]) count[i] += count[prev];\\n            }\\n            maxi = max(maxi, dp[i]);\\n        }\\n\\n        for(int i = 0; i < n; ++i)\\n            if(dp[i] == maxi)\\n                res += count[i];\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n], count = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(count, 1);\\n        int res = 0, maxi = 1;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int prev = 0; prev < i; ++prev) {\\n                if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                    count[i] = count[prev];\\n                } else if (nums[prev] < nums[i] && 1 + dp[prev] == dp[i])\\n                    count[i] += count[prev];\\n            }\\n            maxi = Math.max(maxi, dp[i]);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == maxi)\\n                res += count[i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\nvar findNumberOfLIS = function (nums) {\\n    let n = nums.length;\\n    let dp = new Array(n).fill(1), count = new Array(n).fill(1);\\n    let res = 0, maxi = 1;\\n\\n    for (let i = 0; i < n; ++i) {\\n        for (let prev = 0; prev < i; ++prev) {\\n            if (nums[prev] < nums[i] && 1 + dp[prev] > dp[i]) {\\n                dp[i] = 1 + dp[prev];\\n                count[i] = count[prev];\\n            } else if (nums[prev] < nums[i] && 1 + dp[prev] == dp[i]) count[i] += count[prev];\\n        }\\n        maxi = Math.max(maxi, dp[i]);\\n    }\\n\\n    for (let i = 0; i < n; ++i) {\\n        if (maxi == dp[i])\\n            res += count[i];\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797416,
                "title": "673-number-of-longest-increasing-subsequence-java",
                "content": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int [] dp = new int[n];\\n        int [] cnt = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(cnt,1);\\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                        if (dp[j] + 1 > dp[i]) {\\n                            dp[i] = dp[j] + 1;\\n                            cnt[i] = cnt[j];\\n                        } else if (dp[j] + 1 == dp[i]) {\\n                            cnt[i] += cnt[j];\\n                        }\\n                max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == max) {\\n                ans += cnt[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int [] dp = new int[n];\\n        int [] cnt = new int[n];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(cnt,1);\\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] > nums[j]) {\\n                        if (dp[j] + 1 > dp[i]) {\\n                            dp[i] = dp[j] + 1;\\n                            cnt[i] = cnt[j];\\n                        } else if (dp[j] + 1 == dp[i]) {\\n                            cnt[i] += cnt[j];\\n                        }\\n                max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] == max) {\\n                ans += cnt[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797256,
                "title": "c-java-easy-and-clean-code-dp-bottom-up-beats",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n<!-- > **Please do UpVote** it took lot of time to figure out these solutions -->\\n\\n# Complexity \\n<!-- - Please check the code, as every solution have different complexity -->\\n- Time complexity: $$O(N^2)$$ where `N = nums.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), lenLis = 1;\\n        vector<int> dp(n, 1), cnt(n, 1);\\n        // dp[i] = length of LIS ending at index i\\n        // cnt[i] = count of LIS of length dp[i] ending at index i\\n    \\n        for(int i=0; i<n; i++){\\n            for(int prev = 0; prev < i; prev++ ){\\n                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){\\n                    dp[i] = dp[prev] + 1; \\n                    cnt[i] = cnt[prev];\\n                }\\n                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];\\n            } \\n            lenLis = max(lenLis, dp[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, lenLis = 1;\\n        int dp[] = new int[n], cnt[] = new int[n];\\n        // dp[i] = length of LIS ending at index i\\n        // cnt[i] = count of LIS of length dp[i] ending at index i\\n    \\n        for(int i=0; i<n; i++){\\n            dp[i] = cnt[i] = 1;\\n            for(int prev = 0; prev < i; prev++ ){\\n                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){\\n                    dp[i] = dp[prev] + 1; \\n                    cnt[i] = cnt[prev];\\n                }\\n                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];\\n            } \\n            lenLis = Math.max(lenLis, dp[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);\\n        return ans;\\n    }\\n}\\n```\\n\\n![upvote-4.png](https://assets.leetcode.com/users/images/5af4e2a5-e8b2-4f46-be00-75247cfdf9ff_1689947516.7818904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), lenLis = 1;\\n        vector<int> dp(n, 1), cnt(n, 1);\\n        // dp[i] = length of LIS ending at index i\\n        // cnt[i] = count of LIS of length dp[i] ending at index i\\n    \\n        for(int i=0; i<n; i++){\\n            for(int prev = 0; prev < i; prev++ ){\\n                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){\\n                    dp[i] = dp[prev] + 1; \\n                    cnt[i] = cnt[prev];\\n                }\\n                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];\\n            } \\n            lenLis = max(lenLis, dp[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findNumberOfLIS(int[] nums) {\\n        int n = nums.length, lenLis = 1;\\n        int dp[] = new int[n], cnt[] = new int[n];\\n        // dp[i] = length of LIS ending at index i\\n        // cnt[i] = count of LIS of length dp[i] ending at index i\\n    \\n        for(int i=0; i<n; i++){\\n            dp[i] = cnt[i] = 1;\\n            for(int prev = 0; prev < i; prev++ ){\\n                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){\\n                    dp[i] = dp[prev] + 1; \\n                    cnt[i] = cnt[prev];\\n                }\\n                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];\\n            } \\n            lenLis = Math.max(lenLis, dp[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797143,
                "title": "ruby-solution",
                "content": "# Code\\n```ruby []\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_number_of_lis(nums)\\n  result = [[[-Float::INFINITY,1]]]\\n  \\n  nums.each do |num|\\n    reference_index = result.bsearch_index {|arr| arr.first.first >= num}\\n\\n    unless reference_index\\n      reference_index = result.size\\n      result << [[num, 0]]\\n    end\\n\\n    unless result[reference_index].first.first == num\\n      result[reference_index].unshift [num, 0]\\n    end\\n\\n    sum = result[reference_index - 1].select {|arr| arr.first < num}.sum(&:last)\\n    result[reference_index].first[1] += sum\\n  end\\n  \\n  result.last.sum(&:last)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_number_of_lis(nums)\\n  result = [[[-Float::INFINITY,1]]]\\n  \\n  nums.each do |num|\\n    reference_index = result.bsearch_index {|arr| arr.first.first >= num}\\n\\n    unless reference_index\\n      reference_index = result.size\\n      result << [[num, 0]]\\n    end\\n\\n    unless result[reference_index].first.first == num\\n      result[reference_index].unshift [num, 0]\\n    end\\n\\n    sum = result[reference_index - 1].select {|arr| arr.first < num}.sum(&:last)\\n    result[reference_index].first[1] += sum\\n  end\\n  \\n  result.last.sum(&:last)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3796978,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\nWe will use a dynamic programming approach to track the lengths and counts of increasing subsequences ending at each position in the array. The final answer will be the sum of the counts of subsequences with the maximum length.\\n\\n# Approach\\n\\n\\n1. We initialize two lists `lengths` and `counts`, each with a length equal to the number of elements in the input array `nums`.\\n2. We iterate through the array with two nested loops. For each element at index `i`, we compare it with all previous elements at indices `j < i`.\\n3. If `nums[i] > nums[j]`, it means we can extend the increasing subsequence ending at index `j` by adding element `i`. We then check if this extension results in a longer subsequence (`lengths[j] + 1 > lengths[i]`), and update the `lengths` and `counts` lists accordingly.\\n4. After the iteration, we have the length of the longest increasing subsequence in the variable `max_length`. We then calculate the total count of subsequences with that length and return it.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n == 0:\\n            return 0\\n        \\n        lengths = [1] * n\\n        counts = [1] * n\\n        for i in range(1,n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        \\n        max_length= max(lengths)\\n        total_count= sum(count for length , count in zip(lengths,counts) if length == max_length)\\n\\n        return total_count\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n == 0:\\n            return 0\\n        \\n        lengths = [1] * n\\n        counts = [1] * n\\n        for i in range(1,n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        \\n        max_length= max(lengths)\\n        total_count= sum(count for length , count in zip(lengths,counts) if length == max_length)\\n\\n        return total_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796920,
                "title": "easy-begineer-friendly",
                "content": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n <= 1:\\n            return n\\n\\n        lengths = [1] * n\\n        counts = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        max_length = max(lengths)\\n        return sum(count for length, count in zip(lengths, counts) if length == max_length)\\n\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/47b0286e-43c1-4f87-a09f-327ece584735_1689943499.6379132.jpeg)\\nPlease Upvote me :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n <= 1:\\n            return n\\n\\n        lengths = [1] * n\\n        counts = [1] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    if lengths[j] + 1 > lengths[i]:\\n                        lengths[i] = lengths[j] + 1\\n                        counts[i] = counts[j]\\n                    elif lengths[j] + 1 == lengths[i]:\\n                        counts[i] += counts[j]\\n\\n        max_length = max(lengths)\\n        return sum(count for length, count in zip(lengths, counts) if length == max_length)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796763,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxlen = 1, ans = 0;\\n        vector<int> cnt(n, 1), len(n, 1);\\n        for (int i = 1; i < n; i++) \\n        {\\n            for (int j = 0; j < i; j++) \\n            {\\n                if (nums[i] > nums[j]) \\n                {\\n                    if (len[j]+1 > len[i]) \\n                    {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    else if (len[j]+1 == len[i]) \\n                        cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, len[i]);\\n        }\\n        for (int i = 0; i < n; i++) \\n            if (len[i] == maxlen) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size(), maxlen = 1, ans = 0;\\n        vector<int> cnt(n, 1), len(n, 1);\\n        for (int i = 1; i < n; i++) \\n        {\\n            for (int j = 0; j < i; j++) \\n            {\\n                if (nums[i] > nums[j]) \\n                {\\n                    if (len[j]+1 > len[i]) \\n                    {\\n                        len[i] = len[j]+1;\\n                        cnt[i] = cnt[j];\\n                    }\\n                    else if (len[j]+1 == len[i]) \\n                        cnt[i] += cnt[j];\\n                }\\n            }\\n            maxlen = max(maxlen, len[i]);\\n        }\\n        for (int i = 0; i < n; i++) \\n            if (len[i] == maxlen) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796020,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Recursive    \\n      //length,no.of occurences \\n    pair<int,int> calculateNoOfLIS(vector<int>& nums,int prev,int curr){\\n        if(curr==nums.size()){\\n            return {0,1};\\n        }\\n\\n        pair<int,int> include;\\n        pair<int,int> exclude;\\n\\n        if(prev==-1 || nums[curr]>nums[prev]){\\n            include=calculateNoOfLIS(nums,curr,curr+1);\\n            include.first++;\\n        }\\n\\n        exclude=calculateNoOfLIS(nums,prev,curr+1);\\n        if(include.first==exclude.first){\\n            return {include.first,include.second+exclude.second};\\n        }\\n        else if(include.first>exclude.first){\\n            return include;\\n        }\\n        else{\\n            return exclude;\\n        }\\n    }\\n\\n      //length,no.of occurences \\n    pair<int,int> calculateNoOfLISMemoization(vector<int>& nums,int prev,int curr,vector<vector<pair<int,int>>> &dp){\\n        if(curr==nums.size()){\\n            return {0,1};\\n        }\\n        if(dp[prev+1][curr].first!=-1){\\n            return dp[prev+1][curr];\\n        }\\n        pair<int,int> include;\\n        pair<int,int> exclude;\\n\\n        if(prev==-1 || nums[curr]>nums[prev]){\\n            include=calculateNoOfLISMemoization(nums,curr,curr+1,dp);\\n            include.first++;\\n        }\\n\\n        exclude=calculateNoOfLISMemoization(nums,prev,curr+1,dp);\\n        if(include.first==exclude.first){\\n            dp[prev+1][curr]={include.first,include.second+exclude.second};\\n        }\\n        else if(include.first>exclude.first){\\n            dp[prev+1][curr]= include;\\n        }\\n        else{\\n            dp[prev+1][curr]= exclude;\\n        }\\n        return dp[prev+1][curr];\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<vector<pair<int,int>>> dp(nums.size()+1,vector<pair<int,int>>(nums.size()+1,{-1,-1}));\\n        //return calculateNoOfLIS(nums,-1,0).second;\\n        return calculateNoOfLISMemoization(nums,-1,0,dp).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Recursive    \\n      //length,no.of occurences \\n    pair<int,int> calculateNoOfLIS(vector<int>& nums,int prev,int curr){\\n        if(curr==nums.size()){\\n            return {0,1};\\n        }\\n\\n        pair<int,int> include;\\n        pair<int,int> exclude;\\n\\n        if(prev==-1 || nums[curr]>nums[prev]){\\n            include=calculateNoOfLIS(nums,curr,curr+1);\\n            include.first++;\\n        }\\n\\n        exclude=calculateNoOfLIS(nums,prev,curr+1);\\n        if(include.first==exclude.first){\\n            return {include.first,include.second+exclude.second};\\n        }\\n        else if(include.first>exclude.first){\\n            return include;\\n        }\\n        else{\\n            return exclude;\\n        }\\n    }\\n\\n      //length,no.of occurences \\n    pair<int,int> calculateNoOfLISMemoization(vector<int>& nums,int prev,int curr,vector<vector<pair<int,int>>> &dp){\\n        if(curr==nums.size()){\\n            return {0,1};\\n        }\\n        if(dp[prev+1][curr].first!=-1){\\n            return dp[prev+1][curr];\\n        }\\n        pair<int,int> include;\\n        pair<int,int> exclude;\\n\\n        if(prev==-1 || nums[curr]>nums[prev]){\\n            include=calculateNoOfLISMemoization(nums,curr,curr+1,dp);\\n            include.first++;\\n        }\\n\\n        exclude=calculateNoOfLISMemoization(nums,prev,curr+1,dp);\\n        if(include.first==exclude.first){\\n            dp[prev+1][curr]={include.first,include.second+exclude.second};\\n        }\\n        else if(include.first>exclude.first){\\n            dp[prev+1][curr]= include;\\n        }\\n        else{\\n            dp[prev+1][curr]= exclude;\\n        }\\n        return dp[prev+1][curr];\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<vector<pair<int,int>>> dp(nums.size()+1,vector<pair<int,int>>(nums.size()+1,{-1,-1}));\\n        //return calculateNoOfLIS(nums,-1,0).second;\\n        return calculateNoOfLISMemoization(nums,-1,0,dp).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795799,
                "title": "ruby-solution-with-tests-beats-100-and-100",
                "content": "# Approach\\nDynamic Programming\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_number_of_lis(nums)\\n  n = nums.length\\n  return 0 if n == 0\\n  dp = Array.new(n, 1)\\n  count = Array.new(n, 1)\\n\\n  (0...n).each do |i|\\n    (0...i).each do |j|\\n      if nums[i] > nums[j]\\n        if dp[i] == dp[j] + 1\\n          count[i] += count[j]\\n        elsif dp[i] < dp[j] + 1\\n          dp[i] = dp[j] + 1\\n          count[i] = count[j]\\n        end\\n      end\\n    end\\n  end\\n\\n  max_length = dp.max\\n  count.select.with_index { |_, i| dp[i] == max_length }.sum\\nend\\n\\n# **************** #\\n#       TEST       #\\n# **************** #\\n\\nrequire \"test/unit\"\\nclass Test_find_number_of_lis < Test::Unit::TestCase\\n  def test_\\n    assert_equal 2, find_number_of_lis([1, 3, 5, 4, 7])\\n    assert_equal 5, find_number_of_lis([2, 2, 2, 2, 2])\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_number_of_lis(nums)\\n  n = nums.length\\n  return 0 if n == 0\\n  dp = Array.new(n, 1)\\n  count = Array.new(n, 1)\\n\\n  (0...n).each do |i|\\n    (0...i).each do |j|\\n      if nums[i] > nums[j]\\n        if dp[i] == dp[j] + 1\\n          count[i] += count[j]\\n        elsif dp[i] < dp[j] + 1\\n          dp[i] = dp[j] + 1\\n          count[i] = count[j]\\n        end\\n      end\\n    end\\n  end\\n\\n  max_length = dp.max\\n  count.select.with_index { |_, i| dp[i] == max_length }.sum\\nend\\n\\n# **************** #\\n#       TEST       #\\n# **************** #\\n\\nrequire \"test/unit\"\\nclass Test_find_number_of_lis < Test::Unit::TestCase\\n  def test_\\n    assert_equal 2, find_number_of_lis([1, 3, 5, 4, 7])\\n    assert_equal 5, find_number_of_lis([2, 2, 2, 2, 2])\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795268,
                "title": "step-by-step-explanation-short-and-optimize-code",
                "content": "# Intuition\\nThe problem requires finding the number of longest increasing subsequences in the given array of numbers. We can use a dynamic programming approach to solve this problem.\\n\\n# Approach\\nWe will use two arrays lis and cnt. The lis array will keep track of the length of the longest increasing subsequence ending at each index, and the cnt array will keep track of the count of the longest increasing subsequences ending at each index.\\n\\nTo fill these arrays, we will iterate through the array from right to left. For each index i, we will find the length of the longest increasing subsequence ending at that index and store it in the lis array. We will also keep track of the count of such subsequences and store it in the cnt array.\\n\\nTo compute the lis value at each index i, we will iterate through the array from i + 1 to the end. For each index j, if the element at index j is greater than the element at index i, we can extend the increasing subsequence ending at index i by one, and the length of the longest increasing subsequence ending at index j will be lis[j] + 1. We will take the maximum of all such values to get the lis value for index i.\\n\\nWhile calculating the lis value, we will also keep track of the count of such subsequences. If the lis value for index j plus one is greater than the current lis value for index i, it means we have found a new longer subsequence, so we set the cnt value for index i to the cnt value for index j. If the lis value for index j plus one is equal to the current lis value for index i, it means we have found another subsequence of the same length, so we add the cnt value for index j to the cnt value for index i.\\n\\nAfter filling the lis and cnt arrays, we find the maximum value in the lis array, which represents the length of the longest increasing subsequence. Then we iterate through the lis array and add up the cnt values for all indices where the lis value matches the maximum value. This will give us the total count of the longest increasing subsequences in the array.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is O(n^2), where n is the number of elements in the array. We iterate through the array twice, once to compute the lis and cnt arrays, and then to find the count of longest increasing subsequences.\\n- Space complexity: The space complexity is O(n) as we use two arrays lis and cnt of length n to store the intermediate results.\\n\\n# Code\\n```\\nfunction findNumberOfLIS(nums: number[]): number {\\n    let n = nums.length, lis = new Array(n).fill(1), cnt = new Array(n).fill(1);\\n    for( let i = n - 2 ; i >= 0 ; i-- ){\\n        let max = 1, c = 1;\\n        for( let j = i + 1 ; j < n ; j++ ){\\n            if( nums[i] < nums[j] ){\\n                if( max < lis[j] + 1 ){\\n                    max = lis[j] + 1;\\n                    c = cnt[j]\\n                }\\n                else if( max === lis[j] + 1 )c += cnt[j];\\n            }\\n        }\\n        lis[i] = max;\\n        cnt[i] = c;\\n    }\\n    let max = Math.max(...lis), res = 0;\\n    for( let i = 0 ; i < n ; i++ )if( max === lis[i])res += cnt[i];\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction findNumberOfLIS(nums: number[]): number {\\n    let n = nums.length, lis = new Array(n).fill(1), cnt = new Array(n).fill(1);\\n    for( let i = n - 2 ; i >= 0 ; i-- ){\\n        let max = 1, c = 1;\\n        for( let j = i + 1 ; j < n ; j++ ){\\n            if( nums[i] < nums[j] ){\\n                if( max < lis[j] + 1 ){\\n                    max = lis[j] + 1;\\n                    c = cnt[j]\\n                }\\n                else if( max === lis[j] + 1 )c += cnt[j];\\n            }\\n        }\\n        lis[i] = max;\\n        cnt[i] = c;\\n    }\\n    let max = Math.max(...lis), res = 0;\\n    for( let i = 0 ; i < n ; i++ )if( max === lis[i])res += cnt[i];\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3795256,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,1), cnt(n,1);\\n        int maxi = 1;\\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < i; ++j){\\n                if(nums[i] > nums[j] && dp[i] < dp[j] + 1)\\n                {\\n                    dp[i] = 1 + dp[j];\\n                    cnt[i] = cnt[j];\\n                }\\n                else if(nums[i] > nums[j] && dp[i] == 1 + dp[j])\\n                    cnt[i] += cnt[j];     \\n                maxi = max(maxi,dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i)\\n            if(dp[i] == maxi) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,1), cnt(n,1);\\n        int maxi = 1;\\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < i; ++j){\\n                if(nums[i] > nums[j] && dp[i] < dp[j] + 1)\\n                {\\n                    dp[i] = 1 + dp[j];\\n                    cnt[i] = cnt[j];\\n                }\\n                else if(nums[i] > nums[j] && dp[i] == 1 + dp[j])\\n                    cnt[i] += cnt[j];     \\n                maxi = max(maxi,dp[i]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i)\\n            if(dp[i] == maxi) ans += cnt[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795253,
                "title": "c-solution-dynamic-programming-supereasy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n                         `Bottom-up Dynamic Programming`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Firstly, a dynamic programming (DP) array `dp` of pairs is created. Each element of dp is a pair of integers, denoting `{length_of_lis, count_of_lis}`. Initially, the length of the longest increasing subsequence (LIS) ending at each index is set to 1, and the count of such subsequences is also set to 1.\\n\\n2. The variables `maxi` and `cnt` will be used to keep track of the maximum LIS length found so far and the count of such LIS.\\n\\n3. The nested loops that follow perform a DP calculation to find the length of the LIS ending at each index of the input array nums. The outer loop runs from i = 0 to i = n-1, representing the current index, and the inner loop runs from j = 0 to j = i-1, representing all previous indices.\\n\\n4. Inside the nested loops, the code checks if the element at index i `nums[i]` is greater than the element at index j `nums[j]`. If this condition is true, it means that we can extend the LIS ending at index j with the element at index i.\\n\\n5. If the length of LIS ending at index i `dp[i].first` is equal to the length of LIS ending at index j plus one `dp[j].first + 1`, then we can simply add the count of LIS ending at index j `dp[j].second` to the count of LIS ending at index i `dp[i].second` since we are extending the existing LIS.\\n\\n6. If the length of LIS ending at index i is less than the length of LIS ending at index j plus one, then we have found a longer LIS ending at index i. In this case, we update the length and count of LIS at index i to be the length of LIS at index j plus one and the count of LIS at index j, respectively.\\n\\n7. After the nested loops, the code updates the `maxi` and cnt variables to keep track of the maximum LIS length found so far and the count of such LIS. The count`cnt` is calculated based on the length and count of LIS at each index of the dp array.\\n\\n8. Finally, the function returns the count of the longest increasing subsequences found in the input vector nums as `cnt`.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        vector<pair<int,int>> dp(n,{1,1});\\n\\n        int maxi=0,cnt=0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n\\n                if(nums[i]>nums[j]){\\n            // //we have found another subsequence with the same length as the one ending at i\\n                    if(dp[i].first==dp[j].first+1){\\n                        dp[i].second+=dp[j].second;\\n                    }\\n            //we have found a new longer subsequence ending at i\\n                    else if(dp[i].first<dp[j].first+1){\\n                        dp[i].second=dp[j].second;\\n                        dp[i].first=dp[j].first+1;\\n                    }\\n                }\\n            }\\n\\n            if(dp[i].first==maxi) cnt+=dp[i].second;\\n\\n            else if(dp[i].first>maxi){\\n                maxi=dp[i].first;\\n                cnt=dp[i].second;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        vector<pair<int,int>> dp(n,{1,1});\\n\\n        int maxi=0,cnt=0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n\\n                if(nums[i]>nums[j]){\\n            // //we have found another subsequence with the same length as the one ending at i\\n                    if(dp[i].first==dp[j].first+1){\\n                        dp[i].second+=dp[j].second;\\n                    }\\n            //we have found a new longer subsequence ending at i\\n                    else if(dp[i].first<dp[j].first+1){\\n                        dp[i].second=dp[j].second;\\n                        dp[i].first=dp[j].first+1;\\n                    }\\n                }\\n            }\\n\\n            if(dp[i].first==maxi) cnt+=dp[i].second;\\n\\n            else if(dp[i].first>maxi){\\n                maxi=dp[i].first;\\n                cnt=dp[i].second;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795051,
                "title": "python-easy-to-understand-medium-problem-673-number-of-longest-increasing-subsequence",
                "content": "# Python | Easy to Understand | Medium Problem | 673. Number of Longest Increasing Subsequence\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        n = len(nums)\\n        m, dp, cnt = 0, [1] * n, [1] * n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]\\n                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]\\n            m = max(m, dp[i])                        \\n        return sum(c for l, c in zip(dp, cnt) if l == m)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        n = len(nums)\\n        m, dp, cnt = 0, [1] * n, [1] * n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[i] < dp[j]+1: dp[i], cnt[i] = dp[j]+1, cnt[j]\\n                    elif dp[i] == dp[j]+1: cnt[i] += cnt[j]\\n            m = max(m, dp[i])                        \\n        return sum(c for l, c in zip(dp, cnt) if l == m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795040,
                "title": "c-dynamic-programming-easy-to-understand-medium-number-of-longest-increasing-subsequence",
                "content": "# C++ | Dynamic Programming | Easy to Understand | Medium Problem | Optimal Solution | 673. Number of Longest Increasing Subsequence\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> size(n, 1);\\n        vector<int> ways(n, 1);\\n\\n        int maxL = 1;\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(nums[i] > nums[j] && size[j] + 1 > size[i]) {\\n                    size[i] = size[j] + 1;\\n                    ways[i] = ways[j];\\n                }\\n                else if(nums[i] > nums[j] && size[j] + 1 == size[i]) {\\n                    ways[i] += ways[j];\\n                }\\n                \\n                maxL = max(maxL, size[i]);\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<n; i++) {\\n            if(size[i] == maxL){\\n                res += ways[i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> size(n, 1);\\n        vector<int> ways(n, 1);\\n\\n        int maxL = 1;\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(nums[i] > nums[j] && size[j] + 1 > size[i]) {\\n                    size[i] = size[j] + 1;\\n                    ways[i] = ways[j];\\n                }\\n                else if(nums[i] > nums[j] && size[j] + 1 == size[i]) {\\n                    ways[i] += ways[j];\\n                }\\n                \\n                maxL = max(maxL, size[i]);\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0; i<n; i++) {\\n            if(size[i] == maxL){\\n                res += ways[i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794978,
                "title": "c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>res(n,1);  //stores len\\n        vector<int>count(n,1);  //stores count\\n        int mxlen=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]<nums[j]) continue;\\n                if(nums[i]>nums[j]){\\n                    if(res[j]+1 > res[i]){\\n                        res[i]=res[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(res[j]+1==res[i]){\\n                        count[i]+=count[j];\\n\\n                    }    \\n                }\\n            }\\n            mxlen=max(mxlen,res[i]);\\n        }\\n        int no_of_lis=0;\\n        for(int i=0;i<n;i++){\\n            if(res[i]==mxlen){\\n                no_of_lis+=count[i];\\n            }\\n        }\\n        return no_of_lis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>res(n,1);  //stores len\\n        vector<int>count(n,1);  //stores count\\n        int mxlen=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]<nums[j]) continue;\\n                if(nums[i]>nums[j]){\\n                    if(res[j]+1 > res[i]){\\n                        res[i]=res[j]+1;\\n                        count[i]=count[j];\\n                    }\\n                    else if(res[j]+1==res[i]){\\n                        count[i]+=count[j];\\n\\n                    }    \\n                }\\n            }\\n            mxlen=max(mxlen,res[i]);\\n        }\\n        int no_of_lis=0;\\n        for(int i=0;i<n;i++){\\n            if(res[i]==mxlen){\\n                no_of_lis+=count[i];\\n            }\\n        }\\n        return no_of_lis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794840,
                "title": "commented-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n),count(n);\\n        int ans = 0;\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            dp[i] = 1;\\n            count[i] = 1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i] > nums[j] && dp[j] + 1 > dp[i]){ // Basic LIS conditions\\n                    dp[i] = dp[j] + 1;\\n                    count[i] = count[j];\\n                }\\n                else if(1 + dp[j] == dp[i]) // Modification\\u2019s for keeping up the count\\n                    count[i] += count[j];\\n            }\\n            maxLen = max(maxLen,dp[i]); // Store max length of LIS\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(dp[i] == maxLen) // Add every LIS possible\\n                ans += count[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n),count(n);\\n        int ans = 0;\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            dp[i] = 1;\\n            count[i] = 1;\\n            for(int j=0;j<i;j++){\\n                if(nums[i] > nums[j] && dp[j] + 1 > dp[i]){ // Basic LIS conditions\\n                    dp[i] = dp[j] + 1;\\n                    count[i] = count[j];\\n                }\\n                else if(1 + dp[j] == dp[i]) // Modification\\u2019s for keeping up the count\\n                    count[i] += count[j];\\n            }\\n            maxLen = max(maxLen,dp[i]); // Store max length of LIS\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(dp[i] == maxLen) // Add every LIS possible\\n                ans += count[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1979267,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980086,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979489,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979352,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979252,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1571800,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979641,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980079,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979778,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1569668,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979267,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980086,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979489,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979352,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979252,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1571800,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979641,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980079,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1979778,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1569668,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Alone LIS is easy, but the number of LIS is much harder.\nTry to use DP to solve! It needs 2 arrays. One for LIS, the other for counting!"
                    },
                    {
                        "username": "nitissssh",
                        "content": "is this problem even solvable using top down approach ? I tried simple take not take method but it does not work .\\nclass Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n}; can you please find the mistake ?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Yes , right ! Just the way you keep updating your dp array , keep updating the ways array as well !"
                    },
                    {
                        "username": "ddiazghub",
                        "content": "This feels more like a hard problem than a medium."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m satisfied with \"Beats 23.19%of users with Go\".\\nWhatever the score I did it by myself!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "If you need some test cases\\n\\n```\\n[5, 0, 2, 9, 5, 2, 2, 6, 3, 7]\\n[6, 5, 6, 5, 5, 2, 5, 1, 9, 4]\\n[55, -53, 98, 14, 100, -4, 10, 98, -99, -35, 14, 55, 71, -67, -25, 62, -80, -60, -25, -84]\\n[-59, -40, 87, 95, 4, 19, 35, 81, -50, -76, 49, -85, -51, -1, -14, 51, 59, -31, 85, -86]\\n```\\n\\n```\\n[604201, 173268, 825711, -962315, 371986, -290055, -598067, 768785, 207447, -8577, -723770, 355344, 658591, 655682, 339519, -209106, -374227, -122061, 511833, -708589, -70078, -803698, 998459, -215968, -737684, -463222, 24937, 534684, -129931, -414531, -205434, -150261, 918778, -174578, 135229, -610205, -585191, -2627, -561156, -838982, 521698, -68948, 476041, 469520, -13020, -765400, 940034, 526269, -168230, -132640, 128874, -928243, 696424, -421558, 137825, -888523, -154405, 735775, 782167, -371060, 70836, -196099, -458020, -411981, 22812, 857136, -121663, 422666, 170529, -518545, -995878, 622353, -805716, -955867, -494277, -992142, 726010, 272787, -616737, 334202, 896431, -556743, -723726, -328303, 177232, -789889, -717328, 50215, 181483, -197554, -616093, -290095, -444972, -109629, 206048, 656903, 558351, 21664, -496398, 149347, 444213, 116370, 322666, 176250, -642661, 11863, 468265, -53105, -768333, 685134, -815562, 307570, -854873, 918941, -182136, 151822, 453311, 397774, -714887, 697550, -928579, 977184, -829339, -551972, 365827, -123872, 743129, 560654, 458969, 499032, -160035, -511590, -757896, 248773, 37023, 917022, -37128, -360427, -453304, 63281, 442640, 85331, -281602, -834193, 852285, 198478, -629999, 194507, 767491, -935966, 885304, -144819, 509685, 563042, 855608, 813045, 941401, 685152, -694254, -856859, 255559, 983953, 715976, -305316, 371040, 724491, -788017, 457459, 982805, 323455, -929985, 137464, -25390, 143967, 114353, 994428, 85773, 340675, 419580, -342529, -379963, -947051, -741027, 47638, 606332, -276945, -848417, 728460, -745089, -254623, -232497, -21140, 1363, -793176, 126020, -389514, 1402, -203517, 158633, -233556, -30857, 301839, 887716, -399243, -44026, -380266, 760805, -291287, 120138, 109698, -252667, 627300, 305152, -398959, 59676, -517177, 129933, 590362, 823227, 69366, -817265, -433199, -266980, 924597, 360882, 308789, -365435, 645209, 834566, 954140, 636801, 817632, 703079, 990709, 267958, -554215, -71154, -621020, 817294, 397377, -814835, -420916, -302456, -196236, -528276, -929087, 420663, -621129, -250570, -336218, 132124, -922399, -734091, 933781, -251936, 551718, -379532, 24258, -327813, 905097, -599261, 272482, -907327, 869567, 768531, -89015, 414428, -292055, -840430, -583185, -869670, -313688, -582409, -452740, -603209, -397128, -506697, -889832, -508181, -755401, -199904, -569861, -141319, -728335, 786182, -420085, 980428, -473558, -892248, -469999, -649998, -631123, 807129, 188201, -908927, -36998, 523223, 119428, 342675, -496102, 61736, 91147, 735980, -253923, -281155, -660481, -747241, -40222, 932905, -883656, 585805, 305775, 23437, -103455, -407674, -279572, -786954, 119139, 357031, 140765, -812355, -472418, 213097, -853653, -901134, 55062, -276739, 135456, 927563, 731937, 373958, 163795, 604541, -364271, -2044, 677101, -915473, 310330, -305164, 297704, -529613, -143808, -345840, -634405, 205694, -606315, 438511, 9979, 785661, 517907, -948253, -385684, 108285, 742534, -426470, 805890, 114748, 627475, -98826, -243459, -116449, -757920, 361295, -137556, -612198, 653858, 26012, 313391, 456437, 538403, 455341, -500915, -668424, 807523, 733867, -829713, -117374, 134301, -719962, -486969, -590745, 722743, -525135, -547584, -141671, 429, -411544, -274039, -701062, 7932, -97549, 948254, 115897, -47429, -632270, 764700, -596779, 881581, 965392, 724042, 365035, 658868, -278564, -985463, 284672, 86838, -584221, -970006, -589134, -461265, 155111, -417744, 686060, 116408, 136930, 708246, -598558, 982975, -25782, 101826, 153490, 838870, 754386, 855908, 595720, -466885, 991106, 327026, -359552, 63087, -680352, 937347, 884075, -8267, 679376, 690672, -138992, -632044, 866473, -913474, -274464, 146197, 456851, 408899, 373249, -467861, 670519, -430329, 379137, 284586, 516192, -925805, -622708, -210523, 557275, 31893, -764824, -462614, 931934, 531828, -151209, 652154, 402752, -762508, -136860, 985327, 601584, 488907, -716433, 807591, -985781, 871299, -191821, 76126, 856090, -222931, -611083, 765608, -864482, -87766, 379491, 742547, -537089, 827822, 817570, -516795, 291577, -668090, -294861, -845706, -588441, -74175, 971372, 341261, -108178, -792079, -347791, -290024, -803518, 877724, 83670, 17172, -265345, -976508, 440476, 377505, 127857, 912814, -443810, 697156, -231880, -636333, 777613, -261003, -6768, -934776, -655040, -602150, -945749, -351532, -542819, 502054, 257359, 13295, -419029, -563053, -910345, 420030, 896556, 230091, 38428, 93733, 466030, 997669, 848092, -971785, -487624, -402432, 625733, -689003, 148377, 752855, 463212, -386383, -939782, 711698, -679917, 889748, -290525, 659679, -985656, -324353, -91012, -2713, -737515, -69674, -450717, -203109, -927247, -45787, -391153, 36492, -59540, 179510, -215297, -31772, -742002, 940938, 631975, -930384, 375497, -329944, -713100, -984409, 438483, -111614, -231153, 909383, -196895, 713674, -967572, 818909, -163143, 982056, -260670, -628831, 631103, 436282, -150207, 260387, -88497, 793399, 200448, -253452, 5947, 170368, -763952, 686870, -810663, -408675, -649724, -391129, 379476, -414913, -257896, 807403, -415961, 274912, -694798, -212808, 903828, 318885, 591187, 235940, -831239, -378914, 796282, -695148, 248199, -956751, -296703, 156283, -107317, 671389, -846210, -661083, -21469, 538019, 432484, -491342, 654004, -862318, -813378, -703555, 810546, -309235, -909694, 785786, 802515, 813715, -467416, 228192, -718009, 724678, -781602, -163951, -797570, 224342, 198921, 869818, -278562, 774306, 88595, 617351, -466726, -989376, 952593, -550138, -94659, 494052, -528873, 933087, 870976, 35939, -34172, -785869, 391590, -644150, -971655, -328513, 953195, 803862, 686935, 714634, -990202, -402756, 830767, 24234, -388246, -671215, 798256, -166262, 198287, 960017, 876532, 727498, -260986, 303221, -919220, 30358, -212026, 247264, -168760, 966034, -181516, 394831, 316358, -989870, 898944, 23283, 14002, 707131, 822606, 469112, -497756, 681220, -47791, -337341, -787108, -429544, 647305, -780408, 548775, -590613, -989051, -376002, 81937, 717433, 936360, -418808, 152368, 784085, 863398, 602002, -97902, 252710, -114877, 913333, 534678, 272742, 103959, 201362, -294810, 467424, 644850, 523129, 461558, 350241, -995908, -946453, 155086, 86655, 266234, -268708, -421069, 67186, 8059, 236958, 327388, -789689, -817310, -120267, 580824, -448008, -590489, -822958, 39506, 684156, 977489, 707691, -104406, -782962, 179980, 648035, 306573, -416270, 365841, 565181, 64699, 201696, -947907, -222534, 639329, -429299, 376746, 545333, 186399, -376227, 207707, 216113, -24305, 513813, -351739, -985291, 53532, -836352, -367770, -277673, -663074, -848264, -3708, 174208, -478852, -137040, 134350, 767150, 837289, -498844, -951038, -839783, -506041, 14251, -116837, 227097, 894455, -303248, 736965, 771207, 461005, 931334, 374514, 545270, -579376, -430971, -923216, -648520, -28869, 904210, 427908, 84611, -909583, 143402, -702212, -651164, 717800, 55983, -259739, 971520, -252553, -928746, -31828, 342179, 163380, 772614, 550512, 916150, 578881, 531776, -640960, -267998, -744508, 873287, -302309, -134947, -793275, 579649, 879419, 569064, 773571, 387995, -930506, 931431, 709443, 939125, -828583, 973242, -570824, 510446, 40374, -632042, 406750, -177817, 778807, -976002, -821383, 832702, -769226, -232167, 62059, 169415, 96614, -775135, -913213, 364603, 358482, -500753, 11787, -501439, 133434, 15019, -997009, -575346, 755401, -391211, -879334, -718524, -228488, -16469, -343215, 281047, -300970, 370840, -287565, 894417, 502341, -694947, -889657, 475456, 168258, 255210, 714501, -237136, -204274, -236707, -75652, 69571, -899027, -11175, 23483, -849450, -772262, -933965, -172988, -114911, 211679, -919042, 862434, 821497, 231772, -106388, 983241, 214188, 79316, 994844, -41904, 807749, 248951, 94770, -115049, 273651, -774021, 409989, -28551, 722855, 210306, -635210, -387217, -96671, -837133, 325729, 210090, -661584, 118913, 901224, -38387, -165138, 160239, -523103, 8783, -203003, 245891, -746111, 591059, 680799, -140254, -88949, -359323, 957259, -872580, -702831, 577917, 931261, 624167, 110657, 989289, -440851, -603133, 723986, 257858, 993629, -166075, 797825, 291450, 726145, 869270, 939392, -883829, 6268, 380429, 922242, -488409, -26306, -414245, 625982, -492001, 84675, 463338, 910158, 568202, -808303, 139880, -465302, 56457, 888227, -893222, 235107, -890716, -6536, 846705, 632775, 457093, 304, 549604, -191172, 149989, -693882, 183167, 265391, 471408, -275525, 933621, 963378, -532047, 232342, -777052, -944106, -315273, 444358, -692945, -55263, 854167, 47894, 188052, -638043, 94274, 607116, 995172, 988338, -764397, 289113, -425448, 663256, -327666, 389003, 147388, 901547, -908468, -488830, 790344, 959175, 348657, -261255, 365512, -361667, -678394, 955302, 401735, 672952, -119955, 892900, -521819, -225120, -278233, 909463, 164969, -504874, -699273, 932575, -465153, -772525, -232831, -866035, -486503, -786545, 777543, 52106, 98981, 898533, 538540, -877288, 493434, 94336, -546788, 65350, -881862, 601528, -458185, 577116, -708905, 179693, -18450, 865870, 855036, -162026, -29099, 680562, 970564, 786861, 4901, -573953, 856490, -282255, 757392, 497502, 903343, 692577, 328610, -931181, 499710, -747152, -933651, 743593, -339010, 814042, -712535, 235122, 781232, 197105, 504776, 892766, 988453, -800734, -384630, 609188, 630005, -970782, -217133, -33689, 897753, -390821, 639448, 83130, 938696, 868840, 453940, 858561, -789628, -301704, -48247, -342165, -64840, -919021, -837370, -385685, -793348, -109115, 941036, -665380, -310858, -208341, -494287, -337302, 250612, -259065, 220627, 326729, -970787, -778563, -734357, -573233, -96271, -168557, 979979, 705998, 752586, -236379, 663389, 244532, 563018, 176463, 284361, 365281, -118508, 236481, -484271, 359494, -426834, 562065, -450760, -706501, -868094, -881072, 513148, -157076, 250535, 766277, 611081, -925673, -447490, 226141, -490262, -532872, -886278, -325696, 538925, -693187, 260088, 601392, -828043, -21635, -727282, 648073, -149238, -362380, 881806, -197605, -775933, 290034, -944302, 197253, -618205, 346445, -19816, -864701, 944461, 712527, -674035, 716900, -686576, -481830, -869436, -783902, 917501, -542053, 655057, 768929, 983663, -738748, -154265, 876413, -201119, -164237, -699760, -890748, -763073, 790114, -848696, 897127, -549534, 642253, 616895, 579237, 833660, 556471, 853306, 841966, 61645, -544027, 597595, 182345, -302180, 151776, -662991, 489603, -470696, 44869, -436859, 989458, -181495, -506126, 392483, -176198, 268926, -671249, 31557, 263854, -470156, 549681, 233584, 648899, -140192, 865983, -959062, -423992, -81475, 521437, -455804, 50450, 516861, -573106, -703838, -78282, 322247, 823821, -354699, -640825, -275146, 25112, 66115, 421121, -149004, -855089, -879271, -294867, 77487, -955629, 484223, 395851, -222386, 814137, -772350, -303448, 139674, 472381, -502011, -305586, 607345, -264079, -39492, 656689, -395641, -160964, -195148, -710878, 978334, -722676, 237852, 325370, -542365, 410187, -470482, -49876, -281173, 650337, -257557, -989810, 141836, 254477, 353691, -484256, -83313, -656575, 8575, 904224, 113726, 899167, -971517, 849231, 553069, 707215, -177690, 910923, 853787, -235917, 778927, 360632, -436204, -650281, -459245, -823983, 826293, 378902, 377059, -262842, -95624, 920883, 772899, 451528, -108822, 590106, -955077, 887483, -718823, 100527, -5676, 359834, 74395, -974682, -261190, -794300, -195760, -200441, 465815, 659685, -232455, 512273, -504034, 638433, 149079, 889853, -680624, -804148, -432771, 445562, 966757, -665553, 591283, 555088, -951324, -345156, 521586, 209634, 256249, 858253, 949693, 90189, -159193, -541085, 405581, 536432, 178, -88431, 671764, 413837, -114589, -944945, -580933, 797767, -661880, -109140, 34386, 666837, 880846, -391191, 677387, 508758, 472554, -895094, 477680, -354968, 249301, -10680, 563195, 663895, 289934, 262767, 394034, 197622, -647561, 881787, 849088, 890512, 460192, 988676, -884634, -739128, 802370, -131451, -518955, -648330, 509034, -919799, -865731, 883439, 742751, 660202, -105326, 788441, -699950, 243820, 305523, -977388, -717813, 344670, -191608, -700420, 441204, 346266, 404745, 456666, 634364, 969105, -384466, 119097, -652939, 474265, 553739, -27491, -821232, 953294, -446777, 187656, -839261, 67253, -899720, 239021, -448886, -645037, 368166, -554871, 371847, -91813, -251707, -206964, 660267, 953726, -699705, 165932, 899269, 631988, -425579, -963599, 346496, 128067, -810984, 626214, 403848, -879528, -145229, -985190, 322452, -546012, 859743, 742006, 628759, 270207, 962315, 670441, 731975, -608127, -521729, 12681, -126025, 416606, -650741, 961649, -582033, 180514, 971464, -273252, 196542, -951708, -908809, 959220, -806958, -515515, 644487, 896094, -79845, 726082, -995875, -689127, -260330, -843060, 741593, 216118, -25912, 32312, -507105, -575708, 81895, -709470, 285487, -491515, 38675, -834870, -21474, 120109, -92460, -559564, -663404, -907604, 584129, 529178, 302827, -101052, 174028, 581072, -229570, -932299, -783649, -940213, -339385, 477741, 68865, 492228, 512819, 925039, 645791, 617124, 684220, 802708, -845657, -794483, 108726, 146105, -596808, -521756, -684004, -442229, -593111, 725020, -856993, 251818, -868507, 782239, 980839, 275559, 95781, 653103, 788146, 315290, -910827, -833761, -12913, -562039, -86124, -406281, 42759, -344069, 860426, -882041, 496302, 921939, -375795, 593917, 764588, 268771, -659579, -403981, -692167, 608208, -24725, -195271, -48852, -486120, 653448, 689477, -592130, -950430, -335987, -766370, 835628, -598572, 396348, -655432, 92052, -235916, 925837, 754646, -136168, 959286, -986536, -871088, 617982, 23313, 183289, 611459, 6997, -268581, 911636, -376673, -824334, -656687, 98240, -432591, -531759, -692414, 684445, 597520, 516665, 960551, -12485, -325502, 450222, 865648, 943334, 630054, 105101, 373116, -86086, 274705, -118861, -826884, 403326, 65590, -971961, 291624, 10237, -466105, -595761, 704401, -964152, 80872, 958951, 850403, -729141, 589926, 612621, -394186, 658367, -275202, 777728, 806749, 840810, 312982, 416543, -796262, -98147, 124978, 424494, 304481, 377160, -483764, -452976, 336335, 285728, 447439, -796559, 169672, -642703, -597252, 249342, 480952, 194668, 632516, 348631, -505744, -651087, 137693, 242129, 13877, -336017, -212355, -572689, 47157, 333713, -330635, 797406, -348288, -177334, 174597, -423307, 182900, -636934, 550199, 307671, -778373, -671844, -219704, 349767, -229986, -900199, 49162, 237444, 332279, -884704, 782311, -215112, -826088, -379253, -987843, 603764, 48752, -778519, -928372, -203007, -450644, -634804, -306394, 218875, -358533, -483287, 501209, 395028, 911998, -857487, -505740, -479497, 782304, 655436, -729290, -552142, -947251, -807669, 652577, -80944, -139114, 479494, -373512, -455603, 907403, -201217, 651782, -154585, 337389, 201337, -895939, -428853, 251706, 778248, -44695, 869963, 946649, -39836, -444620, -530680, 747244, 335820, 331774, -825136, -90466, 560420, 591438, -24061, -819832, -806342, 73880, 132661, 922577, 296507, -826632, 190577, 87431, 539907, -815265, -535966, 943695, 60369, -26749, 399808, 316129, -693272, -503868, 757344, -257259, -187211, 371192, -589604, 796058, -560674, -942038, 612175, -677374, 524784, 784976, -562988, 950806, 732771, 681603, 754322, -809814, -346562, 973486, 52926, -692456, 611875, -171865, 950299, 167068, -480052, -789533, -107638, -431386, 147006, 728881, 420443, 181793, 379482, 703306, 314313, 287744, -11239, -103740, 838926, -15356, 130390, -14980, 370003, -83069, -806212, -224493, -363310, -688108, 820406, -673950, -694623, 459280, 44209, 929139, 902468, -101304, 402512, 77169, -919121, 594049, 405732, -429368, 675094, 771347, -261278, -842401, -793024, 405686, 734234, 848546, -982416, 395758, -37806, -461345, 78919, 895574, 317285, 907278, 87816, -554349, 581540, -454124, -97497, 516877, 123640, -450378, 420147, -561655, 201686, 456014, -924221, -261726, -1007, -998789, 63332, 210994, 304628, 162185, -340414, 461109, -208048, 767154, 962055, -982392, -886746, -512692, 167276, -464146, 875769, -132892, -467234, -732975, -510288, -767898, -672561, -445368, 486178, -317807, 108926, -481436, -724741, 797253, -123058, -370538, 586646, 984745, 141101, -56031, 233701, 852919, -322133, 623832, -599511, -967617, -138911, 276918, -838582, -473464, 932595, 249871, 564610, -522313, 359651, -20587, -829405, -535537, -787886, -510123, 603916, -894166, 984962, 938558, 70825, -756993, -650322, 402360, -163419, -232506, 590429, 487914, -405051, -983944, 189022, -519100, -111723, 112101, -619192, 819756, 102347, 323317, -203834, 217717, 972230, 786923, 376780, 153210, -360803, -64713, -489371, -66438, -941313, 857707, 896360, 600041, 537490, -300201, -490352, 459649, -671451, -123656, 640111, -867701, -42995, 506072]\\n```"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "I expected a $$10^9+7$$ in the problem description somewhere."
                    },
                    {
                        "username": "Flange",
                        "content": "[@sarpalmadhav](/sarpalmadhav) wrong. Test [1,1,2,2,3,3,\\u202631,31]."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The max case is when all LIS are of same length i.e 1 and final answer is n (i.e max 10^6) so no need of modulo/long int. If you make the subsequences longer, the frequency for the LIS will decrease."
                    },
                    {
                        "username": "akhil_gadde",
                        "content": "yeah! exactly.. Are we missing anything here?"
                    },
                    {
                        "username": "mazong1123",
                        "content": "I may be wrong, but for [1,2,4,3,5,4,7,2], are the longest sequences [1,2,3,5,7] and [1,2,4,5,7]? Why leetcode expect 3 sequences?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "1 2 3 4 7 length 5"
                    },
                    {
                        "username": "anuj_cse123",
                        "content": "[1,2,3,4,7] also possible ... you are missing this one\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Alright, let's embark on a journey of dynamic programming to find the number of longest increasing subsequences in a sequence of numbers!  I'll discuss like thre approach here, code yourself \n\nStep 1: Finding the Length of the Longest Increasing Subsequence (LIS)\n\nTo begin, we'll create an array called `dp`, where `dp[i]` represents the length of the LIS ending at index `i`. This array will help us keep track of the LIS length as we traverse the sequence. \n\nWe'll initialize `dp` with `1` because every number is a valid LIS of length `1` by itself. Let's call this step \"dp initialization.\" \n\nNow, we'll loop through the sequence from left to right. The outer loop index `i` will act as the potential ending index of the LIS, and the inner loop index `j` will go through all elements before `i`. Whenever we find that `nums[i]` is greater than `nums[j]`, it means we can extend the LIS ending at index `j` by adding `nums[i]` to it. This step will be known as \"dp update.\" \n\nFinally, the maximum value in `dp` will give us the length of the longest increasing subsequence, which we'll call `maxi`. \n\nStep 2: Finding the Number of Longest Increasing Subsequences (LIS)\n\nWe'll create another array called `ways` and initialize it to `1`. This array will keep track of the number of ways to obtain subsequences of length `dp[i]`.  Note that we will do this step as just one extra line in the above dp code only.\n\nWhile updating the `dp` array, we'll also update the `ways` array. Remember, when we update `dp[i]` to `dp[j] + 1`, it means we found a longer LIS ending at index `i`. What would be the number of ways for it if we know the number of ways for the LIS ending at index `j`? Yes, it will be the same as `ways[j]`. But if `dp[i]` is already equal to `dp[j] + 1`, we found another way to reach this length, and we'll update the `ways` array accordingly by adding the ways of forming the LIS at `j` to `ways[i]`. This way, we'll count the number of ways to achieve each LIS length. \n\nOnce we finish all the iterations, we'll have the `ways` array updated with the counts of different LIS lengths. To get the total number of longest increasing subsequences, we'll simply iterate through the `ways` array and count the number of ways for subsequences of length `maxi`. \n"
                    },
                    {
                        "username": "misha",
                        "content": "The problem is meaningless without a modulo. Answer can be as big as 2 ** (n / 2). Take for example such testcase: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33]. We can choose `1` in two ways, `2` in two ways, `3` in two ways, ..., `33` in two ways => answer is 2**33. If you paste this test into testcases, the \"expected\" field is empty :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "This was definitely hard, I was trying to solve it using the traditional take and skip dp.\nBut after checking some youtube videos and understanding the editorial solution I was able to get it."
                    },
                    {
                        "username": "bparanj",
                        "content": "Ah, you\\'re approaching this with the classic recursion-based way of thinking: either take or skip an element, which is the foundation of many dynamic programming problems. However, this problem is more intricate because not only do you need to keep track of the longest increasing subsequence, but also count the maximum number of such subsequences.\\n\\nThe main issue with your code is that you\\'re trying to solve it purely recursively, without using the benefits of dynamic programming to store and reuse the results of subproblems. Your current solution is a depth-first search (DFS) with a lot of overlapping subproblems, which leads to a high time complexity and eventually a TLE (Time Limit Exceeded) error.\\n\\nWe could potentially store the answers for the subproblems in a dynamic programming table. However, we need to carefully define our state. For this problem, a state could be defined by two parameters: the end index of the subsequence and the length of the subsequence. But, for the \\'take\\' scenario, we need an additional check to ensure the subsequence remains increasing.\\n\\nUnfortunately, adapting your current code to use dynamic programming isn\\'t straightforward because the recursion happens in multiple places (during the include and exclude scenarios). In fact, this problem is typically solved using a different dynamic programming approach, as shown in previous responses.\\n\\nThis doesn\\'t mean that your initial intuition was entirely wrong, just that for this problem, the \\'take or skip\\' approach doesn\\'t easily translate into an efficient dynamic programming solution. It\\'s great to keep trying different ways to solve a problem, as it ultimately deepens your understanding of dynamic programming and other techniques!"
                    },
                    {
                        "username": "inav1201",
                        "content": "I see that there are only 2 longest increasing subsequence but the expected is 3. How come it is?\\n\\n[1 2 4 5 7]\\n[1 2 3 5 7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    }
                ]
            },
            {
                "id": 1980045,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979875,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1925878,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979810,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979597,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979334,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1979323,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1576414,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 1571801,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 2068385,
                "content": [
                    {
                        "username": "GitG0",
                        "content": "Given `nums = [1,2,3,1,2,3]`\\nThe expected output is 4, is this how the 4 would be composed?\\n<b>1</b><b>2</b><b>3</b>123\\n<b>1</b><b>2</b>312<b>3</b>\\n<b>1</b>231<b>2</b><b>3</b>\\n123<b>1</b><b>2</b><b>3</b>"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your input and expected output seems to be slightly misunderstood. The input is `nums = [1,2,3,1,2,3]` and the expected output is `4` because there are `4` longest increasing subsequences of length `3`. They are:\\n\\n1. `[1,2,3]` from indices `0,1,2`\\n2. `[1,2,3]` from indices `0,1,5`\\n3. `[1,2,3]` from indices `0,4,5`\\n4. `[1,2,3]` from indices `3,4,5`\\n\\nThese subsequences are distinct and have the maximum length among all increasing subsequences in the given list, hence the output `4`."
                    },
                    {
                        "username": "vi7ec",
                        "content": "Why there is no modulo 10^9+7.\\nFor example this testcase clearly has 2^34 different subsequences:\\n```\\n[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34]\\n```\\nYes, testing system accepts this as a valid testcase but doesn\\'t return anything, expected output is nothing, and all testcases\\' results are Wrong Answer."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lack of a modulo operation in this problem is likely because the problem setter did not anticipate such large numbers of sequences. Indeed, for most problems on competitive programming platforms, especially those involving count or the number of ways, you\\'ll often see a requirement to return the answer modulo 10^9+7, to avoid overflow and keep the numbers manageable.\\n\\nHowever, for the test case you provided, the number of longest increasing subsequences (LIS) is not 2^34. The longest increasing subsequence for the given list is not unique and can be formed in many ways, but we are interested in finding the number of such longest increasing subsequences.\\n\\nEach number appears twice in the list, so for every pair (x, y) with x < y, there are four options:\\n\\n1. Neither x nor y is included in the LIS.\\n2. Only x is included.\\n3. Only y is included.\\n4. Both x and y are included.\\n\\nSo, there are 4^(n/2) possible sequences, where n is the length of the input list.\\n\\nAs you pointed out, this can still result in large numbers. Depending on the platform and problem settings, this may cause overflow issues if not handled properly. However, it\\'s possible that the test system does not fully handle such large inputs, which is why you\\'re not seeing an expected output.\\n\\nFor large-scale test cases like this, it\\'s crucial to design an efficient solution and potentially use modulo arithmetic to avoid overflow issues. If you expect to handle cases where the count is extremely large (close to or exceeding the maximum limit of an integer), you should consider using a modulo operation."
                    },
                    {
                        "username": "psionl0",
                        "content": "I got a signed integer overflow."
                    },
                    {
                        "username": "demonslayer_09",
                        "content": "Does anybody know how to solve this using segment tree??"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, it\\'s possible to solve this problem using a segment tree, but it might be a bit overkill and also harder to implement and understand, especially for beginners.\\n\\nSegment trees are data structures that allow processing range queries and updating array values in logarithmic time. In our case, we could potentially use a segment tree to keep track of the longest increasing subsequence (LIS) and the count of such subsequences up to each position in the array.\\n\\nHere\\'s a rough sketch of how it might look:\\n\\n1. First, we sort the numbers and their indices.\\n\\n2. We initialize a segment tree, where each node represents a range of indices in the sorted array and stores two values: the length of the longest increasing subsequence ending at this range, and the count of such subsequences.\\n\\n3. Then we process the sorted numbers in ascending order. For each number, we use the segment tree to find the longest subsequence ending with a smaller number, and extend this subsequence by the current number. We update the node corresponding to the current number\\'s index in the tree.\\n\\n4. When updating a node in the tree, we may need to recalculate the values stored in its parent nodes, up to the root. This is where the segment tree shines: we can do this efficiently in logarithmic time.\\n\\n5. After processing all numbers, the root of the tree will contain the length of the overall LIS and the count of such subsequences.\\n\\nHowever, note that this approach would work for finding the LIS in general, not specifically for finding the number of subsequences of the longest length. For that, you would need to modify the update process to also keep track of the count of subsequences.\\n\\nIn summary, while a segment tree could theoretically be used for this problem, it\\'s probably not the most suitable tool. It would require careful implementation and understanding of the intricacies of segment trees, and the resulting solution might not be very intuitive or easy to understand. The dynamic programming approach is a lot simpler and more straightforward."
                    },
                    {
                        "username": "exquiro",
                        "content": "Is there a way we can apply DP to the recursion solution of this problem? I tried the recursion but could not apply DP, can someone help me out here. My solution is as follows\\n(PS: It works but gives a TLE)\\n```\\nclass Solution {\\n    int res=0;\\n    int longest_sequence=0;\\n    int solve(vector<int>& a, int ans, int curr, int prev, vector<vector<int>>& dp){\\n        if(curr == a.size()){\\n            if(ans > longest_sequence){\\n                res = 1;\\n                longest_sequence = ans;\\n            } else if(ans == longest_sequence){\\n                res++;\\n            }\\n            // cout << \"Longest Sequence Length: \" << longest_sequence << endl;\\n            return 0;\\n        }\\n\\n        // include\\n        int inc = 0;\\n        if(prev==-1 || a[curr] > a[prev]){\\n            inc = 1 + solve(a, ans+1, curr+1, curr, dp);\\n        }\\n\\n        // exclude\\n        int exc = solve(a, ans, curr+1, prev, dp);\\n\\n        return dp[curr][prev+1] = max(exc, inc);\\n    }\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n\\n        int longest_sequence_length = solve(nums, 0, 0, -1, dp);\\n        for(auto it:dp){\\n            for(auto i:it){\\n                cout << i << \" \";\\n            } cout << endl;\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The TLE (Time Limit Exceeded) issue you are experiencing is because the recursion is not using previously calculated solutions, causing redundant computations. Although you have the DP table in your code, it\\'s not correctly utilized, which is why the recursion is not taking advantage of it. Working solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 1) return N;\\n        vector<int> lengths(N, 0); \\n        vector<int> counts(N, 1); \\n\\n        for (int j = 0; j < N; ++j) {\\n            for (int i = 0; i < j; ++i) {\\n                if (nums[i] < nums[j]) {\\n                    if (lengths[i] >= lengths[j]) {\\n                        lengths[j] = lengths[i] + 1;\\n                        counts[j] = counts[i];\\n                    } else if (lengths[j] == lengths[i] + 1) {\\n                        counts[j] += counts[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        int longest = *max_element(lengths.begin(), lengths.end());\\n        int ans = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (lengths[i] == longest) {\\n                ans += counts[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Saphal",
                        "content": "Can someone point out why is it failing for this testcase:\\n `[0,1,1,1,1,2,2,2,2,3,3,3,-109,-168,-112,-128,-116,-174,-175,-171,-162,-115,-122,-137,-142,4,-109,-100,-154,-183,-116,4,-177,-190,-150,-136,-146,-178,-181,-114,-186,-154,-155,-197,-142,-183,-134,-137,-122,-100,-198,-158,-103,-176,-149,-169,-147,-158,-106,-111,-199,-188,-172,-151,-129,-167,-176,-171,-185,-127,-172,-115,-102,-163,-195,-111,-105,-188,-118,-191,-122,-163,4,-159,-171,-196,-122,-196,-104,-176,-124,-123,-119,-155,-146,-194,-170,-185,-163,-102,-157,-152,-150,-154,-136,-172,-168,5,-177,-166,-122,-148,-118,-197,-152,-156,-121,-124,-104,-106,-153,-175,-184,-153,-180,-172,-135,-169,-100,-154,-183,-127,-105,-180,-114,-164,-158,-115,-133,-172,-149,-154,-155,-118,-187,-171,5,-158,-160,-192,-195,-200,-106,-197,-143,-160,-125,-133,-118,-148,-173,-188,-114,-199,-174,-104,-198,-114,-151,-116,-111,5,-144,6,-105,-178,-113,-108,-113,-141,-152,-172,6,-165,-160,-117,-165,-143,-198,-184,-135,-100,-144,-142,-152,-146,-153,-195,-134,-141,-136,-100,-100,-139,-195,-125,-170,-159,-137,-126,-122,-109,-134,-106,-132,-195,-140,-194,-151,-127,-110,6,-114,-134,-108,-148,-155,-118,-158,-138,-138,-148,-105,-134,-140,-149,-170,7,-177,-159,-126,-119,7,-154,-118,-178,-126,-167,-176,-123,-192,-155,-171,-183,-130,-123,-125,-166,-159,-105,-197,-111,-150,-177,-173,-103,-130,-186,-172,-167,-148,-168,-108,-139,-176,-116,-129,-154,-123,-127,-110,-106,-139,-175,-179,-100,-156,-186,7,-198,-199,8,-151,-180,-112,-151,-113,-174,-140,-143,8,-113,-120,-106,-173,-155,-190,-127,-131,-154,-146,-126,-148,-120,-133,-190,-109,-129,-169,-144,-101,-174,-107,-183,-109,-136,-161,-131,-145,-159,-186,-113,-169,-106,-195,-168,-138,-166,-115,-197,-164,-152,-188,-101,-126,-149,-124,8,-105,-173,-148,-144,-196,-155,-100,-175,-180,-113,-136,-158,-116,-190,-137,-146,-156,-194,-106,-121,-175,-122,-175,-176,-104,9,-146,-167,-200,-186,-195,-130,-176,-149,-134,-170,-129,-128,-158,-171,-185,9,-124,9,-181,-122,-101,-188,-174,-182,-112,-195,-114,-175,-161,-187,-127,-186,-169,-189,-128,-137,-108,-153,-186,-178,-186,-188,10,-155,-101,-135,-113,-141,-116,-102,-198,-128,-145,-190,-127,-108,-166,-116,-163,-181,-172,-148,-113,-191,-151,-123,-115,-135,-115,-144,-188,-129,-196,-105,-148,-112,-191,-160,-184,-120,-134,-149,-162,-174,-188,-134,-117,-175,-138,-192,-124,10,-180,-109,-130,-179,-154,-159,-177,-163,-160,-127,-147,-101,-134,-179,-133,-150,-168,-197,-145,-104,-122,-105,-189,-194,-152,-160,-110,-199,-196,-152,-187,-128,10,-198,-167,-180,-128,-111,-106,11,-151,-120,-156,-133,-132,-107,-183,-129,-133,-104,-106,11,-162,-136,11,-139,-133,-107,-192,-142,-196,-149,-169,-120,-198,-197,-165,-124,-198,-172,-115,-199,-130,-132,-164,-184,-106,-145,-130,12,-191,-115,-123,-169,-183,-107,-158,-124,-185,-116,-199,-184,-200,-125,-143,-135,-160,-170,-168,-155,-145,-171,-119,-139,-127,-127,-127,-189,-119,-179,-111,-100,-180,-135,12,-183,-136,-194,-191,-197,-168,-149,12,-152,-197,-156,-149,-130,-190,-107,-112,-199,-144,-186,-164,-141,-108,-199,-100,-173,-162,-159,-118,-176,-133,-107,-161,-182,-186,-179,-161,-190,-113,-145,-137,-169,-114,-178,-125,-116,-165,-196,-164,-163,-155,-121,13,-200,-170,-118,-133,-132,-150,-195,-132,-134,-148,-107,-137,-166,-138,-117,-182,-122,-176,-123,-171,-155,-151,-110,-181,-109,-129,-176,-178,-104,-128,-100,-108,-110,-169,-163,-119,-162,-174,-125,-102,-110,-170,-133,-119,-109,-110,-198,-153,13,-109,-160,-109,-111,-186,-126,-159,13,-111,-136,-140,-117,-122,-178,-182,-181,-104,-131,-126,-135,-103,-170,-180,-165,-139,-129,-126,-101,-141,-130,-119,-182,14,-122,-154,-148,-144,-129,-183,-122,-106,-185,-115,-196,-126,-112,-128,-157,-143,-106,-196,-198,-124,-184,-132,-190,-124,-121,-106,-106,-183,-153,-130,14,-181,-192,-179,-150,-179,-147,-122,-142,-151,-142,-129,-160,-191,-185,-140,-123,-134,-133,-180,-132,-169,-153,-192,-145,-195,-200,-150,-176,-164,-135,-112,-183,-193,-153,-101,-197,-125,-111,-116,-188,-119,-122,-175,-120,-198,-133,-106,-114,-143,-127,14,-145,-126,-171,-118,-147,-148,-155,-109,-132,-144,-125,-191,15,-124,-174,-129,-110,-169,-163,-165,-107,-114,15,-119,-114,-176,-141,-180,-135,-143,-131,-174,-165,-180,-131,-178,-129,-188,-108,-164,-195,-116,-200,-169,-162,-184,-122,-125,-165,-119,-149,-142,-120,-185,-148,-178,-107,-149,15,-145,-189,-164,-139,-139,-117,-111,-161,-154,-173,-135,-180,-138,-101,-169,-199,-160,-194,-125,-149,-134,-138,-164,-171,-121,-148,-157,-149,-187,-150,-180,-181,-156,-135,-120,-105,-135,-118,-142,-150,-142,16,-107,-187,-158,-186,-161,-138,-139,-142,-109,-135,-167,-159,-102,-190,-122,-144,-102,-117,-177,-158,-139,-125,-137,-148,-101,-182,-166,-142,-191,-173,-119,-173,-120,16,-140,-169,-119,-168,-156,-116,-198,-136,-128,-142,-174,-134,-156,-160,-145,-169,-189,-143,-190,-128,-133,-164,-175,-149,-141,-103,-179,-150,-138,16,-126,-107,-154,-116,-163,-199,-151,-185,-106,-186,-199,-198,-129,-188,-147,17,-183,-175,-159,-179,-181,-123,-186,-171,-189,-117,17,-136,-136,-135,-198,-102,-119,-128,-165,-199,-159,-180,-107,-142,-156,-101,-101,-175,-116,-179,-104,-149,-102,-199,-112,-159,-111,-128,-200,-181,-166,-130,18,-107,-148,-192,-155,-144,-172,18,-127,-122,-184,-193,-167,-108,-117,-147,-167,-104,-139,-136,-148,-187,-155,-112,-124,-133,-108,-155,-141,-170,-189,-139,-105,-166,-159,-171,-170,-113,-135,-177,-198,-103,-110,-189,-191,-143,-188,-189,-106,-134,-195,-151,-106,-108,-119,-106,-159,-191,19,-124,-166,-148,-174,-191,-145,-200,-183,-181,-197,-139,-115,-195,-180,-199,-138,-111,-150,-160,-163,-187,-176,-185,-188,-170,-160,-157,19,-104,-135,-151,-177,-124,-110,-143,-139,-182,-187,-131,-134,-140,-169,-148,-181,-157,-108,20,-129,-109,-139,20]`\\n```\\nOutput is  0 ,expected 1087680\\nclass Solution {\\npublic:\\n    int solve(int index,int prevIndex,vector<int> &nums,vector<int> &ds,\\n                    vector<int> &cnt,vector<vector<int>> &dp){\\n        //base case\\n        if(index>=nums.size()){\\n            cnt[ds.size()]++;\\n            return 0;\\n        }\\n        if(dp[index][prevIndex+1]!=-1){\\n            return dp[index][prevIndex+1];\\n        }\\n\\n        int take=INT_MIN;\\n        if(prevIndex==-1 || nums[prevIndex]<nums[index]){\\n            ds.push_back(nums[index]);\\n            take=1+solve(index+1,index,nums,ds,cnt,dp);\\n            ds.pop_back();\\n        }\\n\\n        int notTake=solve(index+1,prevIndex,nums,ds,cnt,dp);\\n        return dp[index][prevIndex+1] = max(take,notTake);\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> cnt(n+1,1); // to cnt all LIS\\n        vector<int> ds;\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        int largestLen = solve(0,-1,nums,ds,cnt,dp);\\n\\n        return cnt[largestLen];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key mistake in your solution is the way you\\'re counting the longest increasing subsequences (LIS). In your current approach, `cnt[ds.size()]++` gets incremented each time the recursion reaches the end of the array, without checking whether the sequence is increasing or not.\\n\\nHere\\'s a revised version of your function with the correct logic for counting:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int solve(int index, int prevIndex, vector<int> &nums, vector<int> &ds, vector<int> &cnt, vector<vector<int>> &dp, int &max_len){\\n        //base case\\n        if(index >= nums.size()){\\n            max_len = max(max_len, (int)ds.size()); // update the maximum length found\\n            return 0;\\n        }\\n\\n        if(dp[index][prevIndex + 1] != -1){\\n            return dp[index][prevIndex + 1];\\n        }\\n\\n        int take = INT_MIN;\\n        if(prevIndex == -1 || nums[prevIndex] < nums[index]){\\n            ds.push_back(nums[index]);\\n            take = 1 + solve(index + 1, index, nums, ds, cnt, dp, max_len);\\n            ds.pop_back();\\n        }\\n\\n        int notTake = solve(index + 1, prevIndex, nums, ds, cnt, dp, max_len);\\n        return dp[index][prevIndex + 1] = max(take, notTake);\\n    }\\n\\n    int findNumberOfLIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> cnt(n + 1, 0); // initialize cnt with 0\\n        vector<int> ds;\\n        int max_len = 0;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2, -1));\\n        solve(0, -1, nums, ds, cnt, dp, max_len);\\n\\n        return cnt[max_len];\\n    }\\n};\\n```\\n\\nIn the revised version, I\\'m maintaining `max_len` to keep track of the maximum length found during the recursion. Whenever the recursion hits the base case, it updates `max_len` if the current length (`ds.size()`) is greater. This helps to get the length of the longest increasing subsequence. And when it hits the base case, it increments `cnt[ds.size()]`, meaning that it\\'s found an increasing subsequence of that length. Note that the vector `cnt` has been initialized with 0s, not 1s.\\n\\nRemember to take care of this case: when `nums[prevIndex] < nums[index]` you can consider the current number as part of the subsequence, but only then."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a n(logn) solution? My brain is only avaliable for o(n2)... :q"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Range query can be used. For you ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "aitachii",
                        "content": "Same, I did see some binary search solutions in the submission stats."
                    },
                    {
                        "username": "lanceprofe",
                        "content": "is the sequence not a subsequence?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a sequence is a subsequence of itself. The concept of subsequences includes both proper subsequences and the sequence itself. \\n\\nFor instance, let\\'s take an array `arr = [1, 2, 3]`. Here are all its subsequences:\\n\\n- []\\n- [1]\\n- [2]\\n- [3]\\n- [1, 2]\\n- [1, 3]\\n- [2, 3]\\n- [1, 2, 3]\\n\\nThe last subsequence, `[1, 2, 3]`, is the same as the original sequence. It\\'s considered a subsequence because it meets the definition: a subsequence of a sequence is a sequence that can be derived from the original sequence by deleting zero or more elements without changing the order of the remaining elements.\\n\\nSo, in your problem, when you\\'re counting the longest increasing subsequences, it includes the longest increasing sequence itself if it exists."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\"Yes, it may not be the longest increasing subsequence, but it is surely a subsequence.\""
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "This problem has a BIT tag but it seems that no solution is actually based on this concept"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "For your ref: https://leetcode.com/discuss/topic/3795511/n-log-n-fenwick-tree/"
                    },
                    {
                        "username": "user3526nw",
                        "content": "Current limitations allow O(n^2) solution for this problem. If n was 2*10^5 then good fit is Segment Tree and I think BIT is not applicable here for O(n log n) solution"
                    },
                    {
                        "username": "Yvette",
                        "content": "[1,2,4,3,5,4,7,2]\\n\\nI will assume the result for it will be 2, which is \\n12357, and 12457.\\n\\nHowever, the expected the result is 3. How to contact the leetcode for the wrong test case?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Hey consider [1,2,3,4,7]"
                    },
                    {
                        "username": "Badiya",
                        "content": "1,2,3,4,7\\n1,2,3,5,7\\n1,2,4,5,7"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Definitely this needs a modulo (10^9 + 7) answer. If you put an array like [1,...1 (20 times), 2..2,3..3,4..4,5..5,6..6,7..7,8...8] you will get overflow."
                    }
                ]
            },
            {
                "id": 2047539,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1990368,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1983352,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980599,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980497,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980246,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980221,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980197,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1980027,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            },
            {
                "id": 1979902,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "what\\'s wrong in this approach ?\\n\\n `class Solution {\\npublic:\\n    int len(vector<int>& nums, int ind, int prev, vector<vector<int>>& memo , vector<int>&leng) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if (memo[ind][prev + 1] != -1) {\\n            return memo[ind][prev + 1];\\n        }\\n        \\n        int inc = 0;\\n        if (prev == -1 || nums[prev] < nums[ind]) {\\n            inc = 1 + len(nums, ind + 1, ind, memo , leng);\\n        }\\n        int exc = len(nums, ind + 1, prev, memo , leng);\\n        int length = max(inc , exc);\\n        leng[length]++;\\n        memo[ind][prev + 1] = max(inc, exc);\\n        return memo[ind][prev + 1];\\n    }\\n    int findNumberOfLIS(vector<int>& nums) {\\n        vector<int>length(nums.size() , 0 );\\n        vector<vector<int>> memo(nums.size()+1, vector<int>(nums.size() + 1, -1));\\n        int temp = len(nums , 0 , -1  , memo , length);\\n        \\n        return length[temp];\\n\\n    }\\n};`"
                    },
                    {
                        "username": "algoacer",
                        "content": "Coding the solution requires the attitude of a competitive programmer. Otherwise the solution is not intuitive.\n\nHint: Use two arrays one dp(used for lis) and  other count and try to figure logic for count."
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I tried it using whole recursive approach \\ngot TLE "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "Why wont this work??????\\n \\ncount = [1] * len(nums)\\n\\n        for i in range(1,len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    count[i] = max(count[i], count[j] +1)\\n           \\n        mapcnt ={}\\n        for num in count:\\n            if num in mapcnt:\\n                mapcnt[num] += 1\\n            else:\\n                mapcnt[num] =1\\n        return max(mapcnt.values())\\n                    "
                    },
                    {
                        "username": "Bhedanti",
                        "content": "UPDATE: I think I got it, I jut need to put a break after I get the max least value before i.\nPlease scroll away if you dont want to see the code but the below code f mine follows DP and I dont know why I get TLE:\ncount = [1]*len(nums)\n        longmap = {}\n        l = 0\n        for i in range(len(nums)):\n        \n            while l >= 0:\n                if nums[l] < nums[i]:\n                    count[i] += nums[l]\n                else:\n                    l-=1\n        for i in count:\n            if i in longmap:\n                longmap[i] +=1\n            else:\n                longmap[i] = 1\n        return max(longmap.values())\n\n"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "What if the test case is `[5,4,7]` ?\\nthe possible LIS\\' are: 4,7 ; 5,7\\nThen, should the answer be 2?\\nPlease help me understand."
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "class Solution {\\n\\n    int max = 0;\\n    Map<Integer,Integer> map;\\n   \\n    public int findNumberOfLIS(int[] nums) {\\n\\n        int n = nums.length;\\n        map = new HashMap<Integer,Integer>();\\n        map.put(0,0);\\n        helper(nums,0,-1,0,dp);\\n        return map.get(max);\\n    }\\n\\n    public void helper(int[] nums,int index,int prev,int len,int[][][] dp){\\n\\n        if(index>=nums.length){\\n            max = Math.max(max,len);\\n            map.put(len, map.getOrDefault(len,0)+1);\\n            return;\\n        }\\n        if(prev<0 || nums[index]>nums[prev]){\\n            // take\\n            helper(nums,index+1,index,len+1);\\n        }\\n        // not take\\n        helper(nums,index+1,prev,len);\\n    }\\n}\\n\\n\\nI am getting TLE for above recursive solution. I am not understanding how to move forward with this. How can I convert this to DP ?\\n"
                    },
                    {
                        "username": "akhil_gadde",
                        "content": " Let\\'s say there is an array [1, 1, 2 , 2, 3, 3, 4, 4, . . . . ., 1000,1000] of length 2000.\\nNumber of subsequences should be 2^1000 right!\\nI am expecting 1e9+7 in the question. Am I missing something here?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "When you see `nums.length <= 2000`, problem solved. Use DP."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, when you see that the length of the array `nums` is reasonably small (e.g., `nums.length <= 2000`), it is a strong hint that a dynamic programming (DP) approach could be a good fit for solving the problem. \\n\\nThe reason is that DP algorithms often have time complexities proportional to the square or cube of the input size, making them feasible for relatively small inputs. In this case, the time complexity would be O(n^2), where n is the length of the `nums` array, which is manageable for n <= 2000.\\n\\nDP is well-suited for problems like this one, where the solution involves making choices at each step that depend on previous choices. In this problem, we keep track of the length and count of the longest increasing subsequence up to each point in the array. We can then build up the solution for the whole array by extending the solutions for the shorter subsequences. \\n\\nRemember, just seeing a small upper bound on the input size is not enough to immediately conclude that DP should be used. It\\'s essential to understand the problem and identify overlapping subproblems and an optimal substructure, which are key characteristics of problems that can be solved efficiently with DP."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Randomly giving TLE for C++\\uD83D\\uDE02\\nThe same test case runs under 50ms"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Continuous Increasing Subsequence",
        "question_content": "<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest <strong>continuous increasing subsequence</strong> (i.e. subarray)</em>. The subsequence must be <strong>strictly</strong> increasing.</p>\n\n<p>A <strong>continuous increasing subsequence</strong> is defined by two indices <code>l</code> and <code>r</code> (<code>l &lt; r</code>) such that it is <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> and for each <code>l &lt;= i &lt; r</code>, <code>nums[i] &lt; nums[i + 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,4,7]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The longest continuous increasing subsequence is [1,3,5] with length 3.\nEven though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly\nincreasing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 107365,
                "title": "java-c-clean-solution",
                "content": "The idea is to use ```cnt``` to record the length of the current continuous increasing subsequence which ends with ```nums[i]```, and use ```res``` to record the maximum ```cnt```.\\n\\nJava version:\\n```\\n    public int findLengthOfLCIS(int[] nums) {\\n        int res = 0, cnt = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i-1] < nums[i]) res = Math.max(res, ++cnt);\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```\\n\\nC++ version:\\n```\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int res = 0, cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(i == 0 || nums[i-1] < nums[i]) res = max(res, ++cnt);\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cnt```\n```nums[i]```\n```res```\n```cnt```\n```\\n    public int findLengthOfLCIS(int[] nums) {\\n        int res = 0, cnt = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i-1] < nums[i]) res = Math.max(res, ++cnt);\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int res = 0, cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(i == 0 || nums[i-1] < nums[i]) res = max(res, ++cnt);\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199080,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        if not nums:\\n            return 0\\n        dp = [1] * len(nums)\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i - 1] + 1\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        if not nums:\\n            return 0\\n        dp = [1] * len(nums)\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i - 1] + 1\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107392,
                "title": "python-simple-solution",
                "content": "A continuous subsequence is essentially a subarray. Hence this question is asking for the longest increasing subarray and I have no idea why the question calls it continuous subsequence to confuse the readers. \\n\\nAnyway, we can make one pass of the array and keep track of the current streak of increasing elements, reset it when it does not increase.\\n\\n```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        max_len = i = 0\\n        while i < len(nums):\\n            curr = 1\\n            while i + 1 < len(nums) and nums[i] < nums[i + 1]:\\n                curr, i = curr + 1, i + 1\\n            max_len = max(max_len, curr)\\n            i += 1\\n        return max_len\\n```\\n\\n**\\uD83D\\uDCAF Check out https://www.techinterviewhandbook.org for more tips and tricks by me to ace your coding interview \\uD83D\\uDCAF**",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        max_len = i = 0\\n        while i < len(nums):\\n            curr = 1\\n            while i + 1 < len(nums) and nums[i] < nums[i + 1]:\\n                curr, i = curr + 1, i + 1\\n            max_len = max(max_len, curr)\\n            i += 1\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669734,
                "title": "c-simple-solution",
                "content": "***Pls upvote if you find this helpful  :)***\\nKeep the length of each increasing sequence in a variable and one global variable for updating it with all the lengths of increasing sequences.\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()<=1)return nums.size();\\n        int answer=1,count=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n                answer=max(answer,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()<=1)return nums.size();\\n        int answer=1,count=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n                answer=max(answer,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107352,
                "title": "java-code-6-liner",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0) return 0;\\n        int length=1,temp=1;\\n        for(int i=0; i<nums.length-1;i++) {\\n            if(nums[i]<nums[i+1]) {temp++; length=Math.max(length,temp);}\\n            else temp=1; \\n        }\\n        return length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0) return 0;\\n        int length=1,temp=1;\\n        for(int i=0; i<nums.length-1;i++) {\\n            if(nums[i]<nums[i+1]) {temp++; length=Math.max(length,temp);}\\n            else temp=1; \\n        }\\n        return length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535268,
                "title": "python-o-n-solution-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        cur_len = 1\\n        max_len = 1\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i] > nums[i-1]:\\n                cur_len += 1\\n            else:\\n                max_len = max(max_len,cur_len)\\n                cur_len = 1\\n        \\n        return max(max_len,cur_len)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        cur_len = 1\\n        max_len = 1\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i] > nums[i-1]:\\n                cur_len += 1\\n            else:\\n                max_len = max(max_len,cur_len)\\n                cur_len = 1\\n        \\n        return max(max_len,cur_len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577001,
                "title": "easy-c-2-lines",
                "content": "Always set r and c as 1 cause subsequence length can\\'t be smaller than 1.\\n```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        int r=1,c=1;\\n        for(int i=1;i<nums.size();i++)\\n            r=max(r,nums[i]>nums[i-1]?++c:c=1);\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        int r=1,c=1;\\n        for(int i=1;i<nums.size();i++)\\n            r=max(r,nums[i]>nums[i-1]?++c:c=1);\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107351,
                "title": "java-solution-dp",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        \\n        int max = 1;\\n        dp[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n            else {\\n                dp[i] = 1;\\n            }\\n            max = Math.max(max, dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        \\n        int max = 1;\\n        dp[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n            else {\\n                dp[i] = 1;\\n            }\\n            max = Math.max(max, dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107389,
                "title": "c-java-clean-code-3-liner-2-pointers",
                "content": "**C++ record length**\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0, len = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            if (i == 0 || a[i] <= a[i - 1]) len = 0;\\n            mx = max(mx, ++len);\\n        }\\n        return mx;\\n    }\\n};\\n```\\n**C++ 2 pointer**\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.size(); j++) {\\n            if (j == 0 || a[j] <= a[j - 1]) i = j;\\n            mx = max(mx, j - (i - 1))\\n        }\\n        return mx;\\n    }\\n};\\n```\\n3 liner\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.size(); i = (j == 0 || a[j] <= a[j - 1]) ? j : i, mx = max(mx, j - (i - 1)), j++) { }\\n        return mx;\\n    }\\n};\\n```\\n**Java - 2 pointer**\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.length; i = (j == 0 || a[j] <= a[j - 1]) ? j : i, mx = Math.max(mx, j - i + 1), j++) { }\\n        return mx;\\n    }\\n}\\n```\\n\\n**Java length variable**\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n        int mx = 0, len = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            if (i == 0 || a[i] <= a[i - 1]) len = 0;\\n            mx = Math.max(mx, ++len);\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0, len = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            if (i == 0 || a[i] <= a[i - 1]) len = 0;\\n            mx = max(mx, ++len);\\n        }\\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.size(); j++) {\\n            if (j == 0 || a[j] <= a[j - 1]) i = j;\\n            mx = max(mx, j - (i - 1))\\n        }\\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.size(); i = (j == 0 || a[j] <= a[j - 1]) ? j : i, mx = max(mx, j - (i - 1)), j++) { }\\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n        int mx = 0;\\n        for (int i = 0, j = 0; j < a.length; i = (j == 0 || a[j] <= a[j - 1]) ? j : i, mx = Math.max(mx, j - i + 1), j++) { }\\n        return mx;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n        int mx = 0, len = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            if (i == 0 || a[i] <= a[i - 1]) len = 0;\\n            mx = Math.max(mx, ++len);\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394570,
                "title": "1-ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0) return 0;\\n        int length=1,temp=1;\\n        for(int i=0; i<nums.length-1;i++) {\\n            if(nums[i]<nums[i+1]) {temp++; length=Math.max(length,temp);}\\n            else temp=1; \\n        }\\n        return length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0) return 0;\\n        int length=1,temp=1;\\n        for(int i=0; i<nums.length-1;i++) {\\n            if(nums[i]<nums[i+1]) {temp++; length=Math.max(length,temp);}\\n            else temp=1; \\n        }\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979680,
                "title": "java-100-faster-simple-o-n-time-and-o-1-space-simple-and-only-few-lines",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) \\n{\\n\\tint maximum = 1;\\n\\tint currentMax = 1;\\n\\tfor(int i = 1; i < nums.length; i++)\\n\\t{\\n\\t\\tcurrentMax = nums[i] > nums[i - 1] ? currentMax + 1 : 1;   \\n\\t\\tmaximum = Math.max(maximum, currentMax);\\n\\t}\\n\\n\\treturn nums.length == 0 ? 0 : maximum;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) \\n{\\n\\tint maximum = 1;\\n\\tint currentMax = 1;\\n\\tfor(int i = 1; i < nums.length; i++)\\n\\t{\\n\\t\\tcurrentMax = nums[i] > nums[i - 1] ? currentMax + 1 : 1;   \\n\\t\\tmaximum = Math.max(maximum, currentMax);\\n\\t}\\n\\n\\treturn nums.length == 0 ? 0 : maximum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2445685,
                "title": "two-python-solutions-using-dp-and-a-straightforward-soln",
                "content": "1. DP solution.\\n```class Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        dp=[1]*len(nums)\\n        for i in range(1,len(nums)):\\n            if nums[i]>nums[i-1]:\\n                dp[i]+=dp[i-1]\\n        return max(dp)\\n ```\\n2\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        counter=1\\n        temp=1\\n        for i in range(0,len(nums)-1):\\n            if nums[i]<nums[i+1]:\\n                temp+=1\\n                if temp>counter:\\n                    counter=temp\\n            else:\\n                temp=1\\n        return counter",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        dp=[1]*len(nums)\\n        for i in range(1,len(nums)):\\n            if nums[i]>nums[i-1]:\\n                dp[i]+=dp[i-1]\\n        return max(dp)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 541419,
                "title": "python-3-three-solutions-using-stack-and-sliding-window-and-dp",
                "content": "**Using Stack**\\n```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums)==1:\\n            return 1\\n        st = []\\n        max_len = float(\\'-inf\\')\\n        for i in range(len(nums)):\\n            if not st:\\n                st.append(nums[i])\\n            elif st and st[-1]<nums[i]:\\n                st.append(nums[i])\\n            elif st and st[-1]>=nums[i]:\\n                st = []\\n                st.append(nums[i])\\n            max_len = max(max_len,len(st))\\n        return max_len\\n```\\n\\n**Sliding Window**\\n```python \\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return 1\\n        ans = 0 \\n        ind = 0\\n        for i in range(1,len(nums)):\\n            if nums[i-1]>=nums[i]:\\n                ind = i\\n            ans = max(ans,i-ind+1)\\n        return ans\\n```\\n\\n\\n**Dp Approach**\\n```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        dp = [1] * len(nums)\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i - 1] + 1\\n        return max(dp)\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums)==1:\\n            return 1\\n        st = []\\n        max_len = float(\\'-inf\\')\\n        for i in range(len(nums)):\\n            if not st:\\n                st.append(nums[i])\\n            elif st and st[-1]<nums[i]:\\n                st.append(nums[i])\\n            elif st and st[-1]>=nums[i]:\\n                st = []\\n                st.append(nums[i])\\n            max_len = max(max_len,len(st))\\n        return max_len\\n```\n```python \\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return 1\\n        ans = 0 \\n        ind = 0\\n        for i in range(1,len(nums)):\\n            if nums[i-1]>=nums[i]:\\n                ind = i\\n            ans = max(ans,i-ind+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015293,
                "title": "python-easy-solution-without-sliding-window-o-n-54ms-beats-93-23-with-explanation",
                "content": "**Explanation**\\n1. Edge case if there is only one element in nums\\n2. add a counter and a max counter (in case the maximum is at beginning)\\n3. iterate through nums:\\n\\t4. if it\\'s the first element, continue (no previous, will evoke error)\\n\\t5. each time the element is greater than the previous one (increasing), add 1 to counter\\n\\t6. if not, check if the counter is the largest one yet (if it\\'s largest subarray yet)\\n\\t\\t7. if yes, update max counter\\n\\t\\t8. reset counter to 1\\n7. check if last counter is max (edge case)\\n8. return max counter\\n\\n```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1:\\n            return 1\\n        \\n        counter = 1\\n        max_counter = 0\\n        for i in range(len(nums)):\\n            if i == 0:\\n                continue\\n            else:  \\n                if nums[i] > nums[i-1]:\\n                    counter += 1\\n                else:\\n                    if counter > max_counter:\\n                        max_counter = counter\\n                    counter = 1\\n        if counter > max_counter:\\n            max_counter = counter\\n        \\n        return max_counter\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1:\\n            return 1\\n        \\n        counter = 1\\n        max_counter = 0\\n        for i in range(len(nums)):\\n            if i == 0:\\n                continue\\n            else:  \\n                if nums[i] > nums[i-1]:\\n                    counter += 1\\n                else:\\n                    if counter > max_counter:\\n                        max_counter = counter\\n                    counter = 1\\n        if counter > max_counter:\\n            max_counter = counter\\n        \\n        return max_counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670447,
                "title": "javascript-clean-2-sliding-window-approaches",
                "content": "## Solution 1\\n\\n```\\nvar findLengthOfLCIS = function(nums) {\\n    let len = 1, maxLen = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] < nums[i+1]) len++;\\n        else len = 1;\\n        maxLen = Math.max(len, maxLen);\\n    }\\n    return maxLen;  \\n};\\n```\\n\\n## Solution 2\\n\\n```javascript\\nvar findLengthOfLCIS = function(nums) {\\n    if(nums.length < 2) return nums.length;\\n    let left = 0, right = 1, maxLen = 0;\\n    \\n    while(right < nums.length) {\\n        if(nums[right-1] >= nums[right]) left = right;\\n        right++;\\n        maxLen = Math.max(right - left, maxLen);\\n    }\\n    return maxLen    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar findLengthOfLCIS = function(nums) {\\n    let len = 1, maxLen = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] < nums[i+1]) len++;\\n        else len = 1;\\n        maxLen = Math.max(len, maxLen);\\n    }\\n    return maxLen;  \\n};\\n```\n```javascript\\nvar findLengthOfLCIS = function(nums) {\\n    if(nums.length < 2) return nums.length;\\n    let left = 0, right = 1, maxLen = 0;\\n    \\n    while(right < nums.length) {\\n        if(nums[right-1] >= nums[right]) left = right;\\n        right++;\\n        maxLen = Math.max(right - left, maxLen);\\n    }\\n    return maxLen    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3118835,
                "title": "simple-java-solution-using-2-pointer-approach-time-beats-100-of-the-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are to find the longest continuous increasing subsequence(LCIS), for that, what I thought was that, if we are checking the length from an element at any index, and if we reach a point that now our subsequence is not increasing, then we need not to check the length of longest cont. inc. subsequence.\\n\\nFor eg:\\n[1,3,5,4,***2,3,4,5***]\\n\\nhere 2,3,4,5 is our LCIS, what I mean to say in above paragraph was, when we check the LCIS from element at index 0, it ends at element at index 2, now we need not to look for LCIS from element at index 1 and 2, as there length will always be lesser than that of element at index 0.\\n\\nI checked the length of each such part of array and returned the maximum one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use 2 pointers to solve this problem, we will keep the track of previous element and j will keep track of current element. \\n\\nWe will compare nums[i] and nums[j] if nums[j]>nums[i], then currentCount(variable to store the length of current LCIS) will be incremented. \\n\\nIf nums[j]>nums[i] is false, means this was the end of current LCIS and we now need to check the next LCIS means, we will now chance i to j, increament j and make currentCount to 1.\\n\\nIn every iteration we are also updating maxCount if currentCount gets greater than it. \\n\\nAt last we are returning the maxCount.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i = j;\\n                j++;\\n                currentCount = 1;\\n            }\\n            if(maxCount<currentCount)\\n            {\\n                maxCount = currentCount;\\n            }\\n            \\n        }  \\n        return maxCount;  \\n    }\\n}\\n```\\n\\n\\n****Do Upvote if found useful.**** \\u2B06\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i = j;\\n                j++;\\n                currentCount = 1;\\n            }\\n            if(maxCount<currentCount)\\n            {\\n                maxCount = currentCount;\\n            }\\n            \\n        }  \\n        return maxCount;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317161,
                "title": "674-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We handle the base cases where the input list is empty or has only one element. In both cases, the length of the longest continuous in1.creasing subsequence is the length of the input list itself, so we simply return that length.\\n\\n2. We initialize two variables cur_len and max_len to keep track of the length of the current increasing subsequence and the maximum length seen so far, respectively. We set both variables to 1 because the first element of the input list is always part of a subsequence of length 1.\\n\\n3. We iterate through the input list starting from the second element. For each element, we check if it is greater than the previous element. If it is, then it is part of the current increasing subsequence, so we increase the length of the subsequence by 1 (cur_len += 1). We also update the maximum length seen so far (max_len = max(max_len, cur_len)) if necessary. If the current element is not greater than the previous element, then it is the start of a new increasing subsequence, so we reset the length of the subsequence to 1 (cur_len = 1).\\n\\n4. After iterating through the entire input list, we return the maximum length of any increasing subsequence seen (return max_len).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        # Base case: empty list or single element list\\n        if len(nums) == 0 or len(nums) == 1:\\n            return len(nums)\\n        \\n        # Initialize variables to keep track of current length and max length\\n        cur_len = 1  # current length of increasing subsequence\\n        max_len = 1  # maximum length of increasing subsequence\\n        \\n        # Iterate through the list starting from the second element\\n        for i in range(1, len(nums)):\\n            # If the current element is greater than the previous element, it is part of the increasing subsequence\\n            if nums[i] > nums[i-1]:\\n                cur_len += 1  # increase the length of the subsequence\\n                max_len = max(max_len, cur_len)  # update the maximum length if necessary\\n            else:\\n                cur_len = 1  # reset the length of the subsequence if the current element is not greater than the previous element\\n        \\n        return max_len\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        # Base case: empty list or single element list\\n        if len(nums) == 0 or len(nums) == 1:\\n            return len(nums)\\n        \\n        # Initialize variables to keep track of current length and max length\\n        cur_len = 1  # current length of increasing subsequence\\n        max_len = 1  # maximum length of increasing subsequence\\n        \\n        # Iterate through the list starting from the second element\\n        for i in range(1, len(nums)):\\n            # If the current element is greater than the previous element, it is part of the increasing subsequence\\n            if nums[i] > nums[i-1]:\\n                cur_len += 1  # increase the length of the subsequence\\n                max_len = max(max_len, cur_len)  # update the maximum length if necessary\\n            else:\\n                cur_len = 1  # reset the length of the subsequence if the current element is not greater than the previous element\\n        \\n        return max_len\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197563,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int maxi=1;\\n        int c=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                c++;\\n            }\\n            else{\\n                c=1;\\n            }\\n            if(maxi<c){\\n                maxi=c;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int maxi=1;\\n        int c=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                c++;\\n            }\\n            else{\\n                c=1;\\n            }\\n            if(maxi<c){\\n                maxi=c;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488316,
                "title": "js-faster-than-100-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/2abfa80c-dc20-4da7-8002-ca5d2ad5a50f_1661569790.2926805.png)\\n\\n```\\nvar findLengthOfLCIS = function(nums) {\\n    let output = 0;\\n    let count = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (!count || nums[i] > nums[i - 1]) {\\n            count++;\\n        } else {\\n            output = Math.max(output, count);\\n            count = 1;\\n        }\\n    }\\n    \\n    return Math.max(output, count);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLengthOfLCIS = function(nums) {\\n    let output = 0;\\n    let count = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (!count || nums[i] > nums[i - 1]) {\\n            count++;\\n        } else {\\n            output = Math.max(output, count);\\n            count = 1;\\n        }\\n    }\\n    \\n    return Math.max(output, count);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 752266,
                "title": "python-o-n-greedy",
                "content": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n        max_length = 0\\n        cur_length = 0\\n        cur_max = float(\\'-inf\\')\\n        for num in nums:\\n            if num > cur_max:\\n                cur_length += 1\\n                cur_max = num\\n            else:\\n                max_length = max(max_length, cur_length)\\n                cur_length = 1\\n                cur_max = num\\n        return max(max_length, cur_length)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n        max_length = 0\\n        cur_length = 0\\n        cur_max = float(\\'-inf\\')\\n        for num in nums:\\n            if num > cur_max:\\n                cur_length += 1\\n                cur_max = num\\n            else:\\n                max_length = max(max_length, cur_length)\\n                cur_length = 1\\n                cur_max = num\\n        return max(max_length, cur_length)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 715456,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n  let max = 0;\\n  let curr = 0;\\n  let prev = -Infinity;\\n  for (let n of nums){\\n    if(n > prev){\\n      max = Math.max(max, ++curr)      \\n    }else{\\n      curr = 1;\\n    }\\n    prev = n\\n  }\\n  return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n  let max = 0;\\n  let curr = 0;\\n  let prev = -Infinity;\\n  for (let n of nums){\\n    if(n > prev){\\n      max = Math.max(max, ++curr)      \\n    }else{\\n      curr = 1;\\n    }\\n    prev = n\\n  }\\n  return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432416,
                "title": "straight-forward-and-fast-python",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 2:\\n            return len(nums)\\n        tmp, max_l = 1, 0\\n        for i in range(len(nums) - 1):         \\n            if nums[i] < nums[i + 1]:\\n                tmp += 1\\n            else:\\n                max_l = max(max_l, tmp)\\n                tmp = 1\\n        return max(max_l, tmp)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 2:\\n            return len(nums)\\n        tmp, max_l = 1, 0\\n        for i in range(len(nums) - 1):         \\n            if nums[i] < nums[i + 1]:\\n                tmp += 1\\n            else:\\n                max_l = max(max_l, tmp)\\n                tmp = 1\\n        return max(max_l, tmp)",
                "codeTag": "Java"
            },
            {
                "id": 3521788,
                "title": "o-n-longest-continuous-increasing-subsequence-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int i, len=1, maxlen=1;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                len++;\\n            }\\n            else if(len>maxlen)\\n            {\\n                maxlen = len;\\n                len=1;\\n            }\\n            else\\n            {\\n                len=1;\\n            }\\n        }\\n        if(len>maxlen)\\n            maxlen = len;\\n        return maxlen;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/db35f119-6d56-413c-aeac-389431744144_1684034399.839135.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int i, len=1, maxlen=1;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                len++;\\n            }\\n            else if(len>maxlen)\\n            {\\n                maxlen = len;\\n                len=1;\\n            }\\n            else\\n            {\\n                len=1;\\n            }\\n        }\\n        if(len>maxlen)\\n            maxlen = len;\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426987,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int maxlength = 1;\\n        int length = 1;\\n        int n = nums.size();\\n        for(int i= 1; i<n;i++){\\n            if (nums[i-1]<nums[i]){\\n                length++;\\n            }\\n            else{\\n                if(maxlength<length){\\n                    maxlength = length;\\n                }\\n                length = 1;\\n            }\\n        }\\n        return max(length, maxlength);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        l, r, curMax = 0, 1, 1\\n        while r < len(nums):\\n            if nums[r] > nums[r-1]:\\n                curMax = max(curMax, r-l+1)\\n            else:\\n                l = r\\n            r += 1\\n        return curMax\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i = j;\\n                j++;\\n                currentCount = 1;\\n            }\\n            if(maxCount<currentCount)\\n            {\\n                maxCount = currentCount;\\n            }\\n        }  \\n        return maxCount;  \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int maxlength = 1;\\n        int length = 1;\\n        int n = nums.size();\\n        for(int i= 1; i<n;i++){\\n            if (nums[i-1]<nums[i]){\\n                length++;\\n            }\\n            else{\\n                if(maxlength<length){\\n                    maxlength = length;\\n                }\\n                length = 1;\\n            }\\n        }\\n        return max(length, maxlength);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        l, r, curMax = 0, 1, 1\\n        while r < len(nums):\\n            if nums[r] > nums[r-1]:\\n                curMax = max(curMax, r-l+1)\\n            else:\\n                l = r\\n            r += 1\\n        return curMax\\n```\n```Java []\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        int i = 0 ;\\n        int j = 1;\\n        while(j<nums.length)\\n        {\\n            if(nums[j]>nums[i])\\n            {\\n                currentCount++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                i = j;\\n                j++;\\n                currentCount = 1;\\n            }\\n            if(maxCount<currentCount)\\n            {\\n                maxCount = currentCount;\\n            }\\n        }  \\n        return maxCount;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160913,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans=0,c=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                ans=max(ans,c);\\n                c=1;\\n            }\\n        }\\n        ans=max(ans,c);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans=0,c=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                ans=max(ans,c);\\n                c=1;\\n            }\\n        }\\n        ans=max(ans,c);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454483,
                "title": "o-n-with-go",
                "content": "```\\nfunc findLengthOfLCIS(nums []int) int {\\n    res, current := 1, 1\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            current++            \\n        } else {\\n            if current > res {\\n                res = current\\n            }\\n            \\n            current = 1\\n        }\\n    }\\n    \\n    if current > res {\\n        res = current\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findLengthOfLCIS(nums []int) int {\\n    res, current := 1, 1\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            current++            \\n        } else {\\n            if current > res {\\n                res = current\\n            }\\n            \\n            current = 1\\n        }\\n    }\\n    \\n    if current > res {\\n        res = current\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402115,
                "title": "easy-java-solution-1ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = 1;\\n        int count = 1;\\n        \\n        for(int i = 1 ; i < nums.length; i++) {\\n            if (nums[i - 1] < nums[i]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (max < count) {\\n                max = count;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = 1;\\n        int count = 1;\\n        \\n        for(int i = 1 ; i < nums.length; i++) {\\n            if (nums[i - 1] < nums[i]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (max < count) {\\n                max = count;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053719,
                "title": "o-n-solution",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        maxLen = count = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                count = 1\\n                \\n            maxLen = max(count, maxLen)\\n                \\n        return maxLen\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        maxLen = count = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                count = 1\\n                \\n            maxLen = max(count, maxLen)\\n                \\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957587,
                "title": "simple-and-easy-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int findLengthOfLCIS(vector<int> &nums)\\n    {\\n        int mn = INT_MIN, cnt = 0, mx = 0;\\n        for (auto it : nums)\\n        {\\n            if (it > mn)\\n            {\\n                mn = it;\\n                cnt++;\\n            }\\n            else\\n            {\\n                mx = max(cnt, mx);\\n                mn = it;\\n                cnt = 1;\\n            }\\n        }\\n        mx = max(cnt, mx);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findLengthOfLCIS(vector<int> &nums)\\n    {\\n        int mn = INT_MIN, cnt = 0, mx = 0;\\n        for (auto it : nums)\\n        {\\n            if (it > mn)\\n            {\\n                mn = it;\\n                cnt++;\\n            }\\n            else\\n            {\\n                mx = max(cnt, mx);\\n                mn = it;\\n                cnt = 1;\\n            }\\n        }\\n        mx = max(cnt, mx);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881861,
                "title": "longest-continuous-increasing-subsequence-solution-java",
                "content": "class Solution {\\n  public int findLengthOfLCIS(int[] nums) {\\n    int ans = 0;\\n\\n    for (int l = 0, r = 0; r < nums.length; ++r) {\\n      if (r > 0 && nums[r] <= nums[r - 1])\\n        l = r;\\n      ans = Math.max(ans, r - l + 1);\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n  public int findLengthOfLCIS(int[] nums) {\\n    int ans = 0;\\n\\n    for (int l = 0, r = 0; r < nums.length; ++r) {\\n      if (r > 0 && nums[r] <= nums[r - 1])\\n        l = r;\\n      ans = Math.max(ans, r - l + 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1626383,
                "title": "python-single-pass-simplest-self-explanatory-code",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        lcis, cis = 1, 1\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                cis += 1\\n            else:\\n                cis = 1\\n            lcis = max(lcis, cis)\\n        return lcis\\n        \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        lcis, cis = 1, 1\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                cis += 1\\n            else:\\n                cis = 1\\n            lcis = max(lcis, cis)\\n        return lcis\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526297,
                "title": "c-4ms-simple-solution",
                "content": "class Solution {\\npublic:\\n\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int ct = 1, count=0;\\n        \\n        for(int i=0 ; i<n-1 ; ++i)\\n        {\\n            if(nums[i]>=nums[i+1])\\n            {\\n                count = max(count,ct);\\n                ct=1;\\n            }\\n            else ct++;\\n        }\\n        count = max(count,ct);\\n        return count;\\n    }\\n};\\n\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        int ct = 1, count=0;\\n        \\n        for(int i=0 ; i<n-1 ; ++i)\\n        {\\n            if(nums[i]>=nums[i+1])\\n            {\\n                count = max(count,ct);\\n                ct=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1401477,
                "title": "easy-java-solution",
                "content": "class Solution {\\n\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = 1, count = 1;\\n        \\n        for(int i = 1; i<nums.length; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                count++;\\n                max = Math.max(max, count);\\n            }\\n            else\\n                count = 1;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = 1, count = 1;\\n        \\n        for(int i = 1; i<nums.length; i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                count++;\\n                max = Math.max(max, count);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1125400,
                "title": "js-easy-to-understand-for-beginners-as-well-2-solutions",
                "content": "```\\nvar findLengthOfLCIS = function (nums) {\\n  let count = 1,\\n    max = 0;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] > nums[i - 1]) {\\n      count++;\\n      max = Math.max(max, count);\\n    } else {\\n      count = 1;\\n    }\\n  }\\n  return nums.length >= 1 ? (max > 0 ? max : count) : 0;\\n};\\n\\n```\\n\\nSecond solution:\\n```\\nvar findLengthOfLCIS = function(nums) {\\n    if(nums.length==0) return 0\\n    let count=1,max=1;\\n    for(let i=0;i<nums.length-1;i++){\\n        if(nums[i]<nums[i+1]){\\n            count++;\\n            max=Math.max(count,max);\\n        }else{\\n            count=1;\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\nIgnore the below solution(this is for the guy who asked another ques in the comment)\\n```\\nconst longestIncreaseWithInBoundary = (arr, indices) => {\\n  // converting 2D array to 1D\\n  // [[0, 5],[1, 5],[2, 5],[2, 2]] will be [0, 5, 1, 5, 2, 5, 2, 2]\\n  const flatIndices = indices.flat();\\n\\n  const findLongest = (sliced) => {\\n    // this is the old method which is used in this question\\n    let count = 1,\\n      max = 0;\\n    for (let i = 1; i < sliced.length; i++) {\\n      if (sliced[i] > sliced[i - 1]) {\\n        count++;\\n        max = Math.max(count, max);\\n      } else {\\n        count = 1;\\n      }\\n    }\\n    return max > 0 ? max : count;\\n  };\\n\\n let res = [],\\n    map = new Map();\\n  // iterating the 1D(which we converted...we converted because we can avoid inner for loop)\\n  for (let i = 0; i < flatIndices.length; i += 2) {\\n    // this takes a part of given nums\\n    // for example, part of [2,1,3,5,4,7] with  boundary [2,5] is [3,5,4,7]\\n    const slicedArr = arr.slice(flatIndices[i], flatIndices[i + 1] + 1);\\n    // if that value is already stored we can take from that map(no need to pass to the helper func)\\n    if (map.has(flatIndices[i] + \"\" + flatIndices[i + 1])) {\\n      res.push(map.get(flatIndices[i] + \"\" + flatIndices[i + 1]));\\n    } else {\\n      // passing that sliceArr into the helper function(name whatever u want)\\n      const length = findLongest(slicedArr);\\n      // storing that returned value in the map\\n      map.set(flatIndices[i] + \"\" + flatIndices[i + 1], length);\\n      // pushing the returned max subarray value\\n      res.push(length);\\n    }\\n  }\\n  // returning the array which holds the max subarray correspondingly.\\n  // [3,3,2,1]\\n  return res;\\n};\\nconsole.log(\\n  longestIncreaseWithInBoundary(\\n    [2, 1, 3, 5, 4, 7],\\n    [\\n      [0, 5],\\n      [1, 5],\\n      [2, 5],\\n      [2, 2],\\n    ]\\n  )\\n);\\n```\\nBut still Im not giving you assurance that this will work if large number of data is passed.Try it and let me know.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLengthOfLCIS = function (nums) {\\n  let count = 1,\\n    max = 0;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] > nums[i - 1]) {\\n      count++;\\n      max = Math.max(max, count);\\n    } else {\\n      count = 1;\\n    }\\n  }\\n  return nums.length >= 1 ? (max > 0 ? max : count) : 0;\\n};\\n\\n```\n```\\nvar findLengthOfLCIS = function(nums) {\\n    if(nums.length==0) return 0\\n    let count=1,max=1;\\n    for(let i=0;i<nums.length-1;i++){\\n        if(nums[i]<nums[i+1]){\\n            count++;\\n            max=Math.max(count,max);\\n        }else{\\n            count=1;\\n        }\\n    }\\n    return max;\\n};\\n```\n```\\nconst longestIncreaseWithInBoundary = (arr, indices) => {\\n  // converting 2D array to 1D\\n  // [[0, 5],[1, 5],[2, 5],[2, 2]] will be [0, 5, 1, 5, 2, 5, 2, 2]\\n  const flatIndices = indices.flat();\\n\\n  const findLongest = (sliced) => {\\n    // this is the old method which is used in this question\\n    let count = 1,\\n      max = 0;\\n    for (let i = 1; i < sliced.length; i++) {\\n      if (sliced[i] > sliced[i - 1]) {\\n        count++;\\n        max = Math.max(count, max);\\n      } else {\\n        count = 1;\\n      }\\n    }\\n    return max > 0 ? max : count;\\n  };\\n\\n let res = [],\\n    map = new Map();\\n  // iterating the 1D(which we converted...we converted because we can avoid inner for loop)\\n  for (let i = 0; i < flatIndices.length; i += 2) {\\n    // this takes a part of given nums\\n    // for example, part of [2,1,3,5,4,7] with  boundary [2,5] is [3,5,4,7]\\n    const slicedArr = arr.slice(flatIndices[i], flatIndices[i + 1] + 1);\\n    // if that value is already stored we can take from that map(no need to pass to the helper func)\\n    if (map.has(flatIndices[i] + \"\" + flatIndices[i + 1])) {\\n      res.push(map.get(flatIndices[i] + \"\" + flatIndices[i + 1]));\\n    } else {\\n      // passing that sliceArr into the helper function(name whatever u want)\\n      const length = findLongest(slicedArr);\\n      // storing that returned value in the map\\n      map.set(flatIndices[i] + \"\" + flatIndices[i + 1], length);\\n      // pushing the returned max subarray value\\n      res.push(length);\\n    }\\n  }\\n  // returning the array which holds the max subarray correspondingly.\\n  // [3,3,2,1]\\n  return res;\\n};\\nconsole.log(\\n  longestIncreaseWithInBoundary(\\n    [2, 1, 3, 5, 4, 7],\\n    [\\n      [0, 5],\\n      [1, 5],\\n      [2, 5],\\n      [2, 2],\\n    ]\\n  )\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765674,
                "title": "c-greed-is-best-easy-to-understand",
                "content": "***Runtime: 24 ms, faster than 54.02% of C++ online submissions for Longest Continuous Increasing Subsequence.\\nMemory Usage: 11 MB, less than 94.51% of C++ online submissions for Longest Continuous Increasing Subsequence.***\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)    \\n            return 0;\\n        int result = 1;\\n        int current = 1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] > nums[i-1]){\\n                current++;\\n            }else{\\n                current = 1;\\n            }\\n            result = max(result, current);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)    \\n            return 0;\\n        int result = 1;\\n        int current = 1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] > nums[i-1]){\\n                current++;\\n            }else{\\n                current = 1;\\n            }\\n            result = max(result, current);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463513,
                "title": "simple-java-beats-100",
                "content": "```\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums==null || nums.length ==0)\\n            return 0;\\n        int count = 1;\\n        int max = 0;\\n        for(int i =1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                count++;\\n            }else{\\n                max = Math.max(max,count);\\n                count=1;\\n            }\\n        }\\n        \\n        return Math.max(max,count); // if the complete sequence is monotonically increasing",
                "solutionTags": [],
                "code": "```\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums==null || nums.length ==0)\\n            return 0;\\n        int count = 1;\\n        int max = 0;\\n        for(int i =1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                count++;\\n            }else{\\n                max = Math.max(max,count);\\n                count=1;\\n            }\\n        }\\n        \\n        return Math.max(max,count); // if the complete sequence is monotonically increasing",
                "codeTag": "Unknown"
            },
            {
                "id": 328133,
                "title": "divide-and-conquer-recursive-solution-accepted",
                "content": "Below is a classic divide-and-conquer approach to solve this problem using recursion in C#. Although a little complex than the linear solution presented in Solution tab, its intuitive and a common approach for \"longest subsequence\" kind of problems.\\n\\n```\\npublic class Solution {\\n    int FindLCIS_Iter(int[] a, int start, int end) {\\n        if (start == end) {\\n            return 1;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        int leftLcis = FindLCIS_Iter(a, start, mid);\\n        int rightLcis = FindLCIS_Iter(a, mid + 1, end);\\n\\t\\t\\n        int currentLcis = FindLCIS(a, start, end, mid);\\n        List<int> lcisList = new List<int>() { leftLcis, rightLcis, currentLcis };\\n        lcisList.Sort();\\n        return lcisList[lcisList.Count - 1];\\n    }\\n    \\n    int FindLCIS(int[] a, int start, int end, int mid) {\\n        int i = mid, j = mid;\\n        while (i > start && a[i] > a[i - 1]) i -= 1;\\n        while (j < end && a[j] < a[j + 1]) j += 1;\\n        return j - i + 1;\\n    }\\n    \\n    public int FindLengthOfLCIS(int[] nums) {\\n        if (nums.Length < 2) return nums.Length;\\n        return FindLCIS_Iter(nums, 0, nums.Length - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int FindLCIS_Iter(int[] a, int start, int end) {\\n        if (start == end) {\\n            return 1;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        int leftLcis = FindLCIS_Iter(a, start, mid);\\n        int rightLcis = FindLCIS_Iter(a, mid + 1, end);\\n\\t\\t\\n        int currentLcis = FindLCIS(a, start, end, mid);\\n        List<int> lcisList = new List<int>() { leftLcis, rightLcis, currentLcis };\\n        lcisList.Sort();\\n        return lcisList[lcisList.Count - 1];\\n    }\\n    \\n    int FindLCIS(int[] a, int start, int end, int mid) {\\n        int i = mid, j = mid;\\n        while (i > start && a[i] > a[i - 1]) i -= 1;\\n        while (j < end && a[j] < a[j + 1]) j += 1;\\n        return j - i + 1;\\n    }\\n    \\n    public int FindLengthOfLCIS(int[] nums) {\\n        if (nums.Length < 2) return nums.Length;\\n        return FindLCIS_Iter(nums, 0, nums.Length - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304294,
                "title": "python-easy-solution",
                "content": "\\n\\n        max_res = 0\\n        count = 0\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i] > nums[i - 1]:\\n                count += 1\\n                max_res = max(max_res, count)\\n            else:\\n                count = 1\\n        return max_res",
                "solutionTags": [],
                "code": "\\n\\n        max_res = 0\\n        count = 0\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i] > nums[i - 1]:\\n                count += 1\\n                max_res = max(max_res, count)\\n            else:\\n                count = 1\\n        return max_res",
                "codeTag": "Unknown"
            },
            {
                "id": 125498,
                "title": "dp-is-powerfull",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n        for(int i = 1;i < nums.length;++i) {\\n            if(nums[i] > nums[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            } else {\\n                dp[i] = 1;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i < nums.length;++i) {\\n            if(dp[i] > max) {\\n                max = dp[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n        for(int i = 1;i < nums.length;++i) {\\n            if(nums[i] > nums[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            } else {\\n                dp[i] = 1;\\n            }\\n        }\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0;i < nums.length;++i) {\\n            if(dp[i] > max) {\\n                max = dp[i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107366,
                "title": "python",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        if not nums:\\n            return 0\\n        ans, pre = 1, 1\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                ans = max(ans, i - pre)\\n            else:\\n                pre = 1\\n            ans = max(ans, pre)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        if not nums:\\n            return 0\\n        ans, pre = 1, 1\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                ans = max(ans, i - pre)\\n            else:\\n                pre = 1\\n            ans = max(ans, pre)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003991,
                "title": "beginners-python-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 1\\n        curr_len = 1\\n        for i in range(1,n):\\n            if nums[i] > nums[i-1]:\\n                curr_len = curr_len + 1\\n                ans = max(ans,curr_len)\\n            else:\\n                curr_len = 1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 1\\n        curr_len = 1\\n        for i in range(1,n):\\n            if nums[i] > nums[i-1]:\\n                curr_len = curr_len + 1\\n                ans = max(ans,curr_len)\\n            else:\\n                curr_len = 1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898082,
                "title": "starting-and-ending-indexes-of-longest-continuous-increasing-subsequence",
                "content": "# Intuition\\nAs soon as I read the problem statement, I thought of storing the starting and ending indexes of the  increasing longest continuous.subsequence.\\n\\n# Approach\\nThe starting and ending indexes are found and the length of the maximum subsequence is updated.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n= nums.size();\\n        int start=0, end=0, ans=1;\\n        for (int i=1; i<n;i++){\\n            if (nums[i]> nums[end]){\\n            end=i;\\n            ans=max(ans, end-start+1);\\n            }\\n            else {\\n                start=i, end=i;\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n= nums.size();\\n        int start=0, end=0, ans=1;\\n        for (int i=1; i<n;i++){\\n            if (nums[i]> nums[end]){\\n            end=i;\\n            ans=max(ans, end-start+1);\\n            }\\n            else {\\n                start=i, end=i;\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840679,
                "title": "c-easy-solution-lis-slight-modification",
                "content": "Just the ***Longest Increasing Subsequence Code+ Slight modification.***\\nWe need ***continuous LIS*** which means difference between adjacent index should be 1. That\\'s it \\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int prev_ind=ind-1;prev_ind>=-1;prev_ind--){\\n                int len=dp[ind+1][prev_ind+1];\\n                if(prev_ind==-1 || nums[ind]>nums[prev_ind]) {\\n                    if(ind-prev==1)   // Here we add the condition, rest code is same as of LIS\\n                    len= max(len,1+dp[ind+1][ind+1]);\\n                }\\n                dp[ind][prev_ind+1]=len;\\n            }\\n        }\\n                \\n        return dp[0][0];\\n    }\\n};\\n```\\nThanks \\nNitin Manoj",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        for(int ind=n-1;ind>=0;ind--){\\n            for(int prev_ind=ind-1;prev_ind>=-1;prev_ind--){\\n                int len=dp[ind+1][prev_ind+1];\\n                if(prev_ind==-1 || nums[ind]>nums[prev_ind]) {\\n                    if(ind-prev==1)   // Here we add the condition, rest code is same as of LIS\\n                    len= max(len,1+dp[ind+1][ind+1]);\\n                }\\n                dp[ind][prev_ind+1]=len;\\n            }\\n        }\\n                \\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796383,
                "title": "python-short-1-liner-functional-programming",
                "content": "# Approach\\n1. For each adjacent `pairwise` numbers in `nums` check if $$nums_i < nums_{i + 1}$$ to form a boolean array. (Useful to see bools as 1 and 0).\\n`lt_bools = starmap(lt, pairwise(nums))`\\n\\n2. Calculate `running_sums` on the array of bools and reset every time a `0` is found.\\n`run_sums = accumulate(lt_bools, lambda a, x: a * x + 1, initial=1)`\\n\\n3. Return the `max(run_sums) + 1`\\n\\nExample:\\n```python\\nnums     = [1, 3, 5, 4, 7, 2, 4, 5, 7, 9]\\nlt_bools =   [1, 1, 0, 1, 0, 1, 1, 1, 1]\\nrun_sums = [1, 2, 3, 1, 2, 1, 2, 3, 4, 5] # Extra 1 added at the beginning\\nlcis_len = 5\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: list[int]) -> int:\\n        return max(accumulate(starmap(lt, pairwise(nums)), lambda a, x: a * x + 1, initial=1))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```python\\nnums     = [1, 3, 5, 4, 7, 2, 4, 5, 7, 9]\\nlt_bools =   [1, 1, 0, 1, 0, 1, 1, 1, 1]\\nrun_sums = [1, 2, 3, 1, 2, 1, 2, 3, 4, 5] # Extra 1 added at the beginning\\nlcis_len = 5\\n```\n```python\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: list[int]) -> int:\\n        return max(accumulate(starmap(lt, pairwise(nums)), lambda a, x: a * x + 1, initial=1))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519879,
                "title": "very-easy-and-simple-solution-in-javascript-wow-just-watch-it",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n    let max = 0, curr = 0\\n    for(let i = 0 ; i < nums.length; i++) {\\n        if(nums[i] < nums[i + 1]) {\\n            curr++\\n            max = Math.max(max, curr)\\n        } else {\\n            curr = 0\\n        }\\n    }\\n    return max > 0 ? max + 1 : 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n    let max = 0, curr = 0\\n    for(let i = 0 ; i < nums.length; i++) {\\n        if(nums[i] < nums[i + 1]) {\\n            curr++\\n            max = Math.max(max, curr)\\n        } else {\\n            curr = 0\\n        }\\n    }\\n    return max > 0 ? max + 1 : 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3416848,
                "title": "c-solution-87-72-time-94-70-space-update-max-length-on-the-fly",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums);\\n};\\n/*********************************************************/\\nint Solution::findLengthOfLCIS(vector<int>& nums) {\\n    int maxLength=1, length=1, i, size = nums.size();\\n    for (i = 1; i < size; ++i) {\\n        if (nums[i-1] < nums[i]) {\\n            ++length;\\n            if (length > maxLength) {\\n                maxLength = length;\\n            }\\n        } else {\\n            length = 1;\\n        }\\n    }\\n    return maxLength;\\n}\\n/*********************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums);\\n};\\n/*********************************************************/\\nint Solution::findLengthOfLCIS(vector<int>& nums) {\\n    int maxLength=1, length=1, i, size = nums.size();\\n    for (i = 1; i < size; ++i) {\\n        if (nums[i-1] < nums[i]) {\\n            ++length;\\n            if (length > maxLength) {\\n                maxLength = length;\\n            }\\n        } else {\\n            length = 1;\\n        }\\n    }\\n    return maxLength;\\n}\\n/*********************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349814,
                "title": "javascript-easy-single-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    increasing the counter by comparing elements in an array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncompare two elements nums[i] and nums[i-1], if i is greater we include it, so count++, if not we reset counter to 1 and count again for any better LCIS in the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function (nums) {\\n  let count = 1;\\n  let max = 1;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i - 1] < nums[i]) {\\n      count++;\\n    } else {\\n      count = 1;\\n    }\\n    max = Math.max(max, count);\\n  }\\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function (nums) {\\n  let count = 1;\\n  let max = 1;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i - 1] < nums[i]) {\\n      count++;\\n    } else {\\n      count = 1;\\n    }\\n    max = Math.max(max, count);\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089340,
                "title": "2-dp-approach-c-beats-95-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# 1st APPROACH: \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[10001];\\n    int solve(vector<int>& nums, int i, int n){\\n        if(i==n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int k=i;\\n        while(k<n-1 && nums[k]<nums[k+1]){\\n            k++;\\n        }\\n        int cnt1=k-i+1;\\n        int cnt2=solve(nums, k+1, n);\\n        \\n        return dp[i]=max(cnt1, cnt2);\\n    }\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(nums, 0, nums.size());\\n    }\\n};\\n```\\n# 2nd APPROACH: (TLE)\\n# Code\\n```\\nclass Solution {\\n    int solveTab(vector<int>& nums, int n){  \\n         vector<vector<int>> dp(n+1, vector<int> (n+1, 0));  \\n        int ans=0;\\n        for(int curr=n-1; curr>=0; curr--){\\n            for(int prev=curr-1; prev>=-1; prev--){\\n               if(prev==-1 || (nums[curr] > nums[prev]))\\n                    dp[curr][prev+1]=1+dp[curr+1][curr+1];\\n               \\n                ans=max(ans, dp[curr][prev+1]);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n  \\n    int findLengthOfLCIS(vector<int>& nums) {\\n        return solveTab(nums,nums.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10001];\\n    int solve(vector<int>& nums, int i, int n){\\n        if(i==n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int k=i;\\n        while(k<n-1 && nums[k]<nums[k+1]){\\n            k++;\\n        }\\n        int cnt1=k-i+1;\\n        int cnt2=solve(nums, k+1, n);\\n        \\n        return dp[i]=max(cnt1, cnt2);\\n    }\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(nums, 0, nums.size());\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int solveTab(vector<int>& nums, int n){  \\n         vector<vector<int>> dp(n+1, vector<int> (n+1, 0));  \\n        int ans=0;\\n        for(int curr=n-1; curr>=0; curr--){\\n            for(int prev=curr-1; prev>=-1; prev--){\\n               if(prev==-1 || (nums[curr] > nums[prev]))\\n                    dp[curr][prev+1]=1+dp[curr+1][curr+1];\\n               \\n                ans=max(ans, dp[curr][prev+1]);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n  \\n    int findLengthOfLCIS(vector<int>& nums) {\\n        return solveTab(nums,nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863469,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()<=1)return nums.size();\\n        int answer=1,count=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n                answer=max(answer,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()<=1)return nums.size();\\n        int answer=1,count=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n                answer=max(answer,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763468,
                "title": "two-simple-python-solutions",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        prev, cur, res = 0, 0, 0\\n        \\n        for n in nums:\\n            cur = cur + 1 if prev < n else 1\\n            res = max(res, cur)\\n            prev = n\\n\\n        return res\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n```\\n\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        \\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i-1] + dp[i]\\n        \\n        return max(dp)\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        prev, cur, res = 0, 0, 0\\n        \\n        for n in nums:\\n            cur = cur + 1 if prev < n else 1\\n            res = max(res, cur)\\n            prev = n\\n\\n        return res\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n```\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [1] * n\\n        \\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                dp[i] = dp[i-1] + dp[i]\\n        \\n        return max(dp)\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570263,
                "title": "rust-0-ms-linear-scan-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/798332889/) employs a simple loop to count the number of characters in the longest continuous increasing subsequence. It demonstrated **0 ms runtime (100.00%)** and used **2.0 MB memory (100.00%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 \\n    {\\n        let mut max_len : i32 = 0;\\n        let mut cur_len : i32 = 0;\\n        let mut prev    : i32 = -1_000_000_001;\\n        \\n        // [1] we keep track of current length \\'cur_len\\' of subsequence\\n\\t\\t//     and update \\'max_len\\' every time the continuous sequence is broken\\n        for n in nums\\n        {\\n            if n > prev { cur_len += 1; }\\n            else        { max_len = max_len.max(cur_len); cur_len = 1; }\\n            prev = n;\\n        }\\n        \\n        // [2] update \\'max_len\\' for the last continuous sequence\\n        max_len.max(cur_len)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 \\n    {\\n        let mut max_len : i32 = 0;\\n        let mut cur_len : i32 = 0;\\n        let mut prev    : i32 = -1_000_000_001;\\n        \\n        // [1] we keep track of current length \\'cur_len\\' of subsequence\\n\\t\\t//     and update \\'max_len\\' every time the continuous sequence is broken\\n        for n in nums\\n        {\\n            if n > prev { cur_len += 1; }\\n            else        { max_len = max_len.max(cur_len); cur_len = 1; }\\n            prev = n;\\n        }\\n        \\n        // [2] update \\'max_len\\' for the last continuous sequence\\n        max_len.max(cur_len)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2565636,
                "title": "clean-0ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int max =0;\\n        int count =0;\\n        \\n        for(int i=1; i<nums.length;i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                count++;\\n                max = Math.max(count , max);\\n            }\\n            else\\n                count =0;\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int max =0;\\n        int count =0;\\n        \\n        for(int i=1; i<nums.length;i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                count++;\\n                max = Math.max(count , max);\\n            }\\n            else\\n                count =0;\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545784,
                "title": "easy-to-understand",
                "content": "```\\n    int findLengthOfLCIS(vector<int>& nums) \\n    {\\n        int mx=0;\\n        int n=nums.size();\\n        int count=1;\\n        int i=0,j=1;\\n        if(n==1) return 1;\\n        \\n        while(j<n)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n                mx=max(mx,count);\\n            }\\n            else\\n            {\\n                mx=max(mx,count);\\n                count=1;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int findLengthOfLCIS(vector<int>& nums) \\n    {\\n        int mx=0;\\n        int n=nums.size();\\n        int count=1;\\n        int i=0,j=1;\\n        if(n==1) return 1;\\n        \\n        while(j<n)\\n        {\\n            if(nums[i]<nums[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n                mx=max(mx,count);\\n            }\\n            else\\n            {\\n                mx=max(mx,count);\\n                count=1;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2526918,
                "title": "c-2-ways-brute-force-vs-optimal",
                "content": "```\\n/*\\n\\tBrute Force\\n*/\\nint findLengthOfLCIS(vector<int>& nums) {\\n\\tint ans = 1;\\n\\tint i = 0;\\n\\twhile(i < nums.size()) {\\n\\t\\tint m = 1;\\n\\t\\tfor (int j = i + 1; j < nums.size(); ++j) {\\n\\t\\t\\tif (nums[j] > nums[j - 1]) {\\n\\t\\t\\t\\tm++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans = max(ans, m);\\n\\t\\ti += m;\\n\\t}\\n\\treturn ans;\\n}\\n\\n/*\\n\\tOptimal\\n*/\\nint findLengthOfLCIS(vector<int>& nums) {\\n\\tint ans = 1;\\n\\tint count = 1;\\n\\tfor (int i = 1; i < nums.size(); ++i) {\\n\\t\\tif (nums[i] > nums[i - 1]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tans = max(ans, count);\\n\\t\\t} else {\\n\\t\\t\\tcount = 1;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n\\tBrute Force\\n*/\\nint findLengthOfLCIS(vector<int>& nums) {\\n\\tint ans = 1;\\n\\tint i = 0;\\n\\twhile(i < nums.size()) {\\n\\t\\tint m = 1;\\n\\t\\tfor (int j = i + 1; j < nums.size(); ++j) {\\n\\t\\t\\tif (nums[j] > nums[j - 1]) {\\n\\t\\t\\t\\tm++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans = max(ans, m);\\n\\t\\ti += m;\\n\\t}\\n\\treturn ans;\\n}\\n\\n/*\\n\\tOptimal\\n*/\\nint findLengthOfLCIS(vector<int>& nums) {\\n\\tint ans = 1;\\n\\tint count = 1;\\n\\tfor (int i = 1; i < nums.size(); ++i) {\\n\\t\\tif (nums[i] > nums[i - 1]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tans = max(ans, count);\\n\\t\\t} else {\\n\\t\\t\\tcount = 1;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2237415,
                "title": "fastest-java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int len=1,max=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n                len++;\\n            else\\n            {\\n                max=Math.max(len,max);\\n                len=1;\\n            }\\n        }\\n        return Math.max(max,len);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int len=1,max=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n                len++;\\n            else\\n            {\\n                max=Math.max(len,max);\\n                len=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2182572,
                "title": "java-1ms-easy-solution",
                "content": "\\t\\tint n=nums.length;\\n        int c=0;\\n        int maxx=0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i+1]>nums[i]){\\n                c++;\\n                maxx=Math.max(maxx,c);\\n            }else{\\n                c=0;\\n            }\\n        }\\n        return maxx+1;\\n",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "\\t\\tint n=nums.length;\\n        int c=0;\\n        int maxx=0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i+1]>nums[i]){\\n                c++;\\n                maxx=Math.max(maxx,c);\\n            }else{\\n                c=0;\\n            }\\n        }\\n        return maxx+1;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2168019,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int curr=1, ans=1;\\n        for(int i=1; i<nums.size(); ++i){\\n            if(nums[i]>nums[i-1]) ++curr;\\n            else curr=1;\\n            ans = max(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int curr=1, ans=1;\\n        for(int i=1; i<nums.size(); ++i){\\n            if(nums[i]>nums[i-1]) ++curr;\\n            else curr=1;\\n            ans = max(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060291,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans=0;\\n        int temp=1;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]>nums[i])\\n                temp++;\\n            else\\n            {  \\n                ans=max(ans,temp);\\n                temp=1;\\n            }\\n        }\\n        ans=max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans=0;\\n        int temp=1;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]>nums[i])\\n                temp++;\\n            else\\n            {  \\n                ans=max(ans,temp);\\n                temp=1;\\n            }\\n        }\\n        ans=max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885033,
                "title": "very-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count =1;\\n        int maxi =1;\\n        \\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i+1] > nums[i]){\\n                count++;\\n                maxi = max(maxi, count); \\n            }\\n            else{\\n                count =1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n// Upvote please if you like it.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count =1;\\n        int maxi =1;\\n        \\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i+1] > nums[i]){\\n                count++;\\n                maxi = max(maxi, count); \\n            }\\n            else{\\n                count =1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n// Upvote please if you like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800682,
                "title": "6-lines-solution-python-dp-self-explanantory",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len( nums)\\n        d = [1 for i in range (n)]\\n        for i in range (1,n):\\n            if nums[i] > nums[i-1]:\\n                d[i] += d[i-1]\\n        return max(d) \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        n = len( nums)\\n        d = [1 for i in range (n)]\\n        for i in range (1,n):\\n            if nums[i] > nums[i-1]:\\n                d[i] += d[i-1]\\n        return max(d) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793680,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n         int ans = 1;\\n         int n = nums.size();\\n         if(n == 1) return 1;\\n        \\n         int i=0, j = 1;\\n         while( j < n ){\\n             if(nums[j] > nums[j-1]){\\n                 ans = max(ans, (j - i + 1));\\n                 j++;\\n             }\\n             else{\\n                 i = j;\\n                 j++;\\n             }\\n         }\\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n         int ans = 1;\\n         int n = nums.size();\\n         if(n == 1) return 1;\\n        \\n         int i=0, j = 1;\\n         while( j < n ){\\n             if(nums[j] > nums[j-1]){\\n                 ans = max(ans, (j - i + 1));\\n                 j++;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1744859,
                "title": "o-n-time-and-o-1-space-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int result=0;\\n        int curr = nums[0];\\n        int count=1;\\n        if(nums.size()==1)\\n            return 1;\\n        if(nums.size()==0)\\n            return 0;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i]>curr)\\n                count+=1;\\n            else\\n                count=1;\\n            result = max(count,result);\\n            curr = nums[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int result=0;\\n        int curr = nums[0];\\n        int count=1;\\n        if(nums.size()==1)\\n            return 1;\\n        if(nums.size()==0)\\n            return 0;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i]>curr)\\n                count+=1;\\n            else\\n                count=1;\\n            result = max(count,result);\\n            curr = nums[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646129,
                "title": "rust-windows",
                "content": "```\\npub struct Solution {}\\n\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        let mut max = 0;\\n        let accum = nums\\n            .windows(2)\\n            .fold(1, |accum, w| {\\n                if w[0] < w[1] {\\n                    accum + 1\\n                } else {\\n                    if accum > max {\\n                        max = accum;\\n                    }\\n                    1\\n                }\\n            });\\n\\n        max.max(accum)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test() {\\n        assert_eq!(3, Solution::find_length_of_lcis(vec![1,3,5,4,7]));\\n        assert_eq!(1, Solution::find_length_of_lcis(vec![1]));\\n        assert_eq!(4, Solution::find_length_of_lcis(vec![4,3,1,2,3,4]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub struct Solution {}\\n\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        let mut max = 0;\\n        let accum = nums\\n            .windows(2)\\n            .fold(1, |accum, w| {\\n                if w[0] < w[1] {\\n                    accum + 1\\n                } else {\\n                    if accum > max {\\n                        max = accum;\\n                    }\\n                    1\\n                }\\n            });\\n\\n        max.max(accum)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test() {\\n        assert_eq!(3, Solution::find_length_of_lcis(vec![1,3,5,4,7]));\\n        assert_eq!(1, Solution::find_length_of_lcis(vec![1]));\\n        assert_eq!(4, Solution::find_length_of_lcis(vec![4,3,1,2,3,4]));\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597437,
                "title": "best-solution-c",
                "content": "class Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>cnt(n,1);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                cnt[i]=cnt[i-1]+1;\\n            }\\n            ans=max(ans,cnt[i]);\\n        }\\n        return ans;\\n    }\\n};\\n//PLEASE UPVOTE",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>cnt(n,1);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n            {\\n                cnt[i]=cnt[i-1]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1557653,
                "title": "c-98-89-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        \\n            int count = 0, i= 0, maxa=INT_MIN;\\n        \\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n               if(j == nums.size()-1)\\n               {\\n                   count = j-i+1;\\n               }\\n               else if(nums[j] >= nums[j+1])\\n               {\\n                   count = j - i + 1;\\n                   i = j+1;\\n               }\\n               maxa =max(maxa, count);\\n            }\\n        return maxa;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        \\n            int count = 0, i= 0, maxa=INT_MIN;\\n        \\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n               if(j == nums.size()-1)\\n               {\\n                   count = j-i+1;\\n               }\\n               else if(nums[j] >= nums[j+1])\\n               {\\n                   count = j - i + 1;\\n                   i = j+1;\\n               }\\n               maxa =max(maxa, count);\\n            }\\n        return maxa;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540177,
                "title": "using-sliding-window-of-dynamic-size-easy-c-better-than-99-in-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int i = 0;\\n        int ml = 1;\\n        int j = 1;\\n        for(j;j<nums.size();j++){\\n            if(nums[j]<=nums[j-1]){\\n                ml = max(ml,j-i);\\n                i= j;\\n            }\\n        }\\n        if(nums[j-1]>nums[i])\\n            ml = max(ml,j-i);\\n        return ml;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int i = 0;\\n        int ml = 1;\\n        int j = 1;\\n        for(j;j<nums.size();j++){\\n            if(nums[j]<=nums[j-1]){\\n                ml = max(ml,j-i);\\n                i= j;\\n            }\\n        }\\n        if(nums[j-1]>nums[i])\\n            ml = max(ml,j-i);\\n        return ml;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477660,
                "title": "easy-java-solution-one-pass-on-time-o1-space",
                "content": "```\\nclass Solution {\\n  public int findLengthOfLCIS(int[] nums) {\\n    int res = 0, temp = 1;\\n\\n    for (int i = 1; i < nums.length; i++) {\\n      int curr = nums[i];\\n      int prev = nums[i-1];\\n\\n      if (prev < curr) {\\n        temp++;\\n      } else {\\n        res = Math.max(res, temp);\\n        temp = 1;\\n      }\\n    }\\n    return  Math.max(res, temp);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int findLengthOfLCIS(int[] nums) {\\n    int res = 0, temp = 1;\\n\\n    for (int i = 1; i < nums.length; i++) {\\n      int curr = nums[i];\\n      int prev = nums[i-1];\\n\\n      if (prev < curr) {\\n        temp++;\\n      } else {\\n        res = Math.max(res, temp);\\n        temp = 1;\\n      }\\n    }\\n    return  Math.max(res, temp);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470624,
                "title": "python3-solution",
                "content": "\\'\\'\\'\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        msf = 0  # maxim so far\\n        meh = 1  # maxim ending here\\n        n = len(nums)\\n        if n == 1: return 1\\n        last = nums[0]\\n        for i in range(1, n):\\n            if nums[i] > last:\\n                last = nums[i]\\n                meh += 1\\n            else:\\n                meh = 1\\n                last = nums[i] \\n            if msf < meh:\\n                msf = meh\\n        return msf\\n                \\n```\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        msf = 0  # maxim so far\\n        meh = 1  # maxim ending here\\n        n = len(nums)\\n        if n == 1: return 1\\n        last = nums[0]\\n        for i in range(1, n):\\n            if nums[i] > last:\\n                last = nums[i]\\n                meh += 1\\n            else:\\n                meh = 1\\n                last = nums[i] \\n            if msf < meh:\\n                msf = meh\\n        return msf\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469705,
                "title": "python3-stack-fast-easy-solution",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        stack = [nums[0]]\\n        ret = 1\\n        for i in range(1, len(nums)):\\n            if stack and stack[-1] >= nums[i]: stack.clear()\\n            stack.append(nums[i])\\n            ret = max(ret, len(stack))\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        stack = [nums[0]]\\n        ret = 1\\n        for i in range(1, len(nums)):\\n            if stack and stack[-1] >= nums[i]: stack.clear()\\n            stack.append(nums[i])\\n            ret = max(ret, len(stack))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467381,
                "title": "c-o-n-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count = 1, res = 1;\\n        \\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] > nums[i-1])\\n                count++;\\n            else{\\n                res = max(res, count);\\n                count = 1;\\n            }\\n        }\\n        \\n        res = max(count, res);\\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvote if my solution helped !!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count = 1, res = 1;\\n        \\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] > nums[i-1])\\n                count++;\\n            else{\\n                res = max(res, count);\\n                count = 1;\\n            }\\n        }\\n        \\n        res = max(count, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405855,
                "title": "python-solution-faster-o-n",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) <= 1:\\n            return len(nums)\\n        \\n        so_far_longest = 1\\n        current_longest = 1\\n        for i in xrange(1, len(nums)):\\n            if nums[i-1] < nums[i]:\\n                current_longest +=1\\n            else:\\n                current_longest = 1\\n            so_far_longest = max(so_far_longest, current_longest)\\n\\n        return so_far_longest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) <= 1:\\n            return len(nums)\\n        \\n        so_far_longest = 1\\n        current_longest = 1\\n        for i in xrange(1, len(nums)):\\n            if nums[i-1] < nums[i]:\\n                current_longest +=1\\n            else:\\n                current_longest = 1\\n            so_far_longest = max(so_far_longest, current_longest)\\n\\n        return so_far_longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399272,
                "title": "c-simple-solution",
                "content": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp(n , 1);\\n        for(int i=1 ; i<n  ; i++){\\n            dp[i]=nums[i]>nums[i-1]?dp[i-1]+dp[i]:dp[i];\\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp(n , 1);\\n        for(int i=1 ; i<n  ; i++){\\n            dp[i]=nums[i]>nums[i-1]?dp[i-1]+dp[i]:dp[i];\\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392045,
                "title": "python-simplest-solution",
                "content": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tmaxSub = 1\\n\\ttempSub = 1\\n\\tfor i in range(len(nums)-1): \\n\\t\\tif nums[i] < nums[i+1]: \\n\\t\\t\\ttempSub +=1 \\n\\t\\telse: \\n\\t\\t\\tmaxSub = max(maxSub,tempSub)\\n\\t\\t\\ttempSub = 1\\n\\treturn max(maxSub,tempSub)\\n```",
                "solutionTags": [],
                "code": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tmaxSub = 1\\n\\ttempSub = 1\\n\\tfor i in range(len(nums)-1): \\n\\t\\tif nums[i] < nums[i+1]: \\n\\t\\t\\ttempSub +=1 \\n\\t\\telse: \\n\\t\\t\\tmaxSub = max(maxSub,tempSub)\\n\\t\\t\\ttempSub = 1\\n\\treturn max(maxSub,tempSub)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1388944,
                "title": "python-simple-solution-0-n",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        first = nums[0]\\n        curC = 1\\n        maxC = curC\\n        for i in range(1, len(nums)):\\n          if nums[i] > first: curC += 1\\n          else: curC = 1\\n          first = nums[i]\\n          maxC = max(maxC, curC)\\n          \\n        return maxC\\n          \\n          \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        first = nums[0]\\n        curC = 1\\n        maxC = curC\\n        for i in range(1, len(nums)):\\n          if nums[i] > first: curC += 1\\n          else: curC = 1\\n          first = nums[i]\\n          maxC = max(maxC, curC)\\n          \\n        return maxC\\n          \\n          \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337511,
                "title": "rust-with-fold-0ms-and-simple-recursive-racket",
                "content": "Rust:\\n```rust\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        nums.iter().skip(1).fold((nums[0], 1, 1), |(prev, acc, max), i| {\\n            let acc = if *i > prev { acc + 1 } else { 1 };\\n            (*i, acc, acc.max(max))\\n        }).2\\n    }\\n}\\n```\\nRacket:\\n```scheme\\n(define/contract (find-length-of-lcis nums)\\n  (-> (listof exact-integer?) exact-integer?)\\n  (letrec ([go (lambda (xs prev acc max-so-far)\\n                 (cond [(null? xs) (max acc max-so-far)]\\n                       [(<= (car xs) prev) (go (cdr xs) (car xs) 1 (max acc max-so-far))]\\n                       [else (go (cdr xs) (car xs) (+ acc 1) max-so-far)]))])\\n    (go (cdr nums) (car nums) 1 1))\\n  )\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        nums.iter().skip(1).fold((nums[0], 1, 1), |(prev, acc, max), i| {\\n            let acc = if *i > prev { acc + 1 } else { 1 };\\n            (*i, acc, acc.max(max))\\n        }).2\\n    }\\n}\\n```\n```scheme\\n(define/contract (find-length-of-lcis nums)\\n  (-> (listof exact-integer?) exact-integer?)\\n  (letrec ([go (lambda (xs prev acc max-so-far)\\n                 (cond [(null? xs) (max acc max-so-far)]\\n                       [(<= (car xs) prev) (go (cdr xs) (car xs) 1 (max acc max-so-far))]\\n                       [else (go (cdr xs) (car xs) (+ acc 1) max-so-far)]))])\\n    (go (cdr nums) (car nums) 1 1))\\n  )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266954,
                "title": "python-easy-o-n-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef findLengthOfLCIS(self, nums):\\n\\t\\t\\tcount=1\\n\\t\\t\\tmaxi=1\\n\\t\\t\\tfor i in range(1,len(nums)):\\n\\t\\t\\t\\tif(nums[i]>nums[i-1]):\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcount=1\\n\\t\\t\\t\\tmaxi=max(maxi,count)\\n\\n\\t\\t\\treturn maxi\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef findLengthOfLCIS(self, nums):\\n\\t\\t\\tcount=1\\n\\t\\t\\tmaxi=1\\n\\t\\t\\tfor i in range(1,len(nums)):\\n\\t\\t\\t\\tif(nums[i]>nums[i-1]):\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcount=1\\n\\t\\t\\t\\tmaxi=max(maxi,count)\\n\\n\\t\\t\\treturn maxi\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1256674,
                "title": "one-pass-sliding-window-simple-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        if(nums.length==1)return 1;\\n        \\n        int start = 0;\\n        int end = 1;\\n        int max_so_far = 1;\\n        int max = 1;\\n        while(end<nums.length){\\n            if(nums[end]>nums[end-1]){\\n                max =Math.max(max,(end-start+1));\\n            }else{\\n                max = 1;\\n                start = end;\\n            }\\n            ++end;\\n            max_so_far = Math.max(max_so_far,max);\\n        }\\n        return max_so_far;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        if(nums.length==1)return 1;\\n        \\n        int start = 0;\\n        int end = 1;\\n        int max_so_far = 1;\\n        int max = 1;\\n        while(end<nums.length){\\n            if(nums[end]>nums[end-1]){\\n                max =Math.max(max,(end-start+1));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1256099,
                "title": "faster-code-easy",
                "content": "**Do upvote if you like it :)**\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count = 1;\\n        int res = 1;\\n        for(int i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] > nums[i-1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n            res = max(res , count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count = 1;\\n        int res = 1;\\n        for(int i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] > nums[i-1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n            res = max(res , count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238061,
                "title": "python-3-noob-solution-easy-97-68-fast",
                "content": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tk=1\\n\\tli=[]\\n\\tfor i in range(0,len(nums)):\\n\\t\\tif i==len(nums)-1:\\n\\t\\t\\tli.append(k)\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tif nums[i]<nums[i+1]:\\n\\t\\t\\t\\tk+=1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telse:\\n\\t\\t\\t\\tli.append(k)\\n\\t\\t\\t\\tk=1\\n\\t\\t\\t\\tcontinue\\n\\tmax=-1\\n\\tfor i in li:\\n\\t\\tif max<i:\\n\\t\\t\\tmax=i\\n\\treturn max\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tk=1\\n\\tli=[]\\n\\tfor i in range(0,len(nums)):\\n\\t\\tif i==len(nums)-1:\\n\\t\\t\\tli.append(k)\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tif nums[i]<nums[i+1]:\\n\\t\\t\\t\\tk+=1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telse:\\n\\t\\t\\t\\tli.append(k)\\n\\t\\t\\t\\tk=1\\n\\t\\t\\t\\tcontinue\\n\\tmax=-1\\n\\tfor i in li:\\n\\t\\tif max<i:\\n\\t\\t\\tmax=i\\n\\treturn max\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1213844,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int count = 1;\\n        int max = 1;\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i -1]){\\n                count++;\\n            }else{   \\n                count = 1;\\n            }\\n            max = Math.max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int count = 1;\\n        int max = 1;\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i -1]){\\n                count++;\\n            }else{   \\n                count = 1;\\n            }\\n            max = Math.max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202497,
                "title": "c-clean-solution",
                "content": "class Solution {\\npublic:\\n*     int findLengthOfLCIS(vector<int>& nums) {\\n        int maxm , cnt;\\n\\t\\tmaxm  = cnt = 1;\\n        for(int i=1; i<nums.size(); i++) {\\n\\t\\t\\tcnt = (nums[i] > nums[i-1]) ? ++cnt : 1;\\n\\t\\t\\tmaxm = max(cnt, maxm);\\n        }\\n        return maxm;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n*     int findLengthOfLCIS(vector<int>& nums) {\\n        int maxm , cnt;\\n\\t\\tmaxm  = cnt = 1;\\n        for(int i=1; i<nums.size(); i++) {\\n\\t\\t\\tcnt = (nums[i] > nums[i-1]) ? ++cnt : 1;\\n\\t\\t\\tmaxm = max(cnt, maxm);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1142338,
                "title": "python-3-easy-solution",
                "content": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tl = len(nums)\\n\\tres = 0\\n\\ti = 0\\n\\n\\twhile i<l:\\n\\t\\tj = i+1\\n\\n\\t\\twhile j<l and nums[j]>nums[j-1]:\\n\\t\\t\\tj+=1\\n\\t\\tres = max(res, j-i)\\n\\t\\ti = j\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findLengthOfLCIS(self, nums: List[int]) -> int:\\n\\tl = len(nums)\\n\\tres = 0\\n\\ti = 0\\n\\n\\twhile i<l:\\n\\t\\tj = i+1\\n\\n\\t\\twhile j<l and nums[j]>nums[j-1]:\\n\\t\\t\\tj+=1\\n\\t\\tres = max(res, j-i)\\n\\t\\ti = j\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1087180,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int result = 1;\\n        int count = 1;\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i-1])  count++;\\n            else    count = 1;\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int result = 1;\\n        int count = 1;\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] > nums[i-1])  count++;\\n            else    count = 1;\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048476,
                "title": "java-simple-o-n-faster-than-100",
                "content": "```java\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int length = nums.length;\\n        if (length <= 1) return length;\\n        \\n        int curMax = 1;\\n        int max = 1;\\n        \\n        for (int i = 0; i < length - 1; i++) {\\n            if (nums[i] < nums[i + 1]) {\\n                curMax++;\\n                \\n                if (curMax > max) {\\n                   max = curMax; \\n                }\\n            } else {\\n                curMax = 1;\\n            }\\n        }\\n        \\n        if (curMax > max) {\\n            max = curMax;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int length = nums.length;\\n        if (length <= 1) return length;\\n        \\n        int curMax = 1;\\n        int max = 1;\\n        \\n        for (int i = 0; i < length - 1; i++) {\\n            if (nums[i] < nums[i + 1]) {\\n                curMax++;\\n                \\n                if (curMax > max) {\\n                   max = curMax; \\n                }\\n            } else {\\n                curMax = 1;\\n            }\\n        }\\n        \\n        if (curMax > max) {\\n            max = curMax;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977461,
                "title": "java-5-liner",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tint result = 0, currentCount = 0;\\n\\tfor (int i=0;i<nums.length;i++) {\\n\\t\\tcurrentCount = (i==0 || nums[i] > nums[i-1]) ? currentCount + 1 : 1;\\n\\t\\tresult = Math.max(result, currentCount);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tint result = 0, currentCount = 0;\\n\\tfor (int i=0;i<nums.length;i++) {\\n\\t\\tcurrentCount = (i==0 || nums[i] > nums[i-1]) ? currentCount + 1 : 1;\\n\\t\\tresult = Math.max(result, currentCount);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917208,
                "title": "java-beats-99-6",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        if(nums.length == 0) return 0;\\n        \\n        int length = 1;\\n        int maxLength = 1;\\n        \\n        for (int i=1; i<nums.length; i++) {\\n            \\n            if (nums[i] > nums[i-1]) length++;\\n            else length = 1;\\n            \\n            if(length > maxLength) maxLength = length;\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        if(nums.length == 0) return 0;\\n        \\n        int length = 1;\\n        int maxLength = 1;\\n        \\n        for (int i=1; i<nums.length; i++) {\\n            \\n            if (nums[i] > nums[i-1]) length++;\\n            else length = 1;\\n            \\n            if(length > maxLength) maxLength = length;\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884630,
                "title": "python-64ms-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if nums==[]:\\n            return 0\\n        mc=0\\n        c=1 \\n        v=nums[0]\\n        for i in nums[1:]:\\n            if i>v:\\n                v=i \\n                c+=1 \\n            else:\\n                mc=max(mc,c)\\n                v=i\\n                c=1\\n        return max(mc,c)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if nums==[]:\\n            return 0\\n        mc=0\\n        c=1 \\n        v=nums[0]\\n        for i in nums[1:]:\\n            if i>v:\\n                v=i \\n                c+=1 \\n            else:\\n                mc=max(mc,c)\\n                v=i\\n                c=1\\n        return max(mc,c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881811,
                "title": "simple-c-solution-99-15-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count=0;\\n        int maxCount=0;\\n        if(nums.size()<=1) return nums.size();\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n            }\\n            else\\n                count=0;\\n            maxCount = max(maxCount,count);\\n        }\\n        return maxCount+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count=0;\\n        int maxCount=0;\\n        if(nums.size()<=1) return nums.size();\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                count++;\\n            }\\n            else\\n                count=0;\\n            maxCount = max(maxCount,count);\\n        }\\n        return maxCount+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879766,
                "title": "kotlin-greedy-is-good",
                "content": "Solution - [github](https://github.com/An7One/leetcode-solutions-kotlin-an7one/tree/main/src/main/kotlin/com/an7one/leetcode/lvl2/lc0674)\\n\\n<b>By Tag</b>\\n#Subsequence - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/dynamic_programming/by_topic/subsequence)\\n\\n```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/longest-continuous-increasing-subsequence/\\n *\\n * Time Complexity:     O(`nNums`)\\n * Space Complexity:    O(1)\\n *\\n * Reference:\\n * https://leetcode.com/problems/longest-continuous-increasing-subsequence/discuss/107365/JavaC%2B%2BClean-solution\\n */\\nclass Solution {\\n    fun findLengthOfLCIS(nums: IntArray): Int {\\n        // sanity check\\n        if(nums.isEmpty()) return 0\\n        \\n        val nNums = nums.size\\n        \\n        var longest = 1\\n        var len = 1\\n        \\n        for(i in 1 until nNums){\\n            if(i == 0 || nums[i - 1] < nums[i]){\\n                longest = maxOf(longest, ++len)\\n            }else{\\n                len = 1\\n            }\\n        }\\n        \\n        return longest\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/longest-continuous-increasing-subsequence/\\n *\\n * Time Complexity:     O(`nNums`)\\n * Space Complexity:    O(1)\\n *\\n * Reference:\\n * https://leetcode.com/problems/longest-continuous-increasing-subsequence/discuss/107365/JavaC%2B%2BClean-solution\\n */\\nclass Solution {\\n    fun findLengthOfLCIS(nums: IntArray): Int {\\n        // sanity check\\n        if(nums.isEmpty()) return 0\\n        \\n        val nNums = nums.size\\n        \\n        var longest = 1\\n        var len = 1\\n        \\n        for(i in 1 until nNums){\\n            if(i == 0 || nums[i - 1] < nums[i]){\\n                longest = maxOf(longest, ++len)\\n            }else{\\n                len = 1\\n            }\\n        }\\n        \\n        return longest\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861131,
                "title": "java-dp-solution-o-n-time-complexity-o-1-space-complexity",
                "content": "The idea is straightforward, we use a variable `max_length` to track longest continuous increasing subsequence ending at `nums[i]`(inclusive) . To update `max_length`, there has 2 sceanarios:\\n1. If `nums[i-1]` < `nums[i]`,  we use previous `max_length` at `i-1` and add 1 to it as current `max_length` at index `i`.\\n2. If `nums[i-1]` >= `nums[i]`, the `max_length` at index `i` is just itself, which means 1.\\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n        int l = nums.length;\\n        if(l <= 1) return l;\\n        int res = 1;\\n        int max_length = 1;\\n        for(int i=1; i<l; i++) {\\n            max_length = nums[i] > nums[i-1] ? max_length + 1 : 1;\\n            res = Math.max(res, max_length);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        int l = nums.length;\\n        if(l <= 1) return l;\\n        int res = 1;\\n        int max_length = 1;\\n        for(int i=1; i<l; i++) {\\n            max_length = nums[i] > nums[i-1] ? max_length + 1 : 1;\\n            res = Math.max(res, max_length);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859540,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums):\\n\\t    \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n      count = 1\\n      max_len = 1\\n      if len(nums) == 0:\\n        return 0\\n      for i in range(len(nums)-1):\\n        if nums[i] < nums[i+1]:\\n          count+=1\\n          max_len = max(max_len, count)\\n        else:\\n          max_len = max(max_len, count)\\n          count = 1    \\n      return max_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums):\\n\\t    \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n      count = 1\\n      max_len = 1\\n      if len(nums) == 0:\\n        return 0\\n      for i in range(len(nums)-1):\\n        if nums[i] < nums[i+1]:\\n          count+=1\\n          max_len = max(max_len, count)\\n        else:\\n          max_len = max(max_len, count)\\n          count = 1    \\n      return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858026,
                "title": "easy-simple-cpp-easy-to-understand-simple-intiutive",
                "content": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==1 || nums.size()==0)\\n            return nums.size();\\n        int count=0;\\n        int max=INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                count++;\\n            else\\n                count=0;\\n            if(max<count)\\n                max=count;\\n        }\\n        return max+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==1 || nums.size()==0)\\n            return nums.size();\\n        int count=0;\\n        int max=INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                count++;\\n            else\\n                count=0;\\n            if(max<count)\\n                max=count;\\n        }\\n        return max+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854613,
                "title": "python-simple-and-easy-to-understand-approx-99",
                "content": "~64ms Speed (~ 99% faster)\\n\\n```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if len(nums) <= 1:\\n            return len(nums)\\n        maxi = 1\\n        cnt = 1\\n        prev = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i] > prev:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            maxi = max(maxi,cnt)\\n            prev = nums[i]\\n        return maxi\\n                \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if len(nums) <= 1:\\n            return len(nums)\\n        maxi = 1\\n        cnt = 1\\n        prev = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i] > prev:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            maxi = max(maxi,cnt)\\n            prev = nums[i]\\n        return maxi\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 844191,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums.length==0) return 0;\\n        \\n        int current =1;\\n        int maxLength = 1;\\n\\n        // expand the length of window by 1, and reset it back to 1 if found a small number\\n        for (int i=1; i < nums.length; i++){\\n            if (nums[i-1]>=nums[i])\\n                {current =1;}\\n            else\\n            {   current +=1;\\n                maxLength = Math.max(current, maxLength);}\\n        }\\n        return maxLength;\\n\\n    }\\n}\\n\\n```\\n# \\u53E6\\u5916\\u4E00\\u4E2ASliding Window \\u7684\\u95EE\\u9898\\uFF1Aquestion #346\\n# 346\\tMoving Average from Data Stream    \\n\\n```\\nclass MovingAverage {\\n    int mysize;\\n    int[] mylist;\\n    int mysum = 0;\\n     int count = 0;\\n\\n    /** Initialize your data structure here. */\\n    public MovingAverage(int size) {\\n        mysize = size;\\n        mylist = new int[size];\\n\\n    }\\n    \\n    public double next(int val) {\\n        count +=1;\\n        int index = count % mysize;\\n        mysum = mysum - mylist[index]+val;\\n        mylist[index]=val;\\n        if (count < mysize) \\n            {return mysum * 1.0 / count;}\\n        else \\n            {return (mysum * 1.0 / mysize);}\\n\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums.length==0) return 0;\\n        \\n        int current =1;\\n        int maxLength = 1;\\n\\n        // expand the length of window by 1, and reset it back to 1 if found a small number\\n        for (int i=1; i < nums.length; i++){\\n            if (nums[i-1]>=nums[i])\\n                {current =1;}\\n            else\\n            {   current +=1;\\n                maxLength = Math.max(current, maxLength);}\\n        }\\n        return maxLength;\\n\\n    }\\n}\\n\\n```\n```\\nclass MovingAverage {\\n    int mysize;\\n    int[] mylist;\\n    int mysum = 0;\\n     int count = 0;\\n\\n    /** Initialize your data structure here. */\\n    public MovingAverage(int size) {\\n        mysize = size;\\n        mylist = new int[size];\\n\\n    }\\n    \\n    public double next(int val) {\\n        count +=1;\\n        int index = count % mysize;\\n        mysum = mysum - mylist[index]+val;\\n        mylist[index]=val;\\n        if (count < mysize) \\n            {return mysum * 1.0 / count;}\\n        else \\n            {return (mysum * 1.0 / mysize);}\\n\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761294,
                "title": "100-faster-java-easy-solution",
                "content": "class Solution {\\n       public int findLengthOfLCIS(int[] nums) {\\n        \\n      if(nums.length==0)\\n         return 0;  \\n     \\n     int max=1,count=1;\\n     for(int i=1;i<nums.length;i++)\\n     {\\n        if(nums[i]<=nums[i-1])\\n        {\\n           if(count>max) \\n             max=count;\\n           count=1; \\n        }\\n         \\n        else\\n        count++;   \\n     }\\n        \\n      return max<count ? count : max;  \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n       public int findLengthOfLCIS(int[] nums) {\\n        \\n      if(nums.length==0)\\n         return 0;  \\n     \\n     int max=1,count=1;\\n     for(int i=1;i<nums.length;i++)\\n     {\\n        if(nums[i]<=nums[i-1])\\n        {\\n           if(count>max) \\n             max=count;\\n           count=1; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 742911,
                "title": "easiest-java-version-using-sliding-window",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        // edge case\\n        if(nums == null || nums.length == 0)\\n            return 0;\\n        \\n        int res = 1; // min longest subsequence length\\n        int curr = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i-1]) {\\n                curr++;\\n            }\\n            else {\\n                res = Math.max(res, curr);\\n                curr = 1;\\n            }            \\n        }\\n        \\n        res = Math.max(res, curr);\\n        return res;\\n    }\\n}\\n\\n```\\n\\n// Time complexity: O(N)\\n// Space complexity: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        // edge case\\n        if(nums == null || nums.length == 0)\\n            return 0;\\n        \\n        int res = 1; // min longest subsequence length\\n        int curr = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i-1]) {\\n                curr++;\\n            }\\n            else {\\n                res = Math.max(res, curr);\\n                curr = 1;\\n            }            \\n        }\\n        \\n        res = Math.max(res, curr);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738650,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        largest = count = 1\\n        if len(nums) == 0:\\n            return 0   \\n        for idx in range(len(nums) - 1):\\n            if nums[idx] < nums[idx+1]:\\n                count += 1\\n                if count > largest:\\n                    largest = count\\n            else:\\n                count = 1\\n        return largest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        largest = count = 1\\n        if len(nums) == 0:\\n            return 0   \\n        for idx in range(len(nums) - 1):\\n            if nums[idx] < nums[idx+1]:\\n                count += 1\\n                if count > largest:\\n                    largest = count\\n            else:\\n                count = 1\\n        return largest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672341,
                "title": "idiomatic-simple-rust",
                "content": "* Handle edge cases.\\n* Cache previous value.\\n* Iterate over values from second entry for bootstrapping cache.\\n\\n```\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        if nums.len() < 2 {\\n            return nums.len() as i32;\\n        }\\n        let mut longest = 1;\\n        let mut current = 1;\\n        let mut previous_val = nums[0];\\n        for n in nums.iter().skip(1) {\\n            if *n > previous_val {\\n                current += 1;            \\n            } else {\\n                current = 1;\\n            }\\n            longest = std::cmp::max(longest, current);\\n            previous_val = *n;\\n        }\\n        longest\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_length_of_lcis(nums: Vec<i32>) -> i32 {\\n        if nums.len() < 2 {\\n            return nums.len() as i32;\\n        }\\n        let mut longest = 1;\\n        let mut current = 1;\\n        let mut previous_val = nums[0];\\n        for n in nums.iter().skip(1) {\\n            if *n > previous_val {\\n                current += 1;            \\n            } else {\\n                current = 1;\\n            }\\n            longest = std::cmp::max(longest, current);\\n            previous_val = *n;\\n        }\\n        longest\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672251,
                "title": "c-cpp-sliding-window-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        int left=0;\\n        int right=0;\\n        int maxi = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1]){right++;}\\n            else{\\n                maxi = max(right-left+1,maxi);\\n                left = i;\\n                right = i;\\n            }\\n        }\\n        maxi = max(right-left+1,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        int left=0;\\n        int right=0;\\n        int maxi = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>nums[i-1]){right++;}\\n            else{\\n                maxi = max(right-left+1,maxi);\\n                left = i;\\n                right = i;\\n            }\\n        }\\n        maxi = max(right-left+1,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655606,
                "title": "cpp-sol-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==0) return 0;\\n        int k=1,c=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]>0) c++;\\n            else\\n            {\\n                k=max(k,c);c=1;\\n            }\\n        }\\n         k=max(k,c);\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==0) return 0;\\n        int k=1,c=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]>0) c++;\\n            else\\n            {\\n                k=max(k,c);c=1;\\n            }\\n        }\\n         k=max(k,c);\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645918,
                "title": "c-dp",
                "content": "```\\nint findLengthOfLCIS( vector<int>& nums ) {\\n\\tint n = nums.size();\\n\\tif( n == 0 ) return 0;\\n\\n\\tvector<int> dp( n, 0 );\\n\\tdp[0] = 1;\\n\\n\\tint longest = 1;\\n\\tfor( int i=1; i < n; i++ ) {\\n\\t\\tif( nums[i] > nums[i-1] )\\n\\t\\t\\tdp[i] = dp[i-1] + 1;\\n\\t\\telse\\n\\t\\t\\tdp[i] = 1;\\n\\t\\tlongest = max( longest, dp[i] );\\n\\t}\\n\\treturn longest;\\n}\\n```\\n\\nThis can be further improved to use O(1) space. The else block can also be avoided.",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS( vector<int>& nums ) {\\n\\tint n = nums.size();\\n\\tif( n == 0 ) return 0;\\n\\n\\tvector<int> dp( n, 0 );\\n\\tdp[0] = 1;\\n\\n\\tint longest = 1;\\n\\tfor( int i=1; i < n; i++ ) {\\n\\t\\tif( nums[i] > nums[i-1] )\\n\\t\\t\\tdp[i] = dp[i-1] + 1;\\n\\t\\telse\\n\\t\\t\\tdp[i] = 1;\\n\\t\\tlongest = max( longest, dp[i] );\\n\\t}\\n\\treturn longest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 523059,
                "title": "easy-javascript-solution-1-pass-52ms",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n  let curr = 1;\\n  let max = 0;\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] < nums[i + 1]) curr++;\\n    if (curr > max) max = curr;\\n    if (nums[i] >= nums[i + 1]) curr = 1;\\n  }\\n  \\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n  let curr = 1;\\n  let max = 0;\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] < nums[i + 1]) curr++;\\n    if (curr > max) max = curr;\\n    if (nums[i] >= nums[i + 1]) curr = 1;\\n  }\\n  \\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502686,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums == null) {\\n            return 0;\\n        }\\n        if(nums.length <= 1) {\\n            return nums.length;\\n        }\\n        \\n        int maxSoFar = 1, maxCurr = 1;\\n        \\n        for(int i=1; i< nums.length; i++) {\\n            \\n            if(nums[i] > nums[i-1]){\\n                maxCurr++;\\n            } else {\\n                maxCurr = 1;\\n            }\\n            maxSoFar = Math.max(maxSoFar, maxCurr);\\n        }\\n        return maxSoFar;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums == null) {\\n            return 0;\\n        }\\n        if(nums.length <= 1) {\\n            return nums.length;\\n        }\\n        \\n        int maxSoFar = 1, maxCurr = 1;\\n        \\n        for(int i=1; i< nums.length; i++) {\\n            \\n            if(nums[i] > nums[i-1]){\\n                maxCurr++;\\n            } else {\\n                maxCurr = 1;\\n            }\\n            maxSoFar = Math.max(maxSoFar, maxCurr);\\n        }\\n        return maxSoFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485169,
                "title": "python-o-n-solution-faster-than-100",
                "content": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        maxx = 1\\n        cur = 1\\n        for i in range(1,len(nums)):\\n            if nums[i]> nums[i-1]:\\n                cur+=1\\n                maxx = max(cur,maxx)\\n            else:\\n                cur=1    \\n        return maxx\\n```\\n\\nSince the smallest increasing subsequence has lenght of 1, we start with this value.\\nWhen an element is bigger than the previous one, we increase the length of the current longest subsequence. \\nIf we encounter an element that doesnt obey the rule we set cur as 1.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLengthOfLCIS(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        maxx = 1\\n        cur = 1\\n        for i in range(1,len(nums)):\\n            if nums[i]> nums[i-1]:\\n                cur+=1\\n                maxx = max(cur,maxx)\\n            else:\\n                cur=1    \\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476274,
                "title": "go-solution-4ms-100-faster-100-memory-usage",
                "content": "// n - previous number (starts with math.MinInt32)\\n// cc - current count\\n// max - maximum increasing sub array size\\n/* \\n\\tCompare nums[i] with previous (n) and if previous value is smaller than current,\\n\\tincrement current count(cc) . If not, reset the current count(cc) to 1.\\n\\tIf max happens to be smaller than current count (cc) assign cc to max.\\n*/\\n\\t\\n```golang\\nfunc findLengthOfLCIS(nums []int) int {\\n\\tn, cc, max := math.MinInt32, 0, 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif n < nums[i] {\\n\\t\\t\\tcc++\\n\\t\\t} else if n >= nums[i] {\\n\\t\\t\\tcc = 1\\n\\t\\t}\\n\\t\\tif max < cc {\\n\\t\\t\\tmax = cc\\n\\t\\t}\\n\\t\\tn = nums[i]\\n\\t}\\n\\treturn max\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc findLengthOfLCIS(nums []int) int {\\n\\tn, cc, max := math.MinInt32, 0, 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif n < nums[i] {\\n\\t\\t\\tcc++\\n\\t\\t} else if n >= nums[i] {\\n\\t\\t\\tcc = 1\\n\\t\\t}\\n\\t\\tif max < cc {\\n\\t\\t\\tmax = cc\\n\\t\\t}\\n\\t\\tn = nums[i]\\n\\t}\\n\\treturn max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452536,
                "title": "java-o-n-solution-beats-100-time-memory",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums.length==0)return 0;\\n        int sum = 1;\\n        int current = 1;\\n        for (int i=1;i<nums.length;i++){\\n            if (nums[i]>nums[i-1])current++;\\n            else {\\n                sum=Math.max(sum, current);\\n                current=1;\\n            }\\n        }\\n        sum=Math.max(sum, current);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if (nums.length==0)return 0;\\n        int sum = 1;\\n        int current = 1;\\n        for (int i=1;i<nums.length;i++){\\n            if (nums[i]>nums[i-1])current++;\\n            else {\\n                sum=Math.max(sum, current);\\n                current=1;\\n            }\\n        }\\n        sum=Math.max(sum, current);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437811,
                "title": "5-lines-java-100-sliding-window",
                "content": "```\\n    public int findLengthOfLCIS(int[] nums) {\\n        int n = nums.length; \\n        if(n == 0) return n;        \\n        int i=0, j=0, max = 1;\\n        while(++i < n)\\n            if(nums[i-1] < nums[i]) max = Math.max(max, i-j+1);\\n            else j=i;                \\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findLengthOfLCIS(int[] nums) {\\n        int n = nums.length; \\n        if(n == 0) return n;        \\n        int i=0, j=0, max = 1;\\n        while(++i < n)\\n            if(nums[i-1] < nums[i]) max = Math.max(max, i-j+1);\\n            else j=i;                \\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 430855,
                "title": "simple-easy-to-understand-faster-javascript-submission",
                "content": "**Please do upvote this solution, this motivates me to write better posts\\uD83D\\uDE04**\\n\\n```\\nvar findLengthOfLCIS = function(nums) {\\n    let longest = 0,\\n        count = 0;\\n    let prev = -Infinity;\\n    for(let i of nums){\\n        if(i>prev){\\n            count++;\\n        }\\n        else{\\n            count = 1;\\n        }\\n        prev = i;\\n        longest = Math.max(longest, count)\\n    }\\n    return longest\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLengthOfLCIS = function(nums) {\\n    let longest = 0,\\n        count = 0;\\n    let prev = -Infinity;\\n    for(let i of nums){\\n        if(i>prev){\\n            count++;\\n        }\\n        else{\\n            count = 1;\\n        }\\n        prev = i;\\n        longest = Math.max(longest, count)\\n    }\\n    return longest\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359262,
                "title": "simple-java-dp-solution",
                "content": "The idea is similar to Maximum contagious subarray sum, here we maintain the max length found including index i;\\n\\n\\tdp[i] = (nums[i]>nums[i-1] ? dp[i-1] +1 : 1)\\n\\tSolution is max of all dp[i] , i belongs to 0->n\\n\\t\\n\\t`class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        int[] dp = new int[nums.length];\\n        \\n        if(nums.length==0)\\n            return 0;\\n        \\n        dp[0]=1;\\n        int max=1;\\n        \\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n                dp[i]=dp[i-1]+1;\\n            else\\n                dp[i]=1;\\n            max = Math.max(max,dp[i]);\\n        }\\n        return max;\\n    }\\n}`\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        int[] dp = new int[nums.length];\\n        \\n        if(nums.length==0)\\n            return 0;\\n        \\n        dp[0]=1;\\n        int max=1;\\n        \\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>nums[i-1])\\n                dp[i]=dp[i-1]+1;\\n            else\\n                dp[i]=1;\\n            max = Math.max(max,dp[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 351277,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        int count = 1;\\n        int sum = 1;\\n        int ini = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(ini<nums[i]){\\n                count++;\\n            }\\n            else{\\n                count = 1;\\n            }\\n            sum = Math.max(sum,count);\\n            ini = nums[i];\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 244256,
                "title": "faster-java-solution",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        if(nums.length == 0)\\n            return 0;\\n        int count = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0; i< nums.length - 1; i++)\\n        {\\n            if(nums[i+1] > nums[i])\\n                count++;\\n            else\\n                count = 1;\\n\\n            max = Math.max(max,count);\\n        }\\n        return Math.max(max,count);\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n        if(nums.length == 0)\\n            return 0;\\n        int count = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0; i< nums.length - 1; i++)\\n        {\\n            if(nums[i+1] > nums[i])\\n                count++;\\n            else\\n                count = 1;\\n\\n            max = Math.max(max,count);\\n        }\\n        return Math.max(max,count);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 243304,
                "title": "three-java-solutions-two-pointers-dp-optimized-dp",
                "content": "Two pointers. Time: O(n), Space: O(1)\\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint left = 0;\\n\\tint right = 1;\\n\\tint ans = 0;\\n\\twhile (right < nums.length) {\\n\\t\\tif (nums[right] <= nums[right - 1]) {\\n\\t\\t\\tans = Math.max(ans, right - left);\\n\\t\\t\\tleft = right;\\n\\t\\t}\\n\\t\\tright++;\\n\\t}\\n\\n\\tans = Math.max(ans, right - left);\\n\\n\\treturn ans;\\n}\\n```\\nDP, Time: O(n), Space: O(n)\\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = 1;\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tdp[i] = dp[i-1] + 1;\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = 1;\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < dp.length; i++) {\\n\\t\\tans = Math.max(ans, dp[i]);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\nOptimized DP, Time: O(n), Space: O(1)\\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint count = 1;\\n\\tint ans = 1;\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tans = Math.max(ans, count);\\n\\t\\t} else {\\n\\t\\t\\tcount = 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint left = 0;\\n\\tint right = 1;\\n\\tint ans = 0;\\n\\twhile (right < nums.length) {\\n\\t\\tif (nums[right] <= nums[right - 1]) {\\n\\t\\t\\tans = Math.max(ans, right - left);\\n\\t\\t\\tleft = right;\\n\\t\\t}\\n\\t\\tright++;\\n\\t}\\n\\n\\tans = Math.max(ans, right - left);\\n\\n\\treturn ans;\\n}\\n```\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = 1;\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tdp[i] = dp[i-1] + 1;\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = 1;\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < dp.length; i++) {\\n\\t\\tans = Math.max(ans, dp[i]);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\n```\\npublic int findLengthOfLCIS(int[] nums) {\\n\\tif (nums == null || nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint count = 1;\\n\\tint ans = 1;\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tif (nums[i] > nums[i-1]) {\\n\\t\\t\\tcount++;\\n\\t\\t\\tans = Math.max(ans, count);\\n\\t\\t} else {\\n\\t\\t\\tcount = 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235376,
                "title": "c-short-o-1-space-dp",
                "content": "Define `dp[i]` to be the length of the longest increasing subarray (LIS) ending at `nums[i]`. Initially, `dp[i] = 1`. For each `i > 0`, if `nums[i] > nums[i - 1]`, update `dp[i] = dp[i - 1] + 1`. Return the maximum value of `dp`.\\n\\nSince `dp[i]` only depends on `dp[i - 1]`, we can just use a single variable and update it. Another key point to make the codes clean is how to handle empty array.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0, l = 0; i < nums.size(); i++) {\\n            i && nums[i] > nums[i - 1] ? l++ : l = 1;\\n            ans = max(ans, l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0, l = 0; i < nums.size(); i++) {\\n            i && nums[i] > nums[i - 1] ? l++ : l = 1;\\n            ans = max(ans, l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202735,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int FindLengthOfLCIS(int[] nums) {\\n        if(nums.Length == 0) return 0;\\n\\t\\t\\n\\t\\tvar max = int.MinValue;\\n        \\n        var si = 0;\\n        \\n        for(var i = 1; i < nums.Length; i++){\\n            if(nums[i] > nums[i - 1]) continue;\\n            \\n            max = Math.Max(max, i - si);\\n            \\n            si = i;\\n        }\\n        \\n        max = Math.Max(max, nums.Length - si);\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindLengthOfLCIS(int[] nums) {\\n        if(nums.Length == 0) return 0;\\n\\t\\t\\n\\t\\tvar max = int.MinValue;\\n        \\n        var si = 0;\\n        \\n        for(var i = 1; i < nums.Length; i++){\\n            if(nums[i] > nums[i - 1]) continue;\\n            \\n            max = Math.Max(max, i - si);\\n            \\n            si = i;\\n        }\\n        \\n        max = Math.Max(max, nums.Length - si);\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187481,
                "title": "c-100",
                "content": "```\nint findLengthOfLCIS(int* nums, int numsSize) {\n    if (numsSize == 0)\n        return 0;\n    int longest = 0;\n    int continuous = 1;\n    for (int i = 1; i < numsSize; i++){\n        if (nums[i] > nums[i-1]){\n            ++continuous;\n        } else {\n            if (continuous > longest){\n                longest = continuous;\n            }\n            continuous = 1;\n        }\n    }\n    if (continuous > longest){\n        longest = continuous;\n    }\n    return longest;\n}\n```",
                "solutionTags": [],
                "code": "```\nint findLengthOfLCIS(int* nums, int numsSize) {\n    if (numsSize == 0)\n        return 0;\n    int longest = 0;\n    int continuous = 1;\n    for (int i = 1; i < numsSize; i++){\n        if (nums[i] > nums[i-1]){\n            ++continuous;\n        } else {\n            if (continuous > longest){\n                longest = continuous;\n            }\n            continuous = 1;\n        }\n    }\n    if (continuous > longest){\n        longest = continuous;\n    }\n    return longest;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186895,
                "title": "simple-java-100",
                "content": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n                if (nums.length==0) return 0;\\n        int max = 1;\\n        int count =1;\\n        for (int i = 1; i <nums.length ; i++) {\\n            if (nums[i] >nums[i-1]){\\n                count++;\\n                if (count>max){\\n                    max=count;\\n                }\\n            }else {\\n                count=1;\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findLengthOfLCIS(int[] nums) {\\n                if (nums.length==0) return 0;\\n        int max = 1;\\n        int count =1;\\n        for (int i = 1; i <nums.length ; i++) {\\n            if (nums[i] >nums[i-1]){\\n                count++;\\n                if (count>max){\\n                    max=count;\\n                }\\n            }else {\\n                count=1;\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 178688,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        crrcnt = 1\\n        fnlcnt =1\\n        if len(nums) == 0:\\n            return 0\\n        \\n        for i in range(0,len(nums)-1,1):\\n            if nums[i] < nums[i+1]:\\n                crrcnt = crrcnt + 1\\n            else:\\n                fnlcnt = max(crrcnt,fnlcnt)\\n                crrcnt = 1\\n            \\n        return max(fnlcnt,crrcnt)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        crrcnt = 1\\n        fnlcnt =1\\n        if len(nums) == 0:\\n            return 0\\n        \\n        for i in range(0,len(nums)-1,1):\\n            if nums[i] < nums[i+1]:\\n                crrcnt = crrcnt + 1\\n            else:\\n                fnlcnt = max(crrcnt,fnlcnt)\\n                crrcnt = 1\\n            \\n        return max(fnlcnt,crrcnt)",
                "codeTag": "Java"
            },
            {
                "id": 164524,
                "title": "python-super-simple-and-very-intuitive-also-beats-100-at-the-moment",
                "content": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return 1\\n        \\n        count = 1\\n        maxcount = 1\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i] > nums[i-1]:\\n                count+=1\\n            else:\\n                count = 1\\n            if count > maxcount:\\n                maxcount = count\\n        return maxcount\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return 1\\n        \\n        count = 1\\n        maxcount = 1\\n        \\n        for i in range(1,len(nums)):\\n            if nums[i] > nums[i-1]:\\n                count+=1\\n            else:\\n                count = 1\\n            if count > maxcount:\\n                maxcount = count\\n        return maxcount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150197,
                "title": "python-solution-beats-98-27ms",
                "content": "I have seen some solutions but since I have seen my solution is lesser lines of code and easier,I will post it here for reference.\\nThere is no need to have to while loops(according to me it is an additional overhead of maintenance and prone to bugs because of corner cases and boundary conditions)\\nWe keep two pointer `prev` , `cur_max` and `tot_val` . \\nInitially `prev` is the first element and we loop from first index to check increasing continuous pattern.\\nWhen the increasing subsequence breaks, we just update the `cur_max` to be 1 and continue.\\n\\n```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not nums:\\n            return 0\\n        \\n        prev = nums[0]\\n        cur_max = 1\\n        tot_val = 1\\n        \\n        for i in xrange(1,len(nums)):\\n            if nums[i] > prev:\\n                cur_max+=1\\n                tot_val = max(cur_max,tot_val)\\n            else:\\n                cur_max = 1\\n                \\n            prev = nums[i]\\n            \\n        return tot_val\\n\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not nums:\\n            return 0\\n        \\n        prev = nums[0]\\n        cur_max = 1\\n        tot_val = 1\\n        \\n        for i in xrange(1,len(nums)):\\n            if nums[i] > prev:\\n                cur_max+=1\\n                tot_val = max(cur_max,tot_val)\\n            else:\\n                cur_max = 1\\n                \\n            prev = nums[i]\\n            \\n        return tot_val\\n\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148838,
                "title": "java-3ms",
                "content": " public int findLengthOfLCIS(int[] nums) {\\n     int i=1;\\n    int j=0;\\n        \\n     int count=1;\\n        int max=Integer.MIN_VALUE;\\n        if(nums.length==0){\\n            return 0;\\n        }\\n       \\n     while(i<nums.length){\\n         if(nums[i]>nums[j]){\\n             count++;\\n             max=Math.max(max, count);\\n              i++;\\n             j++;\\n         } else {\\n             j=i;\\n             i++;\\n             count=1;\\n         }\\n    }  \\n        return max>0 ? max : 1;\\n    }",
                "solutionTags": [],
                "code": " public int findLengthOfLCIS(int[] nums) {\\n     int i=1;\\n    int j=0;\\n        \\n     int count=1;\\n        int max=Integer.MIN_VALUE;\\n        if(nums.length==0){\\n            return 0;\\n        }\\n       \\n     while(i<nums.length){\\n         if(nums[i]>nums[j]){\\n             count++;\\n             max=Math.max(max, count);\\n              i++;\\n             j++;\\n         } else {\\n             j=i;\\n             i++;\\n             count=1;\\n         }\\n    }  \\n        return max>0 ? max : 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 107346,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nint findLengthOfLCIS(int* nums, int numsSize) {\\n    if(numsSize==0)\\n    {\\n        return 0;\\n    }\\n    int temp=1;\\n    int result=1;\\n    for(int i=1;i<numsSize;i++)\\n    {\\n        if(nums[i]>nums[i-1])\\n        {temp++;}\\n        else\\n        {\\n            if(result<temp)\\n            {result=temp;}\\n            temp=1;\\n        }\\n    }    \\n    if(result<temp)\\n    {result=temp;}\\n    return result;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nint findLengthOfLCIS(int* nums, int numsSize) {\\n    if(numsSize==0)\\n    {\\n        return 0;\\n    }\\n    int temp=1;\\n    int result=1;\\n    for(int i=1;i<numsSize;i++)\\n    {\\n        if(nums[i]>nums[i-1])\\n        {temp++;}\\n        else\\n        {\\n            if(result<temp)\\n            {result=temp;}\\n            temp=1;\\n        }\\n    }    \\n    if(result<temp)\\n    {result=temp;}\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107386,
                "title": "python-anchor-approach",
                "content": "Let's remember the smallest value `prev` in our current chain, and the length `count` of the current chain.\\n\\n```\\ndef findLengthOfLCIS(self, nums):\\n    prev = float('-inf')\\n    ans = count = 0\\n    for x in nums:\\n        if x > prev:\\n            count += 1\\n            ans = max(ans, count)\\n        else:\\n            count = 1\\n        prev = x\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef findLengthOfLCIS(self, nums):\\n    prev = float('-inf')\\n    ans = count = 0\\n    for x in nums:\\n        if x > prev:\\n            count += 1\\n            ans = max(ans, count)\\n        else:\\n            count = 1\\n        prev = x\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4085462,
                "title": "easy-understanding-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int findLengthOfLCIS(int[] nums) {\\n\\n\\n\\t\\t\\tint maxCount = 0;\\n\\t\\t\\tint start = 0;\\n\\n\\t\\t\\tfor(int i = 0;i < nums.length;i++){\\n\\t\\t\\t\\tif(i > 0 && nums[i - 1] >= nums[i]){\\n\\t\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxCount = Math.max(maxCount,i-start+1);\\n\\t\\t\\t}\\n\\t\\t\\treturn maxCount;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int findLengthOfLCIS(int[] nums) {\\n\\n\\n\\t\\t\\tint maxCount = 0;\\n\\t\\t\\tint start = 0;\\n\\n\\t\\t\\tfor(int i = 0;i < nums.length;i++){\\n\\t\\t\\t\\tif(i > 0 && nums[i - 1] >= nums[i]){\\n\\t\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4084024,
                "title": "simple-java-solution-using-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        Stack<Integer>stack=new Stack<>();\\n        int max=0;\\n        for(int i:nums){\\n            if(stack.isEmpty() || (!stack.isEmpty() && stack.peek()<i)) stack.push(i);\\n            else{\\n                max=Math.max(max,stack.size());\\n                stack.clear();\\n                stack.push(i);\\n            }\\n        }\\n        if(stack.size()>max) return stack.size();\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        Stack<Integer>stack=new Stack<>();\\n        int max=0;\\n        for(int i:nums){\\n            if(stack.isEmpty() || (!stack.isEmpty() && stack.peek()<i)) stack.push(i);\\n            else{\\n                max=Math.max(max,stack.size());\\n                stack.clear();\\n                stack.push(i);\\n            }\\n        }\\n        if(stack.size()>max) return stack.size();\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082521,
                "title": "java-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int count = 1;\\n        int res = 0;\\n        for(int i = 1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                count++;\\n            }else{\\n                res = Math.max(res, count);\\n                count = 1;\\n            }\\n        }\\n        return Math.max(res, count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int count = 1;\\n        int res = 0;\\n        for(int i = 1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]){\\n                count++;\\n            }else{\\n                res = Math.max(res, count);\\n                count = 1;\\n            }\\n        }\\n        return Math.max(res, count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078830,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int length = nums.size();\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        for(int i =1; i <length; i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n            {\\n                currentCount++;\\n                if(currentCount>maxCount)\\n                {\\n                    maxCount = currentCount;\\n                }\\n            }\\n            else\\n            {\\n                currentCount = 1;\\n            }\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int length = nums.size();\\n        int maxCount = 1;\\n        int currentCount = 1;\\n        for(int i =1; i <length; i++)\\n        {\\n            if(nums[i-1]<nums[i])\\n            {\\n                currentCount++;\\n                if(currentCount>maxCount)\\n                {\\n                    maxCount = currentCount;\\n                }\\n            }\\n            else\\n            {\\n                currentCount = 1;\\n            }\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078570,
                "title": "kotlin",
                "content": "O(n) beat 100% runtime\\n\\n# Code\\n```\\nclass Solution {\\n    fun findLengthOfLCIS(nums: IntArray): Int {\\n        var prev:Int = Int.MIN_VALUE\\n        var cont:Int = 0\\n        var maxcont :Int = 0\\n        for (n in nums){\\n            if (n> prev){\\n                cont++\\n                prev = n\\n            }\\n            else{\\n                maxcont = maxOf(maxcont,cont)\\n                cont = 1\\n                prev = n\\n            }\\n        }\\n        maxcont = maxOf(maxcont,cont)\\n        return maxcont\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findLengthOfLCIS(nums: IntArray): Int {\\n        var prev:Int = Int.MIN_VALUE\\n        var cont:Int = 0\\n        var maxcont :Int = 0\\n        for (n in nums){\\n            if (n> prev){\\n                cont++\\n                prev = n\\n            }\\n            else{\\n                maxcont = maxOf(maxcont,cont)\\n                cont = 1\\n                prev = n\\n            }\\n        }\\n        maxcont = maxOf(maxcont,cont)\\n        return maxcont\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060819,
                "title": "easy-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count=1,i=0;\\n        int ans=1;\\n        while(i<nums.size()-1){\\n            if(nums[i+1]>nums[i]){\\n                count++;\\n                ans=max(ans,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        int count=1,i=0;\\n        int ans=1;\\n        while(i<nums.size()-1){\\n            if(nums[i+1]>nums[i]){\\n                count++;\\n                ans=max(ans,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058639,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return nums[0];\\n        }\\n        int cnt=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                cnt++;\\n            }\\n            else{\\n                max=Math.max(max,cnt);\\n                cnt=0;\\n            }\\n        }\\n        if(cnt!=0)\\n        {\\n            max=Math.max(max,cnt);\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return nums[0];\\n        }\\n        int cnt=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                cnt++;\\n            }\\n            else{\\n                max=Math.max(max,cnt);\\n                cnt=0;\\n            }\\n        }\\n        if(cnt!=0)\\n        {\\n            max=Math.max(max,cnt);\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057106,
                "title": "easy-way-to-understanding-for-beginner-level-friendly-0ms-easy-way",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n\\n      int k=0;\\n    \\tint []array=new int[a.length];\\n    \\tint count=1;\\n    \\tint []b=new int[a.length];\\n    \\t\\n    \\tfor(int i=0;i<a.length-1;i++)\\n    \\t{\\n    \\t\\tif(a[i]<a[i+1])\\n    \\t\\t{\\n    \\t\\t\\tcount++;\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tb[k]=count;\\n    \\t\\t\\tk++;\\n    \\t\\t\\tcount=1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(i==a.length-2)\\n    \\t\\t{\\n    \\t\\t\\t//System.out.println(\"connected\");\\n    \\t\\t\\tb[k]=count;\\n    \\t\\t\\tk++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tArrays.sort(b);\\n        if(b[b.length-1]==0)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n\\n    \\treturn b[b.length-1];\\n        }\\n    \\t\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] a) {\\n\\n      int k=0;\\n    \\tint []array=new int[a.length];\\n    \\tint count=1;\\n    \\tint []b=new int[a.length];\\n    \\t\\n    \\tfor(int i=0;i<a.length-1;i++)\\n    \\t{\\n    \\t\\tif(a[i]<a[i+1])\\n    \\t\\t{\\n    \\t\\t\\tcount++;\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tb[k]=count;\\n    \\t\\t\\tk++;\\n    \\t\\t\\tcount=1;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(i==a.length-2)\\n    \\t\\t{\\n    \\t\\t\\t//System.out.println(\"connected\");\\n    \\t\\t\\tb[k]=count;\\n    \\t\\t\\tk++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tArrays.sort(b);\\n        if(b[b.length-1]==0)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n\\n    \\treturn b[b.length-1];\\n        }\\n    \\t\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052123,
                "title": "beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int max = 1;\\n        int count = 1;\\n        \\n        for(int i=1; i<nums.length;i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                count++;\\n                max = Math.max(count , max);\\n            }\\n            else\\n                count =1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) \\n    {\\n        int max = 1;\\n        int count = 1;\\n        \\n        for(int i=1; i<nums.length;i++)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                count++;\\n                max = Math.max(count , max);\\n            }\\n            else\\n                count =1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045173,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count=0\\n        if len(nums)==1:\\n            return 1\\n        for i in range(len(nums)-1):\\n            c=1\\n            last=nums[i]\\n            for j in range(i+1,len(nums)):\\n                if last<nums[j]:\\n                    last=nums[j]\\n                    c+=1\\n                else:\\n                    break\\n            count=max(count,c)\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findLengthOfLCIS(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count=0\\n        if len(nums)==1:\\n            return 1\\n        for i in range(len(nums)-1):\\n            c=1\\n            last=nums[i]\\n            for j in range(i+1,len(nums)):\\n                if last<nums[j]:\\n                    last=nums[j]\\n                    c+=1\\n                else:\\n                    break\\n            count=max(count,c)\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044813,
                "title": "the-js-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n    let i = 0;\\n    let currSubLength = 0;\\n    let ans = 0;\\n\\n    if(nums.length == 1) {\\n        return nums.length;\\n    }\\n\\n    while(i < nums.length - 1) {\\n        if(nums[i] >= nums[i+1]) {\\n            ans = ans < currSubLength ? currSubLength : ans;\\n            currSubLength = 0;\\n        } else {\\n            currSubLength++;\\n        }\\n\\n        i++;\\n    }\\n\\n    return ans < currSubLength ? currSubLength+1  : ans+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findLengthOfLCIS = function(nums) {\\n    let i = 0;\\n    let currSubLength = 0;\\n    let ans = 0;\\n\\n    if(nums.length == 1) {\\n        return nums.length;\\n    }\\n\\n    while(i < nums.length - 1) {\\n        if(nums[i] >= nums[i+1]) {\\n            ans = ans < currSubLength ? currSubLength : ans;\\n            currSubLength = 0;\\n        } else {\\n            currSubLength++;\\n        }\\n\\n        i++;\\n    }\\n\\n    return ans < currSubLength ? currSubLength+1  : ans+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033826,
                "title": "java-1000-accepted-easy-kadane-s-implementation",
                "content": "# Intuition\\nKadane\\'s Algorithm\\nTC-O(n)\\nSC-O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int maxcount=1;\\n        int count=1;    //since a single digit will also be counted as an ans subsequence\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                count++;\\n                maxcount=Math.max(maxcount, count);\\n            }\\n            else count=1;   //since a single digit will also be counted as an ans subsequence\\n        }\\n        return maxcount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int maxcount=1;\\n        int count=1;    //since a single digit will also be counted as an ans subsequence\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                count++;\\n                maxcount=Math.max(maxcount, count);\\n            }\\n            else count=1;   //since a single digit will also be counted as an ans subsequence\\n        }\\n        return maxcount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027791,
                "title": "simple-beginner-s-friendly-code",
                "content": "# Intuition\\n*First we find the longest sequence till where the array is monotonically increasing*\\n# Approach\\n*Find the maximum longest sequence and store it in the variable until you don\\'t get the longest sequence bigger than that*\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n         if (nums.empty()) return 0; // Handle empty input case\\n    int maxLen = 1; // Initialize the maximum length to 1 (minimum possible)\\n    int currentLen = 1; // Initialize the current length to 1\\n    \\n    for (int i = 0; i < nums.size() - 1; i++) {\\n        if (nums[i] < nums[i + 1]) {\\n            currentLen++;\\n            maxLen = max(maxLen, currentLen); // Update the maximum length\\n        } else {\\n            currentLen = 1; // Reset the current length\\n        }\\n    }\\n    \\n    return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n         if (nums.empty()) return 0; // Handle empty input case\\n    int maxLen = 1; // Initialize the maximum length to 1 (minimum possible)\\n    int currentLen = 1; // Initialize the current length to 1\\n    \\n    for (int i = 0; i < nums.size() - 1; i++) {\\n        if (nums[i] < nums[i + 1]) {\\n            currentLen++;\\n            maxLen = max(maxLen, currentLen); // Update the maximum length\\n        } else {\\n            currentLen = 1; // Reset the current length\\n        }\\n    }\\n    \\n    return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027409,
                "title": "c-0-ms-100-faster-easy-to-understand-o-n",
                "content": "![leetcode-647.png](https://assets.leetcode.com/users/images/ee170410-2973-464f-978f-11f2dbca0929_1694358397.134127.png)\\n# Approach\\nTHe code initializes two volatile integer variables, \"l\" and \"m,\" with values. \"l\" is set to the size of the input vector \"nums\" minus 1, and \"m\" is set to 1. Additionally, it initializes a variable \"c\" with a value of 1.\\n\\nIt enters a for loop that iterates through the elements of the \"nums\" vector from index 0 to \"l-1.\"\\n\\nInside the loop, it checks if the current element at index \"i\" is less than the next element at index \"i+1.\" If this condition is true, it increments the \"c\" variable by 1, indicating the increasing subsequence length.\\n\\nIf the condition is false, it means the current subsequence has ended, and it updates the \"m\" variable with the maximum of its current value and the \"c\" variable (keeping track of the maximum increasing subsequence length found so far), and then resets \"c\" to 1 for the next potential increasing subsequence.\\n\\nAfter the loop finishes, it ensures that the \"m\" variable is updated one final time by taking the maximum of its current value and the \"c\" variable.\\n\\nFinally, the method returns the value of \"m,\" which represents the length of the longest continuous increasing subsequence in the \"nums\" vector.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        volatile int l = nums.size() - 1;\\n        volatile int m = 1,c = 1;\\n        for (int i = 0; i < l ; i++){\\n            if(nums[i] < nums[i+1])\\n                c += 1;\\n            else{\\n                m = max(c,m);\\n                c = 1;\\n            }\\n        }\\n        m = max(c,m);\\n        return m;\\n    }\\n};\\n```\\n![please upvote.jpg](https://assets.leetcode.com/users/images/369a6654-88b7-4f64-bb0d-1091a4c37629_1694358417.1025085.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        volatile int l = nums.size() - 1;\\n        volatile int m = 1,c = 1;\\n        for (int i = 0; i < l ; i++){\\n            if(nums[i] < nums[i+1])\\n                c += 1;\\n            else{\\n                m = max(c,m);\\n                c = 1;\\n            }\\n        }\\n        m = max(c,m);\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026778,
                "title": "1ms-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = Integer.MIN_VALUE, j = 0;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i - 1] >= nums[i]) {\\n                if (max < i - j) {\\n                    max = i - j;\\n                }\\n                j = i;\\n            }\\n        }\\n\\n        return Math.max(max, nums.length - j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int max = Integer.MIN_VALUE, j = 0;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i - 1] >= nums[i]) {\\n                if (max < i - j) {\\n                    max = i - j;\\n                }\\n                j = i;\\n            }\\n        }\\n\\n        return Math.max(max, nums.length - j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023717,
                "title": "simple-java-solution-1-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int c=1,c1=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1])\\n                c++;\\n            else{\\n                if(c>c1)\\n                    c1=c;\\n                c=1;\\n                continue;\\n            }\\n        }\\n        return Math.max(c,c1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int c=1,c1=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1])\\n                c++;\\n            else{\\n                if(c>c1)\\n                    c1=c;\\n                c=1;\\n                continue;\\n            }\\n        }\\n        return Math.max(c,c1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022896,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        if(nums.length==1){\\n            return 1;\\n        }\\n        int c=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                c++;\\n            }\\n            else{\\n                c=0;\\n            }\\n            if(max<c){\\n                max=c;\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        if(nums.length==1){\\n            return 1;\\n        }\\n        int c=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]<nums[i+1]){\\n                c++;\\n            }\\n            else{\\n                c=0;\\n            }\\n            if(max<c){\\n                max=c;\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020423,
                "title": "elixir-reduce-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec find_length_of_lcis(nums :: [integer]) :: integer\\n  def find_length_of_lcis([h | t] = _nums) do\\n    t\\n    |> Enum.reduce([seq: [h], max: 0], fn num, seq: seq, max: max_length ->\\n      if num > hd(seq) do\\n        [seq: [num | seq], max: max_length]\\n      else\\n        [seq: [num], max: max(max_length, length(seq))]\\n      end\\n    end)\\n    |> then(fn seq: seq, max: max_length -> max(max_length, length(seq)) end)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_length_of_lcis(nums :: [integer]) :: integer\\n  def find_length_of_lcis([h | t] = _nums) do\\n    t\\n    |> Enum.reduce([seq: [h], max: 0], fn num, seq: seq, max: max_length ->\\n      if num > hd(seq) do\\n        [seq: [num | seq], max: max_length]\\n      else\\n        [seq: [num], max: max(max_length, length(seq))]\\n      end\\n    end)\\n    |> then(fn seq: seq, max: max_length -> max(max_length, length(seq)) end)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4013714,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findLengthOfLCIS = function(nums) {\\n    \\n    let maxCount = 1\\n    \\n    let count = 1\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i-1]) {\\n            count++\\n            maxCount = Math.max(maxCount, count)\\n        } else {\\n            count = 1\\n        }\\n    }\\n    \\n    return maxCount\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst findLengthOfLCIS = function(nums) {\\n    \\n    let maxCount = 1\\n    \\n    let count = 1\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i-1]) {\\n            count++\\n            maxCount = Math.max(maxCount, count)\\n        } else {\\n            count = 1\\n        }\\n    }\\n    \\n    return maxCount\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013306,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n), n = length of the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n\\n        int left =0;\\n        int length = 1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n               length= Math.max(length, ((i+1)-left+1));\\n            }\\n            else\\n            {\\n                left=i+1;\\n            }\\n\\n        }\\n\\n        return length;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n\\n        int left =0;\\n        int length = 1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n               length= Math.max(length, ((i+1)-left+1));\\n            }\\n            else\\n            {\\n                left=i+1;\\n            }\\n\\n        }\\n\\n        return length;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010370,
                "title": "c-basic-solutoin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        vector<int> res;\\n        int ans=1;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]<nums[i]){\\n                ans+=1;\\n            } else{\\n                res.push_back(ans);\\n                ans=1;\\n            }\\n        }\\n        res.push_back(ans);\\n        int mx=INT_MIN;\\n        // int mx=0;\\n        for(int i=0; i<res.size(); i++){\\n            mx=max(mx, res[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        vector<int> res;\\n        int ans=1;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]<nums[i]){\\n                ans+=1;\\n            } else{\\n                res.push_back(ans);\\n                ans=1;\\n            }\\n        }\\n        res.push_back(ans);\\n        int mx=INT_MIN;\\n        // int mx=0;\\n        for(int i=0; i<res.size(); i++){\\n            mx=max(mx, res[i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007939,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nfunc findLengthOfLCIS(_ nums: [Int]) -> Int {\\n    guard nums.count != 1 else {return 1}\\n\\n    var count = 1\\n    var max = 0\\n    \\n    for i in 0...nums.count - 2 {\\n        if nums[i] < nums[i + 1] {\\n            count += 1\\n        } else {\\n            if max < count {\\n                max = count\\n            }\\n            count = 1\\n        }\\n    }\\n    \\n    return count < max ? max : count\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\nfunc findLengthOfLCIS(_ nums: [Int]) -> Int {\\n    guard nums.count != 1 else {return 1}\\n\\n    var count = 1\\n    var max = 0\\n    \\n    for i in 0...nums.count - 2 {\\n        if nums[i] < nums[i + 1] {\\n            count += 1\\n        } else {\\n            if max < count {\\n                max = count\\n            }\\n            count = 1\\n        }\\n    }\\n    \\n    return count < max ? max : count\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003551,
                "title": "beats-99-java-easy-solution-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        int max =1;\\n        int c = 1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                if(c>max)\\n                {\\n                    max = c;\\n                }\\n                c = 1;\\n            }\\n        }\\n        return Math.max(c,max);\\n        //return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        \\n        int max =1;\\n        int c = 1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                if(c>max)\\n                {\\n                    max = c;\\n                }\\n                c = 1;\\n            }\\n        }\\n        return Math.max(c,max);\\n        //return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990842,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int FindLengthOfLCIS(int[] nums)\\n    {\\n        if (nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n\\n        var max = 1;\\n        var cur = 1;\\n\\n        for (var i = 1; i < nums.Length; i++)\\n        {\\n            if (nums[i] > nums[i - 1])\\n            {\\n                cur++;\\n            }\\n            else\\n            {\\n                max = Math.Max(max, cur);\\n                cur = 1;\\n            }\\n        }\\n\\n        return Math.Max(max, cur);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int FindLengthOfLCIS(int[] nums)\\n    {\\n        if (nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n\\n        var max = 1;\\n        var cur = 1;\\n\\n        for (var i = 1; i < nums.Length; i++)\\n        {\\n            if (nums[i] > nums[i - 1])\\n            {\\n                cur++;\\n            }\\n            else\\n            {\\n                max = Math.Max(max, cur);\\n                cur = 1;\\n            }\\n        }\\n\\n        return Math.Max(max, cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989764,
                "title": "beats-98-53-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int c=1;\\n        int max=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                c++;\\n            }else{\\n                c=1;\\n            }\\n            max=Math.max(max,c);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int c=1;\\n        int max=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                c++;\\n            }else{\\n                c=1;\\n            }\\n            max=Math.max(max,c);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988831,
                "title": "solved-in-tc-o-n-and-sc-1",
                "content": "# Intuition\\nThe problem asks to find the LCS. The idea is to calculate the size of each LCS and replace if found the max.\\n\\n# Approach\\nIterate over array while keeping two variables. One to store final result and other to replace final result if found max LCS. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int result = 1;\\n        int size = 1;\\n        for (int i =0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1]){\\n               size++;\\n            } else {\\n                size=1;\\n            }\\n            result = Math.max(result, size);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int result = 1;\\n        int size = 1;\\n        for (int i =0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1]){\\n               size++;\\n            } else {\\n                size=1;\\n            }\\n            result = Math.max(result, size);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985701,
                "title": "beats-99-at-time-o-1-space-complexity",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSLIDING WINDOW TECHNIQUE \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==1)  return 1;\\n        int max=INT_MIN;\\n        int start=0;\\n        int end=0;\\n\\n        while(end<nums.size()-1){   \\n            if(nums[end+1]>nums[end])   end++;\\n            else{\\n                if(max<end-start+1) max=end-start+1;\\n                start=end+1;\\n                end++;\\n            }\\n        }\\n        if(max<end-start+1 && end==nums.size()-1)  max=end-start+1;\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLengthOfLCIS(vector<int>& nums) {\\n        if(nums.size()==1)  return 1;\\n        int max=INT_MIN;\\n        int start=0;\\n        int end=0;\\n\\n        while(end<nums.size()-1){   \\n            if(nums[end+1]>nums[end])   end++;\\n            else{\\n                if(max<end-start+1) max=end-start+1;\\n                start=end+1;\\n                end++;\\n            }\\n        }\\n        if(max<end-start+1 && end==nums.size()-1)  max=end-start+1;\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978882,
                "title": "accepted-solution-for-java-beats-100-online-submissions",
                "content": "![Screenshot 2023-08-30 at 9.51.48 AM.png](https://assets.leetcode.com/users/images/6f1fa2a8-20c2-4e57-ba14-39f39d9d46eb_1693369341.5921452.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int cnt=1,max=1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            if(max<cnt)\\n                max=cnt;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findLengthOfLCIS(int[] nums) {\\n        int cnt=1,max=1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            if(max<cnt)\\n                max=cnt;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572264,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1568768,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1794823,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 2017717,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1985892,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1765586,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            },
            {
                "id": 1662311,
                "content": [
                    {
                        "username": "xdavidliu",
                        "content": "The problem explanation is pretty unambiguous and I have no issues with it but the title could be improved: the word \"subsequence\" is most often seen in the \"longest common subsequence\" problem, and there, it specifically allows *non*-contiguous / continuous subsequences. Longest increasing subarray works way better here."
                    },
                    {
                        "username": "ba_minh",
                        "content": "True"
                    },
                    {
                        "username": "the_coder5311",
                        "content": "This problem is very simple and doesn\\'t require sliding window to do! Simple iteration and if/else will handle it just fine. Why complicate an originally easy problem?"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "They should have tagged  `Two Pointers` and  `Sliding Window` in \"Related Topics\" field... "
                    },
                    {
                        "username": "pcRipper",
                        "content": "Please, change the goddamn description : subsequence means subsequence, not subarray(remove these parentheses and just write SUBARRAY). For 5 minutes I\\'ve been trying to understand how can it be solved in O(n) as a search of subsequence without DP!\\uD83D\\uDE24"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Someone please tell the author that there is a difference between subsequence and a subarray. It took me 13 minutes to see they were actually asking for the subsequence"
                    },
                    {
                        "username": "leetflux",
                        "content": "The description and example 2 don't seem to align.\n\nFrom the description: `A continuous increasing subsequence is defined by two indices l and r (l < r)...`\n\nExample 2:\n```\nInput: nums = [2,2,2,2,2]\nOutput: 1\n```\n\nIn example 2 there is no **continuous increasing subsequence** as there are no possible `l` and `r` values that meet the requirements. Am I misunderstanding the description?"
                    },
                    {
                        "username": "luke_py",
                        "content": "exactly what i was thinking, theres no continuous increasing subsequence."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "This problem can be solved without conditionals (if/else, ?/:, etc.) for a fast and of course linear time (O(N)) solution."
                    }
                ]
            }
        ]
    }
]