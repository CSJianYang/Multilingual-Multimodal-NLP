[
    {
        "title": "Minimum Moves to Reach Target Score",
        "question_content": "You are playing a game with integers. You start with the integer 1 and you want to reach the integer target.\nIn one move, you can either:\n\n\tIncrement the current integer by one (i.e., x = x + 1).\n\tDouble the current integer (i.e., x = 2 * x).\n\nYou can use the increment operation any number of times, however, you can only use the double operation at most maxDoubles times.\nGiven the two integers target and maxDoubles, return the minimum number of moves needed to reach target starting with 1.\n&nbsp;\nExample 1:\n\nInput: target = 5, maxDoubles = 0\nOutput: 4\nExplanation: Keep incrementing by 1 until you reach target.\n\nExample 2:\n\nInput: target = 19, maxDoubles = 2\nOutput: 7\nExplanation: Initially, x = 1\nIncrement 3 times so x = 4\nDouble once so x = 8\nIncrement once so x = 9\nDouble again so x = 18\nIncrement once so x = 19\n\nExample 3:\n\nInput: target = 10, maxDoubles = 4\nOutput: 4\nExplanation: Initially, x = 1\nIncrement once so x = 2\nDouble once so x = 4\nIncrement once so x = 5\nDouble again so x = 10\n\n&nbsp;\nConstraints:\n\n\t1 <= target <= 109\n\t0 <= maxDoubles <= 100",
        "solutions": [
            {
                "id": 1692912,
                "title": "go-backwards",
                "content": "We go backwards, transforming `target` to `1`. That way, we get the biggest bang for each double move.\\n\\nNote that we can divide the target only if it\\'s even. \\n\\n#### Compressed Version\\nHere, we make one move if `target` is even (divide by 2), or two moves otherwise (decrement, then divide by 2).\\n**C++**\\n```cpp\\nint minMoves(int target, int maxDoubles) {\\n    int res = 0;\\n    while (target > 1 && maxDoubles--) {\\n        res += 1 + target % 2;\\n        target /= 2;\\n    }\\n    return res + target - 1;\\n}\\n```\\n#### Simple Version\\n**C++**\\n```cpp\\nint minMoves(int target, int maxDoubles) {\\n    int res = 0;\\n    while (target && maxDoubles) {\\n        if (target % 2)\\n            --target;\\n        else {\\n            --maxDoubles;\\n            target /= 2;\\n        }\\n        ++res;\\n    }\\n    return res + target - 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minMoves(int target, int maxDoubles) {\\n    int res = 0;\\n    while (target > 1 && maxDoubles--) {\\n        res += 1 + target % 2;\\n        target /= 2;\\n    }\\n    return res + target - 1;\\n}\\n```\n```cpp\\nint minMoves(int target, int maxDoubles) {\\n    int res = 0;\\n    while (target && maxDoubles) {\\n        if (target % 2)\\n            --target;\\n        else {\\n            --maxDoubles;\\n            target /= 2;\\n        }\\n        ++res;\\n    }\\n    return res + target - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693327,
                "title": "java-c-python-reduce-target-to-1",
                "content": "# **Intuition**\\nWe should use double action as late as possible, as many as possible.\\nDo this process reversely: Reduce target to 1.\\nWe try to use the HALF action as soon as possbile..\\n<br>\\n\\n# **Explanation**\\nIf we still \"half\" action, we do it.\\nIf it\\'s odd, we decrese it by 1 and make it half, which takes two actions.\\nIf it\\'s even, we make it half, which takes one action.\\n\\nIf no more \"half\" action, we decrement continuously to 1, which takes `target - 1` actions.\\n<br>\\n\\n# **Complexity**\\nTime `O(logn)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minMoves(int target, int k) {\\n        int res = 0;\\n        while (target > 1 && k > 0) {   \\n            res += 1 + target % 2;\\n            k--;\\n            target >>= 1;\\n        }\\n        return target - 1 + res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minMoves(int target, int k) {\\n        int res = 0;\\n        while (target > 1 && k > 0) {   \\n            res += 1 + target % 2;\\n            k--;\\n            target >>= 1;\\n        }\\n        return target - 1 + res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minMoves(self, target, k):\\n        res = 0\\n        while target > 1 and k > 0:\\n            res += 1 + target % 2\\n            k -= 1\\n            target >>= 1\\n        return target - 1 + res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minMoves(int target, int k) {\\n        int res = 0;\\n        while (target > 1 && k > 0) {   \\n            res += 1 + target % 2;\\n            k--;\\n            target >>= 1;\\n        }\\n        return target - 1 + res;\\n    }\\n```\n```cpp\\n    int minMoves(int target, int k) {\\n        int res = 0;\\n        while (target > 1 && k > 0) {   \\n            res += 1 + target % 2;\\n            k--;\\n            target >>= 1;\\n        }\\n        return target - 1 + res;\\n    }\\n```\n```py\\n    def minMoves(self, target, k):\\n        res = 0\\n        while target > 1 and k > 0:\\n            res += 1 + target % 2\\n            k -= 1\\n            target >>= 1\\n        return target - 1 + res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1693193,
                "title": "3-lines-greedy",
                "content": "**Idea**\\nFor doubling to take the max effect it should be happening as late as possible. This is why we go backwards and reduce target to 1. \\nGreedily grab as much as possible from the end - dividing by 2. Remainder is the number of increments by 1.\\n\\n**Code**\\n```\\npublic int minMoves(int target, int maxDoubles) {\\n\\tint ans = 0;\\n\\tfor (;target > 1 && --maxDoubles >= 0; target/=2) ans += 1 + target % 2;\\n\\treturn ans + target - 1;\\n}\\n```\\n\\nExpanded\\n```\\npublic int minMoves(int target, int maxDoubles) {\\n\\tint ans = 0;\\n\\t\\n\\t// go untill the start = 1\\n\\twhile (target > 1 && --maxDoubles >= 0) {\\n\\t\\tint nOfIncrements = target % 2;\\n\\t\\t// 1 move for division + nOfIncrements moves of increments by 1\\n\\t\\tans += 1 + nOfIncrements;\\n\\t\\t// the best solution - to take as much as possible\\n\\t\\ttarget /= 2;\\n\\t}\\n\\t\\n\\t// adding target since we can\\'t divide anymore\\n\\treturn ans + target - 1;\\n}\\n```\\n\\n**Specs**\\nTime complexity: O(logn)",
                "solutionTags": [],
                "code": "```\\npublic int minMoves(int target, int maxDoubles) {\\n\\tint ans = 0;\\n\\tfor (;target > 1 && --maxDoubles >= 0; target/=2) ans += 1 + target % 2;\\n\\treturn ans + target - 1;\\n}\\n```\n```\\npublic int minMoves(int target, int maxDoubles) {\\n\\tint ans = 0;\\n\\t\\n\\t// go untill the start = 1\\n\\twhile (target > 1 && --maxDoubles >= 0) {\\n\\t\\tint nOfIncrements = target % 2;\\n\\t\\t// 1 move for division + nOfIncrements moves of increments by 1\\n\\t\\tans += 1 + nOfIncrements;\\n\\t\\t// the best solution - to take as much as possible\\n\\t\\ttarget /= 2;\\n\\t}\\n\\t\\n\\t// adding target since we can\\'t divide anymore\\n\\treturn ans + target - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1694930,
                "title": "jump-game-100-faster-100-less-memory-usage",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n![image](https://assets.leetcode.com/users/images/6a6c3755-a404-4b33-b433-2545774a0040_1642348750.090423.png)\\n\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* We are playing a game in which we are standing at number block 1.\\n* We have given a target N; thus there are total N blocks from start to end.\\n* We have only bounded to use two moves. We can jump from one block to another block. Or we can jump equal blocks that we have crossed.\\n* The double jump feature can use only a limited time given in the question and we should only land at the target block.\\n#### \\u2714\\uFE0F **Solution - I (From target block to start block)**\\n##### **Intuition :-**\\n* Assume that we are at the target block.\\n* So now our moves will be we can go at half of the distance if we use the double jump. This feature can only be used when you are standing at the even value block else you will land at between two blocks.\\n* We will make the no even by getting behind one block from the target block.\\n* We can only go at the half distance only a limited time as we have limited double jump options.\\n* Once we use all the double jump the only feature we can use is single jump hence the total steps will till then will be added to blocks left - 1 as starting point is block 1.\\n##### **Code :-**\\n```\\nint minMoves(int target, int maxDoubles)\\n{\\n     int jump = 0;\\n     while (target && maxDoubles)\\n     {\\n          if (target % 2)\\n               target--;\\n          else\\n          {\\n               target /= 2;\\n               maxDoubles--;\\n          }\\n          jump++;\\n     }\\n     return jump + target - 1;\\n}\\n```\\n**Time Complexity** : `O(logn)`, \\n**Space Complexity** : `O(1)`, \\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [],
                "code": "```\\nint minMoves(int target, int maxDoubles)\\n{\\n     int jump = 0;\\n     while (target && maxDoubles)\\n     {\\n          if (target % 2)\\n               target--;\\n          else\\n          {\\n               target /= 2;\\n               maxDoubles--;\\n          }\\n          jump++;\\n     }\\n     return jump + target - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693110,
                "title": "easy-c-code-with-explanation",
                "content": "We solve the problem in reverse manner. We move from target to 1, because in this way you get more utlilization  of maxDoubles, as a result we can minimise the moves.\\nWhen target is an even number we can decrease the target by half if maxDoubles are available.\\nWhen target is odd we just decrease the target by 1.\\nAfter the maxDoubles are finished, we just decrease each time by 1. (i.e. target-1 times).\\n\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        while(target>1 && maxDoubles>0){\\n            if(target%2==0){\\n                cnt++;\\n                maxDoubles--;\\n                target = target/2;\\n            }\\n            else{\\n                cnt++;\\n                target--;\\n            }\\n        }\\n        return cnt + (target-1);\\n    }\\n};\\n```\\n**Upvote if it helps!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        while(target>1 && maxDoubles>0){\\n            if(target%2==0){\\n                cnt++;\\n                maxDoubles--;\\n                target = target/2;\\n            }\\n            else{\\n                cnt++;\\n                target--;\\n            }\\n        }\\n        return cnt + (target-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692907,
                "title": "easy-c-recursive-approach-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int i, int d){\\n        if(i == 1) return 0; // reached \\n        if(d == 0) return i - 1; // only way left to reach 1 in i - 1 operations\\n        \\n        int ans = 0;\\n        \\n        if(i & 1){ // when i is odd change it to even\\n            ans = 1 + f(i - 1, d);\\n        }\\n        else if(d > 0){ // when i is even and we have maxDoubles left then use it\\n            ans = 1 + f(i / 2, d - 1);\\n        }\\n        \\n        return ans;\\n    }\\n    int minMoves(int target, int maxDoubles) {\\n        return f(target, maxDoubles); // move reverse from target to 1 using / and - operator.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int d){\\n        if(i == 1) return 0; // reached \\n        if(d == 0) return i - 1; // only way left to reach 1 in i - 1 operations\\n        \\n        int ans = 0;\\n        \\n        if(i & 1){ // when i is odd change it to even\\n            ans = 1 + f(i - 1, d);\\n        }\\n        else if(d > 0){ // when i is even and we have maxDoubles left then use it\\n            ans = 1 + f(i / 2, d - 1);\\n        }\\n        \\n        return ans;\\n    }\\n    int minMoves(int target, int maxDoubles) {\\n        return f(target, maxDoubles); // move reverse from target to 1 using / and - operator.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253775,
                "title": "c-solution-0ms-4lines-code-better-than-100-recursion-easy-to-understand",
                "content": "```\\nint minMoves(int target, int maxDoubles) {\\n        if(target==1)   return 0;\\n        if(maxDoubles==0)\\n            return target-1;\\n        if(target%2)\\n            return minMoves(target-1, maxDoubles)+1;\\n        else\\n            return minMoves(target/2, maxDoubles-1)+1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nint minMoves(int target, int maxDoubles) {\\n        if(target==1)   return 0;\\n        if(maxDoubles==0)\\n            return target-1;\\n        if(target%2)\\n            return minMoves(target-1, maxDoubles)+1;\\n        else\\n            return minMoves(target/2, maxDoubles-1)+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788453,
                "title": "best-solution",
                "content": "# Approach\\nGreedy\\n\\n# Complexity\\n- Time complexity:\\n$$O(target)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int minMoves = 0;\\n        while (target > 1) {\\n            if (maxDoubles == 0) {\\n                minMoves += target - 1;\\n                break;\\n            }\\n            if (target % 2 == 0) {\\n                target = target / 2;\\n                maxDoubles--;\\n            } else {\\n                target--;\\n            }\\n            minMoves++;\\n        }\\n        return minMoves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int minMoves = 0;\\n        while (target > 1) {\\n            if (maxDoubles == 0) {\\n                minMoves += target - 1;\\n                break;\\n            }\\n            if (target % 2 == 0) {\\n                target = target / 2;\\n                maxDoubles--;\\n            } else {\\n                target--;\\n            }\\n            minMoves++;\\n        }\\n        return minMoves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078596,
                "title": "c-beginner-friendly-easy-to-undertand",
                "content": "# **Please upvote if it helps!!\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int count=0;\\n        while(target!=1)\\n        {\\n            \\n            if(maxDoubles==0)\\n            {\\n                return count+target-1;\\n            }\\n            count++;\\n            if(target%2==0 && maxDoubles!=0)\\n            {\\n                target/=2;\\n                maxDoubles--;\\n            }\\n            else if(target%2!=0)\\n            {\\n                target-=1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int count=0;\\n        while(target!=1)\\n        {\\n            \\n            if(maxDoubles==0)\\n            {\\n                return count+target-1;\\n            }\\n            count++;\\n            if(target%2==0 && maxDoubles!=0)\\n            {\\n                target/=2;\\n                maxDoubles--;\\n            }\\n            else if(target%2!=0)\\n            {\\n                target-=1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741732,
                "title": "simple-math-java",
                "content": "Start from target and check if it is divisible by 2 if so divide and reduce the maxdoubles .\\n\\nwhy we should  start  from target not from front ?\\n\\nSuppose you have two variables x and y x>y\\ndoubling x in this case will will fetch minimum number to reach target  than doubling y;\\n\\nHeres the code \\n\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        \\n        int ans = 0;\\n        \\n        while(target >0 && maxDoubles >0)\\n        {\\n            \\n           if(target%2 == 0)\\n            {\\n             target = target/2;\\n             maxDoubles--;\\n             }\\n            \\n            else\\n            {\\n                target = target-1;\\n             }\\n            ans++;\\n        }\\n        \\n        if(target != 1) ans+=target-1;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        \\n        int ans = 0;\\n        \\n        while(target >0 && maxDoubles >0)\\n        {\\n            \\n           if(target%2 == 0)\\n            {\\n             target = target/2;\\n             maxDoubles--;\\n             }\\n            \\n            else\\n            {\\n                target = target-1;\\n             }\\n            ans++;\\n        }\\n        \\n        if(target != 1) ans+=target-1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694389,
                "title": "easy-beginner-solution-o-n",
                "content": "def minMoves(self, target: int, maxDoubles: int) -> int:\\n        \\n        ans=0\\n        while target!=1:\\n            if target%2==0 and maxDoubles!=0: \\n                target=target/2\\n                maxDoubles-=1\\n                ans+=1                   \\n            else:\\n                if maxDoubles==0:\\n                    ans=ans+(target-1)\\n                    target=1 \\n                else:\\n                    target-=1\\n                    ans+=1\\n        return int(ans)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "def minMoves(self, target: int, maxDoubles: int) -> int:\\n        \\n        ans=0\\n        while target!=1:\\n            if target%2==0 and maxDoubles!=0: \\n                target=target/2\\n                maxDoubles-=1\\n                ans+=1                   \\n            else:\\n                if maxDoubles==0:\\n                    ans=ans+(target-1)\\n                    target=1 \\n                else:\\n                    target-=1\\n                    ans+=1\\n        return int(ans)",
                "codeTag": "Python3"
            },
            {
                "id": 1693453,
                "title": "c-o-n-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        \\n        while(maxDoubles-- && target > 1) {\\n            if(target % 2 == 1) {\\n                target--;\\n                ans++;\\n            }\\n            target /= 2;\\n            ans++;\\n        }\\n        \\n        ans += (target - 1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        \\n        while(maxDoubles-- && target > 1) {\\n            if(target % 2 == 1) {\\n                target--;\\n                ans++;\\n            }\\n            target /= 2;\\n            ans++;\\n        }\\n        \\n        ans += (target - 1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693010,
                "title": "java-solution-while-going-backwards-from-hi-to-lo",
                "content": "Instead of trying to go from `lo` to `hi`, try to go from `hi` to `lo`.\\nThe idea is that for minimum steps, the doubling needs to take maximum effect while going from `lo` to `hi`.\\n\\nThe easiest way to do so is to half the `hi` if it is even or reduce it by one and then half so that doubling will take maximum effect.\\n\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int steps = 0;\\n        while(target > 1) {\\n            if (target % 2 == 0 && maxDoubles > 0) {\\n                target /= 2;\\n                maxDoubles--;\\n            } else if (maxDoubles == 0) {\\n                steps += target - 1;\\n                break;\\n            } else {\\n                target--;\\n            }\\n            steps++;\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int steps = 0;\\n        while(target > 1) {\\n            if (target % 2 == 0 && maxDoubles > 0) {\\n                target /= 2;\\n                maxDoubles--;\\n            } else if (maxDoubles == 0) {\\n                steps += target - 1;\\n                break;\\n            } else {\\n                target--;\\n            }\\n            steps++;\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692969,
                "title": "c-greedy",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int minMoves(int n, int maxDoubles) {\\n        int c=0;\\n        while(n>1){\\n            if(maxDoubles>0 && n%2==0){\\n                n/=2;\\n                maxDoubles--;\\n            }else{\\n                n--;\\n            }\\n            c++;\\n            if(maxDoubles==0) break;\\n        }\\n        return c+(n-1); \\n    }\\n};\\n```\\n\\n**Do Upvote If It Helps**",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minMoves(int n, int maxDoubles) {\\n        int c=0;\\n        while(n>1){\\n            if(maxDoubles>0 && n%2==0){\\n                n/=2;\\n                maxDoubles--;\\n            }else{\\n                n--;\\n            }\\n            c++;\\n            if(maxDoubles==0) break;\\n        }\\n        return c+(n-1); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596941,
                "title": "java-solution-iterative-coded-in-3-ways-recursive",
                "content": "### **Please Upvote !!!**\\n#### 1. Iterative:\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        if (maxDoubles == 0) return target - 1;\\n\\n        while (target != 1) {\\n            if (target % 2 == 1) {\\n                target--;\\n                moves++;\\n\\n            } else {\\n                if (maxDoubles-- > 0) {\\n                    target /= 2;\\n                    moves++;\\n                } else {\\n                    moves += target - 1;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return moves;\\n    }\\n}\\n```\\n##### OR\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int moveCount = 0;\\n        if (maxDoubles == 0) return target - 1;\\n\\n        while (target != 1) {\\n            if (target % 2 == 0 && maxDoubles > 0) {\\n                target /= 2;\\n                maxDoubles--;\\n\\n            } else if (maxDoubles == 0) {\\n                moveCount += target - 1;\\n                break;\\n            }\\n\\n            else target--;  // target is odd\\n            moveCount++;\\n        }\\n\\n        return moveCount;\\n    }\\n}\\n```\\n##### OR\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n\\n        while (target > 1 && maxDoubles > 0) {\\n            if (target % 2 != 0) {\\n                moves++;\\n            }\\n\\n            maxDoubles--;\\n            target /= 2;\\n            moves++;\\n        }\\n\\n        moves += target - 1;\\n        return moves;\\n    }\\n}\\n```\\nTime Complexity: **O(n)**\\nSpace Complexity: **O(1)**\\n\\n#### 2. Recursive:\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if (target == 1) return 0;\\n        if (maxDoubles == 0) return target - 1;\\n\\n        if (target % 2 == 0) {\\n            return 1 + minMoves(target / 2, maxDoubles - 1);\\n        }\\n        // else\\n        return 2 + minMoves(target / 2, maxDoubles - 1);\\n    }\\n}\\n```\\nTime Complexity: **O(logn)**\\nSpace Complexity: **O(n)**\\n### **Please Upvote !!!**\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        if (maxDoubles == 0) return target - 1;\\n\\n        while (target != 1) {\\n            if (target % 2 == 1) {\\n                target--;\\n                moves++;\\n\\n            } else {\\n                if (maxDoubles-- > 0) {\\n                    target /= 2;\\n                    moves++;\\n                } else {\\n                    moves += target - 1;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return moves;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int moveCount = 0;\\n        if (maxDoubles == 0) return target - 1;\\n\\n        while (target != 1) {\\n            if (target % 2 == 0 && maxDoubles > 0) {\\n                target /= 2;\\n                maxDoubles--;\\n\\n            } else if (maxDoubles == 0) {\\n                moveCount += target - 1;\\n                break;\\n            }\\n\\n            else target--;  // target is odd\\n            moveCount++;\\n        }\\n\\n        return moveCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n\\n        while (target > 1 && maxDoubles > 0) {\\n            if (target % 2 != 0) {\\n                moves++;\\n            }\\n\\n            maxDoubles--;\\n            target /= 2;\\n            moves++;\\n        }\\n\\n        moves += target - 1;\\n        return moves;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if (target == 1) return 0;\\n        if (maxDoubles == 0) return target - 1;\\n\\n        if (target % 2 == 0) {\\n            return 1 + minMoves(target / 2, maxDoubles - 1);\\n        }\\n        // else\\n        return 2 + minMoves(target / 2, maxDoubles - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375777,
                "title": "super-fast-python-simple-loop",
                "content": "```\\ndef minMoves(self, target: int, maxDoubles: int) -> int:\\n        countdbl = 0\\n        count = 0\\n        while target > 1 and countdbl < maxDoubles:\\n            if target %2 == 0 :\\n                target = target //2\\n                countdbl +=1\\n                count+=1\\n            else:\\n                target-=1\\n                count+=1\\n         \\n        count+= (target-1)                               \\n        return count\\n",
                "solutionTags": [],
                "code": "```\\ndef minMoves(self, target: int, maxDoubles: int) -> int:\\n        countdbl = 0\\n        count = 0\\n        while target > 1 and countdbl < maxDoubles:\\n            if target %2 == 0 :\\n                target = target //2\\n                countdbl +=1\\n                count+=1\\n            else:\\n                target-=1\\n                count+=1\\n         \\n        count+= (target-1)                               \\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2153447,
                "title": "faster-than-100-c-python3-start-from-backward-direction",
                "content": "![image](https://assets.leetcode.com/users/images/63a1d008-7bbc-4fae-9f0a-43f808f9cf6d_1655269019.9420733.png)\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int c=0;\\n        while(maxDoubles>0 && target>1){\\n            c += target%2;\\n            target /= 2;\\n            ++c;\\n            --maxDoubles;\\n        }\\n        return c + target-1;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        c=0\\n        while(maxDoubles>0 and target>1):\\n            c += target%2\\n            target //= 2\\n            c += 1\\n            maxDoubles -=1\\n        return c + target-1",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int c=0;\\n        while(maxDoubles>0 && target>1){\\n            c += target%2;\\n            target /= 2;\\n            ++c;\\n            --maxDoubles;\\n        }\\n        return c + target-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078369,
                "title": "python-solution-using-mathematical-approach",
                "content": "```\\nclass Solution(object):\\n    def minMoves(self, target, maxDoubles):\\n        \"\"\"\\n        :type target: int\\n        :type maxDoubles: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        while maxDoubles > 0 and target > 1:\\n            if target&1==1:\\n                target = target - 1\\n            else:\\n                target = target / 2\\n                maxDoubles = maxDoubles - 1\\n            res = res + 1\\n        return  res + (target-1)\\n\\t\\t\\n```\\n\\nTime Complexity:- O(n)\\nMemory :- O(1)\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def minMoves(self, target, maxDoubles):\\n        \"\"\"\\n        :type target: int\\n        :type maxDoubles: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        while maxDoubles > 0 and target > 1:\\n            if target&1==1:\\n                target = target - 1\\n            else:\\n                target = target / 2\\n                maxDoubles = maxDoubles - 1\\n            res = res + 1\\n        return  res + (target-1)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695164,
                "title": "c-simple-o-logn-solution-easy-solution",
                "content": "Intuition\\nWe should use double action as late as possible, as many as possible.\\nDo this process reversely: Reduce target to 1.\\nWe try to use the HALF action as soon as possbile..\\n\\n\\nExplanation\\nIf we still \"half\" action, we do it.\\nIf it\\'s odd, we decrese it by 1 and make it half, which takes two actions.\\nIf it\\'s even, we make it half, which takes one action.\\n\\nIf no more \"half\" action, we decrement continuously to 1, which takes target - 1 actions.\\n\\n\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n*         int cnt=0;\\n        while(target>1 && maxDoubles!=0){\\n            if(target%2==0 ){\\n                target=target/2;\\n                maxDoubles--;\\n            }\\n            else{\\n                target-=1;\\n            }\\n            cnt++;\\n        }\\n        cnt+=target-1; //if maxdouble is zero return target -1\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n*         int cnt=0;\\n        while(target>1 && maxDoubles!=0){\\n            if(target%2==0 ){\\n                target=target/2;\\n                maxDoubles--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1694199,
                "title": "c-faster-than-100",
                "content": "```\\n\\n    int minMoves(int target, int maxDoubles) {\\n        if(target==1) return 0;\\n        int div=0,odd=0;\\n        while(maxDoubles--){\\n            int rem = target%2;\\n            if(rem){\\n                // target--;\\n                odd++;\\n            }\\n            div++;\\n            target/=2;\\n            if(target==1) return div+odd;\\n        }\\n        int ans=div+odd+(target-1);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\n    int minMoves(int target, int maxDoubles) {\\n        if(target==1) return 0;\\n        int div=0,odd=0;\\n        while(maxDoubles--){\\n            int rem = target%2;\\n            if(rem){\\n                // target--;\\n                odd++;\\n            }\\n            div++;\\n            target/=2;\\n            if(target==1) return div+odd;\\n        }\\n        int ans=div+odd+(target-1);\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1693131,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int count=0;\\n        int start=target;\\n        for(int i=0;i<maxDoubles;i++)\\n        {\\n           if(start/2>1)\\n           {\\n               if(start%2==1)\\n               {\\n                   start--;\\n                   count++;\\n               }\\n               start=start/2;\\n               count++;\\n           }\\n            else break;\\n        }\\n        count+=start-1;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int count=0;\\n        int start=target;\\n        for(int i=0;i<maxDoubles;i++)\\n        {\\n           if(start/2>1)\\n           {\\n               if(start%2==1)\\n               {\\n                   start--;\\n                   count++;\\n               }\\n               start=start/2;\\n               count++;\\n           }\\n            else break;\\n        }\\n        count+=start-1;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693024,
                "title": "easy-javascript-js",
                "content": "```\\nvar minMoves = function(target, maxDoubles) {\\n    if (maxDoubles === 0) return target - 1;\\n    let count = 0;\\n    \\n    while (target > 1) {\\n        if (target % 2 === 0 && maxDoubles > 0) {\\n            target /= 2;\\n            maxDoubles--;\\n        } else {\\n            target--;\\n        }\\n        \\n        count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minMoves = function(target, maxDoubles) {\\n    if (maxDoubles === 0) return target - 1;\\n    let count = 0;\\n    \\n    while (target > 1) {\\n        if (target % 2 === 0 && maxDoubles > 0) {\\n            target /= 2;\\n            maxDoubles--;\\n        } else {\\n            target--;\\n        }\\n        \\n        count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3265109,
                "title": "easy-peasy-solution-just-think-backwards-reduce-target-1-not-1-target",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int minMoves(int target, int md)\\n        {\\n            int cnt = 0;\\n            while (target != 1)\\n            {\\n                if (target &1 == 1)\\n                    target--;\\n                else if (md)\\n                {\\n                    md--;\\n                    target /= 2;\\n                }\\n                else\\n                    return cnt + target - 1;\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minMoves(int target, int md)\\n        {\\n            int cnt = 0;\\n            while (target != 1)\\n            {\\n                if (target &1 == 1)\\n                    target--;\\n                else if (md)\\n                {\\n                    md--;\\n                    target /= 2;\\n                }\\n                else\\n                    return cnt + target - 1;\\n                cnt++;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153044,
                "title": "minimum-moves-to-reach-target-score-c-greedy-approach-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int steps=0;\\n        int num=target;\\n        while(num!=1){\\n            // checking if we\\'re out of double counts. This is done to reduce number of iterations as we can\\'t\\n            //double so we\\'ve only one choice i.e. reduce the num by 1\\n            if(maxDoubles==0)\\n                return steps+num-1;\\n            \\n            else if((num&1)==0){ //checking if num is even\\n                num/=2;\\n                maxDoubles--;\\n                steps++;\\n            }\\n            \\n            else{ // if both ifs are not satisified, it means num is odd\\n                num--;\\n                steps++;\\n            }\\n        }\\n        return  steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int steps=0;\\n        int num=target;\\n        while(num!=1){\\n            // checking if we\\'re out of double counts. This is done to reduce number of iterations as we can\\'t\\n            //double so we\\'ve only one choice i.e. reduce the num by 1\\n            if(maxDoubles==0)\\n                return steps+num-1;\\n            \\n            else if((num&1)==0){ //checking if num is even\\n                num/=2;\\n                maxDoubles--;\\n                steps++;\\n            }\\n            \\n            else{ // if both ifs are not satisified, it means num is odd\\n                num--;\\n                steps++;\\n            }\\n        }\\n        return  steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827198,
                "title": "beginner-friendly-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        while(target != 1){\\n            if(maxDoubles == 0) return (moves + target-1);\\n            if(target%2 != 0 && maxDoubles != 0){\\n                target--;  \\n                moves++;\\n            } \\n            if(target%2 == 0 && maxDoubles != 0){\\n                target = target/2;\\n                maxDoubles--;\\n                moves++;\\n            }\\n        }\\n        return moves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        while(target != 1){\\n            if(maxDoubles == 0) return (moves + target-1);\\n            if(target%2 != 0 && maxDoubles != 0){\\n                target--;  \\n                moves++;\\n            } \\n            if(target%2 == 0 && maxDoubles != 0){\\n                target = target/2;\\n                maxDoubles--;\\n                moves++;\\n            }\\n        }\\n        return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583123,
                "title": "c-easy-solution",
                "content": "Just thinking oppositely, I mean reaching to 1 from the target and if maxDoubles exhausted, decrease the target by 1 until it reach 1.\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        while(target > 1) {\\n            if (target % 2) {\\n                target--;\\n                ans++;\\n            }\\n            else if (maxDoubles > 0){\\n                target /= 2;\\n                ans++;\\n                maxDoubles--;\\n            }\\n            \\n            if (maxDoubles == 0) {\\n                break;\\n            }\\n        } \\n        return ans + (target - 1);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        while(target > 1) {\\n            if (target % 2) {\\n                target--;\\n                ans++;\\n            }\\n            else if (maxDoubles > 0){\\n                target /= 2;\\n                ans++;\\n                maxDoubles--;\\n            }\\n            \\n            if (maxDoubles == 0) {\\n                break;\\n            }\\n        } \\n        return ans + (target - 1);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080836,
                "title": "c-greedy-approach-faster-than-100-beginner-friendly",
                "content": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int rem=0;\\n        int count=0;\\n        \\n        while(target>=2 && maxDoubles){\\n            rem += target%2;\\n            target /= 2;\\n            count++;\\n            maxDoubles--;\\n        }\\n        return count+rem+(target-1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int rem=0;\\n        int count=0;\\n        \\n        while(target>=2 && maxDoubles){\\n            rem += target%2;\\n            target /= 2;\\n            count++;\\n            maxDoubles--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1885311,
                "title": "c-going-backwards-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        \\n        int ans = 0;\\n        while(target > 1){\\n            \\n            if(maxDoubles == 0)\\n                return ans + target - 1;\\n            \\n            if(target % 2 != 0)\\n                target--;\\n            \\n            else{\\n                target /= 2;\\n                maxDoubles--;\\n            }\\n            \\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        \\n        int ans = 0;\\n        while(target > 1){\\n            \\n            if(maxDoubles == 0)\\n                return ans + target - 1;\\n            \\n            if(target % 2 != 0)\\n                target--;\\n            \\n            else{\\n                target /= 2;\\n                maxDoubles--;\\n            }\\n            \\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722491,
                "title": "easy-solution-python-explained-30ms",
                "content": "In order to solve this question we have a `target` and a `maxDoubles` we want to start upside down from the `target` until we reach down, starting off by dividing the target by two until we\\'re out of doubles and then we keep decrementing by one \\ni.e. \\nlets say our **`target` = 19 and `maxDobules` = 2**\\n`target    moves    doubles`\\n`19          0            2`\\n`18 1 2 ` decrement target by one because 19/2 = 9.5 (fraction)\\n`9 2 1` \\n`8 3 1` decrement by one again because 9/2 = 9.5\\n`4 4 0` \\nas we don\\'t have anymore doubles we can get the remaining moves by `moves += target-1`\\n`moves = 7`\\n ```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        moves = 0\\n        while maxDoubles > 0 and target > 1:\\n            if target % 2 == 1:\\n                target -= 1\\n            else:\\n                target //= 2\\n                maxDoubles -= 1\\n            moves += 1\\n        moves += target - 1\\n        return moves\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        moves = 0\\n        while maxDoubles > 0 and target > 1:\\n            if target % 2 == 1:\\n                target -= 1\\n            else:\\n                target //= 2\\n                maxDoubles -= 1\\n            moves += 1\\n        moves += target - 1\\n        return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715764,
                "title": "c-easy-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int step=0;\\n        while(maxDoubles && target!=1){\\n            if (target%2!=0){\\n                target--;\\n                step++;\\n            }\\n            target/=2;\\n            step++;\\n            maxDoubles--;\\n        }\\n        if (target) step+=(target-1);\\n        return step;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int step=0;\\n        while(maxDoubles && target!=1){\\n            if (target%2!=0){\\n                target--;\\n                step++;\\n            }\\n            target/=2;\\n            step++;\\n            maxDoubles--;\\n        }\\n        if (target) step+=(target-1);\\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702595,
                "title": "go-forwards",
                "content": "Some of you might be interested in a greedy solution going from `1` to `target`, so here we go.\\n\\n**Same intuition:** \\n* use as many **double** operations as possible.\\n* use the **double** operations on bigger numbers (as late as possible without overshooting).\\n\\nThe maximum **double** operations we can use is `k = min(log2(target), maxDoubles)`.\\nWe should **increment** if `x < target / 2^k`, otherwise **double**.\\n\\n**Naive Implementation (TLE)**\\nThis simple implementation shows the idea clearly, but the sequential **increment** operations take too long.\\nThe optimized versions below skip straight to `x = target / 2^k` without doing sequential increments.\\n```python\\ndef minMoves(self, target, maxDoubles):\\n\\tres = 0\\n\\tk = min(maxDoubles, int(log(target, 2)))\\n\\tx = 1\\n\\twhile x < target:\\n\\t\\tif x < target // 2**k:\\n\\t\\t\\tx += 1\\n\\t\\telse:\\n\\t\\t\\tx *= 2\\n\\t\\t\\tk -= 1\\n\\t\\tres += 1\\n\\treturn res\\n```\\n**Python**\\n```python\\ndef minMoves(self, target, maxDoubles):\\n\\tres = 0\\n\\tk = min(maxDoubles, int(log(target, 2)))\\n\\tx = 1\\n\\twhile x < target:\\n\\t\\ty = target >> k\\n\\t\\tif x < y:\\n\\t\\t\\tres += y - x\\n\\t\\t\\tx = y\\n\\t\\telse:\\n\\t\\t\\tx *= 2\\n\\t\\t\\tk -= 1\\n\\t\\t\\tres += 1\\n\\treturn res\\n```\\n\\n**C++**\\n```c++\\nint minMoves(int target, int maxDoubles) {\\n\\tint res = 0;\\n\\tint k = min(maxDoubles, 31 - __builtin_clz(target));\\n\\tint x = 1;\\n\\twhile (x < target) {\\n\\t\\tint y = target >> k;\\n\\t\\tif (x < y) {\\n\\t\\t\\tres += y - x;\\n\\t\\t\\tx = y;\\n\\t\\t} else {\\n\\t\\t\\tx *= 2;\\n\\t\\t\\tk--;\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minMoves(self, target, maxDoubles):\\n\\tres = 0\\n\\tk = min(maxDoubles, int(log(target, 2)))\\n\\tx = 1\\n\\twhile x < target:\\n\\t\\tif x < target // 2**k:\\n\\t\\t\\tx += 1\\n\\t\\telse:\\n\\t\\t\\tx *= 2\\n\\t\\t\\tk -= 1\\n\\t\\tres += 1\\n\\treturn res\\n```\n```python\\ndef minMoves(self, target, maxDoubles):\\n\\tres = 0\\n\\tk = min(maxDoubles, int(log(target, 2)))\\n\\tx = 1\\n\\twhile x < target:\\n\\t\\ty = target >> k\\n\\t\\tif x < y:\\n\\t\\t\\tres += y - x\\n\\t\\t\\tx = y\\n\\t\\telse:\\n\\t\\t\\tx *= 2\\n\\t\\t\\tk -= 1\\n\\t\\t\\tres += 1\\n\\treturn res\\n```\n```c++\\nint minMoves(int target, int maxDoubles) {\\n\\tint res = 0;\\n\\tint k = min(maxDoubles, 31 - __builtin_clz(target));\\n\\tint x = 1;\\n\\twhile (x < target) {\\n\\t\\tint y = target >> k;\\n\\t\\tif (x < y) {\\n\\t\\t\\tres += y - x;\\n\\t\\t\\tx = y;\\n\\t\\t} else {\\n\\t\\t\\tx *= 2;\\n\\t\\t\\tk--;\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1698537,
                "title": "easy-java-recursion",
                "content": "\\n        \\n        // base case: \\n        if (target == 1) {\\n            return 0;\\n        }\\n        \\n\\t\\t// we use Double, move + 1\\n        if(target % 2 == 0 && maxDoubles > 0) {\\n            return 1 + minMoves(target/2, maxDoubles -1);\\n        }\\n        \\n\\t\\t// we use Incremental, move + 1\\n        else if (target % 2 != 0 && maxDoubles > 0){\\n            return 1 + minMoves (target - 1, maxDoubles);\\n        }\\n\\t\\t// no Double left, return what\\'s left, since we can only use Incremental\\n        else {\\n            return target - 1;\\n        }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\n        \\n        // base case: \\n        if (target == 1) {\\n            return 0;\\n        }\\n        \\n\\t\\t// we use Double, move + 1\\n        if(target % 2 == 0 && maxDoubles > 0) {\\n            return 1 + minMoves(target/2, maxDoubles -1);\\n        }\\n        \\n\\t\\t// we use Incremental, move + 1\\n        else if (target % 2 != 0 && maxDoubles > 0){\\n            return 1 + minMoves (target - 1, maxDoubles);\\n        }\\n\\t\\t// no Double left, return what\\'s left, since we can only use Incremental\\n        else {\\n            return target - 1;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1697355,
                "title": "c-solution-with-inline-comments",
                "content": "The idea is to go backward and take half when is possible (even number)\\n\\n````\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int count = 0;\\n        while(maxDoubles>0 && target>1){ // we have to check also target>1 because it is possible to have more \\'take half\\' moves than needed\\n            if(target%2==0){ // target is even\\n                maxDoubles--; // we decrease our \\'take half\\' moves\\n                target/=2; // we take the half of target\\n            }\\n            else target--; // if we don\\'t take half then we decrease by 1;\\n            count++; // whatever is the move we increase the moves counter\\n        }\\n        return count+target-1; // we return the moves counter plus the target that is the same of counting all the decreasing by 1 moves till the end.\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int count = 0;\\n        while(maxDoubles>0 && target>1){ // we have to check also target>1 because it is possible to have more \\'take half\\' moves than needed\\n            if(target%2==0){ // target is even\\n                maxDoubles--; // we decrease our \\'take half\\' moves\\n                target/=2; // we take the half of target\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1693544,
                "title": "32ms-simple-if-else-100-faster-o-n-soln",
                "content": "Please UPVOTE if u understand properly.\\n\\nExplanation:\\n\\tImportant Note\\n\\t1) Going from (target -> 1) is fater than  going from (1 -> target)\\n\\t2) Right shift operator is faster than dividing by 2( instead of target by 2 I use ( target>>1))\\n\\t\\n\\t\\n\\tif maxDoubles is 0  then we can only decrement by 1.  \\n\\tso returning current step + target - 1 (difference between target and 1 )\\n\\t\\n\\tif target is even,  simply right shift by 1 ( same as divide by 2 but faster)\\n\\tif its odd decrement by 1 \\n\\t\\n\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        res = 0 \\n        while( target > 1 ):\\n            if maxDoubles==0:\\n                return res+(target-1)\\n            if target % 2 == 0:\\n                target = target>>1 \\n                maxDoubles-=1 \\n            else:\\n                target-=1 \\n            res+=1\\n        return res\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        res = 0 \\n        while( target > 1 ):\\n            if maxDoubles==0:\\n                return res+(target-1)\\n            if target % 2 == 0:\\n                target = target>>1 \\n                maxDoubles-=1 \\n            else:\\n                target-=1 \\n            res+=1\\n        return res\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1693538,
                "title": "simple-math-logic-c-0ms-faster-than-100-online-submissions",
                "content": "\\n**Plz upvote if you  liked it ,Thanks**\\n```\\nint minMoves(int target, int maxDoubles) {\\n        if(target==2){\\n            return 1;\\n        }\\n        int count=maxDoubles;\\n        int ans=0;\\n        while(count && target>1){\\n            int rem=target%2;\\n            target=target/2;\\n            ans+=(rem+1);\\n            count--;\\n        }\\n        if(target>1){\\n            ans+=(target-1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minMoves(int target, int maxDoubles) {\\n        if(target==2){\\n            return 1;\\n        }\\n        int count=maxDoubles;\\n        int ans=0;\\n        while(count && target>1){\\n            int rem=target%2;\\n            target=target/2;\\n            ans+=(rem+1);\\n            count--;\\n        }\\n        if(target>1){\\n            ans+=(target-1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693455,
                "title": "c-recursive-approach",
                "content": "````\\nclass Solution {\\npublic:\\n     \\n    int minMoves(int target, int maxDoubles) {\\n        int min=0;\\n        if(target==1)\\n            return 0;\\n        \\n        if(target%2==0 && maxDoubles>=1)\\n        {\\n            return 1+minMoves(target/2,maxDoubles-1);\\n        }\\n        if(target%2!=0 || maxDoubles>0)\\n        {\\n            return 1+minMoves(target-1,maxDoubles);\\n        }\\n        if(target%2!=0 || maxDoubles==0) // if we run out of double moves simply return \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//remaining target -1(we have to reach 1 not zero)  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//this condition helps to counter recursion stack overflow\\n        {\\n            return target-1;\\n        }        \\n        return 0;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n     \\n    int minMoves(int target, int maxDoubles) {\\n        int min=0;\\n        if(target==1)\\n            return 0;\\n        \\n        if(target%2==0 && maxDoubles>=1)\\n        {\\n            return 1+minMoves(target/2,maxDoubles-1);\\n        }\\n        if(target%2!=0 || maxDoubles>0)\\n        {\\n            return 1+minMoves(target-1,maxDoubles);\\n        }\\n        if(target%2!=0 || maxDoubles==0) // if we run out of double moves simply return \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//remaining target -1(we have to reach 1 not zero)  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//this condition helps to counter recursion stack overflow\\n        {\\n            return target-1;\\n        }        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693346,
                "title": "cpp-easy-code-one-go-accepted-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if ( maxDoubles == 0 ) {\\n            return ( target - 1);\\n        }\\n        \\n        \\n        int carry = 0 , pro = target;\\n        \\n        \\n        if ( (int)log2(target) <= maxDoubles  ){\\n            while ( pro > 0 and pro > 1){\\n                carry += pro % 2;   \\n                pro >>= 1;\\n                \\n            }\\n            \\n            \\n            int res = (int)log2(target) + carry;\\n            return res;\\n        }\\n        \\n        int res = 0 ;\\n        if ( maxDoubles > 0 and ( int )log2(target) >=  maxDoubles ){\\n            carry += maxDoubles;\\n          while ( maxDoubles > 0 ){\\n              carry += target % 2;\\n              res = (int)target >> 1;\\n              target >>= 1;\\n             \\n              maxDoubles --;\\n          }  \\n            \\n           \\n            carry += ( res - 1);\\n            \\n            return carry;\\n        }\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if ( maxDoubles == 0 ) {\\n            return ( target - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1693268,
                "title": "go-backward-then-solve-it-using-divide-and-modulo",
                "content": "Basically find three variables:\\nCorner case if no maxDoubles then we return target-1\\n(Since only increment operator)\\n\\nWe work our way backwards:\\n1. If odd number we increment+=1\\n2. Divide by 2 to use maxDoubles\\n\\nreturn increment +used_maxdoubles and remaining (target-1)\\n\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        if maxDoubles == 0:\\n            return target-1\\n        increment = 0\\n        multiple = 0\\n        while target!=1 and maxDoubles:\\n            rem = target%2  #(Used by our increment operator)\\n            increment+=rem\\n        \\n            divide = (target-rem)//2  #(Used by our multiple operator)\\n            maxDoubles-=1        #(Decresing allowed double operator)\\n            multiple+=1\\n            target = divide\\n        return (target-1+increment+multiple) \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        if maxDoubles == 0:\\n            return target-1\\n        increment = 0\\n        multiple = 0\\n        while target!=1 and maxDoubles:\\n            rem = target%2  #(Used by our increment operator)\\n            increment+=rem\\n        \\n            divide = (target-rem)//2  #(Used by our multiple operator)\\n            maxDoubles-=1        #(Decresing allowed double operator)\\n            multiple+=1\\n            target = divide\\n        return (target-1+increment+multiple) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693259,
                "title": "java-easy-solution-worst-case-complexity-o-n",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int count=0;\\n        while(maxDoubles>0&& target>0){\\n            if(target%2==1){\\n                count++;\\n                target--;\\n            }else{\\n                count++;\\n                target/=2;\\n                maxDoubles--;\\n            }    \\n        }\\n        count+=(target-1);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int count=0;\\n        while(maxDoubles>0&& target>0){\\n            if(target%2==1){\\n                count++;\\n                target--;\\n            }else{\\n                count++;\\n                target/=2;\\n                maxDoubles--;\\n            }    \\n        }\\n        count+=(target-1);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693159,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minMoves(int t, int md) {\\n        int count=0;\\n        if(md==0){\\n            return t-1;\\n        }\\n        while(t!=1){\\n            if(t%2==0 && md>0){\\n                t/=2;\\n                md--;\\n                count++;\\n            }\\n            else if(t>1 && md==0){\\n                count+=t-1;\\n                t=1;\\n                md--;\\n            }\\n            else{\\n                t--;\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int t, int md) {\\n        int count=0;\\n        if(md==0){\\n            return t-1;\\n        }\\n        while(t!=1){\\n            if(t%2==0 && md>0){\\n                t/=2;\\n                md--;\\n                count++;\\n            }\\n            else if(t>1 && md==0){\\n                count+=t-1;\\n                t=1;\\n                md--;\\n            }\\n            else{\\n                t--;\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693065,
                "title": "c-easy-iterative",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minMoves(int target, int maxDoubles) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\twhile (target && maxDoubles) {\\n\\t\\t\\t\\tif (target % 2){\\n\\t\\t\\t\\t\\t--target;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t--maxDoubles;\\n\\t\\t\\t\\t\\ttarget /= 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t++res;\\n\\t\\t\\t}\\n\\t\\t\\treturn res + target - 1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minMoves(int target, int maxDoubles) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\twhile (target && maxDoubles) {\\n\\t\\t\\t\\tif (target % 2){\\n\\t\\t\\t\\t\\t--target;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1693054,
                "title": "python-easy-simple-solution",
                "content": "class Solution:\\n\\n    def minMoves(self, target: int, maxD: int) -> int:\\n        if maxD == 0:\\n            return target-1\\n        \\n        count = 0\\n        while target>1:\\n            if maxD>0 and target%2 == 0:\\n                target = target/2\\n                maxD = maxD-1\\n                count += 1\\n            else:\\n                target = target-1\\n                count += 1\\n                \\n            if maxD == 0:\\n                count += target-1\\n                return int(count)\\n        \\n        return int(count)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def minMoves(self, target: int, maxD: int) -> int:\\n        if maxD == 0:\\n            return target-1\\n        \\n        count = 0\\n        while target>1:\\n            if maxD>0 and target%2 == 0:\\n                target = target/2\\n                maxD = maxD-1\\n                count += 1\\n            else:\\n                target = target-1\\n                count += 1\\n                \\n            if maxD == 0:\\n                count += target-1\\n                return int(count)\\n        \\n        return int(count)",
                "codeTag": "Java"
            },
            {
                "id": 3957775,
                "title": "simple-very-very-easyyy-solution-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        while(maxDoubles > 0  && target > 1){\\n            target%2 == 0 ? moves++ : moves +=2;               \\n            target /=2;\\n            maxDoubles--;\\n        }\\n        return moves + target -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        while(maxDoubles > 0  && target > 1){\\n            target%2 == 0 ? moves++ : moves +=2;               \\n            target /=2;\\n            maxDoubles--;\\n        }\\n        return moves + target -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945121,
                "title": "easy-understandable-greedy-solution-beginners-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int two) {\\n        int moves=0;\\n       while(target>1){\\n           if(two>0){\\n       if(target % 2 == 0){\\n           target/=2;\\n           two--;\\n           moves++;\\n     }\\n    else if(target % 2 != 0){\\n         target--;\\n         moves++;\\n     }\\n    }\\n    else return moves+target-1;\\n       }\\n    return moves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int two) {\\n        int moves=0;\\n       while(target>1){\\n           if(two>0){\\n       if(target % 2 == 0){\\n           target/=2;\\n           two--;\\n           moves++;\\n     }\\n    else if(target % 2 != 0){\\n         target--;\\n         moves++;\\n     }\\n    }\\n    else return moves+target-1;\\n       }\\n    return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698604,
                "title": "while-loop-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        // if(maxDoubles)\\n        int count = 0;\\n        while(target!=1){\\n            if(maxDoubles>0){\\n                if(target%2==0){\\n                    target/=2;\\n                    maxDoubles--;\\n                }else{\\n                    target--;\\n                }\\n            }else{\\n                count += target-2;\\n                target=1;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        // if(maxDoubles)\\n        int count = 0;\\n        while(target!=1){\\n            if(maxDoubles>0){\\n                if(target%2==0){\\n                    target/=2;\\n                    maxDoubles--;\\n                }else{\\n                    target--;\\n                }\\n            }else{\\n                count += target-2;\\n                target=1;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555046,
                "title": "easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\n\\n int minMoves(int target, int maxDoubles) {\\n\\n        //move target -> 1\\n\\n        int count=0;\\n        while(target!=1)\\n    \\n            if(target%2==0 && maxDoubles!=0) // if target is even then divide by 2.\\n            {\\n                target=target/2;\\n                count++;\\n                maxDoubles--;\\n            }\\n            else if(target%2!=0 && maxDoubles!=0) // if target is odd then simply decrement.\\n            {\\n                target--;\\n                count++;\\n            }\\n            else           // if maxDoubles is \\'0\\' , then only left choice is to\\n            {             // decrement target until it reaches to 1. so directly take the count.\\n                count+=target-1;\\n                target=1;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n# Code\\n```\\n\\n int minMoves(int target, int maxDoubles) {\\n\\n        //move target -> 1\\n\\n        int count=0;\\n        while(target!=1)\\n    \\n            if(target%2==0 && maxDoubles!=0) // if target is even then divide by 2.\\n            {\\n                target=target/2;\\n                count++;\\n                maxDoubles--;\\n            }\\n            else if(target%2!=0 && maxDoubles!=0) // if target is odd then simply decrement.\\n            {\\n                target--;\\n                count++;\\n            }\\n            else           // if maxDoubles is \\'0\\' , then only left choice is to\\n            {             // decrement target until it reaches to 1. so directly take the count.\\n                count+=target-1;\\n                target=1;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3366772,
                "title": "java-very-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int c=0;\\n        while(target>1 && maxDoubles>0)\\n        {\\n            if(target%2==0)\\n            {\\n                maxDoubles-=1;\\n                target/=2;\\n                c+=1;\\n            }\\n            else\\n            {\\n                target-=1;\\n                c+=1;\\n            }\\n        }\\n        return c+(target-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int c=0;\\n        while(target>1 && maxDoubles>0)\\n        {\\n            if(target%2==0)\\n            {\\n                maxDoubles-=1;\\n                target/=2;\\n                c+=1;\\n            }\\n            else\\n            {\\n                target-=1;\\n                c+=1;\\n            }\\n        }\\n        return c+(target-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358656,
                "title": "easy-python-cpp-solutions",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt=0;\\n        while(target>1 && maxDoubles>0){\\n            if(target%2==0){\\n                maxDoubles=maxDoubles-1;\\n                target=target/2;\\n            }\\n            else {target=target-1;}\\n            cnt=cnt+1;\\n        }\\n        if(target>1) cnt=cnt+(target-1);\\n        return cnt;\\n    }\\n};\\n```\\n# code\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        cnt=0\\n        while target>1 and maxDoubles>0:\\n            if target%2==0:\\n                target=target//2\\n                maxDoubles-=1\\n            else:\\n                target-=1\\n            cnt+=1\\n        if target>1:cnt+=target-1\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt=0;\\n        while(target>1 && maxDoubles>0){\\n            if(target%2==0){\\n                maxDoubles=maxDoubles-1;\\n                target=target/2;\\n            }\\n            else {target=target-1;}\\n            cnt=cnt+1;\\n        }\\n        if(target>1) cnt=cnt+(target-1);\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        cnt=0\\n        while target>1 and maxDoubles>0:\\n            if target%2==0:\\n                target=target//2\\n                maxDoubles-=1\\n            else:\\n                target-=1\\n            cnt+=1\\n        if target>1:cnt+=target-1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827459,
                "title": "divide-most-optimal-java-solution",
                "content": "```\\n  public int minMoves(int target, int maxDoubles) {\\n        int count = 0 ; \\n        while(target>1&&maxDoubles>0){\\n            count+=(target&1)+1;\\n            target>>=1;\\n            maxDoubles--;\\n        }\\n        return count+target-1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int minMoves(int target, int maxDoubles) {\\n        int count = 0 ; \\n        while(target>1&&maxDoubles>0){\\n            count+=(target&1)+1;\\n            target>>=1;\\n            maxDoubles--;\\n        }\\n        return count+target-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2810842,
                "title": "faster-than-100-easy-to-understand-c",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n    int count=0,r=0;\\n    while(maxDoubles>0 && target!=1){\\n        count+=(target%2 +1);\\n        target/=2;\\n        maxDoubles--;\\n    }\\n    count+=(target-1);\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n    int count=0,r=0;\\n    while(maxDoubles>0 && target!=1){\\n        count+=(target%2 +1);\\n        target/=2;\\n        maxDoubles--;\\n    }\\n    count+=(target-1);\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788251,
                "title": "java-greedy-100-faster-easy-to-understand-upvote",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        \\n        int moves = 0;\\n\\n        while(target > 1 && maxDoubles > 0){\\n\\n            if(target % 2 == 1) target -= 1;\\n            else {\\n                target /= 2;\\n                maxDoubles--;\\n            }\\n            moves++;\\n        }\\n        return target == 1 ? moves : moves + (target - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        \\n        int moves = 0;\\n\\n        while(target > 1 && maxDoubles > 0){\\n\\n            if(target % 2 == 1) target -= 1;\\n            else {\\n                target /= 2;\\n                maxDoubles--;\\n            }\\n            moves++;\\n        }\\n        return target == 1 ? moves : moves + (target - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764599,
                "title": "go-backwards",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int steps=0;\\n        while(target>1){\\n            if(maxDoubles==0){\\n                return steps+target-1;\\n            }\\n            if(target%2!=0){\\n                target--;\\n                steps++;\\n            }\\n            else{\\n                target/=2;\\n                steps++;\\n                maxDoubles--;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int steps=0;\\n        while(target>1){\\n            if(maxDoubles==0){\\n                return steps+target-1;\\n            }\\n            if(target%2!=0){\\n                target--;\\n                steps++;\\n            }\\n            else{\\n                target/=2;\\n                steps++;\\n                maxDoubles--;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638462,
                "title": "c-0ms-100-faster-greedy-backward-method-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/19cd8c5f-3cf4-491c-b55c-0e87681ecdcd_1664452788.8030686.png)\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        \\n      int moves = 0;\\n      \\n      while(target != 1)\\n      {\\n        if(maxDoubles == 0) return (target-1 + moves);\\n        \\n        if(maxDoubles != 0 && target%2 == 0)\\n        {\\n          target /= 2;\\n          maxDoubles--;\\n          moves++;\\n        }\\n        \\n        else\\n        {\\n          target--;\\n          moves++;\\n        }\\n         \\n      }\\n      \\n      return moves;\\n       \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        \\n      int moves = 0;\\n      \\n      while(target != 1)\\n      {\\n        if(maxDoubles == 0) return (target-1 + moves);\\n        \\n        if(maxDoubles != 0 && target%2 == 0)\\n        {\\n          target /= 2;\\n          maxDoubles--;\\n          moves++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2561555,
                "title": "c-intuitive-approach",
                "content": "iF we just move backwards instead. I try to make 1 from target. This way, whatever number we have, our end goal will be to make 1. This eases the problem.\\nSo, we have two operations, \\n<li> Remove 1 from number</li>\\n<li> Divide the number by 2 </li>\\n\\nGoing greedly, we keep on dividing the number for as long as we can, and when we finish `maxDoubles`, ie we can not divide anymore, we just return the `remaining_number - 1` becaues that is what it would cost us to make 1 from that number. \\n\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        while(target>1){\\n            if(maxDoubles){\\n                if(target%2) ans += 2;\\n                else ans++;\\n                target/=2;\\n                maxDoubles--;\\n            }\\n            else {\\n                ans+=target-1; \\n                break;\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        while(target>1){\\n            if(maxDoubles){\\n                if(target%2) ans += 2;\\n                else ans++;\\n                target/=2;\\n                maxDoubles--;\\n            }\\n            else {\\n                ans+=target-1; \\n                break;\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159260,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n    int count=0;\\n    if(maxDoubles==0)\\n        {\\n            return target-1;\\n        }\\n        while(target>1)\\n        {\\n            if(target%2==0 && maxDoubles>0) \\n            {\\n                target=target/2;\\n                count++;\\n                maxDoubles--;\\n                \\n            }\\n            else\\n            {\\n                target--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n    int count=0;\\n    if(maxDoubles==0)\\n        {\\n            return target-1;\\n        }\\n        while(target>1)\\n        {\\n            if(target%2==0 && maxDoubles>0) \\n            {\\n                target=target/2;\\n                count++;\\n                maxDoubles--;\\n                \\n            }\\n            else\\n            {\\n                target--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143955,
                "title": "simple-solution-faster-than-100-of-other-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int &m) {\\n        int ans=0;\\n        while(target!=1&&m!=0){\\n            ans++;\\n            if(target%2)\\n                target--;\\n         \\n            else{\\n                target/=2;\\n                m--; \\n            }\\n        }\\n    return ans+target-1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int &m) {\\n        int ans=0;\\n        while(target!=1&&m!=0){\\n            ans++;\\n            if(target%2)\\n                target--;\\n         \\n            else{\\n                target/=2;\\n                m--; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2121549,
                "title": "c-solution",
                "content": "```\\nint minMoves(int target, int maxDoubles){\\n    if (target == 1){\\n        return 0;\\n    }\\n    if (maxDoubles > 0 && target % 2 == 0){\\n        return 1 + minMoves(target/2, maxDoubles-1);\\n    }\\n    if (maxDoubles > 0){\\n        return 1 + minMoves(target-1, maxDoubles);\\n    }\\n    return target-1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMoves(int target, int maxDoubles){\\n    if (target == 1){\\n        return 0;\\n    }\\n    if (maxDoubles > 0 && target % 2 == 0){\\n        return 1 + minMoves(target/2, maxDoubles-1);\\n    }\\n    if (maxDoubles > 0){\\n        return 1 + minMoves(target-1, maxDoubles);\\n    }\\n    return target-1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2104885,
                "title": "c-100-fast-100-simple",
                "content": "class Solution {\\npublic:\\n\\n    int minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        while(maxDoubles>0&&target>1){\\n            if(target%2==1){\\n                ans++;\\n            }\\n            target=target/2;\\n            ans++;\\n            maxDoubles--;\\n        }\\n        return target-1+ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        while(maxDoubles>0&&target>1){\\n            if(target%2==1){\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2089341,
                "title": "python-greedy-why-not-use-all-the-doubles-first",
                "content": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        ans = 0\\n\\t\\t# greed towards double step \\n        while(maxDoubles and target!=1):\\n\\t\\t\\t# odd steps where we need to take one step in order to make it even step\\n            if(target%2 != 0):\\n                target-=1\\n            else:\\n                target//=2\\n                maxDoubles-=1\\n            ans+=1\\n\\t\\t# if all doubles are used up\\n        if(target):\\n            ans+=(target-1)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        ans = 0\\n\\t\\t# greed towards double step \\n        while(maxDoubles and target!=1):\\n\\t\\t\\t# odd steps where we need to take one step in order to make it even step\\n            if(target%2 != 0):\\n                target-=1\\n            else:\\n                target//=2\\n                maxDoubles-=1\\n            ans+=1\\n\\t\\t# if all doubles are used up\\n        if(target):\\n            ans+=(target-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083684,
                "title": "c-greedy-approach-runtime-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        while(target!=1 and maxDoubles!=0)\\n        {\\n            if((target&1)!=0)\\n                target--;\\n            else\\n            {\\n                target=target>>1;\\n                maxDoubles--;\\n            }\\n            ans++;\\n        }\\n        if(target!=1)\\n            ans=ans+target-1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        while(target!=1 and maxDoubles!=0)\\n        {\\n            if((target&1)!=0)\\n                target--;\\n            else\\n            {\\n                target=target>>1;\\n                maxDoubles--;\\n            }\\n            ans++;\\n        }\\n        if(target!=1)\\n            ans=ans+target-1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083544,
                "title": "deep-dive-easy-explanation-c",
                "content": "**Approach:** Here we have to basically minimize the number of moves so that we can reach to the \\'target\\' value. But we have only two moves that we can have in a single step, and also the 2nd possible move we have a fixed numver of moves (maxDoubles) that we can have. So, the thing is we have to use the \\'maxDoubles\\' very wisely. But how do we know  when to double the current value when not?\\nIf we simply start from 1 then we basically don;t have any idea about it. But what id we start from the reverse direction? What I meant is- we will start from the \\'target\\' value and from that value we\\'ll try to reach 0. The advantage that we\\'ll get in this way is- we;ll be able to use the \\'maxDoubles\\' properly that will help us to minimize the number of moves. Let\\'s see how we implement that-\\n\\n\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt=0;\\n        while(target && maxDoubles){\\n            target%2==0 ? target/=2, maxDoubles-- : target--;  // when the \\'target\\' is even we tend to divide the number by 2 (only if \\'maxDouble\\' is NOT 0)\\n            cnt++;\\n        }\\n        \\n        if(maxDoubles ==0) cnt+=target;  // if the \\'maxDouble\\' becomes 0 we don\\'t need to continue any loop, because we are left with the INCREMENT option only! \\n        return cnt-1;  // as we took the cnt=0, we have to reduce 1 while we return it. You can do that diferently as well\\n    }\\n\\t \\n\\t\\n**Time Complexity:** In case the \\'maxDouble\\' is 0 our program takes O(1) TC only, but as we are interested in worst case we focus on the loop. The runtime of the loop depends on \\'target\\' and \\'maxDoubles\\'. \\'maxDoubles\\' runs at max \\'maxDoubles\\' times which happens only when the current value is EVEN, whereas \\'target\\' gets decremented by 1 when we get the current value as ODD. But we are sure it\\'s gonna never take more than LogN times, because two consecutive decrements will never happen. So, combinedly we can say the Time Complexity as **O(logN) + O(maxDouble)** . But the O(logN) is dominant here, so we write **O(logN)** only.\\n\\n**Space Complexity:** **O(1)**, as we don;t use any extra space here!",
                "solutionTags": [
                    "C"
                ],
                "code": "**Approach:** Here we have to basically minimize the number of moves so that we can reach to the \\'target\\' value. But we have only two moves that we can have in a single step, and also the 2nd possible move we have a fixed numver of moves (maxDoubles) that we can have. So, the thing is we have to use the \\'maxDoubles\\' very wisely. But how do we know  when to double the current value when not?\\nIf we simply start from 1 then we basically don;t have any idea about it. But what id we start from the reverse direction? What I meant is- we will start from the \\'target\\' value and from that value we\\'ll try to reach 0. The advantage that we\\'ll get in this way is- we;ll be able to use the \\'maxDoubles\\' properly that will help us to minimize the number of moves. Let\\'s see how we implement that-\\n\\n\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt=0;\\n        while(target && maxDoubles){\\n            target%2==0 ? target/=2, maxDoubles-- : target--;  // when the \\'target\\' is even we tend to divide the number by 2 (only if \\'maxDouble\\' is NOT 0)\\n            cnt++;\\n        }\\n        \\n        if(maxDoubles ==0) cnt+=target;  // if the \\'maxDouble\\' becomes 0 we don\\'t need to continue any loop, because we are left with the INCREMENT option only! \\n        return cnt-1;  // as we took the cnt=0, we have to reduce 1 while we return it. You can do that diferently as well\\n    }\\n\\t \\n\\t\\n**Time Complexity:** In case the \\'maxDouble\\' is 0 our program takes O(1) TC only, but as we are interested in worst case we focus on the loop. The runtime of the loop depends on \\'target\\' and \\'maxDoubles\\'. \\'maxDoubles\\' runs at max \\'maxDoubles\\' times which happens only when the current value is EVEN, whereas \\'target\\' gets decremented by 1 when we get the current value as ODD. But we are sure it\\'s gonna never take more than LogN times, because two consecutive decrements will never happen. So, combinedly we can say the Time Complexity as **O(logN) + O(maxDouble)** . But the O(logN) is dominant here, so we write **O(logN)** only.\\n\\n**Space Complexity:** **O(1)**, as we don;t use any extra space here!",
                "codeTag": "Unknown"
            },
            {
                "id": 2082380,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int md)\\n    { int c=0;\\n            while(t>1&&md>0)\\n            {\\n                if(t%2==0)\\n                {t=t/2;\\n                 c++;\\n                 md--;\\n                }\\n                else\\n                {\\n                    t=t-1;\\n                    c++;\\n                } \\n            } \\n     c+=t;\\n     return c-1; \\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int md)\\n    { int c=0;\\n            while(t>1&&md>0)\\n            {\\n                if(t%2==0)\\n                {t=t/2;\\n                 c++;\\n                 md--;\\n                }\\n                else\\n                {\\n                    t=t-1;\\n                    c++;\\n                } \\n            } \\n     c+=t;\\n     return c-1; \\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080828,
                "title": "c-0ms-faster-than-100-00",
                "content": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int d = 0;\\n        int ans = 0;\\n        while(target >= 2 && maxDoubles){\\n            d += target%2;\\n            target = target/2;\\n            ans++;\\n            maxDoubles--;\\n        }\\n        return d+ans+(target-1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int d = 0;\\n        int ans = 0;\\n        while(target >= 2 && maxDoubles){\\n            d += target%2;\\n            target = target/2;\\n            ans++;\\n            maxDoubles--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2080583,
                "title": "easy-c-code-with-explaination-0ms-faster-than-100",
                "content": "```\\n/*Here instead of multiplying we think geedily ans take the number and bring it to 1;\\ncarry is used to count the increment when the number is odd \\ncount is used to count the total nuber of times we are performing divide operation,where we try to perform max divide operations possible\\nIn the last line we add count(number of divisions by 2),carry(gives the number of increments) and target if it is there .There is target-1 as if we have target 1 then we dont have to do any operations\\nTC:O(n)  SC:O(1);\\n*/\\n\\n```class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        int carry=0;\\n        int count=0;\\n        while(maxDoubles-- && target!=1){\\n            if(target%2!=0){\\n                target/=2;\\n                carry++;\\n            }\\n            else{\\n                target/=2;\\n            }\\n            count++;\\n        }\\n        \\n        return count+carry+(target-1);\\n    }\\n};\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n/*Here instead of multiplying we think geedily ans take the number and bring it to 1;\\ncarry is used to count the increment when the number is odd \\ncount is used to count the total nuber of times we are performing divide operation,where we try to perform max divide operations possible\\nIn the last line we add count(number of divisions by 2),carry(gives the number of increments) and target if it is there .There is target-1 as if we have target 1 then we dont have to do any operations\\nTC:O(n)  SC:O(1);\\n*/\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2080325,
                "title": "runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int m) {\\n        int cnt = 0;\\n        if(m==0){\\n            return target -1;\\n        }\\n        int n = m;\\n        while(target!=1){\\n            if(target%2==0 && n!=0){\\n                target /= 2;\\n                n--;\\n            }\\n            else if(n==0){\\n                break;\\n            }\\n            else{\\n                target--;\\n            }\\n            cnt++;\\n        }\\n        \\n        return target + cnt -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int m) {\\n        int cnt = 0;\\n        if(m==0){\\n            return target -1;\\n        }\\n        int n = m;\\n        while(target!=1){\\n            if(target%2==0 && n!=0){\\n                target /= 2;\\n                n--;\\n            }\\n            else if(n==0){\\n                break;\\n            }\\n            else{\\n                target--;\\n            }\\n            cnt++;\\n        }\\n        \\n        return target + cnt -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080133,
                "title": "java-soln-0-ms",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int i = target;\\n        int res = 0;\\n        \\n        while(i > 1){\\n            if(i % 2 == 0 && maxDoubles > 0){\\n                i /= 2;\\n                maxDoubles--;\\n            }\\n            else{\\n                i--;\\n            }\\n            res++;\\n            if(maxDoubles == 0){\\n                res += i - 1;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int i = target;\\n        int res = 0;\\n        \\n        while(i > 1){\\n            if(i % 2 == 0 && maxDoubles > 0){\\n                i /= 2;\\n                maxDoubles--;\\n            }\\n            else{\\n                i--;\\n            }\\n            res++;\\n            if(maxDoubles == 0){\\n                res += i - 1;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079625,
                "title": "rust-greedy-bitwise-ops-solutions",
                "content": "\\n### Simulation/Greedy\\n\\n```rust\\npub fn min_moves(target: i32, max_doubles: i32) -> i32 {\\n    let mut doubles = max_doubles;\\n    let mut num = target;\\n    let mut steps = 0;\\n\\n    // Check for `doubles` in order to avoid unnecessary looping if the \\n    // number is big, but we cannot perform more `double` operations\\n    while num > 1 && doubles > 0 {\\n        if num & 1 != 0 {\\n            num -= 1;\\n        } else {\\n            num /= 2;\\n            doubles -= 1;\\n        }\\n\\n        steps += 1;\\n    }\\n\\n    // Fast path if `doubles` is zero\\n    if num > 1 {\\n        steps += num - 1;\\n    }\\n\\n    steps\\n}\\n```\\n\\n### Constant time solution using bitwise operations\\n\\n```rust\\npub fn min_moves(target: i32, max_doubles: i32) -> i32 {\\n    // This is the number of division operations that we are allowed to do.\\n    // The maximum number of possible divisions is the number of bits to the \\n    // right of the most significant 1 bit:\\n    // * 0000_0001 => 0 divisions (no bits to the right of the 1 MSB)\\n    // * 0000_1000 => 3 divisions\\n    // * 1000_0000 => 7 divisions\\n    // * 1010_1010 => 7 divisions\\n    let divisions = max_doubles.min((i32::BITS - 1 - target.leading_zeros()) as i32);\\n\\n    // The difference is pretty obvious - it\\'s the same as in the \\n    // naive solution. Once we can no longer do divisions, we just \\n    // subtract one from the value (because we start from ONE to TARGET), \\n    // and this is the number of subtractions that we would need to do\\n    // in case we were looping in the naive solution\\n    let difference = (target >> divisions) - 1;\\n\\n    // So far so good, but how many subtractions we need to perform in between \\n    // the divisions (not in general, only in between the divisions). Example: \\n    // * 18/2 => 9-1 => 8/2 => 4/2 => 2/2 => 1 \\n    // So in this case we need to do 1 subtraction. \\n    //\\n    // This too can be computed using bitwise operations, by computing a mask \\n    // of 1 bits that covers the bits that will be \"divided\":\\n    // Number: ..10101\\n    // Mask:   ..00111\\n    // Result: ..00101\\n    // Thus we end up with 2 one bits set. We would need to switch them to 0\\n    // in order to continue with the divisions, and the only way to do is \\n    // via subtracting 1\\n    let mask = (1 << divisions) - 1;\\n    let subtractions = (target & mask).count_ones() as i32;\\n\\n    // The result is the sum of the number of division operations, \\n    // plus the number of subtraction operations in between the divisions,\\n    // plus the number of subtractions that would need to be performed\\n    // on the remaining value\\n    divisions + subtractions + difference\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```rust\\npub fn min_moves(target: i32, max_doubles: i32) -> i32 {\\n    let mut doubles = max_doubles;\\n    let mut num = target;\\n    let mut steps = 0;\\n\\n    // Check for `doubles` in order to avoid unnecessary looping if the \\n    // number is big, but we cannot perform more `double` operations\\n    while num > 1 && doubles > 0 {\\n        if num & 1 != 0 {\\n            num -= 1;\\n        } else {\\n            num /= 2;\\n            doubles -= 1;\\n        }\\n\\n        steps += 1;\\n    }\\n\\n    // Fast path if `doubles` is zero\\n    if num > 1 {\\n        steps += num - 1;\\n    }\\n\\n    steps\\n}\\n```\n```rust\\npub fn min_moves(target: i32, max_doubles: i32) -> i32 {\\n    // This is the number of division operations that we are allowed to do.\\n    // The maximum number of possible divisions is the number of bits to the \\n    // right of the most significant 1 bit:\\n    // * 0000_0001 => 0 divisions (no bits to the right of the 1 MSB)\\n    // * 0000_1000 => 3 divisions\\n    // * 1000_0000 => 7 divisions\\n    // * 1010_1010 => 7 divisions\\n    let divisions = max_doubles.min((i32::BITS - 1 - target.leading_zeros()) as i32);\\n\\n    // The difference is pretty obvious - it\\'s the same as in the \\n    // naive solution. Once we can no longer do divisions, we just \\n    // subtract one from the value (because we start from ONE to TARGET), \\n    // and this is the number of subtractions that we would need to do\\n    // in case we were looping in the naive solution\\n    let difference = (target >> divisions) - 1;\\n\\n    // So far so good, but how many subtractions we need to perform in between \\n    // the divisions (not in general, only in between the divisions). Example: \\n    // * 18/2 => 9-1 => 8/2 => 4/2 => 2/2 => 1 \\n    // So in this case we need to do 1 subtraction. \\n    //\\n    // This too can be computed using bitwise operations, by computing a mask \\n    // of 1 bits that covers the bits that will be \"divided\":\\n    // Number: ..10101\\n    // Mask:   ..00111\\n    // Result: ..00101\\n    // Thus we end up with 2 one bits set. We would need to switch them to 0\\n    // in order to continue with the divisions, and the only way to do is \\n    // via subtracting 1\\n    let mask = (1 << divisions) - 1;\\n    let subtractions = (target & mask).count_ones() as i32;\\n\\n    // The result is the sum of the number of division operations, \\n    // plus the number of subtraction operations in between the divisions,\\n    // plus the number of subtractions that would need to be performed\\n    // on the remaining value\\n    divisions + subtractions + difference\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2078620,
                "title": "go-from-back-greeady-approach-three-cases-faster-than-100",
                "content": "**First case  : ) when MaxDouble >  0 && target%2 == 0 \\n   in this case divide target by two and decrement Maxdouble by 1,and incremnt your cnt by one;\\n   Second case :) When MaxDouble >0 && Target%2 != 0\\n   in this case decremnt target by one and incremnt your cnt by one ;\\n   Last Case :) When MaxDouble == 0 (doesnot matter target%2 == 0 0r target%2 != 0)\\n    in this case incremnt your cnt by adding target-1;\\n\\t\\n\\tclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        while(target>1){\\n            if(target%2 == 0 && maxDoubles>0){\\n                target/=2;\\n                maxDoubles--;\\n                cnt++;\\n            }else if(target%2 != 0 && maxDoubles>0){\\n                cnt++;\\n                target--;\\n            }else if(maxDoubles == 0){\\n                cnt+=(target-1);\\n                break;\\n            }    \\n        }\\n        return cnt;\\n    }\\n};\\n\\n**If you find helpful Please Upvote**\\t\\n**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        while(target>1){\\n            if(target%2 == 0 && maxDoubles>0){\\n                target/=2;\\n                maxDoubles--;\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2078292,
                "title": "c-python-and-javascript-solution",
                "content": "# **python solution**\\n\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        step = 0\\n        \\n        while target > 1:\\n            if target % 2 == 1:\\n                target -= 1\\n            else:\\n                \\n                if maxDoubles:\\n                    maxDoubles -= 1\\n                    target = target // 2\\n                else:\\n                    return step + target - 1\\n            step += 1\\n        return step\\n```\\n\\n# **c++ solution**\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int step = 0;\\n        \\n        while (target > 1){\\n            if (target % 2 == 1){\\n                target--;\\n            }else{\\n                if (maxDoubles > 0){\\n                    maxDoubles--;\\n                    target /= 2;\\n                }else{\\n                    return step + target - 1;\\n                }\\n            }\\n            step++;\\n        }\\n        return step;\\n    }\\n};\\n```\\n\\n# **Javascript solution**\\n```\\nvar minMoves = function(target, maxDoubles) {\\n    //reverse the shit to reduce and divide to get to 1\\n    let step = 0;\\n    while (target > 1){\\n        if (target % 2 == 1){\\n            target--;\\n        }else{\\n            if (maxDoubles > 0){\\n                target /= 2; \\n                maxDoubles--;\\n            }else{\\n                return step + target - 1;\\n            }\\n        }\\n        step += 1;\\n    }\\n    // console.log(step);\\n    return step;\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        step = 0\\n        \\n        while target > 1:\\n            if target % 2 == 1:\\n                target -= 1\\n            else:\\n                \\n                if maxDoubles:\\n                    maxDoubles -= 1\\n                    target = target // 2\\n                else:\\n                    return step + target - 1\\n            step += 1\\n        return step\\n```\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int step = 0;\\n        \\n        while (target > 1){\\n            if (target % 2 == 1){\\n                target--;\\n            }else{\\n                if (maxDoubles > 0){\\n                    maxDoubles--;\\n                    target /= 2;\\n                }else{\\n                    return step + target - 1;\\n                }\\n            }\\n            step++;\\n        }\\n        return step;\\n    }\\n};\\n```\n```\\nvar minMoves = function(target, maxDoubles) {\\n    //reverse the shit to reduce and divide to get to 1\\n    let step = 0;\\n    while (target > 1){\\n        if (target % 2 == 1){\\n            target--;\\n        }else{\\n            if (maxDoubles > 0){\\n                target /= 2; \\n                maxDoubles--;\\n            }else{\\n                return step + target - 1;\\n            }\\n        }\\n        step += 1;\\n    }\\n    // console.log(step);\\n    return step;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078215,
                "title": "python3-easy-to-understand-plain-logic",
                "content": "**Traverse in reverse order.**\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        c=0\\n        cnt=0\\n        while target>1:\\n            if target%2!=0:\\n                target-=1\\n                c+=1\\n            else:\\n                if cnt<maxDoubles:\\n                    cnt+=1\\n                    target=target//2\\n                    c+=1\\n                else:                         # here maxDoubles are finished so we can only subtract one now.\\n                    c+=target-1\\n                    break\\n        return c\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        c=0\\n        cnt=0\\n        while target>1:\\n            if target%2!=0:\\n                target-=1\\n                c+=1\\n            else:\\n                if cnt<maxDoubles:\\n                    cnt+=1\\n                    target=target//2\\n                    c+=1\\n                else:                         # here maxDoubles are finished so we can only subtract one now.\\n                    c+=target-1\\n                    break\\n        return c\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2077629,
                "title": "simple-c-solution",
                "content": "```\\nint minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        while(target>1)\\n        {\\n            if(target%2==0 && maxDoubles)\\n            {\\n                target=target/2;\\n                maxDoubles--;\\n                ans++;\\n            }\\n            else\\n            {\\n                if(maxDoubles==0)\\n                {\\n                    ans+=target-1;\\n                    break;\\n                }\\n                target--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nint minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        while(target>1)\\n        {\\n            if(target%2==0 && maxDoubles)\\n            {\\n                target=target/2;\\n                maxDoubles--;\\n                ans++;\\n            }\\n            else\\n            {\\n                if(maxDoubles==0)\\n                {\\n                    ans+=target-1;\\n                    break;\\n                }\\n                target--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2023905,
                "title": "c-backwards-w-a-heuristic-stopping-point",
                "content": "```\\n    int minMoves(int target, int md) {\\n        int ops = 0;\\n        while (target != 1) {\\n            if (md == 0)\\n                return ops + target - 1;\\n            \\n            if (target % 2 == 0 && md > 0)\\n                target /= 2, md--;\\n            else\\n                target -= 1;\\n            \\n            ops++;\\n        }\\n        return ops;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int minMoves(int target, int md) {\\n        int ops = 0;\\n        while (target != 1) {\\n            if (md == 0)\\n                return ops + target - 1;\\n            \\n            if (target % 2 == 0 && md > 0)\\n                target /= 2, md--;\\n            else\\n                target -= 1;\\n            \\n            ops++;\\n        }\\n        return ops;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2001589,
                "title": "c-greedy-100-faster",
                "content": "*  It is optimal to use \"double\"  when values are larger . \\n*  Let\\'s say we have to reach 16 from 8 then 8->16 using one move but it will take 8 moves using a \"single\" increment.\\n*  So we will exhaust our available doubles when we have large values. It\\'s easy to implement when we go from target to 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        while(target > 1){\\n            if(maxDoubles == 0){\\n                return cnt + target-1;\\n            }\\n            if((target&1) == 0 && maxDoubles > 0){\\n                target = target/2;\\n                maxDoubles--;\\n            }else{\\n                target--;\\n            }\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        while(target > 1){\\n            if(maxDoubles == 0){\\n                return cnt + target-1;\\n            }\\n            if((target&1) == 0 && maxDoubles > 0){\\n                target = target/2;\\n                maxDoubles--;\\n            }else{\\n                target--;\\n            }\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971979,
                "title": "python-o-maxdoubles-faster-than-100",
                "content": "It is easier to go backwards.\\nSo we need to spend all doubles at the start because halving bigger number will always save us the most steps. \\nOnly problem is that you can\\'t halve numbers that arent divisible by 2. \\nIn that case you need to reduce by one. \\nInstead of reducing, i made it a bit cleaner by just adding the modulo of division and used floor division in the line below.\\nAfter that you are left with \"increments\" only and you just subtract 1 from what is left\\n\\n```\\n\\t\\tjumps = 0\\n        \\n        while maxDoubles and target > 1:\\n            jumps += 1 + target % 2\\n            target //= 2\\n            maxDoubles -= 1\\n        \\n        return jumps + target - 1\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tjumps = 0\\n        \\n        while maxDoubles and target > 1:\\n            jumps += 1 + target % 2\\n            target //= 2\\n            maxDoubles -= 1\\n        \\n        return jumps + target - 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1895636,
                "title": "faster-than-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n     \\n        \\n        int cnt=0;\\n        while(target!=1)\\n        {\\n            \\n            \\n            if(maxDoubles && target%2==0)\\n            {  cnt++;  target/=2; maxDoubles--; continue;}\\n            if(maxDoubles) {cnt++; target--; continue;}\\n            if(!maxDoubles)\\n            {cnt+=target-1; break;}\\n     \\n                \\n        }return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n     \\n        \\n        int cnt=0;\\n        while(target!=1)\\n        {\\n            \\n            \\n            if(maxDoubles && target%2==0)\\n            {  cnt++;  target/=2; maxDoubles--; continue;}\\n            if(maxDoubles) {cnt++; target--; continue;}\\n            if(!maxDoubles)\\n            {cnt+=target-1; break;}\\n     \\n                \\n        }return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894937,
                "title": "0-ms-faster-than-100-00-c-easy-to-understand",
                "content": "```\\nint minMoves(int target, int maxDoubles) {\\n        if(maxDoubles == 0)\\n            return target-1;\\n        if(target == 1)\\n            return 0;\\n        if(maxDoubles == 1){\\n            if(target & 1)\\n                return (target/2)+1;\\n            else\\n                return (target/2);\\n        }\\n        int n = target;\\n        int count = 0;\\n        while(n>1){\\n            if(maxDoubles == 0){\\n                count += n-1;\\n                break;\\n            }\\n            if(n & 1){\\n                n = n-1;\\n                count++;\\n            }\\n            if(maxDoubles > 0){\\n                maxDoubles--;\\n                n = n>>1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMoves(int target, int maxDoubles) {\\n        if(maxDoubles == 0)\\n            return target-1;\\n        if(target == 1)\\n            return 0;\\n        if(maxDoubles == 1){\\n            if(target & 1)\\n                return (target/2)+1;\\n            else\\n                return (target/2);\\n        }\\n        int n = target;\\n        int count = 0;\\n        while(n>1){\\n            if(maxDoubles == 0){\\n                count += n-1;\\n                break;\\n            }\\n            if(n & 1){\\n                n = n-1;\\n                count++;\\n            }\\n            if(maxDoubles > 0){\\n                maxDoubles--;\\n                n = n>>1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1881534,
                "title": "python-3-solution-greedy-do-the-opposite",
                "content": "```py\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        moves = 0\\n        \\n        while target > 1:\\n            if maxDoubles and target & 1 == 0:\\n                target >>= 1\\n                maxDoubles -= 1\\n            else:\\n                target -= 1\\n            \\n            moves += 1\\n            \\n            if not maxDoubles:\\n                break\\n        \\n        return (moves + target) - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```py\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        moves = 0\\n        \\n        while target > 1:\\n            if maxDoubles and target & 1 == 0:\\n                target >>= 1\\n                maxDoubles -= 1\\n            else:\\n                target -= 1\\n            \\n            moves += 1\\n            \\n            if not maxDoubles:\\n                break\\n        \\n        return (moves + target) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836777,
                "title": "java-focus-on-making-it-1-from-given-target",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        while(maxDoubles>0 && target>1){\\n            ans+=target%2;\\n            target/=2;\\n            ans++;\\n            maxDoubles--;\\n        }\\n        if(target>1){\\n            ans+=target;\\n            ans--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        while(maxDoubles>0 && target>1){\\n            ans+=target%2;\\n            target/=2;\\n            ans++;\\n            maxDoubles--;\\n        }\\n        if(target>1){\\n            ans+=target;\\n            ans--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836043,
                "title": "java-beats-100",
                "content": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        \\n        int counter = 0;\\n        \\n        while(target != 1) {\\n            if(target % 2 == 0 && maxDoubles != 0) {\\n                target = target / 2;\\n                maxDoubles--;\\n            } else if(maxDoubles == 0) {\\n                counter += target -1;\\n                break;\\n            }\\n            else if(target % 2 ==1) {\\n                target--;\\n            }\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        \\n        int counter = 0;\\n        \\n        while(target != 1) {\\n            if(target % 2 == 0 && maxDoubles != 0) {\\n                target = target / 2;\\n                maxDoubles--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1813652,
                "title": "100-faster-simplest-approach-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(maxDoubles==0){return target-1;}\\n        int count=0;\\n        int n=target;\\n        int a=maxDoubles;\\n        while(n!=1){\\n            if(n%2==0 && a>0){\\n                n=n/2;\\n                a--;\\n            }\\n            else{\\n                n=n-1;\\n            }count++;\\n            if(a==0){\\n                count+=n-1;\\n                break;\\n            }\\n        }return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(maxDoubles==0){return target-1;}\\n        int count=0;\\n        int n=target;\\n        int a=maxDoubles;\\n        while(n!=1){\\n            if(n%2==0 && a>0){\\n                n=n/2;\\n                a--;\\n            }\\n            else{\\n                n=n-1;\\n            }count++;\\n            if(a==0){\\n                count+=n-1;\\n                break;\\n            }\\n        }return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812645,
                "title": "100-solution-simplest-approach-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(maxDoubles==0){return target-1;}\\n        int count=0;\\n        int n=target;\\n        int a=maxDoubles;\\n        while(n!=1){\\n            if(n%2==0 && a>0){\\n                n=n/2;\\n                a--;\\n            }\\n            else{\\n                n=n-1;\\n            }count++;\\n            if(a==0){\\n                count+=n-1;\\n                break;\\n            }\\n        }return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(maxDoubles==0){return target-1;}\\n        int count=0;\\n        int n=target;\\n        int a=maxDoubles;\\n        while(n!=1){\\n            if(n%2==0 && a>0){\\n                n=n/2;\\n                a--;\\n            }\\n            else{\\n                n=n-1;\\n            }count++;\\n            if(a==0){\\n                count+=n-1;\\n                break;\\n            }\\n        }return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801137,
                "title": "easy-c-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int count = 0;\\n        while(target != 1 && maxDoubles != 0){\\n            if(target%2 == 0){\\n                target = target/2;\\n                maxDoubles--;\\n                count++;\\n            }\\n            else{\\n                target--;\\n                count++;\\n            }\\n        }\\n        return count + target - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int count = 0;\\n        while(target != 1 && maxDoubles != 0){\\n            if(target%2 == 0){\\n                target = target/2;\\n                maxDoubles--;\\n                count++;\\n            }\\n            else{\\n                target--;\\n                count++;\\n            }\\n        }\\n        return count + target - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789355,
                "title": "c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        while(target > 1 and maxDoubles) {\\n            if(target%2) {\\n                target--;\\n                moves++;\\n            } else {\\n                target /= 2;\\n                maxDoubles--;\\n                moves++;\\n            }\\n        }\\n        \\n        moves += target-1;\\n        return moves;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        while(target > 1 and maxDoubles) {\\n            if(target%2) {\\n                target--;\\n                moves++;\\n            } else {\\n                target /= 2;\\n                maxDoubles--;\\n                moves++;\\n            }\\n        }\\n        \\n        moves += target-1;\\n        return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772885,
                "title": "c-clean-code-easy-100-fast",
                "content": "\\t**PLEASE DO UPVOTE IF YOU UNDERSTAND.**\\n\\t\\'\\'\\'\\n\\tclass Solution {\\n\\tpublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        \\n        while(1){\\n            if(target == 1){\\n                break;\\n            }\\n            if(maxDoubles == 0){\\n                ans += target - 1;\\n                break;\\n            }\\n            \\n            if(target & 1){\\n                ans++;\\n                target--;\\n            }\\n            else if(maxDoubles>0){\\n                ans++;\\n                target/=2;\\n                maxDoubles--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\t\\'\\'\\'\\n\\t\\t**PLEASE DO UPVOTE IF YOU UNDERSTAND.**\\n\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        \\n        while(1){\\n            if(target == 1){\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1772032,
                "title": "java-recursive-100-easy-understandable",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if(target==1) return 0;\\n        if(target%2 != 0) return 1 + minMoves(target-1, maxDoubles);\\n        if(maxDoubles >0) return 1 + minMoves(target/2, maxDoubles-1);\\n        else return target-1;\\n    }\\n}\\n// Please UPVOTE if you like.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if(target==1) return 0;\\n        if(target%2 != 0) return 1 + minMoves(target-1, maxDoubles);\\n        if(maxDoubles >0) return 1 + minMoves(target/2, maxDoubles-1);\\n        else return target-1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1726416,
                "title": "minimum-moves-to-reach-target-sum-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n\\t\\tint answer = 0;\\n\\t\\tboolean flag = false;\\n\\t\\twhile (target != 1) {\\n\\t\\t\\tflag = true;\\n\\t\\t\\twhile (target % 2 == 0 && maxDoubles > 0) {\\n\\t\\t\\t\\ttarget /= 2;\\n\\t\\t\\t\\tmaxDoubles--;\\n\\t\\t\\t\\tanswer++;\\n\\t\\t\\t\\tflag = false;\\n\\t\\t\\t}\\n            if (maxDoubles == 0) {\\n\\t\\t\\t\\tanswer += target - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (flag) {\\n\\t\\t\\t\\ttarget--;\\n\\t\\t\\t\\tanswer++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn answer;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n\\t\\tint answer = 0;\\n\\t\\tboolean flag = false;\\n\\t\\twhile (target != 1) {\\n\\t\\t\\tflag = true;\\n\\t\\t\\twhile (target % 2 == 0 && maxDoubles > 0) {\\n\\t\\t\\t\\ttarget /= 2;\\n\\t\\t\\t\\tmaxDoubles--;\\n\\t\\t\\t\\tanswer++;\\n\\t\\t\\t\\tflag = false;\\n\\t\\t\\t}\\n            if (maxDoubles == 0) {\\n\\t\\t\\t\\tanswer += target - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (flag) {\\n\\t\\t\\t\\ttarget--;\\n\\t\\t\\t\\tanswer++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn answer;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716552,
                "title": "recursive-greedy-solution-c",
                "content": "This is what I came up with at first glance whilst attempting the (Virtual) [Weekly Contest 276 ](https://leetcode.com/contest/weekly-contest-276/). This solution is nowhere near perfect and beats ~33% cpp answers. \\n\\nAlthough not optimal (including even some of the if-statements, probably!), I think **NOT** doing a problem the right way the first time around is important! Different approaches like this one can help you in a tricky situation, and can also build your intuition.\\n\\nI thought of the problem CASE BY CASE and found recursion to be really simple in implementation.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        return recursive(target, maxDoubles, 0);\\n    }\\n    \\n    int recursive(int targ, int doubles, int count){\\n        if(targ == 1) return count;\\n        \\n        if(targ > 1 && doubles == 0)\\n            return targ-1 + count;\\n        \\n        if(targ % 2 == 1)\\n            return recursive(targ-1, doubles, count + 1);\\n\\n        if(doubles > 0)\\n            return recursive(targ/2, doubles - 1, count+1);\\n\\n        return 0;\\n        \\n    }\\n};\\n```\\n\\nOf course, the recursive approach can be optimized with some kind of loop in the minMoves function so that we don\\'t take up the call stack.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        return recursive(target, maxDoubles, 0);\\n    }\\n    \\n    int recursive(int targ, int doubles, int count){\\n        if(targ == 1) return count;\\n        \\n        if(targ > 1 && doubles == 0)\\n            return targ-1 + count;\\n        \\n        if(targ % 2 == 1)\\n            return recursive(targ-1, doubles, count + 1);\\n\\n        if(doubles > 0)\\n            return recursive(targ/2, doubles - 1, count+1);\\n\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714258,
                "title": "java-0ms-100-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int steps=0;\\n        //The best approach is to use the max possible halving opportunities. Hence, we run the following while loop.\\n        while(maxDoubles!=0&&target>1){\\n        //if the new target is divisible by 2, we have to take a single step to half the soln.\\n        if(target%2==0){\\n                target/=2;\\n                steps+=1;\\n                maxDoubles--;\\n        }\\n        else{\\n        //if target is odd, we will first have to make it even and then make it half. Hence, two steps per iteration.\\n                target/=2;\\n                steps+=2;\\n                maxDoubles--;\\n         }    \\n        }\\n        steps+=target-1;\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int steps=0;\\n        //The best approach is to use the max possible halving opportunities. Hence, we run the following while loop.\\n        while(maxDoubles!=0&&target>1){\\n        //if the new target is divisible by 2, we have to take a single step to half the soln.\\n        if(target%2==0){\\n                target/=2;\\n                steps+=1;\\n                maxDoubles--;\\n        }\\n        else{\\n        //if target is odd, we will first have to make it even and then make it half. Hence, two steps per iteration.\\n                target/=2;\\n                steps+=2;\\n                maxDoubles--;\\n         }    \\n        }\\n        steps+=target-1;\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706701,
                "title": "faster-than-100-cpp",
                "content": "class Solution {\\npublic:\\n\\n    int minMoves(int target, int maxDoubles) {\\n\\t\\n        int moves=0;\\n       while(maxDoubles!=0 && target!=1)\\n       { \\n           if(target%2==0 )\\n           {\\n               target=target/2;\\n               maxDoubles--;\\n               moves++;\\n           }else\\n           {\\n               target--;\\n               moves++;\\n           }\\n           \\n       }\\n        if(target!=1)\\n        {\\n            moves+=target-1;\\n        }\\n       return moves;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minMoves(int target, int maxDoubles) {\\n\\t\\n        int moves=0;\\n       while(maxDoubles!=0 && target!=1)\\n       { \\n           if(target%2==0 )\\n           {\\n               target=target/2;\\n               maxDoubles--;\\n               moves++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1704837,
                "title": "java-100-e-z-sol",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minMoves(int target, int maxDoubles) {\\n\\t\\t\\tif(maxDoubles==0) return target-1;\\n\\t\\t\\tint c=0;\\n\\t\\t\\twhile(target!=1){\\n\\t\\t\\t\\tif(maxDoubles==0){\\n\\t\\t\\t\\t\\treturn c+target-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(target%2!=0){\\n\\t\\t\\t\\t\\ttarget--;\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\ttarget=target/2;\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\tmaxDoubles--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minMoves(int target, int maxDoubles) {\\n\\t\\t\\tif(maxDoubles==0) return target-1;\\n\\t\\t\\tint c=0;\\n\\t\\t\\twhile(target!=1){\\n\\t\\t\\t\\tif(maxDoubles==0){\\n\\t\\t\\t\\t\\treturn c+target-1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1698911,
                "title": "0ms-c-easy-explanation",
                "content": "\\n```\\n\\t\\tint c=0;\\n        if(maxDoubles==0){\\n            return target-1;\\n        }\\n        else{\\n            int temp=target;\\n            while(temp>1){\\n            \\n                if(temp&1){\\n                    temp-=1;\\n                    c++;\\n                }\\n                else {\\n                if(maxDoubles>0){\\n                maxDoubles--;\\n                temp/=2;\\n                    c++;\\n                    }\\n                else{\\n                c+=temp-1;\\n                 return c;\\n            }\\n                }\\n                }\\n                \\n            }\\n        \\n        return c;\\n    }\\n```\\n**Explanation:-**\\nSome type of problems can be solved by solving backwards.This is one of such problem.\\n\\n**My approach**:- iteratively decrement target by 1 if its odd and if target is even && maxDoubles are greater than 0 then\\n\\ndivide by 2 or decrement by 1. Count number of decrements and return .",
                "solutionTags": [],
                "code": "```\\n\\t\\tint c=0;\\n        if(maxDoubles==0){\\n            return target-1;\\n        }\\n        else{\\n            int temp=target;\\n            while(temp>1){\\n            \\n                if(temp&1){\\n                    temp-=1;\\n                    c++;\\n                }\\n                else {\\n                if(maxDoubles>0){\\n                maxDoubles--;\\n                temp/=2;\\n                    c++;\\n                    }\\n                else{\\n                c+=temp-1;\\n                 return c;\\n            }\\n                }\\n                }\\n                \\n            }\\n        \\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697920,
                "title": "runtime-beats-100-and-memory-usage-beats-100-simple-python3-solution",
                "content": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        ans=0\\n        while maxDoubles and target!=1:\\n            ans+=target%2\\n            target=target//2\\n            ans+=1\\n            maxDoubles-=1\\n        ans+=target\\n        return ans-1\\n```\\n\\nRuntime - 64ms\\nMemory Usage - 14.3mb\\n\\nFor solutions to other LeetCode problems that I have solved, you can check my github repository :\\nhttps://github.com/harshitpoddar09/LeetCode-Solutions\\n\\nPlease upvote if you found this useful so that others can get help as well!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        ans=0\\n        while maxDoubles and target!=1:\\n            ans+=target%2\\n            target=target//2\\n            ans+=1\\n            maxDoubles-=1\\n        ans+=target\\n        return ans-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697793,
                "title": "c-easy-solution",
                "content": "In this question instead of going from 1 to target, start from target and move to 1. \\nThis way you would get the min moves easily. \\n1. Check if target is odd then decrease it by 1\\n2. If target is even, further check if we have maxDoubles with us, if yes then half the target \\n3. Continue the process till you get to 1\\n\\nKeep in mind to decrease and increase the respective values. \\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves=0;\\n        while(target>1)\\n        {\\n            if(target%2!=0)\\n            {\\n                target-=1;\\n                moves++;\\n            }\\n            else\\n            {\\n                if(maxDoubles!=0)\\n                {\\n                    target/=2;\\n                    moves++;\\n                    maxDoubles-=1;\\n                }\\n                else\\n                {\\n                    return (moves+target-1);\\n                }\\n            }\\n        }\\n        return moves;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves=0;\\n        while(target>1)\\n        {\\n            if(target%2!=0)\\n            {\\n                target-=1;\\n                moves++;\\n            }\\n            else\\n            {\\n                if(maxDoubles!=0)\\n                {\\n                    target/=2;\\n                    moves++;\\n                    maxDoubles-=1;\\n                }\\n                else\\n                {\\n                    return (moves+target-1);\\n                }\\n            }\\n        }\\n        return moves;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697307,
                "title": "1ms-java-solution-please-do-tell-in-comments-if-i-can-do-better",
                "content": "This is a 1ms Java Solution... Please do tell me in the comments if I can do better.\\nTrying to get better.\\nThank You.\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        if(maxDoubles==0){\\n            return target-1;\\n        }\\n        while(target!=0){\\n            if((target&1)==1){\\n                target--;\\n                cnt++;\\n            }\\n            else{\\n                if(maxDoubles>0){\\n                    target= target/2;\\n                    cnt++;\\n                    maxDoubles--;\\n                }else{\\n                    return target+cnt-1;\\n                }\\n            }\\n        }\\n        return cnt-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        if(maxDoubles==0){\\n            return target-1;\\n        }\\n        while(target!=0){\\n            if((target&1)==1){\\n                target--;\\n                cnt++;\\n            }\\n            else{\\n                if(maxDoubles>0){\\n                    target= target/2;\\n                    cnt++;\\n                    maxDoubles--;\\n                }else{\\n                    return target+cnt-1;\\n                }\\n            }\\n        }\\n        return cnt-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695522,
                "title": "greedy-cpp-solution-starting-from-target",
                "content": "To solve this problem if the double operations are available we can make one move if target % 2 == 0, and two moves otherwise.\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if (maxDoubles == 0) return target - 1;\\n        int res = 0;\\n        while (maxDoubles && target != 1) {\\n            if (target % 2 != 0) target--, res++;\\n            target /= 2;\\n            res++;\\n            maxDoubles--;\\n        }\\n        res += target - 1;\\n        return res;\\n    }\\n};\\n```\\nLess code solution:\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if (maxDoubles == 0) return target - 1;\\n        int res = 0;\\n        while (maxDoubles-- && target != 1) {\\n            res += 1 + (target % 2);\\n            target /= 2;\\n        }\\n        return res + target - 1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if (maxDoubles == 0) return target - 1;\\n        int res = 0;\\n        while (maxDoubles && target != 1) {\\n            if (target % 2 != 0) target--, res++;\\n            target /= 2;\\n            res++;\\n            maxDoubles--;\\n        }\\n        res += target - 1;\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if (maxDoubles == 0) return target - 1;\\n        int res = 0;\\n        while (maxDoubles-- && target != 1) {\\n            res += 1 + (target % 2);\\n            target /= 2;\\n        }\\n        return res + target - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695157,
                "title": "java-0ms-solution",
                "content": "\\n    public int minMoves(int target, int k) {\\n        int ans = 0;\\n        while (target > 1 && k > 0) {\\n            ans += 1 + target % 2;\\n            k--;\\n            target >>= 1;\\n        }\\n        return target - 1 + ans;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int minMoves(int target, int k) {\\n        int ans = 0;\\n        while (target > 1 && k > 0) {\\n            ans += 1 + target % 2;\\n            k--;\\n            target >>= 1;\\n        }\\n        return target - 1 + ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1695005,
                "title": "c-solution-faster-than-100-in-time-and-100-in-space",
                "content": "The idea is to start from target and reach till 1.\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int num, int db) {\\n        int ans=0;\\n        while(num!=1)\\n        {\\n            if(db==0)\\n            {\\n                ans+=(num-1);\\n                break;\\n            }\\n            if(num==2)\\n            {\\n                num--;\\n            }\\n            else if(num%2==0 and db)\\n            {\\n                num/=2;\\n                db--;\\n            }\\n            else\\n                num--;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int num, int db) {\\n        int ans=0;\\n        while(num!=1)\\n        {\\n            if(db==0)\\n            {\\n                ans+=(num-1);\\n                break;\\n            }\\n            if(num==2)\\n            {\\n                num--;\\n            }\\n            else if(num%2==0 and db)\\n            {\\n                num/=2;\\n                db--;\\n            }\\n            else\\n                num--;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694895,
                "title": "c-simple-solution-self-explanatory",
                "content": "We can also think the question in exactly opposite scenario, where we are given a `target` and we need to reduce it to `1` by using two operations :\\n1. Dividing `target` by 2 as many as `maxDoubles` times \\n2.  Decrementing `target` by `1`.\\n\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles)\\n    {\\n        int count = 0; // to count the no. of moves required\\n        if(maxDoubles == 0) // If we can\\'t double, just return target-1\\n            return target-1;\\n        while(target>1 && maxDoubles)\\n        {\\n            if(target%2 == 1) // If target is not divisible by 2, then just decrement it by 1\\n            {\\n                --target;\\n                count++;\\n            }\\n            else // If target is divisible by 2, then use maxDouble to divide it by 2\\n                count++, --maxDoubles, target/=2;\\n            \\n        }\\n        return count + (target-1);\\n    }\\n};\\n```\\n```\\nRuntime: 4 ms, faster than 100.00% of C++ online submissions for Minimum Moves to Reach Target Score.\\nMemory Usage: 5.8 MB, less than 100.00% of C++ online submissions for Minimum Moves to Reach Target Score.\\n```\\nComment down for any query :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles)\\n    {\\n        int count = 0; // to count the no. of moves required\\n        if(maxDoubles == 0) // If we can\\'t double, just return target-1\\n            return target-1;\\n        while(target>1 && maxDoubles)\\n        {\\n            if(target%2 == 1) // If target is not divisible by 2, then just decrement it by 1\\n            {\\n                --target;\\n                count++;\\n            }\\n            else // If target is divisible by 2, then use maxDouble to divide it by 2\\n                count++, --maxDoubles, target/=2;\\n            \\n        }\\n        return count + (target-1);\\n    }\\n};\\n```\n```\\nRuntime: 4 ms, faster than 100.00% of C++ online submissions for Minimum Moves to Reach Target Score.\\nMemory Usage: 5.8 MB, less than 100.00% of C++ online submissions for Minimum Moves to Reach Target Score.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694748,
                "title": "java-easy-math",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n       //Base case\\n        if(maxDoubles == 0) return target - 1;\\n              int m = 0; //moves\\n            while(target != 1){\\n              //If we are out of doubles , we are only left with a single operation\\n                if(maxDoubles == 0) return m + target - 1;\\n              //If we have \"doubles\" and it is worth to use a \"double\"\\n                if(target % 2 == 0 && maxDoubles > 0){\\n                   target = target / 2;\\n                   maxDoubles--;\\n                }\\n                else{\\n                    target = target - 1;\\n                }\\n                m++;\\n            }\\n      return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n       //Base case\\n        if(maxDoubles == 0) return target - 1;\\n              int m = 0; //moves\\n            while(target != 1){\\n              //If we are out of doubles , we are only left with a single operation\\n                if(maxDoubles == 0) return m + target - 1;\\n              //If we have \"doubles\" and it is worth to use a \"double\"\\n                if(target % 2 == 0 && maxDoubles > 0){\\n                   target = target / 2;\\n                   maxDoubles--;\\n                }\\n                else{\\n                    target = target - 1;\\n                }\\n                m++;\\n            }\\n      return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694711,
                "title": "10-ms-faster-than-100-00-of-c-online-submissions-for-minimum-moves-to-reach-target-score",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n      return  help( target,  maxDoubles);\\n    }\\n    \\n    int help(int &target, int& maxDoubles)\\n    {\\n        int current=1,minimumMovesCount=0;\\n        while( target>1)\\n        {\\n            if(maxDoubles>0&&target%2==0)\\n            {\\n                 target/=2;\\n                minimumMovesCount++;\\n                maxDoubles--;\\n            }\\n            else if(maxDoubles==0&&target%2==0)\\n            {\\n                minimumMovesCount+=target;\\n                minimumMovesCount--;\\n                target=1;\\n            }\\n            else if(maxDoubles>0&&target%2!=0)\\n            {\\n                 target/=2;\\n                minimumMovesCount+=2;\\n                maxDoubles--;\\n            }\\n            else if(maxDoubles==0&&target%2!=0)\\n            {\\n                minimumMovesCount+=target;\\n                minimumMovesCount--;\\n                target=1;\\n            }\\n           \\n        }\\n        return minimumMovesCount;\\n    }  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n      return  help( target,  maxDoubles);\\n    }\\n    \\n    int help(int &target, int& maxDoubles)\\n    {\\n        int current=1,minimumMovesCount=0;\\n        while( target>1)\\n        {\\n            if(maxDoubles>0&&target%2==0)\\n            {\\n                 target/=2;\\n                minimumMovesCount++;\\n                maxDoubles--;\\n            }\\n            else if(maxDoubles==0&&target%2==0)\\n            {\\n                minimumMovesCount+=target;\\n                minimumMovesCount--;\\n                target=1;\\n            }\\n            else if(maxDoubles>0&&target%2!=0)\\n            {\\n                 target/=2;\\n                minimumMovesCount+=2;\\n                maxDoubles--;\\n            }\\n            else if(maxDoubles==0&&target%2!=0)\\n            {\\n                minimumMovesCount+=target;\\n                minimumMovesCount--;\\n                target=1;\\n            }\\n           \\n        }\\n        return minimumMovesCount;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694657,
                "title": "c-100-fast-think-reverse-process",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n          // edge case\\n          \\n           if(maxDoubles == 0) return target - 1;\\n        \\n          int steps = 0;\\n        \\n          while(target != 1){\\n              if(target & 1){\\n                  steps++;\\n                  target--;\\n              }\\n              else{\\n                     if(maxDoubles > 0){\\n                         target /= 2;\\n                         steps++;\\n                         maxDoubles--;\\n                     }   \\n                    else break;\\n              }\\n          }\\n        \\n             if(target != 1) steps += target - 1; \\n             return steps;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n          // edge case\\n          \\n           if(maxDoubles == 0) return target - 1;\\n        \\n          int steps = 0;\\n        \\n          while(target != 1){\\n              if(target & 1){\\n                  steps++;\\n                  target--;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1694523,
                "title": "ez-python-code-for-beginners-using-recursion",
                "content": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        if target==1:\\n            return 0\\n        if maxDoubles==0:\\n            return target-1\\n        if target & 1==1:\\n            return 1+self.minMoves(target-1,maxDoubles)\\n        else:\\n            return 1+self.minMoves(target//2,maxDoubles-1)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        if target==1:\\n            return 0\\n        if maxDoubles==0:\\n            return target-1\\n        if target & 1==1:\\n            return 1+self.minMoves(target-1,maxDoubles)\\n        else:\\n            return 1+self.minMoves(target//2,maxDoubles-1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694398,
                "title": "c",
                "content": "We go backwards for this question(we try to make target 1)\\n1) Traverse the loop while target doesn\\'t become 1 and for each traversal increment no. of moves\\n2) In the loop \\n     a) if maxDoubles becomes 0, we return (moves taken so far) + (target-1), as we are only left with option to decrement target by 1 till it becomes 1\\n\\t b) if maxDoubles>0 and target is even we decrement maxDoubles by one and update target to target/2(as we require minm moves to make 1).\\n\\t c) else, if target is od decrement it by 1 to make it even.\\n\\t d) for case (b) and (c) we increment moves by 1\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves=0;\\n        while(target!=1){\\n            if(maxDoubles==0){\\n                return moves+target-1;\\n            }\\n            else if(maxDoubles>0&&(target&1)==0){\\n                target/=2;\\n                maxDoubles--;\\n            }\\n            else{\\n                target--;\\n            }\\n            moves++;\\n        }\\n        return moves;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves=0;\\n        while(target!=1){\\n            if(maxDoubles==0){\\n                return moves+target-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1694191,
                "title": "greedy-observation-explanation-c",
                "content": "Approach as follows: \\n\\n* 44/2 = 22, it removes 22 from 44 to become half\\n\\twhereas\\n\\t20/2 = 10, it removes 10 from 20 to become half\\n\\n* **Dividing bigger number by 2, removes more** , so greedly we want to use \"divide 2\" on bigger numbers.\\n \\n* **So, start from top and try to divide by 2 as often its possible.**\\n \\n* Starting from back means *2 becomes /2\\n* and add 1 becomes -1 \\n \\n* If number is even and we have divide2 moves left, we perform it else do -1.\\n\\n* Also to optimise for big number, if we no longer have divide2 , then only move we are left with is -1, so it will just add moves equal to left number-1. So, direcly add it to moves and return.( Saying that if number is 4 and only can do \"-1\" move , it will take -1 = 3 moves to make it 1 , so direclty add 3 to move).\\n\\n\\n#### Code C++: \\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxD) {\\n        long long int move=0;\\n        while(target!=1)\\n        {\\n            move++;\\n            if(target%2==0&&maxD>0)\\n                target/=2,maxD--;\\n            else if(maxD==0)\\n            {\\n                target--;\\n                move+=target-1;\\n                break;\\n            }\\n            else\\n                target--;\\n        }\\n        return move;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxD) {\\n        long long int move=0;\\n        while(target!=1)\\n        {\\n            move++;\\n            if(target%2==0&&maxD>0)\\n                target/=2,maxD--;\\n            else if(maxD==0)\\n            {\\n                target--;\\n                move+=target-1;\\n                break;\\n            }\\n            else\\n                target--;\\n        }\\n        return move;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693896,
                "title": "easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int md) {\\n        int c=0;\\n        if(md==0) return (t-1);\\n        else {\\n            while((md--) and t!=1){\\n                if(t%2==1){\\n                    c++;\\n                }\\n                t=t/2;\\n                c++;\\n                \\n            }\\n            if(t!=1){\\n                c=c+(t-1);\\n            }\\n        }\\n    return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minMoves(int t, int md) {\\n        int c=0;\\n        if(md==0) return (t-1);\\n        else {\\n            while((md--) and t!=1){\\n                if(t%2==1){\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1693885,
                "title": "c-javascript-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int n, int d) \\n    {\\n        int count=0;\\n       while(d&&n)\\n       {\\n           if(n%2==0)\\n           {\\n               d--;\\n               n/=2;\\n           }\\n           else\\n           {\\n               n--;\\n           }\\n           count++;\\n       }\\n        return n-1+count;\\n    }\\n};\\n```\\n```\\n/**\\n * @param {number} target\\n * @param {number} maxDoubles\\n * @return {number}\\n */\\nvar minMoves = function(target, d) \\n{\\n  let count=0;\\n  let n=target;\\n  while(d>0&&n>0)\\n    {\\n      if(n%2==0)\\n        {\\n          n=n/2;\\n          d--;\\n        }\\n      else\\n        {\\n          n=n-1;\\n        }\\n      count++;\\n    }\\n  return n-1+count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int n, int d) \\n    {\\n        int count=0;\\n       while(d&&n)\\n       {\\n           if(n%2==0)\\n           {\\n               d--;\\n               n/=2;\\n           }\\n           else\\n           {\\n               n--;\\n           }\\n           count++;\\n       }\\n        return n-1+count;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number} target\\n * @param {number} maxDoubles\\n * @return {number}\\n */\\nvar minMoves = function(target, d) \\n{\\n  let count=0;\\n  let n=target;\\n  while(d>0&&n>0)\\n    {\\n      if(n%2==0)\\n        {\\n          n=n/2;\\n          d--;\\n        }\\n      else\\n        {\\n          n=n-1;\\n        }\\n      count++;\\n    }\\n  return n-1+count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693746,
                "title": "python3-recursive-backwards-solution-greedy-approach",
                "content": "### **Code**:\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        # If all maxDoubles are expired then number of -1 operations to go from target to 1 is (target-1)\\n\\t\\t# If target is 1 that means we return 0. Since target is 1, we return target-1\\n        if maxDoubles == 0 or target == 1:\\n            return target - 1\\n        subracts = 0 # Considering no -1 operation required initially\\n        if target%2 != 0: # Target is odd, we must do one -1 operation to make it even\\n            subracts=1\\n            target-=1 # Target is now even\\n        target = target//2\\n        maxDoubles -= 1 # Since we used a maxDouble operation we have one less /2 operation to work from\\n        return self.minMoves(target, maxDoubles)+subracts+1\\n        # we add 1 here as we will do the /2 operation always\\n```\\n### **Intuition**:\\n**Original Question:**\\nThe question statement asks us to go from 1 to target by 2 operations (**+1 & X2**) of which **X2** can only be applied **maxDouble** number of times by applying minimum number of operations\\n* Essentially doubling a larger number will be a better choice(greedy choice) than doubling a smaller number to minimize the number of operations as double operations are limited, we want to make best use of this operation. **Since we want to start with a bigger number the idea of starting from backwards comes into mind.**\\n\\n### *Now reverse the question into*:\\n**Updated Question:**\\nGo from target to 1 by applying **-1 and /2** where **/2** can be applied only **maxDouble** number of times by applying minimum number of operations\\n\\n*They are the same questions but after reversing the question becomes much simpler.*\\n\\n```\\nSay we have a number 8:\\n8/2 = 4 ---> 4/2 = 2 ----> 2/2 = 1 [3 operations]\\n8-1 = 7 ---> 7-1 = 6 ----> 6-1 = 5 ---> .... ---> 2-1 = 1 [7 operations]\\n```\\nSo to go from target to one **/2** operation is the greedy choice as it reduces the number of operations by half compared to **-1** operation.\\n**Important: *But if we have an odd target we must not divide it directly, we will first -1 from it*.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        # If all maxDoubles are expired then number of -1 operations to go from target to 1 is (target-1)\\n\\t\\t# If target is 1 that means we return 0. Since target is 1, we return target-1\\n        if maxDoubles == 0 or target == 1:\\n            return target - 1\\n        subracts = 0 # Considering no -1 operation required initially\\n        if target%2 != 0: # Target is odd, we must do one -1 operation to make it even\\n            subracts=1\\n            target-=1 # Target is now even\\n        target = target//2\\n        maxDoubles -= 1 # Since we used a maxDouble operation we have one less /2 operation to work from\\n        return self.minMoves(target, maxDoubles)+subracts+1\\n        # we add 1 here as we will do the /2 operation always\\n```\n```\\nSay we have a number 8:\\n8/2 = 4 ---> 4/2 = 2 ----> 2/2 = 1 [3 operations]\\n8-1 = 7 ---> 7-1 = 6 ----> 6-1 = 5 ---> .... ---> 2-1 = 1 [7 operations]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693436,
                "title": "java-easy-solution",
                "content": "\\n\\n    public int minMoves(int target, int maxDoubles) {\\n         int count=0;\\n        int current=0;\\n     while(target>1){\\n         if(target%2==0 && maxDoubles>0){\\n             target=target/2;\\n             maxDoubles-=1;\\n             \\n         }else if(maxDoubles==0){\\n             count+=target-1;\\n             break;\\n         }else{\\n             target--;\\n         }\\n         count++;\\n     }\\n     return count;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\n    public int minMoves(int target, int maxDoubles) {\\n         int count=0;\\n        int current=0;\\n     while(target>1){\\n         if(target%2==0 && maxDoubles>0){\\n             target=target/2;\\n             maxDoubles-=1;\\n             \\n         }else if(maxDoubles==0){\\n             count+=target-1;\\n             break;\\n         }else{\\n             target--;\\n         }\\n         count++;\\n     }\\n     return count;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1693369,
                "title": "simple-c-solution",
                "content": "#### Move from target to 1 instead of 1 to target\\n\\n* If target is even, greedily divide by 2 and reduce doubling moves by 1.\\n* If target is odd, reduce 1 to make it even.\\n* If we have run out of doubling moves, only weay to reach \\'1\\', it to decrement target by \\'1\\' in each step which is basically \\'target\\' steps in total\\n ```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(target==1)     \\n            return 0;\\n        if(maxDoubles==0)\\n            return target-1;\\n        if(target&1)\\n            return 1+minMoves(target-1,maxDoubles);\\n        else\\n            return 1+minMoves(target/2,maxDoubles-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(target==1)     \\n            return 0;\\n        if(maxDoubles==0)\\n            return target-1;\\n        if(target&1)\\n            return 1+minMoves(target-1,maxDoubles);\\n        else\\n            return 1+minMoves(target/2,maxDoubles-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693363,
                "title": "easy-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n\\t   public static int minMoves(int target, int maxDoubles) {\\n\\t        if(maxDoubles == 0) {\\n\\t        \\treturn target-1;\\n\\t        }\\n\\t        int count = 0;\\n\\t        while(target > 0 && maxDoubles > 0) {\\n\\t        \\tif(target % 2 == 0) {\\n\\t        \\t\\ttarget /= 2;\\n\\t        \\t\\tcount++;\\n\\t        \\t\\tmaxDoubles--;\\n\\t        \\t}\\n\\t        \\telse {\\n\\t        \\t\\ttarget--;\\n\\t        \\t\\tcount++;\\n\\t        \\t}\\n\\t        }\\n\\t        return count+target-1;\\n\\t    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t   public static int minMoves(int target, int maxDoubles) {\\n\\t        if(maxDoubles == 0) {\\n\\t        \\treturn target-1;\\n\\t        }\\n\\t        int count = 0;\\n\\t        while(target > 0 && maxDoubles > 0) {\\n\\t        \\tif(target % 2 == 0) {\\n\\t        \\t\\ttarget /= 2;\\n\\t        \\t\\tcount++;\\n\\t        \\t\\tmaxDoubles--;\\n\\t        \\t}\\n\\t        \\telse {\\n\\t        \\t\\ttarget--;\\n\\t        \\t\\tcount++;\\n\\t        \\t}\\n\\t        }\\n\\t        return count+target-1;\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693339,
                "title": "c-100-faster-reduce-target-to-1",
                "content": "We start from end because starting from end will give us the maximum double\\nfor ex :- target = 19, and maxdouble = 2 if we start doubling at early stage like 1,2,4 then we will run out of doubles and will have to move by increments (5,6,7,8,9....) so we double as last as possible since it will give us maximum value so if we start from 1\\nwe increment 3 steps we will reach 4 \\ndouble it we reach 8 \\nthen increment 1 and we reach 9\\nthen double it we reach 18 \\nthen increment it by 1\\n\\nSo if we observe carefully we can use max double jumps if we start dividing from end(for bigger jumps)\\n\\n\\n```\\nint minMoves(int target, int maxDoubles) {\\n        \\n        //base Case\\n        if(maxDoubles==0)\\n            return target-1;\\n        \\n        int moves=0;\\n        int x= target;\\n        while(maxDoubles>=1 && x>1){\\n            \\n            //if the number is not even move 1 step\\n            if(x%2!=0)\\n            {\\n                x-=1;\\n                moves+=1;\\n            }\\n            \\n          //if it is even simply double(or divide) if we have sufficient maxdoubles\\n            else\\n            {\\n                x=x/2;\\n                moves+=1;\\n                maxDoubles--;\\n            }\\n            \\n            \\n        }\\n        \\n        //if we run out of maxDoubles we just move step by step\\n        while(x>1)\\n        {\\n            moves++;\\n            x--;\\n        }\\n        return moves;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nint minMoves(int target, int maxDoubles) {\\n        \\n        //base Case\\n        if(maxDoubles==0)\\n            return target-1;\\n        \\n        int moves=0;\\n        int x= target;\\n        while(maxDoubles>=1 && x>1){\\n            \\n            //if the number is not even move 1 step\\n            if(x%2!=0)\\n            {\\n                x-=1;\\n                moves+=1;\\n            }\\n            \\n          //if it is even simply double(or divide) if we have sufficient maxdoubles\\n            else\\n            {\\n                x=x/2;\\n                moves+=1;\\n                maxDoubles--;\\n            }\\n            \\n            \\n        }\\n        \\n        //if we run out of maxDoubles we just move step by step\\n        while(x>1)\\n        {\\n            moves++;\\n            x--;\\n        }\\n        return moves;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693223,
                "title": "c-simple-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        if(target == 1) return 0;\\n        if(target > 1 and maxDoubles == 0){\\n            return target-1;\\n        }\\n        if(target&1 and maxDoubles>0){\\n            target--;\\n            cnt+=2;\\n            cnt += minMoves(target/2, maxDoubles-1);\\n            return cnt;\\n        }\\n        if(!(target&1) and maxDoubles>0){\\n            cnt++;\\n            cnt += minMoves(target/2, maxDoubles-1);\\n            return cnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        if(target == 1) return 0;\\n        if(target > 1 and maxDoubles == 0){\\n            return target-1;\\n        }\\n        if(target&1 and maxDoubles>0){\\n            target--;\\n            cnt+=2;\\n            cnt += minMoves(target/2, maxDoubles-1);\\n            return cnt;\\n        }\\n        if(!(target&1) and maxDoubles>0){\\n            cnt++;\\n            cnt += minMoves(target/2, maxDoubles-1);\\n            return cnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693127,
                "title": "java-itereative-solution",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int res = 0;\\n        \\n        while(target != 1 && maxDoubles > 0) {\\n            if(target % 2 == 0 && maxDoubles > 0) {\\n                target /= 2;\\n                maxDoubles--;\\n            }\\n            else target -= 1;\\n            res++;\\n        }\\n        \\n        return res + (target - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int res = 0;\\n        \\n        while(target != 1 && maxDoubles > 0) {\\n            if(target % 2 == 0 && maxDoubles > 0) {\\n                target /= 2;\\n                maxDoubles--;\\n            }\\n            else target -= 1;\\n            res++;\\n        }\\n        \\n        return res + (target - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693093,
                "title": "c-2139-minimum-moves-to-reach-target-score",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0; \\n        for (; target > 1 && maxDoubles; ++ans) \\n            if (target&1) --target; \\n            else if (maxDoubles) {\\n                --maxDoubles; \\n                target >>= 1; \\n            }\\n        return ans + target - 1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0; \\n        for (; target > 1 && maxDoubles; ++ans) \\n            if (target&1) --target; \\n            else if (maxDoubles) {\\n                --maxDoubles; \\n                target >>= 1; \\n            }\\n        return ans + target - 1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693089,
                "title": "c-solve-in-reverse-direction-o-n-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        int k = maxDoubles;\\n        \\n        while(target > 1 && k > 0){\\n            if(target % 2 == 0){\\n                target = target/2;\\n                k--;\\n            }\\n            else{\\n                target--;\\n            }\\n            ans++;\\n        }\\n        if(target == 1) return ans;\\n        ans += (target - 1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans = 0;\\n        int k = maxDoubles;\\n        \\n        while(target > 1 && k > 0){\\n            if(target % 2 == 0){\\n                target = target/2;\\n                k--;\\n            }\\n            else{\\n                target--;\\n            }\\n            ans++;\\n        }\\n        if(target == 1) return ans;\\n        ans += (target - 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693082,
                "title": "c-easy-logic",
                "content": "# CODE\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if (1 == target) return 0;\\n\\n        int sol = 0, i = 1;\\n        \\n        while(maxDoubles && target != 1) {\\n            if (target % 2) {\\n                target--;\\n            }\\n            else {\\n                target = target / 2;\\n                maxDoubles--;   \\n            }\\n            sol++;\\n\\n        }\\n                \\n        sol += target - 1;\\n        \\n        return sol;\\n    }\\n};\\n```\\n\\n# LOGIC\\n\\nThe logic is quite simple, but have some mathematical interpretation.\\n\\n**Thinking 1:**   We want to get to target in minimum steps from 1. \\n**Thinking 2:** We should always multiple currValue with 2 only to get maximum out of it and that  should be less than target. 1*2 = 2 and 6*2 = 12, we can see that more the larger value we multiples with 2, more greater result we get\\n**Thinking 3:** Going from 1 to target is same as going from target to 1, means steps will be same.\\n**Thinking 4:** Following *__Thinking 2:__* we can conclude that we should multiple our current value with 2 when we are have larger value, but here is a tradeoff that we must not exceed the target value, so we need to multiple in such way that we can use *maxDoubles* at most and also does not exceed target.\\n**Thinking 5:** Following *__Thinking 3:__* and *__Thinking 4:__*. We will start from target and get down to 1 and we will use *maxDoubles* as much as possible because we are already starting from  target.  So there is no chance of exceeding because of second condition in while loop.\\n**Thinking 6:** Once we exhausted our *maxDoubles * then only option is to use another operation.\\n\\n*__NOTE 1:__* As we are going from target to 1, so we will divide the value by 2 and if no *maxDoubles* are available then we should subtract it by 1.\\n*__NOTE 2:__*  ```sol += target - 1;```, here we are subtracting it by 1, because we are going down from original target value to 1, not to 0.\\n\\n\\nFeel free to ask doubt and please do share some suggestions :)\\nHappy coding\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if (1 == target) return 0;\\n\\n        int sol = 0, i = 1;\\n        \\n        while(maxDoubles && target != 1) {\\n            if (target % 2) {\\n                target--;\\n            }\\n            else {\\n                target = target / 2;\\n                maxDoubles--;   \\n            }\\n            sol++;\\n\\n        }\\n                \\n        sol += target - 1;\\n        \\n        return sol;\\n    }\\n};\\n```\n```sol += target - 1;```",
                "codeTag": "Java"
            },
            {
                "id": 1693021,
                "title": "python-greedy-solution",
                "content": "reverse thinking: change target to 1 with two moves\\n* decrement the current integer by one (i.e., x = x - 1).\\n* Divide the current even integer by 2 (i.e., x = x // 2, if x is even)\\n\\nGreedy algorithm: greedy use the second moves at most maxDoubles times\\n```\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        moves = 0\\n        while target > 1:\\n            if target % 2 == 1:\\n                target -= 1\\n            else:\\n                if maxDoubles > 0:\\n                    target //= 2\\n                    maxDoubles -= 1\\n                else:\\n                    moves += target - 1\\n                    break\\n            moves += 1\\n        return moves\\n```",
                "solutionTags": [],
                "code": "```\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        moves = 0\\n        while target > 1:\\n            if target % 2 == 1:\\n                target -= 1\\n            else:\\n                if maxDoubles > 0:\\n                    target //= 2\\n                    maxDoubles -= 1\\n                else:\\n                    moves += target - 1\\n                    break\\n            moves += 1\\n        return moves\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1693019,
                "title": "c-solution",
                "content": "Try to go in reverse order,i.e., target to 1\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int m) {\\n        int cnt=0;\\n        while(m!=0)\\n        {\\n            if(t==1)\\n                return cnt;\\n            if(t%2)\\n            {\\n                t--;\\n                cnt++;\\n            }\\n            else{\\n              t=t/2;\\n            cnt++;\\n            m--;  \\n            }     \\n        }\\n        if(t>1)\\n            cnt=cnt+(t-1);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int m) {\\n        int cnt=0;\\n        while(m!=0)\\n        {\\n            if(t==1)\\n                return cnt;\\n            if(t%2)\\n            {\\n                t--;\\n                cnt++;\\n            }\\n            else{\\n              t=t/2;\\n            cnt++;\\n            m--;  \\n            }     \\n        }\\n        if(t>1)\\n            cnt=cnt+(t-1);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693008,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        while(maxDoubles > 0 && target > 1){\\n            if(target % 2 == 0){\\n                target/= 2;\\n                maxDoubles--;\\n            }\\n            else{\\n                target -= 1;\\n            }\\n            moves++;\\n        }\\n        if(target > 1) moves += target-1;\\n        return moves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n        while(maxDoubles > 0 && target > 1){\\n            if(target % 2 == 0){\\n                target/= 2;\\n                maxDoubles--;\\n            }\\n            else{\\n                target -= 1;\\n            }\\n            moves++;\\n        }\\n        if(target > 1) moves += target-1;\\n        return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693002,
                "title": "c-greedy",
                "content": "```\\npublic class Solution {\\n    public int MinMoves(int target, int maxDoubles) {\\n        if(target ==1)\\n            return 0;\\n        int res = 0;\\n        while(maxDoubles>0&&target!=1)\\n        {\\n            if(target%2 ==0 )\\n            {\\n                maxDoubles--;\\n                target/=2;\\n            }\\n            else\\n            {\\n                target--;\\n            }\\n            res++;\\n        }\\n        \\n        return res+(target-1);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int MinMoves(int target, int maxDoubles) {\\n        if(target ==1)\\n            return 0;\\n        int res = 0;\\n        while(maxDoubles>0&&target!=1)\\n        {\\n            if(target%2 ==0 )\\n            {\\n                maxDoubles--;\\n                target/=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1692998,
                "title": "java-recursion-100",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if (maxDoubles == 0) return target - 1;\\n        if (target == 1) return 0;\\n        if (target % 2 == 1) {\\n            return 2 + minMoves((target - 1)/2, maxDoubles - 1);\\n        } else {\\n            return 1 + minMoves(target/2, maxDoubles - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if (maxDoubles == 0) return target - 1;\\n        if (target == 1) return 0;\\n        if (target % 2 == 1) {\\n            return 2 + minMoves((target - 1)/2, maxDoubles - 1);\\n        } else {\\n            return 1 + minMoves(target/2, maxDoubles - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692991,
                "title": "instead-make-the-number-1-java",
                "content": "```\\nclass Solution {\\n    public int minMoves(int tar, int maxd) {\\n        //  total number of operations done till  now\\n\\t\\tint moves = 0;\\n\\t\\t//  total number of doubling operations done till  now\\n        int twice = 0;\\n        while (twice < maxd && tar > 1) {\\n            if (tar % 2 == 1) {\\n                moves++;\\n                tar--;\\n            } else {\\n                moves++;\\n                tar /= 2;\\n                twice++;\\n            }\\n        }\\n        if (tar > 1) {\\n            moves += tar - 1;\\n        }\\n        return moves;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMoves(int tar, int maxd) {\\n        //  total number of operations done till  now\\n\\t\\tint moves = 0;\\n\\t\\t//  total number of doubling operations done till  now\\n        int twice = 0;\\n        while (twice < maxd && tar > 1) {\\n            if (tar % 2 == 1) {\\n                moves++;\\n                tar--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1692981,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int k) {\\n        queue<vector<int>>q;\\n        int count = 0;\\n        while(t != 0 and k != 0)\\n        {\\n            if(t % 2 == 0)\\n            {\\n                t = t / 2;\\n                k--;\\n                count++;\\n            }\\n            else\\n            {\\n                t = t - 1;\\n                count++;\\n            }\\n        }\\n        count += (t - 1);\\n        return count;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int k) {\\n        queue<vector<int>>q;\\n        int count = 0;\\n        while(t != 0 and k != 0)\\n        {\\n            if(t % 2 == 0)\\n            {\\n                t = t / 2;\\n                k--;\\n                count++;\\n            }\\n            else\\n            {\\n                t = t - 1;\\n                count++;\\n            }\\n        }\\n        count += (t - 1);\\n        return count;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692954,
                "title": "simple-java-recursion-greedy-o-100-solution",
                "content": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        //O(Math.min(maxDoubles,log(target)) ~ O(100) worst case\\n        if(target<=1)\\n            return 0;\\n\\n        if(maxDoubles>0)\\n            //if you have to divide -> greedily use it at the highest value of target so we\\'ll have minimal increment operations \\n            return minMoves(target/2,maxDoubles-1)+(target%2==0?1:2);\\n        return target-1;\\n    }\\n}\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        //O(Math.min(maxDoubles,log(target)) ~ O(100) worst case\\n        if(target<=1)\\n            return 0;\\n\\n        if(maxDoubles>0)\\n            //if you have to divide -> greedily use it at the highest value of target so we\\'ll have minimal increment operations \\n            return minMoves(target/2,maxDoubles-1)+(target%2==0?1:2);\\n        return target-1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1692946,
                "title": "java-simple-loop-o-2maxdoubles-1",
                "content": "````\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int out = 0;\\n        while(target > 1){\\n            if(maxDoubles == 0){\\n                out += (target -1);\\n                break;\\n            }else if(target%2 != 0){\\n                out++;\\n                target--;\\n            }else {\\n                target /= 2;\\n                maxDoubles--;\\n                out++;\\n            }\\n        }\\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int out = 0;\\n        while(target > 1){\\n            if(maxDoubles == 0){\\n                out += (target -1);\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1692938,
                "title": "python3-easy-solution",
                "content": "Instead of reaching from ```1``` to ```target```, we try to reach from ```target``` to ```1```.\\njust check if target greater than one and maxDoubles greater than 0.\\n\\n```\\nclass Solution:\\n    def minMoves(self, target: int, dob: int) -> int:\\n        if dob==0: return target-1\\n        ans=0\\n        while dob>0 and target>1:\\n            if target%2==0:\\n                target//=2\\n                dob-=1\\n            else:\\n                target-=1\\n                    \\n            ans+=1\\n        return ans+target-1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```1```\n```target```\n```target```\n```1```\n```\\nclass Solution:\\n    def minMoves(self, target: int, dob: int) -> int:\\n        if dob==0: return target-1\\n        ans=0\\n        while dob>0 and target>1:\\n            if target%2==0:\\n                target//=2\\n                dob-=1\\n            else:\\n                target-=1\\n                    \\n            ans+=1\\n        return ans+target-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692930,
                "title": "python3-parity",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/210499523d9965e2d9dd5e1a6fbf67931233e41b) for solutions of weekly 276. \\n\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        ans = 0 \\n        while target > 1 and maxDoubles: \\n            ans += 1\\n            if target&1: target -= 1\\n            else: \\n                target //= 2\\n                maxDoubles -= 1\\n        return ans + target - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        ans = 0 \\n        while target > 1 and maxDoubles: \\n            ans += 1\\n            if target&1: target -= 1\\n            else: \\n                target //= 2\\n                maxDoubles -= 1\\n        return ans + target - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084288,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(maxDoubles==0) return target-1;\\n        int step=0;\\n        while(target!=1){\\n            if(target%2==0 && maxDoubles){\\n                target/=2;\\n                maxDoubles--;\\n            }else{\\n                target-=1;\\n            }\\n            step++;\\n        }\\n        return step;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(maxDoubles==0) return target-1;\\n        int step=0;\\n        while(target!=1){\\n            if(target%2==0 && maxDoubles){\\n                target/=2;\\n                maxDoubles--;\\n            }else{\\n                target-=1;\\n            }\\n            step++;\\n        }\\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078074,
                "title": "my-first-middle-level-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(target) in the worst case and O(0) in the best one\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinMoves(int target, int maxDoubles) {\\n\\n        int minMoves = 0;\\n\\n        if (maxDoubles == 0)\\n        {\\n            return target-1;\\n        }\\n        while (maxDoubles > 0 && target != 1)\\n        {\\n            if (target % 2 == 0)\\n            {\\n                target = target / 2;\\n                maxDoubles--;\\n                minMoves++;\\n            }\\n            else\\n            {\\n                 target--;\\n                 minMoves++;\\n            }\\n        }\\n        if (target != 1)\\n        {\\n            return minMoves + (target - 1);\\n        }\\n        return minMoves;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMoves(int target, int maxDoubles) {\\n\\n        int minMoves = 0;\\n\\n        if (maxDoubles == 0)\\n        {\\n            return target-1;\\n        }\\n        while (maxDoubles > 0 && target != 1)\\n        {\\n            if (target % 2 == 0)\\n            {\\n                target = target / 2;\\n                maxDoubles--;\\n                minMoves++;\\n            }\\n            else\\n            {\\n                 target--;\\n                 minMoves++;\\n            }\\n        }\\n        if (target != 1)\\n        {\\n            return minMoves + (target - 1);\\n        }\\n        return minMoves;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065114,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxD) {\\n        int ans=0;\\n        while(target!=1){\\n            if(maxD>0 && target%2==0 && target/2>1){\\n                target/=2;\\n                ans++;\\n                maxD--;\\n            }\\n            else{\\n                target-=1;\\n                ans++;\\n            }\\n            if(maxD==0 && target>1){\\n                ans=ans+target-1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxD) {\\n        int ans=0;\\n        while(target!=1){\\n            if(maxD>0 && target%2==0 && target/2>1){\\n                target/=2;\\n                ans++;\\n                maxD--;\\n            }\\n            else{\\n                target-=1;\\n                ans++;\\n            }\\n            if(maxD==0 && target>1){\\n                ans=ans+target-1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039091,
                "title": "simple-easy-recursive-and-iterative-solution-in-java-greedy-approach-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can either decrease the target by 1 or half the target if target is  divisible by 2.So we start from given target and when target is divisible by 2 then half it    (when maxDoubles>0) otherwise decrease by 1. (Simple a greedy approach)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif count of maxDobles=0 then simply we return target-1 because we can only go one by one.\\nNow simply call the function func by decresing the value of target to half when target%2==0 and maxDoubles>0 and increase the count of min_Moves . If the target%2!=0 then decrease the target by 1 and increase the count of min_Moves by 1.\\nNow if maxDoubles become zero then after that we cannot half the target , so simply we can simplty increase the min_Moves by target-1.\\nif(target == 1) simply exit the function call. \\n\\nUPVOTE if you understand otherwise ignore it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n       O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    Constant space.\\n     O(1)\\n# Code\\n```\\n// Recursive Solution \\n\\nclass Solution {\\n    int min_Moves=0;\\n    public int minMoves(int target, int maxDoubles) {\\n      if(maxDoubles==0)\\n      {\\n         return target-1;\\n      }\\n        func(target,maxDoubles);\\n        return min_Moves;\\n    }\\n    public void func(int target,int maxDoubles)\\n    {\\n      if(target==1)\\n      {\\n        return;\\n      }\\n      if(maxDoubles==0)\\n      {\\n         min_Moves+=target-1;\\n         return;\\n      }\\n       if(target%2==0 && maxDoubles>0)\\n       {\\n           min_Moves++;\\n           func(target/2,maxDoubles-1);\\n       }\\n       else{\\n         if(maxDoubles>0)\\n         {\\n           min_Moves++;\\n           func(target-1,maxDoubles);\\n         }\\n       }\\n    }\\n}\\n\\n// Iterative Solution\\n\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n      int minMoves=0;\\n      while(target>1)\\n      {\\n        if(maxDoubles==0)\\n        {\\n           minMoves+=target-1;\\n           break;\\n        }\\n        if(maxDoubles>0 && target%2==0)\\n        {\\n          target/=2;\\n          maxDoubles-=1;\\n        }\\n        else{\\n          target--;\\n        }\\n        minMoves++;\\n      }\\n     return minMoves;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Recursive Solution \\n\\nclass Solution {\\n    int min_Moves=0;\\n    public int minMoves(int target, int maxDoubles) {\\n      if(maxDoubles==0)\\n      {\\n         return target-1;\\n      }\\n        func(target,maxDoubles);\\n        return min_Moves;\\n    }\\n    public void func(int target,int maxDoubles)\\n    {\\n      if(target==1)\\n      {\\n        return;\\n      }\\n      if(maxDoubles==0)\\n      {\\n         min_Moves+=target-1;\\n         return;\\n      }\\n       if(target%2==0 && maxDoubles>0)\\n       {\\n           min_Moves++;\\n           func(target/2,maxDoubles-1);\\n       }\\n       else{\\n         if(maxDoubles>0)\\n         {\\n           min_Moves++;\\n           func(target-1,maxDoubles);\\n         }\\n       }\\n    }\\n}\\n\\n// Iterative Solution\\n\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n      int minMoves=0;\\n      while(target>1)\\n      {\\n        if(maxDoubles==0)\\n        {\\n           minMoves+=target-1;\\n           break;\\n        }\\n        if(maxDoubles>0 && target%2==0)\\n        {\\n          target/=2;\\n          maxDoubles-=1;\\n        }\\n        else{\\n          target--;\\n        }\\n        minMoves++;\\n      }\\n     return minMoves;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037612,
                "title": "simple-java-solution-greedy-0-ms-faster-than-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Once maxDoubels is zero return our counter + remaining target as it will only decrement by 1 till targer = 1.\\n- if current target is odd just decrement by 1 other wise divide by 2.\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int counter = 0;\\n        while(target > 1){\\n            if(maxDoubles == 0)\\n                return counter+target-1;\\n            if(target % 2 == 1){\\n                counter++;\\n                target--;\\n                continue;\\n            }\\n            target /= 2;\\n            counter++;\\n            maxDoubles--;\\n        }\\n        return counter;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int counter = 0;\\n        while(target > 1){\\n            if(maxDoubles == 0)\\n                return counter+target-1;\\n            if(target % 2 == 1){\\n                counter++;\\n                target--;\\n                continue;\\n            }\\n            target /= 2;\\n            counter++;\\n            maxDoubles--;\\n        }\\n        return counter;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031581,
                "title": "c-0ms-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) \\n    {\\n        int moves = 0;\\n\\n        while(target != 1)\\n        {\\n            if(maxDoubles > 0 and target%2 == 0) target /= 2, --maxDoubles;\\n            else if(maxDoubles == 0) return moves + target - 1;\\n            else --target;\\n            ++moves;\\n        }\\n        return moves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) \\n    {\\n        int moves = 0;\\n\\n        while(target != 1)\\n        {\\n            if(maxDoubles > 0 and target%2 == 0) target /= 2, --maxDoubles;\\n            else if(maxDoubles == 0) return moves + target - 1;\\n            else --target;\\n            ++moves;\\n        }\\n        return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030762,
                "title": "easy-logic-math",
                "content": "# Intuition:\\nYour intuition is to use a greedy approach where you try to double the current integer as much as possible (up to the given limit maxDoubles) and then increment if necessary to reach the target.\\n\\n# Approach:\\n1. Initialize a variable `cnt` to keep track of the number of moves.\\n2. Use a while loop to iterate until the target `t` becomes 1.\\n3. Inside the loop:\\n   - If `t` is even (i.e., `t % 2 == 0`) and `maxi` (maxDoubles) is greater than 0, double `t` by dividing it by 2 and decrement `maxi` by 1.\\n   - If `t` is not even and `maxi` is greater than 0, decrement `t` by 1 (increment operation).\\n   - If `maxi` is not greater than 0 or `t` is not even, it means you can only increment `t` by 1. Increment `cnt` by `(t - 1)` and break out of the loop.\\n4. Return the final value of `cnt`, which represents the minimum number of moves needed to reach the target.\\n\\n# Complexity:\\n- Time complexity: O(log2(t)), where t is the target number. In the worst case, you will keep halving `t` until it reaches 1, which takes log2(t) steps.\\n- Space complexity: O(1), as you are using a constant amount of extra space for variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int maxi) {\\n        int cnt = 0; // Initialize a variable to count the number of moves.\\n\\n        while (t > 1) { // Continue looping until the target becomes 1.\\n            if (t % 2 == 0 && maxi > 0) { // If t is even and you can still use the double operation.\\n                maxi--; // Decrement the available double operations.\\n                t /= 2; // Double the current integer.\\n            } else if (maxi > 0 && t % 2 != 0) { // If t is not even and you can still use the double operation.\\n                t--; // Increment the current integer by 1.\\n            } else { // If you can only use the increment operation or no more operations are allowed.\\n                cnt += (t - 1); // Increment cnt by (t - 1) to reach the target.\\n                break; // Break out of the loop.\\n            }\\n            cnt++; // Increment the move count after each operation.\\n        }\\n        return cnt; // Return the total number of moves needed to reach the target.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int maxi) {\\n        int cnt = 0; // Initialize a variable to count the number of moves.\\n\\n        while (t > 1) { // Continue looping until the target becomes 1.\\n            if (t % 2 == 0 && maxi > 0) { // If t is even and you can still use the double operation.\\n                maxi--; // Decrement the available double operations.\\n                t /= 2; // Double the current integer.\\n            } else if (maxi > 0 && t % 2 != 0) { // If t is not even and you can still use the double operation.\\n                t--; // Increment the current integer by 1.\\n            } else { // If you can only use the increment operation or no more operations are allowed.\\n                cnt += (t - 1); // Increment cnt by (t - 1) to reach the target.\\n                break; // Break out of the loop.\\n            }\\n            cnt++; // Increment the move count after each operation.\\n        }\\n        return cnt; // Return the total number of moves needed to reach the target.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026058,
                "title": "here-s-why-to-go-backward",
                "content": "```class Solution {\\npublic:\\n    // you have to start by dividing \\n    // and not by multiplying \\n    // when u start with multiplication you \\n    // will multiply smaller value first\\n    // but division of bigger no\\n    // will add more to value\\n\\n    // try 17 and maxx = 2;\\n    // 1*2 = 2, 2*2 = 4 now 17-4 = 13(additions)\\n    // ans will be 15(13+, 2*)\\n    // but 17-1 = 16 -> 16/2 = 8, 8/2 = 4 \\n    // 4-1 = 3, ans is 1 + 2 + 3 = 6(4+,2*)\\n\\n    int minMoves(int t, int maxx) {\\n        int x = 1;\\n        int ans = 0;\\n        while(maxx and t>1){\\n            if(t&1)ans++;\\n            t /= 2;\\n            maxx--;\\n            ans++;\\n        }\\n\\n        ans += t-x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```class Solution {\\npublic:\\n    // you have to start by dividing \\n    // and not by multiplying \\n    // when u start with multiplication you \\n    // will multiply smaller value first\\n    // but division of bigger no\\n    // will add more to value\\n\\n    // try 17 and maxx = 2;\\n    // 1*2 = 2, 2*2 = 4 now 17-4 = 13(additions)\\n    // ans will be 15(13+, 2*)\\n    // but 17-1 = 16 -> 16/2 = 8, 8/2 = 4 \\n    // 4-1 = 3, ans is 1 + 2 + 3 = 6(4+,2*)\\n\\n    int minMoves(int t, int maxx) {\\n        int x = 1;\\n        int ans = 0;\\n        while(maxx and t>1){\\n            if(t&1)ans++;\\n            t /= 2;\\n            maxx--;\\n            ans++;\\n        }\\n\\n        ans += t-x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006809,
                "title": "java-solution-runtime-0ms-faster-than-100-00",
                "content": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        if(maxDoubles == 0)return target-1;\\n        while(1<target){\\n            if(target%2==0){\\n                if(maxDoubles > 0 && target/2 >= 1){\\n                    target/=2; cnt++; maxDoubles--;\\n                    if(target==1)return cnt;\\n                }\\n                else{\\n                    if(target-1 >= 1){\\n                    target-=1; cnt++;\\n                    }\\n                    if(target==1)return cnt;\\n                }\\n            }\\n            else if(maxDoubles == 0)return target-1+cnt;\\n            else{\\n                if(target-1 >= 1){\\n                    target-=1; cnt++;\\n                }\\n                if(target==1)return cnt;\\n            }\\n        }\\n        return cnt;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        int cnt = 0;\\n        if(maxDoubles == 0)return target-1;\\n        while(1<target){\\n            if(target%2==0){\\n                if(maxDoubles > 0 && target/2 >= 1){\\n                    target/=2; cnt++; maxDoubles--;\\n                    if(target==1)return cnt;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4006333,
                "title": "start-from-the-end",
                "content": "# Approach\\nGreedy approach, we start from end and, \\'target\\' and divide target by 2 if target is even otherwise decrease a target and then divide by 2\\n\\n```\\n// 25   steps=1, maxDoubles=2\\n// 14   steps=2, maxDoubles=1 \\n// 7    steps=3, maxDoubles=0\\n// ans: 7+3=10\\n```\\n# Complexity\\n- Time complexity:\\n$$O(maxDoubles)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```  \\nvar minMoves = function(target, maxDoubles) {\\n    let steps=0;\\n    while(target>1 && maxDoubles>0){\\n        if(target%2!==0) {\\n            target--;\\n            steps++;\\n        }\\n        target=target/2;\\n        steps++;\\n        maxDoubles--;\\n    }\\n\\n    return steps+target-1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// 25   steps=1, maxDoubles=2\\n// 14   steps=2, maxDoubles=1 \\n// 7    steps=3, maxDoubles=0\\n// ans: 7+3=10\\n```\n```  \\nvar minMoves = function(target, maxDoubles) {\\n    let steps=0;\\n    while(target>1 && maxDoubles>0){\\n        if(target%2!==0) {\\n            target--;\\n            steps++;\\n        }\\n        target=target/2;\\n        steps++;\\n        maxDoubles--;\\n    }\\n\\n    return steps+target-1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000024,
                "title": "easy-approach-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n       int c=0;\\n       if(target%2!=0){\\n           c++;\\n           target--;\\n       }\\n       while(target>1 && maxDoubles>0){\\n           if(target%2!=0){\\n               c++;\\n               target--;\\n           }\\n           target=target/2;\\n           c++;\\n           maxDoubles--;\\n       }\\n       c=c+target-1;\\n       return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n       int c=0;\\n       if(target%2!=0){\\n           c++;\\n           target--;\\n       }\\n       while(target>1 && maxDoubles>0){\\n           if(target%2!=0){\\n               c++;\\n               target--;\\n           }\\n           target=target/2;\\n           c++;\\n           maxDoubles--;\\n       }\\n       c=c+target-1;\\n       return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985544,
                "title": "beats-100-reduce-target-to-1-explained",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n\\n        while(target != 1)\\n        {\\n            moves++; //if halvin is possible, do it\\n            if(maxDoubles && target%2 == 0)\\n            {\\n             target /= 2;\\n             maxDoubles--;\\n            }\\n            else //otherwise reduce by 1\\n             target--;\\n\\n           if(maxDoubles == 0) //optimization for laege test cases\\n           {\\n            moves += target-1;\\n            break;\\n            }\\n        }\\n    return moves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n\\n        while(target != 1)\\n        {\\n            moves++; //if halvin is possible, do it\\n            if(maxDoubles && target%2 == 0)\\n            {\\n             target /= 2;\\n             maxDoubles--;\\n            }\\n            else //otherwise reduce by 1\\n             target--;\\n\\n           if(maxDoubles == 0) //optimization for laege test cases\\n           {\\n            moves += target-1;\\n            break;\\n            }\\n        }\\n    return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979621,
                "title": "possible-easiest-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(maxDoubles)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int m) {\\n        int i,j,c=0;\\n        while(m-- and t>1)\\n        {\\n            if(t%2==0) c++;\\n            else c+=2;\\n            t=t/2;\\n        }\\n        return c+(t-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int t, int m) {\\n        int i,j,c=0;\\n        while(m-- and t>1)\\n        {\\n            if(t%2==0) c++;\\n            else c+=2;\\n            t=t/2;\\n        }\\n        return c+(t-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918084,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t=0,nt=0;\\n    int solve(int target,int maxd)\\n    {\\n        if(target>=0)\\n        return 1e8;\\n        if(target==1)\\n        return 0;\\n\\n        if(target%2==0 and maxd>0)\\n          t=1+solve(target/2,maxd-1);\\n        else\\n          nt=1+solve(target-1,maxd);\\n           return t+nt;\\n    }\\n    int minMoves(int target, int maxD) {\\n        int ct=0;\\n       while(target>1 and maxD>0)\\n        {\\n            if(target%2==0 and maxD>0)\\n              target=target/2,maxD--;\\n              else\\n              target=target-1;\\n              ct++;\\n        }\\n        return ct+target-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t=0,nt=0;\\n    int solve(int target,int maxd)\\n    {\\n        if(target>=0)\\n        return 1e8;\\n        if(target==1)\\n        return 0;\\n\\n        if(target%2==0 and maxd>0)\\n          t=1+solve(target/2,maxd-1);\\n        else\\n          nt=1+solve(target-1,maxd);\\n           return t+nt;\\n    }\\n    int minMoves(int target, int maxD) {\\n        int ct=0;\\n       while(target>1 and maxD>0)\\n        {\\n            if(target%2==0 and maxD>0)\\n              target=target/2,maxD--;\\n              else\\n              target=target-1;\\n              ct++;\\n        }\\n        return ct+target-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914212,
                "title": "sexiest-thing-i-have-ever-seen",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        while(target>1){\\n            if(target%2==0 && maxDoubles>0){\\n                target=target/2;\\n                maxDoubles--;\\n                ans++;\\n\\n            }\\n            else if(target%2==1 && maxDoubles>0){\\n                target--;\\n                ans++;\\n            } \\n            else{\\n                ans+=target-1;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int ans=0;\\n        while(target>1){\\n            if(target%2==0 && maxDoubles>0){\\n                target=target/2;\\n                maxDoubles--;\\n                ans++;\\n\\n            }\\n            else if(target%2==1 && maxDoubles>0){\\n                target--;\\n                ans++;\\n            } \\n            else{\\n                ans+=target-1;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887623,
                "title": "short-and-simple-ever-100-beats-runtimes-memory",
                "content": "# Code\\n```\\n/**\\n * @param {number} target\\n * @param {number} maxDoubles\\n * @return {number}\\n */\\nvar minMoves = function (target, maxDoubles) {\\n    let steps = 0\\n    while (target != 1) {\\n        if (maxDoubles == 0) {\\n            steps += target - 1\\n            target = 1\\n        }\\n        else if (target % 2 == 0 && maxDoubles > 0) {\\n            steps++\\n            target = target / 2\\n            maxDoubles--\\n        }\\n        else {\\n            steps++\\n            target--\\n        }\\n    }\\n    return steps\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Greedy",
                    "Shortest Path"
                ],
                "code": "```\\n/**\\n * @param {number} target\\n * @param {number} maxDoubles\\n * @return {number}\\n */\\nvar minMoves = function (target, maxDoubles) {\\n    let steps = 0\\n    while (target != 1) {\\n        if (maxDoubles == 0) {\\n            steps += target - 1\\n            target = 1\\n        }\\n        else if (target % 2 == 0 && maxDoubles > 0) {\\n            steps++\\n            target = target / 2\\n            maxDoubles--\\n        }\\n        else {\\n            steps++\\n            target--\\n        }\\n    }\\n    return steps\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876895,
                "title": "easy-c-solution-basic-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(maxDoubles==0)\\n            return target-1;\\n        int ans=0;\\n        while(target!=1)\\n        {\\n            if(target%2==0&& maxDoubles>0)\\n            {\\n                target/=2;\\n                maxDoubles--;\\n                ans++;\\n            }\\n            else\\n            {\\n                if(maxDoubles==0)\\n                {\\n                    ans+=target-1;\\n                    break;\\n                }\\n                target--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        if(maxDoubles==0)\\n            return target-1;\\n        int ans=0;\\n        while(target!=1)\\n        {\\n            if(target%2==0&& maxDoubles>0)\\n            {\\n                target/=2;\\n                maxDoubles--;\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3876211,
                "title": "very-simple-code-explained-approach-c",
                "content": "# Approach\\nHere we will just reverse the question (target -> 1), i.e we can perform 2 action on a target-\\n* Decrease target value by 1, target = target - 1.\\nor\\n* Decrease target value by dividing by 2, target = target / 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n\\n        // We First try to divide target by 2 as many times we can.\\n        while(target > 1 && maxDoubles != 0){\\n            //The below condition is to check if the current target value\\n            // is divisible by 2 or not. \\n            //If not divisible by 2 then we will subtract 1 from it, \\n            //so that next time it will be divisible by 2.\\n            if(target % 2 == 0){\\n                target = target/2;\\n                maxDoubles -= 1;\\n            }else{\\n                target -= 1;\\n            }\\n            moves++;\\n        }\\n        // Here is the condition to check what target value is remaining.\\n        // But this time we are not allowed to divide that target value by 2, as\\n        // maxDoubles = 0.\\n        if(maxDoubles == 0 && target > 1){\\n            moves += target - 1;\\n            return moves;\\n        }\\n        \\n        return moves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n        int moves = 0;\\n\\n        // We First try to divide target by 2 as many times we can.\\n        while(target > 1 && maxDoubles != 0){\\n            //The below condition is to check if the current target value\\n            // is divisible by 2 or not. \\n            //If not divisible by 2 then we will subtract 1 from it, \\n            //so that next time it will be divisible by 2.\\n            if(target % 2 == 0){\\n                target = target/2;\\n                maxDoubles -= 1;\\n            }else{\\n                target -= 1;\\n            }\\n            moves++;\\n        }\\n        // Here is the condition to check what target value is remaining.\\n        // But this time we are not allowed to divide that target value by 2, as\\n        // maxDoubles = 0.\\n        if(maxDoubles == 0 && target > 1){\\n            moves += target - 1;\\n            return moves;\\n        }\\n        \\n        return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872301,
                "title": "simple-python-solution-beats-90",
                "content": "# Intuition\\nThe problem involves reaching the target integer starting from 1 using two operations: incrementing by one or doubling the current integer. We need to find the minimum number of moves required to reach the target, with the restriction that we can only use the double operation at most maxDoubles times. \\n\\n# Approach\\nTo solve the problem, we can use a greedy approach. We will keep dividing the target integer by 2 as long as it is even and we have remaining double operations available (maxDoubles > 0). After using all the possible double operations, we can simply decrement the target integer by 1 until it becomes 1.\\n\\n# Complexity\\n- Time complexity: The time complexity of the solution is O(log(target)) since in each iteration, we divide the target by 2.\\n\\n- Space complexity: The space complexity is O(1) as we are only using a constant amount of extra space to store the count variable c.\\n\\n# Code\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        c=0\\n        while maxDoubles and  target > 1:\\n            if target%2 == 0 and maxDoubles :\\n                c+=1\\n                maxDoubles-=1\\n                target //=2\\n            else:\\n                target -=1\\n                c+=1\\n        if target>1:\\n            c+=target-1\\n        return c \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        c=0\\n        while maxDoubles and  target > 1:\\n            if target%2 == 0 and maxDoubles :\\n                c+=1\\n                maxDoubles-=1\\n                target //=2\\n            else:\\n                target -=1\\n                c+=1\\n        if target>1:\\n            c+=target-1\\n        return c \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872281,
                "title": "simple-python-solution-beats-90",
                "content": "# Intuition\\n<!-- The problem involves reaching the target integer starting from 1 using two operations: incrementing by one or doubling the current integer. We need to find the minimum number of moves required to reach the target, with the restriction that we can only use the double operation at most maxDoubles times. -->\\n\\n# Approach\\n<!-- To solve the problem, we can use a greedy approach. We will keep dividing the target integer by 2 as long as it is even and we have remaining double operations available (maxDoubles > 0). After using all the possible double operations, we can simply decrement the target integer by 1 until it becomes 1. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Time complexity: The time complexity of the solution is O(log(target)) since in each iteration, we divide the target by 2. -->\\n\\n- Space complexity:\\n<!-- Space complexity: The space complexity is O(1) as we are only using a constant amount of extra space to store the count variable c. -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        c=0\\n        while maxDoubles and  target > 1:\\n            if target%2 == 0 and maxDoubles :\\n                c+=1\\n                maxDoubles-=1\\n                target //=2\\n            else:\\n                target -=1\\n                c+=1\\n        if target>1:\\n            c+=target-1\\n        return c \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        c=0\\n        while maxDoubles and  target > 1:\\n            if target%2 == 0 and maxDoubles :\\n                c+=1\\n                maxDoubles-=1\\n                target //=2\\n            else:\\n                target -=1\\n                c+=1\\n        if target>1:\\n            c+=target-1\\n        return c \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865517,
                "title": "rust-o-log-target-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo minimize the number of moves we should mulitiply bigger numbers\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Start backwards from target\\n* Loop while target > 1 and max_divides > 0\\n    * If target is odd, subtract 1\\n    * Divide by 2 otherwise\\n* Add the difference between the remaining target and 1 to the moves we already accumulated\\n\\n# Complexity\\n- Time complexity: $$O(log(target))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_moves(mut target: i32, mut max_doubles: i32) -> i32 {\\n        let mut ans = 0;\\n\\n        while target > 1 && max_doubles > 0 {\\n            if target % 2 != 0 {\\n                target -= 1;\\n            } else {\\n                target /= 2;\\n                max_doubles -= 1;\\n            }\\n            ans += 1;\\n        }   \\n        ans += target - 1;\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_moves(mut target: i32, mut max_doubles: i32) -> i32 {\\n        let mut ans = 0;\\n\\n        while target > 1 && max_doubles > 0 {\\n            if target % 2 != 0 {\\n                target -= 1;\\n            } else {\\n                target /= 2;\\n                max_doubles -= 1;\\n            }\\n            ans += 1;\\n        }   \\n        ans += target - 1;\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864805,
                "title": "minimum-moves-to-reach-target-score-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        step = 0\\n        while target>1:\\n            if target%2==0 and maxDoubles >0 :\\n                target = target//2\\n                maxDoubles = maxDoubles-1\\n            elif maxDoubles==0:\\n                return (step+target-1)\\n            else:\\n                target = target -1\\n            step = step+1\\n        return step\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        step = 0\\n        while target>1:\\n            if target%2==0 and maxDoubles >0 :\\n                target = target//2\\n                maxDoubles = maxDoubles-1\\n            elif maxDoubles==0:\\n                return (step+target-1)\\n            else:\\n                target = target -1\\n            step = step+1\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824524,
                "title": "easy-to-understand-begineer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n          int move=0;\\n        \\n          int reach=1;\\n        \\n          if(maxDoubles==0){\\n         return target-reach;\\n            }\\n        \\n          while(target!=reach){\\n\\n           if(target%2==1&&maxDoubles>0){\\n            target--;\\n            move++;\\n            }\\n            else if(maxDoubles>0){\\n             target=target/2;\\n                \\n                move++;\\n                maxDoubles--;\\n            \\n            }\\n            \\n            if(maxDoubles==0){\\n            move=move+target-reach;\\n                break;\\n            \\n            }\\n        \\n        }\\n        \\n        \\n        \\n        return move;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMoves(int target, int maxDoubles) {\\n          int move=0;\\n        \\n          int reach=1;\\n        \\n          if(maxDoubles==0){\\n         return target-reach;\\n            }\\n        \\n          while(target!=reach){\\n\\n           if(target%2==1&&maxDoubles>0){\\n            target--;\\n            move++;\\n            }\\n            else if(maxDoubles>0){\\n             target=target/2;\\n                \\n                move++;\\n                maxDoubles--;\\n            \\n            }\\n            \\n            if(maxDoubles==0){\\n            move=move+target-reach;\\n                break;\\n            \\n            }\\n        \\n        }\\n        \\n        \\n        \\n        return move;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1901099,
                "content": [
                    {
                        "username": "chibi_chihiro",
                        "content": "A greedy greedy problem ;)"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "For those confused about solution, try to reverse: reach 1 from your target. If target is odd, can you reach it by division or by adding 1? If your target is even, then you reach it by multiplication (18 can be reached by 9 * 2).\\nShould you stop when you are out of allowed division steps or when you reach 1? Or maybe both?\\n"
                    },
                    {
                        "username": "adityy",
                        "content": "no way this is a medium. it should be tagged as \"easy\" "
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "It may be not straightforward to understand that a greedy approach works here. For example it wouldn\\'t work if you were allowed to both increment and decrement by 1"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is a medium easy. It cannot be flagged as easy as it implies a dynamic programming approach. (Your answer is based on the best option to build target: target / 2 or target -1."
                    },
                    {
                        "username": "RushikaK",
                        "content": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if( target == 1)\\n            return 0;\\n        if( maxDoubles == 0)\\n            return target-1;\\n        int count = 0;\\n        while( maxDoubles > 0 && target > 1) {\\n            if( target%2 == 0 && target/2 == 1) {\\n                return ++count;\\n            }\\n            if( target%2 == 0) {\\n                count = count+1;\\n            } else {\\n                count = count +2;\\n            }\\n            target = target/2;\\n            --maxDoubles;\\n        }\\n        return target > 1 ? (count+target-1): count;\\n    }\\n}"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        s = 0\\n        while maxDoubles > 0 and target > 1:\\n            if target % 2 != 0:\\n                target -= 1\\n                s += 1\\n            else:\\n                target //= 2\\n                s += 1\\n                maxDoubles -= 1\\n        return s + target - 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Are you some kind of dumb or blind?"
                    }
                ]
            },
            {
                "id": 1865584,
                "content": [
                    {
                        "username": "chibi_chihiro",
                        "content": "A greedy greedy problem ;)"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "For those confused about solution, try to reverse: reach 1 from your target. If target is odd, can you reach it by division or by adding 1? If your target is even, then you reach it by multiplication (18 can be reached by 9 * 2).\\nShould you stop when you are out of allowed division steps or when you reach 1? Or maybe both?\\n"
                    },
                    {
                        "username": "adityy",
                        "content": "no way this is a medium. it should be tagged as \"easy\" "
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "It may be not straightforward to understand that a greedy approach works here. For example it wouldn\\'t work if you were allowed to both increment and decrement by 1"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is a medium easy. It cannot be flagged as easy as it implies a dynamic programming approach. (Your answer is based on the best option to build target: target / 2 or target -1."
                    },
                    {
                        "username": "RushikaK",
                        "content": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if( target == 1)\\n            return 0;\\n        if( maxDoubles == 0)\\n            return target-1;\\n        int count = 0;\\n        while( maxDoubles > 0 && target > 1) {\\n            if( target%2 == 0 && target/2 == 1) {\\n                return ++count;\\n            }\\n            if( target%2 == 0) {\\n                count = count+1;\\n            } else {\\n                count = count +2;\\n            }\\n            target = target/2;\\n            --maxDoubles;\\n        }\\n        return target > 1 ? (count+target-1): count;\\n    }\\n}"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        s = 0\\n        while maxDoubles > 0 and target > 1:\\n            if target % 2 != 0:\\n                target -= 1\\n                s += 1\\n            else:\\n                target //= 2\\n                s += 1\\n                maxDoubles -= 1\\n        return s + target - 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Are you some kind of dumb or blind?"
                    }
                ]
            },
            {
                "id": 1832229,
                "content": [
                    {
                        "username": "chibi_chihiro",
                        "content": "A greedy greedy problem ;)"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "For those confused about solution, try to reverse: reach 1 from your target. If target is odd, can you reach it by division or by adding 1? If your target is even, then you reach it by multiplication (18 can be reached by 9 * 2).\\nShould you stop when you are out of allowed division steps or when you reach 1? Or maybe both?\\n"
                    },
                    {
                        "username": "adityy",
                        "content": "no way this is a medium. it should be tagged as \"easy\" "
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "It may be not straightforward to understand that a greedy approach works here. For example it wouldn\\'t work if you were allowed to both increment and decrement by 1"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is a medium easy. It cannot be flagged as easy as it implies a dynamic programming approach. (Your answer is based on the best option to build target: target / 2 or target -1."
                    },
                    {
                        "username": "RushikaK",
                        "content": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if( target == 1)\\n            return 0;\\n        if( maxDoubles == 0)\\n            return target-1;\\n        int count = 0;\\n        while( maxDoubles > 0 && target > 1) {\\n            if( target%2 == 0 && target/2 == 1) {\\n                return ++count;\\n            }\\n            if( target%2 == 0) {\\n                count = count+1;\\n            } else {\\n                count = count +2;\\n            }\\n            target = target/2;\\n            --maxDoubles;\\n        }\\n        return target > 1 ? (count+target-1): count;\\n    }\\n}"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        s = 0\\n        while maxDoubles > 0 and target > 1:\\n            if target % 2 != 0:\\n                target -= 1\\n                s += 1\\n            else:\\n                target //= 2\\n                s += 1\\n                maxDoubles -= 1\\n        return s + target - 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Are you some kind of dumb or blind?"
                    }
                ]
            },
            {
                "id": 1706363,
                "content": [
                    {
                        "username": "chibi_chihiro",
                        "content": "A greedy greedy problem ;)"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "For those confused about solution, try to reverse: reach 1 from your target. If target is odd, can you reach it by division or by adding 1? If your target is even, then you reach it by multiplication (18 can be reached by 9 * 2).\\nShould you stop when you are out of allowed division steps or when you reach 1? Or maybe both?\\n"
                    },
                    {
                        "username": "adityy",
                        "content": "no way this is a medium. it should be tagged as \"easy\" "
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "It may be not straightforward to understand that a greedy approach works here. For example it wouldn\\'t work if you were allowed to both increment and decrement by 1"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is a medium easy. It cannot be flagged as easy as it implies a dynamic programming approach. (Your answer is based on the best option to build target: target / 2 or target -1."
                    },
                    {
                        "username": "RushikaK",
                        "content": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if( target == 1)\\n            return 0;\\n        if( maxDoubles == 0)\\n            return target-1;\\n        int count = 0;\\n        while( maxDoubles > 0 && target > 1) {\\n            if( target%2 == 0 && target/2 == 1) {\\n                return ++count;\\n            }\\n            if( target%2 == 0) {\\n                count = count+1;\\n            } else {\\n                count = count +2;\\n            }\\n            target = target/2;\\n            --maxDoubles;\\n        }\\n        return target > 1 ? (count+target-1): count;\\n    }\\n}"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        s = 0\\n        while maxDoubles > 0 and target > 1:\\n            if target % 2 != 0:\\n                target -= 1\\n                s += 1\\n            else:\\n                target //= 2\\n                s += 1\\n                maxDoubles -= 1\\n        return s + target - 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Are you some kind of dumb or blind?"
                    }
                ]
            },
            {
                "id": 1775126,
                "content": [
                    {
                        "username": "chibi_chihiro",
                        "content": "A greedy greedy problem ;)"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "For those confused about solution, try to reverse: reach 1 from your target. If target is odd, can you reach it by division or by adding 1? If your target is even, then you reach it by multiplication (18 can be reached by 9 * 2).\\nShould you stop when you are out of allowed division steps or when you reach 1? Or maybe both?\\n"
                    },
                    {
                        "username": "adityy",
                        "content": "no way this is a medium. it should be tagged as \"easy\" "
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "It may be not straightforward to understand that a greedy approach works here. For example it wouldn\\'t work if you were allowed to both increment and decrement by 1"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It is a medium easy. It cannot be flagged as easy as it implies a dynamic programming approach. (Your answer is based on the best option to build target: target / 2 or target -1."
                    },
                    {
                        "username": "RushikaK",
                        "content": "class Solution {\\n    public int minMoves(int target, int maxDoubles) {\\n        if( target == 1)\\n            return 0;\\n        if( maxDoubles == 0)\\n            return target-1;\\n        int count = 0;\\n        while( maxDoubles > 0 && target > 1) {\\n            if( target%2 == 0 && target/2 == 1) {\\n                return ++count;\\n            }\\n            if( target%2 == 0) {\\n                count = count+1;\\n            } else {\\n                count = count +2;\\n            }\\n            target = target/2;\\n            --maxDoubles;\\n        }\\n        return target > 1 ? (count+target-1): count;\\n    }\\n}"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def minMoves(self, target: int, maxDoubles: int) -> int:\\n        s = 0\\n        while maxDoubles > 0 and target > 1:\\n            if target % 2 != 0:\\n                target -= 1\\n                s += 1\\n            else:\\n                target //= 2\\n                s += 1\\n                maxDoubles -= 1\\n        return s + target - 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Are you some kind of dumb or blind?"
                    }
                ]
            }
        ]
    }
]