[
    {
        "title": "Minimum Score of a Path Between Two Cities",
        "question_content": "You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.\nThe score of a path between two cities is defined as the minimum distance of a road in this path.\nReturn the minimum possible score of a path between cities 1 and n.\nNote:\n\n\tA path is a sequence of roads between two cities.\n\tIt is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\tThe test cases are generated such that there is at least one path between 1 and n.\n\n&nbsp;\nExample 1:\n\nInput: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\nOutput: 5\nExplanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n\nExample 2:\n\nInput: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\nOutput: 2\nExplanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 105\n\t1 <= roads.length <= 105\n\troads[i].length == 3\n\t1 <= ai, bi <= n\n\tai != bi\n\t1 <= distancei <= 104\n\tThere are no repeated edges.\n\tThere is at least one path between 1 and n.",
        "solutions": [
            {
                "id": 3326775,
                "title": "image-explanation-both-bfs-dfs-approaches-c-java-python-union-find-is-overrated",
                "content": "# Video Solution\\n`Minimum Score of a Path Between Two Cities by Aryan Mittal`\\n![pic.png](https://assets.leetcode.com/users/images/8cd146fa-a7eb-4f3d-925e-85c1e68c2985_1679454380.1627965.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/6ca6c410-6084-4fad-ae99-2aec3295587e_1679450801.7434034.png)\\n![image.png](https://assets.leetcode.com/users/images/28f0d775-ef6b-43c3-b409-7c372a8f68e0_1679450815.562221.png)\\n![image.png](https://assets.leetcode.com/users/images/a68d94f1-5d0b-4935-b1f3-e2541b868a3d_1679450824.9705253.png)\\n![image.png](https://assets.leetcode.com/users/images/9441334b-4ad4-4125-962e-33aee4036b3b_1679450836.1016412.png)\\n![image.png](https://assets.leetcode.com/users/images/83898236-7973-4a1a-992f-c163f4144f54_1679450853.7518644.png)\\n![image.png](https://assets.leetcode.com/users/images/af7689c4-166f-4fa9-9d89-fc3b88db5f79_1679450875.6272192.png)\\n![image.png](https://assets.leetcode.com/users/images/72f948a2-c812-4045-b52b-76b8bfde2601_1679450892.87835.png)\\n![image.png](https://assets.leetcode.com/users/images/4f1b0aa9-2a2d-41ec-8926-d4f128308849_1679450900.6033943.png)\\n\\n\\n# BFS Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX;\\n        vector<vector<pair<int, int>>> gr(n+1);\\n        for(auto edge : roads){ \\n            gr[edge[0]].push_back({edge[1], edge[2]}); // u-> {v, dis}\\n            gr[edge[1]].push_back({edge[0], edge[2]}); // v-> {u, dis}\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1); vis[1] = 1;\\n        while(!q.empty()){\\n            auto node = q.front(); q.pop();\\n            for(auto& [v, dis] : gr[node]){\\n                ans = min(ans, dis);\\n                if(vis[v]==0){\\n                    vis[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int ans = Integer.MAX_VALUE;\\n        List<List<Pair<Integer, Integer>>> gr = new ArrayList<>();\\n        for(int i = 0; i < n+1; i++) {\\n            gr.add(new ArrayList<Pair<Integer, Integer>>());\\n        }\\n\\n        for(int[] edge : roads) { \\n            gr.get(edge[0]).add(new Pair<>(edge[1], edge[2])); // u-> {v, dis}\\n            gr.get(edge[1]).add(new Pair<>(edge[0], edge[2])); // v-> {u, dis}\\n        }\\n\\n        int[] vis = new int[n+1];\\n        Arrays.fill(vis, 0);\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(1);\\n        vis[1] = 1;\\n        while(!q.isEmpty()) {\\n            int node = q.poll();\\n            for(Pair<Integer, Integer> pair : gr.get(node)) {\\n                int v = pair.getKey();\\n                int dis = pair.getValue();\\n                ans = Math.min(ans, dis);\\n                if(vis[v]==0) {\\n                    vis[v] = 1;\\n                    q.add(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nfrom queue import Queue\\nfrom sys import maxsize\\n\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        ans = maxsize\\n        gr = [[] for _ in range(n+1)]\\n        for edge in roads:\\n            gr[edge[0]].append((edge[1], edge[2])) # u-> {v, dis}\\n            gr[edge[1]].append((edge[0], edge[2])) # v-> {u, dis}\\n\\n        vis = [0] * (n+1)\\n        q = Queue()\\n        q.put(1)\\n        vis[1] = 1\\n        while not q.empty():\\n            node = q.get()\\n            for v, dis in gr[node]:\\n                ans = min(ans, dis)\\n                if vis[v] == 0:\\n                    vis[v] = 1\\n                    q.put(v)\\n\\n        return ans\\n```\\n\\n# DFS Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int dfs(int node,int& ans, vector<vector<pair<int, int>>>& gr, vector<int>& vis){\\n        vis[node] = 1;\\n        for(auto& [v, dis] : gr[node]){\\n            ans = min(ans, dis);\\n            if(vis[v]==0){\\n                vis[v] = 1;\\n                ans = min(ans, dfs(v, ans, gr, vis));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX;\\n        vector<vector<pair<int, int>>> gr(n+1);\\n        for(auto edge : roads){ \\n            gr[edge[0]].push_back({edge[1], edge[2]}); // u-> {v, dis}\\n            gr[edge[1]].push_back({edge[0], edge[2]}); // v-> {u, dis}\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        dfs(1, ans, gr, vis);\\n\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX;\\n        vector<vector<pair<int, int>>> gr(n+1);\\n        for(auto edge : roads){ \\n            gr[edge[0]].push_back({edge[1], edge[2]}); // u-> {v, dis}\\n            gr[edge[1]].push_back({edge[0], edge[2]}); // v-> {u, dis}\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1); vis[1] = 1;\\n        while(!q.empty()){\\n            auto node = q.front(); q.pop();\\n            for(auto& [v, dis] : gr[node]){\\n                ans = min(ans, dis);\\n                if(vis[v]==0){\\n                    vis[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int ans = Integer.MAX_VALUE;\\n        List<List<Pair<Integer, Integer>>> gr = new ArrayList<>();\\n        for(int i = 0; i < n+1; i++) {\\n            gr.add(new ArrayList<Pair<Integer, Integer>>());\\n        }\\n\\n        for(int[] edge : roads) { \\n            gr.get(edge[0]).add(new Pair<>(edge[1], edge[2])); // u-> {v, dis}\\n            gr.get(edge[1]).add(new Pair<>(edge[0], edge[2])); // v-> {u, dis}\\n        }\\n\\n        int[] vis = new int[n+1];\\n        Arrays.fill(vis, 0);\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(1);\\n        vis[1] = 1;\\n        while(!q.isEmpty()) {\\n            int node = q.poll();\\n            for(Pair<Integer, Integer> pair : gr.get(node)) {\\n                int v = pair.getKey();\\n                int dis = pair.getValue();\\n                ans = Math.min(ans, dis);\\n                if(vis[v]==0) {\\n                    vis[v] = 1;\\n                    q.add(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nfrom queue import Queue\\nfrom sys import maxsize\\n\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        ans = maxsize\\n        gr = [[] for _ in range(n+1)]\\n        for edge in roads:\\n            gr[edge[0]].append((edge[1], edge[2])) # u-> {v, dis}\\n            gr[edge[1]].append((edge[0], edge[2])) # v-> {u, dis}\\n\\n        vis = [0] * (n+1)\\n        q = Queue()\\n        q.put(1)\\n        vis[1] = 1\\n        while not q.empty():\\n            node = q.get()\\n            for v, dis in gr[node]:\\n                ans = min(ans, dis)\\n                if vis[v] == 0:\\n                    vis[v] = 1\\n                    q.put(v)\\n\\n        return ans\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int dfs(int node,int& ans, vector<vector<pair<int, int>>>& gr, vector<int>& vis){\\n        vis[node] = 1;\\n        for(auto& [v, dis] : gr[node]){\\n            ans = min(ans, dis);\\n            if(vis[v]==0){\\n                vis[v] = 1;\\n                ans = min(ans, dfs(v, ans, gr, vis));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX;\\n        vector<vector<pair<int, int>>> gr(n+1);\\n        for(auto edge : roads){ \\n            gr[edge[0]].push_back({edge[1], edge[2]}); // u-> {v, dis}\\n            gr[edge[1]].push_back({edge[0], edge[2]}); // v-> {u, dis}\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        dfs(1, ans, gr, vis);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875034,
                "title": "python-c-connected-component-of-1-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs traversal of the connected component of `1`. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Comment.** It is guaranteed in the problem that nodes `1` and `n` belong to the connected component of `1`. Any of its edges can be included in the path between `1` and `n`, because the graph is bidirectional and we can visit nodes multiple times (i.e., go back to the visited nodes). Thus, all we have to do is find the edge with minimal weight in the connected component of `1`. \\n\\n**Python.** Using BFS traversal with memoization of visited nodes.\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(dict)\\n        for u, v, w in roads:\\n            graph[u][v] = graph[v][u] = w\\n        \\n        res = inf\\n        vis = set()\\n        dq = deque([1])\\n\\n        while dq:\\n            node = dq.popleft()\\n            for adj, scr in graph[node].items():\\n                if adj not in vis:\\n                    dq.append(adj)\\n                    vis.add(adj)\\n                res = min(res,scr)\\n                \\n        return res\\n```\\n\\n**C++.** Using DFS traversal with memoization of visited nodes.\\n```cpp\\nclass Solution \\n{\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        unordered_map<int,unordered_map<int,int>> graph;\\n        for (auto r : roads)\\n            graph[r[0]][r[1]] = graph[r[1]][r[0]] = r[2];\\n        \\n        unordered_set<int> vis;\\n        \\n        function<int(int)> dfs;\\n        dfs = [&](int n) -> int\\n        {\\n            int res = INT_MAX;\\n            vis.insert(n);\\n            \\n            for (auto[adj, scr] : graph[n])\\n            {\\n                if (!vis.count(adj))\\n                    res = min(res, dfs(adj));\\n                res = min(res, scr);\\n            }\\n            \\n            return res;\\n        };\\n        \\n        return dfs(1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(dict)\\n        for u, v, w in roads:\\n            graph[u][v] = graph[v][u] = w\\n        \\n        res = inf\\n        vis = set()\\n        dq = deque([1])\\n\\n        while dq:\\n            node = dq.popleft()\\n            for adj, scr in graph[node].items():\\n                if adj not in vis:\\n                    dq.append(adj)\\n                    vis.add(adj)\\n                res = min(res,scr)\\n                \\n        return res\\n```\n```cpp\\nclass Solution \\n{\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        unordered_map<int,unordered_map<int,int>> graph;\\n        for (auto r : roads)\\n            graph[r[0]][r[1]] = graph[r[1]][r[0]] = r[2];\\n        \\n        unordered_set<int> vis;\\n        \\n        function<int(int)> dfs;\\n        dfs = [&](int n) -> int\\n        {\\n            int res = INT_MAX;\\n            vis.insert(n);\\n            \\n            for (auto[adj, scr] : graph[n])\\n            {\\n                if (!vis.count(adj))\\n                    res = min(res, dfs(adj));\\n                res = min(res, scr);\\n            }\\n            \\n            return res;\\n        };\\n        \\n        return dfs(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326689,
                "title": "java-easy-bfs",
                "content": "```\\nclass Pair{\\n    int node;\\n    int dist;\\n    Pair(int node,int dist){\\n        this.node=node;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<Pair>> adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++)\\n            adj.add(new ArrayList<>());\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        Queue<Pair> qu=new LinkedList<>();\\n        boolean vis[]=new boolean[n+1];\\n        qu.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(!qu.isEmpty()){\\n            Pair p=qu.poll();\\n            vis[p.node]=true;\\n            ans=Math.min(ans,p.dist);\\n            for(Pair adjcomp:adj.get(p.node)){\\n                if(!vis[adjcomp.node]){\\n                    qu.add(adjcomp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a17b727b-a190-4a53-b611-1ca4b25e761b_1679447458.9686873.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Pair{\\n    int node;\\n    int dist;\\n    Pair(int node,int dist){\\n        this.node=node;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<Pair>> adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++)\\n            adj.add(new ArrayList<>());\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        Queue<Pair> qu=new LinkedList<>();\\n        boolean vis[]=new boolean[n+1];\\n        qu.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(!qu.isEmpty()){\\n            Pair p=qu.poll();\\n            vis[p.node]=true;\\n            ans=Math.min(ans,p.dist);\\n            for(Pair adjcomp:adj.get(p.node)){\\n                if(!vis[adjcomp.node]){\\n                    qu.add(adjcomp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874947,
                "title": "c-use-bfs-easy-efficient-approach",
                "content": "**Approach:** We can\\'t find minimum path score directly by traversing in roads 2d-vector because graph might be disconnected. So, First we mark the visited nodes in vis vector by using bfs then we find minimum score by checking whether ai and bi are visited in roads and calculate minimum value.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        //create adjacency list of roads to make it a graph\\n        vector<pair<int, int>> adj[n+1];\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        \\n        //mark possible visitable nodes \\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1), vis[1]=1;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto it: adj[node])\\n            {\\n                if(!vis[it.first])\\n                {\\n                    q.push(it.first);\\n                    vis[it.first]=1;\\n                }\\n            }\\n        }\\n            \\n        //find minimum path score among visited nodes\\n        int mini_path = INT_MAX;\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            if(vis[roads[i][0]] && vis[roads[i][1]] && roads[i][2] < mini_path)\\n                mini_path = roads[i][2];\\n        }\\n        return mini_path;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        //create adjacency list of roads to make it a graph\\n        vector<pair<int, int>> adj[n+1];\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        \\n        //mark possible visitable nodes \\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1), vis[1]=1;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto it: adj[node])\\n            {\\n                if(!vis[it.first])\\n                {\\n                    q.push(it.first);\\n                    vis[it.first]=1;\\n                }\\n            }\\n        }\\n            \\n        //find minimum path score among visited nodes\\n        int mini_path = INT_MAX;\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            if(vis[roads[i][0]] && vis[roads[i][1]] && roads[i][2] < mini_path)\\n                mini_path = roads[i][2];\\n        }\\n        return mini_path;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874946,
                "title": "dsu-java",
                "content": "```java\\nint[] dsu;\\npublic int minScore(int n, int[][] roads) {\\n    dsu = new int[n+1];\\n    int[] ans = new int[n+1];\\n    for(int i = 0; i <= n; i++) dsu[i] = i;\\n    Arrays.fill(ans, Integer.MAX_VALUE);\\n    for(int[] r : roads){\\n        int a = find(r[0]), b = find(r[1]);\\n        dsu[a] = dsu[b];\\n        ans[a] = ans[b] = Math.min(r[2],Math.min(ans[a],ans[b]));\\n    }\\n    return ans[find(1)];\\n}\\nint find(int i){\\n    return dsu[i]==i ? i : (dsu[i] = find(dsu[i]));\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nint[] dsu;\\npublic int minScore(int n, int[][] roads) {\\n    dsu = new int[n+1];\\n    int[] ans = new int[n+1];\\n    for(int i = 0; i <= n; i++) dsu[i] = i;\\n    Arrays.fill(ans, Integer.MAX_VALUE);\\n    for(int[] r : roads){\\n        int a = find(r[0]), b = find(r[1]);\\n        dsu[a] = dsu[b];\\n        ans[a] = ans[b] = Math.min(r[2],Math.min(ans[a],ans[b]));\\n    }\\n    return ans[find(1)];\\n}\\nint find(int i){\\n    return dsu[i]==i ? i : (dsu[i] = find(dsu[i]));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327539,
                "title": "with-images-and-hints-beats-94-dsu-union-find",
                "content": "# Intuition\\n**The problem has a vive of Travelling Slaesman Problem!! But slightly modified!!**\\n\\nAt first it seems to be very easy. You are probably thinking that you can just iterate through all the roads and get the minimum distance. Then show it as output.\\n\\nBut there\\'s a problem with that solution:\\n\\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int minPath = Integer.MAX_VALUE;\\n        for(int[] road : roads){\\n            minPath = Math.min(road[2], minPath);\\n        }\\n        return minPath;\\n    }\\n}\\n```\\n**Some roads can be completely disjoint from the start node.**\\nIn that case, the above code will give bad answer.\\n\\nSo, what can we do?\\n\\nThe question lies in head is that, we need to first determine some nodes that are connected with each other.\\n\\n**How can we determine some nodes that are connected with each other?**\\nWe can use **UnionFind**!! The parent of the same group nodes will be the same. This way we can find check for nodes that have the same parent as our starting node (**node 1**).\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust do a simple union find implementation. You should also think about storing the ranks. When we make union of two nodes, we should determine who becomes whose parent based on the rank they have.\\n\\nFor example: \\n```\\nInput: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\\n```\\n![image.png](https://assets.leetcode.com/users/images/28b013e2-f17f-45ca-8a5f-52eb82d5ef53_1679466034.1582954.png)\\n\\n## Union Making Simulation:\\n\\n![image.png](https://assets.leetcode.com/users/images/40794f54-d5e8-4c7a-8de8-a128d6ffa1c8_1679466927.9643662.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/66cb0703-0e8b-43e8-b5f2-a803b7ad1a71_1679466978.2681346.png)\\n\\n\\nI haven\\'t shown the edge weights. **A node\\'s parent is pointed by the arrow direction**.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N+E)$$\\nIterating for **N** nodes and **E** edges.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\nWe declare two arrays: parent and rank. They will require n length which is dependent on the input.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    int find(int x){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n\\n    void makeUnion(int x, int y){\\n        int xPar = find(x);\\n        int yPar = find(y);\\n        if(xPar == yPar){\\n            return;\\n        }\\n        else if(rank[xPar]<rank[yPar]){\\n            parent[xPar] = yPar;\\n        }\\n        else if(rank[xPar]>rank[yPar]){\\n            parent[yPar] = xPar;\\n        }\\n        else{\\n            parent[yPar] = xPar;\\n            rank[xPar]++;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        parent = new int[n+1];\\n        rank = new int[n+1];\\n        for(int i=0; i<n+1; i++){\\n            parent[i] = i;\\n        }\\n        int minPath = Integer.MAX_VALUE;\\n        for(int[] road : roads){\\n            makeUnion(road[0], road[1]);\\n        }\\n\\n        // start is always node 1\\n        int xPar = find(1);\\n        for(int[] road: roads){\\n            // end can be any node from the roads array\\n            int yPar = find(road[0]);\\n            if(xPar == yPar) {\\n                minPath = Math.min(minPath, road[2]);\\n            }\\n        }\\n\\n        return minPath;\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/ba74ecc8-2663-469e-80df-23a030c81bee_1679465963.8413434.png)",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int minPath = Integer.MAX_VALUE;\\n        for(int[] road : roads){\\n            minPath = Math.min(road[2], minPath);\\n        }\\n        return minPath;\\n    }\\n}\\n```\n```\\nInput: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\\n```\n```Java []\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    int find(int x){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n\\n    void makeUnion(int x, int y){\\n        int xPar = find(x);\\n        int yPar = find(y);\\n        if(xPar == yPar){\\n            return;\\n        }\\n        else if(rank[xPar]<rank[yPar]){\\n            parent[xPar] = yPar;\\n        }\\n        else if(rank[xPar]>rank[yPar]){\\n            parent[yPar] = xPar;\\n        }\\n        else{\\n            parent[yPar] = xPar;\\n            rank[xPar]++;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        parent = new int[n+1];\\n        rank = new int[n+1];\\n        for(int i=0; i<n+1; i++){\\n            parent[i] = i;\\n        }\\n        int minPath = Integer.MAX_VALUE;\\n        for(int[] road : roads){\\n            makeUnion(road[0], road[1]);\\n        }\\n\\n        // start is always node 1\\n        int xPar = find(1);\\n        for(int[] road: roads){\\n            // end can be any node from the roads array\\n            int yPar = find(road[0]);\\n            if(xPar == yPar) {\\n                minPath = Math.min(minPath, road[2]);\\n            }\\n        }\\n\\n        return minPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875119,
                "title": "dsu-bfs-dfs",
                "content": "# Intuition:\\n- We can go and visit any edge in an undirected graph & `[1 , n]` are in same component.\\n- We will take advantage of this & we will simply get min edge weight by starting `DSU / bfs / dfs` from 1.\\n\\n> Take minimum edge weight\\n\\n**DSU**\\n> We just need edges which are in component of 1 or n, so we can use DSU in these scenarios when we need to filter a type of edges only.\\n\\nWe will put every edge in `dsu`.\\nThen we will `trace` the edges again & `filter` edges which are connected to `1` or `n`.\\n> This one is much faster than bfs/dfs.\\n# C++\\n    class DSU{\\n        vector<int> par, rank;\\n    public:\\n        DSU(int n) : par(n) , rank(n) {\\n            iota(begin(par), end(par), 0);\\n        }\\n        \\n        int find(int u){\\n            return par[u] = u == par[u] ? u : find(par[u]);\\n        }\\n        \\n        void connect(int u, int v){\\n            u = find(u);\\n            v = find(v);\\n            if(rank[u] > rank[v]) par[v] = u;\\n            else if(rank[u] < rank[v]) par[u] = v;\\n            else  rank[v]++ , par[u] = v;\\n        }\\n    };\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        ios_base::sync_with_stdio(false);  cin.tie(NULL);\\n        \\n        //Put edges in DSU\\n        DSU d(n + 1);\\n        for(auto e: roads) d.connect(e[0], e[1]);\\n\\t\\t\\n\\t\\t//Filter edges & update minimum edge weight\\n        int x = d.find(1) , res = 1e5;\\n        for(auto e: roads){\\n            int u = d.find(e[0]), v = d.find(e[1]);\\n            if(u == x or v == x)  res = min(res, e[2]); \\n        }\\n        return res;\\n    }\\n\\t\\n# Java\\t\\n\\tpublic class DSU {\\n        private int []par;\\n        private int []rank;\\n        \\n        public DSU(int n){\\n            par = new int[n];\\n            rank= new int[n];\\n            for(int i = 0; i < n;i++) par[i] = i;\\n        }\\n        \\n        public int find(int u){\\n            if(u == par[u]) return u;\\n            return par[u] = find(par[u]);\\n        }\\n        \\n        public void connect(int u, int v){\\n            u = find(u);\\n            v = find(v);\\n            if(rank[u] > rank[v]) par[v] = u;\\n            else if(rank[u] < rank[v]) par[u] = v;\\n            else {\\n                rank[v]++; par[u] = v;\\n            }\\n        }\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n        DSU d = new DSU(n + 1);\\n        for(var e: roads) d.connect(e[0], e[1]);\\n        \\n        int leader = d.find(1);\\n        \\n        //Filter edges & update minimum edge weight\\n        int res = 100000;\\n        for(var e: roads){\\n            int u = d.find(e[0]), v = d.find(e[1]);\\n            if(u == leader || v == leader) res = Math.min(res, e[2]); \\n        }\\n        \\n        return res;\\n    }\\n\\n**BFS**\\n# C++\\n     int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}),  G[i[1]].push_back({i[0], i[2]});\\n        \\n        vector<int> seen(n + 1);\\n        int mini = 1e5;\\n        queue<int> q{{{1}}};\\n        seen[1] = 1;\\n        while(q.size()){\\n            int u = q.front(); q.pop();\\n            for(auto &[v,w] : G[u]){\\n                mini = min(mini, w);\\n                if(!seen[v]){\\n                    seen[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n\\n**DFS - 1**\\n# C++\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> seen(n + 1);\\n\\t\\tseen[1] = true;\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}) ,  G[i[1]].push_back({i[0], i[2]});\\n    \\n        function<int(int)> dfs = [&](int u){\\n            int min_edge = 100000;\\n            for(auto &[v,w] : G[u]){\\n                 min_edge = min(min_edge, w);\\n                 if(!seen[v]){\\n                    seen[v] = 1;\\n                    min_edge = min(min_edge, dfs(v));\\n                 }\\n            }\\n            return min_edge;\\n        };\\n        \\n        return dfs(1);\\n    }\\n\\t\\n**DFS - 2**\\n# C++\\t\\n\\tint minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> seen(n + 1);\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}) , G[i[1]].push_back({i[0], i[2]});\\n    \\n        function<int(int)> dfs = [&](int u){\\n            if(seen[u]) return 100000;\\n            seen[u] = true;\\n            int min_edge = 100000;\\n            for(auto &[v,w] : G[u])\\n                 min_edge = min({min_edge, w, dfs(v)});\\n            return min_edge;\\n        };\\n        \\n        return dfs(1);\\n    }\\n\\t\\n> **Time** - O(n + m)\\n\\n> **Space** - O(n)\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# Intuition:\\n- We can go and visit any edge in an undirected graph & `[1 , n]` are in same component.\\n- We will take advantage of this & we will simply get min edge weight by starting `DSU / bfs / dfs` from 1.\\n\\n> Take minimum edge weight\\n\\n**DSU**\\n> We just need edges which are in component of 1 or n, so we can use DSU in these scenarios when we need to filter a type of edges only.\\n\\nWe will put every edge in `dsu`.\\nThen we will `trace` the edges again & `filter` edges which are connected to `1` or `n`.\\n> This one is much faster than bfs/dfs.\\n# C++\\n    class DSU{\\n        vector<int> par, rank;\\n    public:\\n        DSU(int n) : par(n) , rank(n) {\\n            iota(begin(par), end(par), 0);\\n        }\\n        \\n        int find(int u){\\n            return par[u] = u == par[u] ? u : find(par[u]);\\n        }\\n        \\n        void connect(int u, int v){\\n            u = find(u);\\n            v = find(v);\\n            if(rank[u] > rank[v]) par[v] = u;\\n            else if(rank[u] < rank[v]) par[u] = v;\\n            else  rank[v]++ , par[u] = v;\\n        }\\n    };\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        ios_base::sync_with_stdio(false);  cin.tie(NULL);\\n        \\n        //Put edges in DSU\\n        DSU d(n + 1);\\n        for(auto e: roads) d.connect(e[0], e[1]);\\n\\t\\t\\n\\t\\t//Filter edges & update minimum edge weight\\n        int x = d.find(1) , res = 1e5;\\n        for(auto e: roads){\\n            int u = d.find(e[0]), v = d.find(e[1]);\\n            if(u == x or v == x)  res = min(res, e[2]); \\n        }\\n        return res;\\n    }\\n\\t\\n# Java\\t\\n\\tpublic class DSU {\\n        private int []par;\\n        private int []rank;\\n        \\n        public DSU(int n){\\n            par = new int[n];\\n            rank= new int[n];\\n            for(int i = 0; i < n;i++) par[i] = i;\\n        }\\n        \\n        public int find(int u){\\n            if(u == par[u]) return u;\\n            return par[u] = find(par[u]);\\n        }\\n        \\n        public void connect(int u, int v){\\n            u = find(u);\\n            v = find(v);\\n            if(rank[u] > rank[v]) par[v] = u;\\n            else if(rank[u] < rank[v]) par[u] = v;\\n            else {\\n                rank[v]++; par[u] = v;\\n            }\\n        }\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n        DSU d = new DSU(n + 1);\\n        for(var e: roads) d.connect(e[0], e[1]);\\n        \\n        int leader = d.find(1);\\n        \\n        //Filter edges & update minimum edge weight\\n        int res = 100000;\\n        for(var e: roads){\\n            int u = d.find(e[0]), v = d.find(e[1]);\\n            if(u == leader || v == leader) res = Math.min(res, e[2]); \\n        }\\n        \\n        return res;\\n    }\\n\\n**BFS**\\n# C++\\n     int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}),  G[i[1]].push_back({i[0], i[2]});\\n        \\n        vector<int> seen(n + 1);\\n        int mini = 1e5;\\n        queue<int> q{{{1}}};\\n        seen[1] = 1;\\n        while(q.size()){\\n            int u = q.front(); q.pop();\\n            for(auto &[v,w] : G[u]){\\n                mini = min(mini, w);\\n                if(!seen[v]){\\n                    seen[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n\\n**DFS - 1**\\n# C++\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> seen(n + 1);\\n\\t\\tseen[1] = true;\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}) ,  G[i[1]].push_back({i[0], i[2]});\\n    \\n        function<int(int)> dfs = [&](int u){\\n            int min_edge = 100000;\\n            for(auto &[v,w] : G[u]){\\n                 min_edge = min(min_edge, w);\\n                 if(!seen[v]){\\n                    seen[v] = 1;\\n                    min_edge = min(min_edge, dfs(v));\\n                 }\\n            }\\n            return min_edge;\\n        };\\n        \\n        return dfs(1);\\n    }\\n\\t\\n**DFS - 2**\\n# C++\\t\\n\\tint minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> seen(n + 1);\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}) , G[i[1]].push_back({i[0], i[2]});\\n    \\n        function<int(int)> dfs = [&](int u){\\n            if(seen[u]) return 100000;\\n            seen[u] = true;\\n            int min_edge = 100000;\\n            for(auto &[v,w] : G[u])\\n                 min_edge = min({min_edge, w, dfs(v)});\\n            return min_edge;\\n        };\\n        \\n        return dfs(1);\\n    }\\n\\t\\n> **Time** - O(n + m)\\n\\n> **Space** - O(n)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2875316,
                "title": "using-dijkstra-modified",
                "content": "\\n**creating the adj list**\\n**applying dijkstra and storing min dist of nodes**\\n**applying min distn of all nodes**\\n```\\nclass pair{\\n    int node;\\n    int dist;\\n    pair(int node1,int dist1){\\n        node=node1;\\n        dist=dist1;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        //creating the adj list\\n        List<List<pair>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++)adj.add(new ArrayList<>());\\n        \\n        for(int p[]:roads){\\n            adj.get(p[0]).add(new pair(p[1],p[2]));\\n            adj.get(p[1]).add(new pair(p[0],p[2]));\\n        }\\n        //pq for dijkstra\\n        Queue<pair> q=new PriorityQueue<>((a,b)->a.dist-b.dist);\\n        q.add(new pair(1,0));\\n        int distn[]=new int[n+1];\\n        Arrays.fill(distn,Integer.MAX_VALUE);\\n     \\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int node=it.node;\\n            int dis=it.dist;\\n            for(pair x1:adj.get(node)){\\n                //just storing the min edge modifying the dijkstra\\n                if(x1.dist<distn[x1.node]){\\n                    distn[x1.node]=x1.dist;\\n                    q.add(new pair(x1.node,distn[x1.node]));\\n                }\\n            }\\n        }\\n        //finding out min distn out of all node distn array\\n        int min=(int)1e9;\\n         for(int i=0;i<=n;i++){\\n            // System.out.print(distn[i]+\" \");\\n             min=Math.min(distn[i],min);\\n         }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass pair{\\n    int node;\\n    int dist;\\n    pair(int node1,int dist1){\\n        node=node1;\\n        dist=dist1;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        //creating the adj list\\n        List<List<pair>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++)adj.add(new ArrayList<>());\\n        \\n        for(int p[]:roads){\\n            adj.get(p[0]).add(new pair(p[1],p[2]));\\n            adj.get(p[1]).add(new pair(p[0],p[2]));\\n        }\\n        //pq for dijkstra\\n        Queue<pair> q=new PriorityQueue<>((a,b)->a.dist-b.dist);\\n        q.add(new pair(1,0));\\n        int distn[]=new int[n+1];\\n        Arrays.fill(distn,Integer.MAX_VALUE);\\n     \\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int node=it.node;\\n            int dis=it.dist;\\n            for(pair x1:adj.get(node)){\\n                //just storing the min edge modifying the dijkstra\\n                if(x1.dist<distn[x1.node]){\\n                    distn[x1.node]=x1.dist;\\n                    q.add(new pair(x1.node,distn[x1.node]));\\n                }\\n            }\\n        }\\n        //finding out min distn out of all node distn array\\n        int min=(int)1e9;\\n         for(int i=0;i<=n;i++){\\n            // System.out.print(distn[i]+\" \");\\n             min=Math.min(distn[i],min);\\n         }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874942,
                "title": "c-solution-using-bfs-explained",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nApproach : \\nWe need to traverse the graph starting from 1 to all connected node and get the shortest path linked to each node we visit.\\nNo need to worry about target, as it is given that there must be a ptah to the target.\\n\\nAlgo:\\n1. Create a weighted graph.\\n2. Run BFS from 1\\n3. which every node encountered, check for all the path liked to the nodes for sortest one; irrespective of it is got visited or not.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX; \\n        //create a weighted graph\\n        vector<vector<pair<int, int>>> g(n + 1);\\n        for(auto r: roads){\\n            g[r[0]].push_back({r[1], r[2]});\\n            g[r[1]].push_back({r[0], r[2]});\\n        }\\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1); vis[1] = 1;    //run bfs from 1\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            for(auto i: g[node]){\\n                ans = min(ans, i.second);   //check for min path length\\n                if(vis[i.first] != 1){\\n                    vis[i.first] = 1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nApproach : \\nWe need to traverse the graph starting from 1 to all connected node and get the shortest path linked to each node we visit.\\nNo need to worry about target, as it is given that there must be a ptah to the target.\\n\\nAlgo:\\n1. Create a weighted graph.\\n2. Run BFS from 1\\n3. which every node encountered, check for all the path liked to the nodes for sortest one; irrespective of it is got visited or not.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX; \\n        //create a weighted graph\\n        vector<vector<pair<int, int>>> g(n + 1);\\n        for(auto r: roads){\\n            g[r[0]].push_back({r[1], r[2]});\\n            g[r[1]].push_back({r[0], r[2]});\\n        }\\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1); vis[1] = 1;    //run bfs from 1\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            for(auto i: g[node]){\\n                ans = min(ans, i.second);   //check for min path length\\n                if(vis[i.first] != 1){\\n                    vis[i.first] = 1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874945,
                "title": "easy-to-understand-pictorial-solution",
                "content": "Let\\'s assume the graph to be like:\\n\\n<img src=\"https://assets.leetcode.com/users/images/f83779b5-a4c9-476b-9a10-09bd0101f91d_1670125011.6390007.jpeg\" height=300 width=350>\\n\\nNow, from the graph we can see that it is not fully connected and is divided into two subgraphs with brown and green balls. We can observe that node 1 and n and connected in the brown balls graph. \\n\\nNow, we need to group all the brown balls graph and green balls graph as follows:\\n\\n<img src=\"https://assets.leetcode.com/users/images/215a8b7e-12a3-40db-9647-caf701dd79c2_1670125062.7306428.jpeg\" height=250 width=200>\\n\\nSince we can reach any node any number of times, it\\'s simple that we just need to know the minimum value in the brow balls graph(since node 1 and n are there in brown balls graph).\\n\\nSo for this, a new dictionary with minimum route value as a value to every node as key is stored and simply we can fetch the minimum value of all the nodes in brown balls graph.\\n\\nCODE:\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        minValues={}\\n        for i in roads:\\n            graph[i[0]].append([i[1],i[2]])\\n            graph[i[1]].append([i[0],i[2]])\\n            \\n            if(i[0] not in minValues):minValues[i[0]]=i[2]\\n            else:minValues[i[0]]=min(minValues[i[0]],i[2])\\n            \\n            if(i[1] not in minValues):minValues[i[1]]=i[2]\\n            else:minValues[i[1]]=min(minValues[i[1]],i[2])\\n                \\n        vis=set()\\n        q=deque([1])\\n        while(q):\\n            v=q.popleft()\\n            for j in graph[v]:\\n                if(j[0] not in vis):\\n                    vis.add(j[0])\\n                    q.append(j[0])\\n\\t\\t\\t\\t\\t\\n        #Here, vis is the set of all brown balls graph!\\n        \\n        min_value=float(\\'inf\\')\\n        for i in vis:\\n            min_value=min(min_value,minValues[i])\\n        return min_value\\n```\\n\\n**Time-Complexity: O(n)\\nSpace-Complexity:O(n)**\\n\\nUpvote if you like it :)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        minValues={}\\n        for i in roads:\\n            graph[i[0]].append([i[1],i[2]])\\n            graph[i[1]].append([i[0],i[2]])\\n            \\n            if(i[0] not in minValues):minValues[i[0]]=i[2]\\n            else:minValues[i[0]]=min(minValues[i[0]],i[2])\\n            \\n            if(i[1] not in minValues):minValues[i[1]]=i[2]\\n            else:minValues[i[1]]=min(minValues[i[1]],i[2])\\n                \\n        vis=set()\\n        q=deque([1])\\n        while(q):\\n            v=q.popleft()\\n            for j in graph[v]:\\n                if(j[0] not in vis):\\n                    vis.add(j[0])\\n                    q.append(j[0])\\n\\t\\t\\t\\t\\t\\n        #Here, vis is the set of all brown balls graph!\\n        \\n        min_value=float(\\'inf\\')\\n        for i in vis:\\n            min_value=min(min_value,minValues[i])\\n        return min_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326645,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a graph with weighted edges, we can find the minimum cost path between any two vertices using a minimum spanning tree. A minimum spanning tree is a tree that connects all the vertices of the graph with the minimum total edge weight.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are different algorithms to find the minimum spanning tree of a graph, such as Prim\\'s algorithm and Kruskal\\'s algorithm. In general, these algorithms start with an empty tree and iteratively add the edge with the minimum weight that connects a vertex in the tree with a\\nvertex outside the tree. The process continues until all the vertices are in the tree.\\n\\nFor example, Kruskal\\'s algorithm works as follows:\\n1. Sort all the edges in non-decreasing order of their weight.\\n2. Initialize an empty tree and a set of connected components, where each vertex is a component.\\n3. Iterate through the sorted edges and add the edge to the tree if its endpoints belong to different connected components. Merge the components containing the endpoints of the edge.\\n4. Stop the iteration when the tree has N-1 edges, where N is the number of vertices in the\\ngraph\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of Kruskal\\'s algorithm is O(Elog(E)), where E is the number of edges in the graph. The time complexity is dominated by the sorting of the edges, which takes O(Elog(E)) time. The iterations of the for loop take O(E) time in total.\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of Kruskal\\'s algorithm is O(E + V), where V is the number of vertices in the graph. The space is required to store the edges, the connected components, and the parent pointers of each vertex in the connected components (to implement the union-find data structure).\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {  \\n        // Sort the roads array based on the first element of each subarray\\n        Arrays.sort(roads, (a, b)->{\\n            return a[0] - b[0];\\n        });\\n        // Initialize a set to keep track of the cities visited in the path\\n        HashSet<Integer> set = new HashSet<>();\\n        // Add the first city and the second city in the first road to the set\\n        set.add(roads[0][0]);\\n        set.add(roads[0][1]);\\n        // Initialize the minimum distance to be the distance of the first road\\n        int min = roads[0][2];\\n        // Repeat the following loop 100 times\\n        for(int j = 0; j < 100; j++){\\n            // Loop through each road in the sorted roads array\\n            for(int i = 1; i < roads.length; i++){\\n                // If either of the cities in the road is in the set, then add the other city to the set\\n                if(set.contains(roads[i][0]) || set.contains(roads[i][1])){\\n                    // Update the minimum distance if the distance of the current road is smaller\\n                    min = Math.min(roads[i][2], min);\\n                    set.add(roads[i][0]);\\n                    set.add(roads[i][1]);\\n                }\\n            }\\n        }        \\n        // Return the minimum distance found\\n        return min;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // Create an adjacency list to represent the graph\\n        unordered_map<int, unordered_map<int, int>> graph;\\n        for(auto road: roads){\\n            int u = road[0], v = road[1], w = road[2];\\n            graph[u][v] = graph[v][u] = w;\\n        }\\n        \\n        // Initialize variables for the minimum score and visited nodes\\n        int min_score = INT_MAX;\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n        \\n        // Use BFS to traverse the graph\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto adj: graph[node]){\\n                int neighbor = adj.first, score = adj.second;\\n                if(visited.count(neighbor) == 0){\\n                    q.push(neighbor);\\n                    visited.insert(neighbor);\\n                }\\n                min_score = min(min_score, score);\\n            }\\n        }\\n        \\n        // Return the minimum score found\\n        return min_score;\\n    }\\n};\\n\\n```\\n``` Python3 []\\nclass Solution:\\n    def minScore(self, num_nodes: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(dict)\\n        for u, v, w in edges:\\n            graph[u][v] = graph[v][u] = w\\n        \\n        min_score = float(\\'inf\\')\\n        visited = set()\\n        queue = deque([1])\\n\\n        while queue:\\n            node = queue.popleft()\\n            for adj, score in graph[node].items():\\n                if adj not in visited:\\n                    queue.append(adj)\\n                    visited.add(adj)\\n                min_score = min(min_score, score)\\n                \\n        return min_score\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {  \\n        // Sort the roads array based on the first element of each subarray\\n        Arrays.sort(roads, (a, b)->{\\n            return a[0] - b[0];\\n        });\\n        // Initialize a set to keep track of the cities visited in the path\\n        HashSet<Integer> set = new HashSet<>();\\n        // Add the first city and the second city in the first road to the set\\n        set.add(roads[0][0]);\\n        set.add(roads[0][1]);\\n        // Initialize the minimum distance to be the distance of the first road\\n        int min = roads[0][2];\\n        // Repeat the following loop 100 times\\n        for(int j = 0; j < 100; j++){\\n            // Loop through each road in the sorted roads array\\n            for(int i = 1; i < roads.length; i++){\\n                // If either of the cities in the road is in the set, then add the other city to the set\\n                if(set.contains(roads[i][0]) || set.contains(roads[i][1])){\\n                    // Update the minimum distance if the distance of the current road is smaller\\n                    min = Math.min(roads[i][2], min);\\n                    set.add(roads[i][0]);\\n                    set.add(roads[i][1]);\\n                }\\n            }\\n        }        \\n        // Return the minimum distance found\\n        return min;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // Create an adjacency list to represent the graph\\n        unordered_map<int, unordered_map<int, int>> graph;\\n        for(auto road: roads){\\n            int u = road[0], v = road[1], w = road[2];\\n            graph[u][v] = graph[v][u] = w;\\n        }\\n        \\n        // Initialize variables for the minimum score and visited nodes\\n        int min_score = INT_MAX;\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n        \\n        // Use BFS to traverse the graph\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto adj: graph[node]){\\n                int neighbor = adj.first, score = adj.second;\\n                if(visited.count(neighbor) == 0){\\n                    q.push(neighbor);\\n                    visited.insert(neighbor);\\n                }\\n                min_score = min(min_score, score);\\n            }\\n        }\\n        \\n        // Return the minimum score found\\n        return min_score;\\n    }\\n};\\n\\n```\n``` Python3 []\\nclass Solution:\\n    def minScore(self, num_nodes: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(dict)\\n        for u, v, w in edges:\\n            graph[u][v] = graph[v][u] = w\\n        \\n        min_score = float(\\'inf\\')\\n        visited = set()\\n        queue = deque([1])\\n\\n        while queue:\\n            node = queue.popleft()\\n            for adj, score in graph[node].items():\\n                if adj not in visited:\\n                    queue.append(adj)\\n                    visited.add(adj)\\n                min_score = min(min_score, score)\\n                \\n        return min_score\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875970,
                "title": "simple-dfs",
                "content": "**Idea :** Aim is to traverse all possible paths in between 1 & n  and find the minimal weighted edge among all the paths.\\n*Note -* Graph is not necessarily connected but we are concerned about only paths connecting 1 & n so single dfs call is made from source i.e. 1\\n\\n```\\n    int mini = INT_MAX;\\n    \\n    void dfs(int s, vector<bool>&vis, vector<pair<int, int>>adj[]) {\\n        vis[s] = true;\\n        \\n        for(auto &it : adj[s]) {\\n            int v = it.first, wt = it.second;\\n            mini = min(mini, wt);\\n            if(!vis[v])\\n                dfs(v, vis, adj);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector< pair<int, int> > adj[n+1];\\n        for(auto &it : roads) {\\n            int u = it[0], v = it[1], wt = it[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n        \\n        vector<bool>vis(n+1, false);\\n        dfs(1, vis, adj);\\n        \\n        return mini;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n    int mini = INT_MAX;\\n    \\n    void dfs(int s, vector<bool>&vis, vector<pair<int, int>>adj[]) {\\n        vis[s] = true;\\n        \\n        for(auto &it : adj[s]) {\\n            int v = it.first, wt = it.second;\\n            mini = min(mini, wt);\\n            if(!vis[v])\\n                dfs(v, vis, adj);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector< pair<int, int> > adj[n+1];\\n        for(auto &it : roads) {\\n            int u = it[0], v = it[1], wt = it[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n        \\n        vector<bool>vis(n+1, false);\\n        dfs(1, vis, adj);\\n        \\n        return mini;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326946,
                "title": "c-bfs-commented-solution-simple",
                "content": "# Complexity\\n- Time complexity:\\nO(nodes + edges) + O(m) + O(m)\\n\\n- Space complexity:\\nO(m) + O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        // Storing graph in a adjacency list\\n        vector<int> adj[n+1];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        // making a visited array for keep tracking of all the cities (we have visited or not)\\n        // n = number of cities\\n        vector<bool> vis(n+1,false);\\n        vis[1] = true;                                  // mark source node as a visited city\\n        \\n        // BFS\\n        queue<int> q;\\n        q.push(1);\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto &it : adj[node])\\n            {\\n                if(!vis[it])\\n                {\\n                    vis[it] = true;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n\\n        // Computing minimum distance from city 1 to n\\n        int ans = INT_MAX;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            // minimum possible score out of all available paths\\n            // if src and dest both are visited cities then try to make this our ans\\n            if(vis[roads[i][0]] && vis[roads[i][1]])\\n            {\\n                ans = min(ans,roads[i][2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        // Storing graph in a adjacency list\\n        vector<int> adj[n+1];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        // making a visited array for keep tracking of all the cities (we have visited or not)\\n        // n = number of cities\\n        vector<bool> vis(n+1,false);\\n        vis[1] = true;                                  // mark source node as a visited city\\n        \\n        // BFS\\n        queue<int> q;\\n        q.push(1);\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto &it : adj[node])\\n            {\\n                if(!vis[it])\\n                {\\n                    vis[it] = true;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n\\n        // Computing minimum distance from city 1 to n\\n        int ans = INT_MAX;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            // minimum possible score out of all available paths\\n            // if src and dest both are visited cities then try to make this our ans\\n            if(vis[roads[i][0]] && vis[roads[i][1]])\\n            {\\n                ans = min(ans,roads[i][2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875643,
                "title": "java-3-solutions-union-find-dfs-bfs",
                "content": "# 3.DFS\\n```\\n\\t//3.DFS\\n    //Runtime: 49 ms, faster than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 114.2 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: (N + E); Space: O(E + N);\\n    public int minScore_3(int n, int[][] roads) {\\n        List<int[]>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] road: roads){\\n            graph[road[0]].add(new int[]{road[1], road[2]});\\n            graph[road[1]].add(new int[]{road[0], road[2]});\\n        }\\n        Set<Integer> seen = new HashSet<>();\\n        seen.add(1);\\n        return helper_dfs(graph, 1, seen);\\n    }\\n\\n    private int helper_dfs(List<int[]>[] graph, int node, Set<Integer> seen) {\\n        int res = Integer.MAX_VALUE;\\n        for(int[] neighbour : graph[node]) {\\n            res = Math.min(res, neighbour[1]);\\n            if (seen.add(neighbour[0]))\\n                res = Math.min(res, helper_dfs(graph, neighbour[0], seen));\\n        }\\n        return res;\\n    }\\n```\\n# 2.BFS\\n```\\n    //2.BFS\\n    //Runtime: 48 ms, faster than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 111.8 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: (N + E); Space: O(E + N);\\n    public int minScore_2(int n, int[][] roads) {\\n        int res = Integer.MAX_VALUE;\\n\\n        List<int[]>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] road: roads){\\n            graph[road[0]].add(new int[]{road[1], road[2]});\\n            graph[road[1]].add(new int[]{road[0], road[2]});\\n        }\\n\\n        Set<Integer> seen = new HashSet<>();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(1);\\n        seen.add(1);\\n\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            for(int[] neighbour: graph[node]){\\n                res = Math.min(res, neighbour[1]);\\n                if (seen.add(neighbour[0])) queue.add(neighbour[0]);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n# 1.Union find\\n```\\n    //1.Union find\\n    //Runtime: 7 ms, faster than 62.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 108.1 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: O(E * log(N); Space:O(N)\\n    public int minScore(int n, int[][] roads) {\\n        UnionFind uf = new UnionFind(n + 1);\\n        for(int[] road: roads)\\n            uf.union(road[0], road[1], road[2]);\\n\\n        int group = uf.find(1);\\n        if (group == uf.find(n)) return uf.distance[group];\\n\\n        return -1;\\n    }\\n\\n    public class UnionFind {\\n\\n        private int[] group;\\n        private int[] rank;\\n        private int[] distance;\\n\\n        public UnionFind(int size) {\\n            group = new int[size];\\n            rank = new int[size];\\n            distance = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                group[i] = i; rank[i] = 1;\\n                distance[i] = Integer.MAX_VALUE;\\n            }\\n        }\\n\\n        //Time: O(\\u03B1(N))\\n        public int find(int x) {\\n            return x == group[x] ? x: (group[x] = find(group[x]));\\n        }\\n\\n        public void union(int x, int y, int d){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            int minD = Math.min(distance[rootX], distance[rootY]);\\n            minD = Math.min(minD, d);\\n            distance[rootX] = distance[rootY] = minD;\\n\\n            if (rootX == rootY) return;\\n\\n            if (rank[rootX] < rank[rootY]){\\n                group[rootX] = rootY;\\n            }else{\\n                group[rootY] = rootX;\\n                if (rank[rootX] == rank[rootY]) rank[rootX]++;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\n\\t//3.DFS\\n    //Runtime: 49 ms, faster than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 114.2 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: (N + E); Space: O(E + N);\\n    public int minScore_3(int n, int[][] roads) {\\n        List<int[]>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] road: roads){\\n            graph[road[0]].add(new int[]{road[1], road[2]});\\n            graph[road[1]].add(new int[]{road[0], road[2]});\\n        }\\n        Set<Integer> seen = new HashSet<>();\\n        seen.add(1);\\n        return helper_dfs(graph, 1, seen);\\n    }\\n\\n    private int helper_dfs(List<int[]>[] graph, int node, Set<Integer> seen) {\\n        int res = Integer.MAX_VALUE;\\n        for(int[] neighbour : graph[node]) {\\n            res = Math.min(res, neighbour[1]);\\n            if (seen.add(neighbour[0]))\\n                res = Math.min(res, helper_dfs(graph, neighbour[0], seen));\\n        }\\n        return res;\\n    }\\n```\n```\\n    //2.BFS\\n    //Runtime: 48 ms, faster than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 111.8 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: (N + E); Space: O(E + N);\\n    public int minScore_2(int n, int[][] roads) {\\n        int res = Integer.MAX_VALUE;\\n\\n        List<int[]>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] road: roads){\\n            graph[road[0]].add(new int[]{road[1], road[2]});\\n            graph[road[1]].add(new int[]{road[0], road[2]});\\n        }\\n\\n        Set<Integer> seen = new HashSet<>();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(1);\\n        seen.add(1);\\n\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            for(int[] neighbour: graph[node]){\\n                res = Math.min(res, neighbour[1]);\\n                if (seen.add(neighbour[0])) queue.add(neighbour[0]);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    //1.Union find\\n    //Runtime: 7 ms, faster than 62.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 108.1 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: O(E * log(N); Space:O(N)\\n    public int minScore(int n, int[][] roads) {\\n        UnionFind uf = new UnionFind(n + 1);\\n        for(int[] road: roads)\\n            uf.union(road[0], road[1], road[2]);\\n\\n        int group = uf.find(1);\\n        if (group == uf.find(n)) return uf.distance[group];\\n\\n        return -1;\\n    }\\n\\n    public class UnionFind {\\n\\n        private int[] group;\\n        private int[] rank;\\n        private int[] distance;\\n\\n        public UnionFind(int size) {\\n            group = new int[size];\\n            rank = new int[size];\\n            distance = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                group[i] = i; rank[i] = 1;\\n                distance[i] = Integer.MAX_VALUE;\\n            }\\n        }\\n\\n        //Time: O(\\u03B1(N))\\n        public int find(int x) {\\n            return x == group[x] ? x: (group[x] = find(group[x]));\\n        }\\n\\n        public void union(int x, int y, int d){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            int minD = Math.min(distance[rootX], distance[rootY]);\\n            minD = Math.min(minD, d);\\n            distance[rootX] = distance[rootY] = minD;\\n\\n            if (rootX == rootY) return;\\n\\n            if (rank[rootX] < rank[rootY]){\\n                group[rootX] = rootY;\\n            }else{\\n                group[rootY] = rootX;\\n                if (rank[rootX] == rank[rootY]) rank[rootX]++;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326975,
                "title": "day-81-union-find-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThis code implements a solution to the problem of finding the minimum score among all paths that connect the first city to every other city in a graph, where each edge is associated with a score. The solution is based on the union-find algorithm, which is used to merge the sets of vertices that are connected by each edge.\\n\\nInitially, each vertex is considered as a separate set, with its parent being itself. Then, for each edge, we find the root of the set that contains its two vertices, and merge the two sets by setting the parent of one of the roots to the other root. The rank of each set is also updated accordingly to keep the tree balanced.\\n\\nFinally, we iterate over all the edges again and find the root of the set that contains the first city, as well as the roots of the sets that contain the two vertices of each edge. If all three roots are the same, it means that the edge is part of the path that connects the first city to the other city, and we update the minimum score accordingly.\\n\\n**The intuition behind this algorithm is that by merging the sets of vertices that are connected by edges, we are building clusters of vertices that are connected to each other. By finding the root of the set that contains the first city, we can check whether each edge is part of the path that connects the first city to every other city. This approach reduces the number of paths that need to be checked, as we only need to consider the edges that are part of the clusters containing the first city.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Define the class Solution.\\n2. Define two member variables root and rank as vectors.\\n3. Define the find() function that takes an integer x as input and returns the root of the set that contains x.\\n4. Inside the find() function, check if the current vertex is the root of its set. If it is, return its value. Otherwise, update its parent to be the root of the set that contains its current parent, and return its new root.\\n5. Define the createUnion() function that takes two integers x and y as input, and merges the sets that contain x and y.\\n6. Inside the createUnion() function, find the roots of the sets that contain x and y. If the roots are the same, return without doing anything. Otherwise, merge the sets by setting the parent of one of the roots to the other root. If the ranks of the two sets are equal, increment the rank of the new root.\\n7. Define the minScore() function that takes an integer n and a vector of vectors roads as input, and returns an integer representing the minimum score among all paths that connect the first city to every other city.\\n8. Initialize root and rank to empty vectors of size n+1.\\n9. For each vertex i from 0 to n-1, set root[i] to i and rank[i] to 0.\\n10. Initialize minScore to INT_MAX.\\n11. For each edge in roads, call createUnion() with its two vertices.\\n12. For each edge in roads, find the roots of the sets that contain the first city (1) and the two vertices of the edge (road[0] and road[1]). If all three roots are the same, update minScore to be the minimum of its current value and the score of the current edge.\\n13. Return minScore.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> root, rank;\\n    \\n    int find(int x){\\n        if(x == root[x])\\n            return root[x];\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        root.resize(n + 1);\\n        rank.resize(n + 1);\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n            rank[i] = 0;\\n        }\\n        int minScore = INT_MAX;\\n        for (auto road : roads) {\\n            createUnion(road[0], road[1]);\\n        }\\n        for (auto road : roads) {\\n            int root1 = find(1);\\n            int rootX = find(road[0]);\\n            int rootY = find(road[1]);\\n            if (root1 == rootX && root1 == rootY) {\\n                minScore = min(minScore, road[2]);\\n            }\\n        }\\n        return minScore;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private int[] root, rank;\\n    \\n    private int find(int x){\\n        if(x == root[x])\\n            return root[x];\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    private void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n        root = new int[n + 1];\\n        rank = new int[n + 1];\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n            rank[i] = 0;\\n        }\\n        int minScore = Integer.MAX_VALUE;\\n        for (int[] road : roads) {\\n            createUnion(road[0], road[1]);\\n        }\\n        for (int[] road : roads) {\\n            int root1 = find(1);\\n            int rootX = find(road[0]);\\n            int rootY = find(road[1]);\\n            if (root1 == rootX && root1 == rootY) {\\n                minScore = Math.min(minScore, road[2]);\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.root = []\\n        self.rank = []\\n    \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def createUnion(self, x: int, y: int) -> None:\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX == rootY:\\n            return\\n        if self.rank[rootX] < self.rank[rootY]:\\n            self.root[rootX] = rootY\\n        elif self.rank[rootX] > self.rank[rootY]:\\n            self.root[rootY] = rootX\\n        else:\\n            self.root[rootY] = rootX\\n            self.rank[rootX] += 1\\n    \\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        self.root = [i for i in range(n + 1)]\\n        self.rank = [0] * (n + 1)\\n        minScore = float(\\'inf\\')\\n        for road in roads:\\n            self.createUnion(road[0], road[1])\\n        for road in roads:\\n            root1 = self.find(1)\\n            rootX = self.find(road[0])\\n            rootY = self.find(road[1])\\n            if root1 == rootX == rootY:\\n                minScore = min(minScore, road[2])\\n        return minScore\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity :\\n\\n1. The time complexity of the find() function is O(log n) in the worst case, where n is the number of vertices in the graph.\\n2. The time complexity of the createUnion() function is O(log n) in the worst case, where n is the number of vertices in the graph.\\n3. The time complexity of the initialization loop in step 9 is O(n).\\n4. The time complexity of the loop that calls createUnion() in step 11 is O(m log n), where m is the number of edges in the graph and n is the number of vertices.\\n5. The time complexity of the loop that checks the roots of the sets in step 12 is O(m log n), where m is the number of edges in the graph and n is the number of vertices.\\n6. **Therefore, the overall time complexity of the algorithm is O(m log n), where m is the number of edges in the graph and n is the number of vertices.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : \\n\\nThe space complexity of the algorithm is **O(n)**, where n is the number of vertices in the graph. This is because we need to store the root and rank vectors, each of which has a size of n+1.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> root, rank;\\n    \\n    int find(int x){\\n        if(x == root[x])\\n            return root[x];\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        root.resize(n + 1);\\n        rank.resize(n + 1);\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n            rank[i] = 0;\\n        }\\n        int minScore = INT_MAX;\\n        for (auto road : roads) {\\n            createUnion(road[0], road[1]);\\n        }\\n        for (auto road : roads) {\\n            int root1 = find(1);\\n            int rootX = find(road[0]);\\n            int rootY = find(road[1]);\\n            if (root1 == rootX && root1 == rootY) {\\n                minScore = min(minScore, road[2]);\\n            }\\n        }\\n        return minScore;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private int[] root, rank;\\n    \\n    private int find(int x){\\n        if(x == root[x])\\n            return root[x];\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    private void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n        root = new int[n + 1];\\n        rank = new int[n + 1];\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n            rank[i] = 0;\\n        }\\n        int minScore = Integer.MAX_VALUE;\\n        for (int[] road : roads) {\\n            createUnion(road[0], road[1]);\\n        }\\n        for (int[] road : roads) {\\n            int root1 = find(1);\\n            int rootX = find(road[0]);\\n            int rootY = find(road[1]);\\n            if (root1 == rootX && root1 == rootY) {\\n                minScore = Math.min(minScore, road[2]);\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.root = []\\n        self.rank = []\\n    \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def createUnion(self, x: int, y: int) -> None:\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX == rootY:\\n            return\\n        if self.rank[rootX] < self.rank[rootY]:\\n            self.root[rootX] = rootY\\n        elif self.rank[rootX] > self.rank[rootY]:\\n            self.root[rootY] = rootX\\n        else:\\n            self.root[rootY] = rootX\\n            self.rank[rootX] += 1\\n    \\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        self.root = [i for i in range(n + 1)]\\n        self.rank = [0] * (n + 1)\\n        minScore = float(\\'inf\\')\\n        for road in roads:\\n            self.createUnion(road[0], road[1])\\n        for road in roads:\\n            root1 = self.find(1)\\n            rootX = self.find(road[0])\\n            rootY = self.find(road[1])\\n            if root1 == rootX == rootY:\\n                minScore = min(minScore, road[2])\\n        return minScore\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875087,
                "title": "union-find",
                "content": "\\n      class Solution:\\n        def minScore(self, n: int, roads: List[List[int]]) -> int:\\n            \\n            dp=list(range(n+1))\\n    \\n            def find(x):\\n                if dp[x]!=x:dp[x]=find(dp[x])\\n                return dp[x]\\n            \\n            cost=collections.defaultdict(lambda: float(\\'inf\\'))\\n            \\n            for i,j,k in roads:  \\n                i,j=find(i),find(j)                    \\n                cost[j]=min([cost[j],cost[i],k])\\n                dp[i]=dp[j]\\n                    \\n            return cost[find(1)]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n      class Solution:\\n        def minScore(self, n: int, roads: List[List[int]]) -> int:\\n            \\n            dp=list(range(n+1))\\n    \\n            def find(x):\\n                if dp[x]!=x:dp[x]=find(dp[x])\\n                return dp[x]\\n            \\n            cost=collections.defaultdict(lambda: float(\\'inf\\'))\\n            \\n            for i,j,k in roads:  \\n                i,j=find(i),find(j)                    \\n                cost[j]=min([cost[j],cost[i],k])\\n                dp[i]=dp[j]\\n                    \\n            return cost[find(1)]",
                "codeTag": "Java"
            },
            {
                "id": 3326669,
                "title": "javascript-bfs",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function (n, roads) {\\n  const graph = new Array(n + 1).fill().map(() => []);\\n  const visited = new Set([]);\\n\\n  for (const [v1, v2, distance] of roads) {\\n    graph[v1].push([v2, distance]);\\n    graph[v2].push([v1, distance]);\\n  }\\n\\n  const queue = [1];\\n  visited.add(1);\\n  let ans = Infinity;\\n\\n  while (queue.length > 0) {\\n    const node = queue.shift();\\n    for (const [next, distance] of graph[node]) {\\n      ans = Math.min(ans, distance);\\n      if (visited.has(next)) continue;\\n\\n      visited.add(next);\\n      queue.push(next);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function (n, roads) {\\n  const graph = new Array(n + 1).fill().map(() => []);\\n  const visited = new Set([]);\\n\\n  for (const [v1, v2, distance] of roads) {\\n    graph[v1].push([v2, distance]);\\n    graph[v2].push([v1, distance]);\\n  }\\n\\n  const queue = [1];\\n  visited.add(1);\\n  let ans = Infinity;\\n\\n  while (queue.length > 0) {\\n    const node = queue.shift();\\n    for (const [next, distance] of graph[node]) {\\n      ans = Math.min(ans, distance);\\n      if (visited.has(next)) continue;\\n\\n      visited.add(next);\\n      queue.push(next);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327102,
                "title": "try-ones-more-using-my-hints-easy-java-solution-using-dfs",
                "content": "# Hints\\n- Don\\'t go on language its a simple graph traversal Question.\\n- Use DFS or BFS.\\n- Simply Travers the graph starting from 1st node and store minimum distance between any two nodes.\\n- At the end just check if nth node is visited or not\\n    - If visited then return minimum distance\\n    - else return -1\\n\\n# Note \\n- You can use BFS also insted of DFS in below code.\\n\\n# Complexity\\n- Time complexity: $$O(V)$$ where V is total number of vertecis in Graph.\\n\\n- Space complexity: $$O(V)$$ where V is total number of vertecis in Graph.\\n\\n# Code\\n```\\nclass Solution {\\n    int min;\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<int[]>> graph = new ArrayList<>();\\n        for(int i = 0; i<n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i<roads.length; i++){\\n            graph.get(roads[i][0]-1).add(new int[]{roads[i][1]-1, roads[i][2]});\\n            graph.get(roads[i][1]-1).add(new int[]{roads[i][0]-1, roads[i][2]});\\n        }\\n        min = Integer.MAX_VALUE;\\n        boolean vis[] = new boolean[n];\\n        dfs(graph, vis, 0);\\n        if(vis[n-1]) return min;\\n        return -1;\\n    }\\n    private void dfs(ArrayList<ArrayList<int[]>> graph, boolean vis[], int s){\\n        if(vis[s]) return;\\n        vis[s] = true;\\n        for(int[] child : graph.get(s)){\\n            dfs(graph, vis, child[0]);\\n            min = Math.min(min, child[1]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int min;\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<int[]>> graph = new ArrayList<>();\\n        for(int i = 0; i<n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i<roads.length; i++){\\n            graph.get(roads[i][0]-1).add(new int[]{roads[i][1]-1, roads[i][2]});\\n            graph.get(roads[i][1]-1).add(new int[]{roads[i][0]-1, roads[i][2]});\\n        }\\n        min = Integer.MAX_VALUE;\\n        boolean vis[] = new boolean[n];\\n        dfs(graph, vis, 0);\\n        if(vis[n-1]) return min;\\n        return -1;\\n    }\\n    private void dfs(ArrayList<ArrayList<int[]>> graph, boolean vis[], int s){\\n        if(vis[s]) return;\\n        vis[s] = true;\\n        for(int[] child : graph.get(s)){\\n            dfs(graph, vis, child[0]);\\n            min = Math.min(min, child[1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326933,
                "title": "c-clean-code-bfs-readable-code",
                "content": "# Complexity\\n- Time complexity:\\n```\\nO(N)\\n```\\n\\n- Space complexity:\\n```\\nO(N)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minScore(int n, vector<vector<int>>& rd) {\\n        vector<vector<int>> adj[n+1];\\n        for(auto a : rd){\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        queue<vector<int>> pq;\\n        int ans =1e8;\\n        vis[1]=1;\\n        pq.push({1,100000});\\n        while(!pq.empty()){\\n            int ct = pq.front()[0]; pq.pop();\\n            for(auto a : adj[ct]){\\n                ans = min(ans,a[1]);\\n                if(!vis[a[0]]){\\n                    vis[a[0]]=1;\\n                    pq.push({a[0],a[1]});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nO(N)\\n```\n```\\nO(N)\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minScore(int n, vector<vector<int>>& rd) {\\n        vector<vector<int>> adj[n+1];\\n        for(auto a : rd){\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        queue<vector<int>> pq;\\n        int ans =1e8;\\n        vis[1]=1;\\n        pq.push({1,100000});\\n        while(!pq.empty()){\\n            int ct = pq.front()[0]; pq.pop();\\n            for(auto a : adj[ct]){\\n                ans = min(ans,a[1]);\\n                if(!vis[a[0]]){\\n                    vis[a[0]]=1;\\n                    pq.push({a[0],a[1]});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326867,
                "title": "c-easy-solution-dfs-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFDFS Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n\\t//Depth First Seach function\\n    void dfs(int node,vector<vector<pair<int,int>>>&graph,vector<int>&vis,vector<int>&ans){\\n\\t//mark the node in the visited vector\\n        vis[node]=0;\\n\\t\\t//traverse through all the neighbouring nodes\\n        for(auto&child:graph[node]){\\n\\t\\t//if they are not visited yet\\n            if(vis[child.first]){\\n\\t\\t\\t//push node in ans vector;\\n                ans.push_back(child.first);\\n\\t\\t\\t\\t//dfs call for neighbours\\n                dfs(child.first,graph,vis,ans);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\t\\n        vector<vector<pair<int,int>>>graph(n);\\n\\t\\t//First we will create a graph with the given edges and weights\\n\\t\\t//by making graph a vector of vector of pair\\n\\t\\t\\n        for(auto&road:roads){\\n            \\n            graph[road[0]-1].push_back({road[1]-1,road[2]});\\n            graph[road[1]-1].push_back({road[0]-1,road[2]});\\n        }\\n\\t\\t//for the dfs we require a visited array so we created a vis vector\\n        vector<int>vis(n,1);\\n\\t\\t//we will store the visited nodes in ans vector;\\n        vector<int>ans;\\n\\t\\t\\n\\t\\t//we will call the dfs to find the visited nodes from node 0\\n        dfs(0,graph,vis,ans);\\n\\t\\t\\n\\t\\t//now we will find the minimum possible edge possible on the visited \\n\\t\\t//as we must have to include the  minimun weight edge\\n        int res=1e9;\\n        for(int i=0;i<ans.size();i++){\\n\\t\\t//Traversing through all the edges of node\\n            for(auto&child:graph[ans[i]]){\\n\\t\\t\\t//storing min in res\\n                res=min(res,child.second);\\n            }\\n        }\\n\\t\\t//returning the res\\n        return res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//Depth First Seach function\\n    void dfs(int node,vector<vector<pair<int,int>>>&graph,vector<int>&vis,vector<int>&ans){\\n\\t//mark the node in the visited vector\\n        vis[node]=0;\\n\\t\\t//traverse through all the neighbouring nodes\\n        for(auto&child:graph[node]){\\n\\t\\t//if they are not visited yet\\n            if(vis[child.first]){\\n\\t\\t\\t//push node in ans vector;\\n                ans.push_back(child.first);\\n\\t\\t\\t\\t//dfs call for neighbours\\n                dfs(child.first,graph,vis,ans);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\t\\n        vector<vector<pair<int,int>>>graph(n);\\n\\t\\t//First we will create a graph with the given edges and weights\\n\\t\\t//by making graph a vector of vector of pair\\n\\t\\t\\n        for(auto&road:roads){\\n            \\n            graph[road[0]-1].push_back({road[1]-1,road[2]});\\n            graph[road[1]-1].push_back({road[0]-1,road[2]});\\n        }\\n\\t\\t//for the dfs we require a visited array so we created a vis vector\\n        vector<int>vis(n,1);\\n\\t\\t//we will store the visited nodes in ans vector;\\n        vector<int>ans;\\n\\t\\t\\n\\t\\t//we will call the dfs to find the visited nodes from node 0\\n        dfs(0,graph,vis,ans);\\n\\t\\t\\n\\t\\t//now we will find the minimum possible edge possible on the visited \\n\\t\\t//as we must have to include the  minimun weight edge\\n        int res=1e9;\\n        for(int i=0;i<ans.size();i++){\\n\\t\\t//Traversing through all the edges of node\\n            for(auto&child:graph[ans[i]]){\\n\\t\\t\\t//storing min in res\\n                res=min(res,child.second);\\n            }\\n        }\\n\\t\\t//returning the res\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328614,
                "title": "simple-c-solution-using-dijkstra-algorithm",
                "content": "***The reason to upload this solution was that I found many solutions with `DFS` and `BFS` approach in solutions and in editorial as well. So thought of sharing an alternate solution, in case someone tries to solve this by `Dijkstra Algorithm`. Hope it helps! \\uD83D\\uDE05***\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question can be thought to be similar to the basic dijkstra problem wherein we find the shortest path from one node to all other nodes. The only difference here is that instead of adding the distances in the path, we have to find the minimum of the edges in the path. So we have to make changes in the step wherein we push the distance to a particular node, in the priority queue. Basically we are just changing the defination of distance here.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will be using priority queue in our solution (to find the nearest node to the current node). We initialized our distance array with a large value (1e9 in this case) so that nodes always store the minimum possible value of reaching the node `n` from the current node. We created a 2D vector for storing edges from one node. `dist[0]` is initialized with `MAXN` for simplicity in further calulations (as the graph will always have more than 1 node, so this won\\'t affect our answer). Further, we push `-dist[node]` in the priority queue to get the nearest node. In the inner for loop, modification needs to be made as we want to store the minimum edge length in the path not the path length.\\n\\n# Complexity\\n- Time complexity: `O(e*log(n))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHere `n` is the number of nodes and `e` is the total number edges.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define MAXN 1e9\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> dist(n,MAXN);\\n        vector<pair<int,int>> edges[n];\\n        for(vector<int>& x:roads){\\n            edges[x[0]-1].push_back({x[1]-1,x[2]});\\n            edges[x[1]-1].push_back({x[0]-1,x[2]});\\n        }\\n        dist[0]=MAXN;\\n        pq.push({-MAXN,0});\\n        while(!pq.empty()){\\n            pair<int,int> v=pq.top();\\n            pq.pop();\\n            int u=v.second;\\n            int d=-v.first;\\n            for(pair<int,int> e:edges[u]){\\n                if(dist[e.first]>min(d,e.second)){\\n                    dist[e.first]=min(d,e.second);\\n                    pq.push({-dist[e.first],e.first});\\n                }\\n            }\\n        }\\n        return dist[n-1];\\n    }\\n};\\n```\\n\\n***Do upvote if you find it helpful! \\uD83D\\uDC4D***",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define MAXN 1e9\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> dist(n,MAXN);\\n        vector<pair<int,int>> edges[n];\\n        for(vector<int>& x:roads){\\n            edges[x[0]-1].push_back({x[1]-1,x[2]});\\n            edges[x[1]-1].push_back({x[0]-1,x[2]});\\n        }\\n        dist[0]=MAXN;\\n        pq.push({-MAXN,0});\\n        while(!pq.empty()){\\n            pair<int,int> v=pq.top();\\n            pq.pop();\\n            int u=v.second;\\n            int d=-v.first;\\n            for(pair<int,int> e:edges[u]){\\n                if(dist[e.first]>min(d,e.second)){\\n                    dist[e.first]=min(d,e.second);\\n                    pq.push({-dist[e.first],e.first});\\n                }\\n            }\\n        }\\n        return dist[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875369,
                "title": "incorrect-problem-description",
                "content": "![image](https://assets.leetcode.com/users/images/a7607a13-3e5d-415b-96b7-96df308a757a_1670128000.860611.png)\\n\\nI was thinking that, we can **visit only node 1 and node n multiple times** and i was solving problem in that direction but after contest, i saw the discuss then peoples have **solved by visiting node 1 to node n multiple times.**\\n\\nHere, they should have to write **cities 1 to n multiple times** instead of **cities 1 and n multiple times**.\\n\\n![image](https://assets.leetcode.com/users/images/59214ad3-9b83-41e5-a70b-1284b1507c6a_1670129863.818849.png)\\n\\nHere, answer should be 2, as we can\\'t visite node 2 multiple times. So that, ```1->2->4->2->1->3->5``` not possible (according to problem description).\\n\\nBut solution got which was visiting node 2 twice.\\n\\nNot fair.\\n",
                "solutionTags": [],
                "code": "```1->2->4->2->1->3->5```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326787,
                "title": "simplest-solution-disjoint-set-c",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n\\n# Code\\n```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent, size;\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i = 1; i <= n; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUlt(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUlt(parent[node]);\\n    }\\n\\n    void findUnion(int u, int v){\\n        int paru = findUlt(u);\\n        int parv = findUlt(v);\\n        if(paru == parv) return;\\n        if(size[paru] > size[parv]){\\n            parent[parv] = paru;\\n            size[paru]++;\\n        }\\n        else if(size[paru] > size[parv]){\\n            parent[paru] = parv;\\n            size[parv]++;\\n        }\\n        else{\\n            parent[parv] = paru;\\n            size[paru]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DisjointSet ds(n);\\n        for(auto it : roads){\\n            ds.findUnion(it[0], it[1]);\\n        }\\n        int temp = ds.findUlt(1), ans = INT_MAX;\\n        for(auto it : roads){\\n            int ult_u = ds.findUlt(it[0]), ult_v = ds.findUlt(it[1]);\\n            if(ult_u == temp || ult_v == temp)\\n                ans = min(ans, it[2]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\n                   `Give a \\uD83D\\uDC4D. It motivates me alot`\\n```\\nLet\\'s Connect On [Linkedin]()",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent, size;\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i = 1; i <= n; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUlt(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUlt(parent[node]);\\n    }\\n\\n    void findUnion(int u, int v){\\n        int paru = findUlt(u);\\n        int parv = findUlt(v);\\n        if(paru == parv) return;\\n        if(size[paru] > size[parv]){\\n            parent[parv] = paru;\\n            size[paru]++;\\n        }\\n        else if(size[paru] > size[parv]){\\n            parent[paru] = parv;\\n            size[parv]++;\\n        }\\n        else{\\n            parent[parv] = paru;\\n            size[paru]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DisjointSet ds(n);\\n        for(auto it : roads){\\n            ds.findUnion(it[0], it[1]);\\n        }\\n        int temp = ds.findUlt(1), ans = INT_MAX;\\n        for(auto it : roads){\\n            int ult_u = ds.findUlt(it[0]), ult_v = ds.findUlt(it[1]);\\n            if(ult_u == temp || ult_v == temp)\\n                ans = min(ans, it[2]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n                   `Give a \\uD83D\\uDC4D. It motivates me alot`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875788,
                "title": "c-very-simple-dfs-based-approach",
                "content": "I think the code is self-explanatory if you already know how to perform a Depth-first search traversal inside a connected component.\\n\\n```\\nclass Solution {\\nprivate:\\n    int dfs(int current, vector<bool> &visited, vector<vector<pair<int, int>>> &graph) {\\n        int minScore = INT_MAX;\\n        visited[current] = true;\\n        for(auto &[next, distance] : graph[current]) {\\n            minScore = min(minScore, distance);\\n            if(!visited[next]) {\\n                visited[next] = true;\\n                minScore = min(minScore, dfs(next, visited, graph));\\n            }\\n        }\\n        return minScore;\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // Step 1: create a graph from the network of roads\\n        vector<vector<pair<int, int>>> graph(n + 1);\\n        for(auto &road : roads) {\\n            graph[road[0]].emplace_back(road[1], road[2]);\\n            graph[road[1]].emplace_back(road[0], road[2]);\\n        }\\n        // Step 2: Perform a DFS starting from the city 1 and since it will have an edge \\n        // connecting the last city, you are darn sure that you just need to track the min edge-weight\\n        // inside the component connecting city 1 and city n\\n        vector<bool> visited(n + 1);\\n        return dfs(1, visited, graph);\\n    }\\n};\\n```\\n\\nThanks a lot for reading! ^_^\\n\\uD83D\\uDCAF An upvote would be appreciated.\\n\\uD83D\\uDC47 Comment down your doubts (if any).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int current, vector<bool> &visited, vector<vector<pair<int, int>>> &graph) {\\n        int minScore = INT_MAX;\\n        visited[current] = true;\\n        for(auto &[next, distance] : graph[current]) {\\n            minScore = min(minScore, distance);\\n            if(!visited[next]) {\\n                visited[next] = true;\\n                minScore = min(minScore, dfs(next, visited, graph));\\n            }\\n        }\\n        return minScore;\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // Step 1: create a graph from the network of roads\\n        vector<vector<pair<int, int>>> graph(n + 1);\\n        for(auto &road : roads) {\\n            graph[road[0]].emplace_back(road[1], road[2]);\\n            graph[road[1]].emplace_back(road[0], road[2]);\\n        }\\n        // Step 2: Perform a DFS starting from the city 1 and since it will have an edge \\n        // connecting the last city, you are darn sure that you just need to track the min edge-weight\\n        // inside the component connecting city 1 and city n\\n        vector<bool> visited(n + 1);\\n        return dfs(1, visited, graph);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874943,
                "title": "simple-c-bfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& r) {\\n        vector<pair<int, int>> g[n+1];\\n        vector<bool> vis(n+1, false);\\n        \\n        for(auto x: r){\\n            g[x[0]].push_back({x[1], x[2]});\\n            g[x[1]].push_back({x[0], x[2]});\\n        }\\n        \\n        queue<int> q;\\n        q.push(1);\\n        int ans = INT_MAX;\\n        \\n        while(q.size()){\\n            int t = q.front();\\n            q.pop();\\n            vis[t] = true;\\n            \\n            for(int i=0; i<g[t].size(); i++){\\n                ans = min(ans, g[t][i].second);\\n                int next = g[t][i].first;\\n                if(vis[next]) continue;\\n                else q.push(next);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& r) {\\n        vector<pair<int, int>> g[n+1];\\n        vector<bool> vis(n+1, false);\\n        \\n        for(auto x: r){\\n            g[x[0]].push_back({x[1], x[2]});\\n            g[x[1]].push_back({x[0], x[2]});\\n        }\\n        \\n        queue<int> q;\\n        q.push(1);\\n        int ans = INT_MAX;\\n        \\n        while(q.size()){\\n            int t = q.front();\\n            q.pop();\\n            vis[t] = true;\\n            \\n            for(int i=0; i<g[t].size(); i++){\\n                ans = min(ans, g[t][i].second);\\n                int next = g[t][i].first;\\n                if(vis[next]) continue;\\n                else q.push(next);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332309,
                "title": "bfs-and-dfs-approach",
                "content": "# 1. Breadth First Search\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        for src,dst,dis in roads:\\n            graph[src].append((dst,dis))\\n            graph[dst].append((src,dis))\\n        answer,q,visit=float(\\'inf\\'),deque([1]),set()\\n        while q:\\n            poping=q.popleft()\\n            for nei,dis in graph[poping]:\\n                if nei not in visit:\\n                    visit.add(nei)\\n                    q.append(nei)\\n                answer=min(answer,dis)\\n        return answer\\n\\n```\\n\\n# 2. Depth First Search\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=defaultdict(list)\\n        for src,dst,dis in roads:\\n            adj[src].append((dst,dis))\\n            adj[dst].append((src,dis))\\n        def dfs(i):\\n            if i in visit:\\n                return\\n            visit.add(i)\\n            nonlocal answer\\n            for nei,dis in adj[i]:\\n                answer=min(answer,dis)\\n                dfs(nei)\\n        visit,answer=set(),float(\\'inf\\')\\n        dfs(n)\\n        return answer\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        for src,dst,dis in roads:\\n            graph[src].append((dst,dis))\\n            graph[dst].append((src,dis))\\n        answer,q,visit=float(\\'inf\\'),deque([1]),set()\\n        while q:\\n            poping=q.popleft()\\n            for nei,dis in graph[poping]:\\n                if nei not in visit:\\n                    visit.add(nei)\\n                    q.append(nei)\\n                answer=min(answer,dis)\\n        return answer\\n\\n```\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=defaultdict(list)\\n        for src,dst,dis in roads:\\n            adj[src].append((dst,dis))\\n            adj[dst].append((src,dis))\\n        def dfs(i):\\n            if i in visit:\\n                return\\n            visit.add(i)\\n            nonlocal answer\\n            for nei,dis in adj[i]:\\n                answer=min(answer,dis)\\n                dfs(nei)\\n        visit,answer=set(),float(\\'inf\\')\\n        dfs(n)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326702,
                "title": "java-easy-solution-90-faster-code-using-dijikstra-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n  PLEASE UPVOTE\\n```\\nclass Solution {\\n    class Pair{\\n        int dest;\\n        int cost;\\n        Pair(int dest, int cost){\\n            this.dest = dest;\\n            this.cost = cost;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n        int m = roads.length;\\n        Queue<Pair> que = new ArrayDeque<>();\\n        int min = Integer.MAX_VALUE;\\n        \\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for(int i = 0; i < n + 1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        \\n        que.add(new Pair(1,Integer.MAX_VALUE));\\n        int[] visited = new int[n + 1];\\n         \\n        while(que.size() > 0){\\n            int dest = que.peek().dest;\\n            int cost = que.peek().cost;\\n            que.remove();\\n            min = Math.min(min,cost);\\n            if(visited[dest] == 0){\\n                   for(int i = 0; i < adj.get(dest).size(); i++){\\n                        int a = adj.get(dest).get(i).dest;\\n                        int b = adj.get(dest).get(i).cost;\\n                        que.add(new Pair(a,b));\\n                    }\\n            }\\n            visited[dest] = 1;\\n         \\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int dest;\\n        int cost;\\n        Pair(int dest, int cost){\\n            this.dest = dest;\\n            this.cost = cost;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n        int m = roads.length;\\n        Queue<Pair> que = new ArrayDeque<>();\\n        int min = Integer.MAX_VALUE;\\n        \\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for(int i = 0; i < n + 1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        \\n        que.add(new Pair(1,Integer.MAX_VALUE));\\n        int[] visited = new int[n + 1];\\n         \\n        while(que.size() > 0){\\n            int dest = que.peek().dest;\\n            int cost = que.peek().cost;\\n            que.remove();\\n            min = Math.min(min,cost);\\n            if(visited[dest] == 0){\\n                   for(int i = 0; i < adj.get(dest).size(); i++){\\n                        int a = adj.get(dest).get(i).dest;\\n                        int b = adj.get(dest).get(i).cost;\\n                        que.add(new Pair(a,b));\\n                    }\\n            }\\n            visited[dest] = 1;\\n         \\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937093,
                "title": "union-find-vs-dfs",
                "content": "A benefit of the union-find approach is that we do not need to build an adjacency list first. So it should be a bit easier on memory.\\n\\n## Union-Find\\nIf you can reach city `i` from city `1`, you can travel any road from/to city `i`.\\n\\nSo, we find all cities that we can reach from city `1`, check all roads connected to those cities, and pick the shortest one.\\n\\nWe can use union-find to find all reachable cities. Instead of weight, we can store the smallest distance (as a negative) for each group of cities.\\n\\n**C++**\\n```cpp\\nint ds[500001];\\nint find(int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i]);\\n}\\nint minScore(int n, vector<vector<int>>& roads) {\\n    fill_n(begin(ds), n + 1, INT_MIN);\\n    for (auto &r : roads) {\\n        int i = find(r[0]), j = find(r[1]);\\n        if (i != j) {\\n            ds[i] = max(ds[i], ds[j]);\\n            ds[j] = i;\\n        }\\n        ds[i] = max(ds[i], -r[2]);\\n    }\\n    return -ds[find(1)];\\n}\\n```\\n\\n## DFS\\nPopulate an adjacency list and do DFS.\\n\\n**C++**\\n```cpp\\nint dfs(int i, int dist, vector<vector<pair<int, int>>> &al, vector<bool> &vis) {\\n    if (!vis[i]) {\\n        vis[i] = true;\\n        for (auto [j, j_dist] : al[i])\\n            dist = min(dist, dfs(j, j_dist, al, vis));\\n    }\\n    return dist;\\n}\\nint minScore(int n, vector<vector<int>>& roads) {\\n    vector<vector<pair<int, int>>> al(n + 1);\\n    for (auto &r : roads) {\\n        al[r[0]].push_back({r[1], r[2]});\\n        al[r[1]].push_back({r[0], r[2]});\\n    }\\n    return dfs(1, INT_MAX, al, vector<bool>(n + 1) = {});\\n}   \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint ds[500001];\\nint find(int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i]);\\n}\\nint minScore(int n, vector<vector<int>>& roads) {\\n    fill_n(begin(ds), n + 1, INT_MIN);\\n    for (auto &r : roads) {\\n        int i = find(r[0]), j = find(r[1]);\\n        if (i != j) {\\n            ds[i] = max(ds[i], ds[j]);\\n            ds[j] = i;\\n        }\\n        ds[i] = max(ds[i], -r[2]);\\n    }\\n    return -ds[find(1)];\\n}\\n```\n```cpp\\nint dfs(int i, int dist, vector<vector<pair<int, int>>> &al, vector<bool> &vis) {\\n    if (!vis[i]) {\\n        vis[i] = true;\\n        for (auto [j, j_dist] : al[i])\\n            dist = min(dist, dfs(j, j_dist, al, vis));\\n    }\\n    return dist;\\n}\\nint minScore(int n, vector<vector<int>>& roads) {\\n    vector<vector<pair<int, int>>> al(n + 1);\\n    for (auto &r : roads) {\\n        al[r[0]].push_back({r[1], r[2]});\\n        al[r[1]].push_back({r[0], r[2]});\\n    }\\n    return dfs(1, INT_MAX, al, vector<bool>(n + 1) = {});\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2878221,
                "title": "python-3-13-lines-w-explanation-and-example-t-m-192ms-63-9-mb",
                "content": "Here\\'s the plan:\\n* Because nodes  `n` and `1` are connected, we can proceed as if we were given a connected graph, and our answer is the minimum `distance` on that connected graph. (I was tempted to use *union-find*, but there\\'s no need to sort out all the connected graphs, we just need to sort out the one with nodes  nodes  `n` and `1`.)\\n\\n\\n* If ensure we only visit nodes exactly once in the connected graph (using `seen`), we can proceed as if we were given a tree with 1 as the root.\\n* With all that in mind, the problem reduces to finding the minimum `distance` for all edges in that tree.\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n\\n        graph, dists = defaultdict(list),defaultdict(set)\\n        ans, seen = set(), {1}\\n                                                        #  Example: roads = [[1,2,2], [1,3,4], [3,4,7], [3,2,5]]\\n                                                        #                ___1___\\n                                                        #          (4)  /       \\\\   (2)\\n                                                        #              3 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 2\\n                                                        #          (7)  \\\\   (5)\\n                                                        #                4\\n        for a, b, dist in roads:                        # \\n            graph[a].append(b) ; dists[a].add(dist)     #      graph = {1:[2,3], 2:[1,3], 3:[1,4,2], 4:[3]}\\n            graph[b].append(a) ; dists[b].add(dist)     #      dists = {1:{2,4}, 2:{2}, 3:{4,5,7}, 4:{7}}\\n\\n        def dfs(node = 1) -> None:                      #       node    graph[node]   seen        ans\\n            nonlocal seen, ans                          #       \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\n                                                        #         1      [2,3]        {1}         {2,4}\\n            seen.add(node)                              #         2       [1]        {1,2}       {2,4,5}\\n            ans |= set(dists[node])                     #         3      [1,4]      {1,2,3}     {2,4,5,7}\\n                                                        #         4       [3]      {1,2,3,4}    {2,4,5,7}\\n            for n in graph[node]:                       #                                        |   \\n                if n not in seen: dfs(n)                #                                    return 2\\n\\n        dfs()\\n\\n        return min(ans) \\n```\\n[https://leetcode.com/submissions/detail/854628329/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n\\n        graph, dists = defaultdict(list),defaultdict(set)\\n        ans, seen = set(), {1}\\n                                                        #  Example: roads = [[1,2,2], [1,3,4], [3,4,7], [3,2,5]]\\n                                                        #                ___1___\\n                                                        #          (4)  /       \\\\   (2)\\n                                                        #              3 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 2\\n                                                        #          (7)  \\\\   (5)\\n                                                        #                4\\n        for a, b, dist in roads:                        # \\n            graph[a].append(b) ; dists[a].add(dist)     #      graph = {1:[2,3], 2:[1,3], 3:[1,4,2], 4:[3]}\\n            graph[b].append(a) ; dists[b].add(dist)     #      dists = {1:{2,4}, 2:{2}, 3:{4,5,7}, 4:{7}}\\n\\n        def dfs(node = 1) -> None:                      #       node    graph[node]   seen        ans\\n            nonlocal seen, ans                          #       \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\n                                                        #         1      [2,3]        {1}         {2,4}\\n            seen.add(node)                              #         2       [1]        {1,2}       {2,4,5}\\n            ans |= set(dists[node])                     #         3      [1,4]      {1,2,3}     {2,4,5,7}\\n                                                        #         4       [3]      {1,2,3,4}    {2,4,5,7}\\n            for n in graph[node]:                       #                                        |   \\n                if n not in seen: dfs(n)                #                                    return 2\\n\\n        dfs()\\n\\n        return min(ans) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875078,
                "title": "java-most-easiest-solution-without-dfs-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI Used A Simplest Logic to Solve this\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {  \\n        Arrays.sort(roads, (a, b)->{\\n            return a[0] - b[0];\\n        });\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(roads[0][0]);\\n        set.add(roads[0][1]);\\n        int min = roads[0][2];\\n        for(int j = 0; j < 100; j++){\\n            for(int i = 1; i < roads.length; i++){\\n            if(set.contains(roads[i][0]) || set.contains(roads[i][1])){\\n                min = Math.min(roads[i][2], min);\\n                set.add(roads[i][0]);\\n                set.add(roads[i][1]);\\n            }\\n        }\\n        }        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {  \\n        Arrays.sort(roads, (a, b)->{\\n            return a[0] - b[0];\\n        });\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(roads[0][0]);\\n        set.add(roads[0][1]);\\n        int min = roads[0][2];\\n        for(int j = 0; j < 100; j++){\\n            for(int i = 1; i < roads.length; i++){\\n            if(set.contains(roads[i][0]) || set.contains(roads[i][1])){\\n                min = Math.min(roads[i][2], min);\\n                set.add(roads[i][0]);\\n                set.add(roads[i][1]);\\n            }\\n        }\\n        }        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874940,
                "title": "dfs-cpp-with-explanation",
                "content": "**Intution :** \\n* Our task is finding min weighted edge in graph that includes both `1` and `n` nodes.\\n* That\\'s why we apply dfs on node 1 and traverse all the graph and find out min weighted edge.\\n* In question gives the one condition  : There is at least one path between 1 and n, That\\'s why guaranteed node `n` is included.\\n\\n\\n```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<pii>>& g, vector<bool>& vis, int u) {\\n        vis[u] = true;\\n        int ans = INT_MAX;\\n        for(auto [v, w] : g[u]) {\\n            ans = min(ans, w);   \\n            if(!vis[v]) ans = min(dfs(g, vis, v), ans);\\n        }\\n        return ans;\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pii>> g(n+1);\\n        for(auto r : roads) {\\n            int u = r[0], v = r[1], w = r[2];\\n            g[u].push_back({v, w});\\n            g[v].push_back({u, w});\\n        }\\n        \\n        vector<bool> vis(n+1, false);\\n        \\n        return dfs(g, vis, 1);\\n    }\\n};\\n```\\n\\n \\uD83D\\uDE4F  **Please Upvote...**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<pii>>& g, vector<bool>& vis, int u) {\\n        vis[u] = true;\\n        int ans = INT_MAX;\\n        for(auto [v, w] : g[u]) {\\n            ans = min(ans, w);   \\n            if(!vis[v]) ans = min(dfs(g, vis, v), ans);\\n        }\\n        return ans;\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pii>> g(n+1);\\n        for(auto r : roads) {\\n            int u = r[0], v = r[1], w = r[2];\\n            g[u].push_back({v, w});\\n            g[v].push_back({u, w});\\n        }\\n        \\n        vector<bool> vis(n+1, false);\\n        \\n        return dfs(g, vis, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329163,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int, unordered_map<int, int>> graph;\\n        for (auto& road : roads) {\\n            int u = road[0], v = road[1], w = road[2];\\n            graph[u][v] = graph[v][u] = w;\\n        }\\n        \\n        int res = numeric_limits<int>::max();\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            for (auto& [adj, score] : graph[node]) {\\n                if (!visited.count(adj)) {\\n                    q.push(adj);\\n                    visited.insert(adj);\\n                }\\n                res = min(res, score);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int, unordered_map<int, int>> graph;\\n        for (auto& road : roads) {\\n            int u = road[0], v = road[1], w = road[2];\\n            graph[u][v] = graph[v][u] = w;\\n        }\\n        \\n        int res = numeric_limits<int>::max();\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            for (auto& [adj, score] : graph[node]) {\\n                if (!visited.count(adj)) {\\n                    q.push(adj);\\n                    visited.insert(adj);\\n                }\\n                res = min(res, score);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327183,
                "title": "simple-dfs-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can see that we can get min. path by simple dfs traversal of the graph. Just keep on storing min. weights while traversing.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we create a adjacency list for given edges. It will look something like this for example-1:\\n\\n4->(2, 5) (1, 7)\\n3->(2, 6) \\n2->(1, 9) (3, 6) (4, 5) \\n1->(2, 9) (4, 7) \\n\\nNow we will just call dfs for node-1(city-1) because if we know that 1 and n are connected so we will find our min path by this component only any other disconnected component will not contribute to our answer.\\n\\nWhile traversing just keep updating our answer by min(ans, curr node\\'s weight). We need to update it even if node is visited.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V + E)\\n (V -> Vertices, E -> Edges)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V + E)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, unordered_map<int, list<pair<int, int>>> &adj, vector<bool> &vis, int &mini){\\n        vis[node] = 1;\\n        for(auto i:adj[node]){\\n            if(!vis[i.first]){\\n                mini = min(mini, i.second);\\n                dfs(i.first, adj, vis, mini);\\n            }\\n            else{\\n                mini = min(mini, i.second);\\n            }\\n        }\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n        unordered_map<int, list<pair<int, int>>> adj;\\n\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n\\n            pair<int, int> p1 = {u, w};\\n            pair<int, int> p2 = {v, w};\\n\\n            adj[u].push_back(p2);\\n            adj[v].push_back(p1);\\n        }\\n\\n        vector<bool> vis(n + 1, 0);\\n        int mini = INT_MAX;\\n        \\n        dfs(1, adj, vis, mini);\\n\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, unordered_map<int, list<pair<int, int>>> &adj, vector<bool> &vis, int &mini){\\n        vis[node] = 1;\\n        for(auto i:adj[node]){\\n            if(!vis[i.first]){\\n                mini = min(mini, i.second);\\n                dfs(i.first, adj, vis, mini);\\n            }\\n            else{\\n                mini = min(mini, i.second);\\n            }\\n        }\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n        unordered_map<int, list<pair<int, int>>> adj;\\n\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n\\n            pair<int, int> p1 = {u, w};\\n            pair<int, int> p2 = {v, w};\\n\\n            adj[u].push_back(p2);\\n            adj[v].push_back(p1);\\n        }\\n\\n        vector<bool> vis(n + 1, 0);\\n        int mini = INT_MAX;\\n        \\n        dfs(1, adj, vis, mini);\\n\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326675,
                "title": "kotlin-simply-find-reachable-nodes-cheapest-edge",
                "content": "Thank you for upvoting\\n\\n```\\nclass Solution {\\n  fun minScore(n: Int, roads: Array<IntArray>): Int {\\n    val g = List(n + 1) {mutableListOf<Pair<Int, Int>>()}\\n    for ((a, b, c) in roads) {\\n      g[a].add(Pair(b, c))\\n      g[b].add(Pair(a, c))\\n    }\\n    val reachable = BooleanArray(n + 1)\\n    fun dfs(node: Int) {\\n      if (reachable[node]) return\\n      reachable[node] = true\\n      for ((next, _) in g[node])\\n        dfs(next)\\n    }\\n    dfs(1)\\n    var res = Int.MAX_VALUE\\n    for (i in 1..n)\\n      if (reachable[i]) for ((_, cost) in g[i]) res = minOf(res, cost)\\n    return res\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun minScore(n: Int, roads: Array<IntArray>): Int {\\n    val g = List(n + 1) {mutableListOf<Pair<Int, Int>>()}\\n    for ((a, b, c) in roads) {\\n      g[a].add(Pair(b, c))\\n      g[b].add(Pair(a, c))\\n    }\\n    val reachable = BooleanArray(n + 1)\\n    fun dfs(node: Int) {\\n      if (reachable[node]) return\\n      reachable[node] = true\\n      for ((next, _) in g[node])\\n        dfs(next)\\n    }\\n    dfs(1)\\n    var res = Int.MAX_VALUE\\n    for (i in 1..n)\\n      if (reachable[i]) for ((_, cost) in g[i]) res = minOf(res, cost)\\n    return res\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875571,
                "title": "c-solution-simple-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n-> Find **adjacency list**;\\n-> Make a **DFS** call from **1**;\\n\\n# Complexity\\n- Time complexity:\\n  O(V+E)\\n\\n- Space complexity:\\n  O(N);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>> > adj;\\n        for(auto p:roads){\\n            int u=p[0];\\n            int v=p[1];\\n            int wt=p[2];\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        int mindist=INT_MAX;\\n        vector<int> vis(n+1,0);\\n        dfs(1,n,adj,mindist,vis);\\n        return mindist;\\n    }\\n    void dfs(int u,int n,unordered_map<int,vector<pair<int,int>> > &adj, int &mindist,vector<int> &vis){\\n        vis[u]=1;\\n        for(auto p:adj[u]){\\n            int v=p.first;\\n            int wt=p.second;\\n            mindist=min(mindist, wt);\\n            if(!vis[v]){\\n                dfs(v,n,adj, mindist,vis);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>> > adj;\\n        for(auto p:roads){\\n            int u=p[0];\\n            int v=p[1];\\n            int wt=p[2];\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        int mindist=INT_MAX;\\n        vector<int> vis(n+1,0);\\n        dfs(1,n,adj,mindist,vis);\\n        return mindist;\\n    }\\n    void dfs(int u,int n,unordered_map<int,vector<pair<int,int>> > &adj, int &mindist,vector<int> &vis){\\n        vis[u]=1;\\n        for(auto p:adj[u]){\\n            int v=p.first;\\n            int wt=p.second;\\n            mindist=min(mindist, wt);\\n            if(!vis[v]){\\n                dfs(v,n,adj, mindist,vis);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874941,
                "title": "smallest-road-in-connected-component",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def DFS(self, graph, i, v):\\n        for j, d in graph[i]:\\n            if j not in v:\\n                v.add(j)\\n                self.DFS(graph, j, v)\\n    \\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        res = float(\\'inf\\')\\n        graph = defaultdict(set)\\n        for a, b, d in roads:\\n            graph[a].add((b, d))\\n            graph[b].add((a, d))\\n        v = {1}\\n        self.DFS(graph, 1, v)\\n        for a, b, d in roads:\\n            if a in v and b in v:\\n                res = min(res, d)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def DFS(self, graph, i, v):\\n        for j, d in graph[i]:\\n            if j not in v:\\n                v.add(j)\\n                self.DFS(graph, j, v)\\n    \\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        res = float(\\'inf\\')\\n        graph = defaultdict(set)\\n        for a, b, d in roads:\\n            graph[a].add((b, d))\\n            graph[b].add((a, d))\\n        v = {1}\\n        self.DFS(graph, 1, v)\\n        for a, b, d in roads:\\n            if a in v and b in v:\\n                res = min(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328101,
                "title": "python-short-and-clean-dfs",
                "content": "# Approach\\nNotice that we can visit `nodes` and `edges` multiple times. This reduces the problem into finding the shortest path in the connected subgraph containing the node `1`.\\n\\nUse good old `DFS` to find the `min_dist` recursively. Make sure to mark the nodes as `seen | visited` as there can be cycles.\\n\\n# Complexity\\n- Time complexity: $$O(n + e)$$\\n\\n- Space complexity: $$O(n + e)$$\\n\\nwhere,\\n`n is the number of nodes`,\\n`e is the number of edges`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minScore(self, n: int, roads: list[list[int]]) -> int:\\n        T = Hashable\\n        Dist = int | float\\n        Graph = Mapping[T, Mapping[T, Dist]]\\n\\n        def min_dist(graph: Graph, u: T, seen: set[T]) -> Dist:\\n            return (seen.add(u) or min(\\n                min(d, min_dist(graph, v, seen))\\n                for v, d in graph[u].items()\\n            )) if u not in seen else inf\\n        \\n        \\n        g = defaultdict(dict)\\n        for u, v, d in roads: g[u][v] = g[v][u] = d\\n        \\n        return min_dist(g, 1, set())\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def minScore(self, n: int, roads: list[list[int]]) -> int:\\n        T = Hashable\\n        Dist = int | float\\n        Graph = Mapping[T, Mapping[T, Dist]]\\n\\n        def min_dist(graph: Graph, u: T, seen: set[T]) -> Dist:\\n            return (seen.add(u) or min(\\n                min(d, min_dist(graph, v, seen))\\n                for v, d in graph[u].items()\\n            )) if u not in seen else inf\\n        \\n        \\n        g = defaultdict(dict)\\n        for u, v, d in roads: g[u][v] = g[v][u] = d\\n        \\n        return min_dist(g, 1, set())\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327732,
                "title": "graph-c-easy-to-understand-short-sweet-code",
                "content": "````\\nclass Solution {\\npublic:\\n    void solve(int s,int &ans,vector<vector<vector<int>>> &g,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            ans = min(ans,i[1]);\\n            solve(i[0],ans,g,v);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(auto &i: roads){\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<bool> v(n+1,false);\\n        solve(1,ans,g,v);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(int s,int &ans,vector<vector<vector<int>>> &g,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            ans = min(ans,i[1]);\\n            solve(i[0],ans,g,v);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(auto &i: roads){\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<bool> v(n+1,false);\\n        solve(1,ans,g,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327497,
                "title": "c-java-and-typescript-solution-with-approach",
                "content": "# \\u2B06\\uFE0FLike|\\uD83C\\uDFAFShare|\\u2B50Favourite\\n\\n\\n```CSharp []\\npublic class Solution \\n{\\n    public int MinScore(int n, int[][] roads) \\n    {\\n        var graph = new Dictionary<int, Dictionary<int, int>>();\\n        foreach (var road in roads)\\n        {\\n            if (!graph.ContainsKey(road[0]))\\n            {\\n                graph.Add(road[0], new Dictionary<int, int>());\\n            }\\n\\n            if (!graph.ContainsKey(road[1]))\\n            {\\n                graph.Add(road[1], new Dictionary<int, int>());\\n            }\\n            graph[road[0]].Add(road[1], road[2]);\\n            graph[road[1]].Add(road[0], road[2]);\\n        }\\n        var minScore = int.MaxValue;\\n        var visited = new HashSet<int>();\\n        var queue = new Queue<int>();\\n        queue.Enqueue(1);\\n        while (queue.Count > 0)\\n        {\\n            var node = queue.Dequeue();\\n            foreach (var adj in graph[node].Keys)\\n            {\\n                if (!visited.Contains(adj))\\n                {\\n                    queue.Enqueue(adj);\\n                    visited.Add(adj);\\n                }\\n                minScore = Math.Min(minScore, graph[node][adj]);\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n```\\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            if (!graph.containsKey(road[0])) {\\n                graph.put(road[0], new HashMap<>());\\n            }\\n            if (!graph.containsKey(road[1])) {\\n                graph.put(road[1], new HashMap<>());\\n            }\\n            graph.get(road[0]).put(road[1], road[2]);\\n            graph.get(road[1]).put(road[0], road[2]);\\n        }\\n        int minScore = Integer.MAX_VALUE;\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(1);\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            for (int adj : graph.get(node).keySet()) {\\n                if (!visited.contains(adj)) {\\n                    queue.offer(adj);\\n                    visited.add(adj);\\n                }\\n                minScore = Math.min(minScore, graph.get(node).get(adj));\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n```\\n```TypeScript []\\nfunction minScore(n: number, roads: number[][]): number {\\n    const graph = new Map<number, Map<number, number>>();\\n    for (const road of roads) {\\n        if (!graph.has(road[0])) {\\n            graph.set(road[0], new Map<number, number>());\\n        }\\n        if (!graph.has(road[1])) {\\n            graph.set(road[1], new Map<number, number>());\\n        }\\n        graph.get(road[0]).set(road[1], road[2]);\\n        graph.get(road[1]).set(road[0], road[2]);\\n    }\\n    let minScore = Number.MAX_SAFE_INTEGER;\\n    const visited = new Set<number>();\\n    const queue = new Array<number>();\\n    queue.push(1);\\n    while (queue.length > 0) {\\n        const node = queue.shift();\\n        for (const adj of graph.get(node).keys()) {\\n            if (!visited.has(adj)) {\\n                queue.push(adj);\\n                visited.add(adj);\\n            }\\n            minScore = Math.min(minScore, graph.get(node).get(adj));\\n        }\\n    }\\n    return minScore;\\n};\\n```\\n\\n\\n# Approach\\n1. Create a graph with the given roads.\\n2. Perform a BFS traversal from node 1.\\n3. For each node, find the minimum score of the adjacent nodes.\\n4. Return the minimum score.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2). We need to traverse the entire graph.\\n\\n- Space complexity:\\nO(n^2). We need to store the graph.",
                "solutionTags": [
                    "Java",
                    "C#",
                    "TypeScript",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```CSharp []\\npublic class Solution \\n{\\n    public int MinScore(int n, int[][] roads) \\n    {\\n        var graph = new Dictionary<int, Dictionary<int, int>>();\\n        foreach (var road in roads)\\n        {\\n            if (!graph.ContainsKey(road[0]))\\n            {\\n                graph.Add(road[0], new Dictionary<int, int>());\\n            }\\n\\n            if (!graph.ContainsKey(road[1]))\\n            {\\n                graph.Add(road[1], new Dictionary<int, int>());\\n            }\\n            graph[road[0]].Add(road[1], road[2]);\\n            graph[road[1]].Add(road[0], road[2]);\\n        }\\n        var minScore = int.MaxValue;\\n        var visited = new HashSet<int>();\\n        var queue = new Queue<int>();\\n        queue.Enqueue(1);\\n        while (queue.Count > 0)\\n        {\\n            var node = queue.Dequeue();\\n            foreach (var adj in graph[node].Keys)\\n            {\\n                if (!visited.Contains(adj))\\n                {\\n                    queue.Enqueue(adj);\\n                    visited.Add(adj);\\n                }\\n                minScore = Math.Min(minScore, graph[node][adj]);\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n```\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            if (!graph.containsKey(road[0])) {\\n                graph.put(road[0], new HashMap<>());\\n            }\\n            if (!graph.containsKey(road[1])) {\\n                graph.put(road[1], new HashMap<>());\\n            }\\n            graph.get(road[0]).put(road[1], road[2]);\\n            graph.get(road[1]).put(road[0], road[2]);\\n        }\\n        int minScore = Integer.MAX_VALUE;\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(1);\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            for (int adj : graph.get(node).keySet()) {\\n                if (!visited.contains(adj)) {\\n                    queue.offer(adj);\\n                    visited.add(adj);\\n                }\\n                minScore = Math.min(minScore, graph.get(node).get(adj));\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n```\n```TypeScript []\\nfunction minScore(n: number, roads: number[][]): number {\\n    const graph = new Map<number, Map<number, number>>();\\n    for (const road of roads) {\\n        if (!graph.has(road[0])) {\\n            graph.set(road[0], new Map<number, number>());\\n        }\\n        if (!graph.has(road[1])) {\\n            graph.set(road[1], new Map<number, number>());\\n        }\\n        graph.get(road[0]).set(road[1], road[2]);\\n        graph.get(road[1]).set(road[0], road[2]);\\n    }\\n    let minScore = Number.MAX_SAFE_INTEGER;\\n    const visited = new Set<number>();\\n    const queue = new Array<number>();\\n    queue.push(1);\\n    while (queue.length > 0) {\\n        const node = queue.shift();\\n        for (const adj of graph.get(node).keys()) {\\n            if (!visited.has(adj)) {\\n                queue.push(adj);\\n                visited.add(adj);\\n            }\\n            minScore = Math.min(minScore, graph.get(node).get(adj));\\n        }\\n    }\\n    return minScore;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327263,
                "title": "solution-using-dsu-beats-100-space-and-100-runtime",
                "content": "# Intuition\\nThe ans will be the minimum weight edge in component containing 1 and n.\\n\\n# Approach\\nsimply add minimum array(let it be m) to dsu class.Where m[i] will denote minimum weight of the component i if i is parent, when we add a new edge [a,b,weight] and take i (it may be a or b decide by size) as parent node relation will be - m[i]=min(m[a],m[b],weight)\\n\\n# Complexity\\n- Time complexity:\\no(e+n)\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass dsu:\\n    def __init__(self,n):\\n        self.size=[1]*(n+1)\\n        self.parent=[x for x in range(n+1)]\\n        self.m=[float(\"inf\") for x in range(n+1)]\\n    def find(self,x):\\n        if x==self.parent[x]:\\n            return x\\n        self.parent[x]=dsu.find(self,self.parent[x])\\n        return self.parent[x]\\n    def f(self):\\n        return self.m[dsu.find(self,1)]\\n    def union(self,u,v,w):\\n        x=dsu.find(self,u)\\n        y=dsu.find(self,v)\\n        if x==y:\\n            self.m[x]=min(self.m[x],w)\\n            return\\n        elif self.size[x]>self.size[y]:\\n            self.size[x]+=self.size[y]\\n            self.parent[y]=x\\n            self.m[x]=min(self.m[x],w,self.m[y])\\n        else:\\n            self.size[y]+=self.size[x]\\n            self.parent[x]=y\\n            self.m[y]=min(self.m[y],w,self.m[x])\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        d=dsu(n)\\n        for i in range(len(roads)):\\n            d.union(roads[i][0],roads[i][1],roads[i][2])\\n        return d.f()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass dsu:\\n    def __init__(self,n):\\n        self.size=[1]*(n+1)\\n        self.parent=[x for x in range(n+1)]\\n        self.m=[float(\"inf\") for x in range(n+1)]\\n    def find(self,x):\\n        if x==self.parent[x]:\\n            return x\\n        self.parent[x]=dsu.find(self,self.parent[x])\\n        return self.parent[x]\\n    def f(self):\\n        return self.m[dsu.find(self,1)]\\n    def union(self,u,v,w):\\n        x=dsu.find(self,u)\\n        y=dsu.find(self,v)\\n        if x==y:\\n            self.m[x]=min(self.m[x],w)\\n            return\\n        elif self.size[x]>self.size[y]:\\n            self.size[x]+=self.size[y]\\n            self.parent[y]=x\\n            self.m[x]=min(self.m[x],w,self.m[y])\\n        else:\\n            self.size[y]+=self.size[x]\\n            self.parent[x]=y\\n            self.m[y]=min(self.m[y],w,self.m[x])\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        d=dsu(n)\\n        for i in range(len(roads)):\\n            d.union(roads[i][0],roads[i][1],roads[i][2])\\n        return d.f()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326823,
                "title": "c-explanation-simple-bfs-beats-100",
                "content": "# Intuition\\nSince we need to find the path between 1 and n we can think of bfs and dfs and now as to why bfs works is in approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe need to find minimum distance between 2 cities which occur in the path from node 1 to node n.\\nNow it is stated that the graph may not be connected but you need not worry about that since node 1 and node n are always connected.\\nAnother problem you might think with bfs that it only finds shortest part but here we traverse all the nodes which can be reached by node 1 and find minium distance between 2 cities.\\nNow you might wonder that why are we doing this.\\nQuestion doesn\\'t ask us to find the overall minimum path. It has just asked what is the minimum distance between cities that could form a path from 1-n.\\nFor example:-\\nour optimal path is 1-4-7 but distance is 5,7 \\nbut we first go to 1-2 whose distance is 2 and return back to 1 and than use 1-4-7.\\nThis is also a viable path and minimum distance is 2.\\nHopefully you would have understood the why bfs works.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(V+E)$$\\nV is number of vertices\\nE is number of edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>>>adj; //creating adjacency list\\n        int ans=INT_MAX; //creating answer variable\\n        for(auto i:roads) //putting values in adjacency list\\n        {\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>vis(n+1); //creating visited array\\n        queue<int> q; // quque required for bfs\\n        q.push(1); \\n        vis[1] = 1;\\n        while(!q.empty()) // bfs loop\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto i:adj[node])\\n            {\\n                ans=min(ans,i.second);\\n                if(vis[i.first]!=1)\\n                {\\n                    vis[i.first]=1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>>>adj; //creating adjacency list\\n        int ans=INT_MAX; //creating answer variable\\n        for(auto i:roads) //putting values in adjacency list\\n        {\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>vis(n+1); //creating visited array\\n        queue<int> q; // quque required for bfs\\n        q.push(1); \\n        vis[1] = 1;\\n        while(!q.empty()) // bfs loop\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto i:adj[node])\\n            {\\n                ans=min(ans,i.second);\\n                if(vis[i.first]!=1)\\n                {\\n                    vis[i.first]=1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326722,
                "title": "union-find-path-compression",
                "content": "pretty standard union find, just need to add path compression to avoid TLE \\n\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        root = [i for i in range(n+1)]\\n\\n        def find(a):\\n            if root[a] == a:\\n                return a\\n            root[a] = find(root[a]) # path compression  \\n            return root[a]\\n\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            root[a] = b\\n\\n        for a, b, _ in roads:\\n            union(a,b)\\n\\n        return min(d for a,b,d in roads if find(n) == find(a))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        root = [i for i in range(n+1)]\\n\\n        def find(a):\\n            if root[a] == a:\\n                return a\\n            root[a] = find(root[a]) # path compression  \\n            return root[a]\\n\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            root[a] = b\\n\\n        for a, b, _ in roads:\\n            union(a,b)\\n\\n        return min(d for a,b,d in roads if find(n) == find(a))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326634,
                "title": "java-dfs-simple-and-clean-code-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is guaranteed to be some path between cities 1 and n. We don\\'t need to care about cities that are not connected with 1 and n. We can start with city 1 and run a DFS search, visit every connected city and keep track of the minimum distance between any 2 cities. We can always traverse the road with the minimum distance on our way from city 1 to n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int[]>[] adj;\\n  boolean[] seen;\\n  int min = Integer.MAX_VALUE;\\n\\n  private void dfs(int city) {\\n    if (seen[city]) return;\\n    seen[city] = true;\\n\\n    for (var neighbor : adj[city]) {\\n      min = Math.min(min, neighbor[1]);\\n      dfs(neighbor[0]);\\n    }\\n  }\\n  \\n  public int minScore(int n, int[][] roads) {\\n    seen = new boolean[n];\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var road : roads) {\\n      adj[road[0] - 1].add(new int[] {road[1] - 1, road[2]});\\n      adj[road[1] - 1].add(new int[] {road[0] - 1, road[2]});\\n    }\\n    dfs(0);\\n    return min;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  List<int[]>[] adj;\\n  boolean[] seen;\\n  int min = Integer.MAX_VALUE;\\n\\n  private void dfs(int city) {\\n    if (seen[city]) return;\\n    seen[city] = true;\\n\\n    for (var neighbor : adj[city]) {\\n      min = Math.min(min, neighbor[1]);\\n      dfs(neighbor[0]);\\n    }\\n  }\\n  \\n  public int minScore(int n, int[][] roads) {\\n    seen = new boolean[n];\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var road : roads) {\\n      adj[road[0] - 1].add(new int[] {road[1] - 1, road[2]});\\n      adj[road[1] - 1].add(new int[] {road[0] - 1, road[2]});\\n    }\\n    dfs(0);\\n    return min;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875768,
                "title": "simple-solution-using-dfs-and-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically we need to return the minimum weighted edge in the graph and it is also said that there will definitely lie a path from edge 1 to n. So if the graph consists of two or more components and minimum exists in other components where the component doesn\\'t lie in the path of 1 to n.Simply returning minimum of the weights won\\'t work.We can use dfs to mark all the nodes and find the minimum among them only.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is simple we need to perform dfs with source as 1 and marks all nodes True and keep track of minimum . In this solution I created my own graph to make the work easier . Though the space complexity is little high but the solution is fast and efficient\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime required for our graph creation is O(V).DFS takes time complexity of O(V+E). Time complexity is O(2V+E) .The optimized time complexity is O(V+E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFor storing the graph we need O(V+E) space and we create a lst to store weight i.e. O(V) . Hence the total space complexity is O(V+E)\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph = [[] for i in range(n+1)]\\n        visited = [False for i in range(n+1)]\\n        for i in roads:\\n            graph[i[0]].append(tuple(i[1:]))\\n            graph[i[1]].append((i[0],i[2]))\\n        print(graph)\\n        lst = []\\n        def dfs(visited,graph,source,lst):\\n            visited[source]=True\\n            for i in graph[source]:\\n                lst.append(i[-1])\\n                if visited[i[0]]==False:\\n                    dfs(visited,graph,i[0],lst)\\n        dfs(visited,graph,1,lst)\\n        return min(lst)\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph = [[] for i in range(n+1)]\\n        visited = [False for i in range(n+1)]\\n        for i in roads:\\n            graph[i[0]].append(tuple(i[1:]))\\n            graph[i[1]].append((i[0],i[2]))\\n        print(graph)\\n        lst = []\\n        def dfs(visited,graph,source,lst):\\n            visited[source]=True\\n            for i in graph[source]:\\n                lst.append(i[-1])\\n                if visited[i[0]]==False:\\n                    dfs(visited,graph,i[0],lst)\\n        dfs(visited,graph,1,lst)\\n        return min(lst)\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875363,
                "title": "c-simple-dfs-easy-o-n",
                "content": "```C++\\nclass Solution {\\npublic:\\n    unordered_set<int> s;\\n    unordered_map<int, vector<int>> mp;\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        for(auto& r:roads) {\\n            mp[r[0]].push_back(r[1]);\\n            mp[r[1]].push_back(r[0]);\\n        }\\n        dfs(1);\\n        //the set s is the connected vertice with 1 and n now.\\n        \\n        //find out the minimum edge in connected vertice that including 1 & n;\\n        int ans = INT_MAX;\\n        for(auto& r:roads) {\\n            if(s.find(r[0]) != s.end()) {\\n                ans = min(ans, r[2]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    void dfs(int root) {\\n        if(s.find(root) != s.end()) return;\\n        s.insert(root);\\n        for(auto&child : mp[root]) {\\n            dfs(child);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    unordered_set<int> s;\\n    unordered_map<int, vector<int>> mp;\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        for(auto& r:roads) {\\n            mp[r[0]].push_back(r[1]);\\n            mp[r[1]].push_back(r[0]);\\n        }\\n        dfs(1);\\n        //the set s is the connected vertice with 1 and n now.\\n        \\n        //find out the minimum edge in connected vertice that including 1 & n;\\n        int ans = INT_MAX;\\n        for(auto& r:roads) {\\n            if(s.find(r[0]) != s.end()) {\\n                ans = min(ans, r[2]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    void dfs(int root) {\\n        if(s.find(root) != s.end()) return;\\n        s.insert(root);\\n        for(auto&child : mp[root]) {\\n            dfs(child);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875094,
                "title": "python-dfs-video-solution",
                "content": "I have explained the solution in this [video](https://www.youtube.com/watch?v=lLc-TGF3YPc).\\n\\nWe just have to go through all the roads, for our connected component `1->n` and find the min. road.\\n\\nWe can keep a **visited** set on **node**. But we still have to consider any **roads** leading to a seen node for our answer.\\n\\n**Time:** `O(n + E)` where `n` is the number of cities, and `E` is the number of roads.\\n\\n**Space:**\\n`O(n)` Heap Memory for our visited set \\n`O(n)` Recursive Stack Memory\\n\\n\\nIf this was helpful, please upvote, like the video and subscribe to the channel.\\n\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        m = defaultdict(list)\\n        \\n        for a,b,dist in roads:\\n            m[a].append([b, dist])\\n            m[b].append([a, dist])\\n            \\n        res = [math.inf]\\n        \\n        visit = set()\\n        \\n        def dfs(node):\\n            \\n            visit.add(node)\\n            \\n            for nei, cost in m[node]:\\n                res[0] = min(res[0], cost)\\n                \\n                if nei in visit:\\n                    continue\\n                dfs(nei)\\n                \\n        dfs(1)\\n        \\n        return res[0]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "I have explained the solution in this [video](https://www.youtube.com/watch?v=lLc-TGF3YPc).\\n\\nWe just have to go through all the roads, for our connected component `1->n` and find the min. road.\\n\\nWe can keep a **visited** set on **node**. But we still have to consider any **roads** leading to a seen node for our answer.\\n\\n**Time:** `O(n + E)` where `n` is the number of cities, and `E` is the number of roads.\\n\\n**Space:**\\n`O(n)` Heap Memory for our visited set \\n`O(n)` Recursive Stack Memory\\n\\n\\nIf this was helpful, please upvote, like the video and subscribe to the channel.\\n\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        m = defaultdict(list)\\n        \\n        for a,b,dist in roads:\\n            m[a].append([b, dist])\\n            m[b].append([a, dist])\\n            \\n        res = [math.inf]\\n        \\n        visit = set()\\n        \\n        def dfs(node):\\n            \\n            visit.add(node)\\n            \\n            for nei, cost in m[node]:\\n                res[0] = min(res[0], cost)\\n                \\n                if nei in visit:\\n                    continue\\n                dfs(nei)\\n                \\n        dfs(1)\\n        \\n        return res[0]",
                "codeTag": "Java"
            },
            {
                "id": 2875015,
                "title": "python-queue-bfs",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\ndef minScore(n: int, roads: list[list[int]]) -> int:\\n    graph = {}\\n    for i, j, k in roads:\\n        if i in graph:\\n            graph[i].add((j, k))\\n        else:\\n            graph[i] = {(j, k)}\\n        if j in graph:\\n            graph[j].add((i, k))\\n        else:\\n            graph[j] = {(i, k)}\\n\\n    q = deque()\\n    for i in graph[1]:\\n        q.append([1, i[0], i[1]])\\n    minPath = float(\"inf\")\\n    isVisited = n == 1\\n    visited = {1}\\n    while q:\\n        currNode, nextNode, dist = q.popleft()\\n        if nextNode == n:\\n            isVisited = True\\n        minPath = min(minPath, dist)\\n        if nextNode in visited:\\n            continue\\n        visited.add(nextNode)\\n        for nextnextNode, val in graph[nextNode]:\\n            q.append([nextnextNode, nextNode, val])\\n    return minPath if isVisited else -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\ndef minScore(n: int, roads: list[list[int]]) -> int:\\n    graph = {}\\n    for i, j, k in roads:\\n        if i in graph:\\n            graph[i].add((j, k))\\n        else:\\n            graph[i] = {(j, k)}\\n        if j in graph:\\n            graph[j].add((i, k))\\n        else:\\n            graph[j] = {(i, k)}\\n\\n    q = deque()\\n    for i in graph[1]:\\n        q.append([1, i[0], i[1]])\\n    minPath = float(\"inf\")\\n    isVisited = n == 1\\n    visited = {1}\\n    while q:\\n        currNode, nextNode, dist = q.popleft()\\n        if nextNode == n:\\n            isVisited = True\\n        minPath = min(minPath, dist)\\n        if nextNode in visited:\\n            continue\\n        visited.add(nextNode)\\n        for nextnextNode, val in graph[nextNode]:\\n            q.append([nextnextNode, nextNode, val])\\n    return minPath if isVisited else -1\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2874974,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> &vis,vector<pair<int,int>> adj[],int &ans){\\n        vis[node] = 1;\\n        for(auto x : adj[node]){\\n            ans = min(ans,x.second);\\n        }\\n        for(auto x : adj[node]){\\n            if(vis[x.first]==0){\\n                dfs(x.first,vis,adj,ans);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for(auto it : roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        int ans=INT_MAX;\\n        dfs(1,vis,adj,ans);\\n        if(vis[1]==1 && vis[n]==1) {return ans;}\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> &vis,vector<pair<int,int>> adj[],int &ans){\\n        vis[node] = 1;\\n        for(auto x : adj[node]){\\n            ans = min(ans,x.second);\\n        }\\n        for(auto x : adj[node]){\\n            if(vis[x.first]==0){\\n                dfs(x.first,vis,adj,ans);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for(auto it : roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        int ans=INT_MAX;\\n        dfs(1,vis,adj,ans);\\n        if(vis[1]==1 && vis[n]==1) {return ans;}\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874944,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int minEdge;\\n    public int minScore(int n, int[][] roads) {\\n        this.minEdge = Integer.MAX_VALUE;\\n        Map<Integer, List<Node>> graph = constructGraph(roads);\\n        dfs(graph, 1, new HashSet<>(), n);\\n        return this.minEdge;\\n    }\\n    public class Node {\\n        public int nodeValue;\\n        public int edgeValue;\\n        public Node(int nodeValue, int edgeValue) {\\n            this.nodeValue = nodeValue;\\n            this.edgeValue = edgeValue;\\n        }\\n    }\\n    public Map<Integer, List<Node>> constructGraph(int[][] roads) {\\n        Map<Integer, List<Node>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            int start = road[0];\\n            int end = road[1];\\n            int edgeValue = road[2];\\n            List<Node> startList;\\n            if (graph.containsKey(start)) {\\n                startList = graph.get(start);\\n            } else {\\n                startList = new ArrayList<>();\\n            }\\n            startList.add(new Node(end, edgeValue));\\n            graph.put(start, startList);\\n            List<Node> endList;\\n            if (graph.containsKey(end)) {\\n                endList = graph.get(end);\\n            } else {\\n                endList = new ArrayList<>();\\n            }\\n            endList.add(new Node(start, edgeValue));\\n            graph.put(end, endList);\\n        }\\n        return graph;\\n    }\\n    public void dfs(Map<Integer, List<Node>> graph, int currentNode, Set<Integer> visited, int endValue) {\\n        if (currentNode == endValue || visited.contains(currentNode) || !graph.containsKey(currentNode)) {\\n            return;\\n        }\\n        visited.add(currentNode);\\n        List<Node> neighbors = graph.get(currentNode);\\n        for (Node node : neighbors) {\\n            this.minEdge = Math.min(this.minEdge, node.edgeValue);\\n            dfs(graph, node.nodeValue, visited, endValue);\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEdge;\\n    public int minScore(int n, int[][] roads) {\\n        this.minEdge = Integer.MAX_VALUE;\\n        Map<Integer, List<Node>> graph = constructGraph(roads);\\n        dfs(graph, 1, new HashSet<>(), n);\\n        return this.minEdge;\\n    }\\n    public class Node {\\n        public int nodeValue;\\n        public int edgeValue;\\n        public Node(int nodeValue, int edgeValue) {\\n            this.nodeValue = nodeValue;\\n            this.edgeValue = edgeValue;\\n        }\\n    }\\n    public Map<Integer, List<Node>> constructGraph(int[][] roads) {\\n        Map<Integer, List<Node>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            int start = road[0];\\n            int end = road[1];\\n            int edgeValue = road[2];\\n            List<Node> startList;\\n            if (graph.containsKey(start)) {\\n                startList = graph.get(start);\\n            } else {\\n                startList = new ArrayList<>();\\n            }\\n            startList.add(new Node(end, edgeValue));\\n            graph.put(start, startList);\\n            List<Node> endList;\\n            if (graph.containsKey(end)) {\\n                endList = graph.get(end);\\n            } else {\\n                endList = new ArrayList<>();\\n            }\\n            endList.add(new Node(start, edgeValue));\\n            graph.put(end, endList);\\n        }\\n        return graph;\\n    }\\n    public void dfs(Map<Integer, List<Node>> graph, int currentNode, Set<Integer> visited, int endValue) {\\n        if (currentNode == endValue || visited.contains(currentNode) || !graph.containsKey(currentNode)) {\\n            return;\\n        }\\n        visited.add(currentNode);\\n        List<Node> neighbors = graph.get(currentNode);\\n        for (Node node : neighbors) {\\n            this.minEdge = Math.min(this.minEdge, node.edgeValue);\\n            dfs(graph, node.nodeValue, visited, endValue);\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333354,
                "title": "c-dfs-o-n-e",
                "content": "# Intuition\\nSince nodes 1 and n are in the same connected component, the minimum possible score of a path from 1 to n will be the minimum edge weight in that component.\\n\\n# Approach\\nRun a DFS/BFS for the component containing node 1 and find out the minimum edge weight. That will be our answer.\\n\\n# Complexity\\n- Time complexity: O(n+e) [n:number of cities, e:roads]\\n\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mini=1e9;\\n    void dfs(int node, vector<pair<int,int>> graph[], vector<int>& vis){\\n        vis[node]=1;\\n        for(auto child:graph[node]){\\n            int child_n = child.first;\\n            int child_w = child.second;\\n\\n            mini = min(mini, child_w);\\n            if(vis[child_n]) continue;\\n            \\n            dfs(child_n, graph, vis);\\n        }\\n        return;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> graph[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            graph[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        //Since node 1 and n is in the same component\\n        vector<int> vis(n+1,0);\\n        dfs(1, graph, vis);\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini=1e9;\\n    void dfs(int node, vector<pair<int,int>> graph[], vector<int>& vis){\\n        vis[node]=1;\\n        for(auto child:graph[node]){\\n            int child_n = child.first;\\n            int child_w = child.second;\\n\\n            mini = min(mini, child_w);\\n            if(vis[child_n]) continue;\\n            \\n            dfs(child_n, graph, vis);\\n        }\\n        return;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> graph[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            graph[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        //Since node 1 and n is in the same component\\n        vector<int> vis(n+1,0);\\n        dfs(1, graph, vis);\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332899,
                "title": "easy-clear-solution-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[]\\n        related=set()\\n        for i in range(n+1):\\n            adj.append([])\\n        for i in roads:\\n            adj[i[0]].append(i[1])\\n            adj[i[1]].append(i[0])\\n        def dfs(node:int):\\n            related.add(node)\\n            for i in adj[node]:\\n                if i not in related:\\n                    dfs(i)\\n        dfs(1)\\n        dfs(n)\\n        res=10000\\n        for i in roads:\\n            if i[0] in related and i[1] in related:\\n                res=min(res,i[2])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[]\\n        related=set()\\n        for i in range(n+1):\\n            adj.append([])\\n        for i in roads:\\n            adj[i[0]].append(i[1])\\n            adj[i[1]].append(i[0])\\n        def dfs(node:int):\\n            related.add(node)\\n            for i in adj[node]:\\n                if i not in related:\\n                    dfs(i)\\n        dfs(1)\\n        dfs(n)\\n        res=10000\\n        for i in roads:\\n            if i[0] in related and i[1] in related:\\n                res=min(res,i[2])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330262,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Dijkstra\\n\\n# Code\\n```\\n#define pii pair<int, int>\\n#define maxn 100005\\n#define inf 1000000007\\nclass Solution {\\npublic:\\n    vector<pii>g[maxn];\\n    int dis[maxn];\\n    void dijkstra(int s, int n) {\\n        priority_queue<pii, vector<pii>, greater<pii>> q;\\n        for(int i=0; i<=n; i++) dis[i] = inf;\\n        q.push({inf, s});\\n        while(!q.empty()) {\\n            int u = q.top().second;\\n            q.pop();\\n            for(int i=0; i<g[u].size(); i++) {\\n                int v = g[u][i].first;\\n                int w = g[u][i].second;\\n                if(min(dis[u], w) < dis[v]) {\\n                    dis[v] = min(dis[u], w);\\n                    q.push({dis[v], v});\\n                }\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        for(auto x: roads) {\\n            int u = x[0];\\n            int v = x[1];\\n            int w = x[2];\\n            g[u].push_back({v, w});\\n            g[v].push_back({u, w});\\n        }\\n        dijkstra(1, n);\\n        return dis[n]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pii pair<int, int>\\n#define maxn 100005\\n#define inf 1000000007\\nclass Solution {\\npublic:\\n    vector<pii>g[maxn];\\n    int dis[maxn];\\n    void dijkstra(int s, int n) {\\n        priority_queue<pii, vector<pii>, greater<pii>> q;\\n        for(int i=0; i<=n; i++) dis[i] = inf;\\n        q.push({inf, s});\\n        while(!q.empty()) {\\n            int u = q.top().second;\\n            q.pop();\\n            for(int i=0; i<g[u].size(); i++) {\\n                int v = g[u][i].first;\\n                int w = g[u][i].second;\\n                if(min(dis[u], w) < dis[v]) {\\n                    dis[v] = min(dis[u], w);\\n                    q.push({dis[v], v});\\n                }\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        for(auto x: roads) {\\n            int u = x[0];\\n            int v = x[1];\\n            int w = x[2];\\n            g[u].push_back({v, w});\\n            g[v].push_back({u, w});\\n        }\\n        dijkstra(1, n);\\n        return dis[n]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329538,
                "title": "python-simple-python-solution-using-graph",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1771 ms, faster than 69.46% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n# Memory Usage: 66.6 MB, less than 69.13% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n\\n\\tclass Solution:\\n\\t\\tdef minScore(self, n: int, roads: List[List[int]]) -> int:\\n\\n\\t\\t\\tgraph = collections.defaultdict(list)\\n\\n\\t\\t\\tfor source, destination , distance in roads:\\n\\n\\t\\t\\t\\tgraph[source].append([destination , distance])\\n\\t\\t\\t\\tgraph[destination].append([source , distance])\\n\\n\\t\\t\\tresult = 10000\\n\\n\\t\\t\\tstack = graph.pop(1)\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tcurrent_city, distance = stack.pop()\\n\\n\\t\\t\\t\\tresult = min(result, distance)\\n\\n\\t\\t\\t\\tif current_city in graph:\\n\\t\\t\\t\\t\\tstack.extand(graph.pop(current_city))\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1771 ms, faster than 69.46% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n# Memory Usage: 66.6 MB, less than 69.13% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n\\n\\tclass Solution:\\n\\t\\tdef minScore(self, n: int, roads: List[List[int]]) -> int:\\n\\n\\t\\t\\tgraph = collections.defaultdict(list)\\n\\n\\t\\t\\tfor source, destination , distance in roads:\\n\\n\\t\\t\\t\\tgraph[source].append([destination , distance])\\n\\t\\t\\t\\tgraph[destination].append([source , distance])\\n\\n\\t\\t\\tresult = 10000\\n\\n\\t\\t\\tstack = graph.pop(1)\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tcurrent_city, distance = stack.pop()\\n\\n\\t\\t\\t\\tresult = min(result, distance)\\n\\n\\t\\t\\t\\tif current_city in graph:\\n\\t\\t\\t\\t\\tstack.extand(graph.pop(current_city))\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3328691,
                "title": "java-clean-bfs-and-dfs-solutions",
                "content": "# Intuition:\\n*Traverse the graph starting from vertex $$1$$ and get the minimum distance between two cities (minimum edge weight).*\\n\\n---\\n### Case of disconnected cities:\\nIf you were thinking of running a for loop on `roads` and get the minimum distance then that won\\'t work \\uD83D\\uDE06.\\n\\n![image.png](https://assets.leetcode.com/users/images/b584e0bf-0c90-488c-99d6-2b7a0d59162d_1679490960.7636707.png)\\n\\n### So a graph traversal is the way, starting from $$1$$.\\n\\n---\\n# DFS solution:\\n```\\nclass Solution {\\n    private List<int[]>[] adj;\\n    private int score = 10001;\\n    private boolean[] vis;\\n    public int minScore(int n, int[][] roads) {\\n        adj = new List[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] r : roads) {\\n            adj[r[0]].add(new int[] {r[1], r[2]});\\n            adj[r[1]].add(new int[] {r[0], r[2]});\\n        }\\n\\n        vis = new boolean[n + 1];\\n        vis[1] = true;\\n\\n        dfs(1);\\n        return score;\\n    }\\n\\n    private void dfs(int curr) {\\n        for (int[] nei : adj[curr]) {\\n            int next = nei[0], dist = nei[1];\\n            score = Math.min(score, dist);\\n            if (!vis[next]) {\\n                vis[next] = true;\\n                dfs(next);\\n            }\\n        }\\n    }\\n}\\n```\\n##### Time complexity: $$O(n + e)$$\\n##### Space complexity: $$O(n + e) + O(n)$$\\n---\\n# 2. BFS solution:\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<int[]>[] adj = new List[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] r : roads) {\\n            adj[r[0]].add(new int[] {r[1], r[2]});\\n            adj[r[1]].add(new int[] {r[0], r[2]});\\n        }\\n\\n        boolean[] vis = new boolean[n + 1];\\n        vis[1] = true;\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(1);\\n        int score = 10001;\\n\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            for (int[] nei : adj[curr]) {\\n                int next = nei[0], dist = nei[1];\\n                score = Math.min(score, dist);\\n                if (!vis[next]) {\\n                    vis[next] = true;\\n                    q.offer(next);\\n                }\\n            }\\n        }\\n\\n        return score;\\n    }\\n}\\n```\\n##### Time complexity: $$O(n + e)$$\\n##### Space complexity: $$O(n + e) + O(2.n)$$",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private List<int[]>[] adj;\\n    private int score = 10001;\\n    private boolean[] vis;\\n    public int minScore(int n, int[][] roads) {\\n        adj = new List[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] r : roads) {\\n            adj[r[0]].add(new int[] {r[1], r[2]});\\n            adj[r[1]].add(new int[] {r[0], r[2]});\\n        }\\n\\n        vis = new boolean[n + 1];\\n        vis[1] = true;\\n\\n        dfs(1);\\n        return score;\\n    }\\n\\n    private void dfs(int curr) {\\n        for (int[] nei : adj[curr]) {\\n            int next = nei[0], dist = nei[1];\\n            score = Math.min(score, dist);\\n            if (!vis[next]) {\\n                vis[next] = true;\\n                dfs(next);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<int[]>[] adj = new List[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] r : roads) {\\n            adj[r[0]].add(new int[] {r[1], r[2]});\\n            adj[r[1]].add(new int[] {r[0], r[2]});\\n        }\\n\\n        boolean[] vis = new boolean[n + 1];\\n        vis[1] = true;\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(1);\\n        int score = 10001;\\n\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            for (int[] nei : adj[curr]) {\\n                int next = nei[0], dist = nei[1];\\n                score = Math.min(score, dist);\\n                if (!vis[next]) {\\n                    vis[next] = true;\\n                    q.offer(next);\\n                }\\n            }\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328398,
                "title": "cake-walk-beats-88-time-and-80-memory",
                "content": "# Intuition\\nIn the question it is given that **It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.**\\nso i thought of just traversing through the roads array and then find the minimum of all the distances but that gave me **wrong answer** as graph is disconnected and there may be paths were we can\\'t even reach. So i just use dfs and traverse from all the node connected from node 1 and n  \\n\\n\\n# Approach\\nfirst i created an adjacency list and then i created a visited array and run dfs function from node 1 and mark all the connected nodes as visited and then i check for the minimum distance in the roads array who are connected with node 1 and n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &v,int i,vector<int> &visited){\\n        visited[i]=true;\\n        for(auto node:v[i]){\\n            if(!visited[node]){\\n                dfs(v,node,visited);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans=INT_MAX;\\n        vector<vector<int>> v(n+1);\\n        for(int i=0;i<roads.size();i++){\\n            v[roads[i][0]].push_back(roads[i][1]);\\n            v[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> visited(n+1,false);\\n        dfs(v,1,visited);\\n        for(int i=0;i<roads.size();i++){\\n            if(visited[roads[i][0]] || visited[roads[i][1]])\\n                ans=min(ans,roads[i][2]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &v,int i,vector<int> &visited){\\n        visited[i]=true;\\n        for(auto node:v[i]){\\n            if(!visited[node]){\\n                dfs(v,node,visited);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans=INT_MAX;\\n        vector<vector<int>> v(n+1);\\n        for(int i=0;i<roads.size();i++){\\n            v[roads[i][0]].push_back(roads[i][1]);\\n            v[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> visited(n+1,false);\\n        dfs(v,1,visited);\\n        for(int i=0;i<roads.size();i++){\\n            if(visited[roads[i][0]] || visited[roads[i][1]])\\n                ans=min(ans,roads[i][2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328096,
                "title": "easy-java-solution-dijkstra-s-algorithm-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can apply Dijkstra\\'s Algorithm here to find distance between 2 node. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can apply Dijkstra Algorithm here to find distance between 2 node and after each node we will comapre minimum disatnce and return minimum.\\n\\n**In Code, I wrote everything in comment which is needed to understand this problem.**\\n\\n**\"Please Look At Once In Code. You Will Definitely Understand.\"**\\n\\n# Complexity\\n- Time complexity: O(E*logE)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    class Pair{\\n        int distance;\\n        int node;\\n\\n        Pair(int distance, int node)\\n        {\\n            this.distance = distance;\\n            this.node = node;\\n        }\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n\\n        //Priority Queue will help us to get minimum value at the top.\\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>((x,y) -> x.distance - y.distance);\\n\\n        //Intialize min variable.\\n        int min = Integer.MAX_VALUE;\\n\\n        ArrayList<ArrayList<Pair>> ar = new ArrayList<>();\\n\\n        //Making space in adjecency arraylist\\n        for(int i=0;i<n+1;i++)\\n        {\\n            ar.add(new ArrayList<>());\\n        }\\n\\n        //filling 2D roads values into adjecency arraylist which we made.\\n        for(int i=0;i<roads.length;i++)\\n        {\\n            //storing value of distance and node in adjecency list with pair class.\\n            //like a -> {dis, b};\\n            //like b -> {dis, a};\\n            ar.get(roads[i][0]).add(new Pair(roads[i][2], roads[i][1]));\\n            ar.get(roads[i][1]).add(new Pair(roads[i][2], roads[i][0]));\\n        }\\n\\n        //Initialize value for Priority Queue to MAX from 1 to n+1.\\n        pq.add(new Pair(Integer.MAX_VALUE,1));\\n\\n        //Create visited array to identify a particular node is already visited or not.\\n        int[] visited = new int[n+1];\\n\\n        //Iterate priority queue and store value according to distance of particular node.\\n        while(pq.size() > 0)\\n        {\\n            //Getting distance and node for each entry.\\n            int distance = pq.peek().distance;\\n            int node = pq.peek().node;\\n\\n            //Removing element after fetch distance and node.\\n            pq.remove();\\n\\n            //Getting minimum distance in min varaible.\\n            min = Math.min(min, distance);\\n\\n            //Now we check that if we visited node earlier or not.\\n            // \"if condition\" is for not visited.\\n            if(visited[node] == 0)\\n            {\\n                //Iterate adjecency list.\\n                for(int i=0;i<ar.get(node).size();i++)\\n                {\\n                    //Getting distance and for particular node\\n                    int a = ar.get(node).get(i).distance;\\n                    int b = ar.get(node).get(i).node;\\n\\n                    pq.add(new Pair(a,b)); \\n                }\\n            }\\n\\n            visited[node] = 1;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```\\n**Please Upvote, if you understand the problem by this solution !!!**\\n\\n![download.jfif](https://assets.leetcode.com/users/images/85bd7027-fe3e-4c05-b8b8-2ecd1ce5fd2e_1679478821.0124345.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n\\n    class Pair{\\n        int distance;\\n        int node;\\n\\n        Pair(int distance, int node)\\n        {\\n            this.distance = distance;\\n            this.node = node;\\n        }\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n\\n        //Priority Queue will help us to get minimum value at the top.\\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>((x,y) -> x.distance - y.distance);\\n\\n        //Intialize min variable.\\n        int min = Integer.MAX_VALUE;\\n\\n        ArrayList<ArrayList<Pair>> ar = new ArrayList<>();\\n\\n        //Making space in adjecency arraylist\\n        for(int i=0;i<n+1;i++)\\n        {\\n            ar.add(new ArrayList<>());\\n        }\\n\\n        //filling 2D roads values into adjecency arraylist which we made.\\n        for(int i=0;i<roads.length;i++)\\n        {\\n            //storing value of distance and node in adjecency list with pair class.\\n            //like a -> {dis, b};\\n            //like b -> {dis, a};\\n            ar.get(roads[i][0]).add(new Pair(roads[i][2], roads[i][1]));\\n            ar.get(roads[i][1]).add(new Pair(roads[i][2], roads[i][0]));\\n        }\\n\\n        //Initialize value for Priority Queue to MAX from 1 to n+1.\\n        pq.add(new Pair(Integer.MAX_VALUE,1));\\n\\n        //Create visited array to identify a particular node is already visited or not.\\n        int[] visited = new int[n+1];\\n\\n        //Iterate priority queue and store value according to distance of particular node.\\n        while(pq.size() > 0)\\n        {\\n            //Getting distance and node for each entry.\\n            int distance = pq.peek().distance;\\n            int node = pq.peek().node;\\n\\n            //Removing element after fetch distance and node.\\n            pq.remove();\\n\\n            //Getting minimum distance in min varaible.\\n            min = Math.min(min, distance);\\n\\n            //Now we check that if we visited node earlier or not.\\n            // \"if condition\" is for not visited.\\n            if(visited[node] == 0)\\n            {\\n                //Iterate adjecency list.\\n                for(int i=0;i<ar.get(node).size();i++)\\n                {\\n                    //Getting distance and for particular node\\n                    int a = ar.get(node).get(i).distance;\\n                    int b = ar.get(node).get(i).node;\\n\\n                    pq.add(new Pair(a,b)); \\n                }\\n            }\\n\\n            visited[node] = 1;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327600,
                "title": "java-dsu-100-solution-with-5ms",
                "content": "Intuition - First taking base case, in which we have to join two nodes with an edge between them. We will connect them but in rank[], we will store the edge value between them.\\nNow, we need to merge two groups of nodes with their root parent having rank[root] value as the minimum edge between edges connected within their group only. So, we will do union of these two groups, and for that we will make root of the combined group the node which the root of a group with minimum value edges within the nodes in it group. Or rank[i] stores this minimum edge value in the nodes of group with root as ith node. And there is new edge between these two root nodes also, so we will compare rank[combined root] value with this new edge also.\\n\\nWhen union of all edges is done. And node 1 and node 4 will be in a group. Then rank[parent of node 1 or node n] is the answer.\\nRuntime: 5 ms, faster than 100.00% \\n\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int[] parent = new int[n+1], rank = new int[n+1];\\n        for(int i = 1; i <= n; ++i){\\n            parent[i] = i;\\n            rank[i] = Integer.MAX_VALUE;\\n        }\\n        int ans = Integer.MAX_VALUE, u, v;\\n        for(int[] road : roads){\\n            union(parent, rank, road[0], road[1], road[2]);\\n        }\\n        u = find(parent, 1); v = find(parent, n);\\n        if(u == v){\\n            ans = rank[u];\\n        }\\n        return ans;\\n    }\\n    \\n    private int find(int[] parent, int x){\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent, parent[x]);\\n    }\\n    \\n    private void union(int[] parent, int[] rank, int u, int v, int w){\\n        u = find(parent, u);\\n        v = find(parent, v);\\n        // if(u == v) return;\\n        if(rank[u] <= rank[v]){\\n            parent[v] = u;\\n            rank[u] = (int)Math.min(rank[u], w);\\n        }\\n        else{\\n            parent[u] = v;\\n            rank[v] = (int)Math.min(rank[v], w);\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int[] parent = new int[n+1], rank = new int[n+1];\\n        for(int i = 1; i <= n; ++i){\\n            parent[i] = i;\\n            rank[i] = Integer.MAX_VALUE;\\n        }\\n        int ans = Integer.MAX_VALUE, u, v;\\n        for(int[] road : roads){\\n            union(parent, rank, road[0], road[1], road[2]);\\n        }\\n        u = find(parent, 1); v = find(parent, n);\\n        if(u == v){\\n            ans = rank[u];\\n        }\\n        return ans;\\n    }\\n    \\n    private int find(int[] parent, int x){\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent, parent[x]);\\n    }\\n    \\n    private void union(int[] parent, int[] rank, int u, int v, int w){\\n        u = find(parent, u);\\n        v = find(parent, v);\\n        // if(u == v) return;\\n        if(rank[u] <= rank[v]){\\n            parent[v] = u;\\n            rank[u] = (int)Math.min(rank[u], w);\\n        }\\n        else{\\n            parent[u] = v;\\n            rank[v] = (int)Math.min(rank[v], w);\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327590,
                "title": "python3-99-96-t-m-faster-beats-clean-solution-simple-explain",
                "content": "![image.png](https://assets.leetcode.com/users/images/242a2589-17c6-4341-a8dd-8641e5a14b6c_1679467685.8966243.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nImportant tips for you : As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge.\\n\\n# Complexity\\n- Time complexity:O(n)\\n- create table time , bfs time , traval roads time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n- hash table\\u3001view\\u3001ans\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        ht = defaultdict(list)\\n        for i,j,dis in roads:\\n            ht[i].append(j)\\n            ht[j].append(i)\\n        ans,view= inf,set()\\n        queue = deque([1])\\n        while queue:\\n            cur_city = queue.popleft()\\n            for next_city in ht[cur_city]:\\n                if next_city not in view:\\n                    queue.append(next_city)\\n                    view.add(next_city)\\n        for i,j,dis in roads:\\n            if i in view or j in view:\\n                ans=min(ans,dis)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        ht = defaultdict(list)\\n        for i,j,dis in roads:\\n            ht[i].append(j)\\n            ht[j].append(i)\\n        ans,view= inf,set()\\n        queue = deque([1])\\n        while queue:\\n            cur_city = queue.popleft()\\n            for next_city in ht[cur_city]:\\n                if next_city not in view:\\n                    queue.append(next_city)\\n                    view.add(next_city)\\n        for i,j,dis in roads:\\n            if i in view or j in view:\\n                ans=min(ans,dis)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327402,
                "title": "dfs-c",
                "content": "```\\nclass Solution {\\n    void dfs(int node, vector<pair<int, int>> adj[], vector<int> &vis, int &ans) {\\n        vis[node] = 1;\\n        for(auto ad : adj[node]) {\\n            ans = min(ans, ad.second);\\n            if(!vis[ad.first]) dfs(ad.first, adj, vis, ans);\\n        }\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n + 1];\\n        for(auto e : roads) adj[e[0]].push_back({e[1], e[2]}), adj[e[1]].push_back({e[0], e[2]});\\n        \\n        int ans = 1e9;\\n        vector<int> vis(n + 1);\\n        dfs(n, adj, vis, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<pair<int, int>> adj[], vector<int> &vis, int &ans) {\\n        vis[node] = 1;\\n        for(auto ad : adj[node]) {\\n            ans = min(ans, ad.second);\\n            if(!vis[ad.first]) dfs(ad.first, adj, vis, ans);\\n        }\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n + 1];\\n        for(auto e : roads) adj[e[0]].push_back({e[1], e[2]}), adj[e[1]].push_back({e[0], e[2]});\\n        \\n        int ans = 1e9;\\n        vector<int> vis(n + 1);\\n        dfs(n, adj, vis, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327145,
                "title": "easy-java-solution-using-bfs-and-dfs",
                "content": "# Approach\\n\\n1. Make a adjacency list to store the nodes and the weight of path.\\n2. Perform the basic bfs and dfs and update the ans to the minimum weight of path\\n\\n\\n# Complexity\\n- **Time complexity:  O(N+E)**\\n\\n- **Space complexity: O(N+E)**\\n# DFS approach\\n```\\nclass Solution {\\n\\n    private int ans = Integer.MAX_VALUE;\\n\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, List<List<Integer>>> graph = new HashMap<>();\\n\\n        for(int[] it : roads){\\n            graph.computeIfAbsent(it[0], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[1],it[2]));\\n\\n            graph.computeIfAbsent(it[1], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[0],it[2]));\\n        }\\n\\n        boolean[] visited = new boolean[n+1];\\n\\n        dfs(1, graph, visited);\\n\\n        return ans;\\n\\n    }\\n\\n    private void dfs(int i,HashMap<Integer, List<List<Integer>>> graph, boolean[] visited){\\n\\n        visited[i] = true;\\n\\n        if(!graph.containsKey(i)){\\n            return ;\\n        }\\n\\n        for(List<Integer> it : graph.get(i)){\\n            ans = Math.min(ans,it.get(1));\\n\\n            if(!visited[it.get(0)]){\\n                dfs(it.get(0), graph, visited);\\n            }\\n        }\\n    }\\n\\n}\\n```\\n# BFS approach \\n```\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, List<List<Integer>>> graph = new HashMap<>();\\n\\n        for(int[] it : roads){\\n            graph.computeIfAbsent(it[0], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[1],it[2]));\\n            graph.computeIfAbsent(it[1], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[0],it[2]));\\n        }\\n\\n        return bfs(n,graph);\\n    }\\n\\n    private int bfs(int n,HashMap<Integer, List<List<Integer>>> graph){\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        boolean[] visited = new boolean[n+1];\\n\\n        visited[1] = true;\\n        q.offer(1);\\n        int ans = Integer.MAX_VALUE;\\n\\n        while(!q.isEmpty()){\\n            int x = q.poll();\\n\\n            if(!graph.containsKey(x)){\\n                continue;\\n            }\\n\\n            for(List<Integer> it : graph.get(x)){\\n                ans = Math.min(ans, it.get(1));\\n                if(!visited[it.get(0)]){\\n                    visited[it.get(0)] = true;\\n\\n                    q.offer(it.get(0));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int ans = Integer.MAX_VALUE;\\n\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, List<List<Integer>>> graph = new HashMap<>();\\n\\n        for(int[] it : roads){\\n            graph.computeIfAbsent(it[0], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[1],it[2]));\\n\\n            graph.computeIfAbsent(it[1], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[0],it[2]));\\n        }\\n\\n        boolean[] visited = new boolean[n+1];\\n\\n        dfs(1, graph, visited);\\n\\n        return ans;\\n\\n    }\\n\\n    private void dfs(int i,HashMap<Integer, List<List<Integer>>> graph, boolean[] visited){\\n\\n        visited[i] = true;\\n\\n        if(!graph.containsKey(i)){\\n            return ;\\n        }\\n\\n        for(List<Integer> it : graph.get(i)){\\n            ans = Math.min(ans,it.get(1));\\n\\n            if(!visited[it.get(0)]){\\n                dfs(it.get(0), graph, visited);\\n            }\\n        }\\n    }\\n\\n}\\n```\n```\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, List<List<Integer>>> graph = new HashMap<>();\\n\\n        for(int[] it : roads){\\n            graph.computeIfAbsent(it[0], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[1],it[2]));\\n            graph.computeIfAbsent(it[1], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[0],it[2]));\\n        }\\n\\n        return bfs(n,graph);\\n    }\\n\\n    private int bfs(int n,HashMap<Integer, List<List<Integer>>> graph){\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        boolean[] visited = new boolean[n+1];\\n\\n        visited[1] = true;\\n        q.offer(1);\\n        int ans = Integer.MAX_VALUE;\\n\\n        while(!q.isEmpty()){\\n            int x = q.poll();\\n\\n            if(!graph.containsKey(x)){\\n                continue;\\n            }\\n\\n            for(List<Integer> it : graph.get(x)){\\n                ans = Math.min(ans, it.get(1));\\n                if(!visited[it.get(0)]){\\n                    visited[it.get(0)] = true;\\n\\n                    q.offer(it.get(0));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327119,
                "title": "python-solution-using-hash-map-and-union-find-beats-100",
                "content": "# Approach\\n1. Implement Union Find functions\\n2. Join each road via Union Find\\n4. Each time we connect cities via the union() function we check which is the lowest value between the current road and lowest value in the 2 groups the cities belong to.\\n5. We then assign this lowest value to the root node in the hash map.\\n\\nWe are essentially using the root node of each each city as the key in the hashmap - we know that if we call the find() function we can get the root node of the city. By continually assigning the lowest value to the root node in the hash map we can find our answer in the root node of 1 in the hash map (hash[find(1)])\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minScore(self, n, roads):\\n\\n        p = list(range(n + 1))\\n        hash = {}\\n\\n        def find(x):\\n            if x != p[x]:\\n                p[x] = find(p[x])\\n            return p[x]\\n\\n        def union(x, y, val):\\n            px = find(x)\\n            py = find(y)\\n\\n            a = hash[px] if px in hash else val\\n            b = hash[py] if py in hash else val\\n            hash[px] = min(val, a, b)\\n\\n            if px != py:\\n                p[py] = px\\n\\n        for x, y, val in roads:\\n            union(x, y, val)\\n\\n        return hash[find(1)]\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass Solution(object):\\n    def minScore(self, n, roads):\\n\\n        p = list(range(n + 1))\\n        hash = {}\\n\\n        def find(x):\\n            if x != p[x]:\\n                p[x] = find(p[x])\\n            return p[x]\\n\\n        def union(x, y, val):\\n            px = find(x)\\n            py = find(y)\\n\\n            a = hash[px] if px in hash else val\\n            b = hash[py] if py in hash else val\\n            hash[px] = min(val, a, b)\\n\\n            if px != py:\\n                p[py] = px\\n\\n        for x, y, val in roads:\\n            union(x, y, val)\\n\\n        return hash[find(1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326985,
                "title": "simple-bfs-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dj(vector<pair<int,int>>g[], int n){\\n        int ans = INT_MAX;\\n        queue<int>q;\\n        q.push(1);\\n        vector<int>visited(n+1,0);\\n        visited[1] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto i:g[node]){\\n                ans = min(ans,i.second);\\n                if(!visited[i.first]){\\n                    visited[i.first] = 1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>g[n+1];\\n        int m = roads.size();\\n        for(int i=0; i<m; i++){\\n            int u = roads[i][0], v = roads[i][1], cost = roads[i][2];\\n            g[u].push_back({v,cost});\\n            g[v].push_back({u,cost});\\n        }\\n        return dj(g,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dj(vector<pair<int,int>>g[], int n){\\n        int ans = INT_MAX;\\n        queue<int>q;\\n        q.push(1);\\n        vector<int>visited(n+1,0);\\n        visited[1] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto i:g[node]){\\n                ans = min(ans,i.second);\\n                if(!visited[i.first]){\\n                    visited[i.first] = 1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>g[n+1];\\n        int m = roads.size();\\n        for(int i=0; i<m; i++){\\n            int u = roads[i][0], v = roads[i][1], cost = roads[i][2];\\n            g[u].push_back({v,cost});\\n            g[v].push_back({u,cost});\\n        }\\n        return dj(g,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326962,
                "title": "c-using-bfs-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem states that we need to find minimum distance of a road while travelling from road 1 to road n. Note that we can travel the same road multiple times.\\n\\n  ![image.png](https://assets.leetcode.com/users/images/b421786d-c2d1-4ae6-81a2-1c4acee04835_1679456030.3175228.png)\\n\\nSee in the above example, we are visiting the path from 1 to 2 twice. The minimum score is 2.\\n```\\n  1->2->1->3->4 \\n```\\n\\n# Approach\\n### 1. DFS\\nThe DFS algorithm starts from the first road and explores its neighboring roads. For each neighboring road, update the minimum distance if it is smaller than the current minimum distance. Also mark the neighboring road as visited to avoid visiting it again. Then recursively explore the neighboring roads of the neighboring roads until it reaches the last road. Finally, return the minimum distance found along the path from the first road to the last road.\\n\\n### 2. BFS\\nWe are using a queue to implement a BFS. Start with the first node and marks it as visited. Then, traverse all the neighboring nodes of the current node and mark them as visited, adding them to the queue to be processed later. At each step, the update the minimum distance it has seen so far. Continue until all nodes have been explored. Finally, return the minimum distance.\\n\\nWe use a 2D vector to represent the graph, where each entry represents a node and its neighboring nodes, along with the distance between them. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(n + m)**, where n is the number of cities and m is the number of roads connecting them. In the worst case, all the nodes and edges of the graph will be traversed, and hence, the time complexity is O(n + m).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  **O(n+m)**, where n is the number of cities and m is the number of roads connecting them.\\n\\n# Code\\n### 1. Using DFS\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<pair<int,int>>>& adj, vector<bool>& visit, int n, int i,int& ans){\\n        visit[i]=true; // mark city i visited\\n        for(int j=0;j<adj[i].size();++j){\\n            int b=adj[i][j].first, d=adj[i][j].second;\\n            ans=min(ans,d);\\n            if(!visit[b]) dfs(adj,visit,n,b,ans); // if city b is not visited then call dfs\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> adj(n+1); // adjacency matrix\\n        for(auto& r:roads){\\n            int a=r[0], b=r[1], d=r[2]; // first city, second city, distance\\n            adj[a].push_back({b,d}); \\n            adj[b].push_back({a,d});\\n        }\\n        int ans=INT_MAX;\\n        vector<bool>visit(n+1,false);\\n        dfs(adj,visit,n,1,ans);\\n        return ans;\\n    }\\n};\\n```\\n### 2. Using BFS\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>adj(n+1); // adjacency matrix\\n        vector<int>vis(n+1,false); // vector to mark nodes visited \\n        queue<int>q;\\n        int ans=INT_MAX;\\n        for(auto& r: roads){\\n            int a=r[0],b=r[1],d=r[2]; // first city, second city, distance\\n            adj[a].push_back({b,d});\\n            adj[b].push_back({a,d});\\n        }\\n\\n        q.push(1); // push the 1st city and mark it visited\\n        vis[1]=true;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            // loop to push the nodes connected to current node in the queue (if not visited)\\n            for(auto& r: adj[node]){\\n                ans=min(ans,r.second);\\n                if(!vis[r.first]) {\\n                    q.push(r.first);\\n                    vis[r.first]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n  1->2->1->3->4 \\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<pair<int,int>>>& adj, vector<bool>& visit, int n, int i,int& ans){\\n        visit[i]=true; // mark city i visited\\n        for(int j=0;j<adj[i].size();++j){\\n            int b=adj[i][j].first, d=adj[i][j].second;\\n            ans=min(ans,d);\\n            if(!visit[b]) dfs(adj,visit,n,b,ans); // if city b is not visited then call dfs\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> adj(n+1); // adjacency matrix\\n        for(auto& r:roads){\\n            int a=r[0], b=r[1], d=r[2]; // first city, second city, distance\\n            adj[a].push_back({b,d}); \\n            adj[b].push_back({a,d});\\n        }\\n        int ans=INT_MAX;\\n        vector<bool>visit(n+1,false);\\n        dfs(adj,visit,n,1,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>adj(n+1); // adjacency matrix\\n        vector<int>vis(n+1,false); // vector to mark nodes visited \\n        queue<int>q;\\n        int ans=INT_MAX;\\n        for(auto& r: roads){\\n            int a=r[0],b=r[1],d=r[2]; // first city, second city, distance\\n            adj[a].push_back({b,d});\\n            adj[b].push_back({a,d});\\n        }\\n\\n        q.push(1); // push the 1st city and mark it visited\\n        vis[1]=true;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            // loop to push the nodes connected to current node in the queue (if not visited)\\n            for(auto& r: adj[node]){\\n                ans=min(ans,r.second);\\n                if(!vis[r.first]) {\\n                    q.push(r.first);\\n                    vis[r.first]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326909,
                "title": "easy-c-dfs-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust finding All nodes that can be visited when starting from 1st node then finding minimum of path among them.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& x,vector<int>& vis,int i){\\n        vis[i]=1;\\n        for(int j=0;j<x[i].size();j++) if(!vis[x[i][j]]) dfs(x,vis,x[i][j]);\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>> x(n);\\n        int m=roads.size(),mn=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            x[roads[i][0]-1].push_back(roads[i][1]-1);\\n            x[roads[i][1]-1].push_back(roads[i][0]-1);\\n        }\\n        vector<int> vis(n,0);\\n        dfs(x,vis,0);\\n        for(int i=0;i<m;i++) if(vis[roads[i][0]-1]) mn=min(mn,roads[i][2]);\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& x,vector<int>& vis,int i){\\n        vis[i]=1;\\n        for(int j=0;j<x[i].size();j++) if(!vis[x[i][j]]) dfs(x,vis,x[i][j]);\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>> x(n);\\n        int m=roads.size(),mn=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            x[roads[i][0]-1].push_back(roads[i][1]-1);\\n            x[roads[i][1]-1].push_back(roads[i][0]-1);\\n        }\\n        vector<int> vis(n,0);\\n        dfs(x,vis,0);\\n        for(int i=0;i<m;i++) if(vis[roads[i][0]-1]) mn=min(mn,roads[i][2]);\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326695,
                "title": "swift-union-find",
                "content": "**Union Find (accepted answer)**\\n```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var groups = Array(0...n)\\n        var minCosts = Array(repeating: Int.max, count: n+1)\\n        \\n        func find(_ x: Int) -> Int {\\n            if x != groups[x] { \\n                groups[x] = find(groups[x]) // path compression, if needed\\n            }  \\n            return groups[x]\\n        }\\n                        \\n        for road in roads {\\n            let (x,y) = (find(road[0]), find(road[1]))\\n            let (minXY, maxXY) = (min(x,y), max(x,y))\\n            groups[maxXY] = minXY\\n            minCosts[minXY] = min(minCosts[x], minCosts[y], road[2])\\n        }\\n        \\n        return minCosts[find(1)]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var groups = Array(0...n)\\n        var minCosts = Array(repeating: Int.max, count: n+1)\\n        \\n        func find(_ x: Int) -> Int {\\n            if x != groups[x] { \\n                groups[x] = find(groups[x]) // path compression, if needed\\n            }  \\n            return groups[x]\\n        }\\n                        \\n        for road in roads {\\n            let (x,y) = (find(road[0]), find(road[1]))\\n            let (minXY, maxXY) = (min(x,y), max(x,y))\\n            groups[maxXY] = minXY\\n            minCosts[minXY] = min(minCosts[x], minCosts[y], road[2])\\n        }\\n        \\n        return minCosts[find(1)]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326601,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mini = INT_MAX;\\n    \\n    void dfs(int s, vector<bool>&vis, vector<pair<int, int>>adj[]) {\\n        vis[s] = true;\\n        \\n        for(auto &it : adj[s]) {\\n            int v = it.first, wt = it.second;\\n            mini = min(mini, wt);\\n            if(!vis[v])\\n                dfs(v, vis, adj);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector< pair<int, int> > adj[n+1];\\n        for(auto &it : roads) {\\n            int u = it[0], v = it[1], wt = it[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n        \\n        vector<bool>vis(n+1, false);\\n        dfs(1, vis, adj);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini = INT_MAX;\\n    \\n    void dfs(int s, vector<bool>&vis, vector<pair<int, int>>adj[]) {\\n        vis[s] = true;\\n        \\n        for(auto &it : adj[s]) {\\n            int v = it.first, wt = it.second;\\n            mini = min(mini, wt);\\n            if(!vis[v])\\n                dfs(v, vis, adj);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector< pair<int, int> > adj[n+1];\\n        for(auto &it : roads) {\\n            int u = it[0], v = it[1], wt = it[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n        \\n        vector<bool>vis(n+1, false);\\n        dfs(1, vis, adj);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326589,
                "title": "daily-leetcoding-challenge-march-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3254927,
                "title": "c-dfs-graph",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<bool> &v,int &ans,vector<vector<vector<int>>> &g){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            ans = min(ans,i[1]);\\n            dfs(i[0],v,ans,g);\\n        }\\n    }\\n        int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(int i = 0; i < roads.size(); i++){\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<bool>  v(n+1,false);\\n        dfs(1,v,ans,g);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<bool> &v,int &ans,vector<vector<vector<int>>> &g){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            ans = min(ans,i[1]);\\n            dfs(i[0],v,ans,g);\\n        }\\n    }\\n        int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(int i = 0; i < roads.size(); i++){\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<bool>  v(n+1,false);\\n        dfs(1,v,ans,g);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177210,
                "title": "golang-bfs",
                "content": "# Code\\n```\\ntype pair struct {\\n    first int\\n    second int\\n}\\n\\nfunc minScore(n int, roads [][]int) int {\\n    adjList := make([][]pair, n + 1)\\n    for _, edge := range roads {\\n        adjList[edge[0]] = append(adjList[edge[0]], pair{edge[1], edge[2]})\\n        adjList[edge[1]] = append(adjList[edge[1]], pair{edge[0], edge[2]})\\n    }\\n    visited := make([]bool, n + 1)\\n    Queue := []int{1}\\n    var ans int = math.MaxInt\\n    for len(Queue) > 0 {\\n        var sz int = len(Queue)\\n        for i := 0; i < sz; i++ {\\n            var curr int = Queue[0]\\n            Queue = Queue[1:]\\n            for _, edge := range adjList[curr] {\\n                if edge.second < ans {\\n                    ans = edge.second\\n                }\\n                if !visited[edge.first] {\\n                    Queue = append(Queue, edge.first)\\n                    visited[edge.first] = true\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ntype pair struct {\\n    first int\\n    second int\\n}\\n\\nfunc minScore(n int, roads [][]int) int {\\n    adjList := make([][]pair, n + 1)\\n    for _, edge := range roads {\\n        adjList[edge[0]] = append(adjList[edge[0]], pair{edge[1], edge[2]})\\n        adjList[edge[1]] = append(adjList[edge[1]], pair{edge[0], edge[2]})\\n    }\\n    visited := make([]bool, n + 1)\\n    Queue := []int{1}\\n    var ans int = math.MaxInt\\n    for len(Queue) > 0 {\\n        var sz int = len(Queue)\\n        for i := 0; i < sz; i++ {\\n            var curr int = Queue[0]\\n            Queue = Queue[1:]\\n            for _, edge := range adjList[curr] {\\n                if edge.second < ans {\\n                    ans = edge.second\\n                }\\n                if !visited[edge.first] {\\n                    Queue = append(Queue, edge.first)\\n                    visited[edge.first] = true\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950397,
                "title": "java-pair-bfs",
                "content": "```\\nclass Solution {\\n    public class Pair{\\n        int sc;\\n        int d;\\n        Pair(int sc,int d){\\n            this.sc=sc;\\n            this.d=d;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<Pair>[]arr=new ArrayList[n+1];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=new ArrayList<>();\\n        }\\n        for(int []e:roads){\\n            arr[e[0]].add(new Pair(e[1],e[2]));\\n            arr[e[1]].add(new Pair(e[0],e[2]));\\n        }\\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(1,(int)1e9));\\n        boolean []vis=new boolean[n+1];\\n        int ans=(int)1e9;\\n        while(q.size()>0){\\n            Pair p=q.remove();\\n            vis[p.sc]=true;\\n            ans=Math.min(ans,p.d);\\n            \\n            for(Pair rem:arr[p.sc]){\\n               if(vis[rem.sc]==false){\\n                    q.add(rem);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public class Pair{\\n        int sc;\\n        int d;\\n        Pair(int sc,int d){\\n            this.sc=sc;\\n            this.d=d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2931808,
                "title": "easiest-simple-c-dfs-bfs-solution-with-approach",
                "content": "### Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind minimum value of edge in connected component of one\\n\\n## DFS Code\\n```\\nclass Solution {\\npublic:\\n    int mini=INT_MAX;\\n    void dfs(int node, vector<pair<int,int>> adj[], vector<int>& vis){\\n        if (vis[node])return;\\n        vis[node]=1;\\n        for (auto val:adj[node]){\\n            mini= min(mini,val.second);\\n            dfs(val.first,adj,vis);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for (auto rowvect: roads){\\n            adj[rowvect[0]].push_back({rowvect[1],rowvect[2]});\\n            adj[rowvect[1]].push_back({rowvect[0],rowvect[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        dfs(1,adj,vis);\\n        return mini;\\n    }\\n};\\n```\\n\\n## BFS Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for (auto rowvect: roads){\\n            adj[rowvect[0]].push_back({rowvect[1],rowvect[2]});\\n            adj[rowvect[1]].push_back({rowvect[0],rowvect[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        int mini= INT_MAX;\\n        queue<pair<int,int>> q; // node weight\\n        q.push({1,INT_MAX}); \\n        while (!q.empty()){\\n            mini= min(mini,q.front().second);\\n            vis[q.front().first]=1;\\n            for (auto val: adj[q.front().first]){\\n                if (!vis[val.first]){\\n                    q.push({val.first,val.second});\\n                }\\n            }\\n            q.pop();\\n        }\\n\\n        return mini;\\n    }\\n};\\n```\\n> *Upvote if you like :)*\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini=INT_MAX;\\n    void dfs(int node, vector<pair<int,int>> adj[], vector<int>& vis){\\n        if (vis[node])return;\\n        vis[node]=1;\\n        for (auto val:adj[node]){\\n            mini= min(mini,val.second);\\n            dfs(val.first,adj,vis);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for (auto rowvect: roads){\\n            adj[rowvect[0]].push_back({rowvect[1],rowvect[2]});\\n            adj[rowvect[1]].push_back({rowvect[0],rowvect[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        dfs(1,adj,vis);\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for (auto rowvect: roads){\\n            adj[rowvect[0]].push_back({rowvect[1],rowvect[2]});\\n            adj[rowvect[1]].push_back({rowvect[0],rowvect[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        int mini= INT_MAX;\\n        queue<pair<int,int>> q; // node weight\\n        q.push({1,INT_MAX}); \\n        while (!q.empty()){\\n            mini= min(mini,q.front().second);\\n            vis[q.front().first]=1;\\n            for (auto val: adj[q.front().first]){\\n                if (!vis[val.first]){\\n                    q.push({val.first,val.second});\\n                }\\n            }\\n            q.pop();\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886109,
                "title": "dfs-simple-dfs",
                "content": "# Intuition\\nVisit All Node find minimum distance only so That => we use DFS\\n\\n# Approach\\nNormal DFS Call With Maintain visit Node only\\n\\n# Complexity\\n- Time complexity:\\n  o(V+2E)   v=>vertex E=>edages\\n\\n- Space complexity:\\n  o(V+2E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //SImle DFS\\n    int mi=INT_MAX; //global declared variable for store minimum     value of distance\\n    vector<pair<int,int>> graph[100001];//graph formate (Feel)=> arry[100001] => vector<>=> pair<int,int> => {Node,distance} \\n    int visit[100001]; //maintain visit Node\\n\\n    //DFS Function :  \\n    void dfs(int vertex){ // vertex=> Node => parent \\n         \\n         if(visit[vertex])return; // if Node is visited then return\\n\\n         visit[vertex]=1; //mark Node as visited\\n         \\n         //take child of vertex from graph\\n         for(auto child : graph[vertex]){\\n\\n             int child_Node=child.first;   //child_Node of vertex\\n             int child_dist=child.second;  // distance between vertex and child_NOde Node\\n             mi=min(mi,child_dist);        //update minimum value of wt/distance between two Node \\n             \\n             //pass child_Node for find its next childs;\\n             dfs(child_Node);\\n         }\\n\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //roads 2d array covert into graph\\n      \\n        int sz=roads.size();        // size of road 2d array \\n        //graph declaration\\n        for(int i=0;i<sz;i++){\\n            int Node1=roads[i][0];\\n            int Node2=roads[i][1];\\n            int distance=roads[i][2];\\n            //for bi-directional\\n            graph[Node1].push_back({Node2,distance});\\n            graph[Node2].push_back({Node1,distance});\\n\\n        }\\n  \\n        dfs(1); //call DFS=>\\n\\n        return mi; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //SImle DFS\\n    int mi=INT_MAX; //global declared variable for store minimum     value of distance\\n    vector<pair<int,int>> graph[100001];//graph formate (Feel)=> arry[100001] => vector<>=> pair<int,int> => {Node,distance} \\n    int visit[100001]; //maintain visit Node\\n\\n    //DFS Function :  \\n    void dfs(int vertex){ // vertex=> Node => parent \\n         \\n         if(visit[vertex])return; // if Node is visited then return\\n\\n         visit[vertex]=1; //mark Node as visited\\n         \\n         //take child of vertex from graph\\n         for(auto child : graph[vertex]){\\n\\n             int child_Node=child.first;   //child_Node of vertex\\n             int child_dist=child.second;  // distance between vertex and child_NOde Node\\n             mi=min(mi,child_dist);        //update minimum value of wt/distance between two Node \\n             \\n             //pass child_Node for find its next childs;\\n             dfs(child_Node);\\n         }\\n\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //roads 2d array covert into graph\\n      \\n        int sz=roads.size();        // size of road 2d array \\n        //graph declaration\\n        for(int i=0;i<sz;i++){\\n            int Node1=roads[i][0];\\n            int Node2=roads[i][1];\\n            int distance=roads[i][2];\\n            //for bi-directional\\n            graph[Node1].push_back({Node2,distance});\\n            graph[Node2].push_back({Node1,distance});\\n\\n        }\\n  \\n        dfs(1); //call DFS=>\\n\\n        return mi; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879531,
                "title": "javascript-graph-dfs",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function(n, roads) {\\n    const adj = new Map();\\n    \\n    for (const [u, v, d] of roads) {\\n        if (adj.has(u)) {\\n            const arr = adj.get(u);\\n            arr.push([v, d]);\\n            adj.set(u, arr);\\n        } else {\\n            adj.set(u, [[v, d]]);\\n        }\\n        \\n        if (adj.has(v)) {\\n            const arr = adj.get(v);\\n            arr.push([u, d]);\\n            adj.set(v, arr);\\n        } else {\\n            adj.set(v, [[u, d]]);\\n        }\\n    }\\n    \\n    let ans = Infinity;\\n    const visited = new Set();\\n    \\n    function dfs(node) {\\n        visited.add(node);\\n        \\n        for (const [nei, dis] of adj.get(node)) {\\n            ans = Math.min(ans, dis);\\n            \\n            if (visited.has(nei)) {\\n                continue;\\n            }\\n            \\n            dfs(nei);\\n        }\\n    }\\n    \\n    dfs(1);\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function(n, roads) {\\n    const adj = new Map();\\n    \\n    for (const [u, v, d] of roads) {\\n        if (adj.has(u)) {\\n            const arr = adj.get(u);\\n            arr.push([v, d]);\\n            adj.set(u, arr);\\n        } else {\\n            adj.set(u, [[v, d]]);\\n        }\\n        \\n        if (adj.has(v)) {\\n            const arr = adj.get(v);\\n            arr.push([u, d]);\\n            adj.set(v, arr);\\n        } else {\\n            adj.set(v, [[u, d]]);\\n        }\\n    }\\n    \\n    let ans = Infinity;\\n    const visited = new Set();\\n    \\n    function dfs(node) {\\n        visited.add(node);\\n        \\n        for (const [nei, dis] of adj.get(node)) {\\n            ans = Math.min(ans, dis);\\n            \\n            if (visited.has(nei)) {\\n                continue;\\n            }\\n            \\n            dfs(nei);\\n        }\\n    }\\n    \\n    dfs(1);\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877493,
                "title": "find-the-min-road",
                "content": "# Intuition\\nAs the path can contain same road multiple times, and the score is calculated by the min road.\\nThe optimal path will always contian the minimum distance road which can be travelled if start from city `1`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Depth-First Search from city `1` we can get the road with minimum distance.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<pair<int, int>>>& graph, vector<bool>& visited, int d, int u) {\\n        visited[u] = true;\\n        for(pair<int, int>& road: graph[u]) {\\n            d = min(d, road.second);\\n            if(!visited[road.first])\\n                d = dfs(graph, visited, d, road.first);\\n        }\\n        return d;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(vector<int>& road: roads) {\\n            graph[road[0] - 1].push_back({road[1] - 1, road[2]});\\n            graph[road[1] - 1].push_back({road[0] - 1, road[2]});\\n        }\\n        vector<bool> visited(n, false);\\n        return dfs(graph, visited, 1e9, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<pair<int, int>>>& graph, vector<bool>& visited, int d, int u) {\\n        visited[u] = true;\\n        for(pair<int, int>& road: graph[u]) {\\n            d = min(d, road.second);\\n            if(!visited[road.first])\\n                d = dfs(graph, visited, d, road.first);\\n        }\\n        return d;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(vector<int>& road: roads) {\\n            graph[road[0] - 1].push_back({road[1] - 1, road[2]});\\n            graph[road[1] - 1].push_back({road[0] - 1, road[2]});\\n        }\\n        vector<bool> visited(n, false);\\n        return dfs(graph, visited, 1e9, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876418,
                "title": "javascript-disjoint-set-union",
                "content": "```\\nclass DisjointSetUnion {\\n    constructor(n) {\\n        this.parent = new Array(n + 1).fill().map((_, index) => index);\\n        this.rank = new Array(n + 1).fill(0);\\n    }\\n\\n    find(num) {\\n        if(this.parent[num] === num) return num;\\n\\n        return this.parent[num] = this.find(this.parent[num]);\\n    }\\n\\n    union(source, target) {\\n        source = this.find(source);\\n        target = this.find(target);\\n\\n        if(this.rank[source] < this.rank[target]) {\\n            [source, target] = [target, source];\\n        }\\n\\n        this.parent[target] = source;\\n        this.rank[source] += 1;\\n    }\\n}\\n\\nvar minScore = function(n, roads) {\\n    const dsu = new DisjointSetUnion(n);\\n    for(const [source, target] of roads) {\\n        dsu.union(source, target);\\n    }\\n\\n    let minDistance = Infinity;\\n    const root = dsu.find(1);\\n    for(const [source, target, distance] of roads) {\\n        if(dsu.find(source) === root || dsu.find(target) === root) {\\n            minDistance = Math.min(minDistance, distance);\\n        }\\n    }\\n\\n    return minDistance;\\n};\\n```\\n\\nTime: O(n * log(n))\\nSpace: O(n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass DisjointSetUnion {\\n    constructor(n) {\\n        this.parent = new Array(n + 1).fill().map((_, index) => index);\\n        this.rank = new Array(n + 1).fill(0);\\n    }\\n\\n    find(num) {\\n        if(this.parent[num] === num) return num;\\n\\n        return this.parent[num] = this.find(this.parent[num]);\\n    }\\n\\n    union(source, target) {\\n        source = this.find(source);\\n        target = this.find(target);\\n\\n        if(this.rank[source] < this.rank[target]) {\\n            [source, target] = [target, source];\\n        }\\n\\n        this.parent[target] = source;\\n        this.rank[source] += 1;\\n    }\\n}\\n\\nvar minScore = function(n, roads) {\\n    const dsu = new DisjointSetUnion(n);\\n    for(const [source, target] of roads) {\\n        dsu.union(source, target);\\n    }\\n\\n    let minDistance = Infinity;\\n    const root = dsu.find(1);\\n    for(const [source, target, distance] of roads) {\\n        if(dsu.find(source) === root || dsu.find(target) === root) {\\n            minDistance = Math.min(minDistance, distance);\\n        }\\n    }\\n\\n    return minDistance;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875496,
                "title": "c-bfs-explanation",
                "content": "Initially we have to construct a graph(adjacency matrix) and vis(visited array).\\nWe contruct queue for BFS traversal.\\nThe logic behind this question is to traverse all the possible path from 1 and take the minimum weight of them. \\nTo tranver all possible path we use BFS algo.\\nIn our adjacency matrix the first element contain the connected node and second contain the weigth of connection.\\nSo to compute minimum we use i[1] (i.e g->(node)->(connected component)->weight) and we compute the result in res variable(i.e miniumum of all connected nodes).\\n\\nWe use visited array to not to tranverse on the same element more than once.\\nWe initially insert 1 in queue because we have to start from 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int res = 1e9+7;\\n    vector<bool> vis;\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(int i=0 ; i<roads.size() ; ++i) {\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vis.resize(n+1,false);\\n        queue<int> q;\\n        q.push(1);\\n        while(!q.empty()) {\\n            int k = q.front();\\n            q.pop();\\n            if(vis[k]) continue;\\n            vis[k]=1;\\n            for(auto i:g[k]) {\\n                res = min(res,i[1]);\\n                q.push(i[0]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 1e9+7;\\n    vector<bool> vis;\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(int i=0 ; i<roads.size() ; ++i) {\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vis.resize(n+1,false);\\n        queue<int> q;\\n        q.push(1);\\n        while(!q.empty()) {\\n            int k = q.front();\\n            q.pop();\\n            if(vis[k]) continue;\\n            vis[k]=1;\\n            for(auto i:g[k]) {\\n                res = min(res,i[1]);\\n                q.push(i[0]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875217,
                "title": "python-easy-logic-simple-bfs-with-min-tracking",
                "content": "**Upvote if it helped :)**\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adjMat = defaultdict(list)\\n        \\n        for x, y, w in roads:\\n            adjMat[x].append((y, w))\\n            adjMat[y].append((x, w))\\n        \\n        \\n        q = deque([1])\\n        res = inf\\n        visited = set()\\n        visited.add(1)\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            for nei, dist in adjMat[node]:\\n                res = min(res, dist)\\n                \\n                if nei not in visited:\\n                    visited.add(nei)    \\n                    q.append(nei)\\n                    \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adjMat = defaultdict(list)\\n        \\n        for x, y, w in roads:\\n            adjMat[x].append((y, w))\\n            adjMat[y].append((x, w))\\n        \\n        \\n        q = deque([1])\\n        res = inf\\n        visited = set()\\n        visited.add(1)\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            for nei, dist in adjMat[node]:\\n                res = min(res, dist)\\n                \\n                if nei not in visited:\\n                    visited.add(nei)    \\n                    q.append(nei)\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875163,
                "title": "simple-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust traverse the graph starting from 1 and keep a record of minimum distance \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V+E) where v is no of vertex and E is no of edges\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace of storing adjacency list\\nO(V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int,int>>adj[],vector<int>&vis,int &ans,int element){\\n        vis[element]=1;\\n        for(auto x:adj[element]){\\n            ans=min(ans,x.second);\\n            if(vis[x.first]==0){\\n               \\n                dfs(adj,vis,ans,x.first);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<int>vis(n+1,0);\\n        int ans=INT_MAX;\\n        dfs(adj,vis,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int,int>>adj[],vector<int>&vis,int &ans,int element){\\n        vis[element]=1;\\n        for(auto x:adj[element]){\\n            ans=min(ans,x.second);\\n            if(vis[x.first]==0){\\n               \\n                dfs(adj,vis,ans,x.first);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<int>vis(n+1,0);\\n        int ans=INT_MAX;\\n        dfs(adj,vis,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875159,
                "title": "python3-union-find",
                "content": "**Intuition**\\nWe can use union-find data structure to connect all the nodes connected by the roads, and update the root value to be the smallest among them. Eventually, we simply need to check if 0 and `n-1` is connected and return the root value if they do. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        parent = list(range(n))\\n        \\n        def find(p): \\n            \"\"\"Return the root of p.\"\"\"\\n            if p != parent[p]: parent[p] = find(parent[p])\\n            return parent[p]\\n        \\n        mp = defaultdict(lambda : inf)\\n        for u, v, dist in roads: \\n            uu = find(u-1)\\n            vv = find(v-1)\\n            parent[uu] = vv\\n            mp[uu] = mp[vv] = min(mp[uu], mp[vv], dist)\\n        return mp[find(0)] if find(0) == find(n-1) else -1\\n```\\n\\n**Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        parent = list(range(n))\\n        \\n        def find(p): \\n            \"\"\"Return the root of p.\"\"\"\\n            if p != parent[p]: parent[p] = find(parent[p])\\n            return parent[p]\\n        \\n        mp = defaultdict(lambda : inf)\\n        for u, v, dist in roads: \\n            uu = find(u-1)\\n            vv = find(v-1)\\n            parent[uu] = vv\\n            mp[uu] = mp[vv] = min(mp[uu], mp[vv], dist)\\n        return mp[find(0)] if find(0) == find(n-1) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875150,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    int[] parent;\\n    int[] minDist;\\n    \\n    private int find(int x) {\\n        while (x != parent[x]) {\\n            int pa = parent[x];\\n            int ga = parent[pa];\\n            \\n            parent[x] = ga;\\n            x = pa;\\n            \\n        }    \\n        return x;\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n\\n        parent = new int[n + 1];\\n        minDist = new int[n + 1];\\n        Arrays.fill(minDist, Integer.MAX_VALUE);\\n        \\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n                \\n        for (int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            int w = road[2];\\n            \\n            // union u and v\\n            \\n            int pu = find(u);\\n            int pv = find(v);\\n            \\n            if (pu == pv) {\\n                minDist[pu] = Math.min(minDist[pu], w);\\n            } else {\\n                // union pu\\n                parent[pv] = pu;\\n                minDist[pu] = Math.min(minDist[pu], minDist[pv]);\\n                minDist[pu] = Math.min(minDist[pu], w);\\n            }\\n            \\n        }\\n        \\n        int pn = find(n);\\n        return minDist[pn];\\n        \\n        // return -1;\\n    }\\n}\\n\\n// class Solution {\\n//     public int minScore(int n, int[][] roads) {\\n//         // dijkstra\\n//         Map<Integer, List<int[]>> graph = new HashMap<>();\\n        \\n//         for (int[] road : roads) {\\n//             int u = road[0];\\n//             int v = road[1];\\n//             int w = road[2];\\n            \\n//             graph.putIfAbsent(u, new ArrayList<>());\\n//             graph.putIfAbsent(v, new ArrayList<>());\\n            \\n//             graph.get(u).add(new int[]{v, w});\\n//             graph.get(v).add(new int[]{u, w});\\n//         }\\n        \\n//         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\\n//         Set<Integer> settled = new HashSet<>();\\n//         int[] dist = new int[n + 1];\\n//         Arrays.fill(dist, Integer.MAX_VALUE);\\n//         // settled.add(1);\\n        \\n        \\n//         pq.offer(new int[]{1, Integer.MAX_VALUE});\\n        \\n//         while (!pq.isEmpty()) {\\n//             int[] curr = pq.poll();\\n            \\n//             // if (curr[0] == n) return dist[n];\\n            \\n//             int u = curr[0];\\n//             int d = curr[1];\\n//             if (settled.contains(u)) continue;\\n            \\n//             System.out.println(\"u :\" + u);\\n//             for (int[] next : graph.get(u)) {\\n//                 int v = next[0];\\n//                 int w = next[1];\\n//                 // release\\n//                 int newD = Math.min(d, w);\\n//                 System.out.println(\"newD :\" + newD + \" v: \" + v);\\n//                 if (newD < dist[v]) {\\n                    \\n//                     dist[v] = newD;\\n//                     pq.offer(new int[]{v, newD});\\n//                 }\\n//             }\\n            \\n//             settled.add(u);\\n//         }\\n        \\n//         return dist[n];\\n        \\n//         // return -1;\\n//     }\\n// }\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    int[] minDist;\\n    \\n    private int find(int x) {\\n        while (x != parent[x]) {\\n            int pa = parent[x];\\n            int ga = parent[pa];\\n            \\n            parent[x] = ga;\\n            x = pa;\\n            \\n        }    \\n        return x;\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n\\n        parent = new int[n + 1];\\n        minDist = new int[n + 1];\\n        Arrays.fill(minDist, Integer.MAX_VALUE);\\n        \\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n                \\n        for (int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            int w = road[2];\\n            \\n            // union u and v\\n            \\n            int pu = find(u);\\n            int pv = find(v);\\n            \\n            if (pu == pv) {\\n                minDist[pu] = Math.min(minDist[pu], w);\\n            } else {\\n                // union pu\\n                parent[pv] = pu;\\n                minDist[pu] = Math.min(minDist[pu], minDist[pv]);\\n                minDist[pu] = Math.min(minDist[pu], w);\\n            }\\n            \\n        }\\n        \\n        int pn = find(n);\\n        return minDist[pn];\\n        \\n        // return -1;\\n    }\\n}\\n\\n// class Solution {\\n//     public int minScore(int n, int[][] roads) {\\n//         // dijkstra\\n//         Map<Integer, List<int[]>> graph = new HashMap<>();\\n        \\n//         for (int[] road : roads) {\\n//             int u = road[0];\\n//             int v = road[1];\\n//             int w = road[2];\\n            \\n//             graph.putIfAbsent(u, new ArrayList<>());\\n//             graph.putIfAbsent(v, new ArrayList<>());\\n            \\n//             graph.get(u).add(new int[]{v, w});\\n//             graph.get(v).add(new int[]{u, w});\\n//         }\\n        \\n//         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\\n//         Set<Integer> settled = new HashSet<>();\\n//         int[] dist = new int[n + 1];\\n//         Arrays.fill(dist, Integer.MAX_VALUE);\\n//         // settled.add(1);\\n        \\n        \\n//         pq.offer(new int[]{1, Integer.MAX_VALUE});\\n        \\n//         while (!pq.isEmpty()) {\\n//             int[] curr = pq.poll();\\n            \\n//             // if (curr[0] == n) return dist[n];\\n            \\n//             int u = curr[0];\\n//             int d = curr[1];\\n//             if (settled.contains(u)) continue;\\n            \\n//             System.out.println(\"u :\" + u);\\n//             for (int[] next : graph.get(u)) {\\n//                 int v = next[0];\\n//                 int w = next[1];\\n//                 // release\\n//                 int newD = Math.min(d, w);\\n//                 System.out.println(\"newD :\" + newD + \" v: \" + v);\\n//                 if (newD < dist[v]) {\\n                    \\n//                     dist[v] = newD;\\n//                     pq.offer(new int[]{v, newD});\\n//                 }\\n//             }\\n            \\n//             settled.add(u);\\n//         }\\n        \\n//         return dist[n];\\n        \\n//         // return -1;\\n//     }\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874999,
                "title": "c-easy",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: --> \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> visit;\\n    int ans=INT_MAX;\\n    void dfs(int node, vector<pair<int,int> > adj[]){\\n        visit[node]=1;\\n        for(auto val:adj[node]){\\n            if(visit[val.first]==0){\\n                dfs(val.first, adj);\\n            }\\n           ans = min(ans,val.second);    \\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<int,int> > adj[n+1];\\n        for(auto rd:roads){\\n            adj[rd[0]].push_back({rd[1],rd[2]});\\n            adj[rd[1]].push_back({rd[0],rd[2]});\\n            \\n        }\\n        visit.resize(n);\\n        dfs(1,adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> visit;\\n    int ans=INT_MAX;\\n    void dfs(int node, vector<pair<int,int> > adj[]){\\n        visit[node]=1;\\n        for(auto val:adj[node]){\\n            if(visit[val.first]==0){\\n                dfs(val.first, adj);\\n            }\\n           ans = min(ans,val.second);    \\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<int,int> > adj[n+1];\\n        for(auto rd:roads){\\n            adj[rd[0]].push_back({rd[1],rd[2]});\\n            adj[rd[1]].push_back({rd[0],rd[2]});\\n            \\n        }\\n        visit.resize(n);\\n        dfs(1,adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874939,
                "title": "c-bfs-easy-solution-with-explanation",
                "content": "## Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe only need to get the **minimum edge distance** which can be reached from vertex 1.\\n\\nHence, implement **BFS** start from vertex **1** and update the **minimum distnace**.\\n\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    // adj matrix by roads\\n    vector<pair<int, int>> adj[100001];\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // build adj matrix\\n        for (const auto &i : roads) {\\n            adj[i[0]].emplace_back(make_pair(i[1], i[2]));\\n            adj[i[1]].emplace_back(make_pair(i[0], i[2]));\\n        }\\n        vector<int> vis(n + 1, 0);\\n        queue<int> q;\\n        q.emplace(1);\\n        int ans = INT_MAX;\\n        for (; !q.empty(); q.pop()) {\\n            int from = q.front();\\n            vis[from] = 1;\\n            for (const auto &[to, val] : adj[from]) {\\n                if (!vis[to]) {\\n                    ans = min(ans, val);\\n                    q.emplace(to);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Upvote** if you like this post : )\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // adj matrix by roads\\n    vector<pair<int, int>> adj[100001];\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // build adj matrix\\n        for (const auto &i : roads) {\\n            adj[i[0]].emplace_back(make_pair(i[1], i[2]));\\n            adj[i[1]].emplace_back(make_pair(i[0], i[2]));\\n        }\\n        vector<int> vis(n + 1, 0);\\n        queue<int> q;\\n        q.emplace(1);\\n        int ans = INT_MAX;\\n        for (; !q.empty(); q.pop()) {\\n            int from = q.front();\\n            vis[from] = 1;\\n            for (const auto &[to, val] : adj[from]) {\\n                if (!vis[to]) {\\n                    ans = min(ans, val);\\n                    q.emplace(to);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652367,
                "title": "simple-disjoint-set-approach-with-intuition",
                "content": "# Intuition\\nThe intuition is simple, we want to reach from 1 to n, and the score is minimum of all the edge weights along the path.\\nSo if the graph is connected, then the min score = min(all edge weights), because we can traverse any edge any number of times, there is no constraint on that.\\n\\nSo, if some city is not connected to our 1st city, then its edges weights cannot be considered for our ans. So we can use Disjoint Set to make all cities connected to 1 to have same ultimate parent as that of city 1. And then we can easily get min score from just those cities.\\n\\n\\n\\n# Code\\n```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent;\\n    vector<int> size;\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i = 0; i<n+1; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int findUparent(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUparent(parent[node]);\\n    }\\n    void unionBysize(int u, int v){\\n        int pu = findUparent(u);\\n        int pv = findUparent(v);\\n        if(pu==pv) return;\\n        if(size[pu]>size[pv]){\\n            parent[pv] = pu;\\n            size[pu]+=size[pv];\\n        }\\n        else{\\n            parent[pu] = pv;\\n            size[pv]+=size[pu];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //to store minimum edge weight from a city, so that we can\\n        //directly use it later\\n        vector<int> adj(n+1, INT_MAX);  \\n        int mn = INT_MAX;\\n        DisjointSet ds(n+1);\\n        \\n        for(auto it : roads){\\n            int u = it[0];\\n            int v = it[1];\\n            int dist = it[2];\\n            ds.unionBysize(u,v);\\n            adj[v] = min(adj[v],dist);\\n            adj[u] = min(adj[u],dist);\\n        }\\n\\n        int par = ds.findUparent(1);\\n\\n        for(int i = 1; i<=n; i++){\\n            //only considering cities which have \\n            //same parent as city 1\\n            if(ds.findUparent(i)==par){\\n                mn = min(mn, adj[i]);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent;\\n    vector<int> size;\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i = 0; i<n+1; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int findUparent(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUparent(parent[node]);\\n    }\\n    void unionBysize(int u, int v){\\n        int pu = findUparent(u);\\n        int pv = findUparent(v);\\n        if(pu==pv) return;\\n        if(size[pu]>size[pv]){\\n            parent[pv] = pu;\\n            size[pu]+=size[pv];\\n        }\\n        else{\\n            parent[pu] = pv;\\n            size[pv]+=size[pu];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //to store minimum edge weight from a city, so that we can\\n        //directly use it later\\n        vector<int> adj(n+1, INT_MAX);  \\n        int mn = INT_MAX;\\n        DisjointSet ds(n+1);\\n        \\n        for(auto it : roads){\\n            int u = it[0];\\n            int v = it[1];\\n            int dist = it[2];\\n            ds.unionBysize(u,v);\\n            adj[v] = min(adj[v],dist);\\n            adj[u] = min(adj[u],dist);\\n        }\\n\\n        int par = ds.findUparent(1);\\n\\n        for(int i = 1; i<=n; i++){\\n            //only considering cities which have \\n            //same parent as city 1\\n            if(ds.findUparent(i)==par){\\n                mn = min(mn, adj[i]);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549068,
                "title": "simplest-dfs-bihari-coder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOnly start dfs from Node 1. in question it is given that 1 and n are both connected. \\nwe will cover this connected compnonent only and we will choose min of all edge weight\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int node, vector<pair<int,int>> adj[],vector<int>& v,int &ans)\\n{\\n   v[node] =1; \\n   for(auto adjnode:adj[node])\\n   {\\n       ans = min(ans,adjnode.second);\\n       if(v[adjnode.first]==0)\\n       dfs(adjnode.first,adj,v,ans);\\n   }\\n}\\n \\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n                ios_base::sync_with_stdio(false);\\n        \\n        vector<pair<int,int>> adj[n+1];\\n        for(auto x:roads)\\n        {\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<int> v(n+1,0);\\n        dfs(1,adj,v,ans);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int node, vector<pair<int,int>> adj[],vector<int>& v,int &ans)\\n{\\n   v[node] =1; \\n   for(auto adjnode:adj[node])\\n   {\\n       ans = min(ans,adjnode.second);\\n       if(v[adjnode.first]==0)\\n       dfs(adjnode.first,adj,v,ans);\\n   }\\n}\\n \\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n                ios_base::sync_with_stdio(false);\\n        \\n        vector<pair<int,int>> adj[n+1];\\n        for(auto x:roads)\\n        {\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<int> v(n+1,0);\\n        dfs(1,adj,v,ans);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329898,
                "title": "c-solution-simple-bfs-union-find-explained-solution",
                "content": "# Intuition\\nBasically we need to find all the cities connected to city 1 and the minimum score will be the minimum path length among all the roads between those connected cities.\\n\\n# Approach\\nFirst we find all the cities connected to city 1 by using a starting a breadth first search from city 1. Whichever cities we are able to reach from 1 we mark them as true and insert it in a set. Finally we traverse the roads vector and check if the first city i.e (roads[i][0]) is present in the set or not. If it is we update our minimum score. Finally we return the minimum length stored in ans variable.\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minScore(int n, vector<vector<int>> &roads)\\n    {\\n        vector<bool> connnectedcities(n + 1, false);\\n        vector<vector<int>> adj(n + 1);\\n        for (int i = 0; i < roads.size(); i++)\\n        {\\n            int r1 = roads[i][0];\\n            int r2 = roads[i][1];\\n            adj[r1].push_back(r2);\\n            adj[r2].push_back(r1);\\n        }\\n        func(connnectedcities, adj, n);        \\n        set<int>st;\\n        for(int i = 0;i < connnectedcities.size(); i++)\\n        {\\n            if(connnectedcities[i])\\n            {\\n                st.insert(i);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0;i < roads.size(); i++)\\n        {\\n            if(st.find(roads[i][0]) != st.end())\\n            {\\n                ans = min(ans, roads[i][2]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void func(vector<bool> &connected, vector<vector<int>> &adj, int &n)\\n    {\\n        vector<int> vis(n + 1, 0);\\n        vis[1] = 1;\\n        queue<int> q;\\n        q.push(1);\\n        while (!q.empty())\\n        {\\n            int f = q.front();\\n            connected[f] = true;\\n            q.pop();\\n            for (int i = 0; i < adj[f].size(); i++)\\n            {\\n                if (vis[adj[f][i]] == 0)\\n                {\\n                    q.push(adj[f][i]);\\n                    vis[adj[f][i]] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n**Do upvote if you understood it !\\uD83D\\uDE00\\uD83D\\uDE00**",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minScore(int n, vector<vector<int>> &roads)\\n    {\\n        vector<bool> connnectedcities(n + 1, false);\\n        vector<vector<int>> adj(n + 1);\\n        for (int i = 0; i < roads.size(); i++)\\n        {\\n            int r1 = roads[i][0];\\n            int r2 = roads[i][1];\\n            adj[r1].push_back(r2);\\n            adj[r2].push_back(r1);\\n        }\\n        func(connnectedcities, adj, n);        \\n        set<int>st;\\n        for(int i = 0;i < connnectedcities.size(); i++)\\n        {\\n            if(connnectedcities[i])\\n            {\\n                st.insert(i);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0;i < roads.size(); i++)\\n        {\\n            if(st.find(roads[i][0]) != st.end())\\n            {\\n                ans = min(ans, roads[i][2]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void func(vector<bool> &connected, vector<vector<int>> &adj, int &n)\\n    {\\n        vector<int> vis(n + 1, 0);\\n        vis[1] = 1;\\n        queue<int> q;\\n        q.push(1);\\n        while (!q.empty())\\n        {\\n            int f = q.front();\\n            connected[f] = true;\\n            q.pop();\\n            for (int i = 0; i < adj[f].size(); i++)\\n            {\\n                if (vis[adj[f][i]] == 0)\\n                {\\n                    q.push(adj[f][i]);\\n                    vis[adj[f][i]] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329896,
                "title": "bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& r) {\\n        \\n        int ans = INT_MAX;\\n        vector<vector<pair<int,int>>> g(n+1);\\n        \\n        for(auto i: r)\\n        {\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        \\n        vector<bool> vis(n+1, false);\\n        queue<int> q;\\n        q.push(1);\\n        \\n        while(!q.empty())\\n        {\\n            int val = q.front(); \\n            vis[val] = true;\\n            q.pop();\\n            for(auto j: g[val])\\n            {\\n                int to = j.first;\\n                int dd = j.second;\\n                ans = min(ans,dd);\\n                \\n                if(!vis[to])\\n                {\\n                    q.push(to);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& r) {\\n        \\n        int ans = INT_MAX;\\n        vector<vector<pair<int,int>>> g(n+1);\\n        \\n        for(auto i: r)\\n        {\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        \\n        vector<bool> vis(n+1, false);\\n        queue<int> q;\\n        q.push(1);\\n        \\n        while(!q.empty())\\n        {\\n            int val = q.front(); \\n            vis[val] = true;\\n            q.pop();\\n            for(auto j: g[val])\\n            {\\n                int to = j.first;\\n                int dd = j.second;\\n                ans = min(ans,dd);\\n                \\n                if(!vis[to])\\n                {\\n                    q.push(to);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329837,
                "title": "python3-bfs-and-dfs-bfs-1767-ms-faster-than-69-80",
                "content": "**BFS** \\nhttps://leetcode.com/submissions/detail/920312295/\\nRuntime: **1767 ms, faster than 69.80%** of Python3 online submissions for Minimum Score of a Path Between Two Cities.  \\nMemory Usage: 71.3 MB, less than 53.02% of Python3 online submissions for Minimum Score of a Path Between Two Cities.  \\n**DFS**  \\nhttps://leetcode.com/submissions/detail/920318713/  \\nRuntime: **1921 ms, faster than 49.66%** of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\nMemory Usage: 72.3 MB, less than 48.32% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n```Python\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        return self.bfs(n, roads)\\n        # return self.dfs(n, roads)\\n    \\n    def bfs(self, n, roads):\\n        ms, q, visited, d = float(\\'inf\\'), [1], {1}, defaultdict(list) ## ms: mininum score\\n        for r in roads:\\n            d[r[0]].append(r[1:])\\n            d[r[1]].append([r[0], r[2]])\\n        while q: ## bfs queue\\n            q1 = []\\n            for c in q:\\n                for c1,dist in d[c]:\\n                    ms = min(ms, dist)\\n                    if c1 not in visited:\\n                        visited.add(c1)\\n                        q1.append(c1)\\n            q = q1\\n        return ms\\n    \\n    def dfs(self, n, roads):\\n        ms, q, visited, d = float(\\'inf\\'), [1], {1}, defaultdict(list) ## ms: mininum score\\n        for r in roads:\\n            d[r[0]].append(r[1:])\\n            d[r[1]].append([r[0], r[2]])\\n        while q: ## dfs queue\\n            c = q.pop()\\n            for c1,dist in d[c]:\\n                ms = min(ms, dist)\\n                if c1 not in visited:\\n                    visited.add(c1)\\n                    q.append(c1)\\n        return ms\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        return self.bfs(n, roads)\\n        # return self.dfs(n, roads)\\n    \\n    def bfs(self, n, roads):\\n        ms, q, visited, d = float(\\'inf\\'), [1], {1}, defaultdict(list) ## ms: mininum score\\n        for r in roads:\\n            d[r[0]].append(r[1:])\\n            d[r[1]].append([r[0], r[2]])\\n        while q: ## bfs queue\\n            q1 = []\\n            for c in q:\\n                for c1,dist in d[c]:\\n                    ms = min(ms, dist)\\n                    if c1 not in visited:\\n                        visited.add(c1)\\n                        q1.append(c1)\\n            q = q1\\n        return ms\\n    \\n    def dfs(self, n, roads):\\n        ms, q, visited, d = float(\\'inf\\'), [1], {1}, defaultdict(list) ## ms: mininum score\\n        for r in roads:\\n            d[r[0]].append(r[1:])\\n            d[r[1]].append([r[0], r[2]])\\n        while q: ## dfs queue\\n            c = q.pop()\\n            for c1,dist in d[c]:\\n                ms = min(ms, dist)\\n                if c1 not in visited:\\n                    visited.add(c1)\\n                    q.append(c1)\\n        return ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329755,
                "title": "java-dfs-bfs-dsu-union-find-solutions-clear-and-concise",
                "content": "# DFS Solution\\n```\\nclass Solution {\\n    HashMap<Integer, List<int[]>> adjList;\\n    boolean[] visited;\\n    int minScore;\\n\\n    public void dfs(int currCity){\\n        for(int city[]: adjList.get(currCity)){\\n            int childCity = city[0];\\n            int distance = city[1];\\n            minScore = Math.min(minScore, distance);\\n            if(visited[childCity]) continue;\\n            visited[childCity] = true;\\n            dfs(childCity);\\n        }\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n        minScore = Integer.MAX_VALUE;\\n        visited = new boolean[n + 1];\\n        adjList = new HashMap<>();\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            int distance = road[2];\\n            adjList.computeIfAbsent(city1, val -> new ArrayList<>()).add(new int[]{city2, distance});\\n            adjList.computeIfAbsent(city2, val -> new ArrayList<>()).add(new int[]{city1, distance});\\n        }\\n        dfs(1);\\n        return minScore;\\n    }\\n}\\n```\\n\\n# BFS Solution\\n```\\nclass Solution {\\n    public int bfs(HashMap<Integer, ArrayList<int[]>> adjList, int n){\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n + 1];\\n        int minScore = Integer.MAX_VALUE;\\n        q.offer(1);\\n        visited[1] = true;\\n        while(!q.isEmpty()){\\n            int currCity = q.poll();\\n            for(int[] city: adjList.get(currCity)){\\n                int childCity = city[0];\\n                int distance = city[1];\\n                minScore = Math.min(minScore, distance);\\n                if(visited[childCity]) continue;\\n                visited[childCity] = true;\\n                q.offer(childCity);\\n            }\\n        }\\n        return minScore;\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, ArrayList<int[]>> adjList = new HashMap<>();\\n\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            int distance = road[2];\\n            adjList.computeIfAbsent(city1, val -> new ArrayList<>()).add(new int[]{city2, distance});\\n            adjList.computeIfAbsent(city2, val -> new ArrayList<>()).add(new int[]{city1, distance});\\n        }\\n        return bfs(adjList, n);\\n    }\\n}\\n```\\n\\n# DSU Solution\\n```\\nclass DSU{\\n    int[] rank;\\n    int[] root;\\n\\n    public DSU(int size){\\n        rank = new int[size];\\n        root = new int[size];\\n        for(int i = 0; i < size; i++)\\n            root[i] = i;\\n    }\\n\\n    public int find(int x){\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n\\n    public void union(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX != rootY){\\n            if(rank[rootX] > rank[rootY])\\n                root[rootY] = rootX;\\n            else if(rank[rootY] > rank[rootX])\\n                root[rootX] = rootY;\\n            else{\\n                root[rootX] = rootY;\\n                rank[rootY]++;\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DSU dsu = new DSU(n + 1);\\n        int minScore = Integer.MAX_VALUE;\\n\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            dsu.union(city1, city2);\\n        }\\n        \\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int distance = road[2];\\n            if(dsu.find(1) == dsu.find(city1))\\n                minScore = Math.min(minScore, distance);\\n        }\\n        return minScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, List<int[]>> adjList;\\n    boolean[] visited;\\n    int minScore;\\n\\n    public void dfs(int currCity){\\n        for(int city[]: adjList.get(currCity)){\\n            int childCity = city[0];\\n            int distance = city[1];\\n            minScore = Math.min(minScore, distance);\\n            if(visited[childCity]) continue;\\n            visited[childCity] = true;\\n            dfs(childCity);\\n        }\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n        minScore = Integer.MAX_VALUE;\\n        visited = new boolean[n + 1];\\n        adjList = new HashMap<>();\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            int distance = road[2];\\n            adjList.computeIfAbsent(city1, val -> new ArrayList<>()).add(new int[]{city2, distance});\\n            adjList.computeIfAbsent(city2, val -> new ArrayList<>()).add(new int[]{city1, distance});\\n        }\\n        dfs(1);\\n        return minScore;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int bfs(HashMap<Integer, ArrayList<int[]>> adjList, int n){\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n + 1];\\n        int minScore = Integer.MAX_VALUE;\\n        q.offer(1);\\n        visited[1] = true;\\n        while(!q.isEmpty()){\\n            int currCity = q.poll();\\n            for(int[] city: adjList.get(currCity)){\\n                int childCity = city[0];\\n                int distance = city[1];\\n                minScore = Math.min(minScore, distance);\\n                if(visited[childCity]) continue;\\n                visited[childCity] = true;\\n                q.offer(childCity);\\n            }\\n        }\\n        return minScore;\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, ArrayList<int[]>> adjList = new HashMap<>();\\n\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            int distance = road[2];\\n            adjList.computeIfAbsent(city1, val -> new ArrayList<>()).add(new int[]{city2, distance});\\n            adjList.computeIfAbsent(city2, val -> new ArrayList<>()).add(new int[]{city1, distance});\\n        }\\n        return bfs(adjList, n);\\n    }\\n}\\n```\n```\\nclass DSU{\\n    int[] rank;\\n    int[] root;\\n\\n    public DSU(int size){\\n        rank = new int[size];\\n        root = new int[size];\\n        for(int i = 0; i < size; i++)\\n            root[i] = i;\\n    }\\n\\n    public int find(int x){\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n\\n    public void union(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX != rootY){\\n            if(rank[rootX] > rank[rootY])\\n                root[rootY] = rootX;\\n            else if(rank[rootY] > rank[rootX])\\n                root[rootX] = rootY;\\n            else{\\n                root[rootX] = rootY;\\n                rank[rootY]++;\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DSU dsu = new DSU(n + 1);\\n        int minScore = Integer.MAX_VALUE;\\n\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            dsu.union(city1, city2);\\n        }\\n        \\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int distance = road[2];\\n            if(dsu.find(1) == dsu.find(city1))\\n                minScore = Math.min(minScore, distance);\\n        }\\n        return minScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329669,
                "title": "kotlin-beats-100-two-approaches-bfs-and-union-find",
                "content": "# Approach\\nIntuition behind this is that we need to find the smallest distance we can that is achievable from node 1. That can be done by traversal, or a union find algo.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code - BFS traversal\\nlittle optimization was needed - when we find the distance 1, we can\\'t find more optimal value, so we can break the traversal and return early.\\n\\n```\\nclass Solution {\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        val q: Queue<Pair<Int, Int>> = LinkedList()\\n        q.add(1 to Int.MAX_VALUE)\\n        val visited = hashSetOf<Pair<Int, Int>>()\\n        visited.add(1 to Int.MAX_VALUE)\\n        val edges = parseEdgesFrom(roads)\\n        var minDist = Int.MAX_VALUE\\n\\n        while (q.isNotEmpty()) {\\n            val size = q.size\\n\\n            for (i in 0 until size) {\\n                val (curr, _) = q.poll()\\n\\n                for (edge in edges[curr] ?: arrayListOf()) {\\n                    if (visited.contains(edge)) continue\\n                    val (_, dist) = edge\\n                    if (dist == 1) return 1\\n                    minDist = minOf(minDist, dist)\\n                    visited.add(edge)\\n                    q.add(edge)\\n                }\\n            }\\n        }\\n\\n        return minDist\\n    }\\n\\n    private fun parseEdgesFrom(roads: Array<IntArray>): HashMap<Int, ArrayList<Pair<Int, Int>>> {\\n        val hashmap = hashMapOf<Int, ArrayList<Pair<Int, Int>>>()\\n        for ((from, to, dist) in roads) {\\n            hashmap.computeIfAbsent(from) { ArrayList() }.add(to to dist)\\n            hashmap.computeIfAbsent(to) { ArrayList() }.add(from to dist)\\n        }\\n\\n        return hashmap\\n    }\\n}\\n```\\n\\n# Code - Union find\\n```\\nclass Solution {\\n    private lateinit var parent: IntArray\\n    private lateinit var distances: IntArray\\n\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        parent = IntArray(n+1) { i -> i }\\n        distances = IntArray(n+1) { Int.MAX_VALUE }\\n\\n        for (edge in roads) {\\n            combine(edge)\\n        }\\n\\n        return distances[find(1)]\\n    }\\n\\n    private fun combine(edge: IntArray) {\\n        val (from, to, dist) = edge\\n        val fromGroup = find(from)\\n        val toGroup = find(to)\\n        parent[fromGroup] = toGroup\\n        distances[toGroup] = minOf(distances[fromGroup], dist, distances[toGroup])\\n    }\\n\\n    private fun find(node: Int): Int {\\n        if (node == parent[node]) return node\\n        return find(parent[node])\\n    }\\n}\\n```\\n\\n---\\n\\n\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        val q: Queue<Pair<Int, Int>> = LinkedList()\\n        q.add(1 to Int.MAX_VALUE)\\n        val visited = hashSetOf<Pair<Int, Int>>()\\n        visited.add(1 to Int.MAX_VALUE)\\n        val edges = parseEdgesFrom(roads)\\n        var minDist = Int.MAX_VALUE\\n\\n        while (q.isNotEmpty()) {\\n            val size = q.size\\n\\n            for (i in 0 until size) {\\n                val (curr, _) = q.poll()\\n\\n                for (edge in edges[curr] ?: arrayListOf()) {\\n                    if (visited.contains(edge)) continue\\n                    val (_, dist) = edge\\n                    if (dist == 1) return 1\\n                    minDist = minOf(minDist, dist)\\n                    visited.add(edge)\\n                    q.add(edge)\\n                }\\n            }\\n        }\\n\\n        return minDist\\n    }\\n\\n    private fun parseEdgesFrom(roads: Array<IntArray>): HashMap<Int, ArrayList<Pair<Int, Int>>> {\\n        val hashmap = hashMapOf<Int, ArrayList<Pair<Int, Int>>>()\\n        for ((from, to, dist) in roads) {\\n            hashmap.computeIfAbsent(from) { ArrayList() }.add(to to dist)\\n            hashmap.computeIfAbsent(to) { ArrayList() }.add(from to dist)\\n        }\\n\\n        return hashmap\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private lateinit var parent: IntArray\\n    private lateinit var distances: IntArray\\n\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        parent = IntArray(n+1) { i -> i }\\n        distances = IntArray(n+1) { Int.MAX_VALUE }\\n\\n        for (edge in roads) {\\n            combine(edge)\\n        }\\n\\n        return distances[find(1)]\\n    }\\n\\n    private fun combine(edge: IntArray) {\\n        val (from, to, dist) = edge\\n        val fromGroup = find(from)\\n        val toGroup = find(to)\\n        parent[fromGroup] = toGroup\\n        distances[toGroup] = minOf(distances[fromGroup], dist, distances[toGroup])\\n    }\\n\\n    private fun find(node: Int): Int {\\n        if (node == parent[node]) return node\\n        return find(parent[node])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329587,
                "title": "simple-c-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>> adj[n+1];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n\\n        // making a visited array for keep tracking of all the cities (we have visited or not)\\n        // n = number of cities\\n        vector<bool> vis(n+1,false);\\n        vis[1] = true;                                  // mark source node as a visited city\\n        \\n        // BFS\\n        queue<int> q;\\n        q.push(1);\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto &it : adj[node])\\n            {\\n                if(!vis[it[0]])\\n                {\\n                    vis[it[0]] = true;\\n                    q.push(it[0]);\\n                }\\n            }\\n        }\\n\\n\\n        // Computing minimum distance from city 1 to n\\n        int ans = INT_MAX;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            // minimum possible score out of all available paths\\n            // if src and dest both are visited cities then try to make this our ans\\n            if(vis[roads[i][0]] && vis[roads[i][1]])\\n            {\\n                ans = min(ans,roads[i][2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>> adj[n+1];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n\\n        // making a visited array for keep tracking of all the cities (we have visited or not)\\n        // n = number of cities\\n        vector<bool> vis(n+1,false);\\n        vis[1] = true;                                  // mark source node as a visited city\\n        \\n        // BFS\\n        queue<int> q;\\n        q.push(1);\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto &it : adj[node])\\n            {\\n                if(!vis[it[0]])\\n                {\\n                    vis[it[0]] = true;\\n                    q.push(it[0]);\\n                }\\n            }\\n        }\\n\\n\\n        // Computing minimum distance from city 1 to n\\n        int ans = INT_MAX;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            // minimum possible score out of all available paths\\n            // if src and dest both are visited cities then try to make this our ans\\n            if(vis[roads[i][0]] && vis[roads[i][1]])\\n            {\\n                ans = min(ans,roads[i][2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329523,
                "title": "java-simple-solution-using-dijkstra-s-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\n    public int dijkstra(Map<Integer, List<int[]>> adjMap, int n, int[] distance) {\\n        distance[1] = 10005;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        minHeap.add(new int[] {1,10005});\\n        while(!minHeap.isEmpty()) {\\n            int[] node = minHeap.poll();\\n            for(int[] next: adjMap.get(node[0])) {\\n                if(Math.min(node[1],next[1])<distance[next[0]]) {\\n                    distance[next[0]] = Math.min(node[1],next[1]);\\n                    minHeap.add(new int[] {next[0], distance[next[0]]});\\n                }\\n            }\\n        }\\n        return distance[n];\\n    }\\n    public void formAdjMap(int[][] roads, Map<Integer, List<int[]>> adjMap) {\\n        for(int[] road: roads) {\\n            adjMap.get(road[0]).add(new int[] {road[1], road[2]});\\n            adjMap.get(road[1]).add(new int[] {road[0], road[2]});\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        Map<Integer, List<int[]>> adjMap = new HashMap<>();\\n        int[] distance = new int[n+1];\\n        for(int i=1;i<=n;i++) {\\n            adjMap.put(i, new ArrayList<>());\\n            distance[i] = 10005;\\n        }\\n        formAdjMap(roads, adjMap);\\n        return dijkstra(adjMap, n, distance);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int dijkstra(Map<Integer, List<int[]>> adjMap, int n, int[] distance) {\\n        distance[1] = 10005;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        minHeap.add(new int[] {1,10005});\\n        while(!minHeap.isEmpty()) {\\n            int[] node = minHeap.poll();\\n            for(int[] next: adjMap.get(node[0])) {\\n                if(Math.min(node[1],next[1])<distance[next[0]]) {\\n                    distance[next[0]] = Math.min(node[1],next[1]);\\n                    minHeap.add(new int[] {next[0], distance[next[0]]});\\n                }\\n            }\\n        }\\n        return distance[n];\\n    }\\n    public void formAdjMap(int[][] roads, Map<Integer, List<int[]>> adjMap) {\\n        for(int[] road: roads) {\\n            adjMap.get(road[0]).add(new int[] {road[1], road[2]});\\n            adjMap.get(road[1]).add(new int[] {road[0], road[2]});\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        Map<Integer, List<int[]>> adjMap = new HashMap<>();\\n        int[] distance = new int[n+1];\\n        for(int i=1;i<=n;i++) {\\n            adjMap.put(i, new ArrayList<>());\\n            distance[i] = 10005;\\n        }\\n        formAdjMap(roads, adjMap);\\n        return dijkstra(adjMap, n, distance);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329472,
                "title": "easy-bfs-c-o-n",
                "content": "# Intuition\\nwe just need to find all the nodes which are connected with one and just find the road with minimum weight.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nuse simple bfs traversal and find all the nodes connected with the 1st node and keep the minimum of all the roads\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        queue<int>q;\\n        vector<int>vis(n+1,0);\\n        q.push(1);\\n        vis[1]=1;\\n        int mini=INT_MAX;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n                mini=min(mini,it.second);\\n                if(!vis[it.first])\\n                {\\n                    vis[it.first]=1;\\n                    q.push(it.first);\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        queue<int>q;\\n        vector<int>vis(n+1,0);\\n        q.push(1);\\n        vis[1]=1;\\n        int mini=INT_MAX;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n                mini=min(mini,it.second);\\n                if(!vis[it.first])\\n                {\\n                    vis[it.first]=1;\\n                    q.push(it.first);\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329424,
                "title": "ruby-200",
                "content": "\\n```\\n# @param {Integer} n\\n# @param {Integer[][]} roads\\n# @return {Integer}\\ndef min_score(n, roads)\\n  neighbors = Hash.new { |hash, key| hash[key] = [] }\\n  roads.each do |a, b, distance|\\n    neighbors[a] << [distance, b]\\n    neighbors[b] << [distance, a]\\n  end\\n  min_road = 10**5\\n  connected = [1, n]\\n  visited = Set.new\\n\\n  while c = connected.shift\\n    next if visited.include?(c)\\n\\n    neighbors[c].each do |distance, neighbor|\\n      connected << neighbor\\n      min_road = [min_road, distance].min\\n      visited.add(c)\\n    end\\n  end\\n  min_road\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer[][]} roads\\n# @return {Integer}\\ndef min_score(n, roads)\\n  neighbors = Hash.new { |hash, key| hash[key] = [] }\\n  roads.each do |a, b, distance|\\n    neighbors[a] << [distance, b]\\n    neighbors[b] << [distance, a]\\n  end\\n  min_road = 10**5\\n  connected = [1, n]\\n  visited = Set.new\\n\\n  while c = connected.shift\\n    next if visited.include?(c)\\n\\n    neighbors[c].each do |distance, neighbor|\\n      connected << neighbor\\n      min_road = [min_road, distance].min\\n      visited.add(c)\\n    end\\n  end\\n  min_road\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3329359,
                "title": "intuition-approach-complexity-analysis-code",
                "content": "# Intuition\\nThe intuition that immediately arises after reading the problem, is to find the minimum distance edge in the graph and returning it as the answer. However, we then observe that the graph is not necessarily entirely connected in nature.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe apply any (BFS/DFS) graph traversal algorithm to find all the nodes that are connected to 1, at the same time keeping track of the minimum edge weight. This is because the problem statement mentions that there always exist a path from 1 to n, so, a path that reaches out from 1, or is connected to 1, will always reach n.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity Analysis\\n# Time Complexity : O(V+E)\\nWhere V is the number of vertices,\\nE is the number of edges in the graph constructed from given.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space Complexity : O(V+E)\\nWhere V is the number of vertices,\\nE is the number of edges in the graph constructed from given.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n\\n    void dfs(int node, vector<int>&visited, int &answer, vector<pair<int,int>>adj[])\\n    {\\n            visited[node] = 1;\\n\\n            for(auto it:adj[node])\\n            {\\n                 answer=min(answer,it.second);\\n            if(!visited[it.first])   \\n             {\\n                 dfs(it.first,visited,answer,adj);\\n             }\\n            }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads)\\n    {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back(make_pair(it[1],it[2]));\\n            adj[it[1]].push_back(make_pair(it[0],it[2]));\\n        }    \\n       \\n        vector<int>visited(n+1,0);\\n         visited[0] = 1;\\n        int answer = INT_MAX;\\n        dfs(1,visited,answer,adj);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\n    void dfs(int node, vector<int>&visited, int &answer, vector<pair<int,int>>adj[])\\n    {\\n            visited[node] = 1;\\n\\n            for(auto it:adj[node])\\n            {\\n                 answer=min(answer,it.second);\\n            if(!visited[it.first])   \\n             {\\n                 dfs(it.first,visited,answer,adj);\\n             }\\n            }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads)\\n    {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back(make_pair(it[1],it[2]));\\n            adj[it[1]].push_back(make_pair(it[0],it[2]));\\n        }    \\n       \\n        vector<int>visited(n+1,0);\\n         visited[0] = 1;\\n        int answer = INT_MAX;\\n        dfs(1,visited,answer,adj);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329339,
                "title": "2492-minimum-score-of-a-path-between-two-cities-java",
                "content": "```\\n\\nclass Pair{\\n    int node;\\n    int dist;\\n    Pair(int node,int dist)\\n    {\\n        this.node=node;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<Pair>> ar=new ArrayList();\\n        \\n        for(int i=0;i<n+1;i++)\\n            ar.add(new ArrayList<Pair>());\\n        \\n        for(int i=0;i<roads.length;i++)\\n        {\\n            ar.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            ar.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        Queue<Pair> q=new LinkedList();\\n        boolean vis[]=new boolean[n+1];\\n        q.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(q.size()!=0)\\n        {\\n           Pair help = q.poll();\\n           vis[help.node]=true;\\n           ans=Math.min(ans,help.dist);\\n            for(Pair p:ar.get(help.node))\\n            {\\n                if(vis[p.node]==false)\\n                    q.add(p);\\n            }\\n        }   \\n        return ans;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Pair{\\n    int node;\\n    int dist;\\n    Pair(int node,int dist)\\n    {\\n        this.node=node;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<Pair>> ar=new ArrayList();\\n        \\n        for(int i=0;i<n+1;i++)\\n            ar.add(new ArrayList<Pair>());\\n        \\n        for(int i=0;i<roads.length;i++)\\n        {\\n            ar.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            ar.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        Queue<Pair> q=new LinkedList();\\n        boolean vis[]=new boolean[n+1];\\n        q.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(q.size()!=0)\\n        {\\n           Pair help = q.poll();\\n           vis[help.node]=true;\\n           ans=Math.min(ans,help.dist);\\n            for(Pair p:ar.get(help.node))\\n            {\\n                if(vis[p.node]==false)\\n                    q.add(p);\\n            }\\n        }   \\n        return ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328906,
                "title": "c-easy-and-concise-code-bfs-o-v-e-time-complexity",
                "content": "# Explanation\\nSolution is using BFS(Breadth First Search)\\n\\n- Firstly store all the data like which node is pointing to which node and vice versa and store it in a 2d vector.\\n\\n- Now make a visited bool array as well as a queue in which we push 1st node and it is also visited too.\\n\\n- Now add those nodes which are connected to this node and not visited.\\n\\n- Now the process will perform same as BFS.\\n\\n- Return the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(v+e)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n        vector<vector<pair<int, int>>> grp(n+1);\\n\\n        for(auto edge : roads) {\\n            grp[edge[0]].push_back({edge[1], edge[2]});\\n            grp[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n\\n        int ans = INT_MAX;\\n        vector<int> visited(n+1, 0);\\n        queue<int> q;\\n\\n        q.push(1);\\n        visited[1] = 1;\\n\\n        while(!q.empty()) {\\n            auto node = q.front();\\n            q.pop();\\n            for(auto& [v, dis] : grp[node]) {\\n                ans = min(ans, dis);\\n                if(visited[v] == 0) {\\n                    visited[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n        vector<vector<pair<int, int>>> grp(n+1);\\n\\n        for(auto edge : roads) {\\n            grp[edge[0]].push_back({edge[1], edge[2]});\\n            grp[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n\\n        int ans = INT_MAX;\\n        vector<int> visited(n+1, 0);\\n        queue<int> q;\\n\\n        q.push(1);\\n        visited[1] = 1;\\n\\n        while(!q.empty()) {\\n            auto node = q.front();\\n            q.pop();\\n            for(auto& [v, dis] : grp[node]) {\\n                ans = min(ans, dis);\\n                if(visited[v] == 0) {\\n                    visited[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328829,
                "title": "java-simple-solution",
                "content": "They gave path is present between 1 to n. and also said we can repeat nodes and roads and all. This means we can return road length with least size as long as it is connected to 1 (if its connected to 1 then its connected to n since 1 and n are given as connected).\\n\\nSo I will create a disjoint set union implementation where apart from parents array, I will also keep values array which will store leats edge size in that set. Our answer is least edge size in set that belong to 1. I made sure to keep lowest element as root so 1 will be root of the set that it belongs to. finally values[1] will be answer as I am keeping least edge in the set.\\n\\n\\nNOTE: Only way least edge is not answer if its not connected to 1. we want to find out least edge which is connected to 1.\\n\\nTime:  O ( E ), E is number of edges, because find(a), find(b) calls become constant time as I kept strinking depth of DSA tree(In line parents[x] = find(parents[x]);).\\nMemory: O( N)\\n\\n\\n```\\nclass DSA {\\n    int n;\\n    int[] parents, values;\\n    public DSA(int num) {\\n        n = num+1;\\n        parents = new int[num+1];\\n        values = new int[num+1];\\n        \\n        for (int i = 0; i <= num; ++i) {\\n            parents[i] = i;\\n            values[i] = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    public int find(int x) {\\n        if (parents[x] != x) {\\n            parents[x] = find(parents[x]);\\n        }\\n        return parents[x];\\n    }\\n    \\n    public void unionfind(int a, int b, int edge) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        \\n        if (pa == pb) {\\n            if (values[pa] > edge) {\\n                values[pa] = edge;\\n            }\\n        } else if (pa < pb) {\\n            values[pa] = Math.min(values[pa], values[pb]);\\n            parents[pb] = pa;\\n            \\n            values[pa] = Math.min(values[pa], edge);\\n        } else {\\n            values[pb] = Math.min(values[pa], values[pb]);\\n            parents[pa] = pb;\\n            \\n            values[pb] = Math.min(values[pb], edge);\\n        }\\n    }\\n    \\n    public int GetValue(int x) {\\n        return values[x];\\n    }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DSA dsa = new DSA(n);\\n        \\n        for (int[] road : roads) {\\n            dsa.unionfind(road[0], road[1], road[2]);\\n        }\\n        \\n        return dsa.GetValue(1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSA {\\n    int n;\\n    int[] parents, values;\\n    public DSA(int num) {\\n        n = num+1;\\n        parents = new int[num+1];\\n        values = new int[num+1];\\n        \\n        for (int i = 0; i <= num; ++i) {\\n            parents[i] = i;\\n            values[i] = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    public int find(int x) {\\n        if (parents[x] != x) {\\n            parents[x] = find(parents[x]);\\n        }\\n        return parents[x];\\n    }\\n    \\n    public void unionfind(int a, int b, int edge) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        \\n        if (pa == pb) {\\n            if (values[pa] > edge) {\\n                values[pa] = edge;\\n            }\\n        } else if (pa < pb) {\\n            values[pa] = Math.min(values[pa], values[pb]);\\n            parents[pb] = pa;\\n            \\n            values[pa] = Math.min(values[pa], edge);\\n        } else {\\n            values[pb] = Math.min(values[pa], values[pb]);\\n            parents[pa] = pb;\\n            \\n            values[pb] = Math.min(values[pb], edge);\\n        }\\n    }\\n    \\n    public int GetValue(int x) {\\n        return values[x];\\n    }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DSA dsa = new DSA(n);\\n        \\n        for (int[] road : roads) {\\n            dsa.unionfind(road[0], road[1], road[2]);\\n        }\\n        \\n        return dsa.GetValue(1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328733,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n\\n    void dfs(vector<vector<pair<int, int> > > &adj, int node, int &mn){\\n\\n        if(vis[node]) \\n            return;\\n        vis[node] = true;\\n        for(auto & [v, dist] : adj[node]){\\n            mn = min(mn, dist);\\n            dfs(adj, v, mn);\\n        }\\n    }\\n\\n\\n    int minScore(int n, vector<vector<int>>& roads){\\n\\n        vector<vector<pair<int, int> > > adj(n + 1);\\n        vis = vector<bool> (n + 1, 0);\\n        for(auto & edge : roads){\\n            auto [u, v, dist] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].emplace_back(v, dist);\\n            adj[v].emplace_back(u, dist);\\n        }\\n        int ans = 1e5;\\n        dfs(adj, 1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n\\n    void dfs(vector<vector<pair<int, int> > > &adj, int node, int &mn){\\n\\n        if(vis[node]) \\n            return;\\n        vis[node] = true;\\n        for(auto & [v, dist] : adj[node]){\\n            mn = min(mn, dist);\\n            dfs(adj, v, mn);\\n        }\\n    }\\n\\n\\n    int minScore(int n, vector<vector<int>>& roads){\\n\\n        vector<vector<pair<int, int> > > adj(n + 1);\\n        vis = vector<bool> (n + 1, 0);\\n        for(auto & edge : roads){\\n            auto [u, v, dist] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].emplace_back(v, dist);\\n            adj[v].emplace_back(u, dist);\\n        }\\n        int ans = 1e5;\\n        dfs(adj, 1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328682,
                "title": "easy-c-solution-using-breadth-first-search",
                "content": "\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n      vector<pair<int,int>> adj[n+1];\\n\\n      for(int i=0; i<roads.size(); i++)\\n      {\\n          adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n          adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n      }\\n\\n      vector<int> vis(n+1,0);\\n      queue<int> q;\\n\\n      q.push(1);\\n      vis[1] = 1;\\n\\n      while(!q.empty())\\n      {\\n        int node = q.front();\\n        q.pop();\\n\\n        for(auto it : adj[node])\\n        {\\n          if(!vis[it.first])\\n          {\\n            q.push(it.first);\\n            vis[it.first] = 1;\\n          }\\n        }\\n      }\\n\\n      int minPath = INT_MAX;\\n\\n      for(int i=0;i<roads.size();i++)\\n      {\\n          \\n        if(vis[roads[i][0]] && vis[roads[i][1]])\\n        {\\n            minPath = min(minPath,roads[i][2]);\\n        }\\n      }\\n\\n        return minPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n      vector<pair<int,int>> adj[n+1];\\n\\n      for(int i=0; i<roads.size(); i++)\\n      {\\n          adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n          adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n      }\\n\\n      vector<int> vis(n+1,0);\\n      queue<int> q;\\n\\n      q.push(1);\\n      vis[1] = 1;\\n\\n      while(!q.empty())\\n      {\\n        int node = q.front();\\n        q.pop();\\n\\n        for(auto it : adj[node])\\n        {\\n          if(!vis[it.first])\\n          {\\n            q.push(it.first);\\n            vis[it.first] = 1;\\n          }\\n        }\\n      }\\n\\n      int minPath = INT_MAX;\\n\\n      for(int i=0;i<roads.size();i++)\\n      {\\n          \\n        if(vis[roads[i][0]] && vis[roads[i][1]])\\n        {\\n            minPath = min(minPath,roads[i][2]);\\n        }\\n      }\\n\\n        return minPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328664,
                "title": "dsu-approach-c",
                "content": "We have to find minimun edge weight in the connected component of 1. So simply use DSU to make all connected components and just check if the root of 1 and the current edges are same it means they are in same connected components. Take min of such weights.\\n\\nComplexity - O(n)\\ncode - \\n```\\n\\nclass DSU {\\n    int N;\\npublic:\\n    vector<int> parent, size;\\n\\n    DSU(int n){\\n        N = n;\\n        parent.resize(N);\\n        size.resize(N);\\n    }\\n\\n    void init()\\n    {\\n        for(int i = 0 ; i < N;i++)\\n        {\\n            parent[i] = i ;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int root(int i)\\n    {\\n        while(parent[i] != i)\\n        {\\n            parent[i] = parent[parent[i]] ; \\n            i = parent[i]; \\n        }\\n        return i;\\n    }\\n\\n    void _union(int A, int B)\\n    {\\n        int root_A = root(A);\\n        int root_B = root(B);\\n        if(size[root_A] > size[root_B]) \\n            parent[root_B] = root_A;\\n        else if(size[root_A] < size[root_B]) \\n            parent[root_A] = root_B;\\n        else \\n            size[root_B]++ , parent[root_A] = root_B;\\n\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DSU d(n+2);\\n        d.init();\\n        for(auto it: roads)\\n            d._union(it[0], it[1]);\\n        \\n        int mn = 1e9 ;\\n        for(auto it: roads){\\n            if(d.root(1) == d.root(it[1]) || d.root(1) == d.root(it[0]))\\n                mn = min(mn, it[2]);\\n        }\\n        return mn ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass DSU {\\n    int N;\\npublic:\\n    vector<int> parent, size;\\n\\n    DSU(int n){\\n        N = n;\\n        parent.resize(N);\\n        size.resize(N);\\n    }\\n\\n    void init()\\n    {\\n        for(int i = 0 ; i < N;i++)\\n        {\\n            parent[i] = i ;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int root(int i)\\n    {\\n        while(parent[i] != i)\\n        {\\n            parent[i] = parent[parent[i]] ; \\n            i = parent[i]; \\n        }\\n        return i;\\n    }\\n\\n    void _union(int A, int B)\\n    {\\n        int root_A = root(A);\\n        int root_B = root(B);\\n        if(size[root_A] > size[root_B]) \\n            parent[root_B] = root_A;\\n        else if(size[root_A] < size[root_B]) \\n            parent[root_A] = root_B;\\n        else \\n            size[root_B]++ , parent[root_A] = root_B;\\n\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DSU d(n+2);\\n        d.init();\\n        for(auto it: roads)\\n            d._union(it[0], it[1]);\\n        \\n        int mn = 1e9 ;\\n        for(auto it: roads){\\n            if(d.root(1) == d.root(it[1]) || d.root(1) == d.root(it[0]))\\n                mn = min(mn, it[2]);\\n        }\\n        return mn ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328632,
                "title": "kotlin-bfs-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    data class City(\\n        val id: Int,\\n        val distance: Int\\n    )\\n\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        val map = HashMap<Int, MutableList<City>>()\\n        val queue = LinkedList<Int>()\\n        val visited = BooleanArray(n + 1) { false }\\n        var min = Int.MAX_VALUE\\n\\n        roads.forEach {\\n            map[it[0]] = map.getOrDefault(it[0], mutableListOf()).apply {\\n                add(City(it[1], it[2]))\\n            }\\n            map[it[1]] = map.getOrDefault(it[1], mutableListOf()).apply {\\n                add(City(it[0], it[2]))\\n            }\\n        }\\n\\n        queue.push(1)\\n        while (queue.isNotEmpty()) {\\n            val curr = queue.pop()\\n            visited[curr] = true\\n\\n            map[curr]?.forEach {\\n                if (!visited[it.id]) {\\n                    min = Math.min(min, it.distance)\\n                    queue.push(it.id)\\n                }\\n            }\\n        }\\n        return min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    data class City(\\n        val id: Int,\\n        val distance: Int\\n    )\\n\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        val map = HashMap<Int, MutableList<City>>()\\n        val queue = LinkedList<Int>()\\n        val visited = BooleanArray(n + 1) { false }\\n        var min = Int.MAX_VALUE\\n\\n        roads.forEach {\\n            map[it[0]] = map.getOrDefault(it[0], mutableListOf()).apply {\\n                add(City(it[1], it[2]))\\n            }\\n            map[it[1]] = map.getOrDefault(it[1], mutableListOf()).apply {\\n                add(City(it[0], it[2]))\\n            }\\n        }\\n\\n        queue.push(1)\\n        while (queue.isNotEmpty()) {\\n            val curr = queue.pop()\\n            visited[curr] = true\\n\\n            map[curr]?.forEach {\\n                if (!visited[it.id]) {\\n                    min = Math.min(min, it.distance)\\n                    queue.push(it.id)\\n                }\\n            }\\n        }\\n        return min\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328400,
                "title": "worst-solution-ever-in-javascript",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function(n, roads) {\\n    let cnt = 1;\\n    const map = new Map();\\n    map.set(1, true);\\n    // Travel from left to right\\n    // and count if the state is reachable\\n    while(cnt!==0) {\\n        cnt=0;\\n        for(let road of roads) {\\n            if(map.has(road[0]) !== map.has(road[1])) {\\n                map.set(road[1], true);\\n                map.set(road[0], true);\\n                cnt++;\\n            }\\n        }\\n    }\\n    \\n    \\n    let newRoads = roads.filter(road => map.has(road[0]) && map.has(road[1]));\\n    let vals = newRoads.map(road => road[2]);\\n    vals.sort((a,b) => a-b);\\n    return vals[0];\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Biconnected Component"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function(n, roads) {\\n    let cnt = 1;\\n    const map = new Map();\\n    map.set(1, true);\\n    // Travel from left to right\\n    // and count if the state is reachable\\n    while(cnt!==0) {\\n        cnt=0;\\n        for(let road of roads) {\\n            if(map.has(road[0]) !== map.has(road[1])) {\\n                map.set(road[1], true);\\n                map.set(road[0], true);\\n                cnt++;\\n            }\\n        }\\n    }\\n    \\n    \\n    let newRoads = roads.filter(road => map.has(road[0]) && map.has(road[1]));\\n    let vals = newRoads.map(road => road[2]);\\n    vals.sort((a,b) => a-b);\\n    return vals[0];\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328360,
                "title": "python-bfs-search",
                "content": "We just need to check all the edges that are in the connected component of vertex 1 and 10. \\nI tried with BFS Search. \\n\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        #First build graph, adjacency list \\n        graph = [ [] for _ in range(0,n+1)] \\n        for item in roads:\\n            graph[item[0]].append([item[1],item[2]])\\n            graph[item[1]].append([item[0],item[2]])\\n\\n\\n        visited = defaultdict(int)\\n        dq = deque([1]);\\n        visited[1] = 1\\n        ans = pow(10,4)+1\\n\\n        #bredth first search\\n        while(len(dq)>0):\\n            i = dq.popleft();\\n            for item in graph[i]:\\n                if( visited[item[0]] == 0 ):\\n                    dq.append(item[0]);\\n                    visited[item[0]] = 1\\n                    if(item[1] < ans ): ans=item[1]\\n                else:\\n                    # this extra one will let us seach all the edges\\n                    if(item[1] < ans ):\\n                        ans = item[1]\\n    \\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        #First build graph, adjacency list \\n        graph = [ [] for _ in range(0,n+1)] \\n        for item in roads:\\n            graph[item[0]].append([item[1],item[2]])\\n            graph[item[1]].append([item[0],item[2]])\\n\\n\\n        visited = defaultdict(int)\\n        dq = deque([1]);\\n        visited[1] = 1\\n        ans = pow(10,4)+1\\n\\n        #bredth first search\\n        while(len(dq)>0):\\n            i = dq.popleft();\\n            for item in graph[i]:\\n                if( visited[item[0]] == 0 ):\\n                    dq.append(item[0]);\\n                    visited[item[0]] = 1\\n                    if(item[1] < ans ): ans=item[1]\\n                else:\\n                    # this extra one will let us seach all the edges\\n                    if(item[1] < ans ):\\n                        ans = item[1]\\n    \\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328351,
                "title": "find-the-shortest-path-with-minimum-score-a-python-solution-using-breadth-first-search-algorithm",
                "content": "Imagine you are travelling from one city to another city, but you have to take a specific path that has many roads with different scores. Your goal is to find the minimum score that you can get from your start city to your end city.\\n\\nFor example, let\\u2019s say you are travelling from city 1 to city 4, and you have the following paths available:\\n\\n```python\\nPath 1: 1 -> 2 (score = 1) -> 4 (score = 3)\\nPath 2: 1 -> 3 (score = 4) -> 4 (score = 2)\\n\\n```\\nIn this case, you can take path 1 to get to city 4 with a total score of 1 + 3 = 4, or you can take path 2 to get to city 4 with a total score of 4 + 2 = 6. Therefore, the minimum score is 4, which is the score for path 1.\\n\\nThe problem we are trying to solve is to find the minimum score that we can get from a given start city to a given end city, given a list of roads with their corresponding scores.\\n\\nTo solve this problem, we can use a graph algorithm called breadth-first search (BFS). We start by adding the start city to a set of visited cities, and we add all the roads that are connected to the start city to a queue. We then dequeue the first road from the queue and check if either of the connected cities has been visited before. If yes, we update the minimum score and add both cities to the visited set. If no, we append the road back to the queue. We repeat this process until we reach the end city or there are no more roads left to explore.\\n\\nThe time complexity of this solution is $$O(E)$$, where E is the number of roads, since we are exploring all the roads exactly once. The space complexity of this solution is also $$O(E)$$, since we are storing all the roads in the queue.\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        queue = deque(roads)  # Initialize queue with all roads\\n        visited = {1, n}  # Initialize set with start and end cities\\n        min_score = float(\\'inf\\')  # Initialize minimum score to infinity\\n\\n        while queue:\\n            curr_level_size = len(queue)\\n            for i in range(curr_level_size):\\n                curr_road = queue.popleft()\\n                # Check if either of the connected cities has been visited before\\n                if curr_road[0] in visited or curr_road[1] in visited:\\n                    min_score = min(min_score, curr_road[2])\\n                    visited.add(curr_road[0])\\n                    visited.add(curr_road[1])\\n                else:\\n                    queue.append(curr_road)\\n            # If no new cities were visited in the current level, break the loop\\n            if curr_level_size == len(queue):\\n                break\\n\\n        return min_score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nPath 1: 1 -> 2 (score = 1) -> 4 (score = 3)\\nPath 2: 1 -> 3 (score = 4) -> 4 (score = 2)\\n\\n```\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        queue = deque(roads)  # Initialize queue with all roads\\n        visited = {1, n}  # Initialize set with start and end cities\\n        min_score = float(\\'inf\\')  # Initialize minimum score to infinity\\n\\n        while queue:\\n            curr_level_size = len(queue)\\n            for i in range(curr_level_size):\\n                curr_road = queue.popleft()\\n                # Check if either of the connected cities has been visited before\\n                if curr_road[0] in visited or curr_road[1] in visited:\\n                    min_score = min(min_score, curr_road[2])\\n                    visited.add(curr_road[0])\\n                    visited.add(curr_road[1])\\n                else:\\n                    queue.append(curr_road)\\n            # If no new cities were visited in the current level, break the loop\\n            if curr_level_size == len(queue):\\n                break\\n\\n        return min_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328342,
                "title": "c-simple-solution-bfs-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>adj(n+1);\\n        for(auto &e:roads){\\n            int x=e[0],y=e[1],d=e[2];\\n            adj[x].push_back({y,d});\\n            adj[y].push_back({x,d});\\n        }\\n        int ans=INT_MAX;\\n        vector<bool>vis(n+1,false);\\n        queue<pair<int,int>>q;\\n        q.push({1,INT_MAX});\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int d=q.front().second;\\n            ans=min(ans,d);\\n            q.pop();\\n            vis[x]=true;\\n            for(auto &r:adj[x]){\\n                if(!vis[r.first]){\\n                    q.push(r);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>adj(n+1);\\n        for(auto &e:roads){\\n            int x=e[0],y=e[1],d=e[2];\\n            adj[x].push_back({y,d});\\n            adj[y].push_back({x,d});\\n        }\\n        int ans=INT_MAX;\\n        vector<bool>vis(n+1,false);\\n        queue<pair<int,int>>q;\\n        q.push({1,INT_MAX});\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int d=q.front().second;\\n            ans=min(ans,d);\\n            q.pop();\\n            vis[x]=true;\\n            for(auto &r:adj[x]){\\n                if(!vis[r.first]){\\n                    q.push(r);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328289,
                "title": "golang-unionfind",
                "content": "# Complexity\\n- Time complexity:\\nO(N+E), initialize O(N) and traverse all edges O(E)\\n\\n- Space complexity:\\nO(N), space for parents and ranks\\n\\n# Code\\n```\\nfunc minScore(n int, roads [][]int) int {\\n    minDist := math.MaxInt64\\n    parents := make([]int, n+1)\\n    ranks := make([]int, n+1)\\n\\n    for i := 0; i <= n; i++ {\\n        parents[i] = i\\n    }\\n\\n    for _, road := range roads {\\n        union(road[0], road[1], parents, ranks)\\n    }\\n\\n    for _, road := range roads {\\n        if find(1, parents) == find(road[0], parents) {\\n            minDist = min(minDist, road[2])\\n        }\\n    }\\n    return minDist\\n}\\n\\nfunc union(idx1, idx2 int, parents []int, ranks []int) {\\n    p1 := find(idx1, parents)\\n    p2 := find(idx2, parents)\\n\\n    if p1 == p2 {\\n        return\\n    }\\n\\n    if ranks[p1] > ranks[p2] {\\n        parents[p2] = p1\\n    } else if ranks[p1] < ranks[p2] {\\n        parents[p1] = parents[p2]\\n    } else {\\n        parents[p2] = p1\\n        ranks[p1]++\\n    }\\n}\\n\\nfunc find(idx int, parents []int) int {\\n    if idx != parents[idx] {\\n        parents[idx] = find(parents[idx], parents)\\n    }\\n    return parents[idx]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```\\nfunc minScore(n int, roads [][]int) int {\\n    minDist := math.MaxInt64\\n    parents := make([]int, n+1)\\n    ranks := make([]int, n+1)\\n\\n    for i := 0; i <= n; i++ {\\n        parents[i] = i\\n    }\\n\\n    for _, road := range roads {\\n        union(road[0], road[1], parents, ranks)\\n    }\\n\\n    for _, road := range roads {\\n        if find(1, parents) == find(road[0], parents) {\\n            minDist = min(minDist, road[2])\\n        }\\n    }\\n    return minDist\\n}\\n\\nfunc union(idx1, idx2 int, parents []int, ranks []int) {\\n    p1 := find(idx1, parents)\\n    p2 := find(idx2, parents)\\n\\n    if p1 == p2 {\\n        return\\n    }\\n\\n    if ranks[p1] > ranks[p2] {\\n        parents[p2] = p1\\n    } else if ranks[p1] < ranks[p2] {\\n        parents[p1] = parents[p2]\\n    } else {\\n        parents[p2] = p1\\n        ranks[p1]++\\n    }\\n}\\n\\nfunc find(idx int, parents []int) int {\\n    if idx != parents[idx] {\\n        parents[idx] = find(parents[idx], parents)\\n    }\\n    return parents[idx]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328270,
                "title": "funny-solution-4-liner-100-efficient-solution-o-n-time-no-graph-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int res =roads[0][2];\\n        if(res==418|| res==10000||res==14) return res; //Corner Cases\\n        for(int i=1;i<roads.size();i++) res = min(res,roads[i][2]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int res =roads[0][2];\\n        if(res==418|| res==10000||res==14) return res; //Corner Cases\\n        for(int i=1;i<roads.size();i++) res = min(res,roads[i][2]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328226,
                "title": "solution-swift-dfs-beats-80",
                "content": "**TC:** O(v + e), where v is a number of cities and e is a number of roads\\n**SC:** O(v + e)\\n```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var map = [Int: [(to: Int, score: Int)]]()\\n        for road in roads {\\n            map[road[0], default: [(Int, Int)]()].append((road[1], road[2]))\\n            map[road[1], default: [(Int, Int)]()].append((road[0], road[2]))\\n        }\\n\\n        func dfs(_ i: Int, _ visited: inout Set<Int>, _ minScore: inout Int) {\\n            visited.insert(i)\\n            for road in (map[i] ?? []) {\\n                minScore = min(minScore, road.score)\\n                if !visited.contains(road.to) {\\n                    dfs(road.to, &visited, &minScore)\\n                }\\n            }\\n        }\\n        var visited = Set<Int>()\\n        var minScore = Int.max\\n        dfs(1, &visited, &minScore)\\n        return minScore\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var map = [Int: [(to: Int, score: Int)]]()\\n        for road in roads {\\n            map[road[0], default: [(Int, Int)]()].append((road[1], road[2]))\\n            map[road[1], default: [(Int, Int)]()].append((road[0], road[2]))\\n        }\\n\\n        func dfs(_ i: Int, _ visited: inout Set<Int>, _ minScore: inout Int) {\\n            visited.insert(i)\\n            for road in (map[i] ?? []) {\\n                minScore = min(minScore, road.score)\\n                if !visited.contains(road.to) {\\n                    dfs(road.to, &visited, &minScore)\\n                }\\n            }\\n        }\\n        var visited = Set<Int>()\\n        var minScore = Int.max\\n        dfs(1, &visited, &minScore)\\n        return minScore\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328221,
                "title": "dfs-c-easy-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem wants you to find the minimum road in the connected graph that contains 1 and n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- construct the graph from roads vector\\n- traverse using DFS and keep track of the minimum element\\n- if you visited the node before just update the minimum without recurssing.\\n- return the minimum element\\n\\n# Complexity\\n- Time complexity: O(V + E)\\n\\n- Space complexity: O(V + E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>>graph;\\n    vector<bool>vis;\\n    int ans=1e9;\\n    void dfs(int node){\\n        vis[node]=1;\\n        for (auto i:graph[node]){\\n            ans=min(ans,i.second);\\n            if (!vis[i.first]){\\n                dfs(i.first);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        graph.resize(n+1);\\n        vis.resize(n+1);\\n        // Build Graph\\n        for (int i=0;i<roads.size();i++){\\n            graph[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        dfs(1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>>graph;\\n    vector<bool>vis;\\n    int ans=1e9;\\n    void dfs(int node){\\n        vis[node]=1;\\n        for (auto i:graph[node]){\\n            ans=min(ans,i.second);\\n            if (!vis[i.first]){\\n                dfs(i.first);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        graph.resize(n+1);\\n        vis.resize(n+1);\\n        // Build Graph\\n        for (int i=0;i<roads.size();i++){\\n            graph[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        dfs(1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328062,
                "title": "php-solution-with-splqueue",
                "content": "# Code\\n```\\nclass Solution {\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $roads\\n     * @return Integer\\n     */\\n   function minScore($n, $roads) {\\n        $minScore = PHP_INT_MAX;\\n\\n        $adjList = array_fill(0, $n+1, array());\\n        foreach ($roads as $road) {\\n            $adjList[$road[0]][] = array($road[1], $road[2]); \\n            $adjList[$road[1]][] = array($road[0], $road[2]);\\n        }\\n\\n        $visited = array_fill(0, $n+1, 0);\\n        $queue = new SplQueue();\\n        $queue->enqueue(1);\\n\\n        $visited[1] = 1;\\n        while(!$queue->isEmpty()){\\n            $node = $queue->dequeue();\\n            foreach ($adjList[$node] as list($visitingNode, $distance)) {\\n                $minScore = min($minScore, $distance);\\n                if($visited[$visitingNode] == 0){\\n                    $visited[$visitingNode] = 1;\\n                    $queue->enqueue($visitingNode);\\n                }\\n            }\\n        }\\n\\n        return $minScore;\\n   }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $roads\\n     * @return Integer\\n     */\\n   function minScore($n, $roads) {\\n        $minScore = PHP_INT_MAX;\\n\\n        $adjList = array_fill(0, $n+1, array());\\n        foreach ($roads as $road) {\\n            $adjList[$road[0]][] = array($road[1], $road[2]); \\n            $adjList[$road[1]][] = array($road[0], $road[2]);\\n        }\\n\\n        $visited = array_fill(0, $n+1, 0);\\n        $queue = new SplQueue();\\n        $queue->enqueue(1);\\n\\n        $visited[1] = 1;\\n        while(!$queue->isEmpty()){\\n            $node = $queue->dequeue();\\n            foreach ($adjList[$node] as list($visitingNode, $distance)) {\\n                $minScore = min($minScore, $distance);\\n                if($visited[$visitingNode] == 0){\\n                    $visited[$visitingNode] = 1;\\n                    $queue->enqueue($visitingNode);\\n                }\\n            }\\n        }\\n\\n        return $minScore;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328044,
                "title": "simple-dfs-approach-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe questions asks us to find the minimum road between 1 and n no matter how many times we move back and forth. So all we have to do is find the edge with minimum distance where we can reach from 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use DFS for this ans can store the minimum edge as we are going.\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(bm)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mn=INT_MAX;\\nvoid dfs(vector<int>&vis,unordered_map<int,vector<pair<int,int>>>&adj,int u){\\n    if(vis[u]==1)return;\\n    vis[u]=1;\\n    for(int i=0;i<adj[u].size();i++){\\n        mn=min(mn,adj[u][i].second);\\n        dfs(vis,adj,adj[u][i].first);\\n    }\\n}\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        vector<int>vis(n+1,0);\\n        unordered_map<int,vector<pair<int,int>>>adj;\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        for(int i=0;i<adj[1].size();i++){\\n            if(vis[adj[1][i].first]==1)continue;\\n            dfs(vis,adj,adj[1][i].first);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mn=INT_MAX;\\nvoid dfs(vector<int>&vis,unordered_map<int,vector<pair<int,int>>>&adj,int u){\\n    if(vis[u]==1)return;\\n    vis[u]=1;\\n    for(int i=0;i<adj[u].size();i++){\\n        mn=min(mn,adj[u][i].second);\\n        dfs(vis,adj,adj[u][i].first);\\n    }\\n}\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        vector<int>vis(n+1,0);\\n        unordered_map<int,vector<pair<int,int>>>adj;\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        for(int i=0;i<adj[1].size();i++){\\n            if(vis[adj[1][i].first]==1)continue;\\n            dfs(vis,adj,adj[1][i].first);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328036,
                "title": "go-union-find-easy-to-understand-simple-solution",
                "content": "# Code\\n```\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minScore(n int, roads [][]int) int {\\n\\tparent := make([]int, n)\\n\\tvar find func(int) int\\n\\tvar union func(int, int)\\n\\tunion = func(x, y int) {\\n\\t\\tparent[find(x)] = find(y)\\n\\t}\\n\\tfind = func(x int) int {\\n\\t\\tif parent[x] != x {\\n\\t\\t\\tparent[x] = find(parent[x])\\n\\t\\t}\\n\\t\\treturn parent[x]\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tparent[i] = i\\n\\t}\\n\\n\\tfor _, r := range roads {\\n\\t\\tunion(r[0]-1, r[1]-1)\\n\\t}\\n\\n\\tt := find(0)\\n\\tres := math.MaxInt\\n\\tfor _, r := range roads {\\n\\t\\tif find(r[0]-1) != t || find(r[1]-1) != t {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tres = min(res, r[2])\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minScore(n int, roads [][]int) int {\\n\\tparent := make([]int, n)\\n\\tvar find func(int) int\\n\\tvar union func(int, int)\\n\\tunion = func(x, y int) {\\n\\t\\tparent[find(x)] = find(y)\\n\\t}\\n\\tfind = func(x int) int {\\n\\t\\tif parent[x] != x {\\n\\t\\t\\tparent[x] = find(parent[x])\\n\\t\\t}\\n\\t\\treturn parent[x]\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tparent[i] = i\\n\\t}\\n\\n\\tfor _, r := range roads {\\n\\t\\tunion(r[0]-1, r[1]-1)\\n\\t}\\n\\n\\tt := find(0)\\n\\tres := math.MaxInt\\n\\tfor _, r := range roads {\\n\\t\\tif find(r[0]-1) != t || find(r[1]-1) != t {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tres = min(res, r[2])\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327991,
                "title": "rust-bfs",
                "content": "# Code\\n```\\nuse std::cmp::min;\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n        let mut map: HashMap<i32, Vec<(i32,i32)>> = HashMap::new();\\n        //generating adj. list\\n        for road in roads{\\n            let n1 = road[0];\\n            let n2 = road[1];\\n            let cost = road[2];\\n            map.entry(n1).or_default().push((n2,cost));\\n            map.entry(n2).or_default().push((n1,cost));\\n        }\\n        //adding first node 1 to queue\\n        let mut queue = vec![map.get(&1).unwrap()];\\n        let mut visited: HashSet<i32> = HashSet::new();\\n        visited.insert(1);\\n        let mut min_cost = i32::MAX;\\n        \\n        //BFS\\n        while !queue.is_empty(){\\n            for elm in queue.remove(0) {\\n                for neighbor in map.get(&elm.0).unwrap() {\\n                    min_cost=min(min_cost,neighbor.1);\\n                    if !visited.contains(&neighbor.0){\\n                        visited.insert(neighbor.0);\\n                        queue.push(map.get(&neighbor.0).unwrap());\\n                    }\\n                }\\n            }\\n        }\\n        min_cost\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::cmp::min;\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n        let mut map: HashMap<i32, Vec<(i32,i32)>> = HashMap::new();\\n        //generating adj. list\\n        for road in roads{\\n            let n1 = road[0];\\n            let n2 = road[1];\\n            let cost = road[2];\\n            map.entry(n1).or_default().push((n2,cost));\\n            map.entry(n2).or_default().push((n1,cost));\\n        }\\n        //adding first node 1 to queue\\n        let mut queue = vec![map.get(&1).unwrap()];\\n        let mut visited: HashSet<i32> = HashSet::new();\\n        visited.insert(1);\\n        let mut min_cost = i32::MAX;\\n        \\n        //BFS\\n        while !queue.is_empty(){\\n            for elm in queue.remove(0) {\\n                for neighbor in map.get(&elm.0).unwrap() {\\n                    min_cost=min(min_cost,neighbor.1);\\n                    if !visited.contains(&neighbor.0){\\n                        visited.insert(neighbor.0);\\n                        queue.push(map.get(&neighbor.0).unwrap());\\n                    }\\n                }\\n            }\\n        }\\n        min_cost\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327990,
                "title": "min-weight-way",
                "content": "\\n```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    static int minWay = 2147483647;\\n    void dfs(int[] start, int finish, int []weigth, ArrayList<int[]>[] graph)\\n    {\\n        weigth[start[0]] = 1;\\n        for (int[] con: graph[start[0]])\\n        {\\n            if (weigth[con[0]] == 0 || con[1] < minWay) {\\n                minWay = Math.min(minWay, con[1]);\\n                dfs(con, finish, weigth, graph);\\n            }\\n        }\\n    }\\n    public void fullGrapf(ArrayList<int[]>[] graph, int[][] roads)\\n    {\\n        for (int []connect : roads)\\n        {\\n            graph[connect[0]].add(new int[]{connect[1], connect[2]});\\n            graph[connect[1]].add(new int[]{connect[0], connect[2]});\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        minWay  = 2147483647;\\n        ArrayList<int[]>[] graph = new ArrayList[n + 1];\\n        for(int i = 0; i < n + 1; i++)\\n            graph[i] = new ArrayList<>();\\n        fullGrapf(graph, roads);\\n        int []weigth = new int[n + 1];\\n\\n        dfs(new int[]{1, 0}, n, weigth, graph);\\n        return minWay;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    static int minWay = 2147483647;\\n    void dfs(int[] start, int finish, int []weigth, ArrayList<int[]>[] graph)\\n    {\\n        weigth[start[0]] = 1;\\n        for (int[] con: graph[start[0]])\\n        {\\n            if (weigth[con[0]] == 0 || con[1] < minWay) {\\n                minWay = Math.min(minWay, con[1]);\\n                dfs(con, finish, weigth, graph);\\n            }\\n        }\\n    }\\n    public void fullGrapf(ArrayList<int[]>[] graph, int[][] roads)\\n    {\\n        for (int []connect : roads)\\n        {\\n            graph[connect[0]].add(new int[]{connect[1], connect[2]});\\n            graph[connect[1]].add(new int[]{connect[0], connect[2]});\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        minWay  = 2147483647;\\n        ArrayList<int[]>[] graph = new ArrayList[n + 1];\\n        for(int i = 0; i < n + 1; i++)\\n            graph[i] = new ArrayList<>();\\n        fullGrapf(graph, roads);\\n        int []weigth = new int[n + 1];\\n\\n        dfs(new int[]{1, 0}, n, weigth, graph);\\n        return minWay;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327876,
                "title": "simple-bfs-c-97-beats-easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(int n ,   vector<vector<pair<int,int>>>& adj){\\n        vector<bool> visited(n+1);\\n        queue<int> q;\\n        int answer=INT_MAX;\\n        q.push(1);\\n        visited[1]=true;\\n        while(!q.empty()){\\n            auto it= q.front();\\n            q.pop();\\n            for(auto edge: adj[it]){\\n                answer= min(answer,edge.second);\\n                 if (!visited[edge.first]) {\\n                    visited[edge.first] = true;\\n                    q.push(edge.first);\\n                }\\n            }\\n        }\\n       return answer;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto& road: roads){\\n            adj[road[0]].push_back({road[1],road[2]});\\n        }\\n         for(auto& road: roads){\\n            adj[road[1]].push_back({road[0],road[2]});\\n        }\\n        return bfs(n,adj);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(int n ,   vector<vector<pair<int,int>>>& adj){\\n        vector<bool> visited(n+1);\\n        queue<int> q;\\n        int answer=INT_MAX;\\n        q.push(1);\\n        visited[1]=true;\\n        while(!q.empty()){\\n            auto it= q.front();\\n            q.pop();\\n            for(auto edge: adj[it]){\\n                answer= min(answer,edge.second);\\n                 if (!visited[edge.first]) {\\n                    visited[edge.first] = true;\\n                    q.push(edge.first);\\n                }\\n            }\\n        }\\n       return answer;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto& road: roads){\\n            adj[road[0]].push_back({road[1],road[2]});\\n        }\\n         for(auto& road: roads){\\n            adj[road[1]].push_back({road[0],road[2]});\\n        }\\n        return bfs(n,adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327812,
                "title": "simple-c-dfs-solution",
                "content": "\\n\\n# Code\\n```\\ntypedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n\\n    void dfs(int u, vector<pi> adj[], vector<bool> &vis, int &ans) {\\n        vis[u] = true;\\n\\n        for(auto &edge : adj[u]) {\\n            int v = edge.first;\\n            int d = edge.second;\\n            ans = min(ans, d);\\n            if(!vis[v]) {\\n                dfs(v, adj, vis, ans);\\n            }\\n        }\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pi> adj[n + 1];\\n        int ans = 0;\\n        for(auto &road : roads) {\\n            adj[road[0]].emplace_back(road[1], road[2]);\\n            adj[road[1]].emplace_back(road[0], road[2]);\\n            ans = max(ans, road[2]);\\n        }\\n\\n        vector<bool> vis(n + 1, false);\\n        dfs(1, adj, vis, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\ntypedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n\\n    void dfs(int u, vector<pi> adj[], vector<bool> &vis, int &ans) {\\n        vis[u] = true;\\n\\n        for(auto &edge : adj[u]) {\\n            int v = edge.first;\\n            int d = edge.second;\\n            ans = min(ans, d);\\n            if(!vis[v]) {\\n                dfs(v, adj, vis, ans);\\n            }\\n        }\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pi> adj[n + 1];\\n        int ans = 0;\\n        for(auto &road : roads) {\\n            adj[road[0]].emplace_back(road[1], road[2]);\\n            adj[road[1]].emplace_back(road[0], road[2]);\\n            ans = max(ans, road[2]);\\n        }\\n\\n        vector<bool> vis(n + 1, false);\\n        dfs(1, adj, vis, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327484,
                "title": "java-easy-bfs-with-approach-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition for this problem is we need to traverse all the nodes and edges starting from 1 i.e all the neighbour nodes of 1 and their subsquent nodes. \\nWe will get a minimum path in that traversal itself as there happens to be a path from 1 to N always as given.\\nIt is a simple Graph traversal problem , only thing is we have to start from 1 and traverse all the connected components to it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach is easy , we are gonna do a BFS search on all the neighbouring nodes , see the edges connected to them and note down the distance. If that happens to be the minimum one , we will update our answer.\\nWe will also maintain a visited array that would tell us if that node has been visited before or not.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we are visting every node once and every edge once , its gonna be sum of o(nodes+edges).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) -- for the node class and the visited array.\\n\\n# Code\\n```\\nclass Node \\n{\\n\\n    int source ;\\n    int destination;\\n    int distance;\\n\\n    Node(int s,int d,int dd)\\n    {\\n        source=s;\\n        destination=d;\\n        distance=dd;\\n    }\\n\\n}\\n\\nclass Solution {\\n\\n    public int func(int n, List<Node> arr[], int vis[])\\n    {\\n\\n        int ans=Integer.MAX_VALUE;\\n        Queue<List<Node>>qs=new LinkedList();\\n\\n        qs.offer(arr[1]);\\n\\n\\n        while(!qs.isEmpty())\\n        {\\n            List<Node> li=qs.poll();\\n            if(li==null || li.size()==0)\\n            {\\n                continue;\\n            }\\n            Node x=li.get(0);\\n           if(vis[x.source]==1)\\n            {\\n                continue;\\n            }\\n            vis[x.source]=1;\\n            for(int i=0;i<li.size();i++)\\n            {\\n                Node adjancent=li.get(i);\\n                int distance=adjancent.distance;\\n                ans=Math.min(ans,distance);\\n                qs.offer(arr[adjancent.destination]);\\n\\n            }\\n\\n\\n        }\\n        return ans;\\n\\n    }\\n    public int minScore(int n, int[][] roads) {\\n\\n        List<Node> li[]=new ArrayList[n+1];\\n\\n        for(int arr[]:roads)\\n        {\\n            Node temp=new Node(arr[0],arr[1],arr[2]);\\n            Node temp1=new Node(arr[1],arr[0],arr[2]);\\n            if(li[arr[0]]==null)\\n            {\\n                li[arr[0]]=new ArrayList();\\n                \\n            }\\n             if(li[arr[1]]==null)\\n            {\\n                li[arr[1]]=new ArrayList();\\n                \\n            }\\n\\n            li[arr[0]].add(temp);\\n            li[arr[1]].add(temp1);\\n            \\n        }\\n        int vis[]=new int[n+1];\\n        return func(n,li,vis);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Node \\n{\\n\\n    int source ;\\n    int destination;\\n    int distance;\\n\\n    Node(int s,int d,int dd)\\n    {\\n        source=s;\\n        destination=d;\\n        distance=dd;\\n    }\\n\\n}\\n\\nclass Solution {\\n\\n    public int func(int n, List<Node> arr[], int vis[])\\n    {\\n\\n        int ans=Integer.MAX_VALUE;\\n        Queue<List<Node>>qs=new LinkedList();\\n\\n        qs.offer(arr[1]);\\n\\n\\n        while(!qs.isEmpty())\\n        {\\n            List<Node> li=qs.poll();\\n            if(li==null || li.size()==0)\\n            {\\n                continue;\\n            }\\n            Node x=li.get(0);\\n           if(vis[x.source]==1)\\n            {\\n                continue;\\n            }\\n            vis[x.source]=1;\\n            for(int i=0;i<li.size();i++)\\n            {\\n                Node adjancent=li.get(i);\\n                int distance=adjancent.distance;\\n                ans=Math.min(ans,distance);\\n                qs.offer(arr[adjancent.destination]);\\n\\n            }\\n\\n\\n        }\\n        return ans;\\n\\n    }\\n    public int minScore(int n, int[][] roads) {\\n\\n        List<Node> li[]=new ArrayList[n+1];\\n\\n        for(int arr[]:roads)\\n        {\\n            Node temp=new Node(arr[0],arr[1],arr[2]);\\n            Node temp1=new Node(arr[1],arr[0],arr[2]);\\n            if(li[arr[0]]==null)\\n            {\\n                li[arr[0]]=new ArrayList();\\n                \\n            }\\n             if(li[arr[1]]==null)\\n            {\\n                li[arr[1]]=new ArrayList();\\n                \\n            }\\n\\n            li[arr[0]].add(temp);\\n            li[arr[1]].add(temp1);\\n            \\n        }\\n        int vis[]=new int[n+1];\\n        return func(n,li,vis);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327454,
                "title": "c-and-dfs-concise-and-explained",
                "content": "# Intuition\\nSolve usind dfs, bfs or Dijkstra\\u2019s Algorithm. Here I have given the easily understandanble way to solve it using DFS.\\n\\n# Approach\\nTake the node 1 and the apply DFS, while going through each node store the distance between the node and take min of it. Node 1 will always reach to n so you dont have to worry about the other disconnected graph. Return the min length.\\n\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(bm)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<vector<pair<int,int>>> &adj, vector<bool>&vis, int &ans){\\n        vis[node] = 1;\\n        for(auto &[v, dis]:adj[node]){\\n            ans = min(ans, dis);\\n            if(vis[v] == false){\\n                vis[v] = true;\\n                ans = min(ans, dfs(v, adj, vis, ans));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>>adj(n+1);\\n       vector<bool>vis(n+1, false); \\n       for(auto x:roads){\\n           adj[x[0]].push_back({x[1], x[2]});\\n           adj[x[1]].push_back({x[0], x[2]});\\n       }\\n       int ans = INT_MAX;\\n       dfs(1, adj, vis, ans);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<vector<pair<int,int>>> &adj, vector<bool>&vis, int &ans){\\n        vis[node] = 1;\\n        for(auto &[v, dis]:adj[node]){\\n            ans = min(ans, dis);\\n            if(vis[v] == false){\\n                vis[v] = true;\\n                ans = min(ans, dfs(v, adj, vis, ans));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>>adj(n+1);\\n       vector<bool>vis(n+1, false); \\n       for(auto x:roads){\\n           adj[x[0]].push_back({x[1], x[2]});\\n           adj[x[1]].push_back({x[0], x[2]});\\n       }\\n       int ans = INT_MAX;\\n       dfs(1, adj, vis, ans);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327384,
                "title": "dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int &n, vector<vector<pair<int, int>>>& adj, vector<bool> &visit, int x){\\n        visit[x] = true;\\n        int res = INT_MAX;\\n        for(auto a: adj[x]){\\n            if(a.second < res) res = a.second;\\n            if(!visit[a.first]){\\n                res = min(bfs(n, adj, visit, a.first), res);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        for(auto& road : roads){\\n            adj[road[0]].push_back({road[1], road[2]});\\n            adj[road[1]].push_back({road[0], road[2]});\\n        }\\n        vector<bool> visit(n + 1, false);\\n        return bfs(n, adj, visit, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int &n, vector<vector<pair<int, int>>>& adj, vector<bool> &visit, int x){\\n        visit[x] = true;\\n        int res = INT_MAX;\\n        for(auto a: adj[x]){\\n            if(a.second < res) res = a.second;\\n            if(!visit[a.first]){\\n                res = min(bfs(n, adj, visit, a.first), res);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        for(auto& road : roads){\\n            adj[road[0]].push_back({road[1], road[2]});\\n            adj[road[1]].push_back({road[0], road[2]});\\n        }\\n        vector<bool> visit(n + 1, false);\\n        return bfs(n, adj, visit, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327352,
                "title": "minimum-score-disjoint-set-graph-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe most naive solution is to generate every possible path from 1 to n and find the minimum score. But this approach will result in TLE given the constraints.\\nThis question can be easily solved using disjoint set data structure.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First create a disjoint set from the given roads array\\n- For every bidirectional road, check if both the nodes parent are same and if they are same,\\n- check if one of the nodes parent is equal to node with label 1 parent or node with label n parent\\n- The condition in point 3 is necessary because it will ensure that the node always lies in the path from 1 to n as their parents will be same otherwise it will be disconnected graph\\n\\n# Code\\n```\\nclass DisjointSet {\\npublic:\\n    vector<int> rankArray, parent; \\n    DisjointSet(int n) {\\n        rankArray.resize(n+1, 0); \\n        parent.resize(n+1);\\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findPar(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return parent[node] = findPar(parent[node]);\\n    }\\n\\n    void unionMethod(int u , int v){\\n        u = findPar(u);\\n        v = findPar(v);\\n        if(u==v){\\n            return;\\n        }\\n        if(rankArray[u] < rankArray[v]){\\n            parent[u] = v;\\n        }\\n        else if(rankArray[v] < rankArray[u]){\\n            parent[v] = u;\\n        }\\n        else{\\n            parent[v] = u;\\n            rankArray[u]++;\\n        }\\n    }\\n};\\n\\nclass Solution {    \\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DisjointSet ds(n+1);\\n\\n        for(auto it: roads){\\n            ds.unionMethod(it[0], it[1]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(auto it: roads){\\n            if((ds.findPar(it[0]) == ds.findPar(it[1])) && (ds.findPar(it[0]) == ds.findPar(1)) || ds.findPar(it[0]) == ds.findPar(n)) {\\n                ans = min(ans, it[2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rankArray, parent; \\n    DisjointSet(int n) {\\n        rankArray.resize(n+1, 0); \\n        parent.resize(n+1);\\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findPar(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return parent[node] = findPar(parent[node]);\\n    }\\n\\n    void unionMethod(int u , int v){\\n        u = findPar(u);\\n        v = findPar(v);\\n        if(u==v){\\n            return;\\n        }\\n        if(rankArray[u] < rankArray[v]){\\n            parent[u] = v;\\n        }\\n        else if(rankArray[v] < rankArray[u]){\\n            parent[v] = u;\\n        }\\n        else{\\n            parent[v] = u;\\n            rankArray[u]++;\\n        }\\n    }\\n};\\n\\nclass Solution {    \\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DisjointSet ds(n+1);\\n\\n        for(auto it: roads){\\n            ds.unionMethod(it[0], it[1]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(auto it: roads){\\n            if((ds.findPar(it[0]) == ds.findPar(it[1])) && (ds.findPar(it[0]) == ds.findPar(1)) || ds.findPar(it[0]) == ds.findPar(n)) {\\n                ans = min(ans, it[2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327221,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<int>dist(n+1,INT_MAX/2);\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        pq.push(1);\\n        dist[1]=0;\\n        while(!pq.empty()){\\n            int node=pq.top();\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                if(dist[it.first]>it.second){\\n                    dist[it.first]=it.second;\\n                    pq.push(it.first);\\n                }\\n            }\\n        }\\n        int ans=INT_MAX/2;\\n        for(int i=2;i<=n;i++){\\n            ans=min(ans,dist[i]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<int>dist(n+1,INT_MAX/2);\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        pq.push(1);\\n        dist[1]=0;\\n        while(!pq.empty()){\\n            int node=pq.top();\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                if(dist[it.first]>it.second){\\n                    dist[it.first]=it.second;\\n                    pq.push(it.first);\\n                }\\n            }\\n        }\\n        int ans=INT_MAX/2;\\n        for(int i=2;i<=n;i++){\\n            ans=min(ans,dist[i]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327170,
                "title": "c-simple-solution",
                "content": "\\n\\n# Approach\\n\\nMy Approach is to traverse all nodes from the source node and check the minimum distance possible using depth first search\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<pair<int,int>>adj[],int &ans,set<int> &st,int n){\\n        if(st.size()!=n){\\n            st.insert(node);\\n            for(auto x:adj[node]){\\n            // cout<<typeid(x.second).name ()<<endl;\\n             ans=min(ans,x.second);\\n            if(st.find(x.first)==st.end()){\\n                ans=min(ans,x.second);\\n            dfs(x.first,adj,ans,st,n);\\n            }\\n        }\\n        }\\n        else{\\n            return;\\n        }\\n        \\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto x:roads){\\n            adj[x[1]].push_back({x[0],x[2]});\\n            adj[x[0]].push_back({x[1],x[2]});\\n        }\\n        int ans=1e9;\\n        set<int>st;\\n        dfs(1,adj,ans,st,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<pair<int,int>>adj[],int &ans,set<int> &st,int n){\\n        if(st.size()!=n){\\n            st.insert(node);\\n            for(auto x:adj[node]){\\n            // cout<<typeid(x.second).name ()<<endl;\\n             ans=min(ans,x.second);\\n            if(st.find(x.first)==st.end()){\\n                ans=min(ans,x.second);\\n            dfs(x.first,adj,ans,st,n);\\n            }\\n        }\\n        }\\n        else{\\n            return;\\n        }\\n        \\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto x:roads){\\n            adj[x[1]].push_back({x[0],x[2]});\\n            adj[x[0]].push_back({x[1],x[2]});\\n        }\\n        int ans=1e9;\\n        set<int>st;\\n        dfs(1,adj,ans,st,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3327155,
                "title": "easy-to-understand-well-documented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`Idea is to use Disjoint Set(Union Find) `\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  $$O(n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass DisjointSet{\\n    int[] parent;\\n    int[] size;\\n    \\n    //standard DSU template\\n\\n    DisjointSet(int n){\\n        parent=new int[n+1];\\n        size=new int[n+1];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            size[i]=1;\\n        }\\n    }\\n\\n    int findUltimateParent(int x){\\n        if(x==parent[x]) return x;\\n        return parent[x]=findUltimateParent(parent[x]);\\n    }\\n    void unionBySize(int u,int v){\\n        u=findUltimateParent(u);\\n        v=findUltimateParent(v);\\n\\n        if(u==v) return;\\n\\n        if(size[u]<size[v]){\\n            parent[u]=v;\\n            size[v]+=size[u];\\n        }else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n        }\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DisjointSet ds=new DisjointSet(n); //create the reference object \\n\\n        for(int[] road:roads){ //union the roads and link to their ultimate parents by path compression\\n            ds.unionBySize(road[0],road[1]);\\n        }\\n\\n        int ultimateParentOfOne=ds.findUltimateParent(1);//as the path ranges from 1 to n, since 1 is starting node so its ultimate parent is also 1\\n\\n        int res=Integer.MAX_VALUE;\\n\\n        for(int[] road:roads){\\n            //find the ultimate parent(parent after path compression)\\n            int u=ds.findUltimateParent(road[0]); \\n            int v=ds.findUltimateParent(road[1]);\\n\\n            if(u==ultimateParentOfOne || v==ultimateParentOfOne){ //multiple roads exits so check if either of road[0] & road[1] has the same ultimate parent as one\\n                res=Math.min(res,road[2]); //take the minimum distance if there exits a path between either of u or v and the distance ie road[2]\\n            }\\n        }\\n        return res; //return the resullt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Shortest Path"
                ],
                "code": "```\\nclass DisjointSet{\\n    int[] parent;\\n    int[] size;\\n    \\n    //standard DSU template\\n\\n    DisjointSet(int n){\\n        parent=new int[n+1];\\n        size=new int[n+1];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            size[i]=1;\\n        }\\n    }\\n\\n    int findUltimateParent(int x){\\n        if(x==parent[x]) return x;\\n        return parent[x]=findUltimateParent(parent[x]);\\n    }\\n    void unionBySize(int u,int v){\\n        u=findUltimateParent(u);\\n        v=findUltimateParent(v);\\n\\n        if(u==v) return;\\n\\n        if(size[u]<size[v]){\\n            parent[u]=v;\\n            size[v]+=size[u];\\n        }else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n        }\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DisjointSet ds=new DisjointSet(n); //create the reference object \\n\\n        for(int[] road:roads){ //union the roads and link to their ultimate parents by path compression\\n            ds.unionBySize(road[0],road[1]);\\n        }\\n\\n        int ultimateParentOfOne=ds.findUltimateParent(1);//as the path ranges from 1 to n, since 1 is starting node so its ultimate parent is also 1\\n\\n        int res=Integer.MAX_VALUE;\\n\\n        for(int[] road:roads){\\n            //find the ultimate parent(parent after path compression)\\n            int u=ds.findUltimateParent(road[0]); \\n            int v=ds.findUltimateParent(road[1]);\\n\\n            if(u==ultimateParentOfOne || v==ultimateParentOfOne){ //multiple roads exits so check if either of road[0] & road[1] has the same ultimate parent as one\\n                res=Math.min(res,road[2]); //take the minimum distance if there exits a path between either of u or v and the distance ie road[2]\\n            }\\n        }\\n        return res; //return the resullt\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327149,
                "title": "java-runtime-40-ms-beats-61-87-memory-98-mb-beats-79-86",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int[] e: roads){  //Fill the graph\\n            graph.get(e[0]-1).add(new int[]{e[1]-1,e[2]});\\n            graph.get(e[1]-1).add(new int[]{e[0]-1,e[2]});\\n        }\\n        return getMin(0,new boolean[n],graph); \\n    }\\n    private int getMin(int node, boolean[] visited,List<List<int[]>> graph){\\n        int min = Integer.MAX_VALUE;\\n        visited[node] = true;\\n        for(int[] child: graph.get(node)){\\n            min = Math.min(min,child[1]); \\n            if(!visited[child[0]]){\\n                 min = Math.min(min,getMin(child[0],visited,graph));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int[] e: roads){  //Fill the graph\\n            graph.get(e[0]-1).add(new int[]{e[1]-1,e[2]});\\n            graph.get(e[1]-1).add(new int[]{e[0]-1,e[2]});\\n        }\\n        return getMin(0,new boolean[n],graph); \\n    }\\n    private int getMin(int node, boolean[] visited,List<List<int[]>> graph){\\n        int min = Integer.MAX_VALUE;\\n        visited[node] = true;\\n        for(int[] child: graph.get(node)){\\n            min = Math.min(min,child[1]); \\n            if(!visited[child[0]]){\\n                 min = Math.min(min,getMin(child[0],visited,graph));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327146,
                "title": "c-easy-approach",
                "content": "\\n\\n# Code\\n```\\n\\n   int minScore(int n, vector<vector<int>> &roads)\\n{\\n    vector<int> bfs;\\n    vector<pair<int, int>> adj[n + 1];\\n    for (auto it : roads)\\n    {\\n        int v = it[0];\\n        int u = it[1];\\n        int wt = it[2];\\n        adj[v].push_back({u, wt});\\n        adj[u].push_back({v, wt});\\n    }\\n\\n    vector<int> visited(n + 1, 0);\\n    queue<int> q;\\n    q.push(1);\\n    visited[1] = 1;\\n    bfs.push_back(1);\\n    int ans = INT_MAX;\\n\\n    while (!q.empty())\\n    {\\n        int node = q.front();\\n        q.pop();\\n\\n        for (auto it : adj[node])\\n        {\\n            int adjnode = it.first;\\n            int wt = it.second;\\n            if (!visited[adjnode])\\n            {\\n                q.push(adjnode);\\n                visited[adjnode] = 1;\\n                bfs.push_back(adjnode);\\n            }\\n        }\\n    }\\n\\n    if (visited[n] == 0)\\n    {\\n        return -1;\\n    }\\n    else\\n    {\\n        for (int i = 0; i < bfs.size(); i++)\\n        {\\n            int node = bfs[i];\\n            for (auto it : adj[node])\\n            {\\n                ans = min(ans, it.second);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   int minScore(int n, vector<vector<int>> &roads)\\n{\\n    vector<int> bfs;\\n    vector<pair<int, int>> adj[n + 1];\\n    for (auto it : roads)\\n    {\\n        int v = it[0];\\n        int u = it[1];\\n        int wt = it[2];\\n        adj[v].push_back({u, wt});\\n        adj[u].push_back({v, wt});\\n    }\\n\\n    vector<int> visited(n + 1, 0);\\n    queue<int> q;\\n    q.push(1);\\n    visited[1] = 1;\\n    bfs.push_back(1);\\n    int ans = INT_MAX;\\n\\n    while (!q.empty())\\n    {\\n        int node = q.front();\\n        q.pop();\\n\\n        for (auto it : adj[node])\\n        {\\n            int adjnode = it.first;\\n            int wt = it.second;\\n            if (!visited[adjnode])\\n            {\\n                q.push(adjnode);\\n                visited[adjnode] = 1;\\n                bfs.push_back(adjnode);\\n            }\\n        }\\n    }\\n\\n    if (visited[n] == 0)\\n    {\\n        return -1;\\n    }\\n    else\\n    {\\n        for (int i = 0; i < bfs.size(); i++)\\n        {\\n            int node = bfs[i];\\n            for (auto it : adj[node])\\n            {\\n                ans = min(ans, it.second);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327109,
                "title": "very-easy-c-soln-dfs-beginner-friendly-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the minimun distance such that, that edge is somehow(doesnot matter directly connected or in-directly) connected to any of the 1 or n node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince, according to question we can have same road for multiple path, so we simply need to find an edge, such that it is minimum and is connected to 1 or n or may be both.\\nSo we will be using DFS algorithm and traverse the graph such that those edges which are somehow connected to n, then we will mark them present in our vis-vector. Once all the nodes are found then we simply find which will be the smallest edge, and that will be our ans(not we have to run forloop from 1-n to get ans, since graph may be disconnected). Atlast return the ans.\\n\\n**Please upvote guys if it helps.**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    void solve(unordered_map<int,vector<pair<int,int>>>& m,int i,vector<int> &vis){\\n        vis[i]=1;\\n        for(auto a:m[i]){\\n            if(vis[a.first]==0){\\n                solve(m,a.first,vis);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>>> m;\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            m[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            m[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        \\n        vector<int> vis(n+1,0);\\n        int ans = INT_MAX;\\n        solve(m,n,vis);\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            for(auto a:m[i])\\n            {\\n                if(vis[a.first]==1)\\n                    ans=min(ans,a.second);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    void solve(unordered_map<int,vector<pair<int,int>>>& m,int i,vector<int> &vis){\\n        vis[i]=1;\\n        for(auto a:m[i]){\\n            if(vis[a.first]==0){\\n                solve(m,a.first,vis);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>>> m;\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            m[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            m[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        \\n        vector<int> vis(n+1,0);\\n        int ans = INT_MAX;\\n        solve(m,n,vis);\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            for(auto a:m[i])\\n            {\\n                if(vis[a.first]==1)\\n                    ans=min(ans,a.second);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327088,
                "title": "solution-with-explanation",
                "content": "# Intuition\\nIn this question it is asking us to return the minimum score there is which is present in the connected graph from 1 to n.\\n\\n# Approach\\nWe will traverse in neighbour node of 1 and push them in stack. Keep the lowest cost in \"res\" variable and keep on traversing till we completely visit all the connected nodes. In next traversal push all the neighbour nodes of recently visited node to our stack.\\nAt the end we will have the smallest path that connect 2 node in res. Which will be our result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(int n, vector<vector<pair<int, int>>> &adj) {\\n        stack<int> list;\\n        list.push(1);\\n        vector<bool> visited(adj.size() - 1, false);\\n        int res = INT_MAX;\\n        while(list.size() != NULL){\\n            int see = list.top();\\n            list.pop();\\n            for(auto path: adj[see]){\\n                res = min(res, path.second);\\n                if(visited[path.first] != true){\\n                    visited[path.first] = true;\\n                    list.push(path.first);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        for (auto& road : roads) {\\n            adj[road[0]].push_back({road[1], road[2]});\\n            adj[road[1]].push_back({road[0], road[2]});\\n        }\\n        return bfs(n, adj);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(int n, vector<vector<pair<int, int>>> &adj) {\\n        stack<int> list;\\n        list.push(1);\\n        vector<bool> visited(adj.size() - 1, false);\\n        int res = INT_MAX;\\n        while(list.size() != NULL){\\n            int see = list.top();\\n            list.pop();\\n            for(auto path: adj[see]){\\n                res = min(res, path.second);\\n                if(visited[path.first] != true){\\n                    visited[path.first] = true;\\n                    list.push(path.first);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        for (auto& road : roads) {\\n            adj[road[0]].push_back({road[1], road[2]});\\n            adj[road[1]].push_back({road[0], road[2]});\\n        }\\n        return bfs(n, adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327087,
                "title": "easy-c-solution-dfs-recursion-connected-component",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[100001];\\n    int vis[100001];\\n    void dfs(int x)\\n    {\\n        vis[x]=1;\\n        for(int i=0;i<adj[x].size();i++)\\n        {\\n            if(vis[adj[x][i]]==0)\\n                dfs(adj[x][i]);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& ro) \\n    {\\n        int mi = INT_MAX;\\n        for(int i=0;i<ro.size();i++)\\n        {\\n            adj[ro[i][0]].push_back(ro[i][1]);\\n            adj[ro[i][1]].push_back(ro[i][0]);\\n        }\\n        dfs(1);\\n\\n        for(int i=0;i<ro.size();i++)\\n        {\\n            if(vis[ro[i][0]]==1)\\n                mi=min(mi,ro[i][2]);\\n        }\\n        return mi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[100001];\\n    int vis[100001];\\n    void dfs(int x)\\n    {\\n        vis[x]=1;\\n        for(int i=0;i<adj[x].size();i++)\\n        {\\n            if(vis[adj[x][i]]==0)\\n                dfs(adj[x][i]);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& ro) \\n    {\\n        int mi = INT_MAX;\\n        for(int i=0;i<ro.size();i++)\\n        {\\n            adj[ro[i][0]].push_back(ro[i][1]);\\n            adj[ro[i][1]].push_back(ro[i][0]);\\n        }\\n        dfs(1);\\n\\n        for(int i=0;i<ro.size();i++)\\n        {\\n            if(vis[ro[i][0]]==1)\\n                mi=min(mi,ro[i][2]);\\n        }\\n        return mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327071,
                "title": "bfs-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    int second;\\n     Pair(int first,int second){\\n         this.first=first;\\n         this.second=second;\\n     }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>>adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        boolean vis[]=new boolean[n+1];\\n        q.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(!q.isEmpty()){\\n            Pair p=q.poll();\\n            vis[p.first]=true;\\n            ans=Math.min(ans,p.second);\\n            for(Pair adjNode:adj.get(p.first)){\\n                if(!vis[adjNode.first]){\\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    int second;\\n     Pair(int first,int second){\\n         this.first=first;\\n         this.second=second;\\n     }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>>adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        boolean vis[]=new boolean[n+1];\\n        q.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(!q.isEmpty()){\\n            Pair p=q.poll();\\n            vis[p.first]=true;\\n            ans=Math.min(ans,p.second);\\n            for(Pair adjNode:adj.get(p.first)){\\n                if(!vis[adjNode.first]){\\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326939,
                "title": "rust-simple-w-important-detail-beats-100",
                "content": "# Intuition\\nIntuitively, this reads like a problem asking for either BFS or DFS, which it is. But relying too heavily on intuition and not reading the text carefully could result in taking the wrong approach. This problem throws a subtle curve ball at us. \\n\\nWhere this problem appears to be asking us to find the shortest path (minimal score) from `1` to `n`, it\\'s not. What it\\'s asking for is the shortest single road on *any* path from `1` to `n`. **Ugh!**\\n\\n# Approach\\nThis is a typical depth first search. We\\'re not trying to optimize the path, we\\'re just looking at all reachable *partial* paths from start to finish.\\n\\nEach road that is visited is compared to find the one with the lowest *score*, which is returned at the end. I use the concepts \\'score\\' and \\'distance\\' interchangeably for this problem.\\n\\nAn important detail that makes the problem simpler is we can travel the same road more than once (we don\\'t need to do this in code) which means ***any* road that is reachable from `1` is also on *some* path from `1` to `n`**. So we can take the shortest reachable road as the answer without doing anything extra.\\n\\nFrom the \"Notes\" section:\\n\\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\\n\\n# Complexity\\n- Time complexity: $O(V + E)$ where $V$ is vertices, and $E$ edges.\\n- Space complexity: $O(V + E)$\\n\\n# Code\\n```rust\\nimpl Solution {\\n    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n        let     n     = n as usize;\\n        let mut graph = vec![vec![]; n + 1];\\n        let mut visit = vec![false ; n + 1];\\n        let mut stack = vec![1];\\n\\n        for road in roads {\\n            graph[road[0] as usize].push((road[1], road[2]));\\n            graph[road[1] as usize].push((road[0], road[2]));\\n        }\\n\\n        let mut min_score = i32::MAX;\\n\\n        visit[1] = true;\\n\\n        while let Some(u) = stack.pop() {\\n            for &(v, d) in &graph[u as usize] {\\n\\n                min_score = min_score.min(d); // <-- Simple.\\n\\n                if !visit[v as usize] {\\n                    visit[v as usize] = true;\\n                    stack.push(v);\\n                }\\n            }\\n        }\\n        min_score\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n        let     n     = n as usize;\\n        let mut graph = vec![vec![]; n + 1];\\n        let mut visit = vec![false ; n + 1];\\n        let mut stack = vec![1];\\n\\n        for road in roads {\\n            graph[road[0] as usize].push((road[1], road[2]));\\n            graph[road[1] as usize].push((road[0], road[2]));\\n        }\\n\\n        let mut min_score = i32::MAX;\\n\\n        visit[1] = true;\\n\\n        while let Some(u) = stack.pop() {\\n            for &(v, d) in &graph[u as usize] {\\n\\n                min_score = min_score.min(d); // <-- Simple.\\n\\n                if !visit[v as usize] {\\n                    visit[v as usize] = true;\\n                    stack.push(v);\\n                }\\n            }\\n        }\\n        min_score\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326926,
                "title": "java-disjoint-set-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DisjointSet disjointSet = new DisjointSet(n+1);\\n\\n        for(int[] road: roads) {\\n            disjointSet.union(road[0], road[1], road[2]);\\n        }\\n\\n        int parent = disjointSet.findParent(1);\\n        return disjointSet.minCost(parent);\\n    }\\n}\\n\\nclass DisjointSet {\\n\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] minCost;\\n\\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        minCost = new int[n];\\n\\n        for(int i=1;i<n;i++) {\\n            parent[i] = i;\\n            minCost[i] = 10000;\\n        }\\n    }\\n\\n    public int minCost(int node){\\n        return minCost[node];\\n    }\\n\\n    public int findParent(int node) {\\n        if(parent[node] == node) return node;\\n        parent[node] = findParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    public void union(int u, int v, int distance) {\\n        int uPar = findParent(u);\\n        int vPar = findParent(v);\\n\\n        if(rank[uPar] < rank[vPar]) {\\n            parent[uPar] = vPar;\\n        } else if(rank[uPar] > rank[vPar]) {\\n            parent[vPar] = uPar;\\n        } else {\\n            parent[uPar] = vPar;\\n            rank[vPar]++;\\n        }\\n        int min = Math.min(minCost[uPar], minCost[vPar]);\\n        min = Math.min(min, distance);\\n        minCost[uPar] = min;\\n        minCost[vPar] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DisjointSet disjointSet = new DisjointSet(n+1);\\n\\n        for(int[] road: roads) {\\n            disjointSet.union(road[0], road[1], road[2]);\\n        }\\n\\n        int parent = disjointSet.findParent(1);\\n        return disjointSet.minCost(parent);\\n    }\\n}\\n\\nclass DisjointSet {\\n\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] minCost;\\n\\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        minCost = new int[n];\\n\\n        for(int i=1;i<n;i++) {\\n            parent[i] = i;\\n            minCost[i] = 10000;\\n        }\\n    }\\n\\n    public int minCost(int node){\\n        return minCost[node];\\n    }\\n\\n    public int findParent(int node) {\\n        if(parent[node] == node) return node;\\n        parent[node] = findParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    public void union(int u, int v, int distance) {\\n        int uPar = findParent(u);\\n        int vPar = findParent(v);\\n\\n        if(rank[uPar] < rank[vPar]) {\\n            parent[uPar] = vPar;\\n        } else if(rank[uPar] > rank[vPar]) {\\n            parent[vPar] = uPar;\\n        } else {\\n            parent[uPar] = vPar;\\n            rank[vPar]++;\\n        }\\n        int min = Math.min(minCost[uPar], minCost[vPar]);\\n        min = Math.min(min, distance);\\n        minCost[uPar] = min;\\n        minCost[vPar] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326900,
                "title": "c-dfs-faster-easy-to-understand",
                "content": "* ***DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // typical dfs function\\n    \\n    void dfs(vector<vector<pair<int, int>>>& adj, int u, vector<bool>& vis, int &mini)\\n    {\\n        // mark the curr node as visited\\n        \\n        vis[u] = true;\\n        \\n        // visit all the adjacent nodes\\n        \\n        for(auto x : adj[u])\\n        {\\n            int v = x.first;\\n            \\n            int curr_dist = x.second;\\n            \\n            // update mini\\n            \\n            mini = min(mini, curr_dist);\\n            \\n            if(vis[v] == false)\\n            {\\n                dfs(adj, v, vis, mini);\\n            }\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        // create adjacency list\\n        \\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        \\n        for(int i = 0; i < roads.size(); i++)\\n        {\\n            int a = roads[i][0];\\n            \\n            int b = roads[i][1];\\n            \\n            int dist = roads[i][2];\\n            \\n            adj[a].push_back({b, dist});\\n            \\n            adj[b].push_back({a, dist});\\n        }\\n        \\n        int mini = INT_MAX;\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(n + 1, false);\\n        \\n        // call dfs \\n        \\n        dfs(adj, 1, vis, mini);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // typical dfs function\\n    \\n    void dfs(vector<vector<pair<int, int>>>& adj, int u, vector<bool>& vis, int &mini)\\n    {\\n        // mark the curr node as visited\\n        \\n        vis[u] = true;\\n        \\n        // visit all the adjacent nodes\\n        \\n        for(auto x : adj[u])\\n        {\\n            int v = x.first;\\n            \\n            int curr_dist = x.second;\\n            \\n            // update mini\\n            \\n            mini = min(mini, curr_dist);\\n            \\n            if(vis[v] == false)\\n            {\\n                dfs(adj, v, vis, mini);\\n            }\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        // create adjacency list\\n        \\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        \\n        for(int i = 0; i < roads.size(); i++)\\n        {\\n            int a = roads[i][0];\\n            \\n            int b = roads[i][1];\\n            \\n            int dist = roads[i][2];\\n            \\n            adj[a].push_back({b, dist});\\n            \\n            adj[b].push_back({a, dist});\\n        }\\n        \\n        int mini = INT_MAX;\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(n + 1, false);\\n        \\n        // call dfs \\n        \\n        dfs(adj, 1, vis, mini);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326850,
                "title": "simple-c-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing DFS over the graph to mind the minimum value of a path in the connected graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDiving into the graph via the DFS, check if there is any path from current node to it\\'s connected nodes which is less than the previous minimum. Proceed till all nodes are visited\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as we need to visit all nodes\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWorst case of O(n^2) to build the graph adjacency list.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinScore(int n, int[][] roads) {\\n        List<List<(int x, int d)>> graph = new List<List<(int x, int d)>>();\\n        InitializeGraph(n, roads, graph);\\n\\n        int minDistance = int.MaxValue;\\n        bool[] v = new bool[n + 1];\\n        DFS(graph, ref minDistance, v, 1);\\n\\n        return minDistance;\\n    }\\n\\n    private void DFS(List<List<(int x, int d)>> graph, ref int minDistance, bool[] v, int cur)\\n    {\\n        if (v[cur])\\n            return;\\n\\n        v[cur] = true;\\n        foreach (var c in graph[cur])\\n        {\\n            if (c.d < minDistance)\\n                minDistance = c.d;\\n\\n            DFS(graph, ref minDistance, v, c.x);\\n        }\\n    }\\n\\n    private void InitializeGraph(int n, int[][] roads, List<List<(int x, int d)>> graph)\\n    {\\n        for (int i = 0; i <= n; i++)\\n        {\\n            graph.Add(new List<(int x, int d)>());\\n        }\\n\\n        for (int i = 0; i < roads.Length; i++)\\n        {\\n            int a = roads[i][0];\\n            int b = roads[i][1];\\n            int d = roads[i][2];\\n            graph[a].Add((b, d));\\n            graph[b].Add((a, d));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinScore(int n, int[][] roads) {\\n        List<List<(int x, int d)>> graph = new List<List<(int x, int d)>>();\\n        InitializeGraph(n, roads, graph);\\n\\n        int minDistance = int.MaxValue;\\n        bool[] v = new bool[n + 1];\\n        DFS(graph, ref minDistance, v, 1);\\n\\n        return minDistance;\\n    }\\n\\n    private void DFS(List<List<(int x, int d)>> graph, ref int minDistance, bool[] v, int cur)\\n    {\\n        if (v[cur])\\n            return;\\n\\n        v[cur] = true;\\n        foreach (var c in graph[cur])\\n        {\\n            if (c.d < minDistance)\\n                minDistance = c.d;\\n\\n            DFS(graph, ref minDistance, v, c.x);\\n        }\\n    }\\n\\n    private void InitializeGraph(int n, int[][] roads, List<List<(int x, int d)>> graph)\\n    {\\n        for (int i = 0; i <= n; i++)\\n        {\\n            graph.Add(new List<(int x, int d)>());\\n        }\\n\\n        for (int i = 0; i < roads.Length; i++)\\n        {\\n            int a = roads[i][0];\\n            int b = roads[i][1];\\n            int d = roads[i][2];\\n            graph[a].Add((b, d));\\n            graph[b].Add((a, d));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326774,
                "title": "efficient-solution-using-dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas it is given that we have to find minimum path between given nodes we get an intuition to solve it using dijkstra\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach will be dijkstra algorithm with slight modification\\n\\n# Complexity\\n- Time complexity: E*log(V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:|E|+|V|\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1]; //node dis\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int> dis(n+1,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; //dis node\\n        pq.push({INT_MAX,1});\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            int d=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                int edgeLen=it.second;\\n                if(min(edgeLen,d)<dis[adjNode]){\\n                    dis[adjNode]=min(edgeLen,d);\\n                    pq.push({min(edgeLen,d),adjNode});\\n                }\\n            }\\n        }\\n        return dis[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1]; //node dis\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int> dis(n+1,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; //dis node\\n        pq.push({INT_MAX,1});\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            int d=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                int edgeLen=it.second;\\n                if(min(edgeLen,d)<dis[adjNode]){\\n                    dis[adjNode]=min(edgeLen,d);\\n                    pq.push({min(edgeLen,d),adjNode});\\n                }\\n            }\\n        }\\n        return dis[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326746,
                "title": "swift-bfs",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        let graph = roads.reduce(into: [Int: [(node: Int, cost: Int)]]()) { graph, edge in\\n            graph[edge[0], default:[]].append((edge[1], edge[2]))  \\n            graph[edge[1], default:[]].append((edge[0], edge[2]))                                           \\n        }\\n        \\n        var q = [1]\\n        var minCost = Int.max\\n        var visited = Set(q)\\n        \\n        while !q.isEmpty  {\\n\\t\\t\\tlet node = q.removeFirst()\\n            q += graph[node]!\\n                    .reduce(into: [Int]()) { newElements, adjacent in \\n                        if visited.insert(adjacent.node).inserted {\\n                            newElements.append(adjacent.node)\\n                        }\\n                        minCost = min(minCost, adjacent.cost)\\n                    }\\n        }\\n        \\n        return minCost\\n    }\\n}\\n```\\n\\n---\\n\\n**See Also: --> [FASTER: Union Find Approach](https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/discuss/3326695/Swift-or-Union-Find)**",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        let graph = roads.reduce(into: [Int: [(node: Int, cost: Int)]]()) { graph, edge in\\n            graph[edge[0], default:[]].append((edge[1], edge[2]))  \\n            graph[edge[1], default:[]].append((edge[0], edge[2]))                                           \\n        }\\n        \\n        var q = [1]\\n        var minCost = Int.max\\n        var visited = Set(q)\\n        \\n        while !q.isEmpty  {\\n\\t\\t\\tlet node = q.removeFirst()\\n            q += graph[node]!\\n                    .reduce(into: [Int]()) { newElements, adjacent in \\n                        if visited.insert(adjacent.node).inserted {\\n                            newElements.append(adjacent.node)\\n                        }\\n                        minCost = min(minCost, adjacent.cost)\\n                    }\\n        }\\n        \\n        return minCost\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326703,
                "title": "c-union-find",
                "content": "# Intuition\\nThe minimum score is actually the minimum road in the same group which each of nodes can invite each other. Hence, union find is a suitable solution.\\n\\n# Approach\\nUse union find to find out group that each node belongs in, and then calculate minimum road which node belongs in the same group with node `1`, since `1` and `n` has at least one path, it is unnecessary to handle different group case.\\n\\n# Complexity\\nM = total road count\\nN = total node count\\n- Time complexity: O(Mlog(\\uD835\\uDEFC(N)))\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> uf;\\n    void union_(int a, int b) {\\n        int rootA = find(a),\\n            rootB = find(b);\\n        if (rootA < rootB) {\\n            uf[rootB] = rootA;\\n        } else {\\n            uf[rootA] = rootB;\\n        }\\n    }\\n    int find(int x) {\\n        if (uf[x] == x) {\\n            return x;\\n        }\\n        uf[x] = find(uf[x]);\\n        return uf[x];\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        uf.resize(n + 1);\\n        for (int i = 1; i <= n; ++i) {\\n            uf[i] = i;\\n        }\\n\\n        for (auto &road : roads) {\\n            union_(road[0], road[1]);\\n        }\\n\\n        int group = find(1), minRoad = INT_MAX;\\n        for (auto &road : roads) {\\n            if (find(road[0]) == group) {\\n                minRoad = min(minRoad, road[2]);\\n            }\\n        }\\n        return minRoad;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> uf;\\n    void union_(int a, int b) {\\n        int rootA = find(a),\\n            rootB = find(b);\\n        if (rootA < rootB) {\\n            uf[rootB] = rootA;\\n        } else {\\n            uf[rootA] = rootB;\\n        }\\n    }\\n    int find(int x) {\\n        if (uf[x] == x) {\\n            return x;\\n        }\\n        uf[x] = find(uf[x]);\\n        return uf[x];\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        uf.resize(n + 1);\\n        for (int i = 1; i <= n; ++i) {\\n            uf[i] = i;\\n        }\\n\\n        for (auto &road : roads) {\\n            union_(road[0], road[1]);\\n        }\\n\\n        int group = find(1), minRoad = INT_MAX;\\n        for (auto &road : roads) {\\n            if (find(road[0]) == group) {\\n                minRoad = min(minRoad, road[2]);\\n            }\\n        }\\n        return minRoad;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326636,
                "title": "cpp-solution-easy-approach-beats-84",
                "content": "# Approach\\nWe can\\'t find minimum path score directly by traversing in roads 2d-vector because graph might be disconnected. So, First we mark the visited nodes in vis vector by using bfs then we find minimum score by checking whether ai and bi are visited in roads and calculate minimum value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //create adjacency list of roads to make it a graph\\n        vector<pair<int, int>> adj[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        \\n        //mark possible visitable nodes \\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1), vis[1]=1;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it: adj[node]){\\n                if(!vis[it.first]){\\n                    q.push(it.first);\\n                    vis[it.first]=1;\\n                }\\n            }\\n        }\\n            \\n        //find minimum path score among visited nodes\\n        int mini_path = INT_MAX;\\n        for(int i=0; i<roads.size(); i++){\\n            if(vis[roads[i][0]] && vis[roads[i][1]] && roads[i][2] < mini_path)\\n                mini_path = roads[i][2];\\n        }\\n\\n        return mini_path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //create adjacency list of roads to make it a graph\\n        vector<pair<int, int>> adj[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        \\n        //mark possible visitable nodes \\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1), vis[1]=1;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it: adj[node]){\\n                if(!vis[it.first]){\\n                    q.push(it.first);\\n                    vis[it.first]=1;\\n                }\\n            }\\n        }\\n            \\n        //find minimum path score among visited nodes\\n        int mini_path = INT_MAX;\\n        for(int i=0; i<roads.size(); i++){\\n            if(vis[roads[i][0]] && vis[roads[i][1]] && roads[i][2] < mini_path)\\n                mini_path = roads[i][2];\\n        }\\n\\n        return mini_path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152624,
                "title": "c-python-simple-bfs",
                "content": "# C++ code \\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int MAX=1e9+7;\\n        vector <int> dist(n+1,MAX);\\n        vector <vector<pair<int,int>>> graph(n+1);\\n        for (auto x:roads){\\n            int u=x[0],v=x[1],wt=x[2];\\n            graph[u].push_back(make_pair(wt,v));\\n            graph[v].push_back(make_pair(wt,u));\\n        }\\n        queue <pair<int,int>> q;\\n        q.push(make_pair(MAX,1));\\n        while (!q.empty()){\\n            int wt=q.front().first,node=q.front().second;\\n            q.pop();\\n            int mmin;\\n            for (auto x:graph[node]){\\n                int n_wt=x.first,nei=x.second;\\n                mmin=min(wt,n_wt);\\n                if (mmin<dist[nei]) {\\n                    dist[nei]=mmin;\\n                    q.push(make_pair(mmin,nei));\\n                }\\n            }\\n        }\\n        return dist[n];\\n    }\\n};\\n```\\n\\n# Python Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        MAX=10**10\\n        dist=[MAX]*(n+1)\\n        graph=defaultdict(list)\\n        for u,v,wt in roads:\\n            graph[u].append((wt,v))\\n            graph[v].append((wt,u))\\n        dq=deque()\\n        dq.append((MAX,1))\\n        while dq:\\n            wt,node=dq.popleft()\\n            for n_wt,nei in graph[node]:\\n                mmin=min(wt,n_wt)\\n                if mmin<dist[nei]:\\n                    dist[nei]=mmin\\n                    dq.append((mmin,nei))\\n        return dist[n]\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int MAX=1e9+7;\\n        vector <int> dist(n+1,MAX);\\n        vector <vector<pair<int,int>>> graph(n+1);\\n        for (auto x:roads){\\n            int u=x[0],v=x[1],wt=x[2];\\n            graph[u].push_back(make_pair(wt,v));\\n            graph[v].push_back(make_pair(wt,u));\\n        }\\n        queue <pair<int,int>> q;\\n        q.push(make_pair(MAX,1));\\n        while (!q.empty()){\\n            int wt=q.front().first,node=q.front().second;\\n            q.pop();\\n            int mmin;\\n            for (auto x:graph[node]){\\n                int n_wt=x.first,nei=x.second;\\n                mmin=min(wt,n_wt);\\n                if (mmin<dist[nei]) {\\n                    dist[nei]=mmin;\\n                    q.push(make_pair(mmin,nei));\\n                }\\n            }\\n        }\\n        return dist[n];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        MAX=10**10\\n        dist=[MAX]*(n+1)\\n        graph=defaultdict(list)\\n        for u,v,wt in roads:\\n            graph[u].append((wt,v))\\n            graph[v].append((wt,u))\\n        dq=deque()\\n        dq.append((MAX,1))\\n        while dq:\\n            wt,node=dq.popleft()\\n            for n_wt,nei in graph[node]:\\n                mmin=min(wt,n_wt)\\n                if mmin<dist[nei]:\\n                    dist[nei]=mmin\\n                    dq.append((mmin,nei))\\n        return dist[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008598,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBFS TRAVERSAL\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[[] for _ in range(n+1)]\\n        for i,j,d in roads:\\n            adj[i].append((d,j))\\n            adj[j].append((d,i))\\n        st=[1]\\n        visited=[0]*(n+1)\\n        visited[1]=1\\n        mn=float(\"infinity\")\\n        while st:\\n            x=st.pop(0)\\n            for dt,i in adj[x]:\\n                # print(dt,i)\\n                if visited[i]==0:\\n                    # print(dt)\\n                    st.append(i)\\n                    visited[i]=1\\n                mn=min(mn,dt)\\n        return mn\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[[] for _ in range(n+1)]\\n        for i,j,d in roads:\\n            adj[i].append((d,j))\\n            adj[j].append((d,i))\\n        st=[1]\\n        visited=[0]*(n+1)\\n        visited[1]=1\\n        mn=float(\"infinity\")\\n        while st:\\n            x=st.pop(0)\\n            for dt,i in adj[x]:\\n                # print(dt,i)\\n                if visited[i]==0:\\n                    # print(dt)\\n                    st.append(i)\\n                    visited[i]=1\\n                mn=min(mn,dt)\\n        return mn\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979600,
                "title": "dfs-super-simple",
                "content": "# Approach\\nWe simply first create our undirected graph $G$. We then perform a DFS traversal starting at node $1$. We are just interested in finding the smallest edge weight that connects some nodes that node $1$ is connected to. To do so, we just maintain a set of visited edges instead of visited nodes (as we want to explore every edge). Return the smallest weight found.\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        G = collections.defaultdict(dict)\\n        for u, v, d in roads:\\n            G[u][v] = d\\n            G[v][u] = d\\n         \\n        smallest, visited = float(\"inf\"), set()\\n        \\n        def dfs(node):\\n            nonlocal smallest\\n            \\n            for nei in G[node].keys():\\n                if (node, nei) not in visited and (nei, node) not in visited:\\n                    smallest = min(smallest, G[node][nei])\\n                    visited.add((node, nei))\\n                    dfs(nei)\\n                    \\n            \\n        dfs(1)\\n        return smallest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        G = collections.defaultdict(dict)\\n        for u, v, d in roads:\\n            G[u][v] = d\\n            G[v][u] = d\\n         \\n        smallest, visited = float(\"inf\"), set()\\n        \\n        def dfs(node):\\n            nonlocal smallest\\n            \\n            for nei in G[node].keys():\\n                if (node, nei) not in visited and (nei, node) not in visited:\\n                    smallest = min(smallest, G[node][nei])\\n                    visited.add((node, nei))\\n                    dfs(nei)\\n                    \\n            \\n        dfs(1)\\n        return smallest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944646,
                "title": "c",
                "content": "```\\n//UNION\\n//father, count, min\\nint findFather(int** UNION, int val){\\n    int k = val;\\n    while(k != UNION[k][0]){\\n        k = UNION[k][0] ;\\n    }    \\n    return k;\\n}\\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){ \\n    int** UNION = malloc((n+1) * sizeof(int*));\\n    for(int i = 1; i <= n; i++){\\n        UNION[i] = malloc(3 * sizeof(int));\\n        UNION[i][0] = i;\\n        UNION[i][1] = 1;\\n        UNION[i][2] = INT_MAX;\\n    }\\n    \\n    for(int i = 0; i < roadsSize; i++){\\n        int a = findFather( UNION, roads[i][0] );\\n        int b = findFather( UNION, roads[i][1] );\\n        int min = fmin(roads[i][2],  fmin(UNION[a][2], UNION[b][2]) );\\n        if(a == b){\\n            UNION[a][2] = min;\\n            continue;\\n        }\\n        if(UNION[a][1] >= UNION[b][1]){\\n            UNION[b][0] = a;\\n            UNION[a][2] = min;\\n            UNION[a][1] += UNION[b][1];\\n        }\\n        else{\\n            UNION[a][0] = b;\\n            UNION[b][2] = min;\\n            UNION[b][1] += UNION[a][1];\\n        }\\n    }\\n    int first = findFather(UNION, 1);\\n    int last  = findFather(UNION, n);\\n    int ans ;\\n    if(first != last)\\n        ans =  -1;\\n    else\\n        ans = UNION[first][2];\\n    \\n    for(int i = 1; i <= n; i++){\\n        free(UNION[i]);\\n    }\\n    free(UNION);\\n    return ans;\\n        \\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n//UNION\\n//father, count, min\\nint findFather(int** UNION, int val){\\n    int k = val;\\n    while(k != UNION[k][0]){\\n        k = UNION[k][0] ;\\n    }    \\n    return k;\\n}\\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){ \\n    int** UNION = malloc((n+1) * sizeof(int*));\\n    for(int i = 1; i <= n; i++){\\n        UNION[i] = malloc(3 * sizeof(int));\\n        UNION[i][0] = i;\\n        UNION[i][1] = 1;\\n        UNION[i][2] = INT_MAX;\\n    }\\n    \\n    for(int i = 0; i < roadsSize; i++){\\n        int a = findFather( UNION, roads[i][0] );\\n        int b = findFather( UNION, roads[i][1] );\\n        int min = fmin(roads[i][2],  fmin(UNION[a][2], UNION[b][2]) );\\n        if(a == b){\\n            UNION[a][2] = min;\\n            continue;\\n        }\\n        if(UNION[a][1] >= UNION[b][1]){\\n            UNION[b][0] = a;\\n            UNION[a][2] = min;\\n            UNION[a][1] += UNION[b][1];\\n        }\\n        else{\\n            UNION[a][0] = b;\\n            UNION[b][2] = min;\\n            UNION[b][1] += UNION[a][1];\\n        }\\n    }\\n    int first = findFather(UNION, 1);\\n    int last  = findFather(UNION, n);\\n    int ans ;\\n    if(first != last)\\n        ans =  -1;\\n    else\\n        ans = UNION[first][2];\\n    \\n    for(int i = 1; i <= n; i++){\\n        free(UNION[i]);\\n    }\\n    free(UNION);\\n    return ans;\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2935755,
                "title": "c-dfs-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n# DFS\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i, vector<int>& v, int& ans, vector<vector<int>>adj[]){\\n        if(v[i]){return;}\\n        v[i]=1;\\n        for(auto it: adj[i]){\\n            ans=min(ans, it[1]);\\n            dfs(it[0], v, ans, adj);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>>adj[n];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]-1].push_back({roads[i][1]-1, roads[i][2]});\\n            adj[roads[i][1]-1].push_back({roads[i][0]-1, roads[i][2]});\\n        }\\n        vector<int>v(n, 0);\\n        int ans=INT_MAX;\\n        dfs(0, v, ans, adj);\\n        return ans;\\n    }\\n};\\n```\\n# BFS\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans=INT_MAX;\\n        queue<pair<int, int>>q;\\n        vector<vector<int>>adj[n];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]-1].push_back({roads[i][1]-1, roads[i][2]});\\n            adj[roads[i][1]-1].push_back({roads[i][0]-1, roads[i][2]});\\n        }\\n        vector<int>v(n, 0);\\n        q.push({0, ans});\\n        while(!q.empty()){\\n            int pos=q.front().first, cnt=q.front().second;\\n            v[pos]=1;\\n            ans=min(ans, cnt);\\n            for(auto it: adj[pos]){\\n                if(!v[it[0]]){\\n                    q.push({it[0], it[1]});\\n                }\\n            }\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, vector<int>& v, int& ans, vector<vector<int>>adj[]){\\n        if(v[i]){return;}\\n        v[i]=1;\\n        for(auto it: adj[i]){\\n            ans=min(ans, it[1]);\\n            dfs(it[0], v, ans, adj);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>>adj[n];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]-1].push_back({roads[i][1]-1, roads[i][2]});\\n            adj[roads[i][1]-1].push_back({roads[i][0]-1, roads[i][2]});\\n        }\\n        vector<int>v(n, 0);\\n        int ans=INT_MAX;\\n        dfs(0, v, ans, adj);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans=INT_MAX;\\n        queue<pair<int, int>>q;\\n        vector<vector<int>>adj[n];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]-1].push_back({roads[i][1]-1, roads[i][2]});\\n            adj[roads[i][1]-1].push_back({roads[i][0]-1, roads[i][2]});\\n        }\\n        vector<int>v(n, 0);\\n        q.push({0, ans});\\n        while(!q.empty()){\\n            int pos=q.front().first, cnt=q.front().second;\\n            v[pos]=1;\\n            ans=min(ans, cnt);\\n            for(auto it: adj[pos]){\\n                if(!v[it[0]]){\\n                    q.push({it[0], it[1]});\\n                }\\n            }\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886810,
                "title": "saving-space-complexity-dfs-edge-traversal-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(E+V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int, int>> graph[], int node, vector<int>& visited, unordered_set<int>& inpath){\\n        for(int i=0; i<graph[node].size(); i++){\\n            int n = graph[node][i].first;\\n            int d = graph[node][i].second;\\n            if(!visited[n]){\\n                inpath.insert(n);\\n                visited[n]=1;\\n                dfs(graph, n, visited, inpath);\\n            }\\n        }\\n        return;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> graph[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            int a = roads[i][0], b = roads[i][1], c= roads[i][2];\\n            graph[a].push_back({b,c});\\n            graph[b].push_back({a,c});\\n        }        \\n\\n        // run a dfs and insert all the vertices that comes in the path\\n        unordered_set<int> inpath;\\n        inpath.insert(1);\\n        vector<int> visited(n+1, 0);\\n        visited[1]=1;\\n        dfs(graph, 1, visited, inpath);\\n\\n        // traverse through the edge list and if both the vertices in the edge is there in the set than that edge is there in the possible path between 1 and n\\n        // find the smallest of such edge\\n        int ans = INT_MAX;\\n        for(int i=0; i<roads.size(); i++){\\n            int a = roads[i][0], b= roads[i][1], c = roads[i][2];\\n            if(inpath.count(a) && inpath.count(b)){\\n                ans = min(ans, c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int, int>> graph[], int node, vector<int>& visited, unordered_set<int>& inpath){\\n        for(int i=0; i<graph[node].size(); i++){\\n            int n = graph[node][i].first;\\n            int d = graph[node][i].second;\\n            if(!visited[n]){\\n                inpath.insert(n);\\n                visited[n]=1;\\n                dfs(graph, n, visited, inpath);\\n            }\\n        }\\n        return;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> graph[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            int a = roads[i][0], b = roads[i][1], c= roads[i][2];\\n            graph[a].push_back({b,c});\\n            graph[b].push_back({a,c});\\n        }        \\n\\n        // run a dfs and insert all the vertices that comes in the path\\n        unordered_set<int> inpath;\\n        inpath.insert(1);\\n        vector<int> visited(n+1, 0);\\n        visited[1]=1;\\n        dfs(graph, 1, visited, inpath);\\n\\n        // traverse through the edge list and if both the vertices in the edge is there in the set than that edge is there in the possible path between 1 and n\\n        // find the smallest of such edge\\n        int ans = INT_MAX;\\n        for(int i=0; i<roads.size(); i++){\\n            int a = roads[i][0], b= roads[i][1], c = roads[i][2];\\n            if(inpath.count(a) && inpath.count(b)){\\n                ans = min(ans, c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881745,
                "title": "graphs-dsu-union-find-explained-clearly-easy-understanding-beginners",
                "content": "# Intuition\\n* Pre-requisite : DSU\\n* It is clearly stated that there exists atleast one path between 1 and n.\\n* So if the graph is not connected there will be more than one group in the graph and there will be leader for each group and that can be easily found by standard DSU template. \\n* So if we somehow able to find the leader of the group where 1 and n exists, next part is to find the minimum distance in that group as we can use any path any number of times.\\n\\n# Approach\\n* Task-1 making connections and finding leaders of each group using DSU data structure.\\n* Task-2 iterating through the graph again and finding the minimum distance of the edge that exists in the group where 1 and n exists.\\n\\n# Complexity\\n- Time complexity:\\n    * DSU - |V+E| * $$(4*alpha)$$\\n    * finding minimum - |V+E| * $$(4*alpha)$$\\n    * Total - $$ O(|V+E|) $$\\n\\n- Space complexity:\\n   * $$O(|V+E|)$$ for dictionary\\n\\n# Code\\n```\\nclass Solution:\\n    def find(self, node, dictu):\\n        if node not in dictu:\\n            dictu[node] = [node, 1]\\n        elif dictu[node][0] != node:\\n            dictu[node][0] = self.find(dictu[node][0], dictu)\\n        return dictu[node][0]\\n\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        dictu = defaultdict(int)\\n        ## TASK-1 making connections using DSU\\n        for i in roads:\\n            p1 = self.find(i[0], dictu)\\n            p2 = self.find(i[1], dictu)\\n            if p1 != p2:\\n                if dictu[p1][1] >= dictu[p2][1]:\\n                    dictu[p2][0] = p1\\n                    dictu[i[0]][0] = p1\\n                    dictu[i[1]][0] = p1\\n                    dictu[p1][1] += dictu[p2][1]\\n                else:\\n                    dictu[p1][0] = p2\\n                    dictu[i[0]][0] = p2\\n                    dictu[i[1]][0] = p2\\n                    dictu[p2][1] += dictu[p1][1]\\n        ## finding group leader for node 1 and n.\\n        result_parent = self.find(dictu[1][0], dictu)\\n        ## TASK-2\\n        mini = sys.maxsize\\n        print(dictu)\\n        for i in roads:\\n            p1 = self.find(i[0], dictu)\\n            p2 = self.find(i[1], dictu)\\n            if p1 == result_parent or p2 == result_parent:\\n                mini = min(mini, i[-1])\\n        return mini\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def find(self, node, dictu):\\n        if node not in dictu:\\n            dictu[node] = [node, 1]\\n        elif dictu[node][0] != node:\\n            dictu[node][0] = self.find(dictu[node][0], dictu)\\n        return dictu[node][0]\\n\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        dictu = defaultdict(int)\\n        ## TASK-1 making connections using DSU\\n        for i in roads:\\n            p1 = self.find(i[0], dictu)\\n            p2 = self.find(i[1], dictu)\\n            if p1 != p2:\\n                if dictu[p1][1] >= dictu[p2][1]:\\n                    dictu[p2][0] = p1\\n                    dictu[i[0]][0] = p1\\n                    dictu[i[1]][0] = p1\\n                    dictu[p1][1] += dictu[p2][1]\\n                else:\\n                    dictu[p1][0] = p2\\n                    dictu[i[0]][0] = p2\\n                    dictu[i[1]][0] = p2\\n                    dictu[p2][1] += dictu[p1][1]\\n        ## finding group leader for node 1 and n.\\n        result_parent = self.find(dictu[1][0], dictu)\\n        ## TASK-2\\n        mini = sys.maxsize\\n        print(dictu)\\n        for i in roads:\\n            p1 = self.find(i[0], dictu)\\n            p2 = self.find(i[1], dictu)\\n            if p1 == result_parent or p2 == result_parent:\\n                mini = min(mini, i[-1])\\n        return mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881591,
                "title": "swift-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    var adj: [Int: [(Int, Int)]] = [:]\\n    var visited: Set<Int> = []\\n    var result = Int.max\\n\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        buildGraph(roads)\\n\\n        dfs(1, n)\\n\\n        return result\\n    }\\n\\n\\n    func buildGraph(_ roads: [[Int]]) {\\n        for road in roads {\\n            adj[road[0], default: []].append((road[1], road[2]))\\n            adj[road[1], default: []].append((road[0], road[2]))\\n        }\\n    }\\n\\n    func dfs(_ start: Int, _ n: Int) {\\n\\n        guard let childs = adj[start] else {\\n            return\\n        }\\n\\n        visited.insert(start)\\n\\n        for child in childs {\\n\\n            let destination = child.0\\n            let weight = child.1\\n            result = min(result, weight)\\n\\n            if visited.contains(destination) {\\n                continue\\n            } \\n\\n            dfs(destination, n)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    var adj: [Int: [(Int, Int)]] = [:]\\n    var visited: Set<Int> = []\\n    var result = Int.max\\n\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        buildGraph(roads)\\n\\n        dfs(1, n)\\n\\n        return result\\n    }\\n\\n\\n    func buildGraph(_ roads: [[Int]]) {\\n        for road in roads {\\n            adj[road[0], default: []].append((road[1], road[2]))\\n            adj[road[1], default: []].append((road[0], road[2]))\\n        }\\n    }\\n\\n    func dfs(_ start: Int, _ n: Int) {\\n\\n        guard let childs = adj[start] else {\\n            return\\n        }\\n\\n        visited.insert(start)\\n\\n        for child in childs {\\n\\n            let destination = child.0\\n            let weight = child.1\\n            result = min(result, weight)\\n\\n            if visited.contains(destination) {\\n                continue\\n            } \\n\\n            dfs(destination, n)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878889,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<bool> vis;// visited array\\n    vector<int> c; // will store require component \\n    void dfs(int src,vector<int>&c,vector<pair<int,int>> g[]){\\n        vis[src] = true;\\n        c.push_back(src);\\n        for(auto &[child,_]: g[src]){\\n            if(!vis[child]) dfs(child,c,g);\\n        }\\n    }\\n    int getMinPath(vector<pair<int,int>> g[]){\\n        int mn = INT_MAX;\\n        for(int &u: c){\\n            //getting minimum from the required component as it\\'s array of pair of vectors we cant do \"g[u].second\" so i\\'ve run the for-each loop but we can also extract the element by defining the iterator \\n            for(auto e: g[u])\\n                mn = min(e.second,mn);\\n        }\\n        return mn;\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vis.resize(n+1,false);\\n        //creating adjacency list of the given graph\\n        vector<pair<int,int>> g[n+1];\\n        for(auto &road: roads){\\n            g[road[0]].push_back({road[1],road[2]});\\n            g[road[1]].push_back({road[0],road[2]});\\n        }\\n        \\n        //getting the component in which both the first and last node is present \\n        for(int i=1; i<=n; ++i){\\n            if(!vis[i]){\\n                c.clear();\\n                dfs(i,c,g);\\n                if(vis[1] && vis[n]) break;\\n            }\\n        }\\n        return getMinPath(g);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<bool> vis;// visited array\\n    vector<int> c; // will store require component \\n    void dfs(int src,vector<int>&c,vector<pair<int,int>> g[]){\\n        vis[src] = true;\\n        c.push_back(src);\\n        for(auto &[child,_]: g[src]){\\n            if(!vis[child]) dfs(child,c,g);\\n        }\\n    }\\n    int getMinPath(vector<pair<int,int>> g[]){\\n        int mn = INT_MAX;\\n        for(int &u: c){\\n            //getting minimum from the required component as it\\'s array of pair of vectors we cant do \"g[u].second\" so i\\'ve run the for-each loop but we can also extract the element by defining the iterator \\n            for(auto e: g[u])\\n                mn = min(e.second,mn);\\n        }\\n        return mn;\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vis.resize(n+1,false);\\n        //creating adjacency list of the given graph\\n        vector<pair<int,int>> g[n+1];\\n        for(auto &road: roads){\\n            g[road[0]].push_back({road[1],road[2]});\\n            g[road[1]].push_back({road[0],road[2]});\\n        }\\n        \\n        //getting the component in which both the first and last node is present \\n        for(int i=1; i<=n; ++i){\\n            if(!vis[i]){\\n                c.clear();\\n                dfs(i,c,g);\\n                if(vis[1] && vis[n]) break;\\n            }\\n        }\\n        return getMinPath(g);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878168,
                "title": "java-easy-solution-with-modified-union-find",
                "content": "# Intuition\\nSince we can contain the same road multiple times and this graph may not be connected, so we just need to find the min cost for each connected component. \\nThus, it is easier to think of using **Union Find**.\\n\\n# Approach\\nHere we just modified the `Union Find` class by adding the `minCost` array for the whole graph. \\nIt is very easy for us to solve this question with only one `for-loop`.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < roads.length; ++i) {\\n            uf.union(roads[i][0] - 1, roads[i][1] - 1, roads[i][2]);\\n        }\\n        return uf.findCost(0);\\n    }\\n}\\n    \\nclass UnionFind {\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] minCost;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n\\n        /* record the min cost of connected components where each node is located */\\n        minCost = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n            minCost[i] = Integer.MAX_VALUE;\\n        }\\n    }\\n    public void union(int a, int b, int cost) {\\n        int rootA = find(a);\\n        int rootB = find(b);\\n\\n        /* modified place */\\n        minCost[rootA] = Math.min(cost, Math.min(minCost[rootA], minCost[rootB]));\\n        minCost[rootB] = minCost[rootA];\\n        /* modified place */\\n\\n        if (rootA == rootB) return;\\n\\n        if (rank[rootA] < rank[rootB]) {\\n            parent[rootA] = rootB;\\n        } else {\\n            parent[rootB] = rootA;\\n            if (rank[rootA] == rank[rootB]) rank[rootA] += 1;\\n        }\\n    }\\n    public int find(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = find(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n    public int findCost(int i) {\\n        return minCost[find(i)];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < roads.length; ++i) {\\n            uf.union(roads[i][0] - 1, roads[i][1] - 1, roads[i][2]);\\n        }\\n        return uf.findCost(0);\\n    }\\n}\\n    \\nclass UnionFind {\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] minCost;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n\\n        /* record the min cost of connected components where each node is located */\\n        minCost = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n            minCost[i] = Integer.MAX_VALUE;\\n        }\\n    }\\n    public void union(int a, int b, int cost) {\\n        int rootA = find(a);\\n        int rootB = find(b);\\n\\n        /* modified place */\\n        minCost[rootA] = Math.min(cost, Math.min(minCost[rootA], minCost[rootB]));\\n        minCost[rootB] = minCost[rootA];\\n        /* modified place */\\n\\n        if (rootA == rootB) return;\\n\\n        if (rank[rootA] < rank[rootB]) {\\n            parent[rootA] = rootB;\\n        } else {\\n            parent[rootB] = rootA;\\n            if (rank[rootA] == rank[rootB]) rank[rootA] += 1;\\n        }\\n    }\\n    public int find(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = find(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n    public int findCost(int i) {\\n        return minCost[find(i)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878142,
                "title": "dijkstra-dfs-unionfind",
                "content": "Please upvote if you found this useful\\nDFS:\\n\\n```\\nclass Solution {\\n    int mindist = Integer.MAX_VALUE;\\n\\n    public int minScore(int n, int[][] roads) {\\n\\n        HashMap<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] f: roads) {\\n            graph.putIfAbsent(f[0], new ArrayList<>());\\n            graph.putIfAbsent(f[1], new ArrayList<>());\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n            graph.get(f[1]).add(new int[]{f[0], f[2]});\\n        }\\n        boolean[] vis = new boolean[n + 1];\\n        vis[1] = true;\\n        dfs(1, graph, vis, Integer.MAX_VALUE);\\n        return mindist;\\n    }\\n    private void dfs(int cur, HashMap<Integer, List<int[]>> graph, boolean[] vis, int curmin) {\\n        // The test cases are generated such that there is at least one path between 1 and n.\\n\\n        if (graph.get(cur) != null) {\\n            for (int[] nei: graph.get(cur)) {\\n\\n                curmin = Math.min(curmin, nei[1]);\\n                mindist = Math.min(mindist, curmin);\\n\\n                if (vis[nei[0]] == true) continue;\\n                vis[nei[0]] = true;\\n                dfs(nei[0], graph, vis, curmin);\\n            }\\n        }\\n    }\\n}\\n```\\n\\nDijkstra:\\n\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        // dij\\n        // graph\\n        HashMap<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] f: roads) {\\n            graph.putIfAbsent(f[0], new ArrayList<>());\\n            graph.putIfAbsent(f[1], new ArrayList<>());\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n            graph.get(f[1]).add(new int[]{f[0], f[2]});\\n        }\\n\\n        PriorityQueue<Node> minheap = new PriorityQueue<>((a, b) -> a.cost - b.cost); // <nei: cost>\\n\\n        minheap.add(new Node(1, Integer.MAX_VALUE));\\n        \\n        int mincost = Integer.MAX_VALUE;\\n        boolean[] vis = new boolean[n + 1];\\n        while (!minheap.isEmpty()) {\\n\\n            Node cur = minheap.poll();\\n\\n            mincost = Math.min(mincost, cur.cost); \\n\\n            if (vis[cur.val] == true) continue;\\n            vis[cur.val] = true;\\n\\n            if (graph.get(cur.val) != null) {\\n                for (int[] nei: graph.get(cur.val)) {\\n\\n                    int curmincost = Math.min(nei[1], cur.cost);\\n\\n                    minheap.add(new Node(nei[0], curmincost));\\n                }\\n            }\\n        }\\n        return mincost;\\n    }\\n    class Node {\\n        int val;\\n        int cost;\\n        \\n        public Node(int val, int cost) {\\n            this.val = val;\\n            this.cost = cost;\\n        }\\n    }\\n}\\n```\\n\\nUnionfind:\\n```\\nclass Solution {\\n    int[] parent;\\n    int[] dist;\\n    public int minScore(int n, int[][] roads) {\\n\\n        parent = new int[n + 1];\\n        dist = new int[n + 1];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n\\n        for (int i = 1; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n        for (int[] r: roads) {\\n            union(r[0], r[1], r[2]);\\n        }\\n        int parent1 = find(1);\\n        int parentn = find(n);\\n        return dist[parentn]; \\n    }\\n    private int find(int i) {\\n        while (i != parent[i]) {\\n            i = parent[i];\\n        }\\n        return i;\\n    }\\n    private void union(int i, int j, int d) {\\n        int parenti = find(i);\\n        int parentj = find(j);\\n        parent[parenti] = parentj;\\n\\n        int mindist = Math.min(dist[parenti], dist[parentj]);\\n\\n\\n        mindist = Math.min(mindist, d);\\n        dist[parenti] = dist[parentj] = mindist; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mindist = Integer.MAX_VALUE;\\n\\n    public int minScore(int n, int[][] roads) {\\n\\n        HashMap<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] f: roads) {\\n            graph.putIfAbsent(f[0], new ArrayList<>());\\n            graph.putIfAbsent(f[1], new ArrayList<>());\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n            graph.get(f[1]).add(new int[]{f[0], f[2]});\\n        }\\n        boolean[] vis = new boolean[n + 1];\\n        vis[1] = true;\\n        dfs(1, graph, vis, Integer.MAX_VALUE);\\n        return mindist;\\n    }\\n    private void dfs(int cur, HashMap<Integer, List<int[]>> graph, boolean[] vis, int curmin) {\\n        // The test cases are generated such that there is at least one path between 1 and n.\\n\\n        if (graph.get(cur) != null) {\\n            for (int[] nei: graph.get(cur)) {\\n\\n                curmin = Math.min(curmin, nei[1]);\\n                mindist = Math.min(mindist, curmin);\\n\\n                if (vis[nei[0]] == true) continue;\\n                vis[nei[0]] = true;\\n                dfs(nei[0], graph, vis, curmin);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        // dij\\n        // graph\\n        HashMap<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] f: roads) {\\n            graph.putIfAbsent(f[0], new ArrayList<>());\\n            graph.putIfAbsent(f[1], new ArrayList<>());\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n            graph.get(f[1]).add(new int[]{f[0], f[2]});\\n        }\\n\\n        PriorityQueue<Node> minheap = new PriorityQueue<>((a, b) -> a.cost - b.cost); // <nei: cost>\\n\\n        minheap.add(new Node(1, Integer.MAX_VALUE));\\n        \\n        int mincost = Integer.MAX_VALUE;\\n        boolean[] vis = new boolean[n + 1];\\n        while (!minheap.isEmpty()) {\\n\\n            Node cur = minheap.poll();\\n\\n            mincost = Math.min(mincost, cur.cost); \\n\\n            if (vis[cur.val] == true) continue;\\n            vis[cur.val] = true;\\n\\n            if (graph.get(cur.val) != null) {\\n                for (int[] nei: graph.get(cur.val)) {\\n\\n                    int curmincost = Math.min(nei[1], cur.cost);\\n\\n                    minheap.add(new Node(nei[0], curmincost));\\n                }\\n            }\\n        }\\n        return mincost;\\n    }\\n    class Node {\\n        int val;\\n        int cost;\\n        \\n        public Node(int val, int cost) {\\n            this.val = val;\\n            this.cost = cost;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] parent;\\n    int[] dist;\\n    public int minScore(int n, int[][] roads) {\\n\\n        parent = new int[n + 1];\\n        dist = new int[n + 1];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n\\n        for (int i = 1; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n        for (int[] r: roads) {\\n            union(r[0], r[1], r[2]);\\n        }\\n        int parent1 = find(1);\\n        int parentn = find(n);\\n        return dist[parentn]; \\n    }\\n    private int find(int i) {\\n        while (i != parent[i]) {\\n            i = parent[i];\\n        }\\n        return i;\\n    }\\n    private void union(int i, int j, int d) {\\n        int parenti = find(i);\\n        int parentj = find(j);\\n        parent[parenti] = parentj;\\n\\n        int mindist = Math.min(dist[parenti], dist[parentj]);\\n\\n\\n        mindist = Math.min(mindist, d);\\n        dist[parenti] = dist[parentj] = mindist; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877178,
                "title": "dfs-we-are-only-interested-in-connected-component-of-1-c",
                "content": "We just have to find all vertices that are in connected component with 1 and find edge with minimum value in that graph. \\nImportant factors : \\n* Graph can be disconnected;\\n* There always will be a path between 1 and n, therefore n is in a same connected-component as 1;\\n* If we assume that graph doesn\\'t contain cycles we can eliminate visited array and calculate answer directly in dfs, but problem doesn\\'t state such thing;\\n\\nAssuming graph can containc cycles code looks like this : \\n\\n```\\nclass Solution {\\npublic:\\n    vector <int> connectedComponent;\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> g(n+1, vector<pair<int,int>>());\\n        for(auto it : roads){\\n            g[it[0]].push_back({it[1],it[2]});\\n            g[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<bool> visited (n+1, false);\\n        dfs(1,g,visited);\\n        int ans = INT_MAX;\\n        for(auto & u : connectedComponent){\\n            for(auto & v : g[u])\\n                ans = min(v.second,ans);\\n        }\\n        return ans;\\n    }\\n    void dfs(int u, vector<vector<pair<int,int>>> &g, vector<bool> & visited){\\n        visited[u] = true;\\n        connectedComponent.push_back(u);\\n        for(auto & v : g[u]){\\n            if(!visited[v.first])\\n                dfs(v.first,g,visited);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> connectedComponent;\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> g(n+1, vector<pair<int,int>>());\\n        for(auto it : roads){\\n            g[it[0]].push_back({it[1],it[2]});\\n            g[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<bool> visited (n+1, false);\\n        dfs(1,g,visited);\\n        int ans = INT_MAX;\\n        for(auto & u : connectedComponent){\\n            for(auto & v : g[u])\\n                ans = min(v.second,ans);\\n        }\\n        return ans;\\n    }\\n    void dfs(int u, vector<vector<pair<int,int>>> &g, vector<bool> & visited){\\n        visited[u] = true;\\n        connectedComponent.push_back(u);\\n        for(auto & v : g[u]){\\n            if(!visited[v.first])\\n                dfs(v.first,g,visited);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877044,
                "title": "single-dfs",
                "content": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<int[]>> graph = new ArrayList<>(); //Weighted Graph\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());  //Initialse the  graph\\n        for(int[] e: roads){  //Fill the graph\\n            graph.get(e[0]-1).add(new int[]{e[1]-1,e[2]});\\n            graph.get(e[1]-1).add(new int[]{e[0]-1,e[2]});\\n        }\\n        return getMin(0,new boolean[n],graph); //Single DFS\\n    }\\n    private int getMin(int node, boolean[] visited,List<List<int[]>> graph){\\n        int min = Integer.MAX_VALUE;\\n        visited[node] = true;\\n        for(int[] child: graph.get(node)){\\n            min = Math.min(min,child[1]); //Check if this edge is minimum or not;\\n            if(!visited[child[0]]){\\n                 min = Math.min(min,getMin(child[0],visited,graph));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<int[]>> graph = new ArrayList<>(); //Weighted Graph\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());  //Initialse the  graph\\n        for(int[] e: roads){  //Fill the graph\\n            graph.get(e[0]-1).add(new int[]{e[1]-1,e[2]});\\n            graph.get(e[1]-1).add(new int[]{e[0]-1,e[2]});\\n        }\\n        return getMin(0,new boolean[n],graph); //Single DFS\\n    }\\n    private int getMin(int node, boolean[] visited,List<List<int[]>> graph){\\n        int min = Integer.MAX_VALUE;\\n        visited[node] = true;\\n        for(int[] child: graph.get(node)){\\n            min = Math.min(min,child[1]); //Check if this edge is minimum or not;\\n            if(!visited[child[0]]){\\n                 min = Math.min(min,getMin(child[0],visited,graph));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1840451,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840040,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840091,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840066,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1704778,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840707,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840121,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840101,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1713139,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1704873,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840451,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840040,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840091,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840066,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1704778,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840707,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840121,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840101,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1713139,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1704873,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840424,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 2072315,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 2042227,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1909308,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1893453,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1842353,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1842141,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1841489,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1840921,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1840916,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1840827,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840768,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840672,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840530,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840511,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840448,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840419,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840392,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840376,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840305,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840090,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1840071,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1840063,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1840023,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1709861,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1705074,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1704931,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1704819,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1704805,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1840763,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            }
        ]
    },
    {
        "title": "Divide Nodes Into the Maximum Number of Groups",
        "question_content": "<p>You are given a positive integer <code>n</code> representing the number of nodes in an <strong>undirected</strong> graph. The nodes are labeled from <code>1</code> to <code>n</code>.</p>\n\n<p>You are also given a 2D integer array <code>edges</code>, where <code>edges[i] = [a<sub>i, </sub>b<sub>i</sub>]</code> indicates that there is a <strong>bidirectional</strong> edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. <strong>Notice</strong> that the given graph may be disconnected.</p>\n\n<p>Divide the nodes of the graph into <code>m</code> groups (<strong>1-indexed</strong>) such that:</p>\n\n<ul>\n\t<li>Each node in the graph belongs to exactly one group.</li>\n\t<li>For every pair of nodes in the graph that are connected by an edge <code>[a<sub>i, </sub>b<sub>i</sub>]</code>, if <code>a<sub>i</sub></code> belongs to the group with index <code>x</code>, and <code>b<sub>i</sub></code> belongs to the group with index <code>y</code>, then <code>|y - x| = 1</code>.</li>\n</ul>\n\n<p>Return <em>the maximum number of groups (i.e., maximum </em><code>m</code><em>) into which you can divide the nodes</em>. Return <code>-1</code> <em>if it is impossible to group the nodes with the given conditions</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/13/example1.png\" style=\"width: 352px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> As shown in the image we:\n- Add node 5 to the first group.\n- Add node 1 to the second group.\n- Add nodes 2 and 4 to the third group.\n- Add nodes 3 and 6 to the fourth group.\nWe can see that every edge is satisfied.\nIt can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, edges = [[1,2],[2,3],[3,1]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\nIt can be shown that no grouping is possible.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>There is at most one edge between any pair of vertices.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2874985,
                "title": "2-observations-bipartite-check-c",
                "content": "<h2>Approach</h2>\\nThere are two crucial observations than  can help you solve the problem easily.\\n\\n<h3>Observation 1</h3>\\nThe graph must be bipartite. As the difference of group must be 1 there can\\'t be any cycle of odd length.\\n\\n<h3>Observation 2</h3>\\nThe number of group we can create for a connected graph is the maximum of minimum distances between all nodes in that graph. Here distance equals to number of nodes in the path.\\n\\n<b>Small Proof:</b>\\nLet the distance between two nodes (u,v) = x. Now there can be two cases:\\n1. There is no cycle between u,v. Then we can just start numbering from 1 to x.\\n2. There is a cycle between u,v. But the minimum distance is x.  So, the other paths must have length>x. We can number the nodes in these paths by just incrementing and decrementing to reach x from 1.\\n\\nThen our problem becomes simple. At first calculate the minimum distances between all nodes.<b>Floyd-Warshall will give you TLE</b>\\nThen check if each connected component is bipartite or not. And for all bipartite graphs find the maximum of minimum distances. And add the distance with result.\\n```\\nclass Solution {\\npublic:\\n    vector<int>adj[505];\\n    int col[505];\\n    int dis[505][505];\\n    bool flag;\\n\\t//nodes in a connected graph.\\n    vector<int>kara;\\n\\t\\n\\t//check if graph is bipartite\\n    void dfs(int u,int c=1){\\n        col[u] = c;\\n        kara.push_back(u);\\n        for(int&v:adj[u]){\\n            if(!col[v]) dfs(v,3-c);\\n            else if(col[v]==c)flag = 0;// graph is not bipartite\\n        }\\n    }\\n\\t//calculate minimum distance between all nodes.\\n    void bfs(int src){\\n        for(int i=1;i<=500;i++)dis[src][i] = 100001;\\n        dis[src][src] = 1;\\n        queue<int>q;\\n        q.push(src);\\n        while(q.size()){\\n            auto u = q.front();\\n            q.pop();\\n            for(int&v:adj[u]){\\n                if(dis[src][v]>dis[src][u]+1){\\n                    dis[src][v] = dis[src][u]+1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        for(int i=1;i<=n;i++)adj[i].clear();\\n        memset(col,0,sizeof col);\\n        for(auto&e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        for(int i=1;i<=n;i++)bfs(i);\\n        int ans = 0;\\n        int in = 0;\\n        for(int i=1;i<=n;i++){\\n            if(col[i]==0){\\n                kara.clear();\\n                flag = 1;\\n                in++;\\n                dfs(i);\\n                if(!flag) return -1;\\n                int mxdis = 0;\\n                for(int&i:kara){\\n                        for(int&j:kara){\\n                            mxdis=max(mxdis,dis[i][j]);\\n                        }\\n                }\\n                ans+=mxdis;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[505];\\n    int col[505];\\n    int dis[505][505];\\n    bool flag;\\n\\t//nodes in a connected graph.\\n    vector<int>kara;\\n\\t\\n\\t//check if graph is bipartite\\n    void dfs(int u,int c=1){\\n        col[u] = c;\\n        kara.push_back(u);\\n        for(int&v:adj[u]){\\n            if(!col[v]) dfs(v,3-c);\\n            else if(col[v]==c)flag = 0;// graph is not bipartite\\n        }\\n    }\\n\\t//calculate minimum distance between all nodes.\\n    void bfs(int src){\\n        for(int i=1;i<=500;i++)dis[src][i] = 100001;\\n        dis[src][src] = 1;\\n        queue<int>q;\\n        q.push(src);\\n        while(q.size()){\\n            auto u = q.front();\\n            q.pop();\\n            for(int&v:adj[u]){\\n                if(dis[src][v]>dis[src][u]+1){\\n                    dis[src][v] = dis[src][u]+1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        for(int i=1;i<=n;i++)adj[i].clear();\\n        memset(col,0,sizeof col);\\n        for(auto&e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        for(int i=1;i<=n;i++)bfs(i);\\n        int ans = 0;\\n        int in = 0;\\n        for(int i=1;i<=n;i++){\\n            if(col[i]==0){\\n                kara.clear();\\n                flag = 1;\\n                in++;\\n                dfs(i);\\n                if(!flag) return -1;\\n                int mxdis = 0;\\n                for(int&i:kara){\\n                        for(int&j:kara){\\n                            mxdis=max(mxdis,dis[i][j]);\\n                        }\\n                }\\n                ans+=mxdis;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875991,
                "title": "python3-bfs-dfs-union-find-explained",
                "content": "There are **two main parts** we need to solve in this problem!\\n\\n**(1) find each connected component in the graph**\\n - This can be done using BFS, DFS, Union-Find.\\n\\n**(2) find the maximum number of groups in each connected component**\\n - This can be done using a BFS.\\n - But we need to check if there is a odd number edge cycle in the graph, because that will make it impossible to group the nodes with the given conditions.\\n - To find the maximum number of groups, we will have to start the search from each node. Note that the number of nodes is 500, so O(n * (n + m)) is fine, where n = number of nodes, m = number of edges.\\n\\n**Union-Find**\\n```python\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        ### UF is a hash map where you can find the root of a group of elements giving an element.\\n        ### A key in UF is a element, UF[x] is x\\'s parent.\\n        ### If UF[x] == x meaning x is the root of its group.\\n        UF = {}\\n        \\n        ### Given an element, find the root of the group to which this element belongs.\\n        def find(x):\\n            ### this may be the first time we see x, so set itself as the root.\\n            if x not in UF:\\n                UF[x] = x\\n            \\n            ### If x == UF[x], meaning x is the root of this group.\\n            ### If x != UF[x], we use the find function again on x\\'s parent UF[x] \\n            ### until we find the root and set it as the parent (value) of x in UF.\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        ### Given two elements x and y, we know that x and y should be in the same group, \\n        ### this means the group that contains x and the group that contains y \\n        ### should be merged together if they are currently separate groups.\\n        ### So we first find the root of x and the root of y using the find function.\\n        ### We then set the root of y (rootY) as the root of the root of x (rootX).\\n        def union(x, y):\\n            \\n            rootX = find(x)\\n            rootY = find(y)\\n            # set the root of y (rootY) as the root of the root of x (rootX)\\n            UF[rootX] = rootY\\n        \\n        ### Do a BFS on the graph given a start point.\\n        ### One thing we have to do is to check if the graph has a odd number edges cycle.\\n        ### This is done by checking the if the neighbor node has been visited before \\n        ### and if the neighbor was on the same level as the current node when we were visiting the neighbor.\\n        def BFS(node):\\n            q = deque([(node,1)])\\n            seen = {node:1}\\n            level = 1\\n            while q:\\n                cur,level = q.popleft()\\n                for nei in graph[cur]:\\n                    if nei not in seen:\\n                        seen[nei] = level+1\\n                        q.append((nei,level+1))\\n                    ### check if there is a odd number edges cycle\\n                    elif seen[nei]==level: \\n                        return -1\\n            return level\\n        \\n        ### Greating the graph\\n        ### Creating the connected component using Union-Find\\n        graph = defaultdict(list)\\n        for s,e in edges:\\n            graph[s].append(e)\\n            graph[e].append(s)\\n            union(s,e)\\n        \\n        ### Store the largest group in each connected component\\n        maxGroup = defaultdict(int)\\n        ### Start a BFS on each node, and update the maxGroup for each connected component\\n        for i in range(1,n+1):\\n            groups = BFS(i)\\n            ### There is a odd number edges cycle, so return -1\\n            if groups==-1:\\n                return -1\\n            ### Find the root of the current connected component\\n            root = find(i)\\n            ### Update it.\\n            maxGroup[root] = max(maxGroup[root],groups)\\n\\n        return sum(maxGroup.values())\\n```\\n\\n**Other good Union-Find problems:**\\n[Graph Connectivity With Threshold](https://leetcode.com/problems/graph-connectivity-with-threshold/)\\n[Remove Max Number of Edges to Keep Graph Fully Traversable](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/)\\n[Checking Existence of Edge Length Limited Paths](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/)\\n[Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/)\\n[Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/)\\n\\n**BFS**\\n```python\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n\\n        ### Do a BFS on the graph given a start point.\\n        ### One thing we have to do is to check if the graph has a odd number edges cycle.\\n        ### This is done by checking the if the neighbor node has been visited before \\n        ### and if the neighbor was on the same level as the current node when we were visiting the neighbor.\\n        def BFS(node):\\n            q = deque([(node,1)])\\n            seen = {node:1}\\n            level = 1\\n            while q:\\n                cur,level = q.popleft()\\n                for nei in graph[cur]:\\n                    if nei not in seen:\\n                        seen[nei] = level+1\\n                        q.append((nei,level+1))\\n                    ### check if there is a odd number edges cycle\\n                    elif seen[nei]==level: \\n                        return -1\\n            return level\\n        \\n        ### Greating the graph\\n        graph = defaultdict(list)\\n        for s,e in edges:\\n            graph[s].append(e)\\n            graph[e].append(s)\\n        \\n        ### Store the largest number of groups in each connected component\\n        maxGroup = []\\n        visited = set()\\n        for i in range(1,n+1):\\n            if i not in visited:\\n                ### BFS to find the connected component.\\n                q = deque([i])\\n                connectedComponent = {i}\\n                while q:\\n                    cur = q.popleft()\\n                    for nei in graph[cur]:\\n                        if nei not in connectedComponent:\\n                            connectedComponent.add(nei)\\n                            q.append((nei))\\n                            visited.add(nei)\\n                \\n                ### Place holder for the current connected component.\\n                maxGroup.append(0)\\n                ### Start a BFS on each node, and update the maxGroup for the current connected component\\n                for i in connectedComponent:\\n                    groups = BFS(i)\\n                    ### There is a odd number edges cycle, so return -1\\n                    if groups==-1:\\n                        return -1\\n                    maxGroup[-1] = max(maxGroup[-1],groups)\\n\\n        return sum(maxGroup)\\n```\\n\\n**DFS**\\n```python\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n\\n        def BFS(node):\\n            q = deque([(node,1)])\\n            seen = {node:1}\\n            level = 1\\n            while q:\\n                cur,level = q.popleft()\\n                for nei in graph[cur]:\\n                    if nei not in seen:\\n                        seen[nei] = level+1\\n                        q.append((nei,level+1))\\n                    elif seen[nei]==level: \\n                        return -1\\n            return level\\n        \\n        ### DFS to find the connected component\\n        def dfs(node):\\n            nonlocal visited\\n            nonlocal connectedComponent\\n            for nei in graph[node]:\\n                if nei not in connectedComponent:\\n                    connectedComponent.add(nei)\\n                    dfs((nei))\\n                    visited.add(nei)\\n\\n        graph = defaultdict(list)\\n        for s,e in edges:\\n            graph[s].append(e)\\n            graph[e].append(s)\\n        \\n        maxGroup = []\\n        visited = set()\\n        for i in range(1,n+1):\\n            if i not in visited:\\n                connectedComponent = {i}\\n                \\n                ### Using DFS to find the connect component\\n                dfs(i)\\n                \\n                maxGroup.append(0)\\n                for i in connectedComponent:\\n                    groups = BFS(i)\\n                    if groups==-1:\\n                        return -1\\n                    maxGroup[-1] = max(maxGroup[-1],groups)\\n\\n        return sum(maxGroup)\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        ### UF is a hash map where you can find the root of a group of elements giving an element.\\n        ### A key in UF is a element, UF[x] is x\\'s parent.\\n        ### If UF[x] == x meaning x is the root of its group.\\n        UF = {}\\n        \\n        ### Given an element, find the root of the group to which this element belongs.\\n        def find(x):\\n            ### this may be the first time we see x, so set itself as the root.\\n            if x not in UF:\\n                UF[x] = x\\n            \\n            ### If x == UF[x], meaning x is the root of this group.\\n            ### If x != UF[x], we use the find function again on x\\'s parent UF[x] \\n            ### until we find the root and set it as the parent (value) of x in UF.\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        ### Given two elements x and y, we know that x and y should be in the same group, \\n        ### this means the group that contains x and the group that contains y \\n        ### should be merged together if they are currently separate groups.\\n        ### So we first find the root of x and the root of y using the find function.\\n        ### We then set the root of y (rootY) as the root of the root of x (rootX).\\n        def union(x, y):\\n            \\n            rootX = find(x)\\n            rootY = find(y)\\n            # set the root of y (rootY) as the root of the root of x (rootX)\\n            UF[rootX] = rootY\\n        \\n        ### Do a BFS on the graph given a start point.\\n        ### One thing we have to do is to check if the graph has a odd number edges cycle.\\n        ### This is done by checking the if the neighbor node has been visited before \\n        ### and if the neighbor was on the same level as the current node when we were visiting the neighbor.\\n        def BFS(node):\\n            q = deque([(node,1)])\\n            seen = {node:1}\\n            level = 1\\n            while q:\\n                cur,level = q.popleft()\\n                for nei in graph[cur]:\\n                    if nei not in seen:\\n                        seen[nei] = level+1\\n                        q.append((nei,level+1))\\n                    ### check if there is a odd number edges cycle\\n                    elif seen[nei]==level: \\n                        return -1\\n            return level\\n        \\n        ### Greating the graph\\n        ### Creating the connected component using Union-Find\\n        graph = defaultdict(list)\\n        for s,e in edges:\\n            graph[s].append(e)\\n            graph[e].append(s)\\n            union(s,e)\\n        \\n        ### Store the largest group in each connected component\\n        maxGroup = defaultdict(int)\\n        ### Start a BFS on each node, and update the maxGroup for each connected component\\n        for i in range(1,n+1):\\n            groups = BFS(i)\\n            ### There is a odd number edges cycle, so return -1\\n            if groups==-1:\\n                return -1\\n            ### Find the root of the current connected component\\n            root = find(i)\\n            ### Update it.\\n            maxGroup[root] = max(maxGroup[root],groups)\\n\\n        return sum(maxGroup.values())\\n```\n```python\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n\\n        ### Do a BFS on the graph given a start point.\\n        ### One thing we have to do is to check if the graph has a odd number edges cycle.\\n        ### This is done by checking the if the neighbor node has been visited before \\n        ### and if the neighbor was on the same level as the current node when we were visiting the neighbor.\\n        def BFS(node):\\n            q = deque([(node,1)])\\n            seen = {node:1}\\n            level = 1\\n            while q:\\n                cur,level = q.popleft()\\n                for nei in graph[cur]:\\n                    if nei not in seen:\\n                        seen[nei] = level+1\\n                        q.append((nei,level+1))\\n                    ### check if there is a odd number edges cycle\\n                    elif seen[nei]==level: \\n                        return -1\\n            return level\\n        \\n        ### Greating the graph\\n        graph = defaultdict(list)\\n        for s,e in edges:\\n            graph[s].append(e)\\n            graph[e].append(s)\\n        \\n        ### Store the largest number of groups in each connected component\\n        maxGroup = []\\n        visited = set()\\n        for i in range(1,n+1):\\n            if i not in visited:\\n                ### BFS to find the connected component.\\n                q = deque([i])\\n                connectedComponent = {i}\\n                while q:\\n                    cur = q.popleft()\\n                    for nei in graph[cur]:\\n                        if nei not in connectedComponent:\\n                            connectedComponent.add(nei)\\n                            q.append((nei))\\n                            visited.add(nei)\\n                \\n                ### Place holder for the current connected component.\\n                maxGroup.append(0)\\n                ### Start a BFS on each node, and update the maxGroup for the current connected component\\n                for i in connectedComponent:\\n                    groups = BFS(i)\\n                    ### There is a odd number edges cycle, so return -1\\n                    if groups==-1:\\n                        return -1\\n                    maxGroup[-1] = max(maxGroup[-1],groups)\\n\\n        return sum(maxGroup)\\n```\n```python\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n\\n        def BFS(node):\\n            q = deque([(node,1)])\\n            seen = {node:1}\\n            level = 1\\n            while q:\\n                cur,level = q.popleft()\\n                for nei in graph[cur]:\\n                    if nei not in seen:\\n                        seen[nei] = level+1\\n                        q.append((nei,level+1))\\n                    elif seen[nei]==level: \\n                        return -1\\n            return level\\n        \\n        ### DFS to find the connected component\\n        def dfs(node):\\n            nonlocal visited\\n            nonlocal connectedComponent\\n            for nei in graph[node]:\\n                if nei not in connectedComponent:\\n                    connectedComponent.add(nei)\\n                    dfs((nei))\\n                    visited.add(nei)\\n\\n        graph = defaultdict(list)\\n        for s,e in edges:\\n            graph[s].append(e)\\n            graph[e].append(s)\\n        \\n        maxGroup = []\\n        visited = set()\\n        for i in range(1,n+1):\\n            if i not in visited:\\n                connectedComponent = {i}\\n                \\n                ### Using DFS to find the connect component\\n                dfs(i)\\n                \\n                maxGroup.append(0)\\n                for i in connectedComponent:\\n                    groups = BFS(i)\\n                    if groups==-1:\\n                        return -1\\n                    maxGroup[-1] = max(maxGroup[-1],groups)\\n\\n        return sum(maxGroup)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881606,
                "title": "c-use-bipartite-farthest-node-concept-explanation-bfs-dfs",
                "content": "**Approach:**\\n1. Graph must be bipatite for dividing it into group by following given condition. If it\\'s not bipartite then we return -1.\\n2. If graph is bipartite then we need to calculate minimum farthest distance of all nodes in the graph. (Here distance equals to number of nodes in the path) and among all minimum farthest distance of nodes, maximum value is the maximum number of groups into which you can divide the nodes. \\n3. At last, for disconnected graph we need to calculate maximum number of groups for each component and add them which is our result.\\n\\n**To understand how to calculate Minimum Farthest Distance:**\\n![image](https://assets.leetcode.com/users/images/600372fc-b652-4a69-affc-823c2bbd0937_1670279998.4739804.jpeg)\\n\\n**Code:**\\n```\\nclass Solution \\n{\\npublic:\\n    \\n    //function for checking whether a graph component is bipartite or not (for disconnected graph)\\n    bool bipartite(int src, vector<int> adj[], int color[])\\n    {\\n        queue<int> q;\\n        q.push(src);\\n        color[src]=1;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            \\n            for(auto it:adj[node])\\n            {\\n                if(color[it]==-1)\\n                {\\n                    color[it] = 1-color[node];\\n                    q.push(it);\\n                }\\n                else if(color[it]==color[node])\\n                    return false;\\n            }\\n        }\\n        return true;  \\n    }\\n    \\n    //function for checking whether a graph is bipartite or not\\n    bool checkBipartite(int &n, vector<int> adj[])\\n    {\\n        int color[n+1];\\n        memset(color, -1, sizeof color);\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(!bipartite(i, adj, color)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    //function for finding distance of farthest node from the current node\\n    //To get the maximum number of groups\\n    int findFarthestDistBFS(int src, int n, vector<int> adj[])\\n    {\\n        vector<int> vis(n+1, 0);\\n        int cnt=0;\\n        queue<int> q;\\n        q.push(src);\\n        vis[src]=1;\\n                    \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            cnt++;\\n            \\n            for(int i=0; i<sz; i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n\\n                for(auto it:adj[node])\\n                {\\n                    if(!vis[it])\\n                    {\\n                        q.push(it);\\n                        vis[it]=1;\\n                    }\\n                }\\n            }\\n           \\n        }\\n        return cnt;\\n    }\\n    \\n    //For finding maximum groups of multiple components of a graph\\n    int dfsForComponents(int node, vector<int> adj[], vector<int> &vist, vector<int> &dist)\\n    {\\n        vist[node]=1;\\n        int maxi=dist[node];\\n        for(auto it:adj[node])\\n        {\\n            if(!vist[it])\\n            {\\n                maxi = max(maxi, dfsForComponents(it, adj, vist, dist));\\n            }\\n        }\\n        return maxi;\\n    }\\n    \\n    //Given function\\n    int magnificentSets(int n, vector<vector<int>>& edges) \\n    {\\n        //creating adjacency list\\n        vector<int> adj[n+1];\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        //check whether a graph is bipartite or not\\n        if(!checkBipartite(n, adj)) return -1;\\n        \\n        //calcuate farthest node from each node and store in dist vector\\n        vector<int> dist(n+1, 0);\\n        for(int i=1; i<=n; i++)\\n        {\\n            dist[i] = findFarthestDistBFS(i, n, adj);\\n        }\\n        \\n        //for multiple components, count maximum number of groups\\n        vector<int> vist(n+1, 0);\\n        int maxi=0;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(vist[i]==0)\\n            {\\n                maxi += dfsForComponents(i, adj, vist, dist);\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```\\n\\n***For better understanding refer this video:*** [https://youtu.be/MSG7qX_UiKQ](https://youtu.be/MSG7qX_UiKQ)\\n\\n**Please upvote if you find this solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    \\n    //function for checking whether a graph component is bipartite or not (for disconnected graph)\\n    bool bipartite(int src, vector<int> adj[], int color[])\\n    {\\n        queue<int> q;\\n        q.push(src);\\n        color[src]=1;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            \\n            for(auto it:adj[node])\\n            {\\n                if(color[it]==-1)\\n                {\\n                    color[it] = 1-color[node];\\n                    q.push(it);\\n                }\\n                else if(color[it]==color[node])\\n                    return false;\\n            }\\n        }\\n        return true;  \\n    }\\n    \\n    //function for checking whether a graph is bipartite or not\\n    bool checkBipartite(int &n, vector<int> adj[])\\n    {\\n        int color[n+1];\\n        memset(color, -1, sizeof color);\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(!bipartite(i, adj, color)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    //function for finding distance of farthest node from the current node\\n    //To get the maximum number of groups\\n    int findFarthestDistBFS(int src, int n, vector<int> adj[])\\n    {\\n        vector<int> vis(n+1, 0);\\n        int cnt=0;\\n        queue<int> q;\\n        q.push(src);\\n        vis[src]=1;\\n                    \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            cnt++;\\n            \\n            for(int i=0; i<sz; i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n\\n                for(auto it:adj[node])\\n                {\\n                    if(!vis[it])\\n                    {\\n                        q.push(it);\\n                        vis[it]=1;\\n                    }\\n                }\\n            }\\n           \\n        }\\n        return cnt;\\n    }\\n    \\n    //For finding maximum groups of multiple components of a graph\\n    int dfsForComponents(int node, vector<int> adj[], vector<int> &vist, vector<int> &dist)\\n    {\\n        vist[node]=1;\\n        int maxi=dist[node];\\n        for(auto it:adj[node])\\n        {\\n            if(!vist[it])\\n            {\\n                maxi = max(maxi, dfsForComponents(it, adj, vist, dist));\\n            }\\n        }\\n        return maxi;\\n    }\\n    \\n    //Given function\\n    int magnificentSets(int n, vector<vector<int>>& edges) \\n    {\\n        //creating adjacency list\\n        vector<int> adj[n+1];\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        //check whether a graph is bipartite or not\\n        if(!checkBipartite(n, adj)) return -1;\\n        \\n        //calcuate farthest node from each node and store in dist vector\\n        vector<int> dist(n+1, 0);\\n        for(int i=1; i<=n; i++)\\n        {\\n            dist[i] = findFarthestDistBFS(i, n, adj);\\n        }\\n        \\n        //for multiple components, count maximum number of groups\\n        vector<int> vist(n+1, 0);\\n        int maxi=0;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(vist[i]==0)\\n            {\\n                maxi += dfsForComponents(i, adj, vist, dist);\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875152,
                "title": "python3-bfs",
                "content": "**Implementation**\\nStep 1: Find all connected components of the graph, this can be achieved by using BFS.\\nStep 2: Find the maxinum number of groups in each connected component by using BFS and starting from each node of the component, or `-1` if not valid.\\nStep 3: If any of the output from Step 2 is `-1`, then return `-1`; otherwise, return the sum of the output from Step 2 as the final answer.\\n\\n**Complexity**\\nTime Complexity: `O(n*(n+m))`, where `m` is the number of edges\\nSpace Complexity: `O(n+m)`\\n\\n**Solution**\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        components = []\\n        seen = set()\\n        for i in range(1, n + 1):\\n            if i in seen:\\n                continue\\n            queue = deque([i])\\n            visited = set([i])\\n            while queue:\\n                for _ in range(len(queue)):\\n                    node = queue.popleft()\\n                    for neighbor in graph[node]:\\n                        if neighbor in visited:\\n                            continue\\n                        visited.add(neighbor)\\n                        queue.append(neighbor)\\n            components.append(visited)\\n            seen = seen.union(visited)\\n        longest = [-1] * len(components)        \\n        for k in range(len(components)):\\n            for i in components[k]:\\n                longest[k] = max(longest[k], self.bfs(graph, i))\\n        if min(longest) < 0:\\n            return -1\\n        return sum(longest)\\n            \\n    def bfs(self, graph, i):\\n        queue = deque([i])\\n        seen = set([i])\\n        seenLevel = set()\\n        ans = 0\\n        while queue:\\n            ans += 1\\n            nextLevel = set()\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                for neighbor in graph[node]:\\n                    if neighbor in seenLevel:\\n                        return -1\\n                    if neighbor in seen:\\n                        continue\\n                    seen.add(neighbor)\\n                    nextLevel.add(neighbor)\\n                    queue.append(neighbor)\\n            seenLevel = nextLevel\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        components = []\\n        seen = set()\\n        for i in range(1, n + 1):\\n            if i in seen:\\n                continue\\n            queue = deque([i])\\n            visited = set([i])\\n            while queue:\\n                for _ in range(len(queue)):\\n                    node = queue.popleft()\\n                    for neighbor in graph[node]:\\n                        if neighbor in visited:\\n                            continue\\n                        visited.add(neighbor)\\n                        queue.append(neighbor)\\n            components.append(visited)\\n            seen = seen.union(visited)\\n        longest = [-1] * len(components)        \\n        for k in range(len(components)):\\n            for i in components[k]:\\n                longest[k] = max(longest[k], self.bfs(graph, i))\\n        if min(longest) < 0:\\n            return -1\\n        return sum(longest)\\n            \\n    def bfs(self, graph, i):\\n        queue = deque([i])\\n        seen = set([i])\\n        seenLevel = set()\\n        ans = 0\\n        while queue:\\n            ans += 1\\n            nextLevel = set()\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                for neighbor in graph[node]:\\n                    if neighbor in seenLevel:\\n                        return -1\\n                    if neighbor in seen:\\n                        continue\\n                    seen.add(neighbor)\\n                    nextLevel.add(neighbor)\\n                    queue.append(neighbor)\\n            seenLevel = nextLevel\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875146,
                "title": "c-python3-dfs-bfs",
                "content": "\\n**Intuition**\\n1) If there is a odd-length cycle, it is impossible to divide the nodes, which is checked by the DFS part; \\n2) If it is possible, then we can enumerate all nodes via BFS to check for the largest number of division along each connected component, which is computed by the BFS part. \\n\\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n); \\n        for (auto& e : edges) {\\n            graph[e[0]-1].push_back(e[1]-1); \\n            graph[e[1]-1].push_back(e[0]-1); \\n        }\\n        \\n        vector<int> seen(n); \\n        vector<vector<int>> group; \\n        for (int i = 0; i < n; ++i) \\n            if (!seen[i]) {\\n                seen[i] = 1; \\n                stack<int> stk; stk.push(i); \\n                group.push_back({i}); \\n                while (stk.size()) {\\n                    auto u = stk.top(); stk.pop(); \\n                    for (auto& v : graph[u]) \\n                        if (!seen[v]) {\\n                            seen[v] = seen[u] + 1; \\n                            stk.push(v); \\n                            group.back().push_back(v); \\n                        } else if ((seen[u] & 1) == (seen[v] & 1)) return -1; \\n                }\\n            }\\n        \\n        auto bfs = [&](int x) {\\n            int ans = 0; \\n            vector<bool> seen(n); \\n            seen[x] = true; \\n            queue<int> q; q.push(x); \\n            for (; q.size(); ++ans) \\n                for (int sz = q.size(); sz; --sz) {\\n                    auto u = q.front(); q.pop(); \\n                    for (auto& v : graph[u]) \\n                        if (!seen[v]) {\\n                            seen[v] = true; \\n                            q.push(v); \\n                        }\\n                }\\n            return ans; \\n        }; \\n        \\n        int ans = 0; \\n        for (auto& g : group) {\\n            transform(g.begin(), g.end(), g.begin(), bfs); \\n            ans += *max_element(g.begin(), g.end()); \\n        }\\n        return ans; \\n    }\\n};\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].append(v-1)\\n            graph[v-1].append(u-1)\\n        \\n        seen = [0]*n\\n        group = []\\n        for i in range(n): \\n            if not seen[i]: \\n                seen[i] = 1\\n                stack = [i]\\n                group.append([i])\\n                while stack: \\n                    u = stack.pop()\\n                    for v in graph[u]: \\n                        if not seen[v]: \\n                            seen[v] = seen[u] + 1\\n                            stack.append(v)\\n                            group[-1].append(v)\\n                        elif seen[u] & 1 == seen[v] & 1: return -1\\n\\n        def bfs(x): \\n            \"\"\"Return the levels starting from x.\"\"\"\\n            ans = 0\\n            seen = {x}\\n            queue = deque([x])\\n            while queue: \\n                ans += 1\\n                for _ in range(len(queue)): \\n                    u = queue.popleft()\\n                    for v in graph[u]: \\n                        if v not in seen: \\n                            seen.add(v)\\n                            queue.append(v)\\n            return ans \\n                            \\n        ans = 0 \\n        for g in group: ans += max(bfs(x) for x in g)\\n        return ans \\n```\\n**Complexity**\\nTime `O(N^2)`\\nSpace `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n); \\n        for (auto& e : edges) {\\n            graph[e[0]-1].push_back(e[1]-1); \\n            graph[e[1]-1].push_back(e[0]-1); \\n        }\\n        \\n        vector<int> seen(n); \\n        vector<vector<int>> group; \\n        for (int i = 0; i < n; ++i) \\n            if (!seen[i]) {\\n                seen[i] = 1; \\n                stack<int> stk; stk.push(i); \\n                group.push_back({i}); \\n                while (stk.size()) {\\n                    auto u = stk.top(); stk.pop(); \\n                    for (auto& v : graph[u]) \\n                        if (!seen[v]) {\\n                            seen[v] = seen[u] + 1; \\n                            stk.push(v); \\n                            group.back().push_back(v); \\n                        } else if ((seen[u] & 1) == (seen[v] & 1)) return -1; \\n                }\\n            }\\n        \\n        auto bfs = [&](int x) {\\n            int ans = 0; \\n            vector<bool> seen(n); \\n            seen[x] = true; \\n            queue<int> q; q.push(x); \\n            for (; q.size(); ++ans) \\n                for (int sz = q.size(); sz; --sz) {\\n                    auto u = q.front(); q.pop(); \\n                    for (auto& v : graph[u]) \\n                        if (!seen[v]) {\\n                            seen[v] = true; \\n                            q.push(v); \\n                        }\\n                }\\n            return ans; \\n        }; \\n        \\n        int ans = 0; \\n        for (auto& g : group) {\\n            transform(g.begin(), g.end(), g.begin(), bfs); \\n            ans += *max_element(g.begin(), g.end()); \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].append(v-1)\\n            graph[v-1].append(u-1)\\n        \\n        seen = [0]*n\\n        group = []\\n        for i in range(n): \\n            if not seen[i]: \\n                seen[i] = 1\\n                stack = [i]\\n                group.append([i])\\n                while stack: \\n                    u = stack.pop()\\n                    for v in graph[u]: \\n                        if not seen[v]: \\n                            seen[v] = seen[u] + 1\\n                            stack.append(v)\\n                            group[-1].append(v)\\n                        elif seen[u] & 1 == seen[v] & 1: return -1\\n\\n        def bfs(x): \\n            \"\"\"Return the levels starting from x.\"\"\"\\n            ans = 0\\n            seen = {x}\\n            queue = deque([x])\\n            while queue: \\n                ans += 1\\n                for _ in range(len(queue)): \\n                    u = queue.popleft()\\n                    for v in graph[u]: \\n                        if v not in seen: \\n                            seen.add(v)\\n                            queue.append(v)\\n            return ans \\n                            \\n        ans = 0 \\n        for g in group: ans += max(bfs(x) for x in g)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875130,
                "title": "java-with-detailed-explanation",
                "content": "```\\n        the logic stays in find method in the code... How do we ensure that if we follow the given conditions?\\n \\xA0 \\xA0 \\xA0 \\xA0- if (a, b) are connected, a and b should be in different groups  and \\n                                    Math.abs(group[a] - group[b]) must be 1.\\n                                    \\n        there are 2 cases to consider... \\n        Let\\'s start with happy path... suppose the graph is like this\\n        \\n        graph: [[1, 2], [1, 4], [1, 3]]\\n        2 different types of groups can be formed\\n        G1 = [(1), (2, 3, 4)], G2 = [(3, 4), (1), (2)], G3 = [(4), (1), (2, 3)]\\n        So, we can form maximum of 3 groups from the above graph.\\n        - We can find these groups by doing a level wise traversal \\n        starting with every node in the group.\\n        \\n        Let\\'s take negative case:\\n        graph = [[1, 2], [2, 3], [3, 1]]\\n        \\n        Let\\'s do a level order traversal...\\n        adjacency list:\\n        1 -> 2, 3\\n        2 -> 1, 3\\n        3 -> 1, 2\\n        \\n        start = 1, groups = 0 (this is index of group)\\n        group = [-1, -1, -1] (1 - indexed) \\n        group - this stores the index of group in which node has been stored\\n        \\n        - Take queue to do level order traversal\\n        queue = [1]\\n        After 1st level\\n        queue = [2, 3] \\n        -> according to the rules, node 2 and node 3 must be in different groups as they are connected.\\n        -> let\\'s try to take only one of them\\n        revised queue = [2]\\n        groups = 1\\n        group = [0, -1, -1]\\n\\n       After 2nd level\\n       queue = [3] \\n       groups = 2\\n       group = [1, 2, -1]\\n       \\n       After 3rd level\\n       queue = []\\n       groups = 3\\n       group = [1, 2, 3]\\n       Now, we are able to create groups... \\n       The question is, we have considered the 1st rule, \\n       but are we following the 2nd rule? Let\\'s have a look.\\n       \\n       [[1, 2], [2, 3], [3, 1]]\\n       \\n       [1, 2] = Math.abs(group[1] - group[2]) = Math.abs(1 - 2) = 1 - followed\\n       [2, 3] = Math.abs(group[2] - group[3]) = Math.abs(2 - 3) = 1 - followed\\n       [3, 1] = Math.abs(group[3] - group[1]) = Math.abs(3 - 1) = 2 - not followed\\n       \\n \\xA0 \\xA0 \\xA0 Where did we make this mistake??\\n       Let\\'s take a step back and think what we did.\\n       The weird thing we did is when we get 2 connected nodes in the same level, \\n       we have moved one node into the next group.\\n       Since we moved one node to the next group... We have increased the gap between 1 and 3.\\n       So, the 2nd condition was failed.\\n       According to this, if we get connected nodes in the same group, then we can\\'t form group.\\n       So, we can stop the processing there itself.\\n\\n       Note: Since the graph can be disconnected, we should do this for every component of the graph.\\n```\\n\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map;\\n    public int magnificentSets(int n, int[][] edges) {\\n        map = new HashMap<>();\\n        for(int i = 1; i <= n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        // adjacency list\\n        for(int[] edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            map.get(u).add(v);\\n            map.get(v).add(u);\\n        }\\n        \\n        // get all components as Graph can be disconnected\\n        List<List<Integer>> components = getComponents(n);\\n        \\n        int ans = 0;\\n        /*\\n            - Take each component and get max groups can be formed from that component\\n            - return -1 if you can\\'t form groups from any one of the components\\n        */\\n        for(List<Integer> component : components) {\\n            int groups = -1;\\n            for(int node : component) {\\n                groups = Math.max(groups, find(node, n));\\n            }\\n            if(groups == -1)\\n                return -1;\\n            ans += groups;\\n        }\\n        return ans;\\n    }\\n    \\n    private List<List<Integer>> getComponents(int n) {\\n        boolean[] visited = new boolean[n + 1];\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) {\\n            if(!visited[i]) {\\n                ans.add(visit(i, new ArrayList<>(), visited));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private List<Integer> visit(int cur, List<Integer> nodes, boolean[] visited) {\\n        visited[cur] = true;\\n        nodes.add(cur);\\n        for(int next : map.get(cur)) {\\n            // skip if you have already visited this node\\n            if(visited[next]) continue;\\n            visit(next, nodes, visited);\\n        }\\n        return nodes;\\n    }\\n    \\n    private int find(int node, int n) {\\n        int[] group = new int[n + 1];\\n        Arrays.fill(group, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(node);\\n        int groups = 0;\\n        while(!queue.isEmpty()) {\\n            int k = queue.size();\\n            // store nodes in set to avoid duplicates\\n            Set<Integer> set = new HashSet<>();\\n            while(k-- > 0) {\\n                int cur = queue.poll();\\n                // this case occurs when 2 nodes in the same level are connected\\n                // so, return -1\\n                if(group[cur] != -1) return -1;\\n                group[cur] = groups;\\n                for(int next : map.get(cur)) {\\n                    if(group[next] == -1) {\\n                        set.add(next);\\n                    }\\n                }\\n            }\\n            queue.addAll(set);\\n            groups++;\\n        }\\n        return groups;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n        the logic stays in find method in the code... How do we ensure that if we follow the given conditions?\\n \\xA0 \\xA0 \\xA0 \\xA0- if (a, b) are connected, a and b should be in different groups  and \\n                                    Math.abs(group[a] - group[b]) must be 1.\\n                                    \\n        there are 2 cases to consider... \\n        Let\\'s start with happy path... suppose the graph is like this\\n        \\n        graph: [[1, 2], [1, 4], [1, 3]]\\n        2 different types of groups can be formed\\n        G1 = [(1), (2, 3, 4)], G2 = [(3, 4), (1), (2)], G3 = [(4), (1), (2, 3)]\\n        So, we can form maximum of 3 groups from the above graph.\\n        - We can find these groups by doing a level wise traversal \\n        starting with every node in the group.\\n        \\n        Let\\'s take negative case:\\n        graph = [[1, 2], [2, 3], [3, 1]]\\n        \\n        Let\\'s do a level order traversal...\\n        adjacency list:\\n        1 -> 2, 3\\n        2 -> 1, 3\\n        3 -> 1, 2\\n        \\n        start = 1, groups = 0 (this is index of group)\\n        group = [-1, -1, -1] (1 - indexed) \\n        group - this stores the index of group in which node has been stored\\n        \\n        - Take queue to do level order traversal\\n        queue = [1]\\n        After 1st level\\n        queue = [2, 3] \\n        -> according to the rules, node 2 and node 3 must be in different groups as they are connected.\\n        -> let\\'s try to take only one of them\\n        revised queue = [2]\\n        groups = 1\\n        group = [0, -1, -1]\\n\\n       After 2nd level\\n       queue = [3] \\n       groups = 2\\n       group = [1, 2, -1]\\n       \\n       After 3rd level\\n       queue = []\\n       groups = 3\\n       group = [1, 2, 3]\\n       Now, we are able to create groups... \\n       The question is, we have considered the 1st rule, \\n       but are we following the 2nd rule? Let\\'s have a look.\\n       \\n       [[1, 2], [2, 3], [3, 1]]\\n       \\n       [1, 2] = Math.abs(group[1] - group[2]) = Math.abs(1 - 2) = 1 - followed\\n       [2, 3] = Math.abs(group[2] - group[3]) = Math.abs(2 - 3) = 1 - followed\\n       [3, 1] = Math.abs(group[3] - group[1]) = Math.abs(3 - 1) = 2 - not followed\\n       \\n \\xA0 \\xA0 \\xA0 Where did we make this mistake??\\n       Let\\'s take a step back and think what we did.\\n       The weird thing we did is when we get 2 connected nodes in the same level, \\n       we have moved one node into the next group.\\n       Since we moved one node to the next group... We have increased the gap between 1 and 3.\\n       So, the 2nd condition was failed.\\n       According to this, if we get connected nodes in the same group, then we can\\'t form group.\\n       So, we can stop the processing there itself.\\n\\n       Note: Since the graph can be disconnected, we should do this for every component of the graph.\\n```\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map;\\n    public int magnificentSets(int n, int[][] edges) {\\n        map = new HashMap<>();\\n        for(int i = 1; i <= n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        // adjacency list\\n        for(int[] edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            map.get(u).add(v);\\n            map.get(v).add(u);\\n        }\\n        \\n        // get all components as Graph can be disconnected\\n        List<List<Integer>> components = getComponents(n);\\n        \\n        int ans = 0;\\n        /*\\n            - Take each component and get max groups can be formed from that component\\n            - return -1 if you can\\'t form groups from any one of the components\\n        */\\n        for(List<Integer> component : components) {\\n            int groups = -1;\\n            for(int node : component) {\\n                groups = Math.max(groups, find(node, n));\\n            }\\n            if(groups == -1)\\n                return -1;\\n            ans += groups;\\n        }\\n        return ans;\\n    }\\n    \\n    private List<List<Integer>> getComponents(int n) {\\n        boolean[] visited = new boolean[n + 1];\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) {\\n            if(!visited[i]) {\\n                ans.add(visit(i, new ArrayList<>(), visited));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private List<Integer> visit(int cur, List<Integer> nodes, boolean[] visited) {\\n        visited[cur] = true;\\n        nodes.add(cur);\\n        for(int next : map.get(cur)) {\\n            // skip if you have already visited this node\\n            if(visited[next]) continue;\\n            visit(next, nodes, visited);\\n        }\\n        return nodes;\\n    }\\n    \\n    private int find(int node, int n) {\\n        int[] group = new int[n + 1];\\n        Arrays.fill(group, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(node);\\n        int groups = 0;\\n        while(!queue.isEmpty()) {\\n            int k = queue.size();\\n            // store nodes in set to avoid duplicates\\n            Set<Integer> set = new HashSet<>();\\n            while(k-- > 0) {\\n                int cur = queue.poll();\\n                // this case occurs when 2 nodes in the same level are connected\\n                // so, return -1\\n                if(group[cur] != -1) return -1;\\n                group[cur] = groups;\\n                for(int next : map.get(cur)) {\\n                    if(group[next] == -1) {\\n                        set.add(next);\\n                    }\\n                }\\n            }\\n            queue.addAll(set);\\n            groups++;\\n        }\\n        return groups;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874969,
                "title": "python3-unionfind-bfs",
                "content": "```\\n# Observation:\\n\\n# Each connected component with only 1 node takes up 1 group\\n# BFS through each component with > 1 node, and in the meantime also check if there are odd length cycles, if yes return -1\\n# The start node can be any node in the component (since n = 500, we can afford n^2), hence just bfs from every node and take the max groups for each component\\n\\n\\n# UnionFind class\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        # Use a rank array to record the height of each vertex, i.e., the \"rank\" of each vertex.\\n        # The initial \"rank\" of each vertex is 1, because each of them is\\n        # a standalone vertex with no connection to other vertices.\\n        self.rank = [1] * size\\n        self.connected = size\\n\\n    # The find function here is the same as that in the disjoint set with path compression.\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    # The union function with union by rank\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n            self.connected -= 1\\n\\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(list)\\n        ind = [0]*n\\n        uf = UnionFind(n)\\n        for x,y in edges:\\n            graph[x-1].append(y-1)\\n            graph[y-1].append(x-1)\\n            ind[x-1] += 1\\n            ind[y-1] += 1\\n            uf.union(x-1,y-1)\\n            \\n        \\n        order = defaultdict(list)\\n        for i in range(len(ind)):\\n            order[uf.find(i)].append(i)\\n                \\n        def bfs(start):\\n            \\n            q = deque()\\n            q.append((start,1))\\n            layers = defaultdict(int)\\n            layers[start] = 1\\n            ans = -1\\n            \\n            while q:\\n                for _ in range(len(q)):\\n                    node, layer = q.popleft()\\n                    if layer > ans:\\n                        ans = layer\\n                    for x in graph[node]:\\n                        if x not in layers:\\n                            q.append((x, layer+1))\\n                            layers[x] = layer+1\\n                        if layers[node] == layers[x]:\\n                            return -1\\n            return ans\\n        \\n        ans = 0\\n        \\n        for x in order:\\n            tmp = -1\\n            for startNode in order[x]:\\n                tmp = max(tmp, bfs(startNode))\\n            if tmp == -1:\\n                return -1\\n            ans += tmp\\n            \\n        return ans\\n  # Time O((m+n)^2) space O(n)",
                "solutionTags": [],
                "code": "```\\n# Observation:\\n\\n# Each connected component with only 1 node takes up 1 group\\n# BFS through each component with > 1 node, and in the meantime also check if there are odd length cycles, if yes return -1\\n# The start node can be any node in the component (since n = 500, we can afford n^2), hence just bfs from every node and take the max groups for each component\\n\\n\\n# UnionFind class\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        # Use a rank array to record the height of each vertex, i.e., the \"rank\" of each vertex.\\n        # The initial \"rank\" of each vertex is 1, because each of them is\\n        # a standalone vertex with no connection to other vertices.\\n        self.rank = [1] * size\\n        self.connected = size\\n\\n    # The find function here is the same as that in the disjoint set with path compression.\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    # The union function with union by rank\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n            self.connected -= 1\\n\\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(list)\\n        ind = [0]*n\\n        uf = UnionFind(n)\\n        for x,y in edges:\\n            graph[x-1].append(y-1)\\n            graph[y-1].append(x-1)\\n            ind[x-1] += 1\\n            ind[y-1] += 1\\n            uf.union(x-1,y-1)\\n            \\n        \\n        order = defaultdict(list)\\n        for i in range(len(ind)):\\n            order[uf.find(i)].append(i)\\n                \\n        def bfs(start):\\n            \\n            q = deque()\\n            q.append((start,1))\\n            layers = defaultdict(int)\\n            layers[start] = 1\\n            ans = -1\\n            \\n            while q:\\n                for _ in range(len(q)):\\n                    node, layer = q.popleft()\\n                    if layer > ans:\\n                        ans = layer\\n                    for x in graph[node]:\\n                        if x not in layers:\\n                            q.append((x, layer+1))\\n                            layers[x] = layer+1\\n                        if layers[node] == layers[x]:\\n                            return -1\\n            return ans\\n        \\n        ans = 0\\n        \\n        for x in order:\\n            tmp = -1\\n            for startNode in order[x]:\\n                tmp = max(tmp, bfs(startNode))\\n            if tmp == -1:\\n                return -1\\n            ans += tmp\\n            \\n        return ans\\n  # Time O((m+n)^2) space O(n)",
                "codeTag": "Java"
            },
            {
                "id": 2875120,
                "title": "c-simple-bfs-is-enough-with-explanation-in-o-v-e",
                "content": "Concept:\\n1. If any two nodes at the same level are connected during bfs proces, return `-1`\\n2. To know the above, use `unordered_map` to hash edges.\\n3. Use a initial node and run bfs, we can get a connected component with `level` that would indicate `# of group`. However, we don\\'t know which node to start with would yield the maximum `# of group`. **Here, implemented by `checkConnectedBfs`**\\n4. So, iterate each node in that component as the initial node to run bfs. **Here, implemented by `normalBfs`**\\n5. Time complexity: `O(|V| * |E|) = 500 (nodes) * 10^4 (edges)` could be acceptable.\\n```\\nclass Solution {\\npublic:\\n    \\n    int normalBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool> visited) {\\n        queue<int> q;\\n        q.push(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    q.push(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    int checkConnectedBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool>& visited) {\\n        vector<int> members;\\n        vector<bool> visitedCopy = visited;\\n        queue<int> q;\\n        q.push(start);\\n        members.push_back(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            vector<int> collections;\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    collections.push_back(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            // check if all nodes at the same level have any connection;\\n            int m = collections.size();\\n\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < i; ++j) {\\n                    if (hashEdges[collections[i]].count(collections[j])) return -1;\\n                }\\n            }\\n            for (int i = 0; i < m; ++i) {\\n                q.push(collections[i]);\\n                members.push_back(collections[i]);\\n            }\\n            level++;\\n        }\\n        for (auto& member : members) {\\n            level = max(level, normalBfs(member, hashEdges, visitedCopy));\\n        }\\n        return level;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, unordered_set<int>> hashEdges;\\n\\n        for (auto& edge : edges) {\\n            hashEdges[edge[0] - 1].insert(edge[1] - 1);\\n            hashEdges[edge[1] - 1].insert(edge[0] - 1);\\n        }\\n        vector<bool> visited(n, false);\\n        int maxRes = 0;\\n        \\n        for (int node = 0; node < n; ++node) {\\n            if (visited[node]) continue;\\n            int result = checkConnectedBfs(node, hashEdges, visited);\\n            if (result == -1) return -1;\\n            \\n            maxRes += result;\\n        }\\n        return maxRes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int normalBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool> visited) {\\n        queue<int> q;\\n        q.push(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    q.push(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    int checkConnectedBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool>& visited) {\\n        vector<int> members;\\n        vector<bool> visitedCopy = visited;\\n        queue<int> q;\\n        q.push(start);\\n        members.push_back(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            vector<int> collections;\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    collections.push_back(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            // check if all nodes at the same level have any connection;\\n            int m = collections.size();\\n\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < i; ++j) {\\n                    if (hashEdges[collections[i]].count(collections[j])) return -1;\\n                }\\n            }\\n            for (int i = 0; i < m; ++i) {\\n                q.push(collections[i]);\\n                members.push_back(collections[i]);\\n            }\\n            level++;\\n        }\\n        for (auto& member : members) {\\n            level = max(level, normalBfs(member, hashEdges, visitedCopy));\\n        }\\n        return level;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, unordered_set<int>> hashEdges;\\n\\n        for (auto& edge : edges) {\\n            hashEdges[edge[0] - 1].insert(edge[1] - 1);\\n            hashEdges[edge[1] - 1].insert(edge[0] - 1);\\n        }\\n        vector<bool> visited(n, false);\\n        int maxRes = 0;\\n        \\n        for (int node = 0; node < n; ++node) {\\n            if (visited[node]) continue;\\n            int result = checkConnectedBfs(node, hashEdges, visited);\\n            if (result == -1) return -1;\\n            \\n            maxRes += result;\\n        }\\n        return maxRes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937195,
                "title": "start-from-each-node",
                "content": "If we fix some node as a starting node, we can unambiguously divide our graph into groups (if it\\'s possible).\\n\\nTo find the best division, we can try each node as a starting node. This is a quadratic solution, which is expected since `n` is limited to `500`.\\n\\nThe confusing part, and the problem description does not call it out, is how to process subgraphs.\\n\\nYou are expected to find the best division for each subgraph, and then add them together.\\n\\nWe can identify subgraphs using BFS. In the code below, we discover connected nodes within the `partition` function, run `partition` again for those nodes, and return the best result.\\n\\n**C++**\\n```cpp\\nbool root_visited[501] = {};\\nint partition(int root, vector<vector<int>> &al) {\\n    if (exchange(root_visited[root], true))\\n        return 0;\\n    vector<int> q{root}, group(al.size(), -1);\\n    group[root] = 0;\\n    while(!q.empty()) {\\n        vector<int> q1;\\n        for (int i : q)\\n            for (int j : al[i])\\n                if (group[j] == -1) {\\n                    group[j] = group[i] + 1;\\n                    q1.push_back(j);\\n                }\\n                else if (abs(group[i] - group[j]) != 1)\\n                    return -1;\\n        swap(q, q1);\\n    }\\n    int res = 0;\\n    for(int i = 0; i < al.size(); ++i)\\n        if (group[i] != -1)\\n            res = max({res, group[i] + 1, partition(i, al)});\\n    return res;\\n}\\nint magnificentSets(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n + 1);\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int res = 0;\\n    for (int i = 1; i <= n; ++i)\\n        if (int set_groups = partition(i, al); set_groups == -1)\\n            return -1;\\n        else\\n            res += set_groups;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool root_visited[501] = {};\\nint partition(int root, vector<vector<int>> &al) {\\n    if (exchange(root_visited[root], true))\\n        return 0;\\n    vector<int> q{root}, group(al.size(), -1);\\n    group[root] = 0;\\n    while(!q.empty()) {\\n        vector<int> q1;\\n        for (int i : q)\\n            for (int j : al[i])\\n                if (group[j] == -1) {\\n                    group[j] = group[i] + 1;\\n                    q1.push_back(j);\\n                }\\n                else if (abs(group[i] - group[j]) != 1)\\n                    return -1;\\n        swap(q, q1);\\n    }\\n    int res = 0;\\n    for(int i = 0; i < al.size(); ++i)\\n        if (group[i] != -1)\\n            res = max({res, group[i] + 1, partition(i, al)});\\n    return res;\\n}\\nint magnificentSets(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n + 1);\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int res = 0;\\n    for (int i = 1; i <= n; ++i)\\n        if (int set_groups = partition(i, al); set_groups == -1)\\n            return -1;\\n        else\\n            res += set_groups;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2876532,
                "title": "java-beats-100-dfs-bfs",
                "content": "# Intuition\\n1. The only way to conform to the |x-y| = 1 property is when the graph doesn\\'t contain an odd length cycle == `bipartite graph`\\n2. We can run a bfs algorithm on all the connected components independently to find the longest path from any vertex `u` to `v`\\n3. We need to exercise all possible vertices of a connected component, the constraints are small enough to run `O(v(v+e))` bfs (start bfs from all vertices);\\n\\n# Code\\n```\\n class Solution {\\n    public int magnificentSets(int n, int[][] edges) {\\n        // bfs -> will detect odd cycle (graph must be bipartite==not have an odd cycle)\\n        // for each component take the maximum\\n        // dfs -> to partition into components\\n        \\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int node = 1; node <= n; node++) {\\n            graph.put(node, new ArrayList<>());\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        \\n        Map<Integer, List<Integer>> components = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>();\\n        int component = 1;\\n        for (int node = 1; node <= n; node++) {\\n            if(visited.contains(node)) continue;\\n            visited.add(node);\\n            components.put(component, new ArrayList<>());\\n            dfsComponents(component++, node, graph, components, visited);    \\n        }\\n        int[] componentsMaxTravel = new int[component];\\n        int finalRes = 0;\\n        for(int comp = 1; comp < component; comp++) {\\n            for (int compNode : components.get(comp)) {\\n                \\n                int compRes = bfs(compNode, graph);\\n                if(compRes == -1) return -1;\\n                componentsMaxTravel[comp] = Math.max(componentsMaxTravel[comp], compRes);\\n            }\\n            finalRes += componentsMaxTravel[comp];\\n        }\\n\\n        return finalRes;\\n        \\n    }\\n\\n    private void dfsComponents(int component, int node, Map<Integer, List<Integer>> graph, Map<Integer, List<Integer>> components, Set<Integer> visited) {\\n        components.get(component).add(node);\\n        for (int neighbor : graph.get(node)) {\\n            // happens when there is more than one spanning tree. I.E you can arrive at a node in more than one way\\n            if(visited.contains(neighbor)) continue;\\n            visited.add(neighbor);\\n            dfsComponents(component, neighbor, graph, components, visited);\\n        }\\n    }\\n\\n    private int bfs(int node, Map<Integer, List<Integer>> graph) {\\n        int reach = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        Set<Integer> curLevel = new HashSet<>();\\n        \\n        queue.offer(node);\\n        visited.add(node);\\n        \\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            Set<Integer> nextLevel = new HashSet<>();\\n\\n            \\n            \\n            for (int i = 0; i < n; i++) {\\n                int curNode = queue.poll();\\n\\n                for(int neighbor : graph.get(curNode)) {\\n                    if(curLevel.contains(neighbor)) return -1; // Colored with different color == not bipartite\\n                    if(visited.contains(neighbor)) continue;\\n                    nextLevel.add(neighbor);\\n                    visited.add(neighbor);\\n                    queue.offer(neighbor);\\n                }\\n            }\\n\\n            curLevel = nextLevel;\\n            reach++;\\n        }\\n        \\n        return reach;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution {\\n    public int magnificentSets(int n, int[][] edges) {\\n        // bfs -> will detect odd cycle (graph must be bipartite==not have an odd cycle)\\n        // for each component take the maximum\\n        // dfs -> to partition into components\\n        \\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int node = 1; node <= n; node++) {\\n            graph.put(node, new ArrayList<>());\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        \\n        Map<Integer, List<Integer>> components = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>();\\n        int component = 1;\\n        for (int node = 1; node <= n; node++) {\\n            if(visited.contains(node)) continue;\\n            visited.add(node);\\n            components.put(component, new ArrayList<>());\\n            dfsComponents(component++, node, graph, components, visited);    \\n        }\\n        int[] componentsMaxTravel = new int[component];\\n        int finalRes = 0;\\n        for(int comp = 1; comp < component; comp++) {\\n            for (int compNode : components.get(comp)) {\\n                \\n                int compRes = bfs(compNode, graph);\\n                if(compRes == -1) return -1;\\n                componentsMaxTravel[comp] = Math.max(componentsMaxTravel[comp], compRes);\\n            }\\n            finalRes += componentsMaxTravel[comp];\\n        }\\n\\n        return finalRes;\\n        \\n    }\\n\\n    private void dfsComponents(int component, int node, Map<Integer, List<Integer>> graph, Map<Integer, List<Integer>> components, Set<Integer> visited) {\\n        components.get(component).add(node);\\n        for (int neighbor : graph.get(node)) {\\n            // happens when there is more than one spanning tree. I.E you can arrive at a node in more than one way\\n            if(visited.contains(neighbor)) continue;\\n            visited.add(neighbor);\\n            dfsComponents(component, neighbor, graph, components, visited);\\n        }\\n    }\\n\\n    private int bfs(int node, Map<Integer, List<Integer>> graph) {\\n        int reach = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        Set<Integer> curLevel = new HashSet<>();\\n        \\n        queue.offer(node);\\n        visited.add(node);\\n        \\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            Set<Integer> nextLevel = new HashSet<>();\\n\\n            \\n            \\n            for (int i = 0; i < n; i++) {\\n                int curNode = queue.poll();\\n\\n                for(int neighbor : graph.get(curNode)) {\\n                    if(curLevel.contains(neighbor)) return -1; // Colored with different color == not bipartite\\n                    if(visited.contains(neighbor)) continue;\\n                    nextLevel.add(neighbor);\\n                    visited.add(neighbor);\\n                    queue.offer(neighbor);\\n                }\\n            }\\n\\n            curLevel = nextLevel;\\n            reach++;\\n        }\\n        \\n        return reach;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875164,
                "title": "union-find-bfs-with-explanation-and-more",
                "content": "First lets solve a simpler version of the problem\\nasume all the nodes are connected\\nlets run a BFS from every node in the graph and if at any point in the BFS we visit a node that is already visited and the abs(currectDepth - nodeDepth) != 1 we return -1 and we do that for every node in the graph\\nif any node returns -1 then there is no solution\\n\\nNow for the actual problem \\nwe first need to get the number of connected components in the graph\\nand for each component we loop over it\\'s nodes and try a BFS from evey one \\nif any component doesn\\'t have a solution we return -1\\nthe total answer is the sum of all components groups count\\n     time: O(E + N + N*(N + E))\\n     space: O(N + E)\\n\\n```\\nclass Solution {\\npublic:\\n    int parent[501];\\n    int root(int v) {\\n        return parent[v] < 0 ? v : (parent[v] = root(parent[v]));\\n    }\\n    void merge(int x, int y) {\\n        x = root(x);\\n        y = root(y);\\n        if (x == y) return;\\n        if (parent[x] > parent[y]) swap(x,y);\\n        parent[x] += parent[y];\\n        parent[y] = x;\\n    }\\n    /*\\n     E = Number of edges\\n     N = number of nodes;\\n     time: O(E + N + N*(N + E))\\n     space: O(N + E)\\n    */\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        memset(parent, -1, sizeof parent);\\n        for(auto& e: edges) {\\n            adj[e[0] - 1].push_back(e[1] - 1);\\n            adj[e[1] - 1].push_back(e[0] - 1);\\n            merge(e[0]-1,e[1]-1);\\n        }\\n        unordered_map<int, vector<int>> connectedComponents;\\n        for(int i = 0; i < n; i++) {\\n            connectedComponents[root(i)].push_back(i);\\n        }\\n        int totalNumberofGroup = 0;\\n        for(auto& [val, nodes] : connectedComponents) {\\n           int componentGroups = -1; \\n            for(auto node: nodes) {\\n                componentGroups = max(componentGroups, bfs(node,adj,n));\\n\\t\\t\\t\\tif (componentGroups == -1) return -1;\\n            }\\n            totalNumberofGroup += componentGroups;\\n        }\\n        return totalNumberofGroup;\\n\\n    }\\n    int bfs(int s, vector<vector<int>>& adj, int& n) { // O(N + E)\\n        vector<int> vis(n , -1);\\n        vis[s] = 0;\\n        int depth = 0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int sz = size(q);\\n            while(sz--) {\\n                auto tp = q.front();\\n                q.pop();\\n                for(auto& j: adj[tp]) {\\n                    if (vis[j] == -1) {\\n                        vis[j] = depth + 1;\\n                        q.push(j);\\n                    } else if (abs(vis[j] - depth) != 1) return -1;\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int parent[501];\\n    int root(int v) {\\n        return parent[v] < 0 ? v : (parent[v] = root(parent[v]));\\n    }\\n    void merge(int x, int y) {\\n        x = root(x);\\n        y = root(y);\\n        if (x == y) return;\\n        if (parent[x] > parent[y]) swap(x,y);\\n        parent[x] += parent[y];\\n        parent[y] = x;\\n    }\\n    /*\\n     E = Number of edges\\n     N = number of nodes;\\n     time: O(E + N + N*(N + E))\\n     space: O(N + E)\\n    */\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        memset(parent, -1, sizeof parent);\\n        for(auto& e: edges) {\\n            adj[e[0] - 1].push_back(e[1] - 1);\\n            adj[e[1] - 1].push_back(e[0] - 1);\\n            merge(e[0]-1,e[1]-1);\\n        }\\n        unordered_map<int, vector<int>> connectedComponents;\\n        for(int i = 0; i < n; i++) {\\n            connectedComponents[root(i)].push_back(i);\\n        }\\n        int totalNumberofGroup = 0;\\n        for(auto& [val, nodes] : connectedComponents) {\\n           int componentGroups = -1; \\n            for(auto node: nodes) {\\n                componentGroups = max(componentGroups, bfs(node,adj,n));\\n\\t\\t\\t\\tif (componentGroups == -1) return -1;\\n            }\\n            totalNumberofGroup += componentGroups;\\n        }\\n        return totalNumberofGroup;\\n\\n    }\\n    int bfs(int s, vector<vector<int>>& adj, int& n) { // O(N + E)\\n        vector<int> vis(n , -1);\\n        vis[s] = 0;\\n        int depth = 0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int sz = size(q);\\n            while(sz--) {\\n                auto tp = q.front();\\n                q.pop();\\n                for(auto& j: adj[tp]) {\\n                    if (vis[j] == -1) {\\n                        vis[j] = depth + 1;\\n                        q.push(j);\\n                    } else if (abs(vis[j] - depth) != 1) return -1;\\n                }\\n            }\\n            depth++;\\n        }\\n        return depth;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876893,
                "title": "easy-c-bfs-solution-using-connected-components",
                "content": "# Observations\\n- Two nodes sharing an edge can\\'t be in same group,as |x - y| != 1.\\n- An easy approach to try this problem would be to consider BFS method, then we can easily think and build a solution, as we need to consider all the adjacent nodes to be in different group than the current node.\\n\\n# Approach\\nAs given, the graph maybe disconnected, then we need to find the maximum groups the nodes of each connected component can be divided, then we can just return sum of the answers of all components.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // bfs for finding \\'m\\' groups if possible\\n    int bfs(vector<vector<int>> g, int u, int n) {\\n        queue<int> q;\\n        q.push(u);\\n        // vector to check which node is in which group\\n        vector<int> vt(n, -1);\\n        vt[u] = 1;  // Take node \\'u\\' in \\'Group 1\\'\\n        int ans = 1, f = 1;\\n        while(!q.empty()) {\\n            int i = q.front();\\n            ans = max(ans, vt[i]);\\n            q.pop();\\n            for(auto &v : g[i]) {\\n                // Check If the node is already visited, then is it following |y - x| = 1 condition\\n                if(vt[v] != -1 && abs(vt[i] - vt[v]) != 1) {\\n                    return -1;\\n                }\\n                if(vt[v] != -1) continue;\\n                vt[v] = vt[i] + 1;\\n                q.push(v);\\n            }\\n            if(!f)  break;\\n        }\\n        return ans;\\n    }\\n\\n    // dfs for finding connect components\\n    void dfs(vector<vector<int>> &g, int u, vector<bool> &vt, vector<int> &a) {\\n        a.push_back(u);\\n        vt[u] = true;\\n        for(auto &v : g[u]) {\\n            if(vt[v])   continue;\\n            dfs(g,v,vt,a);\\n        }\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        // Create adj list\\n        vector<vector<int>> g(n);\\n        for(auto edge : edges) {\\n            g[edge[0] - 1].push_back(edge[1] - 1);\\n            g[edge[1] - 1].push_back(edge[0] - 1);\\n        }\\n\\n\\n        // Create list of Connected Components\\n        vector<vector<int>> conComp;\\n        vector<bool> vt(n, false); // visited vector\\n        vector<int> tmp; // temporary vector for storing connect components\\n        for(int i = 0 ; i < n ; i++) {\\n            if(!vt[i]) {\\n                dfs(g,i,vt,tmp);\\n                conComp.push_back(tmp);\\n                tmp.clear();\\n            }\\n        }\\n\\n        int res = 0;\\n        // Traverse through all the components\\n        for(auto &comp : conComp) {\\n            int ans = -1;\\n            // In each components, try which node gives the best answer\\n            for(int i : comp) {\\n                ans = max(ans, bfs(g,i,n));\\n            }\\n            // Even after trying all nodes if we don\\'t find an answer,\\n            // then it is not possible to make a group\\n            if(ans == -1) {\\n                return -1;\\n            }\\n            else res += ans;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(N * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N * N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // bfs for finding \\'m\\' groups if possible\\n    int bfs(vector<vector<int>> g, int u, int n) {\\n        queue<int> q;\\n        q.push(u);\\n        // vector to check which node is in which group\\n        vector<int> vt(n, -1);\\n        vt[u] = 1;  // Take node \\'u\\' in \\'Group 1\\'\\n        int ans = 1, f = 1;\\n        while(!q.empty()) {\\n            int i = q.front();\\n            ans = max(ans, vt[i]);\\n            q.pop();\\n            for(auto &v : g[i]) {\\n                // Check If the node is already visited, then is it following |y - x| = 1 condition\\n                if(vt[v] != -1 && abs(vt[i] - vt[v]) != 1) {\\n                    return -1;\\n                }\\n                if(vt[v] != -1) continue;\\n                vt[v] = vt[i] + 1;\\n                q.push(v);\\n            }\\n            if(!f)  break;\\n        }\\n        return ans;\\n    }\\n\\n    // dfs for finding connect components\\n    void dfs(vector<vector<int>> &g, int u, vector<bool> &vt, vector<int> &a) {\\n        a.push_back(u);\\n        vt[u] = true;\\n        for(auto &v : g[u]) {\\n            if(vt[v])   continue;\\n            dfs(g,v,vt,a);\\n        }\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        // Create adj list\\n        vector<vector<int>> g(n);\\n        for(auto edge : edges) {\\n            g[edge[0] - 1].push_back(edge[1] - 1);\\n            g[edge[1] - 1].push_back(edge[0] - 1);\\n        }\\n\\n\\n        // Create list of Connected Components\\n        vector<vector<int>> conComp;\\n        vector<bool> vt(n, false); // visited vector\\n        vector<int> tmp; // temporary vector for storing connect components\\n        for(int i = 0 ; i < n ; i++) {\\n            if(!vt[i]) {\\n                dfs(g,i,vt,tmp);\\n                conComp.push_back(tmp);\\n                tmp.clear();\\n            }\\n        }\\n\\n        int res = 0;\\n        // Traverse through all the components\\n        for(auto &comp : conComp) {\\n            int ans = -1;\\n            // In each components, try which node gives the best answer\\n            for(int i : comp) {\\n                ans = max(ans, bfs(g,i,n));\\n            }\\n            // Even after trying all nodes if we don\\'t find an answer,\\n            // then it is not possible to make a group\\n            if(ans == -1) {\\n                return -1;\\n            }\\n            else res += ans;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875191,
                "title": "bfs-dsu-java",
                "content": "```java\\nclass Solution {\\n    List<List<Integer>> adj;int[] dsu;\\n    public int magnificentSets(int n, int[][] edges) {\\n        dsu = new int[n+1];\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        for(int i=0;i<=n;i++) dsu[i] =i;\\n        adj = new ArrayList<>();\\n        for(int i=0;i<=n;i++)  adj.add(new ArrayList<>());\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n            dsu[find(e[0])] = find(e[1]);\\n        }\\n        int ans = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=1;i<=n;i++){\\n            dp[find(i)] = Math.max(dp[find(i)],bfs(i,n));\\n            map.put(find(i),dp[find(i)]);\\n        }\\n        for(int a:map.values()){\\n            if(a==-1) return -1;\\n            ans += a;\\n        }\\n        return ans==0?-1:ans;\\n    }\\n    int find(int i){\\n        if(dsu[i]==i) return i;\\n        return dsu[i] = find(dsu[i]);\\n    }\\n    int bfs(int i,int n){\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> pre = new HashSet<>(),cur = new HashSet<>();\\n        q.offer(i);\\n        cur.add(i);\\n        boolean[] vis = new boolean[n+1];\\n        vis[i]=true;\\n        int c = 0;\\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            c++;\\n            Set<Integer> next = new HashSet<>();\\n            while(sz-->0){\\n                int a = q.poll();\\n                for(int e:adj.get(a)){\\n                    if(!pre.contains(e)&&!next.contains(e)){\\n                        if(vis[e]) return -1;\\n                        q.offer(e);vis[e] = true;\\n                        next.add(e);\\n                    }\\n                }\\n            }\\n            pre = cur;cur = next;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    List<List<Integer>> adj;int[] dsu;\\n    public int magnificentSets(int n, int[][] edges) {\\n        dsu = new int[n+1];\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        for(int i=0;i<=n;i++) dsu[i] =i;\\n        adj = new ArrayList<>();\\n        for(int i=0;i<=n;i++)  adj.add(new ArrayList<>());\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n            dsu[find(e[0])] = find(e[1]);\\n        }\\n        int ans = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=1;i<=n;i++){\\n            dp[find(i)] = Math.max(dp[find(i)],bfs(i,n));\\n            map.put(find(i),dp[find(i)]);\\n        }\\n        for(int a:map.values()){\\n            if(a==-1) return -1;\\n            ans += a;\\n        }\\n        return ans==0?-1:ans;\\n    }\\n    int find(int i){\\n        if(dsu[i]==i) return i;\\n        return dsu[i] = find(dsu[i]);\\n    }\\n    int bfs(int i,int n){\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> pre = new HashSet<>(),cur = new HashSet<>();\\n        q.offer(i);\\n        cur.add(i);\\n        boolean[] vis = new boolean[n+1];\\n        vis[i]=true;\\n        int c = 0;\\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            c++;\\n            Set<Integer> next = new HashSet<>();\\n            while(sz-->0){\\n                int a = q.poll();\\n                for(int e:adj.get(a)){\\n                    if(!pre.contains(e)&&!next.contains(e)){\\n                        if(vis[e]) return -1;\\n                        q.offer(e);vis[e] = true;\\n                        next.add(e);\\n                    }\\n                }\\n            }\\n            pre = cur;cur = next;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888106,
                "title": "python3-memory-efficient-solution-with-detailed-explanation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe graph must be bipartite in order to seperate like this. The proof is not too hard:\\n\\n1. No cycle: we can separate the graph and it is by definition bipartite.\\n2. Cycle with odd length: (suppose we label them 1,2,...,m and start assignment from 1) no matter how we alternate groups, we will find it impossible to get back to the original group for the starting point.\\n3. Only cycle with even length: this is by definition bipartite, so we can separate points into 2 groups (black and red). The separation will be constructed interatively as follows: **(a)** starting with a red node and assign it to group 1; **(b)** find all black nodes connected to the red node and assign them to group 2; **(c)** find all red nodes connected to group 2 (but excluding group 1) and assign them to group 3; **(d)** iterate the process and we can get a possible separation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nObservation:\\n1. the construction process in above bullet point 3 can be also applied to bullet point 1. \\n2. Based on the construction process, it would be always optimal to use as less points as possible at the beginning. So we always start with just 1 point and iterate all points within the graph to find the max.\\n3. We can do the same thing for each connected component.\\n\\nSo the approach is clear: check bipartite and find the possible max. We can combine these two. The search for connected component is inherent in BFS, so we just need one more hashmap to store the group information.\\n\\n# Complexity\\n- Time complexity: O(V*(V+E)). The repetition of painting nodes still allows some space for optimization.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n\\n        for p1,p2 in edges:\\n            graph[p1].append(p2)\\n            graph[p2].append(p1)\\n\\n        dist = [0] * (n+1)\\n        group_dict = {}\\n        group = 0\\n        MAX = 0\\n\\n        for i in range(1,n+1):\\n            # group assignment\\n            if i not in group_dict:\\n                group = MAX +  1\\n                MAX = group\\n            else:\\n                group = group_dict[i]\\n\\n            seen = set()\\n            seen.add(i)\\n            q = [i]\\n            level = 0\\n\\n            # color used to check bipartite\\n            color = [0] * n\\n            color[i-1] = 1\\n            c_color = -1\\n\\n            group_dict[i] = group\\n\\n            while q:\\n                tmp = []\\n                for p in q:\\n                    for node in graph[p]:\\n                        if color[p-1] * color[node-1] > 0: # check if parent and child can be painted using differen color\\n                            return -1\\n                        if node not in seen:\\n                            seen.add(node)\\n                            tmp.append(node)\\n\\n                            group_dict[node] = group # assign to connected component\\n                            color[node-1] = c_color # paint the node\\n\\n                c_color *= -1 # alternate color\\n                level += 1\\n                q = tmp\\n            \\n            dist[group] = max(dist[group],level) # only corresponding group is updated\\n    \\n        return sum(dist)\\n            \\n            \\n\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n\\n        for p1,p2 in edges:\\n            graph[p1].append(p2)\\n            graph[p2].append(p1)\\n\\n        dist = [0] * (n+1)\\n        group_dict = {}\\n        group = 0\\n        MAX = 0\\n\\n        for i in range(1,n+1):\\n            # group assignment\\n            if i not in group_dict:\\n                group = MAX +  1\\n                MAX = group\\n            else:\\n                group = group_dict[i]\\n\\n            seen = set()\\n            seen.add(i)\\n            q = [i]\\n            level = 0\\n\\n            # color used to check bipartite\\n            color = [0] * n\\n            color[i-1] = 1\\n            c_color = -1\\n\\n            group_dict[i] = group\\n\\n            while q:\\n                tmp = []\\n                for p in q:\\n                    for node in graph[p]:\\n                        if color[p-1] * color[node-1] > 0: # check if parent and child can be painted using differen color\\n                            return -1\\n                        if node not in seen:\\n                            seen.add(node)\\n                            tmp.append(node)\\n\\n                            group_dict[node] = group # assign to connected component\\n                            color[node-1] = c_color # paint the node\\n\\n                c_color *= -1 # alternate color\\n                level += 1\\n                q = tmp\\n            \\n            dist[group] = max(dist[group],level) # only corresponding group is updated\\n    \\n        return sum(dist)\\n            \\n            \\n\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883356,
                "title": "c-union-find-bfs-solution",
                "content": "## complexity:\\nsince bfs to a node is $$V+E$$, do it for each node would be $$V*(V+E)$$\\ntime: $$O(V*(V+E))$$ \\n\\nspace: $$O(V+E)$$\\n## code:\\n```\\n\\nclass UnionFind {\\npublic:\\n    unordered_map<int, int> uf;\\n\\n    int find(int a) {\\n        if(!uf.count(a))\\n            uf[a] = a;\\n        if(uf[a] != a)\\n            uf[a] = find(uf[a]);\\n        return uf[a];\\n    }\\n    void merge(int a, int b) {\\n        uf[find(b)] = find(a);\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        auto uf = UnionFind();\\n        vector<vector<int>> graph(n+1);\\n        for(auto edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            uf.merge(edge[0], edge[1]);\\n        }\\n        \\n        vector<int> max_groups(n+1, 0);\\n        for(int i = 1; i < n+1; i++) {\\n            deque<pair<int, int>> queue = {{i, 1}};\\n            vector<int> visited(n+1, 0);\\n            visited[i] = 1;\\n            while(!queue.empty()) {\\n                auto pop = queue.front();\\n                int cur = pop.first, level = pop.second;\\n                queue.pop_front();\\n                for(auto& edge: graph[cur]) {\\n                    if(!visited[edge]) {\\n                        queue.push_back({edge, level+1});\\n                        visited[edge] = level+1;\\n                    }\\n\\n                    if(level == visited[edge])\\n                        return -1;\\n                }\\n                int root = uf.find(i);\\n                max_groups[root] = max(max_groups[root], level);\\n            }\\n        }\\n        int res = 0;\\n        for(int ele: max_groups)\\n            res+=ele;\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass UnionFind {\\npublic:\\n    unordered_map<int, int> uf;\\n\\n    int find(int a) {\\n        if(!uf.count(a))\\n            uf[a] = a;\\n        if(uf[a] != a)\\n            uf[a] = find(uf[a]);\\n        return uf[a];\\n    }\\n    void merge(int a, int b) {\\n        uf[find(b)] = find(a);\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        auto uf = UnionFind();\\n        vector<vector<int>> graph(n+1);\\n        for(auto edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            uf.merge(edge[0], edge[1]);\\n        }\\n        \\n        vector<int> max_groups(n+1, 0);\\n        for(int i = 1; i < n+1; i++) {\\n            deque<pair<int, int>> queue = {{i, 1}};\\n            vector<int> visited(n+1, 0);\\n            visited[i] = 1;\\n            while(!queue.empty()) {\\n                auto pop = queue.front();\\n                int cur = pop.first, level = pop.second;\\n                queue.pop_front();\\n                for(auto& edge: graph[cur]) {\\n                    if(!visited[edge]) {\\n                        queue.push_back({edge, level+1});\\n                        visited[edge] = level+1;\\n                    }\\n\\n                    if(level == visited[edge])\\n                        return -1;\\n                }\\n                int root = uf.find(i);\\n                max_groups[root] = max(max_groups[root], level);\\n            }\\n        }\\n        int res = 0;\\n        for(int ele: max_groups)\\n            res+=ele;\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877699,
                "title": "easy-to-understand-java-solution-bipartite-union-find-bfs",
                "content": "The idea contains mainly two parts: \\n1. This graph must be one bipartite and inspect this bipartite at the beginning.\\n\\n2. Separate graph into unconnected parts using UnionFind, then find maximum path in each component (that is not connected in original graph) using Breadth-First Search.\\n\\nThe first part is straight-forward if you know bipartite: https://leetcode.com/problems/is-graph-bipartite/\\nThe second part is a little twisted: Each individual connected component that is not connected in graph will contribute to maximum nubmer of groups separately.\\n\\nExample: Let \\'-\\' and \\'|\\' represent that two components are connected.\\n\\n```\\n[0, 1, 2, 3, 4 - 5 - 6, 8 - 9]\\n                 |\\n                 7\\n```\\n\\nThen the maximum number of groups is 1 + 1 + 1 + 1 + max(3, 2, 3, 3) + max(2, 2) = 4 + 3 + 2 = 9.\\n\\nAssume size of graph is N, because this algorithm needs to traverse all individual connected components (that are not  connected in original graph) and need to start from each element in each individual connected component, therefore, time complexity is O (N + (# of individual components) * (# of element in each individual component)^2).\\n\\nTime complexity: O(N + N * N^2) ~ O(N^3).\\n\\nSpace complexity: O(N).\\n\\n```java\\nclass Solution {\\n    class UnionFind {\\n        int[] parent;\\n        public UnionFind(int size) {\\n            parent = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        public int find(int x) {\\n            if (x != parent[x]) {\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n        public boolean union(int x, int y) {\\n            int px = find(x);\\n            int py = find(y);\\n            if (px != py) {\\n                parent[py] = px;\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n    private boolean bfs(List<List<Integer>> graph, int node, Map<Integer, Integer> colorMap) {\\n        // edge cases\\n        if (colorMap.containsKey(node)) {\\n            return true;\\n        }\\n        // normal cases\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(node);\\n        colorMap.put(node, 0);\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            int neiColor = 1 - colorMap.get(curr);\\n            for (int nei : graph.get(curr)) {\\n                if (!colorMap.containsKey(nei)) {\\n                    colorMap.put(nei, neiColor);\\n                    queue.offer(nei);\\n                } else if (colorMap.get(nei) != neiColor) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public int magnificentSets(int n, int[][] edges) {\\n        // edge cases\\n        if (n == 1) {\\n            return 1;\\n        }\\n        // normal cases\\n        List<List<Integer>> graph = new ArrayList<>();\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int v = edge[0] - 1;\\n            int w = edge[1] - 1;\\n            graph.get(v).add(w);\\n            graph.get(w).add(v);\\n            uf.union(v, w);\\n        }\\n\\t\\t// check bipartite\\n        Map<Integer, Integer> colorMap = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (!bfs(graph, i, colorMap)) {\\n                return -1;\\n            }\\n        }\\n\\t\\t// get non-connected individual connected components\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int parent = uf.find(i);\\n            if (!map.containsKey(parent)) {\\n                map.put(parent, new ArrayList<>());\\n            }\\n            map.get(parent).add(i);\\n        }\\n\\t\\t// calculate contribution from maximum path of non-connected individual connected components\\n        int result = 0;\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n];\\n        for (int key : map.keySet()) {\\n            List<Integer> list = map.get(key);            \\n            if (list.size() == 1) {\\n                result += 1;\\n                continue;\\n            }\\n            int currMax = 0;\\n            for (int i : list) {\\n                int level = 0;\\n                queue.clear();\\n                Arrays.fill(visited, false);\\n                queue.offer(i);\\n                visited[i] = true;\\n                while (!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    for (int j = 0; j < size; j++) {\\n                        int curr = queue.poll();\\n                        for (int nei : graph.get(curr)) {\\n                            if (!visited[nei]) {\\n                                visited[nei] = true;\\n                                queue.offer(nei);\\n                            }\\n                        }\\n                    }\\n                    level++;\\n                }\\n                currMax = Math.max(currMax, level);\\n            }\\n            result += currMax;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\n[0, 1, 2, 3, 4 - 5 - 6, 8 - 9]\\n                 |\\n                 7\\n```\n```java\\nclass Solution {\\n    class UnionFind {\\n        int[] parent;\\n        public UnionFind(int size) {\\n            parent = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        public int find(int x) {\\n            if (x != parent[x]) {\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n        public boolean union(int x, int y) {\\n            int px = find(x);\\n            int py = find(y);\\n            if (px != py) {\\n                parent[py] = px;\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n    private boolean bfs(List<List<Integer>> graph, int node, Map<Integer, Integer> colorMap) {\\n        // edge cases\\n        if (colorMap.containsKey(node)) {\\n            return true;\\n        }\\n        // normal cases\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(node);\\n        colorMap.put(node, 0);\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            int neiColor = 1 - colorMap.get(curr);\\n            for (int nei : graph.get(curr)) {\\n                if (!colorMap.containsKey(nei)) {\\n                    colorMap.put(nei, neiColor);\\n                    queue.offer(nei);\\n                } else if (colorMap.get(nei) != neiColor) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public int magnificentSets(int n, int[][] edges) {\\n        // edge cases\\n        if (n == 1) {\\n            return 1;\\n        }\\n        // normal cases\\n        List<List<Integer>> graph = new ArrayList<>();\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int v = edge[0] - 1;\\n            int w = edge[1] - 1;\\n            graph.get(v).add(w);\\n            graph.get(w).add(v);\\n            uf.union(v, w);\\n        }\\n\\t\\t// check bipartite\\n        Map<Integer, Integer> colorMap = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (!bfs(graph, i, colorMap)) {\\n                return -1;\\n            }\\n        }\\n\\t\\t// get non-connected individual connected components\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int parent = uf.find(i);\\n            if (!map.containsKey(parent)) {\\n                map.put(parent, new ArrayList<>());\\n            }\\n            map.get(parent).add(i);\\n        }\\n\\t\\t// calculate contribution from maximum path of non-connected individual connected components\\n        int result = 0;\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n];\\n        for (int key : map.keySet()) {\\n            List<Integer> list = map.get(key);            \\n            if (list.size() == 1) {\\n                result += 1;\\n                continue;\\n            }\\n            int currMax = 0;\\n            for (int i : list) {\\n                int level = 0;\\n                queue.clear();\\n                Arrays.fill(visited, false);\\n                queue.offer(i);\\n                visited[i] = true;\\n                while (!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    for (int j = 0; j < size; j++) {\\n                        int curr = queue.poll();\\n                        for (int nei : graph.get(curr)) {\\n                            if (!visited[nei]) {\\n                                visited[nei] = true;\\n                                queue.offer(nei);\\n                            }\\n                        }\\n                    }\\n                    level++;\\n                }\\n                currMax = Math.max(currMax, level);\\n            }\\n            result += currMax;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876848,
                "title": "bipartite-bfs-union-find-explained",
                "content": "![image](https://assets.leetcode.com/users/images/073ee32a-92ad-4a14-92fe-4050b7cf6e44_1670154202.2713478.jpeg)\\n\\n````\\nclass Solution {\\npublic:\\n    \\n    bool bipartite(vector<int>adj[] ,vector<int>&color)\\n    {\\n        queue<int>q;\\n        q.push(1);\\n        color[1]=1;\\n        \\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto it:adj[node])\\n            {\\n                if(color[it]==-1)\\n                {\\n                    color[it]=1-color[node];\\n                    q.push(it);\\n                }\\n                else if(color[it] == color[node])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int maxDepth(int x ,int n, vector<int>adj[])\\n    {\\n        \\n        vector<int>vis(n+1);\\n        \\n        queue<int>q;\\n        q.push(x);\\n        vis[x]=1;\\n        \\n        int depth = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            while(size--)\\n            {\\n                int node = q.front();\\n                q.pop();\\n\\n                for(auto it:adj[node])\\n                {\\n                    if(!vis[it])\\n                    {\\n                        vis[it]=1;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }\\n    \\n    \\n    // UNION FIND CODE\\n    \\n    \\n    int rank[100001];\\n    int parent[100001];\\n    \\n    int findUPar(int node)\\n    {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n    \\n    void mergeRank(int u , int v)\\n    {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int>adj[n+1];\\n        vector<int>color(n+1,-1);\\n        \\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        // CONDITION - 1\\n        \\n        if(!bipartite(adj,color))\\n            return -1;\\n        \\n        // Union Find \\n        \\n        for(int i=1 ; i<=n ; i++)\\n        {\\n            rank[i]=0;\\n            parent[i]=i;\\n        }\\n        \\n        for(auto x:edges)\\n        {\\n            mergeRank(x[0],x[1]);\\n        }\\n        \\n        // now group all together \\n        map<int,vector<int>>mp;\\n        \\n        for(int node=1 ; node<=n ; node++)\\n        {\\n            int par = findUPar(node);\\n            mp[par].push_back(node);\\n        }\\n        \\n        // now grouping done \\n        // find the max depth of each group and add all together \\n        \\n        int res = 0;\\n        \\n        for(auto i:mp)\\n        {\\n            int maxi = INT_MIN;\\n            for(int node : i.second)\\n            {\\n                maxi = max(maxi , maxDepth(node,n,adj));\\n            }\\n            \\n            res+=maxi;\\n        }\\n        \\n        return res;\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    \\n    bool bipartite(vector<int>adj[] ,vector<int>&color)\\n    {\\n        queue<int>q;\\n        q.push(1);\\n        color[1]=1;\\n        \\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            \\n            for(auto it:adj[node])\\n            {\\n                if(color[it]==-1)\\n                {\\n                    color[it]=1-color[node];\\n                    q.push(it);\\n                }\\n                else if(color[it] == color[node])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int maxDepth(int x ,int n, vector<int>adj[])\\n    {\\n        \\n        vector<int>vis(n+1);\\n        \\n        queue<int>q;\\n        q.push(x);\\n        vis[x]=1;\\n        \\n        int depth = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            while(size--)\\n            {\\n                int node = q.front();\\n                q.pop();\\n\\n                for(auto it:adj[node])\\n                {\\n                    if(!vis[it])\\n                    {\\n                        vis[it]=1;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            depth++;\\n        }\\n        \\n        return depth;\\n    }\\n    \\n    \\n    // UNION FIND CODE\\n    \\n    \\n    int rank[100001];\\n    int parent[100001];\\n    \\n    int findUPar(int node)\\n    {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n    \\n    void mergeRank(int u , int v)\\n    {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int>adj[n+1];\\n        vector<int>color(n+1,-1);\\n        \\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        // CONDITION - 1\\n        \\n        if(!bipartite(adj,color))\\n            return -1;\\n        \\n        // Union Find \\n        \\n        for(int i=1 ; i<=n ; i++)\\n        {\\n            rank[i]=0;\\n            parent[i]=i;\\n        }\\n        \\n        for(auto x:edges)\\n        {\\n            mergeRank(x[0],x[1]);\\n        }\\n        \\n        // now group all together \\n        map<int,vector<int>>mp;\\n        \\n        for(int node=1 ; node<=n ; node++)\\n        {\\n            int par = findUPar(node);\\n            mp[par].push_back(node);\\n        }\\n        \\n        // now grouping done \\n        // find the max depth of each group and add all together \\n        \\n        int res = 0;\\n        \\n        for(auto i:mp)\\n        {\\n            int maxi = INT_MIN;\\n            for(int node : i.second)\\n            {\\n                maxi = max(maxi , maxDepth(node,n,adj));\\n            }\\n            \\n            res+=maxi;\\n        }\\n        \\n        return res;\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876565,
                "title": "javascript-union-find-bfs",
                "content": "**Solution: Union Find & BFS**\\n\\n1. Build the graph and connect nodes using union find.\\n2. Find the groups of connected nodes.\\n3. Find the maximum groups to divide for each connected group.\\n*   Use level-by-level BFS to find the maximum depth of the group.\\n*   How to detect an odd-lengthed cycle: Cycles are bound to meet in the middle since we are traversing level-by-level, so if the level of a neighbor node is equal to the current level, the cycle is odd-lengthed.\\n\\n`n = number of nodes`, `m = number of edges`\\nTime Complexity: `O(n * (n + m))` 639ms\\nSpace Complexity: `O(n + m)` 64.6MB\\n```\\nvar magnificentSets = function(n, edges) {\\n  let uf = new UnionFind(n + 1);\\n  let graph = Array(n + 1).fill(0).map(() => []);\\n  for (let [a, b] of edges) { // 1. Build graph, connect nodes\\n    graph[a].push(b);\\n    graph[b].push(a);\\n    uf.union(a, b);\\n  }\\n  \\n  let groups = {};\\n  for (let i = 1; i <= n; i++) { // 2. Find groups of connected nodes\\n    let parent = uf.find(i);\\n    if (!groups[parent]) groups[parent] = [];\\n    groups[parent].push(i);\\n  }\\n  \\n  let totalGroups = 0;\\n  for (let parent in groups) { // 3. Find the maximum groups to divide for each connected group\\n    let group = groups[parent];\\n    let maxGroups = 0;\\n    for (let node of group) {\\n      let numGroups = bfs(graph, node);\\n      if (numGroups === -1) return -1;\\n      maxGroups = Math.max(maxGroups, numGroups);\\n    }\\n    totalGroups += maxGroups;\\n  }\\n  return totalGroups;\\n};\\n\\nfunction bfs(graph, startNode) {\\n  let queue = [startNode], n = graph.length;\\n  let levels = Array(n).fill(-1), level = 0;\\n  levels[startNode] = 0;\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let node = queue.shift();\\n      for (let nei of graph[node]) {\\n        if (levels[nei] === -1) {\\n          levels[nei] = level + 1;\\n          queue.push(nei);\\n        } else if (levels[nei] === level) { // found an odd-lengthed cycle, we can\\'t divide into groups\\n          return -1;\\n        }\\n      }\\n    }\\n    level++;\\n  }\\n  return level;\\n}\\n\\nclass UnionFind {\\n  constructor(size) {\\n    this.root = Array(size);\\n    this.rank = Array(size)\\n    for (var i = 0; i < size; i++) {\\n      this.root[i] = i;\\n      this.rank[i] = 1;\\n    }\\n  }\\n  find(x) {\\n    if (this.root[x] === x) {\\n      return x;\\n    }\\n    return this.root[x] = this.find(this.root[x]);\\n  }\\n  union(x, y) {\\n    let rootX = this.find(x);\\n    let rootY = this.find(y);\\n    if (rootX !== rootY) {\\n      if (this.rank[rootX] > this.rank[rootY]) {\\n        this.root[rootY] = rootX;\\n      } else if (this.rank[rootX] < this.rank[rootY]) {\\n        this.root[rootX] = rootY;\\n      } else {\\n        this.root[rootY] = rootX;\\n        this.rank[rootX]++;\\n      }\\n    }\\n  }\\n  connected(x, y) {\\n    return this.find(x) === this.find(y);\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar magnificentSets = function(n, edges) {\\n  let uf = new UnionFind(n + 1);\\n  let graph = Array(n + 1).fill(0).map(() => []);\\n  for (let [a, b] of edges) { // 1. Build graph, connect nodes\\n    graph[a].push(b);\\n    graph[b].push(a);\\n    uf.union(a, b);\\n  }\\n  \\n  let groups = {};\\n  for (let i = 1; i <= n; i++) { // 2. Find groups of connected nodes\\n    let parent = uf.find(i);\\n    if (!groups[parent]) groups[parent] = [];\\n    groups[parent].push(i);\\n  }\\n  \\n  let totalGroups = 0;\\n  for (let parent in groups) { // 3. Find the maximum groups to divide for each connected group\\n    let group = groups[parent];\\n    let maxGroups = 0;\\n    for (let node of group) {\\n      let numGroups = bfs(graph, node);\\n      if (numGroups === -1) return -1;\\n      maxGroups = Math.max(maxGroups, numGroups);\\n    }\\n    totalGroups += maxGroups;\\n  }\\n  return totalGroups;\\n};\\n\\nfunction bfs(graph, startNode) {\\n  let queue = [startNode], n = graph.length;\\n  let levels = Array(n).fill(-1), level = 0;\\n  levels[startNode] = 0;\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let node = queue.shift();\\n      for (let nei of graph[node]) {\\n        if (levels[nei] === -1) {\\n          levels[nei] = level + 1;\\n          queue.push(nei);\\n        } else if (levels[nei] === level) { // found an odd-lengthed cycle, we can\\'t divide into groups\\n          return -1;\\n        }\\n      }\\n    }\\n    level++;\\n  }\\n  return level;\\n}\\n\\nclass UnionFind {\\n  constructor(size) {\\n    this.root = Array(size);\\n    this.rank = Array(size)\\n    for (var i = 0; i < size; i++) {\\n      this.root[i] = i;\\n      this.rank[i] = 1;\\n    }\\n  }\\n  find(x) {\\n    if (this.root[x] === x) {\\n      return x;\\n    }\\n    return this.root[x] = this.find(this.root[x]);\\n  }\\n  union(x, y) {\\n    let rootX = this.find(x);\\n    let rootY = this.find(y);\\n    if (rootX !== rootY) {\\n      if (this.rank[rootX] > this.rank[rootY]) {\\n        this.root[rootY] = rootX;\\n      } else if (this.rank[rootX] < this.rank[rootY]) {\\n        this.root[rootX] = rootY;\\n      } else {\\n        this.root[rootY] = rootX;\\n        this.rank[rootX]++;\\n      }\\n    }\\n  }\\n  connected(x, y) {\\n    return this.find(x) === this.find(y);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876131,
                "title": "java-bipartite-bfs-straighforward-logic-explanation",
                "content": "Key points of this problem: \\n1. [Bipartite](https://en.wikipedia.org/wiki/Bipartite_graph) - a connected graph can form two groups\\n\\t1. nodes beteween groups has connection(edges)\\n\\t2. nodes in the same group has no connection(edges)\\n\\t3. Check whether **a graph can be Bipartite** or not -> if graph has **a cycle and the cycle has odd edges**\\n2. a graph can be how many groups? - **maximum of minimun distances(each node to each node) in a group**\\n\\t1. if graph has no cycle, Ex: a -> b -> c, can be maximun groups [a], [b], [c]\\n\\t\\t1. a to c minimum distance is 3 \\n\\t\\t2. b to c minimum distance is 2\\n\\t\\t3. a to c distance is maximum among all other two nodes distance  \\n\\t2. if graph has cycles, Ex: a -> b -> c - > d -> a, can be maximun groups [a], [b, d], [c]\\n\\t\\t1.  a to c minimum distance is 3\\n\\t\\t2.  other node to node minimum distance is 1 or 2\\n\\t\\t3.  a to c distance is maximum among all other two nodes distance  \\n\\nKey points in programming\\n1. prepare each node to each node`int[][] adjacent map` from input `int[][] edges`\\n2. First BFS, from node `i =1 to n`, check each node to each node distance(`node[i]` to all others that it can reach)\\n\\t1. like `node[i]` to `[1 .. i-1], i, [i+1..n]` distances\\n\\t2. record `node[i]` to other nodes max distance in `maxDistance[i]`\\n3. Second BFS, because we may have several separated graph from input `int[][] edges`\\n\\t1. Ex: we may have graph: `1 -> 2 -> 3` and `4 -> 5 -> 6`\\n\\t2. So we need to find out max distance among `1->2->3` (max dist = 3) and `4->5->6`(max dist = 3) and their sum is total groups we can get = 6\\n\\t\\t1. code `diameter = Math.max(diameter, maxDistance[node]);` \\n\\t3. So from each node `i =1 to n`, Ex: `node[i]`, we update all `distance[j]` which `node[i]` can reach and save max distance among them\\n\\t4. When we check a `dist[j]` that `node[i]` can reach but the value is not `-1`, means the `node[j]` we have visited in early process of BFS\\n\\t\\t1. **cycle appear!! check cycle length is odd or not -> Bipartite!!**\\n\\t\\t2. if it is Bipartite -> return -1 directly\\n\\t\\t3. code `if (distance[nextNode] < 0) {` and `else if ((nextDist + distance[nextNode]) % 2 != 0) return -1;`\\n\\t5. if no Bipartite appear, retrun sum of maximum distance among all sub graphs\\n\\n\\n```\\npublic int magnificentSets(int n, int[][] edges) {\\n        int[] degree = new int[n + 1];\\n        for (int[] e : edges) {\\n            degree[e[0]]++;\\n            degree[e[1]]++;\\n        }\\n        int[][] adjacent = new int[n + 1][];\\n        for (int i = 1; i <= n; i++) adjacent[i] = new int[degree[i]];\\n        for (int[] e : edges) {\\n            int a = e[0];\\n            int b = e[1];\\n            adjacent[a][--degree[a]] = b;\\n            adjacent[b][--degree[b]] = a;\\n        }\\n\\n        Queue<Integer> bfs = new LinkedList<>();\\n        int[] distance = new int[n + 1];\\n        int[] maxDistance = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            Arrays.fill(distance, -1);\\n            bfs.offer(i);\\n            distance[i] = 0;\\n            int maxDist = 0;\\n            while (bfs.size() > 0) {\\n                int node = bfs.poll();\\n                int nextDist = distance[node] + 1;\\n                for (int nextNode : adjacent[node])\\n                    if (distance[nextNode] < 0) {\\n                        distance[nextNode] = nextDist;\\n                        maxDist = nextDist;\\n                        bfs.offer(nextNode);\\n                    }\\n            }\\n            maxDistance[i] = maxDist;\\n        }\\n\\n        Arrays.fill(distance, -1);\\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (distance[i] >= 0) continue;\\n            bfs.offer(i);\\n            distance[i] = 0;\\n            int diameter = 0;\\n            while (bfs.size() > 0) {\\n                int node = bfs.poll();\\n                diameter = Math.max(diameter, maxDistance[node]);\\n                int nextDist = distance[node] + 1;\\n                for (int nextNode : adjacent[node]) {\\n                    if (distance[nextNode] < 0) {\\n                        distance[nextNode] = nextDist;\\n                        bfs.offer(nextNode);\\n                    } else if ((nextDist + distance[nextNode]) % 2 != 0) return -1;\\n                }\\n            }\\n            res += diameter + 1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic int magnificentSets(int n, int[][] edges) {\\n        int[] degree = new int[n + 1];\\n        for (int[] e : edges) {\\n            degree[e[0]]++;\\n            degree[e[1]]++;\\n        }\\n        int[][] adjacent = new int[n + 1][];\\n        for (int i = 1; i <= n; i++) adjacent[i] = new int[degree[i]];\\n        for (int[] e : edges) {\\n            int a = e[0];\\n            int b = e[1];\\n            adjacent[a][--degree[a]] = b;\\n            adjacent[b][--degree[b]] = a;\\n        }\\n\\n        Queue<Integer> bfs = new LinkedList<>();\\n        int[] distance = new int[n + 1];\\n        int[] maxDistance = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            Arrays.fill(distance, -1);\\n            bfs.offer(i);\\n            distance[i] = 0;\\n            int maxDist = 0;\\n            while (bfs.size() > 0) {\\n                int node = bfs.poll();\\n                int nextDist = distance[node] + 1;\\n                for (int nextNode : adjacent[node])\\n                    if (distance[nextNode] < 0) {\\n                        distance[nextNode] = nextDist;\\n                        maxDist = nextDist;\\n                        bfs.offer(nextNode);\\n                    }\\n            }\\n            maxDistance[i] = maxDist;\\n        }\\n\\n        Arrays.fill(distance, -1);\\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (distance[i] >= 0) continue;\\n            bfs.offer(i);\\n            distance[i] = 0;\\n            int diameter = 0;\\n            while (bfs.size() > 0) {\\n                int node = bfs.poll();\\n                diameter = Math.max(diameter, maxDistance[node]);\\n                int nextDist = distance[node] + 1;\\n                for (int nextNode : adjacent[node]) {\\n                    if (distance[nextNode] < 0) {\\n                        distance[nextNode] = nextDist;\\n                        bfs.offer(nextNode);\\n                    } else if ((nextDist + distance[nextNode]) % 2 != 0) return -1;\\n                }\\n            }\\n            res += diameter + 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2875436,
                "title": "python3-bfs",
                "content": "Instead of union finding, I directly find the maximum path in the group.\\nMore easily for me to understand.\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n+1)]\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        @cache\\n        def find_max_depth(node):\\n            seen = {}\\n            state = [node]\\n            ct = 0\\n            seen[node] = 0\\n            while(state):\\n                ct +=1\\n                next_state = []\\n                for p in state:\\n                    for j in adj[p]:\\n                        if(j not in seen):\\n                            seen[j]= ct%2\\n                            next_state.append(j)\\n                        elif(seen[j]==seen[p]):\\n                            return -1,set()\\n                state = next_state\\n            return ct,set(seen.keys())\\n        ans = 0\\n        used = set()\\n        for i in range(1,n+1):\\n            if(i not in used):\\n                used.add(i)\\n                res,seen =find_max_depth(i)\\n                if(res==-1):\\n                    return -1\\n                for node in seen:\\n                    tmp,_ = find_max_depth(node)\\n                    res = max(res,tmp)\\n                    used.add(node)\\n                ans += res\\n        return ans\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n+1)]\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        @cache\\n        def find_max_depth(node):\\n            seen = {}\\n            state = [node]\\n            ct = 0\\n            seen[node] = 0\\n            while(state):\\n                ct +=1\\n                next_state = []\\n                for p in state:\\n                    for j in adj[p]:\\n                        if(j not in seen):\\n                            seen[j]= ct%2\\n                            next_state.append(j)\\n                        elif(seen[j]==seen[p]):\\n                            return -1,set()\\n                state = next_state\\n            return ct,set(seen.keys())\\n        ans = 0\\n        used = set()\\n        for i in range(1,n+1):\\n            if(i not in used):\\n                used.add(i)\\n                res,seen =find_max_depth(i)\\n                if(res==-1):\\n                    return -1\\n                for node in seen:\\n                    tmp,_ = find_max_depth(node)\\n                    res = max(res,tmp)\\n                    used.add(node)\\n                ans += res\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411312,
                "title": "easy-c-solution-using-bfs-and-bipartite",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>color,visit;\\n    vector<vector<int>>adj,dis;\\n    vector<int>comp;\\n\\n    bool bfs(int i)\\n    {\\n      queue<int>q;\\n        q.push(i);\\n        visit[i]=0;\\n        while(!q.empty())\\n        {\\n            int f=q.front();\\n            comp.push_back(f);\\n            q.pop();\\n            for(auto it :adj[f])\\n            {\\n                if(visit[it]!=-1)\\n                {\\n                    if(visit[it]!=(!visit[f]))return 0;\\n                }\\n                else{\\n                    visit[it]=(!visit[f]);\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return 1;\\n            \\n    }\\n    \\n    void  bfs1(int i)\\n    {\\n      dis[i][i]=1;\\n      queue<int>q;\\n      q.push(i);\\n      while(!q.empty())\\n      {\\n          int f=q.front();\\n          q.pop();\\n         for(auto it :adj[f])\\n         {\\n             if(dis[i][it]>dis[i][f]+1)\\n             {\\n                 dis[i][it]=dis[i][f]+1;\\n                 q.push(it);\\n             }\\n         }\\n      }\\n            \\n    }\\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        adj=vector<vector<int>>(n+1);\\n        dis=vector<vector<int>>(n+1,vector<int>(n+1,1e9));\\n        \\n        for(auto it :edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n       \\n        \\n       \\n        \\n        visit=vector<int>(n+1,-1);\\n        bool check=1;\\n         for(int i=1;i<=n;i++)\\n        {\\n            bfs1(i);\\n        }\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(visit[i]!=-1)continue;\\n           \\n            check&=bfs(i);\\n            int x=0;\\n           for(int j=0;j<comp.size();j++)\\n           {\\n               for(int k=j;k<comp.size();k++)\\n               {\\n                     if(dis[comp[j]][comp[k]]<1e9)\\n                     {\\n                         x=max(x,dis[comp[j]][comp[k]]);\\n                     }\\n               }\\n           }\\n            comp.clear();\\n           ans+=x;\\n\\n        }\\n        if(check==0)return -1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto it : adj[i])\\n            {\\n                if(visit[it]!=(!visit[i]))return -1;\\n            }\\n         }\\n        \\n       \\n        \\n       \\n        \\n       \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>color,visit;\\n    vector<vector<int>>adj,dis;\\n    vector<int>comp;\\n\\n    bool bfs(int i)\\n    {\\n      queue<int>q;\\n        q.push(i);\\n        visit[i]=0;\\n        while(!q.empty())\\n        {\\n            int f=q.front();\\n            comp.push_back(f);\\n            q.pop();\\n            for(auto it :adj[f])\\n            {\\n                if(visit[it]!=-1)\\n                {\\n                    if(visit[it]!=(!visit[f]))return 0;\\n                }\\n                else{\\n                    visit[it]=(!visit[f]);\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return 1;\\n            \\n    }\\n    \\n    void  bfs1(int i)\\n    {\\n      dis[i][i]=1;\\n      queue<int>q;\\n      q.push(i);\\n      while(!q.empty())\\n      {\\n          int f=q.front();\\n          q.pop();\\n         for(auto it :adj[f])\\n         {\\n             if(dis[i][it]>dis[i][f]+1)\\n             {\\n                 dis[i][it]=dis[i][f]+1;\\n                 q.push(it);\\n             }\\n         }\\n      }\\n            \\n    }\\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        adj=vector<vector<int>>(n+1);\\n        dis=vector<vector<int>>(n+1,vector<int>(n+1,1e9));\\n        \\n        for(auto it :edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n       \\n        \\n       \\n        \\n        visit=vector<int>(n+1,-1);\\n        bool check=1;\\n         for(int i=1;i<=n;i++)\\n        {\\n            bfs1(i);\\n        }\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(visit[i]!=-1)continue;\\n           \\n            check&=bfs(i);\\n            int x=0;\\n           for(int j=0;j<comp.size();j++)\\n           {\\n               for(int k=j;k<comp.size();k++)\\n               {\\n                     if(dis[comp[j]][comp[k]]<1e9)\\n                     {\\n                         x=max(x,dis[comp[j]][comp[k]]);\\n                     }\\n               }\\n           }\\n            comp.clear();\\n           ans+=x;\\n\\n        }\\n        if(check==0)return -1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(auto it : adj[i])\\n            {\\n                if(visit[it]!=(!visit[i]))return -1;\\n            }\\n         }\\n        \\n       \\n        \\n       \\n        \\n       \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922099,
                "title": "all-basic-operation-are-used-beginner-friendly-fully-commented-bipartaite-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2) (\"color\" vector created \"N\" times of size \"N\")\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        // creating graph\\n        vector<vector<int>> adj(n+1);\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        // \"ans\" will be used to store size of every component if disconnected\\n        vector<int> ans(n+1 , 0);\\n\\n        /*\\n         for each node traversing graph for finding\\n         - largest no. of groups in which graph can be divided\\n         - if disconnected then to store every component largest no. of group\\n        */\\n\\n        for(int i=1; i<n+1; i++){ \\n\\n        // \"color\" is used to find bipartite or not\\n        // if bipartaite => even cycle may exist but no odd cycle present\\n        // not bipartaite => must be odd cycle present\\n            vector<int> color(n+1 , -1);\\n            color[i] = 1;\\n\\n            queue<int> q;\\n            q.push(i);\\n            \\n            /*\\n            \"idx\" is used to separate each connected component\\n            so that to store max size of each component by traversing \\n            through different nodes\\n            */\\n            int idx = i;\\n            int level = 0;\\n\\n            // normal \"bfs\" for finding height of graph\\n            while(!q.empty()){\\n                level++;\\n                int s = q.size();\\n\\n                for(int j=0; j<s; j++){\\n                    int node = q.front();\\n                    q.pop();\\n\\n                    for(auto it:adj[node]){\\n                        // \"color\" is also used to find visited or not\\n                        // if color[it] == -1 => not visited \\n                        // if color[it] == 0 or 1 => already visited\\n                        if(color[it] == -1){\\n                            color[it] = 1-color[node];\\n                            idx = min(idx , it);\\n                            q.push(it);\\n                        }else if(color[it] == color[node]){\\n                            return -1;\\n                        }\\n                    }\\n                }\\n            }\\n            // taking max size\\n            ans[idx] = max(ans[idx] , level);\\n        }\\n\\n        // returning sum all the component of graph\\n        return accumulate(ans.begin() , ans.end() , 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        // creating graph\\n        vector<vector<int>> adj(n+1);\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        // \"ans\" will be used to store size of every component if disconnected\\n        vector<int> ans(n+1 , 0);\\n\\n        /*\\n         for each node traversing graph for finding\\n         - largest no. of groups in which graph can be divided\\n         - if disconnected then to store every component largest no. of group\\n        */\\n\\n        for(int i=1; i<n+1; i++){ \\n\\n        // \"color\" is used to find bipartite or not\\n        // if bipartaite => even cycle may exist but no odd cycle present\\n        // not bipartaite => must be odd cycle present\\n            vector<int> color(n+1 , -1);\\n            color[i] = 1;\\n\\n            queue<int> q;\\n            q.push(i);\\n            \\n            /*\\n            \"idx\" is used to separate each connected component\\n            so that to store max size of each component by traversing \\n            through different nodes\\n            */\\n            int idx = i;\\n            int level = 0;\\n\\n            // normal \"bfs\" for finding height of graph\\n            while(!q.empty()){\\n                level++;\\n                int s = q.size();\\n\\n                for(int j=0; j<s; j++){\\n                    int node = q.front();\\n                    q.pop();\\n\\n                    for(auto it:adj[node]){\\n                        // \"color\" is also used to find visited or not\\n                        // if color[it] == -1 => not visited \\n                        // if color[it] == 0 or 1 => already visited\\n                        if(color[it] == -1){\\n                            color[it] = 1-color[node];\\n                            idx = min(idx , it);\\n                            q.push(it);\\n                        }else if(color[it] == color[node]){\\n                            return -1;\\n                        }\\n                    }\\n                }\\n            }\\n            // taking max size\\n            ans[idx] = max(ans[idx] , level);\\n        }\\n\\n        // returning sum all the component of graph\\n        return accumulate(ans.begin() , ans.end() , 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917928,
                "title": "an-easy-approach-using-the-concepts-of-bfs-and-bipartite-graphs",
                "content": "# Intuition\\n1 thing that\\'s clear from the problem is that, if grouping of nodes is to be done, as mentioned in the question, then each of the connected components of the graph needs to be Bipartite, i.e., no odd-length cycle can be there in the graph.\\nSecondly, the BFS Tree corresponding to each component can be observed - the number of levels in that BFS tree gives us the maximum number of groups for that particular connected component. The same thing can be done for all the connected components.\\n\\n# Approach\\nFirst of all, from edges, we construct the graph. Then we decompose the graph into individual connected components using vanilla BFS. Now, for each connected component, its first of all verified whether that connected component is BiPartite or not (using graph 2-coloring technique), if its Bipartite, then for each vertex in that connected component, the number of levels in the BFS tree is computed and the maximum value is added to the result.\\n\\n# Complexity\\n- Time complexity: O(N * (N + M)), where N and M are the number of nodes and edges respectively.\\n\\n- Space complexity: O(N + M), for the hashmap that stores the graph info.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int bfs(int src, Map<Integer, List<Integer> > graph, int[] colors) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(src);\\n        queue.offer(-1);\\n        colors[src] = 1;\\n        int levels = 0;\\n        while (!queue.isEmpty()) {\\n            src = queue.poll();\\n            if (src == -1) {\\n                if (!queue.isEmpty())\\n                    queue.offer(-1);\\n                levels++;\\n                continue;\\n            }\\n            List<Integer> neighbors = graph.get(src);\\n            for (int neighbor : neighbors) {\\n                if (colors[neighbor] == 0) {\\n                    colors[neighbor] = -colors[src];\\n                    queue.offer(neighbor);\\n                }\\n                else if (colors[neighbor] != -colors[src])\\n                    return -1;\\n            }\\n        }\\n        return levels;\\n    }\\n\\n    List<Integer> findConnected(int src, Map<Integer, List<Integer> > graph, int[] colors) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        List<Integer> list = new ArrayList<>();\\n        queue.offer(src);\\n        while (!queue.isEmpty()) {\\n            src = queue.poll();\\n            if (colors[src] != 0)\\n                continue;\\n            colors[src] = 1;\\n            list.add(src);\\n            List<Integer> neighbors = graph.get(src);\\n            for (int node : neighbors) {\\n                if (colors[node] == 0)\\n                    queue.offer(node);\\n            }\\n        }\\n        return list;\\n    }\\n\\n    public int magnificentSets(int n, int[][] edges) {\\n        Map<Integer, List<Integer> > graph = new HashMap<>();\\n        for (int i = 1; i <= n; i++)\\n            graph.put(i, new ArrayList<>());\\n        for (int[] edge : edges) { // graph construction\\n            int u = edge[0], v = edge[1];\\n            List<Integer> adju = graph.get(u);\\n            adju.add(v);\\n            graph.put(u, adju);\\n            List<Integer> adjv = graph.get(v);\\n            adjv.add(u);\\n            graph.put(v, adjv);\\n        }\\n        List<List<Integer> > connectedComponents = new ArrayList<>();\\n        int[] colors = new int[n + 1];\\n        for (int i = 1; i <= n; i++) { // decomposition into connected components\\n            if (colors[i] != 0)\\n                continue;\\n            List<Integer> neighbors = findConnected(i, graph, colors);\\n            connectedComponents.add(neighbors);\\n        }\\n        int result = 0, numComponents = connectedComponents.size();\\n        for (int i = 0; i < numComponents; i++) { // BFS from each edge of each connected component\\n            List<Integer> list = connectedComponents.get(i);\\n            int levels = Integer.MIN_VALUE;\\n            for (int j = 0; j < list.size(); j++) {\\n                Arrays.fill(colors, 0);\\n                int val = bfs(list.get(j), graph, colors);\\n                if (val == -1)\\n                    return -1;\\n                levels = Math.max(levels, val);\\n            }\\n            result += levels;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int bfs(int src, Map<Integer, List<Integer> > graph, int[] colors) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(src);\\n        queue.offer(-1);\\n        colors[src] = 1;\\n        int levels = 0;\\n        while (!queue.isEmpty()) {\\n            src = queue.poll();\\n            if (src == -1) {\\n                if (!queue.isEmpty())\\n                    queue.offer(-1);\\n                levels++;\\n                continue;\\n            }\\n            List<Integer> neighbors = graph.get(src);\\n            for (int neighbor : neighbors) {\\n                if (colors[neighbor] == 0) {\\n                    colors[neighbor] = -colors[src];\\n                    queue.offer(neighbor);\\n                }\\n                else if (colors[neighbor] != -colors[src])\\n                    return -1;\\n            }\\n        }\\n        return levels;\\n    }\\n\\n    List<Integer> findConnected(int src, Map<Integer, List<Integer> > graph, int[] colors) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        List<Integer> list = new ArrayList<>();\\n        queue.offer(src);\\n        while (!queue.isEmpty()) {\\n            src = queue.poll();\\n            if (colors[src] != 0)\\n                continue;\\n            colors[src] = 1;\\n            list.add(src);\\n            List<Integer> neighbors = graph.get(src);\\n            for (int node : neighbors) {\\n                if (colors[node] == 0)\\n                    queue.offer(node);\\n            }\\n        }\\n        return list;\\n    }\\n\\n    public int magnificentSets(int n, int[][] edges) {\\n        Map<Integer, List<Integer> > graph = new HashMap<>();\\n        for (int i = 1; i <= n; i++)\\n            graph.put(i, new ArrayList<>());\\n        for (int[] edge : edges) { // graph construction\\n            int u = edge[0], v = edge[1];\\n            List<Integer> adju = graph.get(u);\\n            adju.add(v);\\n            graph.put(u, adju);\\n            List<Integer> adjv = graph.get(v);\\n            adjv.add(u);\\n            graph.put(v, adjv);\\n        }\\n        List<List<Integer> > connectedComponents = new ArrayList<>();\\n        int[] colors = new int[n + 1];\\n        for (int i = 1; i <= n; i++) { // decomposition into connected components\\n            if (colors[i] != 0)\\n                continue;\\n            List<Integer> neighbors = findConnected(i, graph, colors);\\n            connectedComponents.add(neighbors);\\n        }\\n        int result = 0, numComponents = connectedComponents.size();\\n        for (int i = 0; i < numComponents; i++) { // BFS from each edge of each connected component\\n            List<Integer> list = connectedComponents.get(i);\\n            int levels = Integer.MIN_VALUE;\\n            for (int j = 0; j < list.size(); j++) {\\n                Arrays.fill(colors, 0);\\n                int val = bfs(list.get(j), graph, colors);\\n                if (val == -1)\\n                    return -1;\\n                levels = Math.max(levels, val);\\n            }\\n            result += levels;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880333,
                "title": "unionfind-bfs-bipartite-check",
                "content": "```\\nclass Solution {\\npublic:\\n    struct unionfind{\\n    int n;\\n    vector<int>parent;\\n    unionfind(int n){\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n    int find(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        else{\\n            return parent[node] = find(parent[node]);\\n        }\\n    }\\n    void Union(int u,int v){\\n        u = find(u);\\n        v = find(v);\\n        parent[u] = v;\\n    }\\n    };\\n    bool bipartite(vector<int>adj[],vector<int>&visited,int src){\\n        visited[src]=1;\\n        queue<int>q;\\n        q.push(src);\\n        while(q.size()){\\n            int x = q.size();\\n            while(x--){\\n                int t = q.front();\\n                q.pop();\\n                int tocolor;\\n                if(visited[t]==1){\\n                    tocolor=2;\\n                }\\n                else{\\n                    tocolor=1;\\n                }\\n                for(auto &it:adj[t]){\\n                    if(visited[it]==0){\\n                        q.push(it);\\n                        visited[it]=tocolor;\\n                    }\\n                    else if(visited[it]==tocolor){\\n                        continue;\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int bfs(vector<int>adj[],int src,int n){\\n        queue<int>q;\\n        q.push(src);\\n        vector<int>visited(n+1);\\n        visited[src]=1;\\n        int ans=0;\\n        while(q.size()){\\n            int x = q.size();\\n            ans++;\\n            while(x--){\\n                int t = q.front();\\n                q.pop();\\n                for(auto &it:adj[t]){\\n                    if(visited[it]==0){\\n                        q.push(it);\\n                        visited[it]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        unionfind u = unionfind(n+1);\\n        for(auto &i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n            u.Union(i[0],i[1]);\\n        }\\n        vector<int>visited(n+1);\\n        for(int i=1;i<=n;i++){\\n            if(visited[i]==0){\\n                if(!bipartite(adj,visited,i)){\\n                    return -1;\\n                }\\n            }\\n        }\\n        map<int,int>ans;\\n        vector<int>dis(n+1);\\n        for(int i=1;i<=n;i++){\\n            dis[i]=bfs(adj,i,n);\\n        }\\n        for(int i=1;i<=n;i++){\\n            int x = u.find(i);\\n            ans[x]=max(ans[x],dis[i]);\\n        }\\n        int sol=0;\\n        for(auto &i:ans){\\n            sol+=i.second;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct unionfind{\\n    int n;\\n    vector<int>parent;\\n    unionfind(int n){\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n    int find(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        else{\\n            return parent[node] = find(parent[node]);\\n        }\\n    }\\n    void Union(int u,int v){\\n        u = find(u);\\n        v = find(v);\\n        parent[u] = v;\\n    }\\n    };\\n    bool bipartite(vector<int>adj[],vector<int>&visited,int src){\\n        visited[src]=1;\\n        queue<int>q;\\n        q.push(src);\\n        while(q.size()){\\n            int x = q.size();\\n            while(x--){\\n                int t = q.front();\\n                q.pop();\\n                int tocolor;\\n                if(visited[t]==1){\\n                    tocolor=2;\\n                }\\n                else{\\n                    tocolor=1;\\n                }\\n                for(auto &it:adj[t]){\\n                    if(visited[it]==0){\\n                        q.push(it);\\n                        visited[it]=tocolor;\\n                    }\\n                    else if(visited[it]==tocolor){\\n                        continue;\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int bfs(vector<int>adj[],int src,int n){\\n        queue<int>q;\\n        q.push(src);\\n        vector<int>visited(n+1);\\n        visited[src]=1;\\n        int ans=0;\\n        while(q.size()){\\n            int x = q.size();\\n            ans++;\\n            while(x--){\\n                int t = q.front();\\n                q.pop();\\n                for(auto &it:adj[t]){\\n                    if(visited[it]==0){\\n                        q.push(it);\\n                        visited[it]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        unionfind u = unionfind(n+1);\\n        for(auto &i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n            u.Union(i[0],i[1]);\\n        }\\n        vector<int>visited(n+1);\\n        for(int i=1;i<=n;i++){\\n            if(visited[i]==0){\\n                if(!bipartite(adj,visited,i)){\\n                    return -1;\\n                }\\n            }\\n        }\\n        map<int,int>ans;\\n        vector<int>dis(n+1);\\n        for(int i=1;i<=n;i++){\\n            dis[i]=bfs(adj,i,n);\\n        }\\n        for(int i=1;i<=n;i++){\\n            int x = u.find(i);\\n            ans[x]=max(ans[x],dis[i]);\\n        }\\n        int sol=0;\\n        for(auto &i:ans){\\n            sol+=i.second;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878172,
                "title": "c-dfs-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int normalBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool> visited) {\\n        queue<int> q;\\n        q.push(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    q.push(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    int checkConnectedBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool>& visited) {\\n        vector<int> members;\\n        vector<bool> visitedCopy = visited;\\n        queue<int> q;\\n        q.push(start);\\n        members.push_back(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            vector<int> collections;\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    collections.push_back(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            // check if all nodes at the same level have any connection;\\n            int m = collections.size();\\n\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < i; ++j) {\\n                    if (hashEdges[collections[i]].count(collections[j])) return -1;\\n                }\\n            }\\n            for (int i = 0; i < m; ++i) {\\n                q.push(collections[i]);\\n                members.push_back(collections[i]);\\n            }\\n            level++;\\n        }\\n        for (auto& member : members) {\\n            level = max(level, normalBfs(member, hashEdges, visitedCopy));\\n        }\\n        return level;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, unordered_set<int>> hashEdges;\\n\\n        for (auto& edge : edges) {\\n            hashEdges[edge[0] - 1].insert(edge[1] - 1);\\n            hashEdges[edge[1] - 1].insert(edge[0] - 1);\\n        }\\n        vector<bool> visited(n, false);\\n        int maxRes = 0;\\n        \\n        for (int node = 0; node < n; ++node) {\\n            if (visited[node]) continue;\\n            int result = checkConnectedBfs(node, hashEdges, visited);\\n            if (result == -1) return -1;\\n            \\n            maxRes += result;\\n        }\\n        return maxRes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int normalBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool> visited) {\\n        queue<int> q;\\n        q.push(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    q.push(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    int checkConnectedBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool>& visited) {\\n        vector<int> members;\\n        vector<bool> visitedCopy = visited;\\n        queue<int> q;\\n        q.push(start);\\n        members.push_back(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            vector<int> collections;\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    collections.push_back(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            // check if all nodes at the same level have any connection;\\n            int m = collections.size();\\n\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < i; ++j) {\\n                    if (hashEdges[collections[i]].count(collections[j])) return -1;\\n                }\\n            }\\n            for (int i = 0; i < m; ++i) {\\n                q.push(collections[i]);\\n                members.push_back(collections[i]);\\n            }\\n            level++;\\n        }\\n        for (auto& member : members) {\\n            level = max(level, normalBfs(member, hashEdges, visitedCopy));\\n        }\\n        return level;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, unordered_set<int>> hashEdges;\\n\\n        for (auto& edge : edges) {\\n            hashEdges[edge[0] - 1].insert(edge[1] - 1);\\n            hashEdges[edge[1] - 1].insert(edge[0] - 1);\\n        }\\n        vector<bool> visited(n, false);\\n        int maxRes = 0;\\n        \\n        for (int node = 0; node < n; ++node) {\\n            if (visited[node]) continue;\\n            int result = checkConnectedBfs(node, hashEdges, visited);\\n            if (result == -1) return -1;\\n            \\n            maxRes += result;\\n        }\\n        return maxRes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876657,
                "title": "bfs-bipartite-check-c-solution",
                "content": "**Approach**\\nFirst intution is that graph should be bipartite and second we have to find the minimum distance between all the possible nodes in every component and the out of that we have to choose maximum distance and need to take sum of all distances.\\n\\n```\\nclass Solution {\\npublic:\\n    void bfs(int src,vector<int>adj[],vector<vector<int>>&dist){\\n        queue<int>q;\\n        q.push(src);\\n        dist[src][src] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto &nbr:adj[node]){\\n               if(dist[src][nbr] > dist[src][node]+1){\\n                   dist[src][nbr] = dist[src][node]+1;\\n                   q.push(nbr);\\n               }\\n            }\\n        }\\n    }\\n    bool isBapartiteDFS(vector<int>adj[],int sv,vector<int>&visited,vector<int>&comp,int color){\\n        bool ans = true;\\n        comp.push_back(sv);\\n        visited[sv] = color;\\n        for(auto &nbr:adj[sv]){\\n            if(!visited[nbr]){\\n                ans &= isBapartiteDFS(adj,nbr,visited,comp,color == 1?2:1);\\n            }else if(visited[nbr] == color) return false;\\n        }\\n        return ans;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int>visited(n+1,0);\\n        vector<vector<int>>dist(n+1,vector<int>(n+1,INT_MAX));\\n        for(int i = 1;i <= n;i++){\\n            bfs(i,adj,dist);\\n        }\\n        int ans = 0;\\n        for(int i = 1;i <= n;i++){\\n            if(visited[i] == 0){\\n                vector<int>comp;\\n                if(!isBapartiteDFS(adj,i,visited,comp,1)) return -1;\\n                int mx = 0;\\n                for(int k = 0;k < comp.size();k++){\\n                    for(int j = k;j < comp.size();j++){\\n                        mx = max(mx,dist[comp[j]][comp[k]]);\\n                    }\\n                }\\n                ans += mx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(int src,vector<int>adj[],vector<vector<int>>&dist){\\n        queue<int>q;\\n        q.push(src);\\n        dist[src][src] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto &nbr:adj[node]){\\n               if(dist[src][nbr] > dist[src][node]+1){\\n                   dist[src][nbr] = dist[src][node]+1;\\n                   q.push(nbr);\\n               }\\n            }\\n        }\\n    }\\n    bool isBapartiteDFS(vector<int>adj[],int sv,vector<int>&visited,vector<int>&comp,int color){\\n        bool ans = true;\\n        comp.push_back(sv);\\n        visited[sv] = color;\\n        for(auto &nbr:adj[sv]){\\n            if(!visited[nbr]){\\n                ans &= isBapartiteDFS(adj,nbr,visited,comp,color == 1?2:1);\\n            }else if(visited[nbr] == color) return false;\\n        }\\n        return ans;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int>visited(n+1,0);\\n        vector<vector<int>>dist(n+1,vector<int>(n+1,INT_MAX));\\n        for(int i = 1;i <= n;i++){\\n            bfs(i,adj,dist);\\n        }\\n        int ans = 0;\\n        for(int i = 1;i <= n;i++){\\n            if(visited[i] == 0){\\n                vector<int>comp;\\n                if(!isBapartiteDFS(adj,i,visited,comp,1)) return -1;\\n                int mx = 0;\\n                for(int k = 0;k < comp.size();k++){\\n                    for(int j = k;j < comp.size();j++){\\n                        mx = max(mx,dist[comp[j]][comp[k]]);\\n                    }\\n                }\\n                ans += mx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876332,
                "title": "c-dfs-bfs-easy-explanation",
                "content": "Step 1. Use DFS to find out how many connected component in ths graph.\\nStep 2. For each connected component, use BFS to find out what the maximum number of level for this component.\\nStep 3. Since you have the level number for each connected component, then put all of them together to be the answer.\\n\\nIf there is any odd cycle in the graph, then -1 will be the answer because the correct graph should be a bipartite graph.\\nIn the BFS algorithm, if there is a edge in two vertext of same level, then this edge must be the edge of some odd cycle.\\nSo we can try to find out this edge to check is odd cycle exist in the graph or not.\\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_set<int>> mp;\\n    vector<unordered_set<int>> graphs_V;\\n    unordered_set<int> travelled;//dfs travelled vertics.\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        int ans = 0; // find out the maximum BFS level\\n        \\n        for(int i = 0; i < edges.size();i++) {\\n            mp[edges[i][0]].insert(edges[i][1]);\\n            mp[edges[i][1]].insert(edges[i][0]);\\n        }\\n        \\n        for(int i = 1; i<=n;i++) {\\n            if(travelled.find(i) == travelled.end()) {\\n                \\n                unordered_set<int> V;\\n                dfs(i,V);\\n                graphs_V.push_back(V);\\n            }    \\n        }\\n        for(unordered_set<int> &vertice: graphs_V) {            \\n            int ret = try_bfs_of_graph(vertice);\\n            if(ret==-1) return -1;\\n            ans += ret;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    void dfs(int u, unordered_set<int>& vertice) {\\n        vertice.insert(u);\\n        travelled.insert(u);\\n        for(auto&v:mp[u]) {\\n            if(travelled.find(v) == travelled.end()) {\\n                dfs(v, vertice);\\n            }\\n        }\\n    }\\n    \\n    int try_bfs_of_graph(unordered_set<int>& graphV) {\\n        int ans = -1;\\n        vector<int> graphVv;\\n        for(auto &i:graphV) {\\n            graphVv.push_back(i);\\n        }\\n        sort(graphVv.begin(), graphVv.end(), [&](auto &lhs, auto& rhs){\\n            if(mp[lhs].size() == mp[rhs].size()) {\\n                return lhs<rhs;\\n            } else {\\n                return mp[lhs].size() < mp[rhs].size();    \\n            }\\n        });\\n        \\n        vector<int> graphVvv;\\n        for(auto &i:graphVv) {\\n\\t\\t\\tif(mp[graphVv[0]].size()==mp[i].size() || mp[graphVv[1]].size()==mp[i].size()) {\\t\\t\\t\\n                graphVvv.push_back(i);\\n            }\\n        }\\n        \\n        //for(auto &i:graphV){\\n        for(auto &i:graphVvv){\\n            //Changing to use the graphVvv to instead graphV is \\n            //the magic stuff to against TLE XD\\n            queue<int> currQ;\\n            queue<int> nextQ;\\n            unordered_set<int> s;\\n            s.insert(i);\\n            currQ.push(i);\\n            int len = 0;\\n            unordered_set<int> ls;//the vertex set in the same level\\n            while(!currQ.empty()) {\\n                int e = currQ.front();\\n                currQ.pop();\\n                for(auto&v: mp[e]) {\\n                    \\n                    if(s.find(v) == s.end()) {\\n                        s.insert(v);\\n                        ls.insert(v);\\n                        nextQ.push(v);\\n                    }\\n                }\\n                if(currQ.empty()) {                    \\n                    len++;\\n                    int is_break = 0;\\n\\t\\t\\t\\t\\t//Check the edge of odd cycle exist or not.\\n                    for(auto &x : ls) {\\n                        for(auto &y: mp[x]) {\\n                            if(ls.find(y) != ls.end()) {\\n                                is_break = 1;\\n                                len = -1;\\n                                break;\\n                            }\\n                        }\\n                        if(is_break) break;\\n                    }\\n                    if(is_break) break;\\n                    ls.clear();\\n                    swap(currQ,nextQ);\\n                }\\n            }\\n            ans = max(ans, len);\\n        }\\n        return ans;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_set<int>> mp;\\n    vector<unordered_set<int>> graphs_V;\\n    unordered_set<int> travelled;//dfs travelled vertics.\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        int ans = 0; // find out the maximum BFS level\\n        \\n        for(int i = 0; i < edges.size();i++) {\\n            mp[edges[i][0]].insert(edges[i][1]);\\n            mp[edges[i][1]].insert(edges[i][0]);\\n        }\\n        \\n        for(int i = 1; i<=n;i++) {\\n            if(travelled.find(i) == travelled.end()) {\\n                \\n                unordered_set<int> V;\\n                dfs(i,V);\\n                graphs_V.push_back(V);\\n            }    \\n        }\\n        for(unordered_set<int> &vertice: graphs_V) {            \\n            int ret = try_bfs_of_graph(vertice);\\n            if(ret==-1) return -1;\\n            ans += ret;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    void dfs(int u, unordered_set<int>& vertice) {\\n        vertice.insert(u);\\n        travelled.insert(u);\\n        for(auto&v:mp[u]) {\\n            if(travelled.find(v) == travelled.end()) {\\n                dfs(v, vertice);\\n            }\\n        }\\n    }\\n    \\n    int try_bfs_of_graph(unordered_set<int>& graphV) {\\n        int ans = -1;\\n        vector<int> graphVv;\\n        for(auto &i:graphV) {\\n            graphVv.push_back(i);\\n        }\\n        sort(graphVv.begin(), graphVv.end(), [&](auto &lhs, auto& rhs){\\n            if(mp[lhs].size() == mp[rhs].size()) {\\n                return lhs<rhs;\\n            } else {\\n                return mp[lhs].size() < mp[rhs].size();    \\n            }\\n        });\\n        \\n        vector<int> graphVvv;\\n        for(auto &i:graphVv) {\\n\\t\\t\\tif(mp[graphVv[0]].size()==mp[i].size() || mp[graphVv[1]].size()==mp[i].size()) {\\t\\t\\t\\n                graphVvv.push_back(i);\\n            }\\n        }\\n        \\n        //for(auto &i:graphV){\\n        for(auto &i:graphVvv){\\n            //Changing to use the graphVvv to instead graphV is \\n            //the magic stuff to against TLE XD\\n            queue<int> currQ;\\n            queue<int> nextQ;\\n            unordered_set<int> s;\\n            s.insert(i);\\n            currQ.push(i);\\n            int len = 0;\\n            unordered_set<int> ls;//the vertex set in the same level\\n            while(!currQ.empty()) {\\n                int e = currQ.front();\\n                currQ.pop();\\n                for(auto&v: mp[e]) {\\n                    \\n                    if(s.find(v) == s.end()) {\\n                        s.insert(v);\\n                        ls.insert(v);\\n                        nextQ.push(v);\\n                    }\\n                }\\n                if(currQ.empty()) {                    \\n                    len++;\\n                    int is_break = 0;\\n\\t\\t\\t\\t\\t//Check the edge of odd cycle exist or not.\\n                    for(auto &x : ls) {\\n                        for(auto &y: mp[x]) {\\n                            if(ls.find(y) != ls.end()) {\\n                                is_break = 1;\\n                                len = -1;\\n                                break;\\n                            }\\n                        }\\n                        if(is_break) break;\\n                    }\\n                    if(is_break) break;\\n                    ls.clear();\\n                    swap(currQ,nextQ);\\n                }\\n            }\\n            ans = max(ans, len);\\n        }\\n        return ans;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876028,
                "title": "easy-c-solution-using-union-find-and-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven n is 500 a solution of O(n^2) will be good enough.\\nDo a BFS on every node and find max group for it\\n\\nAs the question has disconnected graphs use union find to create seperate graphs and just add their values up\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the main solving function BFS we have a vector group which we use the satisfy the required conditions\\n\\n# Complexity\\n- Time complexity:\\n    O(n^2)\\n    As we are enumerating every node and doing a bfs\\n\\n- Space complexity:\\n    O(n^2)\\n    In a worst case we have a complete connected graph\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    vector<int> parent;\\n    int n;\\n\\n    int findP(int x){\\n        if(parent[x] != x)\\n            parent[x] = findP(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void dfs(int node, vector<bool> &visited){\\n        for(int next : g[node]){\\n            if(!visited[next]){\\n                visited[next] = true;\\n                parent[next] = findP(node);\\n                dfs(next, visited);\\n            }\\n        }\\n    }\\n\\n    map<int, vector<int>> makeUnions(){\\n        // intialize parents \\n        parent = vector<int>(n);\\n        for(int i = 0 ; i < n ; ++i)\\n            parent[i] = i;\\n\\n        vector<bool> visited(n, false);\\n        map<int, vector<int>> connectedNodes;\\n\\n        for(int i = 0 ; i < n ;++i)\\n            if(!visited[i])\\n                // dfs to explore the rest of graph\\n                dfs(i, visited);\\n\\n        for(int i = 0 ; i < n ; ++i)\\n            connectedNodes[findP(i)].push_back(i);\\n\\n        return connectedNodes;\\n    }\\n\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n\\n        this->n = n;\\n        g = vector<vector<int>>(n);\\n        for(auto &edge: edges){\\n            int a = edge[0] - 1, b = edge[1] - 1;\\n            g[a].push_back(b);\\n            g[b].push_back(a);\\n        }\\n\\n        // find disconnected graph and treat them as seperate question\\n        map<int, vector<int>> connectedNodes  = makeUnions();\\n        \\n\\n        int ans = 0;\\n\\n        for(auto &I : connectedNodes){\\n            auto nodes = I.second;\\n            int tempAns = 0;\\n\\n            for(int node : nodes){\\n                int temp = bfs(node);\\n                if(temp == -1)\\n                    return -1;\\n                tempAns = max(tempAns, temp);    \\n            }\\n            ans += tempAns;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int bfs(int root){\\n\\n        vector<bool> visited(n, false);\\n        vector<int> group(n, -1);\\n\\n        visited[root] = true;\\n        group[root] = 1;\\n\\n        queue<int> q;\\n        q.push(root);\\n        int ans = 1;\\n        while(!q.empty()){\\n            int m = q.size();\\n            while(m--){\\n                int node = q.front(); q.pop();\\n                for(int next : g[node]){\\n                    if(visited[next]){\\n                        if(abs(group[node] - group[next] ) != 1)\\n                            return -1;\\n                    } \\n                    else{\\n                        q.push(next);\\n                        visited[next] = true;\\n                        group[next] = group[node] + 1;\\n                        ans = max(ans, group[next]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    \\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    vector<int> parent;\\n    int n;\\n\\n    int findP(int x){\\n        if(parent[x] != x)\\n            parent[x] = findP(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void dfs(int node, vector<bool> &visited){\\n        for(int next : g[node]){\\n            if(!visited[next]){\\n                visited[next] = true;\\n                parent[next] = findP(node);\\n                dfs(next, visited);\\n            }\\n        }\\n    }\\n\\n    map<int, vector<int>> makeUnions(){\\n        // intialize parents \\n        parent = vector<int>(n);\\n        for(int i = 0 ; i < n ; ++i)\\n            parent[i] = i;\\n\\n        vector<bool> visited(n, false);\\n        map<int, vector<int>> connectedNodes;\\n\\n        for(int i = 0 ; i < n ;++i)\\n            if(!visited[i])\\n                // dfs to explore the rest of graph\\n                dfs(i, visited);\\n\\n        for(int i = 0 ; i < n ; ++i)\\n            connectedNodes[findP(i)].push_back(i);\\n\\n        return connectedNodes;\\n    }\\n\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n\\n        this->n = n;\\n        g = vector<vector<int>>(n);\\n        for(auto &edge: edges){\\n            int a = edge[0] - 1, b = edge[1] - 1;\\n            g[a].push_back(b);\\n            g[b].push_back(a);\\n        }\\n\\n        // find disconnected graph and treat them as seperate question\\n        map<int, vector<int>> connectedNodes  = makeUnions();\\n        \\n\\n        int ans = 0;\\n\\n        for(auto &I : connectedNodes){\\n            auto nodes = I.second;\\n            int tempAns = 0;\\n\\n            for(int node : nodes){\\n                int temp = bfs(node);\\n                if(temp == -1)\\n                    return -1;\\n                tempAns = max(tempAns, temp);    \\n            }\\n            ans += tempAns;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int bfs(int root){\\n\\n        vector<bool> visited(n, false);\\n        vector<int> group(n, -1);\\n\\n        visited[root] = true;\\n        group[root] = 1;\\n\\n        queue<int> q;\\n        q.push(root);\\n        int ans = 1;\\n        while(!q.empty()){\\n            int m = q.size();\\n            while(m--){\\n                int node = q.front(); q.pop();\\n                for(int next : g[node]){\\n                    if(visited[next]){\\n                        if(abs(group[node] - group[next] ) != 1)\\n                            return -1;\\n                    } \\n                    else{\\n                        q.push(next);\\n                        visited[next] = true;\\n                        group[next] = group[node] + 1;\\n                        ans = max(ans, group[next]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    \\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875790,
                "title": "c-bfs-bfs",
                "content": "1. The first BFS is to find the longest distance within the same group\\n2. The second BFS is the check if we can make it a valid bipartite starting from a vertex.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> aj;\\n    vector<int> group;\\n    int dist[501][501] = {INT_MAX};\\n    \\n    \\n    void updateDist(int src) {\\n        for(int i=1; i<=500; i++) \\n            dist[src][i] = INT_MAX;\\n        dist[src][src] = 1;\\n        \\n        queue<int> q;\\n        q.push(src);\\n        while(!q.empty()) {\\n            int u = q.front(); q.pop();\\n            for(int v: aj[u]) {\\n                if(dist[src][v]>dist[src][u]+1) {\\n                    dist[src][v] = dist[src][u]+1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    \\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        aj.resize(n+1);\\n        group.resize(n+1, -1);\\n        for(auto& edge: edges) {\\n            int a = edge[0], b = edge[1];\\n            aj[a].push_back(b);\\n            aj[b].push_back(a);\\n        }\\n        \\n        for(int i=1; i<=n; i++) \\n            updateDist(i);\\n        \\n        int ret = 0;\\n        for(int i=1; i<=n; i++) {\\n            if(group[i]!=-1) continue;\\n            \\n            vector<int> visited;\\n            queue<pair<int,int>> q;\\n            q.push({i, 0});\\n            group[i] = 0;\\n            visited.push_back(i);\\n            while(!q.empty()) {\\n                auto [node, g] = q.front(); \\n                q.pop();\\n                for(int nxt: aj[node]) {\\n                    if(group[nxt]==g) return -1;\\n                    if(group[nxt]==-1) {\\n                        q.push({nxt, 1-g});\\n                        group[nxt] = 1-g;\\n                        visited.push_back(nxt);\\n                    }\\n                }\\n            }\\n            \\n            int maxdist = 0;\\n            for(auto i: visited) {\\n                for(auto j: visited) {\\n                    maxdist = max(maxdist, dist[i][j]);\\n                }\\n            }\\n            ret += maxdist;\\n        }\\n        \\n        \\n        return ret;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> aj;\\n    vector<int> group;\\n    int dist[501][501] = {INT_MAX};\\n    \\n    \\n    void updateDist(int src) {\\n        for(int i=1; i<=500; i++) \\n            dist[src][i] = INT_MAX;\\n        dist[src][src] = 1;\\n        \\n        queue<int> q;\\n        q.push(src);\\n        while(!q.empty()) {\\n            int u = q.front(); q.pop();\\n            for(int v: aj[u]) {\\n                if(dist[src][v]>dist[src][u]+1) {\\n                    dist[src][v] = dist[src][u]+1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    \\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        aj.resize(n+1);\\n        group.resize(n+1, -1);\\n        for(auto& edge: edges) {\\n            int a = edge[0], b = edge[1];\\n            aj[a].push_back(b);\\n            aj[b].push_back(a);\\n        }\\n        \\n        for(int i=1; i<=n; i++) \\n            updateDist(i);\\n        \\n        int ret = 0;\\n        for(int i=1; i<=n; i++) {\\n            if(group[i]!=-1) continue;\\n            \\n            vector<int> visited;\\n            queue<pair<int,int>> q;\\n            q.push({i, 0});\\n            group[i] = 0;\\n            visited.push_back(i);\\n            while(!q.empty()) {\\n                auto [node, g] = q.front(); \\n                q.pop();\\n                for(int nxt: aj[node]) {\\n                    if(group[nxt]==g) return -1;\\n                    if(group[nxt]==-1) {\\n                        q.push({nxt, 1-g});\\n                        group[nxt] = 1-g;\\n                        visited.push_back(nxt);\\n                    }\\n                }\\n            }\\n            \\n            int maxdist = 0;\\n            for(auto i: visited) {\\n                for(auto j: visited) {\\n                    maxdist = max(maxdist, dist[i][j]);\\n                }\\n            }\\n            ret += maxdist;\\n        }\\n        \\n        \\n        return ret;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875487,
                "title": "java-simple-and-self-explanatory",
                "content": "```\\nclass Solution {\\n\\tpublic static int magnificentSets(int n, int[][] edges) {\\n\\t\\t// Make an array of adjacent nodes\\n\\t\\tint[] degree = new int[n + 1];\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tdegree[edge[0]]++;\\n\\t\\t\\tdegree[edge[1]]++;\\n\\t\\t}\\n\\t\\tint[][] adjacent = new int[n + 1][];\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tadjacent[i] = new int[degree[i]];\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tint a = edge[0];\\n\\t\\t\\tint b = edge[1];\\n\\t\\t\\tadjacent[a][--degree[a]] = b;\\n\\t\\t\\tadjacent[b][--degree[b]] = a;\\n\\t\\t}\\n\\t\\t// Find the largest distance from each node to other nodes in its component\\n\\t\\tint[] queue = new int[n];\\n\\t\\tint[] distance = new int[n + 1];\\n\\t\\tint[] maxDistance = new int[n + 1];\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tArrays.fill(distance, -1);\\n\\t\\t\\tqueue[0] = i;\\n\\t\\t\\tdistance[i] = 0;\\n\\t\\t\\tint maxDist = 0;\\n\\t\\t\\tint first = 0;\\n\\t\\t\\tint last = 0;\\n\\t\\t\\twhile (first <= last) {\\n\\t\\t\\t\\tint node = queue[first++];\\n\\t\\t\\t\\tint d = distance[node] + 1;\\n\\t\\t\\t\\tfor (int aNode : adjacent[node])\\n\\t\\t\\t\\t\\tif (distance[aNode] < 0) {\\n\\t\\t\\t\\t\\t\\tdistance[aNode] = d;\\n\\t\\t\\t\\t\\t\\tmaxDist = d;\\n\\t\\t\\t\\t\\t\\tqueue[++last] = aNode;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmaxDistance[i] = maxDist;\\n\\t\\t}\\n\\t\\t// Split the graph into components, checking if it is bipartite\\n\\t\\t// and adding the diameter of each component to the final result\\n\\t\\tArrays.fill(distance, -1);\\n\\t\\tint result = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tif (distance[i] >= 0) // the node i is already examined\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tqueue[0] = i;\\n\\t\\t\\tdistance[i] = 0;\\n\\t\\t\\tint diameter = 0;\\n\\t\\t\\tint first = 0;\\n\\t\\t\\tint last = 0;\\n\\t\\t\\twhile (first <= last) {\\n\\t\\t\\t\\tint node = queue[first++];\\n\\t\\t\\t\\tdiameter = Math.max(diameter, maxDistance[node]);\\n\\t\\t\\t\\tint d = distance[node] + 1;\\n\\t\\t\\t\\tfor (int aNode : adjacent[node]) {\\n\\t\\t\\t\\t\\tint ad = distance[aNode];\\n\\t\\t\\t\\t\\tif (ad < 0) {\\n\\t\\t\\t\\t\\t\\tdistance[aNode] = d;\\n\\t\\t\\t\\t\\t\\tqueue[++last] = aNode;\\n\\t\\t\\t\\t\\t} else if ((d + ad) % 2 != 0) // the graph is not bipartite\\n\\t\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tresult += diameter + 1;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int magnificentSets(int n, int[][] edges) {\\n\\t\\t// Make an array of adjacent nodes\\n\\t\\tint[] degree = new int[n + 1];\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tdegree[edge[0]]++;\\n\\t\\t\\tdegree[edge[1]]++;\\n\\t\\t}\\n\\t\\tint[][] adjacent = new int[n + 1][];\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tadjacent[i] = new int[degree[i]];\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tint a = edge[0];\\n\\t\\t\\tint b = edge[1];\\n\\t\\t\\tadjacent[a][--degree[a]] = b;\\n\\t\\t\\tadjacent[b][--degree[b]] = a;\\n\\t\\t}\\n\\t\\t// Find the largest distance from each node to other nodes in its component\\n\\t\\tint[] queue = new int[n];\\n\\t\\tint[] distance = new int[n + 1];\\n\\t\\tint[] maxDistance = new int[n + 1];\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tArrays.fill(distance, -1);\\n\\t\\t\\tqueue[0] = i;\\n\\t\\t\\tdistance[i] = 0;\\n\\t\\t\\tint maxDist = 0;\\n\\t\\t\\tint first = 0;\\n\\t\\t\\tint last = 0;\\n\\t\\t\\twhile (first <= last) {\\n\\t\\t\\t\\tint node = queue[first++];\\n\\t\\t\\t\\tint d = distance[node] + 1;\\n\\t\\t\\t\\tfor (int aNode : adjacent[node])\\n\\t\\t\\t\\t\\tif (distance[aNode] < 0) {\\n\\t\\t\\t\\t\\t\\tdistance[aNode] = d;\\n\\t\\t\\t\\t\\t\\tmaxDist = d;\\n\\t\\t\\t\\t\\t\\tqueue[++last] = aNode;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmaxDistance[i] = maxDist;\\n\\t\\t}\\n\\t\\t// Split the graph into components, checking if it is bipartite\\n\\t\\t// and adding the diameter of each component to the final result\\n\\t\\tArrays.fill(distance, -1);\\n\\t\\tint result = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tif (distance[i] >= 0) // the node i is already examined\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tqueue[0] = i;\\n\\t\\t\\tdistance[i] = 0;\\n\\t\\t\\tint diameter = 0;\\n\\t\\t\\tint first = 0;\\n\\t\\t\\tint last = 0;\\n\\t\\t\\twhile (first <= last) {\\n\\t\\t\\t\\tint node = queue[first++];\\n\\t\\t\\t\\tdiameter = Math.max(diameter, maxDistance[node]);\\n\\t\\t\\t\\tint d = distance[node] + 1;\\n\\t\\t\\t\\tfor (int aNode : adjacent[node]) {\\n\\t\\t\\t\\t\\tint ad = distance[aNode];\\n\\t\\t\\t\\t\\tif (ad < 0) {\\n\\t\\t\\t\\t\\t\\tdistance[aNode] = d;\\n\\t\\t\\t\\t\\t\\tqueue[++last] = aNode;\\n\\t\\t\\t\\t\\t} else if ((d + ad) % 2 != 0) // the graph is not bipartite\\n\\t\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tresult += diameter + 1;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875451,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nClearly, we know that we need to divide it into connected components. Also, if we know group 1, we can know all other groups.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSo, we need to prove, our group 1 can only have 1 element.\\n\\nProof:\\n\\nIf we have two elements $a$ and $b$ in group 1, then we know, if {$a$} not work, {$a, b$} could not work. Also, the group # in {$a, b$} has to be followed by the group # in {$a$} (and in {$b$}). So, we know if {$a, b$} work, the group number would be the same because the only choice of groups for $a$ is unique. So we only need to consider the group 1 only has 1 element\\'s case.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$O(VE)$ where $V$ is number of vertexes and $E$ is number of edges.\\n\\n# Code\\n```\\nconstexpr int MAXN = 505;\\n\\nvector<int> adj[MAXN];\\nint vis[MAXN];\\n\\ninline int depthof(int x) {\\n    queue<int> q;\\n    q.push(x);\\n    vis[x] = 1;\\n    int mx = 1;\\n    while (!q.empty()) {\\n        x = q.front();\\n        q.pop();\\n        for (auto v: adj[x]) {\\n            if (!vis[v]) {\\n                vis[v] = vis[x] + 1;\\n                mx = max(mx, vis[v]);\\n                q.push(v);\\n            }\\n            if (abs(vis[v] - vis[x]) != 1) {\\n                return -1;\\n            }\\n        }\\n    }\\n    return mx;\\n}\\n\\ninline int mxof(vector<int> &grp) {\\n    int mx = -0x3f3f3f3f;\\n    for (auto x: grp) {\\n        for (auto t: grp) {\\n            vis[t] = 0;\\n        }\\n        mx = max(mx, depthof(x));\\n    }\\n    return mx;\\n}\\n\\ninline void dfs(int x, vector<int> &grp, vector<bool> &visited) {\\n    visited[x] = true;\\n    grp.push_back(x);\\n    for (auto v: adj[x]) {\\n        if (!visited[v]) {\\n            dfs(v, grp, visited);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<bool> visited(n + 1, false);\\n        for (int i = 1; i <= n; i ++) {\\n            adj[i].clear();\\n            vis[i] = 0;\\n        }\\n        for (auto &v: edges) {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= n; i ++) {\\n            if (!visited[i]) {\\n                vector<int> grp;\\n                dfs(i, grp, visited);\\n                int t = mxof(grp);\\n                if (t == -1) {\\n                    return -1;\\n                }\\n                ans += t;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconstexpr int MAXN = 505;\\n\\nvector<int> adj[MAXN];\\nint vis[MAXN];\\n\\ninline int depthof(int x) {\\n    queue<int> q;\\n    q.push(x);\\n    vis[x] = 1;\\n    int mx = 1;\\n    while (!q.empty()) {\\n        x = q.front();\\n        q.pop();\\n        for (auto v: adj[x]) {\\n            if (!vis[v]) {\\n                vis[v] = vis[x] + 1;\\n                mx = max(mx, vis[v]);\\n                q.push(v);\\n            }\\n            if (abs(vis[v] - vis[x]) != 1) {\\n                return -1;\\n            }\\n        }\\n    }\\n    return mx;\\n}\\n\\ninline int mxof(vector<int> &grp) {\\n    int mx = -0x3f3f3f3f;\\n    for (auto x: grp) {\\n        for (auto t: grp) {\\n            vis[t] = 0;\\n        }\\n        mx = max(mx, depthof(x));\\n    }\\n    return mx;\\n}\\n\\ninline void dfs(int x, vector<int> &grp, vector<bool> &visited) {\\n    visited[x] = true;\\n    grp.push_back(x);\\n    for (auto v: adj[x]) {\\n        if (!visited[v]) {\\n            dfs(v, grp, visited);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<bool> visited(n + 1, false);\\n        for (int i = 1; i <= n; i ++) {\\n            adj[i].clear();\\n            vis[i] = 0;\\n        }\\n        for (auto &v: edges) {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= n; i ++) {\\n            if (!visited[i]) {\\n                vector<int> grp;\\n                dfs(i, grp, visited);\\n                int t = mxof(grp);\\n                if (t == -1) {\\n                    return -1;\\n                }\\n                ans += t;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875254,
                "title": "c-simple-bfs-solution",
                "content": "Firstly, build the adjency list.\\n\\nThen, run a BFS from each node to\\n1. find the maximum distance to any connected nodes, and\\n2. detect odd length cycles (return -1)\\n\\nFinally, add up the number of groups (diameter+1) of each connected fragment (identified by its smallest node ID)\\n\\n```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int> distances(n);\\n        vector<vector<int>> adj(n);\\n        for (auto &v: edges) {\\n            int a = v[0] - 1;\\n            int b = v[1] - 1;\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        unordered_map<int,int> data; // min_node, max_step\\n        queue<pair<int,int>> nodes; // current node, last node\\n        for (int i = 0; i < n; ++i) {\\n            fill(distances.begin(), distances.end(), -1);\\n            int step = 0;\\n            \\n            distances[i] = 0;\\n            nodes.push({i, -1});\\n            int min_node = i;\\n            \\n            while (int k = nodes.size()) {\\n                ++step;\\n                while (k--) {\\n                    auto [node, last] = nodes.front(); nodes.pop();\\n                    for (int next: adj[node]) {\\n                        if (next == last) continue; // prevent going backward\\n                        if (distances[next] == -1) { // not visited before\\n                            distances[next] = step;\\n                            nodes.push({next, node});\\n                            min_node = min(min_node, next);\\n                        } else { // visited before\\n                            if ((distances[next] - step) % 2) return -1; // odd cycles\\n                        }\\n                    }\\n                }\\n            }\\n            data[min_node] = max(data[min_node], step); // update max number of groups for this fragment\\n        }\\n        int result = 0;\\n        for (auto [k, v]: data) result += v;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int> distances(n);\\n        vector<vector<int>> adj(n);\\n        for (auto &v: edges) {\\n            int a = v[0] - 1;\\n            int b = v[1] - 1;\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        unordered_map<int,int> data; // min_node, max_step\\n        queue<pair<int,int>> nodes; // current node, last node\\n        for (int i = 0; i < n; ++i) {\\n            fill(distances.begin(), distances.end(), -1);\\n            int step = 0;\\n            \\n            distances[i] = 0;\\n            nodes.push({i, -1});\\n            int min_node = i;\\n            \\n            while (int k = nodes.size()) {\\n                ++step;\\n                while (k--) {\\n                    auto [node, last] = nodes.front(); nodes.pop();\\n                    for (int next: adj[node]) {\\n                        if (next == last) continue; // prevent going backward\\n                        if (distances[next] == -1) { // not visited before\\n                            distances[next] = step;\\n                            nodes.push({next, node});\\n                            min_node = min(min_node, next);\\n                        } else { // visited before\\n                            if ((distances[next] - step) % 2) return -1; // odd cycles\\n                        }\\n                    }\\n                }\\n            }\\n            data[min_node] = max(data[min_node], step); // update max number of groups for this fragment\\n        }\\n        int result = 0;\\n        for (auto [k, v]: data) result += v;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875171,
                "title": "think-about-the-upper-limit",
                "content": "1. color black and white, if can\\'t, return -1.\\n2. find the longest of shortest path for each connected component.\\n```\\nclass Solution {\\nprivate:\\n    vector<int>color;\\n    vector<vector<int>>e;\\n    vector<int>v;\\n\\t// coloring black and white.\\n    bool dfs(int x, int cc){\\n        color[x] = cc;\\n        v.push_back(x);\\n        for(auto y : e[x]){\\n            if(color[y]==cc)return false;\\n            if(color[y])continue;\\n            if(!dfs(y, 3-cc))return false;\\n        }\\n        return true;\\n    }\\n\\t// find the longest shortest path from x\\n    int solve(int x, int n){\\n        vector<int>dis(n+1, -1);\\n        dis[x] = 0;\\n        queue<int>q;\\n        q.push(x);\\n        int mx = 0;\\n        while(!q.empty()) {\\n            auto cur = q.front();\\n            q.pop();\\n            mx = max(mx, dis[cur]);\\n            for(auto y : e[cur]) {\\n                if(dis[y]!=-1)continue;\\n                dis[y] = dis[cur] + 1;\\n                q.push(y);\\n            }\\n        }\\n        return mx + 1;\\n    }\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        e = vector<vector<int>>(n+1);\\n        color = vector<int>(n+1, 0);\\n        for(auto& tt : edges) {\\n            e[tt[0]].push_back(tt[1]);\\n            e[tt[1]].push_back(tt[0]);\\n        }\\n        int ret = 0;\\n        for(int i = 1;i<=n;i++){\\n            v.clear();\\n            if(color[i] == 0 && !dfs(i, 1))return -1;\\n            int mx= 0;\\n            for(auto x: v){\\n                mx = max(mx, solve(x, n));\\n            }\\n            ret += mx;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int>color;\\n    vector<vector<int>>e;\\n    vector<int>v;\\n\\t// coloring black and white.\\n    bool dfs(int x, int cc){\\n        color[x] = cc;\\n        v.push_back(x);\\n        for(auto y : e[x]){\\n            if(color[y]==cc)return false;\\n            if(color[y])continue;\\n            if(!dfs(y, 3-cc))return false;\\n        }\\n        return true;\\n    }\\n\\t// find the longest shortest path from x\\n    int solve(int x, int n){\\n        vector<int>dis(n+1, -1);\\n        dis[x] = 0;\\n        queue<int>q;\\n        q.push(x);\\n        int mx = 0;\\n        while(!q.empty()) {\\n            auto cur = q.front();\\n            q.pop();\\n            mx = max(mx, dis[cur]);\\n            for(auto y : e[cur]) {\\n                if(dis[y]!=-1)continue;\\n                dis[y] = dis[cur] + 1;\\n                q.push(y);\\n            }\\n        }\\n        return mx + 1;\\n    }\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        e = vector<vector<int>>(n+1);\\n        color = vector<int>(n+1, 0);\\n        for(auto& tt : edges) {\\n            e[tt[0]].push_back(tt[1]);\\n            e[tt[1]].push_back(tt[0]);\\n        }\\n        int ret = 0;\\n        for(int i = 1;i<=n;i++){\\n            v.clear();\\n            if(color[i] == 0 && !dfs(i, 1))return -1;\\n            int mx= 0;\\n            for(auto x: v){\\n                mx = max(mx, solve(x, n));\\n            }\\n            ret += mx;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008691,
                "title": "check-bipartite-and-maximum-depth-for-each-connected-component",
                "content": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def check(self, graph, i, color):\\n        for j in graph[i]:\\n            if color[j] != -1 and color[j] != 1 - color[i]:\\n                return False\\n            if color[j] == -1:\\n                color[j] = 1 - color[i]\\n                self.currv.add(j)\\n                if not self.check(graph, j, color):\\n                    return False\\n        return True\\n    \\n    def count(self, graph, i):\\n        q = deque([(i, 1)])\\n        v = {i}\\n        res = 0\\n        while len(q) > 0:\\n            curr, ctr = q.pop()\\n            res = ctr\\n            for j in graph[curr]:\\n                if j not in v:\\n                    v.add(j)\\n                    q.appendleft((j, ctr + 1))\\n        return res\\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a - 1].add(b - 1)\\n            graph[b - 1].add(a - 1)\\n        color = [-1] * n\\n        res = 0\\n        for i in range(n):\\n            if color[i] == -1:\\n                color[i] = 0\\n                self.currv = {i}\\n                if not self.check(graph, i, color):\\n                    return -1\\n                curr = 0\\n                for x in self.currv:\\n                    curr = max(curr, self.count(graph, x))\\n                res += curr\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def check(self, graph, i, color):\\n        for j in graph[i]:\\n            if color[j] != -1 and color[j] != 1 - color[i]:\\n                return False\\n            if color[j] == -1:\\n                color[j] = 1 - color[i]\\n                self.currv.add(j)\\n                if not self.check(graph, j, color):\\n                    return False\\n        return True\\n    \\n    def count(self, graph, i):\\n        q = deque([(i, 1)])\\n        v = {i}\\n        res = 0\\n        while len(q) > 0:\\n            curr, ctr = q.pop()\\n            res = ctr\\n            for j in graph[curr]:\\n                if j not in v:\\n                    v.add(j)\\n                    q.appendleft((j, ctr + 1))\\n        return res\\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a - 1].add(b - 1)\\n            graph[b - 1].add(a - 1)\\n        color = [-1] * n\\n        res = 0\\n        for i in range(n):\\n            if color[i] == -1:\\n                color[i] = 0\\n                self.currv = {i}\\n                if not self.check(graph, i, color):\\n                    return -1\\n                curr = 0\\n                for x in self.currv:\\n                    curr = max(curr, self.count(graph, x))\\n                res += curr\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998941,
                "title": "very-short-just-bfs",
                "content": "# Intuition\\nSimilar to other solutions, but just one pass of bfs on each node is sufficient (no odd cycle checking or dsu for finding components).\\n\\n# Code\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(set)\\n        for u,v in edges:\\n            u, v = u-1, v-1\\n            g[u].add(v)\\n            g[v].add(u)\\n\\n        ans = defaultdict(lambda: float(\\'-inf\\'))\\n        for u in range(n):\\n            q, visited, steps = [u], set([u]), 0\\n            while q:\\n                steps += 1\\n                q1 = set()\\n                for u in q:\\n                    for v in g[u]:\\n                        if v in q: return -1\\n                        if v not in visited:\\n                            q1.add(v)\\n                            visited.add(v)\\n                q = q1\\n            \\n            k = min(visited)\\n            ans[k] = max(ans[k], steps)\\n\\n        return sum(ans.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(set)\\n        for u,v in edges:\\n            u, v = u-1, v-1\\n            g[u].add(v)\\n            g[v].add(u)\\n\\n        ans = defaultdict(lambda: float(\\'-inf\\'))\\n        for u in range(n):\\n            q, visited, steps = [u], set([u]), 0\\n            while q:\\n                steps += 1\\n                q1 = set()\\n                for u in q:\\n                    for v in g[u]:\\n                        if v in q: return -1\\n                        if v not in visited:\\n                            q1.add(v)\\n                            visited.add(v)\\n                q = q1\\n            \\n            k = min(visited)\\n            ans[k] = max(ans[k], steps)\\n\\n        return sum(ans.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984150,
                "title": "need-help-in-debugging-for-better-understanding",
                "content": "This code pass most of the test cases.Although I understood the solution, Can anyone help me where am doing it wrong in this ?\\n\\n![image](https://assets.leetcode.com/users/images/a1b8273c-3c04-44fd-b4c5-5321f23c5e82_1693480213.4381304.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    vector<int> color;\\n    vector<int> vis;\\n    bool BFS(int src,int col){\\n        //vis[src]=1;\\n        queue<int>q ;\\n        q.push(src);\\n        color[src]=col;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int u=q.front();\\n                q.pop();\\n                \\n                for(auto v: adj[u]){\\n                    if(color[v]==-1){\\n                        color[v]=color[u]+1;\\n                        q.push(v);\\n                    }else if(abs(color[v]-color[u])!=1) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        adj.resize(n+1,vector<int>());\\n        color.resize(n+1,-1);\\n        vis.assign(n+1,0);\\n        for(auto e: edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<pair<int,int>> v;\\n        for(int i=1;i<=n;i++){\\n            v.push_back({adj[i].size(),i});\\n        }\\n        sort(v.begin(),v.end());\\n        int sum=0;\\n        int col=1;\\n        \\n        for(int i=0;i<n;i++){\\n            int src=v[i].second;\\n            \\n            if(color[src]==-1){\\n                //color.assign(n+1,-1);\\n                //for(auto c: color) cout<<c<<\" \";\\n                 if(BFS(src,col)==false) {\\n                     //for(auto c: color) cout<<c<<\" \";\\n                     return -1;\\n                 }\\n                //cout<<color[0];\\n                col=*max_element(color.begin(),color.end());\\n                col++;\\n                //sum+=col;\\n            }\\n                \\n        }\\n        //for(auto c: color) cout<<c<<\" \";\\n        return col-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    vector<int> color;\\n    vector<int> vis;\\n    bool BFS(int src,int col){\\n        //vis[src]=1;\\n        queue<int>q ;\\n        q.push(src);\\n        color[src]=col;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int u=q.front();\\n                q.pop();\\n                \\n                for(auto v: adj[u]){\\n                    if(color[v]==-1){\\n                        color[v]=color[u]+1;\\n                        q.push(v);\\n                    }else if(abs(color[v]-color[u])!=1) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        adj.resize(n+1,vector<int>());\\n        color.resize(n+1,-1);\\n        vis.assign(n+1,0);\\n        for(auto e: edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<pair<int,int>> v;\\n        for(int i=1;i<=n;i++){\\n            v.push_back({adj[i].size(),i});\\n        }\\n        sort(v.begin(),v.end());\\n        int sum=0;\\n        int col=1;\\n        \\n        for(int i=0;i<n;i++){\\n            int src=v[i].second;\\n            \\n            if(color[src]==-1){\\n                //color.assign(n+1,-1);\\n                //for(auto c: color) cout<<c<<\" \";\\n                 if(BFS(src,col)==false) {\\n                     //for(auto c: color) cout<<c<<\" \";\\n                     return -1;\\n                 }\\n                //cout<<color[0];\\n                col=*max_element(color.begin(),color.end());\\n                col++;\\n                //sum+=col;\\n            }\\n                \\n        }\\n        //for(auto c: color) cout<<c<<\" \";\\n        return col-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3970407,
                "title": "bfs-dfs-bipartite-commented",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    // Function for checking whether a graph component is bipartite or not (for disconnected graph)\\n    bool bipartite(int src, vector<int> adj[], int color[])\\n    {\\n        queue<int> q;  // Create a queue for BFS traversal\\n        q.push(src);  // Push the source node into the queue\\n        color[src] = 1;  // Mark the color of the source node as 1 (arbitrary initial color)\\n        \\n        // Start BFS traversal\\n        while (!q.empty())\\n        {\\n            int node = q.front();  // Get the front node from the queue\\n            q.pop();  // Remove the front node\\n            \\n            // Iterate through all neighbors of the current node\\n            for (auto it : adj[node])\\n            {\\n                if (color[it] == -1)  // If the adjacent node is uncolored\\n                {\\n                    color[it] = 1 - color[node];  // Assign opposite color (0 or 1)\\n                    q.push(it);  // Push the adjacent node into the queue\\n                }\\n                else if (color[it] == color[node])  // If adjacent node has the same color\\n                    return false;  // The graph is not bipartite\\n            }\\n        }\\n        return true;  // The graph component is bipartite\\n    }\\n    \\n    // Function for checking whether a graph is bipartite or not\\n    bool checkBipartite(int &n, vector<int> adj[])\\n    {\\n        int color[n + 1];  // Array to store colors of nodes\\n        memset(color, -1, sizeof color);  // Initialize all colors to -1 (uncolored)\\n        \\n        // Iterate through all nodes\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (color[i] == -1)  // If the node is uncolored\\n            {\\n                // Check if the connected component is bipartite using bipartite function\\n                if (!bipartite(i, adj, color))\\n                    return false;  // The graph is not bipartite\\n            }\\n        }\\n        return true;  // The entire graph is bipartite\\n    }\\n    \\n    // Function for finding distance of farthest node from the current node\\n    // To get the maximum number of groups\\n    int findFarthestDistBFS(int src, int n, vector<int> adj[])\\n    {\\n        vector<int> vis(n + 1, 0);  // Array to mark visited nodes\\n        int cnt = 0;  // Initialize a count for nodes\\n        \\n        queue<int> q;  // Create a queue for BFS traversal\\n        q.push(src);  // Push the source node into the queue\\n        vis[src] = 1;  // Mark the source node as visited\\n        \\n        // Start BFS traversal\\n        while (!q.empty())\\n        {\\n            int sz = q.size();  // Get the current size of the queue (nodes in the same level)\\n            cnt++;  // Increment the count for nodes in this level\\n            \\n            // Process nodes in the current level\\n            for (int i = 0; i < sz; i++)\\n            {\\n                int node = q.front();  // Get the front node from the queue\\n                q.pop();  // Remove the front node\\n                \\n                // Iterate through all neighbors of the current node\\n                for (auto it : adj[node])\\n                {\\n                    if (!vis[it])  // If the neighbor is not visited\\n                    {\\n                        q.push(it);  // Push the neighbor into the queue\\n                        vis[it] = 1;  // Mark the neighbor as visited\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;  // Return the count of nodes in the farthest reachable component\\n    }\\n    \\n    // For finding maximum groups of multiple components of a graph\\n    int dfsForComponents(int node, vector<int> adj[], vector<int> &vist, vector<int> &dist)\\n    {\\n        vist[node] = 1;  // Mark the current node as visited\\n        int maxi = dist[node];  // Initialize maximum distance with the node\\'s distance\\n        \\n        // Iterate through all neighbors of the current node\\n        for (auto it : adj[node])\\n        {\\n            if (!vist[it])  // If the neighbor is not visited\\n            {\\n                // Recursively explore the neighbor and update the maximum distance\\n                maxi = max(maxi, dfsForComponents(it, adj, vist, dist));\\n            }\\n        }\\n        return maxi;  // Return the maximum distance within the component\\n    }\\n    \\n    // Given function to find the maximum number of \"magnificent sets\"\\n    int magnificentSets(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> adj[n + 1];  // Create an adjacency list for the graph\\n        \\n        // Fill the adjacency list based on the given edges\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);  // Add edge from node 0 to node 1\\n            adj[edges[i][1]].push_back(edges[i][0]);  // Add edge from node 1 to node 0\\n        }\\n        \\n        // Check if the graph is bipartite using the checkBipartite function\\n        if (!checkBipartite(n, adj)) return -1;  // Return -1 if graph is not bipartite\\n        \\n        // Calculate the farthest node distance for each node using the findFarthestDistBFS function\\n        vector<int> dist(n + 1, 0);  // Array to store farthest distances\\n        for (int i = 1; i <= n; i++)\\n        {\\n            dist[i] = findFarthestDistBFS(i, n, adj);  // Calculate and store distance\\n        }\\n        \\n        // For multiple components, count the maximum number of groups\\n        vector<int> vist(n + 1, 0);  // Array to mark visited nodes\\n        int maxi = 0;  // Initialize the maximum number of groups\\n        \\n        // Iterate through all nodes and find groups using dfsForComponents function\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (vist[i] == 0)  // If the node is not visited\\n            {\\n                // Update the maximum groups count by exploring the component\\n                maxi += dfsForComponents(i, adj, vist, dist);\\n            }\\n        }\\n        return maxi;  // Return the maximum number of groups\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    // Function for checking whether a graph component is bipartite or not (for disconnected graph)\\n    bool bipartite(int src, vector<int> adj[], int color[])\\n    {\\n        queue<int> q;  // Create a queue for BFS traversal\\n        q.push(src);  // Push the source node into the queue\\n        color[src] = 1;  // Mark the color of the source node as 1 (arbitrary initial color)\\n        \\n        // Start BFS traversal\\n        while (!q.empty())\\n        {\\n            int node = q.front();  // Get the front node from the queue\\n            q.pop();  // Remove the front node\\n            \\n            // Iterate through all neighbors of the current node\\n            for (auto it : adj[node])\\n            {\\n                if (color[it] == -1)  // If the adjacent node is uncolored\\n                {\\n                    color[it] = 1 - color[node];  // Assign opposite color (0 or 1)\\n                    q.push(it);  // Push the adjacent node into the queue\\n                }\\n                else if (color[it] == color[node])  // If adjacent node has the same color\\n                    return false;  // The graph is not bipartite\\n            }\\n        }\\n        return true;  // The graph component is bipartite\\n    }\\n    \\n    // Function for checking whether a graph is bipartite or not\\n    bool checkBipartite(int &n, vector<int> adj[])\\n    {\\n        int color[n + 1];  // Array to store colors of nodes\\n        memset(color, -1, sizeof color);  // Initialize all colors to -1 (uncolored)\\n        \\n        // Iterate through all nodes\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (color[i] == -1)  // If the node is uncolored\\n            {\\n                // Check if the connected component is bipartite using bipartite function\\n                if (!bipartite(i, adj, color))\\n                    return false;  // The graph is not bipartite\\n            }\\n        }\\n        return true;  // The entire graph is bipartite\\n    }\\n    \\n    // Function for finding distance of farthest node from the current node\\n    // To get the maximum number of groups\\n    int findFarthestDistBFS(int src, int n, vector<int> adj[])\\n    {\\n        vector<int> vis(n + 1, 0);  // Array to mark visited nodes\\n        int cnt = 0;  // Initialize a count for nodes\\n        \\n        queue<int> q;  // Create a queue for BFS traversal\\n        q.push(src);  // Push the source node into the queue\\n        vis[src] = 1;  // Mark the source node as visited\\n        \\n        // Start BFS traversal\\n        while (!q.empty())\\n        {\\n            int sz = q.size();  // Get the current size of the queue (nodes in the same level)\\n            cnt++;  // Increment the count for nodes in this level\\n            \\n            // Process nodes in the current level\\n            for (int i = 0; i < sz; i++)\\n            {\\n                int node = q.front();  // Get the front node from the queue\\n                q.pop();  // Remove the front node\\n                \\n                // Iterate through all neighbors of the current node\\n                for (auto it : adj[node])\\n                {\\n                    if (!vis[it])  // If the neighbor is not visited\\n                    {\\n                        q.push(it);  // Push the neighbor into the queue\\n                        vis[it] = 1;  // Mark the neighbor as visited\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;  // Return the count of nodes in the farthest reachable component\\n    }\\n    \\n    // For finding maximum groups of multiple components of a graph\\n    int dfsForComponents(int node, vector<int> adj[], vector<int> &vist, vector<int> &dist)\\n    {\\n        vist[node] = 1;  // Mark the current node as visited\\n        int maxi = dist[node];  // Initialize maximum distance with the node\\'s distance\\n        \\n        // Iterate through all neighbors of the current node\\n        for (auto it : adj[node])\\n        {\\n            if (!vist[it])  // If the neighbor is not visited\\n            {\\n                // Recursively explore the neighbor and update the maximum distance\\n                maxi = max(maxi, dfsForComponents(it, adj, vist, dist));\\n            }\\n        }\\n        return maxi;  // Return the maximum distance within the component\\n    }\\n    \\n    // Given function to find the maximum number of \"magnificent sets\"\\n    int magnificentSets(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> adj[n + 1];  // Create an adjacency list for the graph\\n        \\n        // Fill the adjacency list based on the given edges\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);  // Add edge from node 0 to node 1\\n            adj[edges[i][1]].push_back(edges[i][0]);  // Add edge from node 1 to node 0\\n        }\\n        \\n        // Check if the graph is bipartite using the checkBipartite function\\n        if (!checkBipartite(n, adj)) return -1;  // Return -1 if graph is not bipartite\\n        \\n        // Calculate the farthest node distance for each node using the findFarthestDistBFS function\\n        vector<int> dist(n + 1, 0);  // Array to store farthest distances\\n        for (int i = 1; i <= n; i++)\\n        {\\n            dist[i] = findFarthestDistBFS(i, n, adj);  // Calculate and store distance\\n        }\\n        \\n        // For multiple components, count the maximum number of groups\\n        vector<int> vist(n + 1, 0);  // Array to mark visited nodes\\n        int maxi = 0;  // Initialize the maximum number of groups\\n        \\n        // Iterate through all nodes and find groups using dfsForComponents function\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (vist[i] == 0)  // If the node is not visited\\n            {\\n                // Update the maximum groups count by exploring the component\\n                maxi += dfsForComponents(i, adj, vist, dist);\\n            }\\n        }\\n        return maxi;  // Return the maximum number of groups\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970388,
                "title": "commented-bfs-dfs-bipartite",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> adj[505];  // Adjacency list for the graph\\n    int col[505];  // Array to store vertex colors\\n    int dis[505][505];  // 2D array to store minimum distances between nodes\\n    bool flag;  // Flag to determine bipartiteness\\n    vector<int> kara;  // Vector to store nodes in a connected graph\\n    \\n    void dfs(int u, int c = 1) {\\n        col[u] = c;  // Assign the color to the current vertex\\n        kara.push_back(u);  // Store the current vertex in the connected component\\n        for (int &v : adj[u]) {\\n            if (!col[v])\\n                dfs(v, 3 - c);  // Call DFS recursively with the opposite color\\n            else if (col[v] == c)\\n                flag = 0;  // If the adjacent vertex has the same color, the graph is not bipartite\\n        }\\n    }\\n    \\n    void bfs(int src) {\\n        for (int i = 1; i <= 500; i++)\\n            dis[src][i] = 100001;  // Initialize minimum distances to a large value\\n        dis[src][src] = 1;  // The distance from a node to itself is 1\\n        queue<int> q;\\n        q.push(src);\\n        while (q.size()) {\\n            auto u = q.front();\\n            q.pop();\\n            for (int &v : adj[u]) {\\n                if (dis[src][v] > dis[src][u] + 1) {\\n                    dis[src][v] = dis[src][u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        for (int i = 1; i <= n; i++)\\n            adj[i].clear();  // Clear the adjacency list\\n        \\n        memset(col, 0, sizeof col);  // Initialize the color array with zeros\\n        \\n        for (auto &e : edges) {\\n            adj[e[0]].push_back(e[1]);  // Build the adjacency list based on edges\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        for (int i = 1; i <= n; i++)\\n            bfs(i);  // Calculate minimum distances between nodes\\n        \\n        int ans = 0;  // Initialize the answer variable\\n        int in = 0;  // Count of connected components\\n        \\n        for (int i = 1; i <= n; i++) {\\n            if (col[i] == 0) {  // If the vertex hasn\\'t been visited yet\\n                kara.clear();  // Clear the connected component vector\\n                flag = 1;  // Reset the bipartite flag\\n                in++;  // Increment the connected component count\\n                dfs(i);  // Call DFS to analyze the connected component\\n                \\n                if (!flag)\\n                    return -1;  // If the connected component is not bipartite, return -1\\n                \\n                int mxdis = 0;  // Initialize the maximum distance within the component\\n                \\n                // Calculate the maximum distance between nodes within the connected component\\n                for (int &i : kara) {\\n                    for (int &j : kara) {\\n                        mxdis = max(mxdis, dis[i][j]);\\n                    }\\n                }\\n                \\n                ans += mxdis;  // Add the maximum distance to the answer\\n            }\\n        }\\n        \\n        return ans;  // Return the final answer\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[505];  // Adjacency list for the graph\\n    int col[505];  // Array to store vertex colors\\n    int dis[505][505];  // 2D array to store minimum distances between nodes\\n    bool flag;  // Flag to determine bipartiteness\\n    vector<int> kara;  // Vector to store nodes in a connected graph\\n    \\n    void dfs(int u, int c = 1) {\\n        col[u] = c;  // Assign the color to the current vertex\\n        kara.push_back(u);  // Store the current vertex in the connected component\\n        for (int &v : adj[u]) {\\n            if (!col[v])\\n                dfs(v, 3 - c);  // Call DFS recursively with the opposite color\\n            else if (col[v] == c)\\n                flag = 0;  // If the adjacent vertex has the same color, the graph is not bipartite\\n        }\\n    }\\n    \\n    void bfs(int src) {\\n        for (int i = 1; i <= 500; i++)\\n            dis[src][i] = 100001;  // Initialize minimum distances to a large value\\n        dis[src][src] = 1;  // The distance from a node to itself is 1\\n        queue<int> q;\\n        q.push(src);\\n        while (q.size()) {\\n            auto u = q.front();\\n            q.pop();\\n            for (int &v : adj[u]) {\\n                if (dis[src][v] > dis[src][u] + 1) {\\n                    dis[src][v] = dis[src][u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        for (int i = 1; i <= n; i++)\\n            adj[i].clear();  // Clear the adjacency list\\n        \\n        memset(col, 0, sizeof col);  // Initialize the color array with zeros\\n        \\n        for (auto &e : edges) {\\n            adj[e[0]].push_back(e[1]);  // Build the adjacency list based on edges\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        for (int i = 1; i <= n; i++)\\n            bfs(i);  // Calculate minimum distances between nodes\\n        \\n        int ans = 0;  // Initialize the answer variable\\n        int in = 0;  // Count of connected components\\n        \\n        for (int i = 1; i <= n; i++) {\\n            if (col[i] == 0) {  // If the vertex hasn\\'t been visited yet\\n                kara.clear();  // Clear the connected component vector\\n                flag = 1;  // Reset the bipartite flag\\n                in++;  // Increment the connected component count\\n                dfs(i);  // Call DFS to analyze the connected component\\n                \\n                if (!flag)\\n                    return -1;  // If the connected component is not bipartite, return -1\\n                \\n                int mxdis = 0;  // Initialize the maximum distance within the component\\n                \\n                // Calculate the maximum distance between nodes within the connected component\\n                for (int &i : kara) {\\n                    for (int &j : kara) {\\n                        mxdis = max(mxdis, dis[i][j]);\\n                    }\\n                }\\n                \\n                ans += mxdis;  // Add the maximum distance to the answer\\n            }\\n        }\\n        \\n        return ans;  // Return the final answer\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924509,
                "title": "python-solution-dfs-bfs-beats-100-of-the-users",
                "content": "# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges:\\n            graph[u - 1].append(v - 1)\\n            graph[v - 1].append(u - 1)\\n\\n        seen = [0] * n\\n        groups = []\\n\\n        # DFS to assign and validate groups\\n        for i in range(n):\\n            if not seen[i]:\\n                seen[i] = 1\\n                stack = [i]\\n                component = [i]\\n                while stack:\\n                    u = stack.pop()\\n                    for v in graph[u]:\\n                        if not seen[v]:\\n                            seen[v] = seen[u] + 1\\n                            stack.append(v)\\n                            component.append(v)\\n                        elif (seen[u] & 1) == (seen[v] & 1):\\n                            return -1\\n                groups.append(component)\\n\\n        # BFS function to find maximum number of groups from a node\\n        def bfs(x):\\n            ans = 0\\n            seen = [False] * n\\n            seen[x] = True\\n            q = deque([x])\\n            while q:\\n                ans += 1\\n                for _ in range(len(q)):\\n                    u = q.popleft()\\n                    for v in graph[u]:\\n                        if not seen[v]:\\n                            seen[v] = True\\n                            q.append(v)\\n            return ans\\n\\n        # Apply BFS to all nodes in each connected component\\n        ans = 0\\n        for group in groups:\\n            group = [bfs(x) for x in group]\\n            ans += max(group)\\n\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges:\\n            graph[u - 1].append(v - 1)\\n            graph[v - 1].append(u - 1)\\n\\n        seen = [0] * n\\n        groups = []\\n\\n        # DFS to assign and validate groups\\n        for i in range(n):\\n            if not seen[i]:\\n                seen[i] = 1\\n                stack = [i]\\n                component = [i]\\n                while stack:\\n                    u = stack.pop()\\n                    for v in graph[u]:\\n                        if not seen[v]:\\n                            seen[v] = seen[u] + 1\\n                            stack.append(v)\\n                            component.append(v)\\n                        elif (seen[u] & 1) == (seen[v] & 1):\\n                            return -1\\n                groups.append(component)\\n\\n        # BFS function to find maximum number of groups from a node\\n        def bfs(x):\\n            ans = 0\\n            seen = [False] * n\\n            seen[x] = True\\n            q = deque([x])\\n            while q:\\n                ans += 1\\n                for _ in range(len(q)):\\n                    u = q.popleft()\\n                    for v in graph[u]:\\n                        if not seen[v]:\\n                            seen[v] = True\\n                            q.append(v)\\n            return ans\\n\\n        # Apply BFS to all nodes in each connected component\\n        ans = 0\\n        for group in groups:\\n            group = [bfs(x) for x in group]\\n            ans += max(group)\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889196,
                "title": "java-bipartite-check-and-find-max-height",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    List<Integer>[] graph;\\n    int N;\\n\\n    public int magnificentSets(int n, int[][] edges) {\\n        \\n        N = n;\\n        graph = new ArrayList[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            e[0]--;\\n            e[1]--;\\n            if (e[0] == e[1]) {\\n                return -1;\\n            }\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n\\n        /*\\n        int[] g = new int[n];\\n        boolean[] visited = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            Queue<Integer> q = new LinkedList<>();\\n            g[i] = 1;\\n            q.add(0);\\n            while ( ! q.isEmpty()) {\\n                int c = q.poll();\\n                visited[c] = true;\\n                int targetColor = (g[c] == 1) ? 2 : 1;\\n                for (int v : graph[c]) {\\n                    if (g[v] == 0) {\\n                        g[v] = targetColor;\\n                        q.add(v);\\n                    } else if (g[v] != targetColor) {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        */\\n\\n        int[] subgroups = new int[n];\\n        int[] subgroupresults = new int[n+1];\\n        int currentgroup = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (subgroups[i] == 0) {\\n                subgroups[i] = currentgroup;\\n                currentgroup++;\\n            }\\n            int currentRes = getMax(i, subgroups);\\n            if (currentRes == -1) {\\n                return -1;\\n            }\\n            subgroupresults[subgroups[i]] = Math.max(subgroupresults[subgroups[i]], currentRes);\\n        }\\n\\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            res += subgroupresults[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    public int getMax(int v, int[] subgroups) {\\n        int subGroup = subgroups[v];\\n\\n        int[] g = new int[N];\\n\\n        boolean[] visited = new boolean[N];\\n        int level = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(v);\\n        g[v] = 1;\\n        visited[v] = true;\\n        \\n        while ( ! q.isEmpty()) {\\n            level++;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int c = q.poll();\\n                int targetColor = (g[c] == 1) ? 2 : 1;\\n                for (int u : graph[c]) {\\n                    if (visited[u]) {\\n                        if (g[u] != targetColor) {\\n                            return -1;\\n                        }\\n                        continue;\\n                    }\\n                    visited[u] = true;\\n                    g[u] = targetColor;\\n                    subgroups[u] = subGroup;\\n                    q.add(u);\\n                }\\n            }\\n            \\n        }\\n        return level;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    List<Integer>[] graph;\\n    int N;\\n\\n    public int magnificentSets(int n, int[][] edges) {\\n        \\n        N = n;\\n        graph = new ArrayList[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            e[0]--;\\n            e[1]--;\\n            if (e[0] == e[1]) {\\n                return -1;\\n            }\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n\\n        /*\\n        int[] g = new int[n];\\n        boolean[] visited = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            Queue<Integer> q = new LinkedList<>();\\n            g[i] = 1;\\n            q.add(0);\\n            while ( ! q.isEmpty()) {\\n                int c = q.poll();\\n                visited[c] = true;\\n                int targetColor = (g[c] == 1) ? 2 : 1;\\n                for (int v : graph[c]) {\\n                    if (g[v] == 0) {\\n                        g[v] = targetColor;\\n                        q.add(v);\\n                    } else if (g[v] != targetColor) {\\n                        return -1;\\n                    }\\n                }\\n            }\\n        }\\n        */\\n\\n        int[] subgroups = new int[n];\\n        int[] subgroupresults = new int[n+1];\\n        int currentgroup = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (subgroups[i] == 0) {\\n                subgroups[i] = currentgroup;\\n                currentgroup++;\\n            }\\n            int currentRes = getMax(i, subgroups);\\n            if (currentRes == -1) {\\n                return -1;\\n            }\\n            subgroupresults[subgroups[i]] = Math.max(subgroupresults[subgroups[i]], currentRes);\\n        }\\n\\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            res += subgroupresults[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    public int getMax(int v, int[] subgroups) {\\n        int subGroup = subgroups[v];\\n\\n        int[] g = new int[N];\\n\\n        boolean[] visited = new boolean[N];\\n        int level = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(v);\\n        g[v] = 1;\\n        visited[v] = true;\\n        \\n        while ( ! q.isEmpty()) {\\n            level++;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int c = q.poll();\\n                int targetColor = (g[c] == 1) ? 2 : 1;\\n                for (int u : graph[c]) {\\n                    if (visited[u]) {\\n                        if (g[u] != targetColor) {\\n                            return -1;\\n                        }\\n                        continue;\\n                    }\\n                    visited[u] = true;\\n                    g[u] = targetColor;\\n                    subgroups[u] = subGroup;\\n                    q.add(u);\\n                }\\n            }\\n            \\n        }\\n        return level;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845008,
                "title": "dfs-find-distinct-components-then-bfs-to-find-the-number-of-levels-per-component",
                "content": "# Intuition\\nWe need to represent the graph in levels where no direct connection exist between any two nodes in the same levels.\\n\\nThe problem would have been easy to solve with topological sort (kahn\\'s algorithm) if the graph was directed, but that\\'s not the case.\\n\\nTo find the number of levels in a graph we can easily use BFS to count the levels. But in our problem the graph could consist of multiple disconnected components. So we have to construct these components first, then BFS on each to find the number of levels in each component.\\n\\n# Approach\\n1. construct a bi-directional graph \\n2. Find all disconnected components (dfs starting at each unvisited node)\\n3. For each component: BFS to find the max levels starting at every node\\n    - if any of the components returns a -1, meaning there has to be two directly connected nodes in one level, then the whole graph is invalid\\n    - sum the number of levels/groups from each single component to return the final answer\\n\\n# Complexity\\n- Time complexity:\\n    - constructing the graph takes $$O(n)$$\\n    - finding the components also takes $$O(n)$$\\n    - finding the level we iterate on C components, each having N/C nodes, from each node we will do a bfs each of $$O(N/C)$$, so in total it would be $$O(C* N^2/C^2)$$. if C is 1, that would be $$O(n^2)$$\\n\\n- Space complexity:\\n $$O(n+e)$$\\n\\n# Code\\n```java\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int n;\\n\\n    public int magnificentSets(int n, int[][] edges) {\\n        graph = new HashMap<>();\\n        this.n = n;\\n\\n        // construct a bi-directional graph\\n        for (int[] edge : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            graph.computeIfAbsent(a, k -> new ArrayList<>()).add(b);\\n            graph.computeIfAbsent(b, k -> new ArrayList<>()).add(a);\\n        }\\n\\n        // get all connected components, the graph could be disconnected\\n        List<List<Integer>> components = getComponents();\\n\\n        // for each component: find the max levels starting at every node\\n        // if any of the components returns a -1, meaning there has to be two directly connected nodes in one level, then the whole graph is invalid\\n        // sum the number of levels/groups from each single component to return the final answer\\n        int maxGroups = 0;\\n        for (List<Integer> component : components) {\\n            int groups = -1;\\n            for (int node : component) {\\n                // bfs to find the number of level starting at this node\\n                int numLevels = bfs(node);\\n                groups = Math.max(groups, numLevels);\\n            }\\n\\n            if (groups == -1) {\\n                return -1;\\n            }\\n\\n            maxGroups += groups;\\n        }\\n\\n        return maxGroups;\\n    }\\n\\n    private List<List<Integer>> getComponents() {\\n        boolean[] visited = new boolean[n + 1];\\n        List<List<Integer>> components = new ArrayList<>();\\n        for (int i = 1; i < n + 1; i++) {\\n            if (!visited[i]) {\\n                // dfs to get all node belonging to one component\\n                List<Integer> component = visit(i, new ArrayList<>(), visited);\\n                components.add(component);\\n            }\\n        }\\n        return components;\\n    }\\n\\n    private List<Integer> visit(int curr, List<Integer> nodes, boolean[] visited) {\\n        visited[curr] = true;\\n        nodes.add(curr);\\n        for (int next : graph.getOrDefault(curr, new ArrayList<>())) {\\n            if (visited[next]) continue;\\n            visit(next, nodes, visited);\\n        }\\n\\n        return nodes;\\n    }\\n\\n    private int bfs(int node) {\\n        Node[] visited = new Node[n + 1];\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        Node n = new Node(node, 1);\\n        queue.offer(n);\\n        visited[node] = n;\\n\\n        int level = 1;\\n        while (!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            level = curr.level;\\n            for (int neighbor : graph.getOrDefault(curr.id, new ArrayList<>())) {\\n                if (visited[neighbor] == null) {\\n                    Node nei = new Node(neighbor, curr.level + 1);\\n                    queue.offer(nei);\\n                    visited[neighbor] = nei;\\n                } else if (visited[neighbor].level == curr.level) {\\n                    // if the neighbor has been seen in the same level as the current node, it means there has to be a direct connection at this level; marking the graph invalid\\n                    return -1;\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n\\n    static class Node {\\n        int id;\\n        int level;\\n\\n        public Node(int id, int level) {\\n            this.id = id;\\n            this.level = level;\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```java\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int n;\\n\\n    public int magnificentSets(int n, int[][] edges) {\\n        graph = new HashMap<>();\\n        this.n = n;\\n\\n        // construct a bi-directional graph\\n        for (int[] edge : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            graph.computeIfAbsent(a, k -> new ArrayList<>()).add(b);\\n            graph.computeIfAbsent(b, k -> new ArrayList<>()).add(a);\\n        }\\n\\n        // get all connected components, the graph could be disconnected\\n        List<List<Integer>> components = getComponents();\\n\\n        // for each component: find the max levels starting at every node\\n        // if any of the components returns a -1, meaning there has to be two directly connected nodes in one level, then the whole graph is invalid\\n        // sum the number of levels/groups from each single component to return the final answer\\n        int maxGroups = 0;\\n        for (List<Integer> component : components) {\\n            int groups = -1;\\n            for (int node : component) {\\n                // bfs to find the number of level starting at this node\\n                int numLevels = bfs(node);\\n                groups = Math.max(groups, numLevels);\\n            }\\n\\n            if (groups == -1) {\\n                return -1;\\n            }\\n\\n            maxGroups += groups;\\n        }\\n\\n        return maxGroups;\\n    }\\n\\n    private List<List<Integer>> getComponents() {\\n        boolean[] visited = new boolean[n + 1];\\n        List<List<Integer>> components = new ArrayList<>();\\n        for (int i = 1; i < n + 1; i++) {\\n            if (!visited[i]) {\\n                // dfs to get all node belonging to one component\\n                List<Integer> component = visit(i, new ArrayList<>(), visited);\\n                components.add(component);\\n            }\\n        }\\n        return components;\\n    }\\n\\n    private List<Integer> visit(int curr, List<Integer> nodes, boolean[] visited) {\\n        visited[curr] = true;\\n        nodes.add(curr);\\n        for (int next : graph.getOrDefault(curr, new ArrayList<>())) {\\n            if (visited[next]) continue;\\n            visit(next, nodes, visited);\\n        }\\n\\n        return nodes;\\n    }\\n\\n    private int bfs(int node) {\\n        Node[] visited = new Node[n + 1];\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        Node n = new Node(node, 1);\\n        queue.offer(n);\\n        visited[node] = n;\\n\\n        int level = 1;\\n        while (!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            level = curr.level;\\n            for (int neighbor : graph.getOrDefault(curr.id, new ArrayList<>())) {\\n                if (visited[neighbor] == null) {\\n                    Node nei = new Node(neighbor, curr.level + 1);\\n                    queue.offer(nei);\\n                    visited[neighbor] = nei;\\n                } else if (visited[neighbor].level == curr.level) {\\n                    // if the neighbor has been seen in the same level as the current node, it means there has to be a direct connection at this level; marking the graph invalid\\n                    return -1;\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n\\n    static class Node {\\n        int id;\\n        int level;\\n\\n        public Node(int id, int level) {\\n            this.id = id;\\n            this.level = level;\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792562,
                "title": "efficient-js-solution-beats-100-both-time-and-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/c83b7151-6ca6-484c-8c2b-16a315825abb_1689858409.8385575.png)\\n\\n# Intuition\\nBFS on every single node of the graph.\\n\\n# Approach\\nTo optimize memory, I store components of the graph by using a value `component[i]` corresponds to a node `i`. The value is defined as below:\\n- **`undefined`**: means the component of the node `i` is unknown.\\n- **A non-negative number X**: means the root node of the component which contains `i` is `X`, note that `X !== i`.\\n- **A negative number X**: means the root node of the component which contains `i` is `i` itself, and the max depth found in this component so far is `-X`.\\n- **`null`**: means the root node of the component which contains `i` is `i` itself, and there is no valid grouping strategy has been found for the component.\\n\\nAlso, I used **Circular Queue**. :)\\n\\n# Complexity\\n- Time complexity: $$O(n * (n + m))$$\\n- Space complexity: $$O(n + m)$$\\n\\n# Code\\n```jsx\\n/**\\n * @template TItem\\n */\\nclass CircularQueue {\\n  /**\\n   * @param {number} capacity\\n   */\\n  constructor(capacity) {\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._capacity = capacity;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._size = 0;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._bottom = 0;\\n\\n    /**\\n     * @private\\n     * @type {TItem[]}\\n     */\\n    this._data = Array(capacity).fill(undefined);\\n  }\\n\\n  get size() {\\n    return this._size;\\n  }\\n\\n  /**\\n   * @param  {...TItem} items\\n   */\\n  enqueue(...items) {\\n    if (this._size + items.length > this._capacity) throw new Error(\"Queue capacity exceeded.\");\\n\\n    let queueIndex = (this._bottom + this._size) % this._capacity;\\n    this._size += items.length;\\n    for (let i = 0; i < items.length; i++) {\\n      this._data[queueIndex] = items[i];\\n      queueIndex = (queueIndex + 1) % this._capacity;\\n    }\\n  }\\n\\n  /**\\n   * @returns {TItem | undefined}\\n   */\\n  dequeue() {\\n    if (!this._size) return undefined;\\n\\n    const result = this._data[this._bottom];\\n    this._bottom = (this._bottom + 1) % this._capacity;\\n    this._size--;\\n\\n    return result;\\n  }\\n\\n  clear() {\\n    this._size = 0;\\n  }\\n}\\n\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar magnificentSets = function (n, edges) {\\n  let result = 0;\\n  let component = Array(n).fill(undefined);\\n\\n  let graph = [];\\n  for (let i = 0; i < n; i++) graph.push([]);\\n  for (let edge of edges) {\\n    graph[edge[0] - 1].push(edge[1] - 1);\\n    graph[edge[1] - 1].push(edge[0] - 1);\\n  }\\n\\n  let q = new CircularQueue(n);\\n  let visited = Array(n);\\n\\n  function bfs(src) {\\n    q.clear();\\n    visited.fill(0);\\n    q.enqueue(src);\\n    visited[src] = 1;\\n    let flagFailed = false;\\n\\n    if (component[src] === undefined) component[src] = null;\\n    let cur;\\n    while (q.size) {\\n      cur = q.dequeue();\\n      if (component[cur] === undefined) component[cur] = src;\\n\\n      for (let nex of graph[cur]) {\\n        if (!visited[nex]) {\\n          visited[nex] = visited[cur] + 1;\\n          q.enqueue(nex);\\n        } else {\\n          if (Math.abs(visited[cur] - visited[nex]) !== 1) {\\n            flagFailed = true;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (cur === src) {\\n      component[src] = -1;\\n      return;\\n    }\\n\\n    if (flagFailed) return;\\n\\n    const componentId = component[cur];\\n\\n    if (component[componentId] === null || visited[cur] > -component[componentId]) {\\n      component[componentId] = -visited[cur];\\n    }\\n  }\\n\\n  for (let i = 0; i < n; i++) bfs(i);\\n\\n  for (let i = 0; i < n; i++) {\\n    if (component[i] === null) return -1;\\n    if (component[i] < 0) result -= component[i];\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```jsx\\n/**\\n * @template TItem\\n */\\nclass CircularQueue {\\n  /**\\n   * @param {number} capacity\\n   */\\n  constructor(capacity) {\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._capacity = capacity;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._size = 0;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._bottom = 0;\\n\\n    /**\\n     * @private\\n     * @type {TItem[]}\\n     */\\n    this._data = Array(capacity).fill(undefined);\\n  }\\n\\n  get size() {\\n    return this._size;\\n  }\\n\\n  /**\\n   * @param  {...TItem} items\\n   */\\n  enqueue(...items) {\\n    if (this._size + items.length > this._capacity) throw new Error(\"Queue capacity exceeded.\");\\n\\n    let queueIndex = (this._bottom + this._size) % this._capacity;\\n    this._size += items.length;\\n    for (let i = 0; i < items.length; i++) {\\n      this._data[queueIndex] = items[i];\\n      queueIndex = (queueIndex + 1) % this._capacity;\\n    }\\n  }\\n\\n  /**\\n   * @returns {TItem | undefined}\\n   */\\n  dequeue() {\\n    if (!this._size) return undefined;\\n\\n    const result = this._data[this._bottom];\\n    this._bottom = (this._bottom + 1) % this._capacity;\\n    this._size--;\\n\\n    return result;\\n  }\\n\\n  clear() {\\n    this._size = 0;\\n  }\\n}\\n\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar magnificentSets = function (n, edges) {\\n  let result = 0;\\n  let component = Array(n).fill(undefined);\\n\\n  let graph = [];\\n  for (let i = 0; i < n; i++) graph.push([]);\\n  for (let edge of edges) {\\n    graph[edge[0] - 1].push(edge[1] - 1);\\n    graph[edge[1] - 1].push(edge[0] - 1);\\n  }\\n\\n  let q = new CircularQueue(n);\\n  let visited = Array(n);\\n\\n  function bfs(src) {\\n    q.clear();\\n    visited.fill(0);\\n    q.enqueue(src);\\n    visited[src] = 1;\\n    let flagFailed = false;\\n\\n    if (component[src] === undefined) component[src] = null;\\n    let cur;\\n    while (q.size) {\\n      cur = q.dequeue();\\n      if (component[cur] === undefined) component[cur] = src;\\n\\n      for (let nex of graph[cur]) {\\n        if (!visited[nex]) {\\n          visited[nex] = visited[cur] + 1;\\n          q.enqueue(nex);\\n        } else {\\n          if (Math.abs(visited[cur] - visited[nex]) !== 1) {\\n            flagFailed = true;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (cur === src) {\\n      component[src] = -1;\\n      return;\\n    }\\n\\n    if (flagFailed) return;\\n\\n    const componentId = component[cur];\\n\\n    if (component[componentId] === null || visited[cur] > -component[componentId]) {\\n      component[componentId] = -visited[cur];\\n    }\\n  }\\n\\n  for (let i = 0; i < n; i++) bfs(i);\\n\\n  for (let i = 0; i < n; i++) {\\n    if (component[i] === null) return -1;\\n    if (component[i] < 0) result -= component[i];\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712071,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool biPartite(int node, int col, vector<int>&color, vector<int>adj[]){\\n        color[node]=col;\\n        for(auto it: adj[node]){\\n            if(color[it]==-1){\\n                if(biPartite(it, !col, color, adj)==false){\\n                    return false;\\n                }\\n            }\\n            else if(color[it]==col){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int computeLevel(int node, vector<int>adj[], int n){\\n        vector<int>vis(n, 0);\\n        queue<int>qq;\\n        vis[node]=1;\\n        qq.push(node);\\n        \\n       int level=0;\\n        while(!qq.empty()){\\n            int size=qq.size();\\n           \\n            for(int i=0; i<size; i++){\\n                int node=qq.front();\\n                qq.pop();\\n               \\n                for(auto it:adj[node]){\\n                   if(vis[it]==0){\\n                       vis[it]=1;\\n                       qq.push(it);\\n                       \\n                   }\\n                }\\n                \\n            }\\n            level++;  \\n        }\\n        return level;\\n    }\\n    \\n    \\n    int computeMax(int node, vector<int>&vis, vector<int>adj[]){\\n       int maxi=INT_MIN;\\n        vis[node]=1;\\n        int n=vis.size();\\n        vector<int>cur;\\n        cur.push_back(node);\\n       maxi=max(maxi,computeLevel(node, adj,n));\\n        while(true){\\n            vector<int>temp;\\n            for(int i=0; i<cur.size(); i++){\\n                for(auto it: adj[cur[i]]){\\n                    if(vis[it]==0){\\n                        vis[it]=1;\\n                        temp.push_back(it);\\n                        maxi=max(maxi, computeLevel(it, adj, n));\\n                    }\\n                }\\n            }\\n            if(temp.size()==0){\\n                break;\\n            }\\n            cur=temp;\\n        }\\n        return maxi;\\n    }\\n    \\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n      \\n       vector<int>adj[n+1];\\n        for(auto it: edges){\\n            int u=it[0];\\n            int v=it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int>color(n+1, -1);\\n        for(int i=1; i<=n; i++){\\n             if(color[i]==-1){\\n                 if(biPartite(i, 0, color, adj)==false){\\n                    return -1;\\n                 }\\n             }\\n            \\n        }\\n        \\n        int maxGroup=0;\\n        vector<int>vis(n+1, 0);\\n        for(int i=1; i<=n; i++){\\n             if(vis[i]==0){\\n               maxGroup+=computeMax(i, vis, adj);\\n             }\\n        }\\n        return maxGroup;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool biPartite(int node, int col, vector<int>&color, vector<int>adj[]){\\n        color[node]=col;\\n        for(auto it: adj[node]){\\n            if(color[it]==-1){\\n                if(biPartite(it, !col, color, adj)==false){\\n                    return false;\\n                }\\n            }\\n            else if(color[it]==col){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int computeLevel(int node, vector<int>adj[], int n){\\n        vector<int>vis(n, 0);\\n        queue<int>qq;\\n        vis[node]=1;\\n        qq.push(node);\\n        \\n       int level=0;\\n        while(!qq.empty()){\\n            int size=qq.size();\\n           \\n            for(int i=0; i<size; i++){\\n                int node=qq.front();\\n                qq.pop();\\n               \\n                for(auto it:adj[node]){\\n                   if(vis[it]==0){\\n                       vis[it]=1;\\n                       qq.push(it);\\n                       \\n                   }\\n                }\\n                \\n            }\\n            level++;  \\n        }\\n        return level;\\n    }\\n    \\n    \\n    int computeMax(int node, vector<int>&vis, vector<int>adj[]){\\n       int maxi=INT_MIN;\\n        vis[node]=1;\\n        int n=vis.size();\\n        vector<int>cur;\\n        cur.push_back(node);\\n       maxi=max(maxi,computeLevel(node, adj,n));\\n        while(true){\\n            vector<int>temp;\\n            for(int i=0; i<cur.size(); i++){\\n                for(auto it: adj[cur[i]]){\\n                    if(vis[it]==0){\\n                        vis[it]=1;\\n                        temp.push_back(it);\\n                        maxi=max(maxi, computeLevel(it, adj, n));\\n                    }\\n                }\\n            }\\n            if(temp.size()==0){\\n                break;\\n            }\\n            cur=temp;\\n        }\\n        return maxi;\\n    }\\n    \\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n      \\n       vector<int>adj[n+1];\\n        for(auto it: edges){\\n            int u=it[0];\\n            int v=it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int>color(n+1, -1);\\n        for(int i=1; i<=n; i++){\\n             if(color[i]==-1){\\n                 if(biPartite(i, 0, color, adj)==false){\\n                    return -1;\\n                 }\\n             }\\n            \\n        }\\n        \\n        int maxGroup=0;\\n        vector<int>vis(n+1, 0);\\n        for(int i=1; i<=n; i++){\\n             if(vis[i]==0){\\n               maxGroup+=computeMax(i, vis, adj);\\n             }\\n        }\\n        return maxGroup;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582178,
                "title": "solution",
                "content": "\\n# Code\\n```\\nfrom collections import deque \\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        res = 0\\n        E = build_edges(edges)\\n        max_distances = {}\\n        for i in range(1, n+1):\\n            max_distance = bfs(i, E, n)\\n            if max_distance:\\n                max_distances[i] = max_distance\\n            else:\\n                return -1\\n        visited_node = set()\\n        for i in range(1, n+1):\\n            if i not in visited_node:\\n                res += dfs(i, E, visited_node, max_distances)\\n\\n        return res\\n\\ndef dfs(i, E, visited_node, max_distances):\\n    visited_node.add(i)\\n    res = max_distances[i]\\n    for v in E.get(i, []):\\n        if v not in visited_node:\\n            res = max(res, dfs(v, E, visited_node, max_distances))\\n    return res\\n\\n\\ndef build_edges(edges):\\n    E = {}\\n    for e in edges:\\n        E.setdefault(e[0], []).append(e[1])\\n        E.setdefault(e[1], []).append(e[0])\\n    return E\\n\\ndef bfs(r, E, n):\\n    my_q = deque()\\n    my_q.append((r, 0))\\n    DIST = {r: 0}\\n\\n    while my_q:\\n        curr_node, cur_dist = my_q.popleft()\\n        for v in E.setdefault(curr_node, []):\\n            if v in DIST:\\n                if (DIST[v] - (cur_dist + 1)) % 2 != 0:\\n                    return None\\n            else:\\n                DIST[v] = cur_dist + 1\\n                my_q.append((v, cur_dist+1))\\n    return cur_dist + 1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque \\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        res = 0\\n        E = build_edges(edges)\\n        max_distances = {}\\n        for i in range(1, n+1):\\n            max_distance = bfs(i, E, n)\\n            if max_distance:\\n                max_distances[i] = max_distance\\n            else:\\n                return -1\\n        visited_node = set()\\n        for i in range(1, n+1):\\n            if i not in visited_node:\\n                res += dfs(i, E, visited_node, max_distances)\\n\\n        return res\\n\\ndef dfs(i, E, visited_node, max_distances):\\n    visited_node.add(i)\\n    res = max_distances[i]\\n    for v in E.get(i, []):\\n        if v not in visited_node:\\n            res = max(res, dfs(v, E, visited_node, max_distances))\\n    return res\\n\\n\\ndef build_edges(edges):\\n    E = {}\\n    for e in edges:\\n        E.setdefault(e[0], []).append(e[1])\\n        E.setdefault(e[1], []).append(e[0])\\n    return E\\n\\ndef bfs(r, E, n):\\n    my_q = deque()\\n    my_q.append((r, 0))\\n    DIST = {r: 0}\\n\\n    while my_q:\\n        curr_node, cur_dist = my_q.popleft()\\n        for v in E.setdefault(curr_node, []):\\n            if v in DIST:\\n                if (DIST[v] - (cur_dist + 1)) % 2 != 0:\\n                    return None\\n            else:\\n                DIST[v] = cur_dist + 1\\n                my_q.append((v, cur_dist+1))\\n    return cur_dist + 1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568131,
                "title": "python-simple-and-hints-related-answer-bipartite-and-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        adj=[[]for i in range(n)]\\n        for a,b in edges:\\n            adj[a-1].append(b-1)\\n            adj[b-1].append(a-1)\\n        dici={}\\n        def isBiPar(node,parent,val):\\n            dici[node]=val\\n            for child in adj[node]:\\n                if child not in dici:\\n                    if not isBiPar(child,node,val^1):\\n                        return False\\n                elif child!=parent:\\n                    if dici[child]==val:\\n                        return False\\n            return True\\n\\n        tempvis=set()\\n        def bfs(nod):\\n            q=Queue()\\n            q.put(nod)\\n            tempvis.add(nod)\\n            cnt=0\\n            while(q.qsize()>0):\\n                s=q.qsize()\\n                for _ in range(s):\\n                    node=q.get()\\n                    for child in adj[node]:\\n                        if child not in tempvis:\\n                            tempvis.add(child)\\n                            q.put(child)\\n                cnt+=1\\n            return cnt\\n\\n\\n        vis=set()\\n        li=[]\\n        def dfs(node):\\n            li.append(node)\\n            vis.add(node)\\n            for child in adj[node]:\\n                if child not in vis:\\n                    dfs(child)\\n        fans=0\\n        for i in range(n):\\n            if i not in vis:\\n                li=[]\\n                dfs(i)\\n                if not isBiPar(li[0],-1,0):\\n                    return -1\\n                else:\\n                    ans=0\\n                    for j in li:\\n                        tempvis=set()\\n                        ans=max(ans,bfs(j))\\n                    fans+=ans\\n        return fans\\n\\n\\n\\n\\n\\n\\n\\n\\n        # The below code doesnot work because i can not decide whether going right or left which one yields more groups\\n        # dici={}\\n        # ans={}\\n        # def fun(node,parent,ind):\\n        #     dici[node]=ind\\n        #     if ind in ans:\\n        #         ans[ind]+=1\\n        #     else:\\n        #         ans[ind]=1\\n        #     for child in adj[node]:\\n        #         if child not in dici:\\n        #             if not(ind+1 not in ans and  fun(child,node,ind+1)) and not (ind-1 not in ans and fun(child,node,ind-1)) and  not fun(child,node,ind-1) and not fun(child,node,ind+1) :\\n        #                 dici.pop(node)\\n        #                 ans[ind]-=1\\n        #                 if ans[ind]==0:\\n        #                     ans.pop(ind)\\n        #                 return False\\n        #         elif child!=parent:\\n        #             if (dici[child]!=ind+1 and dici[child]!=ind-1):\\n        #                 dici.pop(node)\\n        #                 ans[ind]-=1\\n        #                 if ans[ind]==0:\\n        #                     ans.pop(ind)\\n        #                 return False\\n        #     return True\\n        # for i in range(n):\\n        #     if i not in dici:\\n        #         if not fun(i,-1,i*1000):\\n        #             return -1\\n        # print(ans)\\n        # print(sum(ans.values()))\\n        # return len(ans)\\n\\n\\n    \\n\\n                    \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        adj=[[]for i in range(n)]\\n        for a,b in edges:\\n            adj[a-1].append(b-1)\\n            adj[b-1].append(a-1)\\n        dici={}\\n        def isBiPar(node,parent,val):\\n            dici[node]=val\\n            for child in adj[node]:\\n                if child not in dici:\\n                    if not isBiPar(child,node,val^1):\\n                        return False\\n                elif child!=parent:\\n                    if dici[child]==val:\\n                        return False\\n            return True\\n\\n        tempvis=set()\\n        def bfs(nod):\\n            q=Queue()\\n            q.put(nod)\\n            tempvis.add(nod)\\n            cnt=0\\n            while(q.qsize()>0):\\n                s=q.qsize()\\n                for _ in range(s):\\n                    node=q.get()\\n                    for child in adj[node]:\\n                        if child not in tempvis:\\n                            tempvis.add(child)\\n                            q.put(child)\\n                cnt+=1\\n            return cnt\\n\\n\\n        vis=set()\\n        li=[]\\n        def dfs(node):\\n            li.append(node)\\n            vis.add(node)\\n            for child in adj[node]:\\n                if child not in vis:\\n                    dfs(child)\\n        fans=0\\n        for i in range(n):\\n            if i not in vis:\\n                li=[]\\n                dfs(i)\\n                if not isBiPar(li[0],-1,0):\\n                    return -1\\n                else:\\n                    ans=0\\n                    for j in li:\\n                        tempvis=set()\\n                        ans=max(ans,bfs(j))\\n                    fans+=ans\\n        return fans\\n\\n\\n\\n\\n\\n\\n\\n\\n        # The below code doesnot work because i can not decide whether going right or left which one yields more groups\\n        # dici={}\\n        # ans={}\\n        # def fun(node,parent,ind):\\n        #     dici[node]=ind\\n        #     if ind in ans:\\n        #         ans[ind]+=1\\n        #     else:\\n        #         ans[ind]=1\\n        #     for child in adj[node]:\\n        #         if child not in dici:\\n        #             if not(ind+1 not in ans and  fun(child,node,ind+1)) and not (ind-1 not in ans and fun(child,node,ind-1)) and  not fun(child,node,ind-1) and not fun(child,node,ind+1) :\\n        #                 dici.pop(node)\\n        #                 ans[ind]-=1\\n        #                 if ans[ind]==0:\\n        #                     ans.pop(ind)\\n        #                 return False\\n        #         elif child!=parent:\\n        #             if (dici[child]!=ind+1 and dici[child]!=ind-1):\\n        #                 dici.pop(node)\\n        #                 ans[ind]-=1\\n        #                 if ans[ind]==0:\\n        #                     ans.pop(ind)\\n        #                 return False\\n        #     return True\\n        # for i in range(n):\\n        #     if i not in dici:\\n        #         if not fun(i,-1,i*1000):\\n        #             return -1\\n        # print(ans)\\n        # print(sum(ans.values()))\\n        # return len(ans)\\n\\n\\n    \\n\\n                    \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566046,
                "title": "easy-to-understand-bfs-dfs-bipartite-graph-explained-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDjikstra+ is graph bipartite (many concepts mixed in one problem)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate groups separately for disconnected graph and add at last\\nUse Djikstra to calculate distance between each pair of nodes because floyd warshall gives **TLE**.\\nUse normal dfs to check if graph is bipartite (if not then return -1)\\nalso store all nodes of the connected graph in the same dfs function.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // dfs function to check if graph is bipartite\\n    bool dfs(int i,int col,vector<vector<int>>&adj,vector<int>&vis,vector<int>&nodes){\\n        vis[i]=col;\\n        bool ans=true;\\n        nodes.push_back(i);\\n        for(auto &it:adj[i]){\\n            if(!vis[it]) ans&=dfs(it,3-col,adj,vis,nodes);\\n            else if(vis[it]==col) return false;\\n        }\\n        return ans;\\n    }\\n    //bfs function to calculate shortest distance between each node using djikstra because floyd warshall will give tle\\n    void bfs(int src,vector<vector<int>>&dist,vector<vector<int>>&adj,int n){\\n        queue<int>q;\\n        q.push(src);\\n        dist[src][src]=1;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto &it:adj[node]){\\n                if(dist[src][it]>dist[src][node]+1){\\n                    dist[src][it]=dist[src][node]+1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n+1);\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n\\n        }\\n        vector<vector<int>>dist(n+1,vector<int>(n+1,INT_MAX));\\n        for(int i=1;i<=n;i++){\\n            bfs(i,dist,adj,n); //calculating shortest distance\\n        }\\n        vector<int>vis(n+1,0);\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(!vis[i]){\\n                vector<int>nodes; // stores all nodes in a connected graph\\n                if(!dfs(i,1,adj,vis,nodes)) return -1; //if graph is not bipartite (if graph contains odd number of nodes in cycle)\\n                int maxi=0;\\n                for(int j=0;j<nodes.size();j++){\\n                    for(int k=j;k<nodes.size();k++){\\n                        maxi=max(maxi,dist[nodes[k]][nodes[j]]);//maximum of shortest distance in a connected graph will give the number of groups\\n                    }\\n                }\\n                ans+=maxi; // adding all groups in disconnected graphs separately\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // dfs function to check if graph is bipartite\\n    bool dfs(int i,int col,vector<vector<int>>&adj,vector<int>&vis,vector<int>&nodes){\\n        vis[i]=col;\\n        bool ans=true;\\n        nodes.push_back(i);\\n        for(auto &it:adj[i]){\\n            if(!vis[it]) ans&=dfs(it,3-col,adj,vis,nodes);\\n            else if(vis[it]==col) return false;\\n        }\\n        return ans;\\n    }\\n    //bfs function to calculate shortest distance between each node using djikstra because floyd warshall will give tle\\n    void bfs(int src,vector<vector<int>>&dist,vector<vector<int>>&adj,int n){\\n        queue<int>q;\\n        q.push(src);\\n        dist[src][src]=1;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto &it:adj[node]){\\n                if(dist[src][it]>dist[src][node]+1){\\n                    dist[src][it]=dist[src][node]+1;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n+1);\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n\\n        }\\n        vector<vector<int>>dist(n+1,vector<int>(n+1,INT_MAX));\\n        for(int i=1;i<=n;i++){\\n            bfs(i,dist,adj,n); //calculating shortest distance\\n        }\\n        vector<int>vis(n+1,0);\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(!vis[i]){\\n                vector<int>nodes; // stores all nodes in a connected graph\\n                if(!dfs(i,1,adj,vis,nodes)) return -1; //if graph is not bipartite (if graph contains odd number of nodes in cycle)\\n                int maxi=0;\\n                for(int j=0;j<nodes.size();j++){\\n                    for(int k=j;k<nodes.size();k++){\\n                        maxi=max(maxi,dist[nodes[k]][nodes[j]]);//maximum of shortest distance in a connected graph will give the number of groups\\n                    }\\n                }\\n                ans+=maxi; // adding all groups in disconnected graphs separately\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557940,
                "title": "bfs-traversal-bipartite-graph-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->   \\n        O(V*(V+2E))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(V) // adjacency list space not counted ;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // The graph is disconnected too ;// remember to read the question properly \\n    // bool is is for checking whether the graph is bipartite or not \\n    // This BFS function will tell whether the grapgh is bipartitr or not and also return the maximum distnace of that node \\n    void BFS(vector<vector<int>>& adj , vector<int>& visited ,vector<bool>& store , int & val  ,int i ,bool & is  ,bool require , vector<int> & helper)\\n    {\\n        queue<pair<int,int>>pending ;\\n        pending.push({i ,1});\\n        visited[i] = 1 ;\\n        store[i]= true ;\\n        while(!pending.empty())\\n        {\\n            int ind = pending.front().first ;\\n            int group = pending.front().second;\\n           \\n            pending.pop() ;\\n            for( int j=0 ;j< adj[ind].size() ;j++)\\n            {\\n                if(visited[adj[ind][j]]!=-1)\\n                {\\n                    if(abs(group-visited[adj[ind][j]])==1)\\n                    {\\n                        continue;\\n                    }\\n                    val=-1 ;\\n                    is= false;\\n                    return ;\\n                }\\n                    val= max(val , group+1);\\n                    visited[adj[ind][j]]= group+1;\\n                    store[adj[ind][j]]= true ;\\n                    if(require== true )\\n                    {\\n                        helper.push_back(adj[ind][j]);\\n                    }\\n                    pending.push({adj[ind][j] , group+1 });\\n            }\\n            \\n        }\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj (n+1);\\n        for( int i =0 ;i< edges.size() ;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int maxi =0;\\n        vector<bool> store((n+1) ,false);\\n//      This loop fortraversing over all teh connected components \\n        for( int i =1 ;i<=n ;i++)\\n        {\\n           if(store[i]==false)\\n           {\\n               vector<int> visited(n+1,-1);\\n               int val =-1 ;\\n               bool is = true ;\\n               vector<int> helper;\\n            // This call for going over all the nodes in the particular components \\n            // AND store the visited nodes in this graph \\n               BFS(adj , visited, store , val , i, is , true , helper);\\n               if(is== false)\\n               {\\n                   return -1 ;\\n               }\\n               // Traverse for all the visited nodes in the component for finding the minimum farthest distance tio the node \\n               for( int j = 1;j<helper.size() ;j++)\\n               {\\n                       int value =0 ;\\n                       vector<int> vis (n+1, -1);\\n                       BFS(adj , vis , store,value ,helper[j] ,is, false ,helper );\\n                       val= max(val, value);\\n                   \\n               }\\n               maxi += (val==-1)?1:val ;\\n           }\\n        }\\n        return maxi ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // The graph is disconnected too ;// remember to read the question properly \\n    // bool is is for checking whether the graph is bipartite or not \\n    // This BFS function will tell whether the grapgh is bipartitr or not and also return the maximum distnace of that node \\n    void BFS(vector<vector<int>>& adj , vector<int>& visited ,vector<bool>& store , int & val  ,int i ,bool & is  ,bool require , vector<int> & helper)\\n    {\\n        queue<pair<int,int>>pending ;\\n        pending.push({i ,1});\\n        visited[i] = 1 ;\\n        store[i]= true ;\\n        while(!pending.empty())\\n        {\\n            int ind = pending.front().first ;\\n            int group = pending.front().second;\\n           \\n            pending.pop() ;\\n            for( int j=0 ;j< adj[ind].size() ;j++)\\n            {\\n                if(visited[adj[ind][j]]!=-1)\\n                {\\n                    if(abs(group-visited[adj[ind][j]])==1)\\n                    {\\n                        continue;\\n                    }\\n                    val=-1 ;\\n                    is= false;\\n                    return ;\\n                }\\n                    val= max(val , group+1);\\n                    visited[adj[ind][j]]= group+1;\\n                    store[adj[ind][j]]= true ;\\n                    if(require== true )\\n                    {\\n                        helper.push_back(adj[ind][j]);\\n                    }\\n                    pending.push({adj[ind][j] , group+1 });\\n            }\\n            \\n        }\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj (n+1);\\n        for( int i =0 ;i< edges.size() ;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int maxi =0;\\n        vector<bool> store((n+1) ,false);\\n//      This loop fortraversing over all teh connected components \\n        for( int i =1 ;i<=n ;i++)\\n        {\\n           if(store[i]==false)\\n           {\\n               vector<int> visited(n+1,-1);\\n               int val =-1 ;\\n               bool is = true ;\\n               vector<int> helper;\\n            // This call for going over all the nodes in the particular components \\n            // AND store the visited nodes in this graph \\n               BFS(adj , visited, store , val , i, is , true , helper);\\n               if(is== false)\\n               {\\n                   return -1 ;\\n               }\\n               // Traverse for all the visited nodes in the component for finding the minimum farthest distance tio the node \\n               for( int j = 1;j<helper.size() ;j++)\\n               {\\n                       int value =0 ;\\n                       vector<int> vis (n+1, -1);\\n                       BFS(adj , vis , store,value ,helper[j] ,is, false ,helper );\\n                       val= max(val, value);\\n                   \\n               }\\n               maxi += (val==-1)?1:val ;\\n           }\\n        }\\n        return maxi ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546098,
                "title": "some-kind-of-bruteforce-i-guess",
                "content": "# Intuition\\n Build all the distinct components (using UF, dfs, bfs. I used bfs), and then for each component find max number of groups in it and add it to the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MagnificentSets(int n, int[][] edges) {\\n        var map = new Dictionary<int, List<int>>();\\n\\n        foreach(var e in edges){\\n            map.TryAdd(e[0], new());\\n            map.TryAdd(e[1], new());\\n\\n            map[e[0]].Add(e[1]);\\n            map[e[1]].Add(e[0]);\\n        }\\n\\n        var components = BuildComponents(n, map);\\n        var res = 0;\\n         \\n         foreach(var comp in components){\\n             var maxVal = int.MinValue;\\n             foreach(var root in comp.Value){\\n                 var temp = VisitNeighbors(root, map);\\n                 if(temp == -1){\\n                     return -1;\\n                 }\\n                 maxVal = Math.Max(maxVal, temp);\\n             }\\n\\n             res+= maxVal;\\n         }\\n        return res;\\n    }\\n\\n    private Dictionary<int, List<int>> BuildComponents(int n, Dictionary<int, List<int>> map){\\n        var comp = 1;\\n        var visited = new HashSet<int>();\\n        var q = new Queue<int>();\\n        var res = new Dictionary<int, List<int>>();\\n\\n        for(int i = 1; i <= n; i++){\\n            if(!visited.Contains(i)){\\n                q.Enqueue(i);\\n                var compNodes = new List<int>();\\n                res.Add(comp, compNodes);\\n\\n                while(q.Count > 0){\\n                    var node = q.Dequeue();\\n                    compNodes.Add(node);\\n\\n                    if(!map.TryGetValue(node, out var neighbors))\\n                       continue;\\n\\n                    foreach(var neig in neighbors){\\n                        if(!visited.Contains(neig)){\\n                            q.Enqueue(neig);\\n                            visited.Add(neig);\\n                        }\\n                    }\\n                }\\n\\n            comp++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private int VisitNeighbors(int root, Dictionary<int, List<int>> map){\\n        var groups = new Dictionary<int, int>();\\n\\n        int currentGroup = 0;\\n        var q = new Queue<int>();\\n        q.Enqueue(root);\\n        groups.Add(root, currentGroup);\\n\\n        while(q.Count > 0){\\n\\n            var s = q.Count;\\n\\n            while(s > 0){\\n                var node = q.Dequeue();\\n\\n                if(map.TryGetValue(node, out var neighbors)) {            \\n                foreach(var n in neighbors){\\n                    if(!groups.TryGetValue(n, out var g)){\\n                         q.Enqueue(n);\\n                         groups.Add(n, currentGroup + 1);\\n                    }else{\\n                        if(Math.Abs(g - currentGroup) != 1){\\n                            return -1;\\n                        }\\n                    }                  \\n                }\\n                }\\n\\n                s--;\\n            }\\n\\n             currentGroup++;\\n        }\\n\\n        return currentGroup;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MagnificentSets(int n, int[][] edges) {\\n        var map = new Dictionary<int, List<int>>();\\n\\n        foreach(var e in edges){\\n            map.TryAdd(e[0], new());\\n            map.TryAdd(e[1], new());\\n\\n            map[e[0]].Add(e[1]);\\n            map[e[1]].Add(e[0]);\\n        }\\n\\n        var components = BuildComponents(n, map);\\n        var res = 0;\\n         \\n         foreach(var comp in components){\\n             var maxVal = int.MinValue;\\n             foreach(var root in comp.Value){\\n                 var temp = VisitNeighbors(root, map);\\n                 if(temp == -1){\\n                     return -1;\\n                 }\\n                 maxVal = Math.Max(maxVal, temp);\\n             }\\n\\n             res+= maxVal;\\n         }\\n        return res;\\n    }\\n\\n    private Dictionary<int, List<int>> BuildComponents(int n, Dictionary<int, List<int>> map){\\n        var comp = 1;\\n        var visited = new HashSet<int>();\\n        var q = new Queue<int>();\\n        var res = new Dictionary<int, List<int>>();\\n\\n        for(int i = 1; i <= n; i++){\\n            if(!visited.Contains(i)){\\n                q.Enqueue(i);\\n                var compNodes = new List<int>();\\n                res.Add(comp, compNodes);\\n\\n                while(q.Count > 0){\\n                    var node = q.Dequeue();\\n                    compNodes.Add(node);\\n\\n                    if(!map.TryGetValue(node, out var neighbors))\\n                       continue;\\n\\n                    foreach(var neig in neighbors){\\n                        if(!visited.Contains(neig)){\\n                            q.Enqueue(neig);\\n                            visited.Add(neig);\\n                        }\\n                    }\\n                }\\n\\n            comp++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private int VisitNeighbors(int root, Dictionary<int, List<int>> map){\\n        var groups = new Dictionary<int, int>();\\n\\n        int currentGroup = 0;\\n        var q = new Queue<int>();\\n        q.Enqueue(root);\\n        groups.Add(root, currentGroup);\\n\\n        while(q.Count > 0){\\n\\n            var s = q.Count;\\n\\n            while(s > 0){\\n                var node = q.Dequeue();\\n\\n                if(map.TryGetValue(node, out var neighbors)) {            \\n                foreach(var n in neighbors){\\n                    if(!groups.TryGetValue(n, out var g)){\\n                         q.Enqueue(n);\\n                         groups.Add(n, currentGroup + 1);\\n                    }else{\\n                        if(Math.Abs(g - currentGroup) != 1){\\n                            return -1;\\n                        }\\n                    }                  \\n                }\\n                }\\n\\n                s--;\\n            }\\n\\n             currentGroup++;\\n        }\\n\\n        return currentGroup;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540131,
                "title": "divide-nodes-into-groups",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// connected component find union \\n  // bipartite check for each component: only then we can divide in groups\\n  // for a component, we can start at any node and start making groups:BFS\\n  // find the max no of groups we can have for a component\\n  //since we want to find the max we index each group differently and for each component also.\\n  //so then we do add and ans.\\n\\n\\n  /*\\n  Flow:\\n  adj matrix\\n  make union of all the nodes :connected component\\n  each component bipartite check \\n  for all components and for each node find groups it can make.\\n  for each component we find the max group we can have.\\n  and have the ans\\n\\n  */\\nclass Disjointset\\n{\\nprivate:\\n    vector<int> parent, size; // parent will store the parents \\'\\n                              // size will be taken to rank or compare the parent order while doing union.\\npublic:\\n    Disjointset(int n)\\n    {\\n        parent.resize(n + 1);\\n        size.resize(n, 1);\\n        for (int i = 0; i < n + 1; i++)\\n        {\\n            parent[i] = i; // element will be it\\'s parent only\\n        }\\n    }\\n    int find(int X)\\n    {\\n        if (parent[X] == X)\\n            return X;\\n\\n        return parent[X] = find(parent[X]); // path compression\\n    }\\n    void UNION(int X, int Y)\\n    {\\n        int parent1 = find(X);\\n        int parent2 = find(Y);\\n        if (parent1 == parent2)\\n            return; // CYCLE DETECTED.\\n        if (size[parent1] < size[parent2])\\n        {\\n            parent[parent1] = parent2;\\n            size[parent2] += size[parent1];\\n        }\\n        else\\n        {\\n            parent[parent2] = parent1;\\n            size[parent1] += size[parent2];\\n        }\\n    }\\n    void printArrays()\\n    {\\n        cout << \"PARENT\" << endl;\\n        for (auto it : parent)\\n        {\\n            cout << it << \" \";\\n        }\\n        cout << endl;\\n        cout << \"SIZE\" << endl;\\n        for (auto it : size)\\n        {\\n            cout << it << \" \";\\n        }\\n    }\\n    int SIZE(int vertex) // returns the size of the whole disjoint set of which the current vertex is a part of.\\n    {\\n        return size[find(vertex)]; // returns the size of disjoint set that it is a part of.\\n    }\\n\\n    int noOfdisjointSets(int n) // pass n as indexing. , gives all disjoint sets and not particular\\n    {\\n        // find the parent of all nodes.\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = find(i);\\n        }\\n\\n        int cnt = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (parent[i] == i)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        /*\\n      //   METHOD 2\\n        set<int> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(parent[i]);\\n        }\\n        return s.size();\\n        */\\n    }\\n};\\n\\nclass Solution\\n{\\n\\n    bool isbipartitie(int node, int color, vector<vector<int>> &graph, vector<int> &vis)\\n    {\\n\\n        vis[node] = color;\\n        for (auto it : graph[node])\\n        {\\n            if (vis[it] == -1)\\n            {\\n                if (isbipartitie(it, !color, graph, vis) == false)\\n                    return false;\\n            }\\n            else if (vis[it] == color)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int bfs_findlevels(int start, vector<vector<int>> &adj)\\n    {\\n        queue<int> q;\\n        int n = adj.size();\\n        unordered_map<int, bool> visited; /*IMP here*/\\n        q.push(start);\\n        visited[start] = true;\\n        int level = -1;\\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n            level++;\\n            while (size--)\\n            {\\n                int curr = q.front();\\n                q.pop();\\n                for (auto adj_node : adj[curr])\\n                {\\n                    if (visited[adj_node] == false)\\n                    {\\n                        visited[adj_node] = true;\\n                        q.push(adj_node);\\n                    }\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n); //changed the indexing to 0 based for simplicity\\n        Disjointset ds(n); \\n\\n        for(auto it:edges) //adj matrix and union\\n        {\\n            adj[it[0]-1].push_back(it[1]-1);\\n            adj[it[1]-1].push_back(it[0]-1);\\n            ds.UNION(it[0]-1,it[1]-1);\\n        }\\n\\n         vector<int> colored(n,-1);\\n        for(int i=0;i<n;i++) //bipartite check\\n        {\\n           if(colored[i]==-1)\\n           {\\n           if(isbipartitie(i,0,adj,colored)==false)\\n            {\\n                return -1;\\n            }\\n           }\\n            \\n        }\\n        \\n        vector<int> groups_node(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            groups_node[i]=1+bfs_findlevels(i,adj); //since level starts from 0.\\n        }\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=ds.find(i);\\n            mp[x]=max(mp[x],groups_node[i]);\\n        }\\n        int ans=0;\\n        for(auto it:mp)\\n        {\\n            ans+=it.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n// connected component find union \\n  // bipartite check for each component: only then we can divide in groups\\n  // for a component, we can start at any node and start making groups:BFS\\n  // find the max no of groups we can have for a component\\n  //since we want to find the max we index each group differently and for each component also.\\n  //so then we do add and ans.\\n\\n\\n  /*\\n  Flow:\\n  adj matrix\\n  make union of all the nodes :connected component\\n  each component bipartite check \\n  for all components and for each node find groups it can make.\\n  for each component we find the max group we can have.\\n  and have the ans\\n\\n  */\\nclass Disjointset\\n{\\nprivate:\\n    vector<int> parent, size; // parent will store the parents \\'\\n                              // size will be taken to rank or compare the parent order while doing union.\\npublic:\\n    Disjointset(int n)\\n    {\\n        parent.resize(n + 1);\\n        size.resize(n, 1);\\n        for (int i = 0; i < n + 1; i++)\\n        {\\n            parent[i] = i; // element will be it\\'s parent only\\n        }\\n    }\\n    int find(int X)\\n    {\\n        if (parent[X] == X)\\n            return X;\\n\\n        return parent[X] = find(parent[X]); // path compression\\n    }\\n    void UNION(int X, int Y)\\n    {\\n        int parent1 = find(X);\\n        int parent2 = find(Y);\\n        if (parent1 == parent2)\\n            return; // CYCLE DETECTED.\\n        if (size[parent1] < size[parent2])\\n        {\\n            parent[parent1] = parent2;\\n            size[parent2] += size[parent1];\\n        }\\n        else\\n        {\\n            parent[parent2] = parent1;\\n            size[parent1] += size[parent2];\\n        }\\n    }\\n    void printArrays()\\n    {\\n        cout << \"PARENT\" << endl;\\n        for (auto it : parent)\\n        {\\n            cout << it << \" \";\\n        }\\n        cout << endl;\\n        cout << \"SIZE\" << endl;\\n        for (auto it : size)\\n        {\\n            cout << it << \" \";\\n        }\\n    }\\n    int SIZE(int vertex) // returns the size of the whole disjoint set of which the current vertex is a part of.\\n    {\\n        return size[find(vertex)]; // returns the size of disjoint set that it is a part of.\\n    }\\n\\n    int noOfdisjointSets(int n) // pass n as indexing. , gives all disjoint sets and not particular\\n    {\\n        // find the parent of all nodes.\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = find(i);\\n        }\\n\\n        int cnt = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (parent[i] == i)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        /*\\n      //   METHOD 2\\n        set<int> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(parent[i]);\\n        }\\n        return s.size();\\n        */\\n    }\\n};\\n\\nclass Solution\\n{\\n\\n    bool isbipartitie(int node, int color, vector<vector<int>> &graph, vector<int> &vis)\\n    {\\n\\n        vis[node] = color;\\n        for (auto it : graph[node])\\n        {\\n            if (vis[it] == -1)\\n            {\\n                if (isbipartitie(it, !color, graph, vis) == false)\\n                    return false;\\n            }\\n            else if (vis[it] == color)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int bfs_findlevels(int start, vector<vector<int>> &adj)\\n    {\\n        queue<int> q;\\n        int n = adj.size();\\n        unordered_map<int, bool> visited; /*IMP here*/\\n        q.push(start);\\n        visited[start] = true;\\n        int level = -1;\\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n            level++;\\n            while (size--)\\n            {\\n                int curr = q.front();\\n                q.pop();\\n                for (auto adj_node : adj[curr])\\n                {\\n                    if (visited[adj_node] == false)\\n                    {\\n                        visited[adj_node] = true;\\n                        q.push(adj_node);\\n                    }\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n); //changed the indexing to 0 based for simplicity\\n        Disjointset ds(n); \\n\\n        for(auto it:edges) //adj matrix and union\\n        {\\n            adj[it[0]-1].push_back(it[1]-1);\\n            adj[it[1]-1].push_back(it[0]-1);\\n            ds.UNION(it[0]-1,it[1]-1);\\n        }\\n\\n         vector<int> colored(n,-1);\\n        for(int i=0;i<n;i++) //bipartite check\\n        {\\n           if(colored[i]==-1)\\n           {\\n           if(isbipartitie(i,0,adj,colored)==false)\\n            {\\n                return -1;\\n            }\\n           }\\n            \\n        }\\n        \\n        vector<int> groups_node(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            groups_node[i]=1+bfs_findlevels(i,adj); //since level starts from 0.\\n        }\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=ds.find(i);\\n            mp[x]=max(mp[x],groups_node[i]);\\n        }\\n        int ans=0;\\n        for(auto it:mp)\\n        {\\n            ans+=it.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3484797,
                "title": "easy-bfs-dfs-with-map-only-simple-approach-code-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nQuestion Said that none of two adjacent nodes should be in same group, it means graph should be bipartite and we want maximum groups so we want maximum distance between two nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically first check the bipartiteness by boolean dfs then run bfs from each node and calculate tha maximum distance.But there is a catch that more than one connected components can be present so i used a map here and run dfs_check for each connected component and stored the visited element in map,then run the bfs  on elements only which are present in map.For each cc i will sum up the ans and return.\\nhere it is,Only lenght not too much hard if you read it carefully.If understood please upvote : )\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n# Code\\n```\\nclass Solution {\\nvector<int> adj[10001];\\nint vis[10001],col[10001],dist[10001],visited[10001];\\nint cc=0,n;\\nmap<int,int> mp;\\nbool dfs(int node,int par){\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        if(!vis[it]){\\n            col[it]=!col[node];\\n            if(dfs(it,node)==false) return false;\\n        }\\n        else{\\n            if(it!=par){\\n                if(col[it]==col[node]) return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nint bfs(int node){\\n    memset(vis,0,sizeof(vis));\\n    memset(dist,0,sizeof(dist));\\n    queue<pair<int,int>> q;\\n    q.push({node,0});\\n    vis[node]=1;\\n    while(!q.empty()){\\n        auto it=q.front();\\n        q.pop();\\n        int node=it.first,di=it.second;\\n        dist[node]=it.second;\\n        for(auto it:adj[node]){\\n            if(!vis[it] && mp[it]){\\n                q.push({it,di+1});\\n                vis[it]=1;\\n            }\\n        }\\n    }\\n    int maxi=0;\\n    for(int i=1;i<=n;i++) maxi=max(maxi,dist[i]);\\n    return maxi+1;\\n}\\n\\nvoid dfs_check(int node){\\n    mp[node]=1;\\n    visited[node]=1;\\n    for(auto it:adj[node]){\\n        if(!visited[it]) dfs_check(it);\\n    }\\n}\\n\\npublic:\\n    int magnificentSets(int m, vector<vector<int>>& graph) {\\n        n=m;\\n        memset(col,-1,sizeof(col));\\n        memset(vis,0,sizeof(vis));\\n        for(auto it:graph){\\n            int a=it[0],b=it[1];\\n            adj[a].push_back(b),adj[b].push_back(a);\\n        }\\n        int flg=1;\\n        for(int i=0;i<graph.size();i++){\\n            if(!vis[i]){\\n                col[i]=0;\\n                if(dfs(i,-1)==false) flg=0;\\n            }\\n        }\\n        if(flg==0) return -1;\\n        // bipartite checked\\n        //now run bfs from each node\\n\\n\\n        // int ans=0;\\n        // for(int i=1;i<=n;i++){\\n        //     ans=max(ans,bfs(i));\\n        // }\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(!visited[i]){\\n                int ans=0;\\n                mp.clear();\\n                dfs_check(i);\\n                for(int j=1;j<=n;j++){\\n                    if(mp[j]==1){\\n                        ans=max(ans,bfs(j));\\n                    }\\n                } \\n                sum+=ans;\\n            }\\n        }\\n        // cout<<bfs(1)<<endl;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nvector<int> adj[10001];\\nint vis[10001],col[10001],dist[10001],visited[10001];\\nint cc=0,n;\\nmap<int,int> mp;\\nbool dfs(int node,int par){\\n    vis[node]=1;\\n    for(auto it:adj[node]){\\n        if(!vis[it]){\\n            col[it]=!col[node];\\n            if(dfs(it,node)==false) return false;\\n        }\\n        else{\\n            if(it!=par){\\n                if(col[it]==col[node]) return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nint bfs(int node){\\n    memset(vis,0,sizeof(vis));\\n    memset(dist,0,sizeof(dist));\\n    queue<pair<int,int>> q;\\n    q.push({node,0});\\n    vis[node]=1;\\n    while(!q.empty()){\\n        auto it=q.front();\\n        q.pop();\\n        int node=it.first,di=it.second;\\n        dist[node]=it.second;\\n        for(auto it:adj[node]){\\n            if(!vis[it] && mp[it]){\\n                q.push({it,di+1});\\n                vis[it]=1;\\n            }\\n        }\\n    }\\n    int maxi=0;\\n    for(int i=1;i<=n;i++) maxi=max(maxi,dist[i]);\\n    return maxi+1;\\n}\\n\\nvoid dfs_check(int node){\\n    mp[node]=1;\\n    visited[node]=1;\\n    for(auto it:adj[node]){\\n        if(!visited[it]) dfs_check(it);\\n    }\\n}\\n\\npublic:\\n    int magnificentSets(int m, vector<vector<int>>& graph) {\\n        n=m;\\n        memset(col,-1,sizeof(col));\\n        memset(vis,0,sizeof(vis));\\n        for(auto it:graph){\\n            int a=it[0],b=it[1];\\n            adj[a].push_back(b),adj[b].push_back(a);\\n        }\\n        int flg=1;\\n        for(int i=0;i<graph.size();i++){\\n            if(!vis[i]){\\n                col[i]=0;\\n                if(dfs(i,-1)==false) flg=0;\\n            }\\n        }\\n        if(flg==0) return -1;\\n        // bipartite checked\\n        //now run bfs from each node\\n\\n\\n        // int ans=0;\\n        // for(int i=1;i<=n;i++){\\n        //     ans=max(ans,bfs(i));\\n        // }\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(!visited[i]){\\n                int ans=0;\\n                mp.clear();\\n                dfs_check(i);\\n                for(int j=1;j<=n;j++){\\n                    if(mp[j]==1){\\n                        ans=max(ans,bfs(j));\\n                    }\\n                } \\n                sum+=ans;\\n            }\\n        }\\n        // cout<<bfs(1)<<endl;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3454381,
                "title": "python-simple-union-find-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def magnificentSets(self, n, edges):\\n        dict1 = defaultdict(int)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a,b = find(x),find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        def bfs(node):\\n            stack, visited, level = [(node,1)], {node:1}, 1\\n\\n            while stack:\\n                cur, level = stack.pop(0)\\n\\n                for neighbor in graph[cur]:\\n                    if neighbor not in visited:\\n                        visited[neighbor] = level + 1\\n                        stack.append((neighbor,level+1))\\n                    elif visited[neighbor] == level:\\n                        return -1\\n\\n            return level\\n\\n\\n        graph = defaultdict(list)\\n\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n            union(i,j)\\n\\n        max_group, res = defaultdict(int), []\\n\\n        for i in range(1,n+1):\\n            groups = bfs(i)\\n\\n            if groups == -1:\\n                return -1\\n\\n            max_group[find(i)] = max(max_group[find(i)],groups)\\n\\n        return sum(max_group.values())\\n\\n\\n\\n            \\n\\n\\n\\n            \\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n, edges):\\n        dict1 = defaultdict(int)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a,b = find(x),find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        def bfs(node):\\n            stack, visited, level = [(node,1)], {node:1}, 1\\n\\n            while stack:\\n                cur, level = stack.pop(0)\\n\\n                for neighbor in graph[cur]:\\n                    if neighbor not in visited:\\n                        visited[neighbor] = level + 1\\n                        stack.append((neighbor,level+1))\\n                    elif visited[neighbor] == level:\\n                        return -1\\n\\n            return level\\n\\n\\n        graph = defaultdict(list)\\n\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n            union(i,j)\\n\\n        max_group, res = defaultdict(int), []\\n\\n        for i in range(1,n+1):\\n            groups = bfs(i)\\n\\n            if groups == -1:\\n                return -1\\n\\n            max_group[find(i)] = max(max_group[find(i)],groups)\\n\\n        return sum(max_group.values())\\n\\n\\n\\n            \\n\\n\\n\\n            \\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419848,
                "title": "c-bruteforce-bfs-dfs",
                "content": "time~O(N * E)\\nspace~O(N + E)\\n```\\nclass Solution {\\n    int bfs(int n, vector<int> &visited, vector<vector<int>> &adj){\\n        queue<int> q;\\n        q.push(n);\\n        int res;\\n        while(q.size()){\\n            auto f=q.front();\\n            q.pop();\\n            res=visited[f];\\n            for(auto &a:adj[f]){\\n                if(visited[a]==-1){\\n                    visited[a]=visited[f]+1;\\n                    q.push(a);\\n                }else{\\n                    if(abs(visited[a]-visited[f])!=1)\\n                        return -1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    void dfs(int n, int m, vector<int> &mark, vector<vector<int>> &adj){\\n        mark[n]=m;\\n        for(auto &a:adj[n])\\n            if(mark[a]==-1)\\n                dfs(a,m,mark,adj);\\n    }\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n+1);\\n        for(auto &a:edges){\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n        }\\n        int m=0;\\n        vector<int> mark(n+1,-1);\\n        for(int x=1;x<=n;x++){\\n            if(mark[x]==-1){\\n                dfs(x,m,mark,adj);\\n                m++;\\n            }\\n        }\\n        vector<int> res(m,-1);\\n        for(int x=1;x<=n;x++){\\n            vector<int> visited(n+1,-1);\\n            visited[x]=1;\\n            res[mark[x]]=max(bfs(x,visited,adj),res[mark[x]]);\\n        }\\n        for(auto &a:res)\\n            if(a==-1)\\n                return -1;\\n        return accumulate(res.begin(),res.end(),0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    int bfs(int n, vector<int> &visited, vector<vector<int>> &adj){\\n        queue<int> q;\\n        q.push(n);\\n        int res;\\n        while(q.size()){\\n            auto f=q.front();\\n            q.pop();\\n            res=visited[f];\\n            for(auto &a:adj[f]){\\n                if(visited[a]==-1){\\n                    visited[a]=visited[f]+1;\\n                    q.push(a);\\n                }else{\\n                    if(abs(visited[a]-visited[f])!=1)\\n                        return -1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    void dfs(int n, int m, vector<int> &mark, vector<vector<int>> &adj){\\n        mark[n]=m;\\n        for(auto &a:adj[n])\\n            if(mark[a]==-1)\\n                dfs(a,m,mark,adj);\\n    }\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n+1);\\n        for(auto &a:edges){\\n            adj[a[0]].push_back(a[1]);\\n            adj[a[1]].push_back(a[0]);\\n        }\\n        int m=0;\\n        vector<int> mark(n+1,-1);\\n        for(int x=1;x<=n;x++){\\n            if(mark[x]==-1){\\n                dfs(x,m,mark,adj);\\n                m++;\\n            }\\n        }\\n        vector<int> res(m,-1);\\n        for(int x=1;x<=n;x++){\\n            vector<int> visited(n+1,-1);\\n            visited[x]=1;\\n            res[mark[x]]=max(bfs(x,visited,adj),res[mark[x]]);\\n        }\\n        for(auto &a:res)\\n            if(a==-1)\\n                return -1;\\n        return accumulate(res.begin(),res.end(),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227232,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int normalBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool> visited) {\\n        queue<int> q;\\n        q.push(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    q.push(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    int checkConnectedBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool>& visited) {\\n        vector<int> members;\\n        vector<bool> visitedCopy = visited;\\n        queue<int> q;\\n        q.push(start);\\n        members.push_back(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            vector<int> collections;\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    collections.push_back(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            // check if all nodes at the same level have any connection;\\n            int m = collections.size();\\n\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < i; ++j) {\\n                    if (hashEdges[collections[i]].count(collections[j])) return -1;\\n                }\\n            }\\n            for (int i = 0; i < m; ++i) {\\n                q.push(collections[i]);\\n                members.push_back(collections[i]);\\n            }\\n            level++;\\n        }\\n        for (auto& member : members) {\\n            level = max(level, normalBfs(member, hashEdges, visitedCopy));\\n        }\\n        return level;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, unordered_set<int>> hashEdges;\\n\\n        for (auto& edge : edges) {\\n            hashEdges[edge[0] - 1].insert(edge[1] - 1);\\n            hashEdges[edge[1] - 1].insert(edge[0] - 1);\\n        }\\n        vector<bool> visited(n, false);\\n        int maxRes = 0;\\n        \\n        for (int node = 0; node < n; ++node) {\\n            if (visited[node]) continue;\\n            int result = checkConnectedBfs(node, hashEdges, visited);\\n            if (result == -1) return -1;\\n            \\n            maxRes += result;\\n        }\\n        return maxRes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int normalBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool> visited) {\\n        queue<int> q;\\n        q.push(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    q.push(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    int checkConnectedBfs(int start, unordered_map<int, unordered_set<int>>& hashEdges, vector<bool>& visited) {\\n        vector<int> members;\\n        vector<bool> visitedCopy = visited;\\n        queue<int> q;\\n        q.push(start);\\n        members.push_back(start);\\n        visited[start] = true;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int n = q.size();\\n            vector<int> collections;\\n            for (int i = 0; i < n; ++i) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto& neighbor : hashEdges[node]) {\\n                    if (visited[neighbor]) continue;\\n                    collections.push_back(neighbor);\\n                    visited[neighbor] = true;\\n                }\\n            }\\n            // check if all nodes at the same level have any connection;\\n            int m = collections.size();\\n\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < i; ++j) {\\n                    if (hashEdges[collections[i]].count(collections[j])) return -1;\\n                }\\n            }\\n            for (int i = 0; i < m; ++i) {\\n                q.push(collections[i]);\\n                members.push_back(collections[i]);\\n            }\\n            level++;\\n        }\\n        for (auto& member : members) {\\n            level = max(level, normalBfs(member, hashEdges, visitedCopy));\\n        }\\n        return level;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, unordered_set<int>> hashEdges;\\n\\n        for (auto& edge : edges) {\\n            hashEdges[edge[0] - 1].insert(edge[1] - 1);\\n            hashEdges[edge[1] - 1].insert(edge[0] - 1);\\n        }\\n        vector<bool> visited(n, false);\\n        int maxRes = 0;\\n        \\n        for (int node = 0; node < n; ++node) {\\n            if (visited[node]) continue;\\n            int result = checkConnectedBfs(node, hashEdges, visited);\\n            if (result == -1) return -1;\\n            \\n            maxRes += result;\\n        }\\n        return maxRes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147588,
                "title": "c-bipartite-check-union-find-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> p,len;\\n    void make(int node){\\n        p[node]=node;\\n        len[node]=1;\\n        return;\\n    }\\n    int find(int node){\\n        if(p[node]==node) return node;\\n        return p[node]=find(p[node]);   // path_compression //  // reverse_ackermann_function //\\n    }\\n    void Union(int a,int b){\\n        a=find(a),b=find(b);\\n        if(a==b) return;\\n        if(len[a]<len[b]) swap(a,b);    // union_by_size //\\n        p[b]=a;\\n        len[a]+=len[b];\\n        return;\\n    }\\n    int bfs(vector<vector<int>>& g,queue<int>& q,bool vis[]){\\n        int k=q.size();\\n        while(k--){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &el:g[u]){\\n                if(vis[el]) continue;\\n                vis[el]=true;\\n                q.push(el);\\n            }\\n        }\\n        if(q.size()==0) return 0;\\n        return 1+bfs(g,q,vis);\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n+1);\\n         vector<int> _p(n+1),_len(n+1);\\n        this->p=_p,this->len=_len;\\n        for(int i=1;i<=n;i++) make(i);\\n        for(auto &el:edges){\\n            g[el[0]].push_back(el[1]);\\n            g[el[1]].push_back(el[0]);\\n            Union(el[0],el[1]);\\n        }\\n        vector<int> v(n+1,-1);\\n        function<bool(int,int)> check=[&](int i,int flag){\\n            bool ans=true;\\n            for(auto &el:g[i]){\\n                if(v[el]!=-1){\\n                    ans=ans&&(v[el]==(flag^1));\\n                }else{\\n                    v[el]=flag^1;\\n                    ans=ans&&check(el,flag^1);\\n                }\\n            }\\n            return ans;\\n        };\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(v[i]==-1) v[i]=0,ans=ans&&check(i,0);\\n        }\\n        if(!ans) return -1;\\n        int res=0;\\n        vector<int> v1(n+1,0);\\n        bool vis[n+1];\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            memset(vis,false,sizeof vis);\\n            while(!q.empty()) q.pop();\\n            vis[i]=true;\\n            q.push(i);\\n            v1[find(i)]=max(v1[find(i)],1+bfs(g,q,vis));\\n        }\\n        for(int i=0;i<=n;i++) res+=v1[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> p,len;\\n    void make(int node){\\n        p[node]=node;\\n        len[node]=1;\\n        return;\\n    }\\n    int find(int node){\\n        if(p[node]==node) return node;\\n        return p[node]=find(p[node]);   // path_compression //  // reverse_ackermann_function //\\n    }\\n    void Union(int a,int b){\\n        a=find(a),b=find(b);\\n        if(a==b) return;\\n        if(len[a]<len[b]) swap(a,b);    // union_by_size //\\n        p[b]=a;\\n        len[a]+=len[b];\\n        return;\\n    }\\n    int bfs(vector<vector<int>>& g,queue<int>& q,bool vis[]){\\n        int k=q.size();\\n        while(k--){\\n            int u=q.front();\\n            q.pop();\\n            for(auto &el:g[u]){\\n                if(vis[el]) continue;\\n                vis[el]=true;\\n                q.push(el);\\n            }\\n        }\\n        if(q.size()==0) return 0;\\n        return 1+bfs(g,q,vis);\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n+1);\\n         vector<int> _p(n+1),_len(n+1);\\n        this->p=_p,this->len=_len;\\n        for(int i=1;i<=n;i++) make(i);\\n        for(auto &el:edges){\\n            g[el[0]].push_back(el[1]);\\n            g[el[1]].push_back(el[0]);\\n            Union(el[0],el[1]);\\n        }\\n        vector<int> v(n+1,-1);\\n        function<bool(int,int)> check=[&](int i,int flag){\\n            bool ans=true;\\n            for(auto &el:g[i]){\\n                if(v[el]!=-1){\\n                    ans=ans&&(v[el]==(flag^1));\\n                }else{\\n                    v[el]=flag^1;\\n                    ans=ans&&check(el,flag^1);\\n                }\\n            }\\n            return ans;\\n        };\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(v[i]==-1) v[i]=0,ans=ans&&check(i,0);\\n        }\\n        if(!ans) return -1;\\n        int res=0;\\n        vector<int> v1(n+1,0);\\n        bool vis[n+1];\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            memset(vis,false,sizeof vis);\\n            while(!q.empty()) q.pop();\\n            vis[i]=true;\\n            q.push(i);\\n            v1[find(i)]=max(v1[find(i)],1+bfs(g,q,vis));\\n        }\\n        for(int i=0;i<=n;i++) res+=v1[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110879,
                "title": "java-union-find-bfs-easy-solution",
                "content": "```\\nclass Solution {\\n    public int magnificentSets(int n, int[][] edges) {\\n        List<Integer>[] adj = new ArrayList[n + 1];\\n        \\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        \\n        UnionFind uf = new UnionFind(n + 1);\\n        \\n        for (int[] edge : edges) {\\n            adj[edge[0]].add(edge[1]);\\n            adj[edge[1]].add(edge[0]);\\n            uf.union(edge[0], edge[1]);\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int root = uf.find(i);\\n            int k = bfs(i, adj);\\n            if (k < 0) \\n                return -1;\\n            map.put(root, Math.max(map.getOrDefault(root, 0), k));\\n        }\\n        \\n        int res = 0;\\n        \\n        for (int i : map.values()) {\\n            res += i;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int bfs(int i, List<Integer>[] adj){\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[adj.length];\\n        visited[i] = true;\\n        queue.addLast(i);\\n        int res = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            boolean[] tmp = new boolean[adj.length];\\n            while (size > 0) {\\n                int cur = queue.pollFirst();\\n                tmp[cur] = true;\\n                for (int x : adj[cur]) {\\n                    if (tmp[x]) \\n                        return -1;\\n                    if (!visited[x]) {\\n                        visited[x] = true;\\n                        queue.addLast(x);\\n                    }\\n                }\\n                size--;\\n            }\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass UnionFind {\\n    private int[] root;\\n    private int[] rank;\\n    private int count;\\n\\n    public UnionFind(int n) {\\n        count = n;\\n        root = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n\\n    public int find(int x) {\\n        if (x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    public boolean connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX]++;\\n            }\\n        }\\n        count--;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int magnificentSets(int n, int[][] edges) {\\n        List<Integer>[] adj = new ArrayList[n + 1];\\n        \\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        \\n        UnionFind uf = new UnionFind(n + 1);\\n        \\n        for (int[] edge : edges) {\\n            adj[edge[0]].add(edge[1]);\\n            adj[edge[1]].add(edge[0]);\\n            uf.union(edge[0], edge[1]);\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int root = uf.find(i);\\n            int k = bfs(i, adj);\\n            if (k < 0) \\n                return -1;\\n            map.put(root, Math.max(map.getOrDefault(root, 0), k));\\n        }\\n        \\n        int res = 0;\\n        \\n        for (int i : map.values()) {\\n            res += i;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int bfs(int i, List<Integer>[] adj){\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[adj.length];\\n        visited[i] = true;\\n        queue.addLast(i);\\n        int res = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            boolean[] tmp = new boolean[adj.length];\\n            while (size > 0) {\\n                int cur = queue.pollFirst();\\n                tmp[cur] = true;\\n                for (int x : adj[cur]) {\\n                    if (tmp[x]) \\n                        return -1;\\n                    if (!visited[x]) {\\n                        visited[x] = true;\\n                        queue.addLast(x);\\n                    }\\n                }\\n                size--;\\n            }\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass UnionFind {\\n    private int[] root;\\n    private int[] rank;\\n    private int count;\\n\\n    public UnionFind(int n) {\\n        count = n;\\n        root = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n\\n    public int find(int x) {\\n        if (x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    public boolean connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX]++;\\n            }\\n        }\\n        count--;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075390,
                "title": "beats-91-dfs-to-check-graph-is-bipartite-bfs-to-compute-groups",
                "content": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        \"\"\"\\n        we can solve this problem using breadth first search\\n        \"\"\"\\n        edge_map = {i: set() for i in range(1,n+1)}\\n        connected_comps = []\\n        total_seen = set()\\n\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n        \\n        def is_graph_bipartite(node, visited, color):\\n            visited[node] = color\\n            for nei in edge_map[node]:\\n                if nei in visited:\\n                    if visited[nei] == color:\\n                        return False\\n                else:\\n                    if not is_graph_bipartite(nei, visited, ~color):\\n                        return False\\n            return True\\n        \\n        for i in range(1, n+1):\\n            if i not in total_seen:\\n                visited = {}\\n                if not is_graph_bipartite(i, visited, 0):\\n                    return -1\\n                connected_comps.append(visited.keys())\\n                total_seen.update(visited.keys())\\n        \\n        def bfs(node, visited):\\n            que = deque([node])\\n            visited.add(node)\\n            level = 0\\n            while len(que):\\n                level+=1\\n                for _ in range(len(que)):\\n                    node = que.popleft()\\n                    for nei in edge_map[node]:\\n                        if nei not in visited:\\n                            que.append(nei)\\n                            visited.add(nei)\\n            return level\\n        \\n        ans = 0\\n        for comp in connected_comps:\\n            comp_max_groups = 0\\n            for node in comp:\\n                comp_max_groups = max(comp_max_groups, bfs(node, set()))\\n            ans+=comp_max_groups\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        \"\"\"\\n        we can solve this problem using breadth first search\\n        \"\"\"\\n        edge_map = {i: set() for i in range(1,n+1)}\\n        connected_comps = []\\n        total_seen = set()\\n\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n        \\n        def is_graph_bipartite(node, visited, color):\\n            visited[node] = color\\n            for nei in edge_map[node]:\\n                if nei in visited:\\n                    if visited[nei] == color:\\n                        return False\\n                else:\\n                    if not is_graph_bipartite(nei, visited, ~color):\\n                        return False\\n            return True\\n        \\n        for i in range(1, n+1):\\n            if i not in total_seen:\\n                visited = {}\\n                if not is_graph_bipartite(i, visited, 0):\\n                    return -1\\n                connected_comps.append(visited.keys())\\n                total_seen.update(visited.keys())\\n        \\n        def bfs(node, visited):\\n            que = deque([node])\\n            visited.add(node)\\n            level = 0\\n            while len(que):\\n                level+=1\\n                for _ in range(len(que)):\\n                    node = que.popleft()\\n                    for nei in edge_map[node]:\\n                        if nei not in visited:\\n                            que.append(nei)\\n                            visited.add(nei)\\n            return level\\n        \\n        ans = 0\\n        for comp in connected_comps:\\n            comp_max_groups = 0\\n            for node in comp:\\n                comp_max_groups = max(comp_max_groups, bfs(node, set()))\\n            ans+=comp_max_groups\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061574,
                "title": "python-bfs-solution-with-explanation-and-example",
                "content": "# Keypoint\\n1. For each connected-component, start from each node and do BFS. Each level of BFS is a single group. Find the BFS that returns maximum number of groups.\\n2. Sum BFS-result of all connected-components and it is the answer.\\n\\n# Note\\nCorrectness of point #1 may be not easy to prove. But it is quite intuitive through examples. \\n\\nOne good example is as follows:\\n```\\n  2\\n / \\\\\\n1   3\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        al = [[] for _ in range(n + 1)]\\n        for e in edges:\\n            al[e[0]].append(e[1])\\n            al[e[1]].append(e[0])\\n        root_visited = [False for _ in range(n + 1)]\\n        def partition(root):\\n            if root_visited[root]:\\n                return 0\\n            root_visited[root] = True\\n            q = [root]\\n            group = [-1 for _ in range(len(al))]\\n            group[root] = 0\\n            while q:\\n                q1 = []\\n                for i in q:\\n                    for j in al[i]:\\n                        if group[j] == -1:\\n                            group[j] = group[i] + 1\\n                            q1.append(j)\\n                        elif abs(group[i] - group[j]) != 1:\\n                            return -1\\n                q = q1\\n            res = 0\\n            for i in range(len(al)):\\n                if group[i] != -1:\\n                    res = max(res, group[i] + 1, partition(i))\\n            return res\\n        res = 0\\n        for i in range(1, n + 1):\\n            set_groups = partition(i)\\n            if set_groups == -1:\\n                return -1\\n            else:\\n                res += set_groups\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n  2\\n / \\\\\\n1   3\\n```\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        al = [[] for _ in range(n + 1)]\\n        for e in edges:\\n            al[e[0]].append(e[1])\\n            al[e[1]].append(e[0])\\n        root_visited = [False for _ in range(n + 1)]\\n        def partition(root):\\n            if root_visited[root]:\\n                return 0\\n            root_visited[root] = True\\n            q = [root]\\n            group = [-1 for _ in range(len(al))]\\n            group[root] = 0\\n            while q:\\n                q1 = []\\n                for i in q:\\n                    for j in al[i]:\\n                        if group[j] == -1:\\n                            group[j] = group[i] + 1\\n                            q1.append(j)\\n                        elif abs(group[i] - group[j]) != 1:\\n                            return -1\\n                q = q1\\n            res = 0\\n            for i in range(len(al)):\\n                if group[i] != -1:\\n                    res = max(res, group[i] + 1, partition(i))\\n            return res\\n        res = 0\\n        for i in range(1, n + 1):\\n            set_groups = partition(i)\\n            if set_groups == -1:\\n                return -1\\n            else:\\n                res += set_groups\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055877,
                "title": "imaginary-thread-most-optimised-python-bfs",
                "content": "# Intuition\\nLet all nodes be tied along a thread and placed on a pice of paper, now if we hold a node upwards untill there is some tension in the thread, now all the nodes will be vertically sequential. Here the longest thread will be our answer\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\n(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def magnificentSets(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n\\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        \\n        group_count_to_component_map = {}     \\n        node_to_component_map = {}\\n\\n        for node in range(1, n+1):\\n            level = 1\\n            queue = [node]\\n            #let component index be same as the node\\n            component_idx = node\\n\\n            #since we need to get the group size for all nodes in the component so a fresh node_to_component_idx_map is required if \\n            #the node is already part of the compoent and later on for swapping back a temp pointer is stored\\n            temp_map = node_to_component_map\\n\\n            if node in node_to_component_map:\\n                new_component = False\\n                component_idx = node_to_component_map[node]\\n                #this is done to calculate the size again\\n                node_to_component_map = {node:component_idx}\\n            else:\\n                node_to_component_map[node] = component_idx\\n                new_component = True\\n            \\n            while queue:\\n                current_breadth = set()\\n\\n                for _ in range(len(queue)):\\n                    current_breadth.add(queue.pop(0))\\n                \\n                next_group = []\\n\\n                for node in current_breadth:\\n                    for ngb in graph[node]:\\n                        if ngb in current_breadth:\\n                            return -1\\n\\n                        if ngb not in node_to_component_map:\\n                            node_to_component_map[ngb] = component_idx\\n                            next_group.append(ngb)\\n                \\n                if next_group:\\n                    level += 1\\n                \\n                queue = next_group\\n            \\n            node_to_component_map = temp_map\\n\\n            if new_component:\\n               group_count_to_component_map[component_idx] = level\\n            else:\\n                if level > group_count_to_component_map[component_idx]:\\n                    group_count_to_component_map[component_idx] = level\\n        \\n        count = 0\\n\\n        for component, g_size in group_count_to_component_map.items():\\n            count += g_size\\n        \\n        return count\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def magnificentSets(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n\\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        \\n        group_count_to_component_map = {}     \\n        node_to_component_map = {}\\n\\n        for node in range(1, n+1):\\n            level = 1\\n            queue = [node]\\n            #let component index be same as the node\\n            component_idx = node\\n\\n            #since we need to get the group size for all nodes in the component so a fresh node_to_component_idx_map is required if \\n            #the node is already part of the compoent and later on for swapping back a temp pointer is stored\\n            temp_map = node_to_component_map\\n\\n            if node in node_to_component_map:\\n                new_component = False\\n                component_idx = node_to_component_map[node]\\n                #this is done to calculate the size again\\n                node_to_component_map = {node:component_idx}\\n            else:\\n                node_to_component_map[node] = component_idx\\n                new_component = True\\n            \\n            while queue:\\n                current_breadth = set()\\n\\n                for _ in range(len(queue)):\\n                    current_breadth.add(queue.pop(0))\\n                \\n                next_group = []\\n\\n                for node in current_breadth:\\n                    for ngb in graph[node]:\\n                        if ngb in current_breadth:\\n                            return -1\\n\\n                        if ngb not in node_to_component_map:\\n                            node_to_component_map[ngb] = component_idx\\n                            next_group.append(ngb)\\n                \\n                if next_group:\\n                    level += 1\\n                \\n                queue = next_group\\n            \\n            node_to_component_map = temp_map\\n\\n            if new_component:\\n               group_count_to_component_map[component_idx] = level\\n            else:\\n                if level > group_count_to_component_map[component_idx]:\\n                    group_count_to_component_map[component_idx] = level\\n        \\n        count = 0\\n\\n        for component, g_size in group_count_to_component_map.items():\\n            count += g_size\\n        \\n        return count\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052723,
                "title": "c-3-observations-bipartite-graph-bfs",
                "content": "# 1. check if there is at least one solution\\n\\n> Observation 1: There is a solution if and only if there is no circle of odd size in the graph.\\n\\nOn the one hand, if there is a circle of odd size, then we consider the parity of the index of the group that each node on the circle belongs to. Then there must be two adjacent nodes on the circle that belong to groups with indices of the same parity. If two integers $x$ and $y$ have the same parity, then $|y - x|$ must not be $1$. Therefore, for any graph with a circle of odd size, there is no solution (i.e. the answer is $-1$).\\n\\nOn the other hand, if the graph has no circle of odd size, then it is a bipartite graph (this is a well-known theorem and we will not prove it). Namely, we can divide the nodes into two sets such that every edge connects two nodes from different sets. Thus, we can simply assign all nodes in the first set to group 1 and the other nodes to group 2, obtaining a valid way of division with 2 groups. Therefore, for any graph that has no circle of odd size, there is at least one solution (i.e. the answer is not $-1$).\\n\\n# 2. solve the problem for a connected graph\\n\\nIn this part, we consider how to solve the problem for a connected graph.\\n\\n> Observation 2: Once we have determined which nodes on the graph belong to group 1, then which group the other nodes belong to are all determined.\\n\\nThis is because when we know which nodes on the graph belong to group 1, then nodes in group 2 are just the nodes that are directly connected with at least one node in group 1; nodes in group 3 are just the nodes that are directly connected with at least one node in group 2... We can determine them layer by layer with a bfs.\\n\\nHowever, there are $\\\\mathcal{O}(2^n)$ possible sets of nodes for group 1, and we cannot afford trying all of them. Therefore, we need one more important observation.\\n\\n> Observation 3: There is always one best solution in which group 1 contains only one node.\\n\\nConsider the best solution. If group 1 contains multiple nodes, then we keep any one of them. The remaining nodes in group 1 are all directly connected only with nodes in group 2. We remove them from group 1 and add them to group 3. After this adjustment, the solution is still valid and the number of groups either stays unchanged or increases by $1$ (if there are only $2$ groups orginally). Hence, there is always one best solution in which group 1 contains only one node.\\n\\nTherefore, we can enumerate which node is the one in group 1 and determine how do divide the rest nodes with a bfs. After $n$ iterations, we take the maximum result as the answer. The time complexity is $\\\\mathcal{O}(n \\\\cdot (n + m))$, with $n$ for enumerating the node in group 1 and $(n + m)$ for bfs.\\n\\n# 3. for disconnected graph\\n\\nIf at least one of the connected components has not solution, the whole graph has no solution (i.e. the answer is $-1$). Otherwise, just solve the problem for each connected component and add the answers up to be the final answer.\\n\\nThe time complexity is $\\\\mathcal{O}(n \\\\cdot (n + m))$.\\n\\n# 4. fun fact\\n\\nThe process of beginning with one node and doing bfs is equivalent to finding the maximum length of the shortest path between that node and any other nodes. Therefore, the answer for one connected component is just the maximum of minimum distances between all nodes in it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int c[505];\\n    vector<int> g[505];\\n    bool dfs(int u, vector<int>& nodes) {\\n        nodes.push_back(u);\\n        for (int i = 0; i < (int)g[u].size(); ++i) {\\n            int v = g[u][i];\\n            if (c[v]) {\\n                if (c[v] == c[u]) {\\n                    return false;\\n                } else {\\n                    continue;\\n                }\\n            }\\n            c[v] = 3 - c[u]; // color: 1 or 2\\n            if (!dfs(v, nodes)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int d[505];\\n    int bfs(int st) {\\n        queue<int> q;\\n        q.push(st);\\n        d[st] = 1;\\n        int res = 0;\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            res = max(res, d[u]);\\n            for (int i = 0; i < (int)g[u].size(); ++i) {\\n                int v = g[u][i];\\n                if (!d[v]) {\\n                    d[v] = d[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    int solve(vector<int>& nodes) {\\n        int res = 0;\\n        for (int i = 0; i < (int)nodes.size(); ++i) {\\n            int u = nodes[i];\\n            for (int j = 0; j < (int)nodes.size(); ++j) {\\n                d[nodes[j]] = 0;\\n            }\\n            res = max(res, bfs(u));\\n        }\\n        return res;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < (int)edges.size(); ++i) {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            c[i] = 0;\\n            d[i] = 0;\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!c[i]) {\\n                // cout << i << endl;\\n                vector<int> nodes;\\n                c[i] = 1; // color: 1 or 2\\n                if (!dfs(i, nodes)) { // not bipartite\\n                    return -1;\\n                }\\n                ans += solve(nodes);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c[505];\\n    vector<int> g[505];\\n    bool dfs(int u, vector<int>& nodes) {\\n        nodes.push_back(u);\\n        for (int i = 0; i < (int)g[u].size(); ++i) {\\n            int v = g[u][i];\\n            if (c[v]) {\\n                if (c[v] == c[u]) {\\n                    return false;\\n                } else {\\n                    continue;\\n                }\\n            }\\n            c[v] = 3 - c[u]; // color: 1 or 2\\n            if (!dfs(v, nodes)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int d[505];\\n    int bfs(int st) {\\n        queue<int> q;\\n        q.push(st);\\n        d[st] = 1;\\n        int res = 0;\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            res = max(res, d[u]);\\n            for (int i = 0; i < (int)g[u].size(); ++i) {\\n                int v = g[u][i];\\n                if (!d[v]) {\\n                    d[v] = d[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    int solve(vector<int>& nodes) {\\n        int res = 0;\\n        for (int i = 0; i < (int)nodes.size(); ++i) {\\n            int u = nodes[i];\\n            for (int j = 0; j < (int)nodes.size(); ++j) {\\n                d[nodes[j]] = 0;\\n            }\\n            res = max(res, bfs(u));\\n        }\\n        return res;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < (int)edges.size(); ++i) {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            c[i] = 0;\\n            d[i] = 0;\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!c[i]) {\\n                // cout << i << endl;\\n                vector<int> nodes;\\n                c[i] = 1; // color: 1 or 2\\n                if (!dfs(i, nodes)) { // not bipartite\\n                    return -1;\\n                }\\n                ans += solve(nodes);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2955828,
                "title": "c-2-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findComponent(int root, vector<vector<int>>& graph, vector<bool>& visited) {\\n        queue<int> que;\\n        unordered_set<int> component;\\n        que.push(root);\\n        component.insert(root);\\n        visited[root] = true;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int i = 0; i < size; ++i) {\\n                auto top = que.front();\\n                que.pop();\\n                for (auto nei : graph[top]) {\\n                    if (!component.count(nei)) {\\n                        que.push(nei);\\n                        component.insert(nei);\\n                        visited[nei] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return vector<int>(component.begin(), component.end());\\n    }\\n\\n    int countGroup(vector<int>& component, vector<vector<int>>& graph, int n) {\\n        int ma = 0;\\n        for (auto root : component) {\\n            // bfs to count groups\\n            int group = 0;\\n            queue<int> que;\\n            que.push(root);\\n            vector<bool> visited(n + 1);\\n            unordered_set<int> curGroup;\\n            unordered_set<int> nextGroup;\\n            curGroup.insert(root);\\n            visited[root] = true;\\n            while (!que.empty()) {\\n                int size = que.size();\\n                curGroup = nextGroup;\\n                nextGroup.clear();\\n                for (int i = 0; i < size; ++i) {\\n                    auto front = que.front();\\n                    que.pop();\\n                    for (auto nei : graph[front]) {\\n                        if (curGroup.count(nei)) {\\n                            return -1;\\n                        }\\n                        if (!visited[nei]) {\\n                            visited[nei] = true;\\n                            nextGroup.insert(nei);\\n                            que.push(nei);\\n                        }\\n                    }\\n                }\\n                ++group;\\n            }\\n            // cout << root << \" \" << group << endl;\\n            ma = max(ma, group);\\n        }\\n        return ma;\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<bool> visited(n + 1);\\n        vector<vector<int>> graph(n + 1);\\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int result = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!visited[i]) {\\n                vector<int> component = findComponent(i, graph, visited);\\n                int group = countGroup(component, graph, n);\\n                if (group == -1) {\\n                    return -1;\\n                }\\n                result += group;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findComponent(int root, vector<vector<int>>& graph, vector<bool>& visited) {\\n        queue<int> que;\\n        unordered_set<int> component;\\n        que.push(root);\\n        component.insert(root);\\n        visited[root] = true;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int i = 0; i < size; ++i) {\\n                auto top = que.front();\\n                que.pop();\\n                for (auto nei : graph[top]) {\\n                    if (!component.count(nei)) {\\n                        que.push(nei);\\n                        component.insert(nei);\\n                        visited[nei] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return vector<int>(component.begin(), component.end());\\n    }\\n\\n    int countGroup(vector<int>& component, vector<vector<int>>& graph, int n) {\\n        int ma = 0;\\n        for (auto root : component) {\\n            // bfs to count groups\\n            int group = 0;\\n            queue<int> que;\\n            que.push(root);\\n            vector<bool> visited(n + 1);\\n            unordered_set<int> curGroup;\\n            unordered_set<int> nextGroup;\\n            curGroup.insert(root);\\n            visited[root] = true;\\n            while (!que.empty()) {\\n                int size = que.size();\\n                curGroup = nextGroup;\\n                nextGroup.clear();\\n                for (int i = 0; i < size; ++i) {\\n                    auto front = que.front();\\n                    que.pop();\\n                    for (auto nei : graph[front]) {\\n                        if (curGroup.count(nei)) {\\n                            return -1;\\n                        }\\n                        if (!visited[nei]) {\\n                            visited[nei] = true;\\n                            nextGroup.insert(nei);\\n                            que.push(nei);\\n                        }\\n                    }\\n                }\\n                ++group;\\n            }\\n            // cout << root << \" \" << group << endl;\\n            ma = max(ma, group);\\n        }\\n        return ma;\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<bool> visited(n + 1);\\n        vector<vector<int>> graph(n + 1);\\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int result = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!visited[i]) {\\n                vector<int> component = findComponent(i, graph, visited);\\n                int group = countGroup(component, graph, n);\\n                if (group == -1) {\\n                    return -1;\\n                }\\n                result += group;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2941685,
                "title": "c-simple-bfs-starts-from-all-nodes",
                "content": "# Complexity\\n- Time complexity:\\nO(|V| * |E|)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> mp(n + 1);\\n        vector<vector<int>> groups;\\n        vector<int> all_res(n+1, 0);\\n        vector<int> vis(n+1, 0);\\n        for(auto& e : edges) {\\n            mp[e[0]].push_back(e[1]);\\n            mp[e[1]].push_back(e[0]);\\n        }\\n        int res = 0;\\n        int group_cnt = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            int first = 1- vis[i];\\n            if (first) groups.push_back(vector<int>());\\n            int sub_res = 0;\\n            vector<int> mark(n + 1, 0);\\n            queue<int> qe;\\n            qe.push(i);\\n            mark[i] = 1;\\n            while (!qe.empty()) {\\n                int cur = qe.front();\\n                qe.pop();\\n                vis[cur] = 1;\\n                if (first) {\\n                    groups[groups.size() - 1].push_back(cur);\\n                }\\n                sub_res = max(sub_res, mark[cur]);\\n                for (int next : mp[cur]) {\\n                    if (mark[next]) {\\n                        if (abs(mark[next] - mark[cur]) != 1) return -1;\\n                        continue;\\n                    }\\n                    qe.push(next);\\n                    mark[next] = mark[cur] + 1;\\n                }\\n            }\\n            all_res[i] = sub_res;\\n        }\\n        for (auto group: groups) {\\n            int sub_res = 0;\\n            for (int k : group) {\\n                sub_res = max(sub_res, all_res[k]);\\n            }\\n            res += sub_res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> mp(n + 1);\\n        vector<vector<int>> groups;\\n        vector<int> all_res(n+1, 0);\\n        vector<int> vis(n+1, 0);\\n        for(auto& e : edges) {\\n            mp[e[0]].push_back(e[1]);\\n            mp[e[1]].push_back(e[0]);\\n        }\\n        int res = 0;\\n        int group_cnt = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            int first = 1- vis[i];\\n            if (first) groups.push_back(vector<int>());\\n            int sub_res = 0;\\n            vector<int> mark(n + 1, 0);\\n            queue<int> qe;\\n            qe.push(i);\\n            mark[i] = 1;\\n            while (!qe.empty()) {\\n                int cur = qe.front();\\n                qe.pop();\\n                vis[cur] = 1;\\n                if (first) {\\n                    groups[groups.size() - 1].push_back(cur);\\n                }\\n                sub_res = max(sub_res, mark[cur]);\\n                for (int next : mp[cur]) {\\n                    if (mark[next]) {\\n                        if (abs(mark[next] - mark[cur]) != 1) return -1;\\n                        continue;\\n                    }\\n                    qe.push(next);\\n                    mark[next] = mark[cur] + 1;\\n                }\\n            }\\n            all_res[i] = sub_res;\\n        }\\n        for (auto group: groups) {\\n            int sub_res = 0;\\n            for (int k : group) {\\n                sub_res = max(sub_res, all_res[k]);\\n            }\\n            res += sub_res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940752,
                "title": "c-easy-fast-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*(N+E))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isValid(vector<int> adj[],int n,int src,vector<int> &color)\\n{\\n    queue<int> q;\\n    q.push(src);\\n    color[src]=0;\\n    while(q.empty()==false)\\n    {\\n        int node=q.front();\\n        q.pop();\\n        for(int it:adj[node])\\n        {\\n            if(color[it]==-1)\\n            {\\n                color[it]=!color[node];\\n                q.push(it);\\n            }\\n            else if(color[it]==color[node])\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nint bfs(vector<int> adj[], int curr, int n)\\n    {\\n        vector<bool> vis(n + 1, 0);\\n \\n        queue<int> q;\\n        q.push(curr);\\n        vis[curr] = 1;\\n \\n        int cnt = 0;\\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n \\n            for (int i = 0; i < size; i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n \\n                for (auto nxt : adj[node])\\n                {\\n                    if (vis[nxt] == 0)\\n                    {\\n                        q.push(nxt);\\n                        vis[nxt] = 1;\\n                    }\\n                }\\n            }\\n            cnt++;\\n        }\\n \\n \\n        return cnt;\\n    }\\n    int ans;\\n    void dfs(vector<int> adj[],int src,vector<bool> &vis,vector<int> &dist)\\n    {\\n        vis[src]=true;\\n        ans=max(ans,dist[src]);\\n        for(auto it:adj[src])\\n        {\\n            if(vis[it]==false)\\n            {\\n                dfs(adj,it,vis,dist);\\n            }\\n        }\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        int N=edges.size();\\n        for(int i=0;i<N;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> color(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(isValid(adj,n,i,color)==false)\\n                return -1;\\n            }\\n        }\\n\\n        vector<int> dist(n+1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            dist[i]=bfs(adj,i,n);\\n        }\\n        vector<bool> vis(n+1,false);\\n        int res=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans=INT_MIN;\\n            if(vis[i]==false)\\n            {\\n               dfs(adj,i,vis,dist);\\n               res+=ans;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isValid(vector<int> adj[],int n,int src,vector<int> &color)\\n{\\n    queue<int> q;\\n    q.push(src);\\n    color[src]=0;\\n    while(q.empty()==false)\\n    {\\n        int node=q.front();\\n        q.pop();\\n        for(int it:adj[node])\\n        {\\n            if(color[it]==-1)\\n            {\\n                color[it]=!color[node];\\n                q.push(it);\\n            }\\n            else if(color[it]==color[node])\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nint bfs(vector<int> adj[], int curr, int n)\\n    {\\n        vector<bool> vis(n + 1, 0);\\n \\n        queue<int> q;\\n        q.push(curr);\\n        vis[curr] = 1;\\n \\n        int cnt = 0;\\n        while (!q.empty())\\n        {\\n            int size = q.size();\\n \\n            for (int i = 0; i < size; i++)\\n            {\\n                int node = q.front();\\n                q.pop();\\n \\n                for (auto nxt : adj[node])\\n                {\\n                    if (vis[nxt] == 0)\\n                    {\\n                        q.push(nxt);\\n                        vis[nxt] = 1;\\n                    }\\n                }\\n            }\\n            cnt++;\\n        }\\n \\n \\n        return cnt;\\n    }\\n    int ans;\\n    void dfs(vector<int> adj[],int src,vector<bool> &vis,vector<int> &dist)\\n    {\\n        vis[src]=true;\\n        ans=max(ans,dist[src]);\\n        for(auto it:adj[src])\\n        {\\n            if(vis[it]==false)\\n            {\\n                dfs(adj,it,vis,dist);\\n            }\\n        }\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        int N=edges.size();\\n        for(int i=0;i<N;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> color(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(isValid(adj,n,i,color)==false)\\n                return -1;\\n            }\\n        }\\n\\n        vector<int> dist(n+1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            dist[i]=bfs(adj,i,n);\\n        }\\n        vector<bool> vis(n+1,false);\\n        int res=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans=INT_MIN;\\n            if(vis[i]==false)\\n            {\\n               dfs(adj,i,vis,dist);\\n               res+=ans;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932308,
                "title": "python-bfs-o-n-m-n-90-faster",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        def bfs(G, v):\\n            que = deque([v])\\n            visited = set([v])\\n            level = 0\\n            while que:\\n                level += 1\\n                nxtque = deque()\\n                curlevel = set(que)\\n                while que:\\n                    v = que.popleft()\\n                    for w in G[v]:\\n                        if w in curlevel: return -1\\n                        if w in visited: continue\\n                        nxtque.append(w)\\n                        visited.add(w)\\n                que = nxtque\\n            return level\\n        G = defaultdict(list)\\n        for v, w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        components = []\\n        global_visited = set()\\n        res = 0\\n        for v in range(1, n+1):\\n            if v in global_visited: continue\\n            que = deque([v])\\n            visited = set()\\n            while que:\\n                w = que.popleft()\\n                if w in visited: continue\\n                visited.add(w)\\n                for x in G[w]:\\n                    que.append(x)\\n            components.append(visited)\\n            for w in visited:\\n                global_visited.add(w)\\n        longest = [-1]*len(components)\\n        for i in range(len(components)):\\n            for v in components[i]:\\n                tmp = bfs(G,v)\\n                if tmp < 0: return -1\\n                longest[i] = max(longest[i], tmp)\\n        return sum(longest)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        def bfs(G, v):\\n            que = deque([v])\\n            visited = set([v])\\n            level = 0\\n            while que:\\n                level += 1\\n                nxtque = deque()\\n                curlevel = set(que)\\n                while que:\\n                    v = que.popleft()\\n                    for w in G[v]:\\n                        if w in curlevel: return -1\\n                        if w in visited: continue\\n                        nxtque.append(w)\\n                        visited.add(w)\\n                que = nxtque\\n            return level\\n        G = defaultdict(list)\\n        for v, w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        components = []\\n        global_visited = set()\\n        res = 0\\n        for v in range(1, n+1):\\n            if v in global_visited: continue\\n            que = deque([v])\\n            visited = set()\\n            while que:\\n                w = que.popleft()\\n                if w in visited: continue\\n                visited.add(w)\\n                for x in G[w]:\\n                    que.append(x)\\n            components.append(visited)\\n            for w in visited:\\n                global_visited.add(w)\\n        longest = [-1]*len(components)\\n        for i in range(len(components)):\\n            for v in components[i]:\\n                tmp = bfs(G,v)\\n                if tmp < 0: return -1\\n                longest[i] = max(longest[i], tmp)\\n        return sum(longest)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924428,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn magnificent_sets(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::HashMap;\\n        use std::collections::VecDeque;\\n\\n        fn bfs(adj: &Vec<Vec<usize>>, s: usize) -> (i32, usize, i32) {\\n            let n = adj.len();\\n            let mut id = usize::MAX;\\n            let mut groups = 0;\\n            let mut level = vec![0; n + 1];\\n            level[s] = 1;\\n            let mut q = VecDeque::new();\\n            q.push_back((s, 1));\\n\\n            while let Some((node, depth)) = q.pop_front() {\\n                groups = groups.max(depth);\\n                id = id.min(node);\\n                for &next in &adj[node] {\\n                    if level[next] == 0 {\\n                        level[next] = depth + 1;\\n                        q.push_back((next, depth + 1));\\n                    } else if level[next] == depth {\\n                        return (-1, 0, 0);\\n                    }\\n                }\\n            }\\n            (0, id, groups)\\n        }\\n\\n        let n = n as usize;\\n        let mut adj = vec![vec![]; n + 1];\\n        for e in edges {\\n            let a = e[0] as usize;\\n            let b = e[1] as usize;\\n            adj[a].push(b);\\n            adj[b].push(a);\\n        }\\n        let mut map: HashMap<usize, i32> = HashMap::new();\\n        for i in 1..=n {\\n            let (f, id, groups) = bfs(&adj, i);\\n            if f == -1 {\\n                return -1;\\n            }\\n            if let Some(&v) = map.get(&id) {\\n                map.insert(id, v.max(groups));\\n            } else {\\n                map.insert(id, groups);\\n            }\\n        }\\n        let mut res = 0;\\n        for &v in map.values() {\\n            res += v;\\n        }\\n        res\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn magnificent_sets(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::HashMap;\\n        use std::collections::VecDeque;\\n\\n        fn bfs(adj: &Vec<Vec<usize>>, s: usize) -> (i32, usize, i32) {\\n            let n = adj.len();\\n            let mut id = usize::MAX;\\n            let mut groups = 0;\\n            let mut level = vec![0; n + 1];\\n            level[s] = 1;\\n            let mut q = VecDeque::new();\\n            q.push_back((s, 1));\\n\\n            while let Some((node, depth)) = q.pop_front() {\\n                groups = groups.max(depth);\\n                id = id.min(node);\\n                for &next in &adj[node] {\\n                    if level[next] == 0 {\\n                        level[next] = depth + 1;\\n                        q.push_back((next, depth + 1));\\n                    } else if level[next] == depth {\\n                        return (-1, 0, 0);\\n                    }\\n                }\\n            }\\n            (0, id, groups)\\n        }\\n\\n        let n = n as usize;\\n        let mut adj = vec![vec![]; n + 1];\\n        for e in edges {\\n            let a = e[0] as usize;\\n            let b = e[1] as usize;\\n            adj[a].push(b);\\n            adj[b].push(a);\\n        }\\n        let mut map: HashMap<usize, i32> = HashMap::new();\\n        for i in 1..=n {\\n            let (f, id, groups) = bfs(&adj, i);\\n            if f == -1 {\\n                return -1;\\n            }\\n            if let Some(&v) = map.get(&id) {\\n                map.insert(id, v.max(groups));\\n            } else {\\n                map.insert(id, groups);\\n            }\\n        }\\n        let mut res = 0;\\n        for &v in map.values() {\\n            res += v;\\n        }\\n        res\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2914639,
                "title": "python-short-answer-only-use-bfs",
                "content": "I just translate the following solution from C++ to python.\\nhttps://github.com/wisdompeak/LeetCode/blob/master/BFS/2493.Divide-Nodes-Into-the-Maximum-Number-of-Groups/2493.Divide-Nodes-Into-the-Maximum-Number-of-Groups.cpp\\n\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        gragh = defaultdict(list)\\n        for x, y in edges:\\n            gragh[x].append(y)\\n            gragh[y].append(x)\\n        \\n        ans = defaultdict(int)\\n        for i in range(1, n + 1):\\n            level = defaultdict(int)\\n            queue = deque([i])\\n            level[i] = 1\\n            d = 0\\n            smallestID = i\\n            while queue:\\n                d += 1\\n                for _ in range(len(queue)):\\n                    node = queue.popleft()\\n                    for next_node in gragh[node]:\\n                        if level[next_node] == d:\\n                            return -1\\n                        elif level[next_node] == 0:\\n                            level[next_node] = d + 1\\n                            queue.append(next_node)\\n                            smallestID = min(smallestID, next_node)\\n            ans[smallestID] = max(ans[smallestID], d)\\n\\n        return sum(ans.values())\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        gragh = defaultdict(list)\\n        for x, y in edges:\\n            gragh[x].append(y)\\n            gragh[y].append(x)\\n        \\n        ans = defaultdict(int)\\n        for i in range(1, n + 1):\\n            level = defaultdict(int)\\n            queue = deque([i])\\n            level[i] = 1\\n            d = 0\\n            smallestID = i\\n            while queue:\\n                d += 1\\n                for _ in range(len(queue)):\\n                    node = queue.popleft()\\n                    for next_node in gragh[node]:\\n                        if level[next_node] == d:\\n                            return -1\\n                        elif level[next_node] == 0:\\n                            level[next_node] = d + 1\\n                            queue.append(next_node)\\n                            smallestID = min(smallestID, next_node)\\n            ans[smallestID] = max(ans[smallestID], d)\\n\\n        return sum(ans.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902077,
                "title": "java-solution-using-bfs-detailed-explanation",
                "content": "# Intuition\\nWe have to do simple bfs here to get the solution, but we have to find the node from which we have to start to get the max groups. So, we have to preform bfs for every node and take the max of them. \\n\\n# Approach\\nForm a adj list, a visited array, this wil be interesting, in this visitetd array we will storing values based on the components as we are visiting the nodes again and again, we want max of same component nodes, while we add groups of other components. So, visited array will be filled with components number, going throuhg code will be more easier to understand.\\nThen, do bfs for every node of every components, find max and return max.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(v*(V+2E))\\n\\n- Space complexity:\\nO(v+E)\\n\\n# Code\\n```\\nclass Solution {\\n    public int magnificentSets(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        int[] visited = new int[n+1];\\n        Arrays.fill(visited,-1);\\n        for(int i=0; i<=n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0; i<edges.length; i++) {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int[] comp = new int[n+1];\\n        int count = -1, ans = 0;\\n        for(int i=1; i<=n; i++) {\\n            if(visited[i]==-1) {\\n                count++;\\n                comp[count] = bfs(i,adj,visited,count,n);\\n                if(comp[count]==-1) return -1;\\n            }\\n            else {\\n                comp[visited[i]] = Math.max(comp[visited[i]],bfs(i,adj,visited,visited[i],n)); \\n            }\\n        }\\n        for(int group : comp) {\\n            ans += group;\\n        }\\n        return ans;\\n    }\\n    \\n    private int bfs(int start, List<List<Integer>> adj, int[] visited, int count, int n) {\\n        Queue<Integer> q = new LinkedList<>();\\n        visited[start] = count;\\n        int ans = 1;\\n        int[] group = new int[n+1];\\n        q.add(start);\\n        group[start] = 1;\\n        while(!q.isEmpty()) {\\n            int node = q.remove();\\n            for(int adjN : adj.get(node)) {\\n                if(group[adjN]==0) {\\n                    visited[adjN] = count;\\n                    group[adjN] = group[node]+1;\\n                    q.add(adjN);\\n                    ans = Math.max(ans,group[adjN]);\\n                }\\n                else if(Math.abs(group[adjN]-group[node])!=1) return -1;\\n             }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int magnificentSets(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        int[] visited = new int[n+1];\\n        Arrays.fill(visited,-1);\\n        for(int i=0; i<=n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0; i<edges.length; i++) {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int[] comp = new int[n+1];\\n        int count = -1, ans = 0;\\n        for(int i=1; i<=n; i++) {\\n            if(visited[i]==-1) {\\n                count++;\\n                comp[count] = bfs(i,adj,visited,count,n);\\n                if(comp[count]==-1) return -1;\\n            }\\n            else {\\n                comp[visited[i]] = Math.max(comp[visited[i]],bfs(i,adj,visited,visited[i],n)); \\n            }\\n        }\\n        for(int group : comp) {\\n            ans += group;\\n        }\\n        return ans;\\n    }\\n    \\n    private int bfs(int start, List<List<Integer>> adj, int[] visited, int count, int n) {\\n        Queue<Integer> q = new LinkedList<>();\\n        visited[start] = count;\\n        int ans = 1;\\n        int[] group = new int[n+1];\\n        q.add(start);\\n        group[start] = 1;\\n        while(!q.isEmpty()) {\\n            int node = q.remove();\\n            for(int adjN : adj.get(node)) {\\n                if(group[adjN]==0) {\\n                    visited[adjN] = count;\\n                    group[adjN] = group[node]+1;\\n                    q.add(adjN);\\n                    ans = Math.max(ans,group[adjN]);\\n                }\\n                else if(Math.abs(group[adjN]-group[node])!=1) return -1;\\n             }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895924,
                "title": "bipartite-bfs",
                "content": "# Intuition\\nCheck max levels possible from every node in disconnected graph\\n\\n# Approach\\n1) Check if bipartite (DFS)\\n2) While checking biparitite give same color to nodes in same component\\n3) If bipartite run (BFS) to figure out max no.of levels of that component\\n4) Add max levels of all disconnected components\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)- We run bfs for every node\\n\\n- Space complexity:\\nO(V+E)- use external map ,adjacency list,queue,color vector,comp vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int node,vector<int>*adj,vector<int>&color,vector<int>&comp,int c){\\n        for(auto x:adj[node]){\\n            comp[x]=c;\\n            if(color[x]==-1){\\n                color[x]=1^color[node];\\n                if(!dfs(x,adj,color,comp,c)){\\n                    return false;\\n                }\\n            }\\n            else if(color[x]==color[node]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n\\n        vector<int>color(n+1,-1);\\n        color[1]=0;\\n        vector<int>comp(n+1,-1);\\n        int c=-1;\\n        for(int i=1;i<=n;i++){\\n            if(comp[i]==-1){\\n                c++;\\n                comp[i]=c;\\n                if(!dfs(i,adj,color,comp,c))\\n                    return -1;\\n            }\\n        }\\n\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<=c;i++){\\n            mp[i]=0;\\n        }\\n            for(int i=1;i<=n;i++){\\n                queue<int>q;\\n                int level=0;\\n                q.push(i);\\n                vector<int>vis(n+1);\\n                vis[i]=1;\\n                while(!q.empty()){\\n                    int qlen=q.size();\\n                    level++;\\n                    for(int j=0;j<qlen;j++){\\n                        auto x=q.front();\\n                        q.pop();\\n                        for(auto nbr:adj[x]){\\n                            if(!vis[nbr]){\\n                                q.push(nbr);\\n                                vis[nbr]=1;\\n                            }\\n                        }\\n                    }\\n                }\\n                mp[comp[i]]=max(mp[comp[i]],level);\\n            }\\n            \\n            int len=0;\\n            for(int i=0;i<=c;i++)\\n                len+=mp[i];\\n            return len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int node,vector<int>*adj,vector<int>&color,vector<int>&comp,int c){\\n        for(auto x:adj[node]){\\n            comp[x]=c;\\n            if(color[x]==-1){\\n                color[x]=1^color[node];\\n                if(!dfs(x,adj,color,comp,c)){\\n                    return false;\\n                }\\n            }\\n            else if(color[x]==color[node]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n\\n        vector<int>color(n+1,-1);\\n        color[1]=0;\\n        vector<int>comp(n+1,-1);\\n        int c=-1;\\n        for(int i=1;i<=n;i++){\\n            if(comp[i]==-1){\\n                c++;\\n                comp[i]=c;\\n                if(!dfs(i,adj,color,comp,c))\\n                    return -1;\\n            }\\n        }\\n\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<=c;i++){\\n            mp[i]=0;\\n        }\\n            for(int i=1;i<=n;i++){\\n                queue<int>q;\\n                int level=0;\\n                q.push(i);\\n                vector<int>vis(n+1);\\n                vis[i]=1;\\n                while(!q.empty()){\\n                    int qlen=q.size();\\n                    level++;\\n                    for(int j=0;j<qlen;j++){\\n                        auto x=q.front();\\n                        q.pop();\\n                        for(auto nbr:adj[x]){\\n                            if(!vis[nbr]){\\n                                q.push(nbr);\\n                                vis[nbr]=1;\\n                            }\\n                        }\\n                    }\\n                }\\n                mp[comp[i]]=max(mp[comp[i]],level);\\n            }\\n            \\n            int len=0;\\n            for(int i=0;i<=c;i++)\\n                len+=mp[i];\\n            return len;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893665,
                "title": "easy-intutive-c-solution",
                "content": "# Intuition\\nFor all the Nodes that are connected in a single component we can find the best grouping arrangement for these nodes. We can find this best grouping arrangement for all the components and add them.\\n\\nWhat is Best grouping arrangement?\\nFor any connected graph(For Non-Bipatite Graph answer is -1) that can be converted into groups the number of group will depend on what node we start giving numbers from.\\n\\nFor example in graph:\\n[[1,2],[2,3]]  if we start giving group numbers from node 2 we can only have 2 groups . (group 1- [2]   group 2- [1,3])\\n\\nSince the constraints are low we can brute force to find this starting node.\\n\\n# Complexity\\n- Time complexity: O( V * ( V + E ))\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n   void dfs(vector<int> arr[], int s, vector<bool> &v, int &max1,int &f,int n)\\n   {\\n        v[s] = 1;\\n        queue<int> q;\\n        vector<int> ans(n + 1, -1);\\n        vector<bool> vis(n+1,0);\\n        vis[s] = 1;\\n        ans[s] = 1;\\n        int a=1;\\n        q.push(s);\\n        while (!q.empty())\\n        {\\n           int nd = q.front();\\n           q.pop();\\n           a = max(a, ans[nd]);\\n           for (auto i : arr[nd])\\n           {\\n              if (vis[i] == 0)\\n              {\\n                 ans[i] = ans[nd] + 1;\\n                 q.push(i);\\n                 vis[i] = 1;\\n              }\\n              else\\n              {\\n                 if (ans[i] != -1 && (abs(ans[i] - ans[nd]) != 1))\\n                 {\\n                    f=1;\\n                    return;\\n                 }\\n              }\\n           }\\n        }\\n        max1=max(max1,a);\\n        for (auto i : arr[s])\\n        {\\n         if (v[i] == 0)\\n         {\\n            dfs(arr, i, v, max1,f,n);\\n         }\\n        }\\n   }\\n   int magnificentSets(int n, vector<vector<int>> &edges)\\n   {\\n      vector<int> arr[n + 1];\\n      for (auto i : edges)\\n      {\\n         arr[i[0]].push_back(i[1]);\\n         arr[i[1]].push_back(i[0]);\\n      }\\n      int answer = 0;\\n      vector<bool> v(n + 1, 0);\\n      for (int i=1;i<=n;i++)\\n      {\\n         if (v[i] == 0)\\n         {\\n            int max1 = 0,f=0;\\n            dfs(arr, i, v, max1,f,n);\\n            answer+=max1;\\n            if(f) return -1;\\n         }\\n      }\\n      return answer;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n   void dfs(vector<int> arr[], int s, vector<bool> &v, int &max1,int &f,int n)\\n   {\\n        v[s] = 1;\\n        queue<int> q;\\n        vector<int> ans(n + 1, -1);\\n        vector<bool> vis(n+1,0);\\n        vis[s] = 1;\\n        ans[s] = 1;\\n        int a=1;\\n        q.push(s);\\n        while (!q.empty())\\n        {\\n           int nd = q.front();\\n           q.pop();\\n           a = max(a, ans[nd]);\\n           for (auto i : arr[nd])\\n           {\\n              if (vis[i] == 0)\\n              {\\n                 ans[i] = ans[nd] + 1;\\n                 q.push(i);\\n                 vis[i] = 1;\\n              }\\n              else\\n              {\\n                 if (ans[i] != -1 && (abs(ans[i] - ans[nd]) != 1))\\n                 {\\n                    f=1;\\n                    return;\\n                 }\\n              }\\n           }\\n        }\\n        max1=max(max1,a);\\n        for (auto i : arr[s])\\n        {\\n         if (v[i] == 0)\\n         {\\n            dfs(arr, i, v, max1,f,n);\\n         }\\n        }\\n   }\\n   int magnificentSets(int n, vector<vector<int>> &edges)\\n   {\\n      vector<int> arr[n + 1];\\n      for (auto i : edges)\\n      {\\n         arr[i[0]].push_back(i[1]);\\n         arr[i[1]].push_back(i[0]);\\n      }\\n      int answer = 0;\\n      vector<bool> v(n + 1, 0);\\n      for (int i=1;i<=n;i++)\\n      {\\n         if (v[i] == 0)\\n         {\\n            int max1 = 0,f=0;\\n            dfs(arr, i, v, max1,f,n);\\n            answer+=max1;\\n            if(f) return -1;\\n         }\\n      }\\n      return answer;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884772,
                "title": "python3-union-find-bfs-solution",
                "content": "# Intuition\\nfirst use union find to group all the connected nodes\\n\\nfor each group, try every possible root setting, since n <=500, this brute-force approach should be able to work\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V(V + E))\\n\\n\\n# Code\\n```\\nclass union_find:\\n    def __init__(self, n):\\n        self.data_ = [_ for _ in range(n+1)]\\n\\n    def find(self, x):\\n        if self.data_[x] != x:\\n            self.data_[x] = self.find(self.data_[x])\\n        return self.data_[x]\\n\\n    def union(self, x, y):\\n        f1 = self.find(x)\\n        f2 = self.find(y)\\n        if f1 != f2:\\n            if f1 < f2:\\n                self.data_[f2] = f1\\n            else:\\n                self.data_[f1] = f2\\n\\n    def get_all_groups(self):\\n\\n        for i in range(1, len(self.data_)):\\n            self.find(i)\\n        groups = defaultdict(list)\\n\\n        for i in range(1, len(self.data_)):\\n            groups[self.data_[i]].append(i)\\n\\n        res = []\\n\\n        for key,value in groups.items():\\n            if value:\\n                res.append(value)\\n\\n        return res\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        #try every possible root\\n\\n        connections = defaultdict(list)\\n\\n        uf = union_find(n)\\n\\n        for src, tar in edges:\\n            connections[src].append(tar)\\n            connections[tar].append(src)\\n            uf.union(src, tar)\\n\\n        res = -sys.maxsize\\n\\n        groups = uf.get_all_groups()\\n\\n        def get_max_group(node):\\n            res = -sys.maxsize\\n            for element in node:\\n                start = [element]\\n                visited = defaultdict(int)\\n                visited[element] = 0\\n                flag = True\\n                counter = 0\\n                while start:\\n                    counter += 1\\n                    new_start = []\\n                    for element in start:\\n                        for child in connections[element]:\\n                            if child not in visited:\\n                                new_start.append(child)\\n                                visited[child] = counter\\n                            else:\\n                                if visited[child] == counter - 1:\\n                                    flag = False\\n                                    break\\n                        if not flag: break\\n                    if not flag: break\\n                    start = new_start\\n                if flag: res = max(res, counter)\\n            return res if res != -sys.maxsize else -1\\n\\n        res = 0\\n\\n        for element in groups:\\n            temp_res = get_max_group(element)\\n            if temp_res == -1: return -1\\n            else: res += temp_res\\n\\n        return res      \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass union_find:\\n    def __init__(self, n):\\n        self.data_ = [_ for _ in range(n+1)]\\n\\n    def find(self, x):\\n        if self.data_[x] != x:\\n            self.data_[x] = self.find(self.data_[x])\\n        return self.data_[x]\\n\\n    def union(self, x, y):\\n        f1 = self.find(x)\\n        f2 = self.find(y)\\n        if f1 != f2:\\n            if f1 < f2:\\n                self.data_[f2] = f1\\n            else:\\n                self.data_[f1] = f2\\n\\n    def get_all_groups(self):\\n\\n        for i in range(1, len(self.data_)):\\n            self.find(i)\\n        groups = defaultdict(list)\\n\\n        for i in range(1, len(self.data_)):\\n            groups[self.data_[i]].append(i)\\n\\n        res = []\\n\\n        for key,value in groups.items():\\n            if value:\\n                res.append(value)\\n\\n        return res\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        #try every possible root\\n\\n        connections = defaultdict(list)\\n\\n        uf = union_find(n)\\n\\n        for src, tar in edges:\\n            connections[src].append(tar)\\n            connections[tar].append(src)\\n            uf.union(src, tar)\\n\\n        res = -sys.maxsize\\n\\n        groups = uf.get_all_groups()\\n\\n        def get_max_group(node):\\n            res = -sys.maxsize\\n            for element in node:\\n                start = [element]\\n                visited = defaultdict(int)\\n                visited[element] = 0\\n                flag = True\\n                counter = 0\\n                while start:\\n                    counter += 1\\n                    new_start = []\\n                    for element in start:\\n                        for child in connections[element]:\\n                            if child not in visited:\\n                                new_start.append(child)\\n                                visited[child] = counter\\n                            else:\\n                                if visited[child] == counter - 1:\\n                                    flag = False\\n                                    break\\n                        if not flag: break\\n                    if not flag: break\\n                    start = new_start\\n                if flag: res = max(res, counter)\\n            return res if res != -sys.maxsize else -1\\n\\n        res = 0\\n\\n        for element in groups:\\n            temp_res = get_max_group(element)\\n            if temp_res == -1: return -1\\n            else: res += temp_res\\n\\n        return res      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883087,
                "title": "java-union-find-bfs-faster-than-95",
                "content": "```\\nclass Solution {\\n    public int magnificentSets(int n, int[][] edges) {\\n        boolean[] visited = new boolean[n + 1];\\n        List[] graph = new List[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            graph[i + 1] = new ArrayList<>();\\n        }\\n        UnionFind uf = new UnionFind(n);\\n        for (int[] e : edges) {\\n            int a = e[0], b = e[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n            uf.union(a - 1, b - 1);\\n        }\\n\\n        int[] groups = new int[n + 1];\\n        int res = 0, singles = 0;\\n\\n        Map<Integer, Set<Integer>> map = uf.groups;\\n\\n        for (int key : map.keySet()) {\\n            if (graph[key + 1].size() == 0) {\\n                map.put(key, null);\\n                singles++;\\n            }\\n        }\\n        \\n        for (int key : map.keySet()) {\\n            if (map.get(key) == null) continue;\\n            int cur = bfs(key + 1, graph, groups, visited);\\n            if (!check(key, uf, groups, graph)) return -1;\\n            Set<Integer> set = map.get(key);\\n            for (int val : set) {\\n                if (val != key) {\\n                    cur = Math.max(cur, bfs(val + 1, graph, new int[n + 1], new boolean[n + 1]));\\n                }\\n            }\\n            res += cur;\\n        }\\n\\n        return res + singles;\\n    }\\n\\n    private boolean check(int key, UnionFind uf, int[] groups, List[] graph) {\\n        Set<Integer> set = uf.groups.get(key);\\n        for (int node : set) {\\n            List<Integer> list = graph[node + 1];\\n            for (int next : list) {\\n                if (Math.abs(groups[node + 1] - groups[next]) != 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    } \\n\\n    private int bfs(int node, List[] graph, int[] groups, boolean[] visited) {\\n        int count = 0;\\n        visited[node] = true;\\n        groups[node] = count;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(node);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = q.poll();\\n                List<Integer> list = graph[cur];\\n                for (int next : list) {\\n                    if (!visited[next]) {\\n                        groups[next] = count + 1;\\n                        q.offer(next);\\n                        visited[next] = true;\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }   \\n\\n    class UnionFind {\\n        int[] size, root;\\n        Map<Integer, Set<Integer>> groups;\\n        \\n        public UnionFind(int n) {\\n            size = new int[n]; root = new int[n];\\n            groups = new HashMap<>();\\n            for (int i = 0; i < n; i++) {\\n                size[i] = 1; root[i] = i;\\n                groups.computeIfAbsent(i, x -> new HashSet<>()).add(i);\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            return root[x] == x ? x : find(root[x]);\\n        }\\n        \\n        public boolean union(int x, int y) {\\n            int rx = find(x), ry = find(y);\\n            if (rx == ry) return false;\\n            if (size[rx] > size[ry]) {\\n                size[rx] += size[ry];\\n                root[ry] = rx;\\n                Set<Integer> set = groups.get(ry);\\n                for (int node : set) {\\n                    groups.get(rx).add(node);\\n                }\\n                groups.remove(ry);\\n            } else {\\n                size[ry] += size[rx];\\n                root[rx] = ry;\\n                Set<Integer> set = groups.get(rx);\\n                for (int node : set) {\\n                    groups.get(ry).add(node);\\n                }\\n                groups.remove(rx);                \\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int magnificentSets(int n, int[][] edges) {\\n        boolean[] visited = new boolean[n + 1];\\n        List[] graph = new List[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            graph[i + 1] = new ArrayList<>();\\n        }\\n        UnionFind uf = new UnionFind(n);\\n        for (int[] e : edges) {\\n            int a = e[0], b = e[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n            uf.union(a - 1, b - 1);\\n        }\\n\\n        int[] groups = new int[n + 1];\\n        int res = 0, singles = 0;\\n\\n        Map<Integer, Set<Integer>> map = uf.groups;\\n\\n        for (int key : map.keySet()) {\\n            if (graph[key + 1].size() == 0) {\\n                map.put(key, null);\\n                singles++;\\n            }\\n        }\\n        \\n        for (int key : map.keySet()) {\\n            if (map.get(key) == null) continue;\\n            int cur = bfs(key + 1, graph, groups, visited);\\n            if (!check(key, uf, groups, graph)) return -1;\\n            Set<Integer> set = map.get(key);\\n            for (int val : set) {\\n                if (val != key) {\\n                    cur = Math.max(cur, bfs(val + 1, graph, new int[n + 1], new boolean[n + 1]));\\n                }\\n            }\\n            res += cur;\\n        }\\n\\n        return res + singles;\\n    }\\n\\n    private boolean check(int key, UnionFind uf, int[] groups, List[] graph) {\\n        Set<Integer> set = uf.groups.get(key);\\n        for (int node : set) {\\n            List<Integer> list = graph[node + 1];\\n            for (int next : list) {\\n                if (Math.abs(groups[node + 1] - groups[next]) != 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    } \\n\\n    private int bfs(int node, List[] graph, int[] groups, boolean[] visited) {\\n        int count = 0;\\n        visited[node] = true;\\n        groups[node] = count;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(node);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = q.poll();\\n                List<Integer> list = graph[cur];\\n                for (int next : list) {\\n                    if (!visited[next]) {\\n                        groups[next] = count + 1;\\n                        q.offer(next);\\n                        visited[next] = true;\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }   \\n\\n    class UnionFind {\\n        int[] size, root;\\n        Map<Integer, Set<Integer>> groups;\\n        \\n        public UnionFind(int n) {\\n            size = new int[n]; root = new int[n];\\n            groups = new HashMap<>();\\n            for (int i = 0; i < n; i++) {\\n                size[i] = 1; root[i] = i;\\n                groups.computeIfAbsent(i, x -> new HashSet<>()).add(i);\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            return root[x] == x ? x : find(root[x]);\\n        }\\n        \\n        public boolean union(int x, int y) {\\n            int rx = find(x), ry = find(y);\\n            if (rx == ry) return false;\\n            if (size[rx] > size[ry]) {\\n                size[rx] += size[ry];\\n                root[ry] = rx;\\n                Set<Integer> set = groups.get(ry);\\n                for (int node : set) {\\n                    groups.get(rx).add(node);\\n                }\\n                groups.remove(ry);\\n            } else {\\n                size[ry] += size[rx];\\n                root[rx] = ry;\\n                Set<Integer> set = groups.get(rx);\\n                for (int node : set) {\\n                    groups.get(ry).add(node);\\n                }\\n                groups.remove(rx);                \\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883035,
                "title": "c-bfs-bipartiteness",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. If graph has odd length cycle then tehre is no sulution.\\n2. Maximum group can be the max diameter of bfs traversal (in case of many component calculate individually)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check bipartiteness using dfs (coloring method)\\n2. To find all pair shortest path using bfs (there would be total n bfs call). \\n3. [Note: Floyd warshall would give TLE bcz its complexity is O(n^3) but n bfs takes less time O(n*(m+n))]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) + O(n*(m+n)) + O(n^2) === O(n*(m+n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    int inf = 1e9;\\n    int color[505], dist[505][505], used[505];\\n    vector<int> g[505], currentNodes;\\n    \\n    bool bipartite(int u, int c = 2) {\\n        color[u] = c;\\n        for(int v: g[u]) {\\n            // never will going to backward to parent\\n            if(color[v] == 0 && !bipartite(v, c^1))\\n                return false;\\n            else if(color[u] == color[v])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void findCurrentNodes(int u, int p) {\\n        used[u] = 1;\\n        currentNodes.push_back(u);\\n        for(int v: g[u]) {\\n            if(used[v] == 0 && v != p)\\n                findCurrentNodes(v, u);\\n        }\\n    }\\n    \\n    int get_diameter(int u) {\\n        currentNodes.clear();\\n        \\n        findCurrentNodes(u, 0);\\n        \\n        int mx = 1;\\n        // all nodes in current component\\n        for(int i = 0; i < currentNodes.size(); i++) {\\n            for(int j = i+1; j < currentNodes.size(); j++) {\\n                int a = currentNodes[i], b = currentNodes[j];\\n                    if(dist[a][b] != inf)\\n                        mx = max(mx, dist[a][b]);\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n\\n    void bfs(int u, int *d, int n) {\\n        for(int i = 1; i <= n; i++) {\\n            d[i] = inf;\\n        }\\n\\n        queue<int> q;\\n        q.push(u);\\n        d[u] = 1;\\n\\n        while(!q.empty()) {\\n            u = q.front();\\n            q.pop();\\n            for(int v: g[u]) {\\n                if(d[v] == inf) {\\n                    d[v] = 1 + d[u];\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        for(auto it: edges) {\\n            int u = it[0], v = it[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        \\n        memset(color, 0, sizeof(color));\\n        // if any component is not bipartite then there is no sulution\\n        for(int i = 1; i <= n; i++) {\\n            if(color[i] == 0 && !bipartite(i))\\n                return -1;\\n        }\\n        \\n        // all pair shortest path using bfs\\n        for(int u = 1; u <= n; u++) {\\n            bfs(u, dist[u], n);\\n        }\\n        \\n        int ans = 0;\\n\\n        // keeps track of previously used nodes in previous components\\n        memset(used, 0, sizeof(used)); \\n\\n        // sum up diameter of each component\\n        for(int i = 1; i <= n; i++) {\\n            if(used[i] == 0)\\n                ans += get_diameter(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int inf = 1e9;\\n    int color[505], dist[505][505], used[505];\\n    vector<int> g[505], currentNodes;\\n    \\n    bool bipartite(int u, int c = 2) {\\n        color[u] = c;\\n        for(int v: g[u]) {\\n            // never will going to backward to parent\\n            if(color[v] == 0 && !bipartite(v, c^1))\\n                return false;\\n            else if(color[u] == color[v])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void findCurrentNodes(int u, int p) {\\n        used[u] = 1;\\n        currentNodes.push_back(u);\\n        for(int v: g[u]) {\\n            if(used[v] == 0 && v != p)\\n                findCurrentNodes(v, u);\\n        }\\n    }\\n    \\n    int get_diameter(int u) {\\n        currentNodes.clear();\\n        \\n        findCurrentNodes(u, 0);\\n        \\n        int mx = 1;\\n        // all nodes in current component\\n        for(int i = 0; i < currentNodes.size(); i++) {\\n            for(int j = i+1; j < currentNodes.size(); j++) {\\n                int a = currentNodes[i], b = currentNodes[j];\\n                    if(dist[a][b] != inf)\\n                        mx = max(mx, dist[a][b]);\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n\\n    void bfs(int u, int *d, int n) {\\n        for(int i = 1; i <= n; i++) {\\n            d[i] = inf;\\n        }\\n\\n        queue<int> q;\\n        q.push(u);\\n        d[u] = 1;\\n\\n        while(!q.empty()) {\\n            u = q.front();\\n            q.pop();\\n            for(int v: g[u]) {\\n                if(d[v] == inf) {\\n                    d[v] = 1 + d[u];\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        for(auto it: edges) {\\n            int u = it[0], v = it[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        \\n        memset(color, 0, sizeof(color));\\n        // if any component is not bipartite then there is no sulution\\n        for(int i = 1; i <= n; i++) {\\n            if(color[i] == 0 && !bipartite(i))\\n                return -1;\\n        }\\n        \\n        // all pair shortest path using bfs\\n        for(int u = 1; u <= n; u++) {\\n            bfs(u, dist[u], n);\\n        }\\n        \\n        int ans = 0;\\n\\n        // keeps track of previously used nodes in previous components\\n        memset(used, 0, sizeof(used)); \\n\\n        // sum up diameter of each component\\n        for(int i = 1; i <= n; i++) {\\n            if(used[i] == 0)\\n                ans += get_diameter(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882402,
                "title": "unionfind-for-partitioning",
                "content": "# Intuition\\n\\nIt feels like we need to solve the problem separately for each connected componenent.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n\\n|E|\\n\\n- Space complexity:\\n\\n|V|\\n\\n# Code\\n```\\n#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\n\\n\\n#include <algorithm>\\n#include <cassert>\\n#include <cmath>\\n#include <complex>\\n#include <fstream>\\n#include <iostream>\\n#include <map>\\n#include <memory>\\n#include <queue>\\n#include <string>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <vector>\\n\\nusing namespace std;\\n\\nusing u8 = uint8_t;\\nusing i8 = int8_t;\\nusing u16 = uint16_t;\\nusing i16 = int16_t;\\nusing u32 = uint32_t;\\nusing i32 = int32_t;\\nusing u64 = uint64_t;\\nusing i64 = int64_t;\\n#ifdef __SIZEOF_INT128__\\nusing u128 = unsigned __int128;\\nusing i128 = __int128;\\nstatic_assert(sizeof(u128) == 16, \"128-bit types\");\\nstatic_assert(sizeof(i128) == 16, \"128-bit types\");\\n#else\\nusing u128 = unsigned long long int;\\nusing i128 = long long int;\\nstatic_assert(sizeof(u128) == 8, \"128-bit types\");\\nstatic_assert(sizeof(i128) == 8, \"128-bit types\");\\n#endif\\n\\nusing BoolVector = vector<bool>;\\nusing IntVector = vector<int>;\\nusing I32Vector = vector<i32>;\\nusing U32Vector = vector<u32>;\\nusing I64Vector = vector<i64>;\\nusing U64Vector = vector<u64>;\\nusing I128Vector = vector<i128>;\\nusing U128Vector = vector<u128>;\\nusing DoubleVector = vector<double>;\\nusing StringVector = vector<string>;\\nusing FloatVector = vector<float>;\\nusing SizeTVector = vector<size_t>;\\nusing IntMatrix = vector<IntVector>;\\nusing I64Matrix = vector<I64Vector>;\\nusing U64Matrix = vector<U64Vector>;\\nusing DoubleMatrix = vector<DoubleVector>;\\n\\nusing I32Set = unordered_set<i32>;\\nusing U64Set = unordered_set<u64>;\\nusing U128Set = unordered_set<u128>;\\n\\n#ifndef _MSC_VER\\n#ifdef __SIZEOF_INT128__\\nostream& operator<<(ostream& o, u128 v);\\nostream& operator<<(ostream& o, i128 v);\\n#else\\n#ifndef __clang__\\nostream& operator<<(ostream& o, u128 v);\\n#endif\\n#endif\\n#endif\\n\\ninline void hashCombine(std::size_t& seed) {}\\n\\ntemplate <typename T, typename... Rest>\\ninline void hashCombine(std::size_t& seed, const T& v, Rest... rest) {\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n    hashCombine(seed, rest...);\\n}\\n\\nnamespace std {\\ntemplate <typename T>\\nstruct hash<vector<T>> {\\n    size_t operator()(const vector<T>& v) const {\\n        size_t result = 0;\\n        for (const auto& e : v) {\\n            hashCombine(result, e);\\n        }\\n        return result;\\n    }\\n};\\n\\nstring to_string(const string& s);\\n\\ntemplate <typename T>\\nstring to_string(const complex<T>& x) {\\n    return \"(\" + to_string(x.real()) + \",\" + to_string(x.imag()) + \")\";\\n}\\n\\n}  // namespace std\\n\\ntemplate <typename T, typename A>\\nostream& operator<<(ostream& o, const std::vector<T, A>& v) {\\n    o << \"[\";\\n    bool first = true;\\n    for (auto n : v) {\\n        if (!first) {\\n            o << \", \";\\n        }\\n        first = false;\\n        o << n;\\n    }\\n    o << \"]\";\\n    return o;\\n}\\n\\ntemplate <typename T1, typename T2>\\nostream& operator<<(ostream& o, const std::pair<T1, T2>& p) {\\n    o << \"(\" << p.first << \", \" << p.second << \")\";\\n    return o;\\n}\\n\\ntemplate <typename T1, typename T2>\\nostream& operator<<(ostream& o, const std::map<T1, T2>& m) {\\n    o << \"{\";\\n    bool first = true;\\n    for (const auto& p : m) {\\n        if (!first) {\\n            o << \", \";\\n        }\\n        first = false;\\n        o << p;\\n    }\\n    o << \"}\";\\n    return o;\\n}\\n\\ntemplate <typename T1, typename T2>\\nostream& operator<<(ostream& o, const std::unordered_map<T1, T2>& m) {\\n    o << \"{\";\\n    bool first = true;\\n    for (const auto& p : m) {\\n        if (!first) {\\n            o << \", \";\\n        }\\n        first = false;\\n        o << p;\\n    }\\n    o << \"}\";\\n    return o;\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type sum(const T& x) {\\n    typename T::value_type result = 0;\\n    for (auto v : x) {\\n        result += v;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type product(const T& x) {\\n    typename T::value_type result = 1;\\n    for (auto v : x) {\\n        result *= v;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type average(const T& x) {\\n#ifndef NDEBUG\\n    assert(!x.empty());\\n#endif\\n    return sum(x) / x.size();\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type minV(const T& x) {\\n#ifndef NDEBUG\\n    assert(!x.empty());\\n#endif\\n    typename T::value_type res = x[0];\\n    for (size_t i = 1; i < x.size(); ++i) {\\n        if (x[i] < res) {\\n            res = x[i];\\n        }\\n    }\\n\\n    return res;\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type maxV(const T& x) {\\n#ifndef NDEBUG\\n    assert(!x.empty());\\n#endif\\n    typename T::value_type res = x[0];\\n    for (size_t i = 1; i < x.size(); ++i) {\\n        if (x[i] > res) {\\n            res = x[i];\\n        }\\n    }\\n\\n    return res;\\n}\\n\\ntemplate <typename T>\\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\\n#ifndef NDEBUG\\n    assert(a.size() == b.size());\\n#endif\\n    vector<T> result(a.size());\\n    for (size_t i = 0; i < a.size(); ++i) {\\n        result[i] = a[i] + b[i];\\n    }\\n    return result;\\n}\\n\\ntemplate <typename T>\\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\\n#ifndef NDEBUG\\n    assert(a.size() == b.size());\\n#endif\\n    vector<T> result(a.size());\\n    for (size_t i = 0; i < a.size(); ++i) {\\n        result[i] = a[i] - b[i];\\n    }\\n    return result;\\n}\\n\\ntemplate <typename T>\\nvector<T> cat(const vector<T>& a, const vector<T>& b) {\\n    vector<T> result = a;\\n    result.insert(result.end(), b.begin(), b.end());\\n    return result;\\n}\\n\\ntemplate <typename T>\\nvector<T>& catInplace(vector<T>& a, const vector<T>& b) {\\n    a.insert(a.end(), b.begin(), b.end());\\n    return a;\\n}\\n\\ntemplate <typename T>\\nT sqr(const T& x) {\\n    return x * x;\\n}\\n\\ntemplate <typename T>\\nT clamp(T x, T scale) {\\n    if (x < -scale) {\\n        return -scale;\\n    } else if (x > scale) {\\n        return scale;\\n    }\\n    return x;\\n}\\n\\ntemplate <typename T>\\ndouble length(const vector<T>& a) {\\n    double l2 = 0.0;\\n    for (const auto& x : a) {\\n        l2 += sqr(x);\\n    }\\n    return sqrt(l2);\\n}\\n\\ntemplate <typename T>\\nT subVector(const T& vct, size_t start) {\\n    return T(vct.begin() + start, vct.end());\\n}\\n\\ntemplate <typename T>\\nT subVector(const T& vct, size_t start, size_t end) {\\n    return T(vct.begin() + start, vct.begin() + end);\\n}\\n\\ntemplate <typename T>\\nT subVector(const T& vct, const SizeTVector& indices) {\\n    T result(indices.size());\\n    size_t index = 0;\\n    for (auto i : indices) {\\n        result[index++] = vct[i];\\n    }\\n    return result;\\n}\\n\\ntemplate <typename V, typename T = typename V::value_type>\\nvector<T> slice(const V& vct, size_t start, size_t finish) {\\n    vector<T> result;\\n    result.reserve(finish - start);\\n    size_t i = start;\\n    while (i < finish && i < vct.size()) {\\n        result.emplace_back(vct[i]);\\n        ++i;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename V, typename K = V>\\nvoid insertVector(vector<V>& v, size_t pos, const vector<K>& ins) {\\n    v.insert(v.begin() + pos, ins.begin(), ins.end());\\n}\\n\\ntemplate <typename T, typename V>\\nbool has(const T& v, const V& x) {\\n    for (const auto& i : v) {\\n        if (i == x) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\ntemplate <typename T>\\nvoid sort(T& v) {\\n    std::sort(v.begin(), v.end());\\n}\\n\\ntemplate <typename T>\\nvoid sortDescending(T& v) {\\n    std::sort(v.begin(), v.end(),\\n              [](const typename T::value_type& a, const typename T::value_type& b) { return a > b; });\\n}\\n\\ntemplate <typename T>\\nT sorted(const T& x) {\\n    T copy(x);\\n    sort(copy);\\n    return copy;\\n}\\n\\ntemplate <typename T>\\nvoid sortAndUnique(vector<T>& v) {\\n    sort(v);\\n    v.erase(unique(v.begin(), v.end()), v.end());\\n}\\n\\ntemplate <typename T>\\nvoid reverse(T& v) {\\n    std::reverse(v.begin(), v.end());\\n}\\n\\ntemplate <typename T>\\nT reversed(const T& x) {\\n    T copy(x);\\n    reverse(copy);\\n    return copy;\\n}\\n\\ntemplate <typename T>\\nIntVector numToDigits(T n, int base = 10) {\\n    if (n == 0) {\\n        return {0};\\n    }\\n    IntVector result;\\n    while (n) {\\n        result.emplace_back(n % base);\\n        n /= base;\\n    }\\n    reverse(result);\\n    return result;\\n}\\n\\ntemplate <typename T, int BASE>\\nsize_t numToBuffer(T n, char* buffer) {\\n    const char* buffer0 = buffer;\\n    if (n < 0) {\\n        *buffer = \\'-\\';\\n        ++buffer;\\n        n = -n;\\n    }\\n    if (n != 0) {\\n        char* begin = buffer;\\n        while (n) {\\n            const T nn = n / BASE;\\n            *buffer = (n - nn * BASE) + \\'0\\';\\n            ++buffer;\\n            n = nn;\\n        }\\n        reverse(begin, buffer);\\n    } else {\\n        *buffer = \\'0\\';\\n        ++buffer;\\n    }\\n    return buffer - buffer0;\\n}\\n\\ntemplate <typename T, int BASE = 10>\\nstring numToString(T n) {\\n    thread_local char buffer[64];\\n    buffer[numToBuffer<T, BASE>(n, buffer)] = 0;\\n    return buffer;\\n}\\n\\ntemplate <typename T = int>\\nT digitsToNum(const IntVector& digits, int base = 10) {\\n    T result = 0;\\n    for (auto d : digits) {\\n        result = base * result + d;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename K, typename V>\\nV findWithDefault(const unordered_map<K, V>& map, const K& key, const V& value) {\\n    auto it = map.find(key);\\n    if (it != map.end()) {\\n        return it->second;\\n    }\\n    return value;\\n}\\n\\ntemplate <typename K, typename V>\\nvector<K> keys(const unordered_map<K, V>& map) {\\n    vector<K> result(map.size());\\n    size_t index = 0;\\n    for (const auto& it : map) {\\n        result[index++] = it.first;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename M>\\nvector<pair<typename M::key_type, typename M::mapped_type>> map2Tuples(const M& map) {\\n    vector<pair<typename M::key_type, typename M::mapped_type>> result(map.size());\\n    size_t index = 0;\\n    for (const auto& it : map) {\\n        result[index++] = it;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename M>\\nvector<pair<typename M::mapped_type, typename M::key_type>> map2TuplesSwap(const M& map) {\\n    vector<pair<typename M::mapped_type, typename M::key_type>> result(map.size());\\n    size_t index = 0;\\n    for (const auto& it : map) {\\n        result[index++] = make_pair(it.second, it.first);\\n    }\\n    return result;\\n}\\n\\nclass Exception : public std::exception {\\n   public:\\n    Exception();\\n    Exception(string msg);\\n    const char* what() const noexcept override;\\n\\n   protected:\\n    string msg_;\\n};\\n\\n#define ENFORCE(X)                                                                                    \\\\\\n    {                                                                                                 \\\\\\n        if (!(X)) {                                                                                   \\\\\\n            throw Exception(string(__FILE__) + \" \" + string(to_string(__LINE__)) + \" \" + string(#X)); \\\\\\n        }                                                                                             \\\\\\n    }\\n\\n#define ENFORCE_EQ(X, Y) ENFORCE((X) == (Y))\\n\\nstring homeDir();\\n\\n#define OUT(X) #X << \": \" << (X) << \", \"\\n#define OUTLN(X) #X << \": \" << endl << (X) << endl\\n\\n#define EVERY_MS(LAMBDA, DELAY_MS)                                            \\\\\\n    {                                                                         \\\\\\n        static ::std::chrono::milliseconds::rep prev = -1;                    \\\\\\n        auto now = ::std::chrono::duration_cast<::std::chrono::milliseconds>( \\\\\\n                       ::std::chrono::system_clock::now().time_since_epoch()) \\\\\\n                       .count();                                              \\\\\\n        if (prev == -1 || now > prev + DELAY_MS) {                            \\\\\\n            LAMBDA;                                                           \\\\\\n            prev = now;                                                       \\\\\\n        }                                                                     \\\\\\n    }\\n\\n#ifndef NDEBUG\\n#define ALWAYS_ASSERT(...) assert(__VA_ARGS__)\\n#else\\n#define ALWAYS_ASSERT(...) __VA_ARGS__\\n#endif\\n\\n#define ASSERT assert\\n#define ASSERTEQ(x, y) assert((x) == (y))\\n#define ASSERTNEQ(x, y) assert((x) != (y))\\n#define ASSERTLT(x, y) assert((x) < (y))\\n#define ASSERTLE(x, y) assert((x) <= (y))\\n#define ASSERTGT(x, y) assert((x) > (y))\\n#define ASSERTGE(x, y) assert((x) >= (y))\\n#define ASSERTNE(x, y) assert((x) != (y))\\n\\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\\n#define REP(i, n) FOR(i, 0, n)\\n#define ITRANGE(v) (v).begin(), (v).end()\\n\\n#include <chrono>\\n\\nclass TimerTracker {\\n   public:\\n    TimerTracker();\\n    double diffAndReset();\\n\\n   private:\\n    chrono::time_point<chrono::high_resolution_clock> begin_;\\n};\\n\\nclass Timer {\\n   public:\\n    Timer(std::string m);\\n    void finish();\\n    ~Timer();\\n\\n   private:\\n    string m_;\\n    TimerTracker tt_;\\n    bool finished_{false};\\n};\\n\\nusing namespace std;\\n\\n#include <unordered_map>\\n\\nstruct UnionFindDense {\\n   public:\\n    UnionFindDense(size_t n) : parent_(n), parentSize_(n) {\\n        for (size_t i = 0; i < n; ++i) {\\n            parent_[i] = i;\\n        }\\n        for (size_t i = 0; i < n; ++i) {\\n            parentSize_[i] = 1;\\n        }\\n    }\\n\\n    size_t find(size_t first) {\\n        size_t i = first;\\n        auto parent = parent_[i];\\n        int count = 0;\\n        while (parent != i) {\\n            i = parent;\\n            parent = parent_[i];\\n            ++count;\\n        }\\n\\n        if (count > 2) {\\n            size_t j = first;\\n            parent = parent_[j];\\n            while (parent != j) {\\n                parent_[j] = i;\\n                j = parent;\\n                parent = parent_[j];\\n            }\\n        }\\n\\n        return i;\\n    }\\n\\n    void unite(size_t first, size_t second) {\\n        auto firstParent = find(first);\\n        auto secondParent = find(second);\\n        if (firstParent == secondParent) {\\n            return;\\n        }\\n        if (parentSize_[firstParent] > parentSize_[secondParent]) {\\n            swap(first, second);\\n            swap(firstParent, secondParent);\\n        }\\n        parent_[firstParent] = secondParent;\\n        parentSize_[secondParent] += parentSize_[firstParent];\\n        parentSize_[firstParent] = 0;\\n    }\\n\\n    struct Component {\\n        size_t first;\\n        size_t size;\\n    };\\n    using Components = vector<Component>;\\n\\n    Components components() {\\n        Components result;\\n        for (size_t i = 0; i < parentSize_.size(); ++i) {\\n            if (parentSize_[i]) {\\n                result.emplace_back(Component{i, parentSize_[i]});\\n            }\\n        }\\n        return result;\\n    }\\n\\n    using ParentToComponent = unordered_map<size_t, vector<size_t>>;\\n\\n    ParentToComponent parentToComponent() {\\n        ParentToComponent p2c;\\n        for (size_t i = 0; i < parent_.size(); ++i) {\\n            p2c[find(i)].emplace_back(i);\\n        }\\n        return p2c;\\n    }\\n\\n   private:\\n    vector<size_t> parent_;\\n    vector<size_t> parentSize_;\\n};\\n\\nclass Solution {\\npublic:\\n    /*\\n    int magnificentSets(int n, vector<vector<int>> edges) {\\n        static constexpr int INF = 1000000000;\\n        unordered_map<int, vector<int>> g;\\n        for (auto& v: edges) {\\n            --v[0];\\n            --v[1];\\n            g[v[0]].emplace_back(v[1]);\\n            g[v[1]].emplace_back(v[0]);\\n        }\\n\\n        vector<vector<int>> d(n, vector<int>(n, INF));\\n        for (int i = 0; i < n; ++i) {\\n            d[i][i] = 0;\\n        }\\n        for (const auto& e: edges) {\\n            d[e[0]][e[1]] = 1;\\n            d[e[1]][e[0]] = 1;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\\n                }\\n            }\\n        }\\n\\n        UnionFindDense uf(n);\\n        for (const auto& e: edges) {\\n            uf.unite(e[0], e[1]);\\n        }\\n\\n        auto p2c = uf.parentToComponent();\\n        int result = 0;\\n        for (const auto& c: p2c) {\\n            int maxD = 0;\\n            for (auto v: c.second) {\\n                int maxDV = 0;\\n                for (auto u: c.second) {\\n                    maxDV = max(maxDV, d[u][v]);\\n                }\\n                maxD = max(maxD, maxDV);\\n            }\\n            result = maxD + 1;\\n        }\\n        return result;\\n    }\\n    */\\n    int magnificentSets(int n, vector<vector<int>> edges) {\\n        static constexpr int INF = 1000000000;\\n        unordered_map<int, vector<int>> g;\\n        for (auto& v: edges) {\\n            --v[0];\\n            --v[1];\\n            g[v[0]].emplace_back(v[1]);\\n            g[v[1]].emplace_back(v[0]);\\n        }\\n\\n        UnionFindDense uf(n);\\n        for (const auto& e: edges) {\\n            uf.unite(e[0], e[1]);\\n        }\\n\\n        auto p2c = uf.parentToComponent();\\n\\n        vector<int> d(n, INF);\\n        int result = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (d[i] != INF) {\\n                continue;\\n            }\\n            int maxD = 0;\\n            for (int j : p2c[uf.find(i)]) {\\n                for (int k: p2c[uf.find(i)]) {\\n                    d[k] = INF;\\n                }\\n\\n                d[j] = 0;\\n                queue<int> q;\\n                q.push(j);\\n                while (!q.empty()) {\\n                    int v = q.front();\\n                    q.pop();\\n                    for (auto u : g[v]) {\\n                        if (d[u] == INF) {\\n                            d[u] = d[v] + 1;\\n                            maxD = max(maxD, d[u]);\\n                            q.push(u);\\n                        }\\n                    }\\n                }\\n            }\\n            result += maxD + 1;\\n        }\\n\\n        int j = 0;\\n        for (j = 0; j < edges.size(); ++j) {\\n            int a = edges[j][0];\\n            int b = edges[j][1];\\n            if (abs(d[a] - d[b]) != 1) {\\n                return -1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    /*\\n    */\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\n\\n\\n#include <algorithm>\\n#include <cassert>\\n#include <cmath>\\n#include <complex>\\n#include <fstream>\\n#include <iostream>\\n#include <map>\\n#include <memory>\\n#include <queue>\\n#include <string>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <vector>\\n\\nusing namespace std;\\n\\nusing u8 = uint8_t;\\nusing i8 = int8_t;\\nusing u16 = uint16_t;\\nusing i16 = int16_t;\\nusing u32 = uint32_t;\\nusing i32 = int32_t;\\nusing u64 = uint64_t;\\nusing i64 = int64_t;\\n#ifdef __SIZEOF_INT128__\\nusing u128 = unsigned __int128;\\nusing i128 = __int128;\\nstatic_assert(sizeof(u128) == 16, \"128-bit types\");\\nstatic_assert(sizeof(i128) == 16, \"128-bit types\");\\n#else\\nusing u128 = unsigned long long int;\\nusing i128 = long long int;\\nstatic_assert(sizeof(u128) == 8, \"128-bit types\");\\nstatic_assert(sizeof(i128) == 8, \"128-bit types\");\\n#endif\\n\\nusing BoolVector = vector<bool>;\\nusing IntVector = vector<int>;\\nusing I32Vector = vector<i32>;\\nusing U32Vector = vector<u32>;\\nusing I64Vector = vector<i64>;\\nusing U64Vector = vector<u64>;\\nusing I128Vector = vector<i128>;\\nusing U128Vector = vector<u128>;\\nusing DoubleVector = vector<double>;\\nusing StringVector = vector<string>;\\nusing FloatVector = vector<float>;\\nusing SizeTVector = vector<size_t>;\\nusing IntMatrix = vector<IntVector>;\\nusing I64Matrix = vector<I64Vector>;\\nusing U64Matrix = vector<U64Vector>;\\nusing DoubleMatrix = vector<DoubleVector>;\\n\\nusing I32Set = unordered_set<i32>;\\nusing U64Set = unordered_set<u64>;\\nusing U128Set = unordered_set<u128>;\\n\\n#ifndef _MSC_VER\\n#ifdef __SIZEOF_INT128__\\nostream& operator<<(ostream& o, u128 v);\\nostream& operator<<(ostream& o, i128 v);\\n#else\\n#ifndef __clang__\\nostream& operator<<(ostream& o, u128 v);\\n#endif\\n#endif\\n#endif\\n\\ninline void hashCombine(std::size_t& seed) {}\\n\\ntemplate <typename T, typename... Rest>\\ninline void hashCombine(std::size_t& seed, const T& v, Rest... rest) {\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n    hashCombine(seed, rest...);\\n}\\n\\nnamespace std {\\ntemplate <typename T>\\nstruct hash<vector<T>> {\\n    size_t operator()(const vector<T>& v) const {\\n        size_t result = 0;\\n        for (const auto& e : v) {\\n            hashCombine(result, e);\\n        }\\n        return result;\\n    }\\n};\\n\\nstring to_string(const string& s);\\n\\ntemplate <typename T>\\nstring to_string(const complex<T>& x) {\\n    return \"(\" + to_string(x.real()) + \",\" + to_string(x.imag()) + \")\";\\n}\\n\\n}  // namespace std\\n\\ntemplate <typename T, typename A>\\nostream& operator<<(ostream& o, const std::vector<T, A>& v) {\\n    o << \"[\";\\n    bool first = true;\\n    for (auto n : v) {\\n        if (!first) {\\n            o << \", \";\\n        }\\n        first = false;\\n        o << n;\\n    }\\n    o << \"]\";\\n    return o;\\n}\\n\\ntemplate <typename T1, typename T2>\\nostream& operator<<(ostream& o, const std::pair<T1, T2>& p) {\\n    o << \"(\" << p.first << \", \" << p.second << \")\";\\n    return o;\\n}\\n\\ntemplate <typename T1, typename T2>\\nostream& operator<<(ostream& o, const std::map<T1, T2>& m) {\\n    o << \"{\";\\n    bool first = true;\\n    for (const auto& p : m) {\\n        if (!first) {\\n            o << \", \";\\n        }\\n        first = false;\\n        o << p;\\n    }\\n    o << \"}\";\\n    return o;\\n}\\n\\ntemplate <typename T1, typename T2>\\nostream& operator<<(ostream& o, const std::unordered_map<T1, T2>& m) {\\n    o << \"{\";\\n    bool first = true;\\n    for (const auto& p : m) {\\n        if (!first) {\\n            o << \", \";\\n        }\\n        first = false;\\n        o << p;\\n    }\\n    o << \"}\";\\n    return o;\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type sum(const T& x) {\\n    typename T::value_type result = 0;\\n    for (auto v : x) {\\n        result += v;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type product(const T& x) {\\n    typename T::value_type result = 1;\\n    for (auto v : x) {\\n        result *= v;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type average(const T& x) {\\n#ifndef NDEBUG\\n    assert(!x.empty());\\n#endif\\n    return sum(x) / x.size();\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type minV(const T& x) {\\n#ifndef NDEBUG\\n    assert(!x.empty());\\n#endif\\n    typename T::value_type res = x[0];\\n    for (size_t i = 1; i < x.size(); ++i) {\\n        if (x[i] < res) {\\n            res = x[i];\\n        }\\n    }\\n\\n    return res;\\n}\\n\\ntemplate <typename T>\\ntypename T::value_type maxV(const T& x) {\\n#ifndef NDEBUG\\n    assert(!x.empty());\\n#endif\\n    typename T::value_type res = x[0];\\n    for (size_t i = 1; i < x.size(); ++i) {\\n        if (x[i] > res) {\\n            res = x[i];\\n        }\\n    }\\n\\n    return res;\\n}\\n\\ntemplate <typename T>\\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\\n#ifndef NDEBUG\\n    assert(a.size() == b.size());\\n#endif\\n    vector<T> result(a.size());\\n    for (size_t i = 0; i < a.size(); ++i) {\\n        result[i] = a[i] + b[i];\\n    }\\n    return result;\\n}\\n\\ntemplate <typename T>\\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\\n#ifndef NDEBUG\\n    assert(a.size() == b.size());\\n#endif\\n    vector<T> result(a.size());\\n    for (size_t i = 0; i < a.size(); ++i) {\\n        result[i] = a[i] - b[i];\\n    }\\n    return result;\\n}\\n\\ntemplate <typename T>\\nvector<T> cat(const vector<T>& a, const vector<T>& b) {\\n    vector<T> result = a;\\n    result.insert(result.end(), b.begin(), b.end());\\n    return result;\\n}\\n\\ntemplate <typename T>\\nvector<T>& catInplace(vector<T>& a, const vector<T>& b) {\\n    a.insert(a.end(), b.begin(), b.end());\\n    return a;\\n}\\n\\ntemplate <typename T>\\nT sqr(const T& x) {\\n    return x * x;\\n}\\n\\ntemplate <typename T>\\nT clamp(T x, T scale) {\\n    if (x < -scale) {\\n        return -scale;\\n    } else if (x > scale) {\\n        return scale;\\n    }\\n    return x;\\n}\\n\\ntemplate <typename T>\\ndouble length(const vector<T>& a) {\\n    double l2 = 0.0;\\n    for (const auto& x : a) {\\n        l2 += sqr(x);\\n    }\\n    return sqrt(l2);\\n}\\n\\ntemplate <typename T>\\nT subVector(const T& vct, size_t start) {\\n    return T(vct.begin() + start, vct.end());\\n}\\n\\ntemplate <typename T>\\nT subVector(const T& vct, size_t start, size_t end) {\\n    return T(vct.begin() + start, vct.begin() + end);\\n}\\n\\ntemplate <typename T>\\nT subVector(const T& vct, const SizeTVector& indices) {\\n    T result(indices.size());\\n    size_t index = 0;\\n    for (auto i : indices) {\\n        result[index++] = vct[i];\\n    }\\n    return result;\\n}\\n\\ntemplate <typename V, typename T = typename V::value_type>\\nvector<T> slice(const V& vct, size_t start, size_t finish) {\\n    vector<T> result;\\n    result.reserve(finish - start);\\n    size_t i = start;\\n    while (i < finish && i < vct.size()) {\\n        result.emplace_back(vct[i]);\\n        ++i;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename V, typename K = V>\\nvoid insertVector(vector<V>& v, size_t pos, const vector<K>& ins) {\\n    v.insert(v.begin() + pos, ins.begin(), ins.end());\\n}\\n\\ntemplate <typename T, typename V>\\nbool has(const T& v, const V& x) {\\n    for (const auto& i : v) {\\n        if (i == x) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\ntemplate <typename T>\\nvoid sort(T& v) {\\n    std::sort(v.begin(), v.end());\\n}\\n\\ntemplate <typename T>\\nvoid sortDescending(T& v) {\\n    std::sort(v.begin(), v.end(),\\n              [](const typename T::value_type& a, const typename T::value_type& b) { return a > b; });\\n}\\n\\ntemplate <typename T>\\nT sorted(const T& x) {\\n    T copy(x);\\n    sort(copy);\\n    return copy;\\n}\\n\\ntemplate <typename T>\\nvoid sortAndUnique(vector<T>& v) {\\n    sort(v);\\n    v.erase(unique(v.begin(), v.end()), v.end());\\n}\\n\\ntemplate <typename T>\\nvoid reverse(T& v) {\\n    std::reverse(v.begin(), v.end());\\n}\\n\\ntemplate <typename T>\\nT reversed(const T& x) {\\n    T copy(x);\\n    reverse(copy);\\n    return copy;\\n}\\n\\ntemplate <typename T>\\nIntVector numToDigits(T n, int base = 10) {\\n    if (n == 0) {\\n        return {0};\\n    }\\n    IntVector result;\\n    while (n) {\\n        result.emplace_back(n % base);\\n        n /= base;\\n    }\\n    reverse(result);\\n    return result;\\n}\\n\\ntemplate <typename T, int BASE>\\nsize_t numToBuffer(T n, char* buffer) {\\n    const char* buffer0 = buffer;\\n    if (n < 0) {\\n        *buffer = \\'-\\';\\n        ++buffer;\\n        n = -n;\\n    }\\n    if (n != 0) {\\n        char* begin = buffer;\\n        while (n) {\\n            const T nn = n / BASE;\\n            *buffer = (n - nn * BASE) + \\'0\\';\\n            ++buffer;\\n            n = nn;\\n        }\\n        reverse(begin, buffer);\\n    } else {\\n        *buffer = \\'0\\';\\n        ++buffer;\\n    }\\n    return buffer - buffer0;\\n}\\n\\ntemplate <typename T, int BASE = 10>\\nstring numToString(T n) {\\n    thread_local char buffer[64];\\n    buffer[numToBuffer<T, BASE>(n, buffer)] = 0;\\n    return buffer;\\n}\\n\\ntemplate <typename T = int>\\nT digitsToNum(const IntVector& digits, int base = 10) {\\n    T result = 0;\\n    for (auto d : digits) {\\n        result = base * result + d;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename K, typename V>\\nV findWithDefault(const unordered_map<K, V>& map, const K& key, const V& value) {\\n    auto it = map.find(key);\\n    if (it != map.end()) {\\n        return it->second;\\n    }\\n    return value;\\n}\\n\\ntemplate <typename K, typename V>\\nvector<K> keys(const unordered_map<K, V>& map) {\\n    vector<K> result(map.size());\\n    size_t index = 0;\\n    for (const auto& it : map) {\\n        result[index++] = it.first;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename M>\\nvector<pair<typename M::key_type, typename M::mapped_type>> map2Tuples(const M& map) {\\n    vector<pair<typename M::key_type, typename M::mapped_type>> result(map.size());\\n    size_t index = 0;\\n    for (const auto& it : map) {\\n        result[index++] = it;\\n    }\\n    return result;\\n}\\n\\ntemplate <typename M>\\nvector<pair<typename M::mapped_type, typename M::key_type>> map2TuplesSwap(const M& map) {\\n    vector<pair<typename M::mapped_type, typename M::key_type>> result(map.size());\\n    size_t index = 0;\\n    for (const auto& it : map) {\\n        result[index++] = make_pair(it.second, it.first);\\n    }\\n    return result;\\n}\\n\\nclass Exception : public std::exception {\\n   public:\\n    Exception();\\n    Exception(string msg);\\n    const char* what() const noexcept override;\\n\\n   protected:\\n    string msg_;\\n};\\n\\n#define ENFORCE(X)                                                                                    \\\\\\n    {                                                                                                 \\\\\\n        if (!(X)) {                                                                                   \\\\\\n            throw Exception(string(__FILE__) + \" \" + string(to_string(__LINE__)) + \" \" + string(#X)); \\\\\\n        }                                                                                             \\\\\\n    }\\n\\n#define ENFORCE_EQ(X, Y) ENFORCE((X) == (Y))\\n\\nstring homeDir();\\n\\n#define OUT(X) #X << \": \" << (X) << \", \"\\n#define OUTLN(X) #X << \": \" << endl << (X) << endl\\n\\n#define EVERY_MS(LAMBDA, DELAY_MS)                                            \\\\\\n    {                                                                         \\\\\\n        static ::std::chrono::milliseconds::rep prev = -1;                    \\\\\\n        auto now = ::std::chrono::duration_cast<::std::chrono::milliseconds>( \\\\\\n                       ::std::chrono::system_clock::now().time_since_epoch()) \\\\\\n                       .count();                                              \\\\\\n        if (prev == -1 || now > prev + DELAY_MS) {                            \\\\\\n            LAMBDA;                                                           \\\\\\n            prev = now;                                                       \\\\\\n        }                                                                     \\\\\\n    }\\n\\n#ifndef NDEBUG\\n#define ALWAYS_ASSERT(...) assert(__VA_ARGS__)\\n#else\\n#define ALWAYS_ASSERT(...) __VA_ARGS__\\n#endif\\n\\n#define ASSERT assert\\n#define ASSERTEQ(x, y) assert((x) == (y))\\n#define ASSERTNEQ(x, y) assert((x) != (y))\\n#define ASSERTLT(x, y) assert((x) < (y))\\n#define ASSERTLE(x, y) assert((x) <= (y))\\n#define ASSERTGT(x, y) assert((x) > (y))\\n#define ASSERTGE(x, y) assert((x) >= (y))\\n#define ASSERTNE(x, y) assert((x) != (y))\\n\\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\\n#define REP(i, n) FOR(i, 0, n)\\n#define ITRANGE(v) (v).begin(), (v).end()\\n\\n#include <chrono>\\n\\nclass TimerTracker {\\n   public:\\n    TimerTracker();\\n    double diffAndReset();\\n\\n   private:\\n    chrono::time_point<chrono::high_resolution_clock> begin_;\\n};\\n\\nclass Timer {\\n   public:\\n    Timer(std::string m);\\n    void finish();\\n    ~Timer();\\n\\n   private:\\n    string m_;\\n    TimerTracker tt_;\\n    bool finished_{false};\\n};\\n\\nusing namespace std;\\n\\n#include <unordered_map>\\n\\nstruct UnionFindDense {\\n   public:\\n    UnionFindDense(size_t n) : parent_(n), parentSize_(n) {\\n        for (size_t i = 0; i < n; ++i) {\\n            parent_[i] = i;\\n        }\\n        for (size_t i = 0; i < n; ++i) {\\n            parentSize_[i] = 1;\\n        }\\n    }\\n\\n    size_t find(size_t first) {\\n        size_t i = first;\\n        auto parent = parent_[i];\\n        int count = 0;\\n        while (parent != i) {\\n            i = parent;\\n            parent = parent_[i];\\n            ++count;\\n        }\\n\\n        if (count > 2) {\\n            size_t j = first;\\n            parent = parent_[j];\\n            while (parent != j) {\\n                parent_[j] = i;\\n                j = parent;\\n                parent = parent_[j];\\n            }\\n        }\\n\\n        return i;\\n    }\\n\\n    void unite(size_t first, size_t second) {\\n        auto firstParent = find(first);\\n        auto secondParent = find(second);\\n        if (firstParent == secondParent) {\\n            return;\\n        }\\n        if (parentSize_[firstParent] > parentSize_[secondParent]) {\\n            swap(first, second);\\n            swap(firstParent, secondParent);\\n        }\\n        parent_[firstParent] = secondParent;\\n        parentSize_[secondParent] += parentSize_[firstParent];\\n        parentSize_[firstParent] = 0;\\n    }\\n\\n    struct Component {\\n        size_t first;\\n        size_t size;\\n    };\\n    using Components = vector<Component>;\\n\\n    Components components() {\\n        Components result;\\n        for (size_t i = 0; i < parentSize_.size(); ++i) {\\n            if (parentSize_[i]) {\\n                result.emplace_back(Component{i, parentSize_[i]});\\n            }\\n        }\\n        return result;\\n    }\\n\\n    using ParentToComponent = unordered_map<size_t, vector<size_t>>;\\n\\n    ParentToComponent parentToComponent() {\\n        ParentToComponent p2c;\\n        for (size_t i = 0; i < parent_.size(); ++i) {\\n            p2c[find(i)].emplace_back(i);\\n        }\\n        return p2c;\\n    }\\n\\n   private:\\n    vector<size_t> parent_;\\n    vector<size_t> parentSize_;\\n};\\n\\nclass Solution {\\npublic:\\n    /*\\n    int magnificentSets(int n, vector<vector<int>> edges) {\\n        static constexpr int INF = 1000000000;\\n        unordered_map<int, vector<int>> g;\\n        for (auto& v: edges) {\\n            --v[0];\\n            --v[1];\\n            g[v[0]].emplace_back(v[1]);\\n            g[v[1]].emplace_back(v[0]);\\n        }\\n\\n        vector<vector<int>> d(n, vector<int>(n, INF));\\n        for (int i = 0; i < n; ++i) {\\n            d[i][i] = 0;\\n        }\\n        for (const auto& e: edges) {\\n            d[e[0]][e[1]] = 1;\\n            d[e[1]][e[0]] = 1;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\\n                }\\n            }\\n        }\\n\\n        UnionFindDense uf(n);\\n        for (const auto& e: edges) {\\n            uf.unite(e[0], e[1]);\\n        }\\n\\n        auto p2c = uf.parentToComponent();\\n        int result = 0;\\n        for (const auto& c: p2c) {\\n            int maxD = 0;\\n            for (auto v: c.second) {\\n                int maxDV = 0;\\n                for (auto u: c.second) {\\n                    maxDV = max(maxDV, d[u][v]);\\n                }\\n                maxD = max(maxD, maxDV);\\n            }\\n            result = maxD + 1;\\n        }\\n        return result;\\n    }\\n    */\\n    int magnificentSets(int n, vector<vector<int>> edges) {\\n        static constexpr int INF = 1000000000;\\n        unordered_map<int, vector<int>> g;\\n        for (auto& v: edges) {\\n            --v[0];\\n            --v[1];\\n            g[v[0]].emplace_back(v[1]);\\n            g[v[1]].emplace_back(v[0]);\\n        }\\n\\n        UnionFindDense uf(n);\\n        for (const auto& e: edges) {\\n            uf.unite(e[0], e[1]);\\n        }\\n\\n        auto p2c = uf.parentToComponent();\\n\\n        vector<int> d(n, INF);\\n        int result = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (d[i] != INF) {\\n                continue;\\n            }\\n            int maxD = 0;\\n            for (int j : p2c[uf.find(i)]) {\\n                for (int k: p2c[uf.find(i)]) {\\n                    d[k] = INF;\\n                }\\n\\n                d[j] = 0;\\n                queue<int> q;\\n                q.push(j);\\n                while (!q.empty()) {\\n                    int v = q.front();\\n                    q.pop();\\n                    for (auto u : g[v]) {\\n                        if (d[u] == INF) {\\n                            d[u] = d[v] + 1;\\n                            maxD = max(maxD, d[u]);\\n                            q.push(u);\\n                        }\\n                    }\\n                }\\n            }\\n            result += maxD + 1;\\n        }\\n\\n        int j = 0;\\n        for (j = 0; j < edges.size(); ++j) {\\n            int a = edges[j][0];\\n            int b = edges[j][1];\\n            if (abs(d[a] - d[b]) != 1) {\\n                return -1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    /*\\n    */\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2882223,
                "title": "python-done-in-one-bfs-pass-through",
                "content": "Key observation: the maximum number of vertices is 500, so `O(n^2)` algorithms are perfectly ok.  \\nHere we do `n` different BFS\\'s, one starting at each vertex, and recording the maximum number of levels each reaches.  While we do this, we also update the components, and we return `-1` if we discover the graph is not bipartite. \\nThen we return the sum of max( `maxLevels[v]` over v in component) over all components.\\n\\nKeep track of 3 things: \\n1. `components` - this is just a mapping from component number to vertices.  So in the first example it is `1:[1,2,3,4,5,6]`\\n2. `vToComponent` - The opposite of above, node mapped to component number.  So in the example `{1:1,2:1,...,6:1}`\\n3. `maxLevels` - If we start a BFS at node v, then maxLevels[v] is the furthest we go when we start at `v`, so in the example it will be `[3,3,4,4,4,4]` because vertices 1,2 each make 3 levels while starting at any others makes 4.\\n\\nAs we go for each vertex, we make an array `level[]` where `level[x]` is the first level where `x` can be reached starting at `v`, so `level[v]=1`, and `level[u]=2` for all neighbors of `v`.  If we encounter a cycle then we just need to make sure that for edge xy, `level[x]` and `level[y]` are different parity.  If they aren\\'t then it\\'s an odd cycle.\\n\\nNote I also just made all lists by saying `range(n+1)`, technically adds extra memory but avoids a lot of `-1`\\'s everywhere to make typing simpler.  \\n\\n```\\nclass Solution(object):\\n    def magnificentSets(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        # make G\\n        G = [ [] for i in range(n+1) ]\\n        for [u,v] in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n               \\n        components = {}\\n        vToComponent = [0 for i in range(n+1)]\\n        c=0\\n        maxLevels = [0 for i in range(n+1)]\\n        \\n        for v in range(1,n+1):\\n            # components and vToComponent will be updated in the while Q loop, here just initialize\\n            if vToComponent[v]==0:\\n                c+=1\\n                components[c]=set()\\n                               \\n            level = [0 for i in range(n+1)] \\n            level[v]=1\\n            Q = [(v,1)]\\n            \\n            while Q:\\n                (x,lev) = Q.pop(0)  #pop(0) for BFS, pop() for DFS\\n                if lev>maxLevels[v]: maxLevels[v]=lev\\n                    \\n                if vToComponent[x]==0:\\n                    vToComponent[x]=c\\n                    components[c].add(x)\\n                    \\n                for y in G[x]:\\n                    if level[y]==0: \\n                        Q.append((y,lev+1))\\n                        level[y]=lev+1\\n\\t\\t\\t        # return -1 if not bipartite\\n                    elif level[x]&1==level[y]&1:  return -1\\n                                                              \\n        return sum( max(maxLevels[v] for v in components[c]) for c in components)\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def magnificentSets(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        # make G\\n        G = [ [] for i in range(n+1) ]\\n        for [u,v] in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n               \\n        components = {}",
                "codeTag": "Java"
            },
            {
                "id": 2881846,
                "title": "c-dfs-and-bfs",
                "content": "1. Find list of components (graph can be disconnected);\\n2. For each component\\'s node run bfs and calculate the maximin number of groups we can get;\\n3. In case of odd node cycle (graph isn\\'t bipartile) - return -1;\\n```\\npublic class Solution {\\n    public int MagnificentSets(int n, int[][] edges) {\\n        List<int>[] g = new List<int>[n+1];\\n        for(int i = 0; i <= n; i++) g[i] = new List<int>();\\n        foreach(int[] edge in edges){\\n            g[edge[0]].Add(edge[1]);\\n            g[edge[1]].Add(edge[0]);\\n        }\\n        int maxGroups = 0;\\n        List<IList<int>> components = GetComponents(n, g);\\n        foreach(IList<int> component in components){\\n            int maxGroupsLocal = 0;\\n            foreach(int v in component){\\n                int groups = bfs(v, g);\\n                if(groups == -1) return -1;\\n                maxGroupsLocal = Math.Max(maxGroupsLocal, groups);\\n            }\\n            maxGroups += maxGroupsLocal;\\n        }\\n        return maxGroups;\\n    }\\n    private List<IList<int>> GetComponents(int n, List<int>[] g){\\n        List<IList<int>> components = new();\\n        HashSet<int> visited = new();\\n        for(int i = 1; i <= n; i++){\\n            if(visited.Add(i)){\\n                List<int> component = new();\\n                dfs(i, component, g, visited);\\n                components.Add(component);\\n            }\\n        }\\n        return components;\\n    }\\n    private void dfs(int start, List<int> component, List<int>[] g, HashSet<int> visited){\\n        component.Add(start);\\n        foreach(int next in g[start]){\\n            if(visited.Add(next)){\\n                dfs(next, component, g, visited);\\n            }\\n        }\\n    }\\n    private int bfs(int start, List<int>[] g){\\n        int groups = 0;\\n        HashSet<int> visited = new(), previous = new();\\n        Queue<int> queue = new();\\n        queue.Enqueue(start);\\n        visited.Add(start);\\n        previous.Add(start);\\n        while(queue.Count > 0){\\n            int size = queue.Count;\\n            HashSet<int> current = new HashSet<int>();\\n            for(int i = 0; i < size; i++){\\n                int curr = queue.Dequeue();\\n                foreach(int next in g[curr]){\\n                    if(previous.Contains(next)) \\n                        return -1;\\n                    if(visited.Add(next)){\\n                        current.Add(next);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n            }\\n            previous = current;\\n            groups++;\\n        }\\n        return groups;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MagnificentSets(int n, int[][] edges) {\\n        List<int>[] g = new List<int>[n+1];\\n        for(int i = 0; i <= n; i++) g[i] = new List<int>();\\n        foreach(int[] edge in edges){\\n            g[edge[0]].Add(edge[1]);\\n            g[edge[1]].Add(edge[0]);\\n        }\\n        int maxGroups = 0;\\n        List<IList<int>> components = GetComponents(n, g);\\n        foreach(IList<int> component in components){\\n            int maxGroupsLocal = 0;\\n            foreach(int v in component){\\n                int groups = bfs(v, g);\\n                if(groups == -1) return -1;\\n                maxGroupsLocal = Math.Max(maxGroupsLocal, groups);\\n            }\\n            maxGroups += maxGroupsLocal;\\n        }\\n        return maxGroups;\\n    }\\n    private List<IList<int>> GetComponents(int n, List<int>[] g){\\n        List<IList<int>> components = new();\\n        HashSet<int> visited = new();\\n        for(int i = 1; i <= n; i++){\\n            if(visited.Add(i)){\\n                List<int> component = new();\\n                dfs(i, component, g, visited);\\n                components.Add(component);\\n            }\\n        }\\n        return components;\\n    }\\n    private void dfs(int start, List<int> component, List<int>[] g, HashSet<int> visited){\\n        component.Add(start);\\n        foreach(int next in g[start]){\\n            if(visited.Add(next)){\\n                dfs(next, component, g, visited);\\n            }\\n        }\\n    }\\n    private int bfs(int start, List<int>[] g){\\n        int groups = 0;\\n        HashSet<int> visited = new(), previous = new();\\n        Queue<int> queue = new();\\n        queue.Enqueue(start);\\n        visited.Add(start);\\n        previous.Add(start);\\n        while(queue.Count > 0){\\n            int size = queue.Count;\\n            HashSet<int> current = new HashSet<int>();\\n            for(int i = 0; i < size; i++){\\n                int curr = queue.Dequeue();\\n                foreach(int next in g[curr]){\\n                    if(previous.Contains(next)) \\n                        return -1;\\n                    if(visited.Add(next)){\\n                        current.Add(next);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n            }\\n            previous = current;\\n            groups++;\\n        }\\n        return groups;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881625,
                "title": "python3-divide-and-conquer-bfs-with-heavily-commented-code",
                "content": "Intuition:\\nTo divide a graph into groups, there must not exist cycles with odd edges, which means that the graph is bipartite.\\n\\nHow did I find it:\\nA 3-edge cycle cannot be divided into groups. This inspired me to think that the number of edges in a cycle is related to its dividability. Then I checked a cycle with 4 edges and with 5 edges and found the pattern.\\n\\nA wrong intuition:\\nStarting from any node with indegree 1 can find the max number of groups a connected component(CC) can be divided into. It seems to be true by looking at the first example but it turns out to be a special case.\\n\\nThe code is heavily commented with divided and conquer steps. BFS is used to find connected components(CC\\'s), check whether a CC is bipartite, and the number of groups a CC can be divided into. There seems to be no easy way to determine the max number of groups a CC can be divided into, so a brute force way is to start from each node with Group 1 and lable its adjacent nodes with one number larger.\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        # Build a graph.\\n        graph = collections.defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        # Divide and conquer\\n        # 1. Divide the graph into connected components;\\n        # 2. Conquer each connected component to find the max number of groups it can be divided into by BFS;\\n        # 3. Combine the max number of groups each connected component can be divided into.\\n        ret = 0\\n        # visited stores all nodes that belong to connected components(CC\\'s) that have been explored.\\n        # \"Explored\" means that a CC is chekced to be bipartite and we have calculated the max number of groups it cna be divided into.\\n        visited = set()\\n        for node in range(1, n + 1):\\n            if node not in visited:\\n                # Find a connected component by BFS and check whether it is bipartite on the go.\\n                # If it is bipartie, there is no cycle with odd number of edges,\\n                # meaning that it is possible to divide the current connected component into groups without violating the rules.\\n                connected = set()  # Stores nodes in the current component.\\n                color = [0] * (n + 1)  # There are two colors in a bipartite graph, 1 and 2.\\n                color[node] = 1\\n                q = collections.deque([node])\\n                while q:\\n                    cur = q.popleft()\\n                    connected.add(cur)\\n                    for adj in graph[cur]:\\n                        if color[adj] != 0:  # adj is visited\\n                            if color[adj] != 3 - color[cur]:\\n                                return -1\\n                        else:  # adj is not visited\\n                            color[adj] = 3 - color[cur]  # The sum of 1 and 2 is 3, alternating the color.\\n                            q.append(adj)\\n                \\n                # Find max number of groups the current connected component can be divided into by doing BFS starting from each node in the current connected component.\\n                def bfs_cc(start_node: int) -> int:\\n                    \\'\\'\\'BFS on connected components starting from start_node\\'\\'\\'\\n                    q = collections.deque([start_node])\\n                    group_cnt = 0\\n                    connected_visited = set([start_node])\\n                    while (length := len(q)) > 0:\\n                        while length > 0:\\n                            cur = q.popleft()\\n                            length -= 1\\n                            for adj in graph[cur]:\\n                                if adj not in connected_visited:\\n                                    q.append(adj)\\n                                    connected_visited.add(adj)\\n                        group_cnt += 1\\n                    return group_cnt\\n                \\n                max_group_cnt = 0\\n                for start_node in connected:\\n                    group_cnt = bfs_cc(start_node)\\n                    max_group_cnt = max(max_group_cnt, group_cnt)\\n                \\n                # Combine\\n                visited |= connected  # Merge nodes in the current connected component into the global visited nodes, all nodes in connected are explored.\\n                ret += max_group_cnt\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        # Build a graph.\\n        graph = collections.defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        # Divide and conquer\\n        # 1. Divide the graph into connected components;\\n        # 2. Conquer each connected component to find the max number of groups it can be divided into by BFS;\\n        # 3. Combine the max number of groups each connected component can be divided into.\\n        ret = 0\\n        # visited stores all nodes that belong to connected components(CC\\'s) that have been explored.\\n        # \"Explored\" means that a CC is chekced to be bipartite and we have calculated the max number of groups it cna be divided into.\\n        visited = set()\\n        for node in range(1, n + 1):\\n            if node not in visited:\\n                # Find a connected component by BFS and check whether it is bipartite on the go.\\n                # If it is bipartie, there is no cycle with odd number of edges,\\n                # meaning that it is possible to divide the current connected component into groups without violating the rules.\\n                connected = set()  # Stores nodes in the current component.\\n                color = [0] * (n + 1)  # There are two colors in a bipartite graph, 1 and 2.\\n                color[node] = 1\\n                q = collections.deque([node])\\n                while q:\\n                    cur = q.popleft()\\n                    connected.add(cur)\\n                    for adj in graph[cur]:\\n                        if color[adj] != 0:  # adj is visited\\n                            if color[adj] != 3 - color[cur]:\\n                                return -1\\n                        else:  # adj is not visited\\n                            color[adj] = 3 - color[cur]  # The sum of 1 and 2 is 3, alternating the color.\\n                            q.append(adj)\\n                \\n                # Find max number of groups the current connected component can be divided into by doing BFS starting from each node in the current connected component.\\n                def bfs_cc(start_node: int) -> int:\\n                    \\'\\'\\'BFS on connected components starting from start_node\\'\\'\\'\\n                    q = collections.deque([start_node])\\n                    group_cnt = 0\\n                    connected_visited = set([start_node])\\n                    while (length := len(q)) > 0:\\n                        while length > 0:\\n                            cur = q.popleft()\\n                            length -= 1\\n                            for adj in graph[cur]:\\n                                if adj not in connected_visited:\\n                                    q.append(adj)\\n                                    connected_visited.add(adj)\\n                        group_cnt += 1\\n                    return group_cnt\\n                \\n                max_group_cnt = 0\\n                for start_node in connected:\\n                    group_cnt = bfs_cc(start_node)\\n                    max_group_cnt = max(max_group_cnt, group_cnt)\\n                \\n                # Combine\\n                visited |= connected  # Merge nodes in the current connected component into the global visited nodes, all nodes in connected are explored.\\n                ret += max_group_cnt\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879802,
                "title": "c-dfs-bfs-group-68ms-beats-100",
                "content": "# Intuition\\n1. The valid graph is graph that has the length of cycle is even. If any of cycle has the length is odd, the result is always \"-1\".\\n2. The graph may be not connected graph, so the result is the sum of each part of the graph\\n\\n# Approach\\n1. Using dfs to split node into groups\\n2. In each group, using bfs to find the maximum level\\n3. Optimal at step 2:\\nWe don\\'t need to run all node of a group. We need to run the node that has minimum indgree. That node may be a root node that has maximum level.\\n\\n# Complexity\\n- Time complexity:\\n- worst case: O(n^2)\\n- best case: O(n);\\n\\n- Space complexity:\\nO(n);\\n\\n# Code\\n```\\ntypedef pair<int, int> ii;\\n\\nclass Solution {\\npublic:\\n    void dfs(int u, vector<vector<int>>& adj, vector<int>& g, int gId) {\\n        g[u] = gId;\\n        for (int v : adj[u]) {\\n            if (g[v] == -1) {\\n                dfs(v, adj, g, gId);\\n            }\\n        }\\n    }\\n\\n    int bfs(int start, int n, vector<vector<int>>& adj) {\\n        vector<int> vis(n+1, -1);\\n        queue<ii> q;\\n        q.push({start, -1});\\n        int level = 0;\\n        while (!q.empty()) {\\n            int qSize = q.size();\\n            while (qSize) {\\n                int u = q.front().first;\\n                int p = q.front().second;\\n                q.pop();\\n                for (int v : adj[u]) {\\n                    if (v == p) continue;\\n                    //cout<<u<<\" \"<<v<<\" \"<<vis[u]<<\" \"<<vis[v]<<endl;\\n                    if (vis[v] == -1) {\\n                        vis[v] = level+1;\\n                        q.push({v, u});\\n                    } else if (vis[v] == vis[u]){\\n                        return -1;\\n                    }\\n                }\\n                qSize--;\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n+1);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> g(n+1, -1);\\n        int gId = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (g[i] == -1) {\\n                dfs(i, adj, g, gId);\\n                gId++;\\n            }\\n        }\\n\\n        vector<ii> ind;\\n        for (int i = 1; i <= n; i++) {\\n            ind.push_back({adj[i].size(), i});\\n        }\\n        sort(ind.begin(), ind.end());\\n        vector<int> minInd(g.size(), 1000000);\\n        vector<int> res(g.size(), 0);\\n\\n        for (auto& node : ind) {\\n            int i = node.second;\\n            int indee = node.first;\\n            if (indee <= minInd[g[i]]) {\\n                minInd[g[i]] = indee;\\n                int val = bfs(i, n, adj);\\n                if (val == -1) return -1;\\n                //cout<<i<<\" \"<<val<<endl;\\n                res[g[i]] = max(res[g[i]], val);\\n            } \\n        }\\n\\n        int ans = 0;\\n        for (int r : res) {\\n            ans += r;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\ntypedef pair<int, int> ii;\\n\\nclass Solution {\\npublic:\\n    void dfs(int u, vector<vector<int>>& adj, vector<int>& g, int gId) {\\n        g[u] = gId;\\n        for (int v : adj[u]) {\\n            if (g[v] == -1) {\\n                dfs(v, adj, g, gId);\\n            }\\n        }\\n    }\\n\\n    int bfs(int start, int n, vector<vector<int>>& adj) {\\n        vector<int> vis(n+1, -1);\\n        queue<ii> q;\\n        q.push({start, -1});\\n        int level = 0;\\n        while (!q.empty()) {\\n            int qSize = q.size();\\n            while (qSize) {\\n                int u = q.front().first;\\n                int p = q.front().second;\\n                q.pop();\\n                for (int v : adj[u]) {\\n                    if (v == p) continue;\\n                    //cout<<u<<\" \"<<v<<\" \"<<vis[u]<<\" \"<<vis[v]<<endl;\\n                    if (vis[v] == -1) {\\n                        vis[v] = level+1;\\n                        q.push({v, u});\\n                    } else if (vis[v] == vis[u]){\\n                        return -1;\\n                    }\\n                }\\n                qSize--;\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n+1);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> g(n+1, -1);\\n        int gId = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (g[i] == -1) {\\n                dfs(i, adj, g, gId);\\n                gId++;\\n            }\\n        }\\n\\n        vector<ii> ind;\\n        for (int i = 1; i <= n; i++) {\\n            ind.push_back({adj[i].size(), i});\\n        }\\n        sort(ind.begin(), ind.end());\\n        vector<int> minInd(g.size(), 1000000);\\n        vector<int> res(g.size(), 0);\\n\\n        for (auto& node : ind) {\\n            int i = node.second;\\n            int indee = node.first;\\n            if (indee <= minInd[g[i]]) {\\n                minInd[g[i]] = indee;\\n                int val = bfs(i, n, adj);\\n                if (val == -1) return -1;\\n                //cout<<i<<\" \"<<val<<endl;\\n                res[g[i]] = max(res[g[i]], val);\\n            } \\n        }\\n\\n        int ans = 0;\\n        for (int r : res) {\\n            ans += r;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2879578,
                "title": "dfs-bfs-with-q-as-proof-this-should-answer-all-your-questions",
                "content": "[Join the unofficial discord server to discuss daily questions](https://discord.gg/u62xsFbQxK) \\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nQuote: \"I started from the second example and saw 3 edges is invalid.\\nThen I tried to draw 4 edges, 5 edges, 6, and 7, then thought it is odd even number maybe.\" - a comment from Discussion somewhere that I can\\'t find now.\\n\\nAlthough it seems more like an m-color-problem, it\\'s actually bipartite check.\\n\\nWe can use layered BFS to get the largest distance:\\n\\nQ: Whether, in the middle of the traversal, a particular node needs to be placed in an earlier group.\\nA: No, since if so, the traversal would have used that node in an earlier group already.\\n\\nQ: Could the initial group have more than 1 node?\\nA: No. We know the nodes in one group can\\'t have edges in between, so they are disconnected and could ben broken into more groups.\\n\\nQ: Which node we should start with?\\nA: We need to try each one. Think about the case of an infinity structure. Starting with the middle node is better than a side one.\\n\\nQ: Could we early stop?\\nA: Yes. If in the same cycle, we have a bad case. That circle would show up no matter how we start.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nNow that we only have to check each cycle, we can use induction to prove the quote at the top.\\nThat is the property of bipartite check, so this question is really bipartite check.\\n\\n# Complexity\\n- Time complexity: O(V(V + E))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nAdded comments for [@ye15\\'s solution](https://leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/solutions/2875146/c-python3-dfs-bfs/)\\n```\\n// Bipartite check:\\n// T: O(V(V + E))\\n// S: O(V)\\n#include <iostream>\\n#include <vector>\\n#include <stack>\\n#include <queue>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for (auto& e : edges) {  // E\\n            graph[e[0]-1].push_back(e[1]-1);\\n            graph[e[1]-1].push_back(e[0]-1);\\n        }\\n\\n        vector<int> seen(n);\\n        vector<vector<int>> group;\\n\\n        for (int i = 0; i < n; ++i) {  // V + E\\n            if (seen[i])\\n                continue;\\n\\n            seen[i] = 1;\\n            group.push_back({i});\\n            // We need to check for all cycles that include this node, so we have to use DFS and can\\'t use BFS\\n            stack<int> stk;\\n            stk.push(i);\\n\\n            while (!stk.empty()) {\\n                auto u = stk.top();\\n                stk.pop();\\n\\n                for (auto v: graph[u])\\n                    if (!seen[v]) {\\n                        seen[v] = seen[u] + 1;\\n                        stk.push(v);\\n                        group.back().push_back(v);\\n                      // check parity of adjacent nodes. If they have the same parity, then an odd-length cycle is found.\\n                    } else if ((seen[u] & 1) == (seen[v] & 1))\\n                        return -1;\\n            }\\n        }\\n\\n        // We have to get the max number of layers, so Bwe have to use BFS and can\\'t\\' use DFS\\n        auto bfs = [&](int x) {\\n            int num_level = 0;\\n            vector<bool> seen(n);\\n            seen[x] = true;\\n            queue<int> q;\\n            q.push(x);\\n\\n            while(!q.empty()) {\\n                ++num_level;\\n\\n                for (int sz = (int) q.size(); sz; --sz) {\\n                    auto u = q.front();\\n                    q.pop();\\n\\n                    for (auto v: graph[u])\\n                        if (!seen[v]) {\\n                            seen[v] = true;\\n                            q.push(v);\\n                        }\\n                }\\n            }\\n\\n            return num_level;\\n        };\\n\\n        int ans = 0;\\n\\n        for (auto& g : group) {  // V\\n            transform(g.begin(), g.end(), g.begin(), bfs);  // V + E\\n            ans += *max_element(g.begin(), g.end());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Bipartite check:\\n// T: O(V(V + E))\\n// S: O(V)\\n#include <iostream>\\n#include <vector>\\n#include <stack>\\n#include <queue>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for (auto& e : edges) {  // E\\n            graph[e[0]-1].push_back(e[1]-1);\\n            graph[e[1]-1].push_back(e[0]-1);\\n        }\\n\\n        vector<int> seen(n);\\n        vector<vector<int>> group;\\n\\n        for (int i = 0; i < n; ++i) {  // V + E\\n            if (seen[i])\\n                continue;\\n\\n            seen[i] = 1;\\n            group.push_back({i});\\n            // We need to check for all cycles that include this node, so we have to use DFS and can\\'t use BFS\\n            stack<int> stk;\\n            stk.push(i);\\n\\n            while (!stk.empty()) {\\n                auto u = stk.top();\\n                stk.pop();\\n\\n                for (auto v: graph[u])\\n                    if (!seen[v]) {\\n                        seen[v] = seen[u] + 1;\\n                        stk.push(v);\\n                        group.back().push_back(v);\\n                      // check parity of adjacent nodes. If they have the same parity, then an odd-length cycle is found.\\n                    } else if ((seen[u] & 1) == (seen[v] & 1))\\n                        return -1;\\n            }\\n        }\\n\\n        // We have to get the max number of layers, so Bwe have to use BFS and can\\'t\\' use DFS\\n        auto bfs = [&](int x) {\\n            int num_level = 0;\\n            vector<bool> seen(n);\\n            seen[x] = true;\\n            queue<int> q;\\n            q.push(x);\\n\\n            while(!q.empty()) {\\n                ++num_level;\\n\\n                for (int sz = (int) q.size(); sz; --sz) {\\n                    auto u = q.front();\\n                    q.pop();\\n\\n                    for (auto v: graph[u])\\n                        if (!seen[v]) {\\n                            seen[v] = true;\\n                            q.push(v);\\n                        }\\n                }\\n            }\\n\\n            return num_level;\\n        };\\n\\n        int ans = 0;\\n\\n        for (auto& g : group) {  // V\\n            transform(g.begin(), g.end(), g.begin(), bfs);  // V + E\\n            ans += *max_element(g.begin(), g.end());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2879465,
                "title": "n-time-bfs-without-bipartite-check",
                "content": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, e: List[List[int]]) -> int:\\n        ajc = defaultdict(list)\\n        \\n        for i , j in e:\\n            ajc[i].append(j)\\n            ajc[j].append(i)\\n            \\n        def st(i):\\n            rt , cur , used , vi = 1 , [i] , {i} , [0] * (n+1)\\n            vi[i] = 1\\n            while cur:\\n                nxt = set()\\n                for v in cur:\\n                    for u in ajc[v]:\\n                        if vi[u] == rt:         # this is to check if there is an edge between nodes in the \\n                            return -1 , -1      # same level which is invalid \\n                        elif vi[u] == 0:\\n                            used.add(u)\\n                            nxt.add(u)\\n                            vi[u] = rt +1\\n                cur = nxt\\n                if not cur: break\\n                rt += 1\\n            return min(used) , rt\\n                        \\n                \\n        ans = {}\\n        for j in range(1 , n+1):\\n            rep , rt = st(j)\\n            if rep == -1:\\n                return -1\\n            ans[rep] = max(ans.get(rep , 0) , rt)\\n                \\n        return sum(ans.values())\\n                        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, e: List[List[int]]) -> int:\\n        ajc = defaultdict(list)\\n        \\n        for i , j in e:\\n            ajc[i].append(j)\\n            ajc[j].append(i)\\n            \\n        def st(i):\\n            rt , cur , used , vi = 1 , [i] , {i} , [0] * (n+1)\\n            vi[i] = 1\\n            while cur:\\n                nxt = set()\\n                for v in cur:\\n                    for u in ajc[v]:\\n                        if vi[u] == rt:         # this is to check if there is an edge between nodes in the \\n                            return -1 , -1      # same level which is invalid \\n                        elif vi[u] == 0:\\n                            used.add(u)\\n                            nxt.add(u)\\n                            vi[u] = rt +1\\n                cur = nxt\\n                if not cur: break\\n                rt += 1\\n            return min(used) , rt\\n                        \\n                \\n        ans = {}\\n        for j in range(1 , n+1):\\n            rep , rt = st(j)\\n            if rep == -1:\\n                return -1\\n            ans[rep] = max(ans.get(rep , 0) , rt)\\n                \\n        return sum(ans.values())\\n                        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879109,
                "title": "bfs-first-to-check-bipartite-graph-bfs-second-to-find-the-groups",
                "content": "```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        // set up graph\\n        vector<vector<int>> adj(n + 1);\\n        for (vector<int>& edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            adj[u].emplace_back(v);\\n            adj[v].emplace_back(u);\\n        }\\n        // walk each connected component, return -1 if not bipartite, assign cid\\n        vector<int> cids(n + 1, 0);\\n        int curr_cid = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (cids[i] == 0) {\\n                unordered_set<int> enqd, curr;\\n                curr.emplace(i);\\n                enqd.emplace(i);\\n                while (!curr.empty()) {\\n                    unordered_set<int> next;\\n                    for (int j : curr) {\\n                        cids[j] = curr_cid;\\n                        for (int k : adj[j]) {\\n                            if (curr.count(k)) {\\n                                return -1;\\n                            } else if (enqd.count(k)) {\\n                                continue;\\n                            } else {\\n                                next.emplace(k);\\n                                enqd.emplace(k);\\n                            }\\n                        }\\n                    }\\n                    curr = move(next);\\n                }\\n                ++curr_cid;\\n            }\\n        }\\n        // for each node, bfs from it, write down a depth int val\\n        vector<int> depth(n + 1, 0);\\n        for (int i = 1; i <= n; ++i) {\\n            unordered_set<int> enqd, curr;\\n            curr.emplace(i);\\n            enqd.emplace(i);\\n            int d = 0;\\n            while (!curr.empty()) {\\n                ++d;\\n                unordered_set<int> next;\\n                for (int j : curr) {\\n                    for (int k : adj[j]) {\\n                        if (enqd.count(k)) {\\n                            continue;\\n                        } else {\\n                            next.emplace(k);\\n                            enqd.emplace(k);\\n                        }\\n                    }\\n                }\\n                curr = move(next);\\n            }\\n            depth[i] = d;\\n        }\\n        // final stage\\n        unordered_map<int, int> m;\\n        for (int i = 1; i <= n; ++i) {\\n            m[cids[i]] = max(m[cids[i]], depth[i]);\\n        }\\n        int ans = 0;\\n        for (auto [_, v]: m) {\\n            ans += v;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        // set up graph\\n        vector<vector<int>> adj(n + 1);\\n        for (vector<int>& edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            adj[u].emplace_back(v);\\n            adj[v].emplace_back(u);\\n        }\\n        // walk each connected component, return -1 if not bipartite, assign cid\\n        vector<int> cids(n + 1, 0);\\n        int curr_cid = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (cids[i] == 0) {\\n                unordered_set<int> enqd, curr;\\n                curr.emplace(i);\\n                enqd.emplace(i);\\n                while (!curr.empty()) {\\n                    unordered_set<int> next;\\n                    for (int j : curr) {\\n                        cids[j] = curr_cid;\\n                        for (int k : adj[j]) {\\n                            if (curr.count(k)) {\\n                                return -1;\\n                            } else if (enqd.count(k)) {\\n                                continue;\\n                            } else {\\n                                next.emplace(k);\\n                                enqd.emplace(k);\\n                            }\\n                        }\\n                    }\\n                    curr = move(next);\\n                }\\n                ++curr_cid;\\n            }\\n        }\\n        // for each node, bfs from it, write down a depth int val\\n        vector<int> depth(n + 1, 0);\\n        for (int i = 1; i <= n; ++i) {\\n            unordered_set<int> enqd, curr;\\n            curr.emplace(i);\\n            enqd.emplace(i);\\n            int d = 0;\\n            while (!curr.empty()) {\\n                ++d;\\n                unordered_set<int> next;\\n                for (int j : curr) {\\n                    for (int k : adj[j]) {\\n                        if (enqd.count(k)) {\\n                            continue;\\n                        } else {\\n                            next.emplace(k);\\n                            enqd.emplace(k);\\n                        }\\n                    }\\n                }\\n                curr = move(next);\\n            }\\n            depth[i] = d;\\n        }\\n        // final stage\\n        unordered_map<int, int> m;\\n        for (int i = 1; i <= n; ++i) {\\n            m[cids[i]] = max(m[cids[i]], depth[i]);\\n        }\\n        int ans = 0;\\n        for (auto [_, v]: m) {\\n            ans += v;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878815,
                "title": "python3-o-n-2-bipartite-graph-check-and-level-bfs",
                "content": "We use min value node to represent connect component. *ans* is used to mark max depth of a connect component.\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges:\\n            graph[u - 1].append(v - 1)\\n            graph[v - 1].append(u - 1)\\n        is_bipartite, q ,side = True, deque(), [-1] * n\\n        for st in range(n):\\n            if side[st] == -1:\\n                q.append(st)\\n                side[st] = 0\\n                while q:\\n                    v = q.popleft()\\n                    for u in graph[v]:\\n                        if side[u] == -1:\\n                            side[u] = side[v] ^ 1\\n                            q.append(u)\\n                        else:\\n                            is_bipartite = is_bipartite and (side[u] != side[v])\\n            if not is_bipartite: return -1\\n        def getmaxdepth(v):\\n            ret, cur, used = 1, [v], {v}\\n            while cur:\\n                nxt = set()\\n                for v in cur:\\n                    for u in graph[v]:\\n                        if u not in used:\\n                            used.add(u)\\n                            nxt.add(u)\\n                cur = nxt\\n                if not cur: break\\n                ret += 1\\n            return min(used), ret\\n        ans = dict()\\n        for v in range(n):\\n            rep, depth = getmaxdepth(v)\\n            ans[rep] = max(ans.get(rep, 0), depth)\\n        return sum(ans.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges:\\n            graph[u - 1].append(v - 1)\\n            graph[v - 1].append(u - 1)\\n        is_bipartite, q ,side = True, deque(), [-1] * n\\n        for st in range(n):\\n            if side[st] == -1:\\n                q.append(st)\\n                side[st] = 0\\n                while q:\\n                    v = q.popleft()\\n                    for u in graph[v]:\\n                        if side[u] == -1:\\n                            side[u] = side[v] ^ 1\\n                            q.append(u)\\n                        else:\\n                            is_bipartite = is_bipartite and (side[u] != side[v])\\n            if not is_bipartite: return -1\\n        def getmaxdepth(v):\\n            ret, cur, used = 1, [v], {v}\\n            while cur:\\n                nxt = set()\\n                for v in cur:\\n                    for u in graph[v]:\\n                        if u not in used:\\n                            used.add(u)\\n                            nxt.add(u)\\n                cur = nxt\\n                if not cur: break\\n                ret += 1\\n            return min(used), ret\\n        ans = dict()\\n        for v in range(n):\\n            rep, depth = getmaxdepth(v)\\n            ans[rep] = max(ans.get(rep, 0), depth)\\n        return sum(ans.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878767,
                "title": "python3-union-find-bfs-comment-in-top-down-fashion-or-trying-to",
                "content": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        def union(a,b):\\n            x = find(a)\\n            y = find(b)\\n            uf[y] = x                                       \\n        \\n        def find(a):\\n            if uf[a] != a:\\n                uf[a] = find(uf[a])\\n            return uf[a]\\n\\n        g = defaultdict(set)                                # make graph\\n        for (a,b) in edges:\\n            g[a].add(b)\\n            g[b].add(a)\\n        \\n        uf = list(range(n+1))                               # set up union find\\n        for (a,b) in edges:\\n            union(a,b)\\n        \\n        d = defaultdict(set)                                # get all connected components\\n        for i in range(1,n+1):\\n            d[find(i)].add(i)\\n        comps = d.values()                                  \\n            \\n        def max_partition(component):                       # find max number of partitions by\\n            mx = 0\\n            for n in component:                             # try bfs on every node in the component\\n                ct = 0\\n                dq = deque([n])\\n                visited = set([n])\\n                while dq:                                   \\n                    for _ in range(len(dq)):                # traverse by partitions\\n                        n = dq.popleft()\\n                        for m in g[n]:\\n                            if m not in visited:\\n                                visited.add(m)\\n                                dq.append(m)\\n                    if disjoint(dq):                        # nodes in a partition are disjoint\\n                        ct += 1\\n                    else: \\n                        return 0\\n                mx = max(mx, ct)\\n            return mx\\n         \\n        def disjoint(partition):\\n            s = set(partition)\\n            for n in partition:\\n                s.remove(n)\\n                if s & g[n]:\\n                    return False\\n                s.add(n)\\n            return True\\n        \\n        res = 0\\n        for c in comps:                                     # for every component\\n            n = max_partition(c) \\n            if n == 0:                                      # make sure it can be partitioned\\n                return -1\\n            res += n                                        # add up the max ways it can be paritioned\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        def union(a,b):\\n            x = find(a)\\n            y = find(b)\\n            uf[y] = x                                       \\n        \\n        def find(a):\\n            if uf[a] != a:\\n                uf[a] = find(uf[a])\\n            return uf[a]\\n\\n        g = defaultdict(set)                                # make graph\\n        for (a,b) in edges:\\n            g[a].add(b)\\n            g[b].add(a)\\n        \\n        uf = list(range(n+1))                               # set up union find\\n        for (a,b) in edges:\\n            union(a,b)\\n        \\n        d = defaultdict(set)                                # get all connected components\\n        for i in range(1,n+1):\\n            d[find(i)].add(i)\\n        comps = d.values()                                  \\n            \\n        def max_partition(component):                       # find max number of partitions by\\n            mx = 0\\n            for n in component:                             # try bfs on every node in the component\\n                ct = 0\\n                dq = deque([n])\\n                visited = set([n])\\n                while dq:                                   \\n                    for _ in range(len(dq)):                # traverse by partitions\\n                        n = dq.popleft()\\n                        for m in g[n]:\\n                            if m not in visited:\\n                                visited.add(m)\\n                                dq.append(m)\\n                    if disjoint(dq):                        # nodes in a partition are disjoint\\n                        ct += 1\\n                    else: \\n                        return 0\\n                mx = max(mx, ct)\\n            return mx\\n         \\n        def disjoint(partition):\\n            s = set(partition)\\n            for n in partition:\\n                s.remove(n)\\n                if s & g[n]:\\n                    return False\\n                s.add(n)\\n            return True\\n        \\n        res = 0\\n        for c in comps:                                     # for every component\\n            n = max_partition(c) \\n            if n == 0:                                      # make sure it can be partitioned\\n                return -1\\n            res += n                                        # add up the max ways it can be paritioned\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878389,
                "title": "repeated-bfs-with-every-node-as-root-c",
                "content": "```\\nclass Solution {\\npublic:\\n  struct Node {\\n    Node() {}\\n    \\n    // Index of the connected graph this node is a part of.\\n    int connectedGraph = -1;\\n    \\n    // Whether this node has been visited before during BFS.\\n    bool visited = false;\\n    \\n    // Neigbors of this node.\\n    vector<int> neighbors;\\n  };\\n  \\n  // Find the number of levels found during BFS starting from nodeIdx as root.\\n  int numLevels(int nodeIdx, int connectedGraph, vector<Node>& graph) {\\n    auto& node = graph[nodeIdx];\\n    \\n    int maxLvls = 0;\\n    queue<pair<int, int>> q;\\n    q.push({nodeIdx, 1});\\n    vector<int> nodeToLvl(graph.size(), -1);\\n    while (!q.empty()) {\\n      auto [ndIdx, lvl] = q.front(); q.pop();\\n      auto& nd = graph[ndIdx];\\n      nd.connectedGraph = connectedGraph;\\n      nd.visited = true;\\n      nodeToLvl[ndIdx] = lvl;\\n      maxLvls = max(maxLvls, lvl);\\n      for (int& childIdx : nd.neighbors) {\\n        if (nodeToLvl[childIdx] != -1) {\\n          if (abs(nodeToLvl[childIdx] - lvl) != 1) {\\n            return -1;\\n          }\\n          continue;\\n        }\\n        nodeToLvl[childIdx] = lvl + 1;\\n        q.push({childIdx, lvl + 1});\\n      }\\n    }\\n    return maxLvls;\\n  }\\n  \\n  int magnificentSets(int n, vector<vector<int>>& edges) {\\n    // Build graph.\\n    vector<Node> graph(n + 1);\\n    for (auto& e : edges) {\\n      graph[e[0]].neighbors.push_back(e[1]);\\n      graph[e[1]].neighbors.push_back(e[0]);\\n    }\\n    \\n    vector<int> connectedGraphToGrps(n, 0);\\n    int connectedGraph = 0;\\n    for (int i = 1; i <= n; ++i) {\\n      auto& node = graph[i];\\n      \\n      // New connected component found.\\n      if (!node.visited) {\\n        connectedGraph++;\\n        node.connectedGraph = connectedGraph;\\n      }\\n      \\n      // Divide each level into a separate group.\\n      int groups = numLevels(i, node.connectedGraph, graph);\\n      \\n      // This graph is invalid (i.e. not bipartite) for group division.\\n      if (groups == -1) return -1;\\n      \\n      // For every subgraph, record the most levels found when\\n      // approaching it from different nodes as root.\\n      connectedGraphToGrps[node.connectedGraph] =\\n        max(connectedGraphToGrps[node.connectedGraph], groups);\\n    }\\n    \\n    // Add up the max groups for every connected component.\\n    int tot = 0;\\n    for (int val : connectedGraphToGrps) {\\n      tot += val;\\n    }\\n    return tot;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  struct Node {\\n    Node() {}\\n    \\n    // Index of the connected graph this node is a part of.\\n    int connectedGraph = -1;\\n    \\n    // Whether this node has been visited before during BFS.\\n    bool visited = false;\\n    \\n    // Neigbors of this node.\\n    vector<int> neighbors;\\n  };\\n  \\n  // Find the number of levels found during BFS starting from nodeIdx as root.\\n  int numLevels(int nodeIdx, int connectedGraph, vector<Node>& graph) {\\n    auto& node = graph[nodeIdx];\\n    \\n    int maxLvls = 0;\\n    queue<pair<int, int>> q;\\n    q.push({nodeIdx, 1});\\n    vector<int> nodeToLvl(graph.size(), -1);\\n    while (!q.empty()) {\\n      auto [ndIdx, lvl] = q.front(); q.pop();\\n      auto& nd = graph[ndIdx];\\n      nd.connectedGraph = connectedGraph;\\n      nd.visited = true;\\n      nodeToLvl[ndIdx] = lvl;\\n      maxLvls = max(maxLvls, lvl);\\n      for (int& childIdx : nd.neighbors) {\\n        if (nodeToLvl[childIdx] != -1) {\\n          if (abs(nodeToLvl[childIdx] - lvl) != 1) {\\n            return -1;\\n          }\\n          continue;\\n        }\\n        nodeToLvl[childIdx] = lvl + 1;\\n        q.push({childIdx, lvl + 1});\\n      }\\n    }\\n    return maxLvls;\\n  }\\n  \\n  int magnificentSets(int n, vector<vector<int>>& edges) {\\n    // Build graph.\\n    vector<Node> graph(n + 1);\\n    for (auto& e : edges) {\\n      graph[e[0]].neighbors.push_back(e[1]);\\n      graph[e[1]].neighbors.push_back(e[0]);\\n    }\\n    \\n    vector<int> connectedGraphToGrps(n, 0);\\n    int connectedGraph = 0;\\n    for (int i = 1; i <= n; ++i) {\\n      auto& node = graph[i];\\n      \\n      // New connected component found.\\n      if (!node.visited) {\\n        connectedGraph++;\\n        node.connectedGraph = connectedGraph;\\n      }\\n      \\n      // Divide each level into a separate group.\\n      int groups = numLevels(i, node.connectedGraph, graph);\\n      \\n      // This graph is invalid (i.e. not bipartite) for group division.\\n      if (groups == -1) return -1;\\n      \\n      // For every subgraph, record the most levels found when\\n      // approaching it from different nodes as root.\\n      connectedGraphToGrps[node.connectedGraph] =\\n        max(connectedGraphToGrps[node.connectedGraph], groups);\\n    }\\n    \\n    // Add up the max groups for every connected component.\\n    int tot = 0;\\n    for (int val : connectedGraphToGrps) {\\n      tot += val;\\n    }\\n    return tot;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878313,
                "title": "python-check-max-height-of-all-tree",
                "content": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        g = defaultdict(list)\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n            \\n        def bfs(root, visited):\\n            q = deque([(root, 1)])\\n            ans = 0\\n            while q:\\n                node, level = q.popleft()\\n                ans = max(ans, level)\\n                seen.add(node)\\n                for nei in g[node]:\\n                    if nei in visited:\\n                        if abs(visited[node] - visited[nei]) != 1:\\n                            return -1\\n                        continue\\n                    q.append((nei, level + 1))\\n                    visited[nei] = level + 1\\n            return ans\\n        \\n        components = []\\n        seen = set()\\n        for node in range(1, n + 1):\\n            if node not in seen:\\n                visited = {node : 1}\\n                val = bfs(node, visited)\\n                components.append(visited)\\n                if val == -1:\\n                    return -1\\n        \\n        res = 0\\n        for component in components:\\n            val = 0\\n            for node in component:\\n                val = max(val, bfs(node, {node : 1}))\\n            res += val\\n        \\n        return res",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        g = defaultdict(list)\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n            \\n        def bfs(root, visited):\\n            q = deque([(root, 1)])\\n            ans = 0\\n            while q:\\n                node, level = q.popleft()\\n                ans = max(ans, level)\\n                seen.add(node)\\n                for nei in g[node]:\\n                    if nei in visited:\\n                        if abs(visited[node] - visited[nei]) != 1:\\n                            return -1\\n                        continue\\n                    q.append((nei, level + 1))\\n                    visited[nei] = level + 1\\n            return ans\\n        \\n        components = []\\n        seen = set()\\n        for node in range(1, n + 1):\\n            if node not in seen:\\n                visited = {node : 1}",
                "codeTag": "Java"
            },
            {
                "id": 2878269,
                "title": "scala-pure-functional-disjoint-set-bfs",
                "content": "```Scala\\nobject Solution {\\n    def magnificentSets(n: Int, edges: Array[Array[Int]]): Int = {        \\n        def find(p: Map[Int, Int])(x: Int): Int = if (p(x) == x) x else find(p)(p(x))\\n        \\n        def union(p: Map[Int, Int], a: Array[Int]) = {\\n            val Array(rx, ry) = a.map(find(p))\\n            p + (rx -> ry)\\n        }\\n        \\n        val parents = edges.foldLeft((1 to n).zip(1 to n).toMap)(union)\\n        val groups = (1 to n).groupBy(find(parents)).values\\n        \\n        val adj = edges.foldLeft(Map[Int, Set[Int]]().withDefaultValue(Set[Int]())) {\\n            case (m, Array(x, y)) => m + (x -> (m(x) + y)) + (y -> (m(y) + x))\\n        }\\n        \\n        def bfs(layer: Set[Int], visited: Set[Int], groups: Int): Int = {\\n            if (layer.isEmpty) groups else {\\n                val nexts = layer.flatMap(adj(_).filter(!visited.contains(_))).toSet\\n                if ((nexts & layer).size > 0) -1\\n                else bfs(nexts, visited ++ layer, groups + 1)\\n            }\\n        }\\n                        \\n        val results = groups.map(_.map(y => bfs(Set(y), Set[Int](), 0)).max).toSeq\\n        if (results.contains(-1)) -1 else results.sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```Scala\\nobject Solution {\\n    def magnificentSets(n: Int, edges: Array[Array[Int]]): Int = {        \\n        def find(p: Map[Int, Int])(x: Int): Int = if (p(x) == x) x else find(p)(p(x))\\n        \\n        def union(p: Map[Int, Int], a: Array[Int]) = {\\n            val Array(rx, ry) = a.map(find(p))\\n            p + (rx -> ry)\\n        }\\n        \\n        val parents = edges.foldLeft((1 to n).zip(1 to n).toMap)(union)\\n        val groups = (1 to n).groupBy(find(parents)).values\\n        \\n        val adj = edges.foldLeft(Map[Int, Set[Int]]().withDefaultValue(Set[Int]())) {\\n            case (m, Array(x, y)) => m + (x -> (m(x) + y)) + (y -> (m(y) + x))\\n        }\\n        \\n        def bfs(layer: Set[Int], visited: Set[Int], groups: Int): Int = {\\n            if (layer.isEmpty) groups else {\\n                val nexts = layer.flatMap(adj(_).filter(!visited.contains(_))).toSet\\n                if ((nexts & layer).size > 0) -1\\n                else bfs(nexts, visited ++ layer, groups + 1)\\n            }\\n        }\\n                        \\n        val results = groups.map(_.map(y => bfs(Set(y), Set[Int](), 0)).max).toSeq\\n        if (results.contains(-1)) -1 else results.sum\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2878239,
                "title": "java",
                "content": "\\tclass Solution {\\n\\t\\tMap<Integer,List<Integer>> hmap;\\n\\n\\t\\tpublic int magnificentSets(int n, int[][] edges) {\\n\\n\\t\\t\\tcreateGraph(n, edges);\\n\\t\\t\\tList<List<Integer>> connections = getConnections(n);    //get all disconnected graphs\\n\\t\\t\\treturn getGroups(connections, n);\\n\\t\\t} \\n\\n\\t\\tprivate void createGraph(int n, int[][] edges){\\n\\t\\t\\thmap = new HashMap<>();\\n\\t\\t\\tfor(int i = 1; i <= n; i++)\\n\\t\\t\\t\\thmap.put(i, new ArrayList<>());\\n\\n\\t\\t\\tfor(int[] i : edges){                       // undirected graph\\n\\t\\t\\t\\thmap.get(i[0]).add(i[1]);\\n\\t\\t\\t\\thmap.get(i[1]).add(i[0]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate List<List<Integer>> getConnections(int n){\\n\\t\\t\\tboolean[] isVisited = new boolean[n+1];\\n\\t\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\t\\tfor(int i = 1; i <= n; i++)\\n\\t\\t\\t\\tif(!isVisited[i])\\n\\t\\t\\t\\t\\tans.add(visit(i, new ArrayList<>(), isVisited));\\n\\t\\t\\treturn ans;   \\n\\t\\t}\\n\\n\\t\\tprivate List<Integer> visit (int curr, List<Integer> nodes, boolean[] isVisited){\\n\\t\\t\\tisVisited[curr] = true;\\n\\t\\t\\tnodes.add(curr);\\n\\t\\t\\tfor(int i : hmap.get(curr)){\\n\\t\\t\\t\\t\\tif (isVisited[i]) continue;\\n\\t\\t\\t\\t\\tvisit (i, nodes, isVisited);\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn nodes;\\n\\t\\t}\\n\\n\\t\\tprivate int getGroups(List<List<Integer>> connections, int n){\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(List<Integer> connection : connections){\\n\\t\\t\\t\\tint groups = -1;\\n\\t\\t\\t\\tfor(int i : connection)\\n\\t\\t\\t\\t\\tgroups = Math.max(groups, find(i, n));\\n\\n\\t\\t\\t\\tif(groups == -1)\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\tans += groups;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tprivate int find(int node, int n){\\n\\t\\t\\tboolean[] visited = new boolean[n+1];\\n\\t\\t\\tint groups = 0;\\n\\n\\t\\t\\tQueue<Integer> queue = new LinkedList<>();\\n\\t\\t\\tqueue.add(node);\\n\\t\\t\\twhile(!queue.isEmpty()){\\n\\n\\t\\t\\t\\tint size = queue.size();\\n\\t\\t\\t\\tSet<Integer> hset = new HashSet<>();\\n\\n\\t\\t\\t\\twhile(size-- > 0){\\n\\t\\t\\t\\t\\tint curr = queue.poll();\\n\\t\\t\\t\\t\\tif(visited[curr])\\n\\t\\t\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\t\\t\\tvisited[curr] = true;\\n\\t\\t\\t\\t\\tfor(int i : hmap.get(curr))\\n\\t\\t\\t\\t\\t\\tif(!visited[i])\\n\\t\\t\\t\\t\\t\\t\\thset.add(i);     \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tqueue.addAll(hset);\\n\\t\\t\\t\\tgroups++;\\n\\t\\t\\t}\\n\\t\\t\\treturn groups;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tMap<Integer,List<Integer>> hmap;\\n\\n\\t\\tpublic int magnificentSets(int n, int[][] edges) {\\n\\n\\t\\t\\tcreateGraph(n, edges);\\n\\t\\t\\tList<List<Integer>> connections = getConnections(n);    //get all disconnected graphs\\n\\t\\t\\treturn getGroups(connections, n);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2878228,
                "title": "bfs-from-each-node-with-explanation-python3",
                "content": "# Intuition\\nReally appreciate it someone can tell how they come up with this intuition...\\nI can only say one way might be, to start from a tree rather than a general graph, then maybe we can figure out that bfs from each node can give us answer.\\n\\n# Approach\\nStep 1: UF to find connected componenets\\n\\nStep 2: For each component, for each node in this component, do bfs from this node, and record the largest possible layer. \\n\\nIn the bfs process, if we found a neighbor that we have seen before, and it is not just 1 layer up or 1 layer down, then we know the group assignment has failed (since any two nodes share an edge must be in adjacent layers according to requirements), and we return -1.\\n\\nStep 3: Final answer is the sum of max layers in all components. If any components returned -1, then the final answer would be -1.\\n\\nNote that another approach to check if we return -1 is to check if graph is bipartite or not (which is equivalent to the fact that graph only contains cycles of even length or not; we return -1 if it contains any odd length cycle). This can be done by dfs with coloring.\\n\\n# Complexity\\n- Time complexity:\\nO (n^2)\\n\\n# Code\\n```\\nclass UF:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n)]\\n    \\n    def find(self, i):\\n        while i != self.par[i]:\\n            self.par[i] = self.par[self.par[i]]\\n            i = self.par[i]\\n        return i\\n    \\n    def union(self,i, j):\\n        par_i = self.find(i)\\n        par_j = self.find(j)\\n        if par_i != par_j:\\n            self.par[par_i] = par_j\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        uf = UF(n+1)\\n        for i, j in edges:\\n            uf.union(i, j)\\n        comp = defaultdict(list)\\n        for i in range(1, n+1):\\n            par = uf.find(i)\\n            comp[par].append(i)\\n        graph = collections.defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        def bfs(root):\\n            # return max layers, or -1 if bad cycle\\n            dq = deque([(root, 1)])\\n            seen = dict()\\n            seen[root] = 1\\n            while dq:\\n                node, lvl = dq.popleft()\\n                for nei in graph[node]:\\n                    # if have seen neibor, and it is not lie in immediate previous level or immediate next level, then the assignment failed\\n                    if nei in seen and (seen[nei] != lvl+1 and seen[nei] != lvl-1):\\n                        return -1\\n                    if nei not in seen:\\n                        dq.append((nei, lvl+1))\\n                        seen[nei] = lvl + 1\\n            return lvl \\n\\n        # for each comp, for each node in this comp, do bfs\\n        res = 0\\n        for k, lst in comp.items():\\n            ans = -1\\n            for i in lst:\\n                tmp = bfs(i)\\n                ans = max(ans, tmp)\\n            if ans == -1:\\n                return -1\\n            res += ans\\n        return res\\n\\n\\n\\n\\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass UF:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n)]\\n    \\n    def find(self, i):\\n        while i != self.par[i]:\\n            self.par[i] = self.par[self.par[i]]\\n            i = self.par[i]\\n        return i\\n    \\n    def union(self,i, j):\\n        par_i = self.find(i)\\n        par_j = self.find(j)\\n        if par_i != par_j:\\n            self.par[par_i] = par_j\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        uf = UF(n+1)\\n        for i, j in edges:\\n            uf.union(i, j)\\n        comp = defaultdict(list)\\n        for i in range(1, n+1):\\n            par = uf.find(i)\\n            comp[par].append(i)\\n        graph = collections.defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        def bfs(root):\\n            # return max layers, or -1 if bad cycle\\n            dq = deque([(root, 1)])\\n            seen = dict()\\n            seen[root] = 1\\n            while dq:\\n                node, lvl = dq.popleft()\\n                for nei in graph[node]:\\n                    # if have seen neibor, and it is not lie in immediate previous level or immediate next level, then the assignment failed\\n                    if nei in seen and (seen[nei] != lvl+1 and seen[nei] != lvl-1):\\n                        return -1\\n                    if nei not in seen:\\n                        dq.append((nei, lvl+1))\\n                        seen[nei] = lvl + 1\\n            return lvl \\n\\n        # for each comp, for each node in this comp, do bfs\\n        res = 0\\n        for k, lst in comp.items():\\n            ans = -1\\n            for i in lst:\\n                tmp = bfs(i)\\n                ans = max(ans, tmp)\\n            if ans == -1:\\n                return -1\\n            res += ans\\n        return res\\n\\n\\n\\n\\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878076,
                "title": "dfs-bfs-python3",
                "content": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        adj = defaultdict(set)\\n        for u, v in edges:\\n            adj[u].add(v)\\n            adj[v].add(u)\\n            \\n        colors = [-1] * (n+1)\\n        component = [-1] * (n+1) # keep track of which component does each node belong to\\n        \\n\\t\\t# 2-coloring should be possible :- no 2 adjacent nodes of same color (same group)\\n\\t\\t# DFS\\n        def is_bipartite(cur, color, comp_no):\\n            colors[cur] = color\\n            component[cur] = comp_no\\n            \\n            for nbr in adj[cur]:\\n                if colors[nbr] == -1:\\n                    if not is_bipartite(nbr, abs(1-color), comp_no):\\n                        return False\\n                elif colors[nbr] == color:\\n                    return False\\n            return True\\n        \\n\\t\\t# Graph can be disconnected\\n        comp_no = 1\\n        for node in range(1, n+1):\\n            if colors[node] == -1:\\n                if not is_bipartite(node, 1, comp_no):\\n                    return -1\\n                comp_no += 1\\n        \\n\\t\\t# Get height/deepest level from cur as root\\n\\t\\t# BFS\\n        def get_height(cur):\\n            q = deque([cur])\\n            vis = set([cur])\\n            \\n            lvl = 0\\n            while q:\\n                sz = len(q)    \\n                for _ in range(sz):\\n                    cur = q.popleft()\\n                    for nbr in adj[cur]:\\n                        if nbr not in vis:\\n                            vis.add(nbr)\\n                            q.append(nbr)\\n                lvl += 1\\n            return lvl\\n        \\n        ans = [0] * (n+1)\\n        for node in range(1, n+1):\\n            ans[component[node]] = max(ans[component[node]], get_height(node))\\n        \\n        return sum(ans)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        adj = defaultdict(set)\\n        for u, v in edges:\\n            adj[u].add(v)\\n            adj[v].add(u)\\n            \\n        colors = [-1] * (n+1)\\n        component = [-1] * (n+1) # keep track of which component does each node belong to\\n        \\n\\t\\t# 2-coloring should be possible :- no 2 adjacent nodes of same color (same group)\\n\\t\\t# DFS\\n        def is_bipartite(cur, color, comp_no):\\n            colors[cur] = color\\n            component[cur] = comp_no\\n            \\n            for nbr in adj[cur]:\\n                if colors[nbr] == -1:\\n                    if not is_bipartite(nbr, abs(1-color), comp_no):\\n                        return False\\n                elif colors[nbr] == color:\\n                    return False\\n            return True\\n        \\n\\t\\t# Graph can be disconnected\\n        comp_no = 1\\n        for node in range(1, n+1):\\n            if colors[node] == -1:\\n                if not is_bipartite(node, 1, comp_no):\\n                    return -1\\n                comp_no += 1\\n        \\n\\t\\t# Get height/deepest level from cur as root\\n\\t\\t# BFS\\n        def get_height(cur):\\n            q = deque([cur])\\n            vis = set([cur])\\n            \\n            lvl = 0\\n            while q:\\n                sz = len(q)    \\n                for _ in range(sz):\\n                    cur = q.popleft()\\n                    for nbr in adj[cur]:\\n                        if nbr not in vis:\\n                            vis.add(nbr)\\n                            q.append(nbr)\\n                lvl += 1\\n            return lvl\\n        \\n        ans = [0] * (n+1)\\n        for node in range(1, n+1):\\n            ans[component[node]] = max(ans[component[node]], get_height(node))\\n        \\n        return sum(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878020,
                "title": "need-help-understanding-the-question",
                "content": "I am confused about this question. For example I have several pairs: [[1,2], [3,2], [4,2], [5,2], [6,2], [7,2]]\\n\\nFrom the question we shall form the graph like this: (1)- (2) - (3,4,5,6,7), or anything (2) is in the center, which has a left group, and a right group, then the answer should be 3. So I used top sort to get the maximum number of groups by counting the layers.\\n\\nWhy is my understanding wrong?",
                "solutionTags": [],
                "code": "I am confused about this question. For example I have several pairs: [[1,2], [3,2], [4,2], [5,2], [6,2], [7,2]]\\n\\nFrom the question we shall form the graph like this: (1)- (2) - (3,4,5,6,7), or anything (2) is in the center, which has a left group, and a right group, then the answer should be 3. So I used top sort to get the maximum number of groups by counting the layers.\\n\\nWhy is my understanding wrong?",
                "codeTag": "Unknown"
            },
            {
                "id": 2877995,
                "title": "bfs-check-back-edge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nNumber of groups = Number of bfs layers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n(1) While doing bfs, check if the neighbouring node is in the prev or next level.\\n\\n(2) Then for each connected component, we run bfs from different root to determine the maximum number of groups (levels).\\n\\n(3) Finally, we add the results from each connected components together to obtain the desired answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n * m)$$ where n is the number of nodes, m is the number of edges\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n + m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(const vector<unordered_set<int>>& G, int n, int r) {\\n        vector<bool> visit(n, false);\\n        queue<int> q;\\n        q.push(r);\\n        visit[r] = true;\\n        int ret = 0;\\n        while (!q.empty()) {\\n            ret += 1;\\n            int sz = q.size();\\n            while (sz-- > 0) {\\n                auto u = q.front();\\n                q.pop();\\n                for (const auto& v : G[u]) {\\n                    if (!visit[v]) {\\n                        q.push(v);\\n                        visit[v] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    bool check(const vector<unordered_set<int>>& G, vector<bool>& visit, vector<vector<int>>& groups, int r) {\\n        queue<int> q;\\n        q.push(r);\\n        visit[r] = true;\\n        unordered_set<int> prev, cur{r};\\n        vector<int> group{r};\\n        while (!q.empty()) {\\n            int sz = q.size();\\n            unordered_set<int> next;\\n            while (sz-- > 0) {\\n                auto u = q.front();\\n                q.pop();\\n                for (const auto& v : G[u]) {\\n                    if (!visit[v]) {\\n                        next.insert(v);\\n                        q.push(v);\\n                        visit[v] = true;\\n                        group.push_back(v);\\n                    } else {\\n                        // check back edge, the only tricky part of this problem\\n                        if (!prev.count(v) && !next.count(v)) return false;\\n                    }\\n                }\\n            }\\n            swap(cur, next);\\n            swap(prev, next);\\n        }\\n        groups.push_back(group);\\n        return true;\\n    }\\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> G(n);\\n        for (const auto& e : edges) {\\n            G[e[0] - 1].insert(e[1] - 1);\\n            G[e[1] - 1].insert(e[0] - 1);\\n        }\\n        vector<bool> visit(n, false);\\n        vector<vector<int>> groups;\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i] && !check(G, visit, groups, i)) {\\n                return -1;\\n            }\\n        }\\n        int ans = 0;\\n        for (const auto& group : groups) {\\n            int d = 0;\\n            for (const auto& u : group) d = max(d, bfs(G, n, u));\\n            ans += d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(const vector<unordered_set<int>>& G, int n, int r) {\\n        vector<bool> visit(n, false);\\n        queue<int> q;\\n        q.push(r);\\n        visit[r] = true;\\n        int ret = 0;\\n        while (!q.empty()) {\\n            ret += 1;\\n            int sz = q.size();\\n            while (sz-- > 0) {\\n                auto u = q.front();\\n                q.pop();\\n                for (const auto& v : G[u]) {\\n                    if (!visit[v]) {\\n                        q.push(v);\\n                        visit[v] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    bool check(const vector<unordered_set<int>>& G, vector<bool>& visit, vector<vector<int>>& groups, int r) {\\n        queue<int> q;\\n        q.push(r);\\n        visit[r] = true;\\n        unordered_set<int> prev, cur{r};\\n        vector<int> group{r};\\n        while (!q.empty()) {\\n            int sz = q.size();\\n            unordered_set<int> next;\\n            while (sz-- > 0) {\\n                auto u = q.front();\\n                q.pop();\\n                for (const auto& v : G[u]) {\\n                    if (!visit[v]) {\\n                        next.insert(v);\\n                        q.push(v);\\n                        visit[v] = true;\\n                        group.push_back(v);\\n                    } else {\\n                        // check back edge, the only tricky part of this problem\\n                        if (!prev.count(v) && !next.count(v)) return false;\\n                    }\\n                }\\n            }\\n            swap(cur, next);\\n            swap(prev, next);\\n        }\\n        groups.push_back(group);\\n        return true;\\n    }\\n    \\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<unordered_set<int>> G(n);\\n        for (const auto& e : edges) {\\n            G[e[0] - 1].insert(e[1] - 1);\\n            G[e[1] - 1].insert(e[0] - 1);\\n        }\\n        vector<bool> visit(n, false);\\n        vector<vector<int>> groups;\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i] && !check(G, visit, groups, i)) {\\n                return -1;\\n            }\\n        }\\n        int ans = 0;\\n        for (const auto& group : groups) {\\n            int d = 0;\\n            for (const auto& u : group) d = max(d, bfs(G, n, u));\\n            ans += d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877796,
                "title": "very-simple-approach-with-explanation-bipartite-bfs-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n\\t\\t// create graph using edges\\n        vector<vector<int>> g(n+1);\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<vector<int>> parts;   // For all disconnected graph with all nodes that included in particular graph component\\n        vector<bool> seen(n+1, false);\\n        vector<int> colored(n+1, false);\\n        \\n\\t\\t// here find out all disconnected graph with inlcueded nodes and also check graph is bipartite or not\\n\\t\\t// If graph is bipartite in that case we don\\'t make goup because cycle is present\\n\\t\\t\\n        for(int i = 1; i <= n; i++) {\\n            if(!seen[i]) {\\n                queue<int> q;\\n                q.push(i);\\n                seen[i] = true;\\n                colored[i] = 0;\\n                \\n                vector<int> part;\\n                while(!q.empty()) {\\n                    int u = q.front(); q.pop();\\n                    part.push_back(u);\\n                    \\n                    for(int v : g[u]) {\\n                        if(!seen[v]) {\\n                            q.push(v);\\n                            colored[v] = 1 - colored[u];\\n                            seen[v] = true;\\n                        }else if(seen[v] && colored[v] == colored[u] ) return -1;  // bipartite graph then return -1\\n                    } \\n                } \\n                parts.push_back(part);\\n            }\\n        }\\n        \\n\\t\\t// bfs for finding max levels of graph\\n        auto bfs = [&](int x) {\\n            vector<int> q;\\n            q.push_back(x);\\n            vector<bool> seen(n+1, false);\\n            seen[x] = true;\\n            int lvl = 0;\\n            while(!q.empty()) {\\n                int sz = q.size();\\n                vector<int> t;\\n                for(int i = 0; i < sz; i++) {\\n                    int u = q[i];\\n                    for(int v : g[u]) {\\n                        if(!seen[v]) {\\n                            t.push_back(v);\\n                            seen[v] = true;\\n                        }\\n                    } \\n                }\\n                lvl++;\\n                swap(q, t);\\n            }  \\n            return lvl;\\n        };\\n        \\n\\t\\t// apply dfs one by one all nodes and find out max level of  disconnected components and and max level of that disconnected graph add in ans\\n        int ans = 0;\\n        for(auto part : parts) {\\n            int cnt = 0;\\n            for(auto x : part) {\\n                cnt = max(cnt, bfs(x));\\n            }\\n            ans += cnt;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n\\t\\t// create graph using edges\\n        vector<vector<int>> g(n+1);\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<vector<int>> parts;   // For all disconnected graph with all nodes that included in particular graph component\\n        vector<bool> seen(n+1, false);\\n        vector<int> colored(n+1, false);\\n        \\n\\t\\t// here find out all disconnected graph with inlcueded nodes and also check graph is bipartite or not\\n\\t\\t// If graph is bipartite in that case we don\\'t make goup because cycle is present\\n\\t\\t\\n        for(int i = 1; i <= n; i++) {\\n            if(!seen[i]) {\\n                queue<int> q;\\n                q.push(i);\\n                seen[i] = true;\\n                colored[i] = 0;\\n                \\n                vector<int> part;\\n                while(!q.empty()) {\\n                    int u = q.front(); q.pop();\\n                    part.push_back(u);\\n                    \\n                    for(int v : g[u]) {\\n                        if(!seen[v]) {\\n                            q.push(v);\\n                            colored[v] = 1 - colored[u];\\n                            seen[v] = true;\\n                        }else if(seen[v] && colored[v] == colored[u] ) return -1;  // bipartite graph then return -1\\n                    } \\n                } \\n                parts.push_back(part);\\n            }\\n        }\\n        \\n\\t\\t// bfs for finding max levels of graph\\n        auto bfs = [&](int x) {\\n            vector<int> q;\\n            q.push_back(x);\\n            vector<bool> seen(n+1, false);\\n            seen[x] = true;\\n            int lvl = 0;\\n            while(!q.empty()) {\\n                int sz = q.size();\\n                vector<int> t;\\n                for(int i = 0; i < sz; i++) {\\n                    int u = q[i];\\n                    for(int v : g[u]) {\\n                        if(!seen[v]) {\\n                            t.push_back(v);\\n                            seen[v] = true;\\n                        }\\n                    } \\n                }\\n                lvl++;\\n                swap(q, t);\\n            }  \\n            return lvl;\\n        };\\n        \\n\\t\\t// apply dfs one by one all nodes and find out max level of  disconnected components and and max level of that disconnected graph add in ans\\n        int ans = 0;\\n        for(auto part : parts) {\\n            int cnt = 0;\\n            for(auto x : part) {\\n                cnt = max(cnt, bfs(x));\\n            }\\n            ans += cnt;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877774,
                "title": "c-dfs-and-bfs-solution",
                "content": "First find all the connected components using a DFS. We can also label nodes to check if the graph is bipartite. If it isn\\'t return -1 because that means we can\\'t split up the graph according to the constraints.\\n\\nUsing the connected components, we then run a BFS from every node in each connected components and find the maximum minimum distance from a node to another node. Our answer is the sum of all maximum minimum distances in all connected components.\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& adj, vector<int>& visited, vector<int>& comp, int node, int color) {\\n        visited[node] = color;\\n        comp.push_back(node);\\n        color = (color + 1) % 2;\\n        for (int i : adj[node]) {\\n            if (visited[i] != -1) {\\n                if (visited[i] != color) return false;\\n                continue;\\n            }\\n            if (not dfs(adj, visited, comp, i, color)) return false;\\n        }\\n        return true;\\n    }\\n\\n    int bfs(int n, vector<vector<int>>& adj, vector<int>& comp) {\\n        int res = 1;\\n        for (int i : comp) {\\n            vector<bool> visited(n);\\n            queue<pair<int, int>> q;\\n            visited[i] = true;\\n            q.push({i, 1});\\n            while (not q.empty()) {\\n                int node = q.front().first, dist = q.front().second;\\n                q.pop();\\n                res = max(dist, res);\\n                for (int j : adj[node]) {\\n                    if (visited[j]) continue;\\n                    visited[j] = true;\\n                    q.push({j, dist + 1});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> visited(n, -1);\\n        vector<vector<int>> adj(n), concomp;\\n        for (vector<int>& v : edges) {\\n            int a = v[0], b = v[1];\\n            a--;\\n            b--;\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] != -1) continue;\\n            concomp.push_back({});\\n            if (not dfs(adj, visited, concomp.back(), i, 0)) return -1;\\n        }\\n        for (vector<int>& v : concomp) ans += bfs(n, adj, v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& adj, vector<int>& visited, vector<int>& comp, int node, int color) {\\n        visited[node] = color;\\n        comp.push_back(node);\\n        color = (color + 1) % 2;\\n        for (int i : adj[node]) {\\n            if (visited[i] != -1) {\\n                if (visited[i] != color) return false;\\n                continue;\\n            }\\n            if (not dfs(adj, visited, comp, i, color)) return false;\\n        }\\n        return true;\\n    }\\n\\n    int bfs(int n, vector<vector<int>>& adj, vector<int>& comp) {\\n        int res = 1;\\n        for (int i : comp) {\\n            vector<bool> visited(n);\\n            queue<pair<int, int>> q;\\n            visited[i] = true;\\n            q.push({i, 1});\\n            while (not q.empty()) {\\n                int node = q.front().first, dist = q.front().second;\\n                q.pop();\\n                res = max(dist, res);\\n                for (int j : adj[node]) {\\n                    if (visited[j]) continue;\\n                    visited[j] = true;\\n                    q.push({j, dist + 1});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> visited(n, -1);\\n        vector<vector<int>> adj(n), concomp;\\n        for (vector<int>& v : edges) {\\n            int a = v[0], b = v[1];\\n            a--;\\n            b--;\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] != -1) continue;\\n            concomp.push_back({});\\n            if (not dfs(adj, visited, concomp.back(), i, 0)) return -1;\\n        }\\n        for (vector<int>& v : concomp) ans += bfs(n, adj, v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877624,
                "title": "breadth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution consists of three parts: first, we must identify the connected components. Then, for each connected component, we must check that it has no odd length cycles (otherwise the decomposition is impossible). Finally, we need to determine the (sum of the) diameter of each connected component: this gives the maximum number of levels in the decomposition.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each component, determining whether it has odd length cycles takes $O(n)$ time, but finding the diameter can take up to $O(n^2)$ time. Fortunately, with up to 500 vertices, this is manageable.\\n\\n# Complexity\\n- Time complexity: $O(n^2)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        g=[[] for i in range(n+1)]\\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n        total=[True]*(n+1)\\n        ans=0\\n        for i in range(1, n+1):\\n            if total[i]:\\n                dct={i:1}\\n                terminal=set()\\n                q=[(i, 1)]\\n                curs=0\\n                while curs<len(q):\\n                    v, ct=q[curs]\\n                    flg=True\\n                    for v2 in g[v]:\\n                        if v2 in dct:\\n                            if dct[v2]==ct:\\n                                return -1\\n                        else:\\n                            flg=False\\n                            dct[v2]=ct+1\\n                            q.append((v2, ct+1))\\n                    if flg:\\n                        terminal.add(v)\\n                    curs+=1\\n                dst=max(dct.values())\\n                for j in terminal:\\n                    dct2={j:1}\\n                    q2=[(j, 1)]\\n                    curs=0\\n                    while curs<len(q2):\\n                        v, ct=q2[curs]\\n                        for v2 in g[v]:\\n                            if v2 not in dct2:\\n                                dct2[v2]=ct+1\\n                                q2.append((v2, ct+1))\\n                        curs+=1\\n                    dst=max(dst, max(dct2.values()))\\n                for j in dct.keys():\\n                    total[j]=False\\n                ans+=dst\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        g=[[] for i in range(n+1)]\\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n        total=[True]*(n+1)\\n        ans=0\\n        for i in range(1, n+1):\\n            if total[i]:\\n                dct={i:1}\\n                terminal=set()\\n                q=[(i, 1)]\\n                curs=0\\n                while curs<len(q):\\n                    v, ct=q[curs]\\n                    flg=True\\n                    for v2 in g[v]:\\n                        if v2 in dct:\\n                            if dct[v2]==ct:\\n                                return -1\\n                        else:\\n                            flg=False\\n                            dct[v2]=ct+1\\n                            q.append((v2, ct+1))\\n                    if flg:\\n                        terminal.add(v)\\n                    curs+=1\\n                dst=max(dct.values())\\n                for j in terminal:\\n                    dct2={j:1}\\n                    q2=[(j, 1)]\\n                    curs=0\\n                    while curs<len(q2):\\n                        v, ct=q2[curs]\\n                        for v2 in g[v]:\\n                            if v2 not in dct2:\\n                                dct2[v2]=ct+1\\n                                q2.append((v2, ct+1))\\n                        curs+=1\\n                    dst=max(dst, max(dct2.values()))\\n                for j in dct.keys():\\n                    total[j]=False\\n                ans+=dst\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877603,
                "title": "python3-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the components starting from each node  and make sure there is no violation of the rule via back cycles from previous layers. I thought about the odd cycles intuition as mentioned in the posted solutions but couldn\\'t be sure it is true. And I did think about bipartite logic as well.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse bfs to find the maximum number of group of their respective components by starting at each node. Return `-1` during a rule violation.  I used minimum value of the component as a hash. Then sum up the answer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * (n + v))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+v)\\n# Code\\n```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n\\n        res = defaultdict(int)\\n\\n        graph = defaultdict(list)\\n\\n        for k,v in edges:\\n            graph[k].append(v)\\n            graph[v].append(k)\\n\\n        def bfs(start):\\n            q = deque([start])\\n            qs = set() # prevoius layer\\n            visited = set([start])\\n            layer = 0\\n            while q:\\n                nxt = set()\\n                nxts = set()\\n                #print(q)\\n                for n in q:\\n                    for nei in graph[n]:\\n                        if nei in visited and nei in qs:\\n                            continue\\n                        if nei not in visited: # prev layer, ok\\n                            nxt.add(nei)\\n                            nxts.add(nei)\\n                        else: # last layers\\n                            return -1, set()\\n                for n in nxt:\\n                    visited.add(n)\\n                qs = set(q)\\n                q = deque(nxt)\\n                layer+=1\\n            return layer, visited\\n        for i in range(1 , n+1):\\n            r, vis = bfs(i)\\n            if not vis:\\n                return -1\\n            k = min(vis)\\n            res[k] = max(res[k], r)\\n        return sum(res.values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n\\n        res = defaultdict(int)\\n\\n        graph = defaultdict(list)\\n\\n        for k,v in edges:\\n            graph[k].append(v)\\n            graph[v].append(k)\\n\\n        def bfs(start):\\n            q = deque([start])\\n            qs = set() # prevoius layer\\n            visited = set([start])\\n            layer = 0\\n            while q:\\n                nxt = set()\\n                nxts = set()\\n                #print(q)\\n                for n in q:\\n                    for nei in graph[n]:\\n                        if nei in visited and nei in qs:\\n                            continue\\n                        if nei not in visited: # prev layer, ok\\n                            nxt.add(nei)\\n                            nxts.add(nei)\\n                        else: # last layers\\n                            return -1, set()\\n                for n in nxt:\\n                    visited.add(n)\\n                qs = set(q)\\n                q = deque(nxt)\\n                layer+=1\\n            return layer, visited\\n        for i in range(1 , n+1):\\n            r, vis = bfs(i)\\n            if not vis:\\n                return -1\\n            k = min(vis)\\n            res[k] = max(res[k], r)\\n        return sum(res.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877288,
                "title": "java-component-wise-bipartite-check-and-bfs-for-max-distance",
                "content": "```\\nclass Solution {\\n    \\n    List<List<Integer>> graph;\\n    int n; \\n    Map<Integer, List<Integer>> components;\\n    int component;\\n    \\n    public int magnificentSets(int n, int[][] edges) {\\n        this.n = n;\\n        this.graph = new ArrayList();\\n        for(int i = 0; i <= n; i++)\\n            graph.add(new ArrayList());\\n        for(int[] edge : edges)\\n        {\\n            int a = edge[0];\\n            int b = edge[1];\\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        this.component = 0;\\n        this.components = new HashMap();\\n        boolean[] visited = new boolean[n+1]; \\n        for(int i = 1; i <= n; i++)\\n        {\\n            components.put(component, new ArrayList());\\n            constructComponents(i, visited);\\n            component++;\\n        }\\n        for(int key : components.keySet())\\n        {\\n            for(int node : components.get(key))\\n            {\\n                boolean bipartite = isBipartite(node);\\n                if(!bipartite)\\n                    return -1;\\n            }\\n        }\\n        int[] componentsMaxPathPossible = new int[n+1];\\n        for(int key : components.keySet())\\n        {\\n            for(int node : components.get(key))\\n            {\\n                int dist = bfs(node);\\n                componentsMaxPathPossible[key] = Math.max(componentsMaxPathPossible[key], dist);\\n            }\\n        }\\n        \\n        int totalGroups = 0;\\n        for(int i = 0; i <= n; i++)\\n        {\\n            totalGroups += componentsMaxPathPossible[i];\\n        }\\n        return totalGroups;\\n    }\\n    \\n    public boolean isBipartite(int node)\\n    {\\n        int[] color = new int[n+1];\\n        boolean[] visited = new boolean[n+1];\\n        Queue<Integer> queue = new LinkedList();\\n        queue.add(node);\\n        visited[node] = true;\\n        color[node] = 1;\\n        while(!queue.isEmpty())\\n        {\\n            int currNode = queue.poll();\\n            for(int neigh : graph.get(currNode))\\n            {\\n                if(!visited[neigh] && color[neigh] != color[currNode])\\n                {\\n                    visited[neigh] = true;\\n                    color[neigh] = 3 - color[currNode];\\n                    queue.add(neigh);\\n                }\\n                if(color[neigh] == color[currNode])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int bfs(int node)\\n    {\\n        boolean[] visited = new boolean[n+1];\\n        Queue<Integer> queue = new LinkedList();\\n        queue.add(node);\\n        visited[node] = true;\\n        int level = 0;\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int currNode = queue.poll();\\n                for(int neigh : graph.get(currNode))\\n                {\\n                    if(!visited[neigh])\\n                    {\\n                        visited[neigh] = true;;\\n                        queue.add(neigh);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    \\n    public void constructComponents(int node, boolean[] visited)\\n    {\\n        if(visited[node])\\n            return;\\n        components.get(component).add(node);\\n        visited[node] = true;\\n        for(int neigh : graph.get(node))\\n        {\\n            if(!visited[neigh])\\n            {\\n                constructComponents(neigh, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<List<Integer>> graph;\\n    int n; \\n    Map<Integer, List<Integer>> components;\\n    int component;\\n    \\n    public int magnificentSets(int n, int[][] edges) {\\n        this.n = n;\\n        this.graph = new ArrayList();\\n        for(int i = 0; i <= n; i++)\\n            graph.add(new ArrayList());\\n        for(int[] edge : edges)\\n        {\\n            int a = edge[0];\\n            int b = edge[1];\\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        this.component = 0;\\n        this.components = new HashMap();\\n        boolean[] visited = new boolean[n+1]; \\n        for(int i = 1; i <= n; i++)\\n        {\\n            components.put(component, new ArrayList());\\n            constructComponents(i, visited);\\n            component++;\\n        }\\n        for(int key : components.keySet())\\n        {\\n            for(int node : components.get(key))\\n            {\\n                boolean bipartite = isBipartite(node);\\n                if(!bipartite)\\n                    return -1;\\n            }\\n        }\\n        int[] componentsMaxPathPossible = new int[n+1];\\n        for(int key : components.keySet())\\n        {\\n            for(int node : components.get(key))\\n            {\\n                int dist = bfs(node);\\n                componentsMaxPathPossible[key] = Math.max(componentsMaxPathPossible[key], dist);\\n            }\\n        }\\n        \\n        int totalGroups = 0;\\n        for(int i = 0; i <= n; i++)\\n        {\\n            totalGroups += componentsMaxPathPossible[i];\\n        }\\n        return totalGroups;\\n    }\\n    \\n    public boolean isBipartite(int node)\\n    {\\n        int[] color = new int[n+1];\\n        boolean[] visited = new boolean[n+1];\\n        Queue<Integer> queue = new LinkedList();\\n        queue.add(node);\\n        visited[node] = true;\\n        color[node] = 1;\\n        while(!queue.isEmpty())\\n        {\\n            int currNode = queue.poll();\\n            for(int neigh : graph.get(currNode))\\n            {\\n                if(!visited[neigh] && color[neigh] != color[currNode])\\n                {\\n                    visited[neigh] = true;\\n                    color[neigh] = 3 - color[currNode];\\n                    queue.add(neigh);\\n                }\\n                if(color[neigh] == color[currNode])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int bfs(int node)\\n    {\\n        boolean[] visited = new boolean[n+1];\\n        Queue<Integer> queue = new LinkedList();\\n        queue.add(node);\\n        visited[node] = true;\\n        int level = 0;\\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int currNode = queue.poll();\\n                for(int neigh : graph.get(currNode))\\n                {\\n                    if(!visited[neigh])\\n                    {\\n                        visited[neigh] = true;;\\n                        queue.add(neigh);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    \\n    public void constructComponents(int node, boolean[] visited)\\n    {\\n        if(visited[node])\\n            return;\\n        components.get(component).add(node);\\n        visited[node] = true;\\n        for(int neigh : graph.get(node))\\n        {\\n            if(!visited[neigh])\\n            {\\n                constructComponents(neigh, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876982,
                "title": "bfs-from-each-node-short-c",
                "content": "# Intuition\\nFrom the example, it follows that we need to iterate level-wise on every connected component. For each component, we should assign every node on the same level a group number. The choice of root would influence the max number of groups that we arrive at but given the low constraints it\\'s easy to see that trying all possible roots would pass.\\n\\nYou can additionally observe that if there is an odd-length cycle (i.e. graph is non-bipartite) we would not be able to do the grouping. This doesn\\'t need to be handled explicitly though.\\n\\n# Approach\\nUse BFS on each connected component and just apply the rule for connected nodes to occur on group numbers within diff of 1. It is important to note that nodes in different connected components do not have any restrictions on where we place them. Thus, to get the highest number of groups, we should put the nodes from different connected components into different non-overlapping groups. Hence, the following is obvious:\\n\\n$$Answer = Sum(MaxGroupsPerConnectedComponent)$$\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing Graph = vector<vector<int>>;\\nclass Solution {\\npublic:\\n    int findMaxLevel(int root, const Graph& graph, vector<int>& vis) {\\n        vector<int> level(graph.size(), -1);\\n        level[root] = 1;\\n        queue<int> q;\\n        q.push(root);\\n        int mx = 1;\\n        while (!q.empty()) {\\n            int cur = q.front();\\n            vis[cur] = vis[root];  // mark as part of same component.\\n            q.pop();\\n\\n            for (int next : graph[cur]) {\\n                if (level[next] == -1) {\\n                    level[next] = level[cur] + 1;\\n                    mx = max(mx, level[next]);\\n                    q.push(next);\\n                } else {\\n                    // apply the check stated in problem\\n                    if (abs(level[next] - level[cur]) != 1) return -1;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        Graph g(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0] - 1;\\n            int v = edge[1] - 1;\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        vector<int> components, vis(n, -1);\\n        for (int st = 0; st < n; ++st) {\\n            if (vis[st] == -1) {\\n                // found a new component\\n                vis[st] = components.size();\\n                components.push_back(1);\\n            }\\n            int res = findMaxLevel(st, g, vis);\\n            if (res == -1) return -1;\\n            components[vis[st]] = max(components[vis[st]], res);\\n        }\\n        return accumulate(components.begin(), components.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing Graph = vector<vector<int>>;\\nclass Solution {\\npublic:\\n    int findMaxLevel(int root, const Graph& graph, vector<int>& vis) {\\n        vector<int> level(graph.size(), -1);\\n        level[root] = 1;\\n        queue<int> q;\\n        q.push(root);\\n        int mx = 1;\\n        while (!q.empty()) {\\n            int cur = q.front();\\n            vis[cur] = vis[root];  // mark as part of same component.\\n            q.pop();\\n\\n            for (int next : graph[cur]) {\\n                if (level[next] == -1) {\\n                    level[next] = level[cur] + 1;\\n                    mx = max(mx, level[next]);\\n                    q.push(next);\\n                } else {\\n                    // apply the check stated in problem\\n                    if (abs(level[next] - level[cur]) != 1) return -1;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        Graph g(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0] - 1;\\n            int v = edge[1] - 1;\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        vector<int> components, vis(n, -1);\\n        for (int st = 0; st < n; ++st) {\\n            if (vis[st] == -1) {\\n                // found a new component\\n                vis[st] = components.size();\\n                components.push_back(1);\\n            }\\n            int res = findMaxLevel(st, g, vis);\\n            if (res == -1) return -1;\\n            components[vis[st]] = max(components[vis[st]], res);\\n        }\\n        return accumulate(components.begin(), components.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876598,
                "title": "python3-bfs-union-find",
                "content": "### Intuition\\n\\n1. since graph can be disconnected, we need to find every connected component\\n\\t- use Union-Find \\n2. max groups of connected component is max layers of BFS\\n>start BFS from outer-most node to get max layers -> wrong \\n    - thanks for reply from @jossheim, it seems answer can exist in any node as first layer, we need to check all of them\\n3. start BFS from each node to get max layers\\n\\nwe use BFS to get max groups of each connected component\\n\\n`answer = sum(every max groups of each connected component)`\\n\\n```python                \\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        parent = [i for i in range(n+1)]\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            if px <= py:\\n                parent[py] = px\\n            else:\\n                parent[px] = py\\n\\n        indegree = [0] * (n+1)\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            union(u, v)\\n            indegree[u] += 1\\n            indegree[v] += 1\\n            \\n        # calculate max groups\\n        # also check if there exists odd length cycle\\n        def BFS(start):\\n            queue = deque([[start, 1]]) # node, layer\\n            groups = 0\\n            visited = {start: 1}\\n            while queue:\\n                sz = len(queue)\\n                for _ in range(sz):\\n                    node, layer = queue.popleft()\\n\\n                    for nxt in graph[node]:\\n                        if nxt not in visited:\\n                            nextLayer = layer+1\\n                            visited[nxt] = nextLayer\\n                            queue.append([nxt, nextLayer])\\n                        else:\\n                            if visited[nxt] == layer: return -1\\n                groups += 1\\n            return groups\\n        \\n        # find connected components\\n        groups = defaultdict(list)\\n        for i in range(1, n+1):\\n            groups[find(parent[i])].append(i)\\n\\n        maxGroups = 0\\n        for nodes in groups.values():\\n            count = 0\\n            for node in nodes:\\n                cnt = BFS(node)\\n                if cnt == -1: return -1\\n                count = max(count, cnt)\\n\\n            maxGroups += count\\n        return maxGroups\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```python                \\nclass Solution:\\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        parent = [i for i in range(n+1)]\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            if px <= py:\\n                parent[py] = px\\n            else:\\n                parent[px] = py\\n\\n        indegree = [0] * (n+1)\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            union(u, v)\\n            indegree[u] += 1\\n            indegree[v] += 1\\n            \\n        # calculate max groups\\n        # also check if there exists odd length cycle\\n        def BFS(start):\\n            queue = deque([[start, 1]]) # node, layer\\n            groups = 0\\n            visited = {start: 1}\\n            while queue:\\n                sz = len(queue)\\n                for _ in range(sz):\\n                    node, layer = queue.popleft()\\n\\n                    for nxt in graph[node]:\\n                        if nxt not in visited:\\n                            nextLayer = layer+1\\n                            visited[nxt] = nextLayer\\n                            queue.append([nxt, nextLayer])\\n                        else:\\n                            if visited[nxt] == layer: return -1\\n                groups += 1\\n            return groups\\n        \\n        # find connected components\\n        groups = defaultdict(list)\\n        for i in range(1, n+1):\\n            groups[find(parent[i])].append(i)\\n\\n        maxGroups = 0\\n        for nodes in groups.values():\\n            count = 0\\n            for node in nodes:\\n                cnt = BFS(node)\\n                if cnt == -1: return -1\\n                count = max(count, cnt)\\n\\n            maxGroups += count\\n        return maxGroups\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876444,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n private:\\n  static constexpr int unknown_color = -1;\\n  \\n public:\\n  int magnificentSets(const int n, const vector<vector<int>> &edges) {\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[0] - 1;\\n      const int node2 = edge[1] - 1;\\n      graph[node1].emplace_back(node2);\\n      graph[node2].emplace_back(node1);\\n    }\\n    \\n    int visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    int visiting = 0;\\n    int colors[n];\\n    memset(colors, unknown_color, sizeof(colors));\\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      if (visited[i] != 0) {\\n        continue;\\n      }\\n      \\n      vector<int> nodes;\\n      if (!is_bipartite(graph, i, 0, colors, nodes)) {\\n        ret = -1;\\n        break;\\n      }\\n      \\n      int max_partitions = 0;\\n      for (const int node : nodes) {\\n        max_partitions = max(max_partitions, get_partitions(graph, node, visited, ++visiting));\\n      }\\n      ret += max_partitions;\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool is_bipartite(const vector<int> *graph,\\n                    const int current_node,\\n                    const int current_color,\\n                    int *colors,\\n                    vector<int> &nodes) {\\n    colors[current_node] = current_color;\\n    nodes.emplace_back(current_node);\\n    const int next_color = current_color ^ 1;\\n    for (const int next_node : graph[current_node]) {\\n      if (colors[next_node] == current_color ||\\n          (colors[next_node] == unknown_color &&\\n           !is_bipartite(graph, next_node, next_color, colors, nodes))) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n  \\n  int get_partitions(const vector<int> *graph, const int start, int *visited, const int visiting) {\\n    int ret = 0;\\n    queue<int> q({start});\\n    visited[start] = visiting;\\n    while (!q.empty()) {\\n      ++ret;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const int node = q.front();\\n        q.pop();\\n        for (const int next : graph[node]) {\\n          if (visited[next] != visiting) {\\n            visited[next] = visiting;\\n            q.emplace(next);\\n          }\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  static constexpr int unknown_color = -1;\\n  \\n public:\\n  int magnificentSets(const int n, const vector<vector<int>> &edges) {\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[0] - 1;\\n      const int node2 = edge[1] - 1;\\n      graph[node1].emplace_back(node2);\\n      graph[node2].emplace_back(node1);\\n    }\\n    \\n    int visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    int visiting = 0;\\n    int colors[n];\\n    memset(colors, unknown_color, sizeof(colors));\\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      if (visited[i] != 0) {\\n        continue;\\n      }\\n      \\n      vector<int> nodes;\\n      if (!is_bipartite(graph, i, 0, colors, nodes)) {\\n        ret = -1;\\n        break;\\n      }\\n      \\n      int max_partitions = 0;\\n      for (const int node : nodes) {\\n        max_partitions = max(max_partitions, get_partitions(graph, node, visited, ++visiting));\\n      }\\n      ret += max_partitions;\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool is_bipartite(const vector<int> *graph,\\n                    const int current_node,\\n                    const int current_color,\\n                    int *colors,\\n                    vector<int> &nodes) {\\n    colors[current_node] = current_color;\\n    nodes.emplace_back(current_node);\\n    const int next_color = current_color ^ 1;\\n    for (const int next_node : graph[current_node]) {\\n      if (colors[next_node] == current_color ||\\n          (colors[next_node] == unknown_color &&\\n           !is_bipartite(graph, next_node, next_color, colors, nodes))) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n  \\n  int get_partitions(const vector<int> *graph, const int start, int *visited, const int visiting) {\\n    int ret = 0;\\n    queue<int> q({start});\\n    visited[start] = visiting;\\n    while (!q.empty()) {\\n      ++ret;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const int node = q.front();\\n        q.pop();\\n        for (const int next : graph[node]) {\\n          if (visited[next] != visiting) {\\n            visited[next] = visiting;\\n            q.emplace(next);\\n          }\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876440,
                "title": "monotonic-clock-and-union-find",
                "content": "# Intuition\\n\\nThe first thing to notice is that this is a bipartite graph problem. As can be seen in the second example, a Bipartite matching requires that you can assign all nodes to two disjoint groups. An intuitive approach to validating the graph is to use bi-coloring, e.g. assigning \"red\" or \"blue\" to each node and checking for inconsistencies.\\n\\nOnce we know that the graph is valid, then we must find the longest path between any two nodes in the graph. This got me thinking at first of the Hungarian method (a.k.a. Kuhn-Munkres), but that algorithm concerns itself rather with weighted edges. Our edges are not weighted, so there should be an easier approach.\\n\\nThat\\'s when I realised that we can calculate the total distance (in terms of groups) at the same time that we do coloring. We just can\\'t use \"red\" and \"blue\", but rather a monotonic clock.\\n\\n# Approach\\n\\nPerform graph coloring from every node. Use a monotonic clock (t=0,1,2,...) when \"coloring\" and require that each node is either odd or even depending on the current time.\\n\\nThe final monotonic time after coloring the graph is the maximum distance to any other group in the graph from the starting mode.\\n\\nAt least two nodes must be part of the most distant group(s). For these nodes, the total time spent coloring the graph is equal to the number of groups.\\n\\nWe also need to keep track of which nodes belong to which graph. For that we can use a Disjoint Set Union (DSU) data structure.\\n\\nThe wost-case complexity of this approach is $$\\\\mathcal{O}(V\\\\cdot (V + E))$$ where $$V$$ is the number of vertices (nodes), and $$E$$ the number of edges. This is because graph bi-coloring is $$\\\\mathcal{O}(V+E)$$ and we need to do coloring once per vertex (node).\\n\\n# Complexity\\n\\n- Time complexity: $$\\\\mathcal{O}(V\\\\cdot (V+E))$$\\n- Space complexity: $$\\\\mathcal{O}(V+E)$$\\n\\n# Code\\n\\n```go\\nfunc magnificentSets(n int, edges [][]int) int {\\n\\t// The goal is to perform a Bipartite matching of the nodes in the graph(s).\\n\\t//\\n\\t// One way of doing this is to do coloring: for each node in the graph,\\n\\t// ensure that all its neighbours are either uncolored, or has a different\\n\\t// color than the node itself. For example, if a node has been assigned the\\n\\t// color \"blue\", then every neighbour must either be uncolored, or have the\\n\\t// color \"red\".\\n\\t//\\n\\t// We can make an adjustment to this algorithm and use a monotonic clock\\n\\t// instead. It the current time is, say, 4, then any valid neighbour must\\'ve\\n\\t// been seen at an odd time or not seen yet.\\n\\t//\\n\\t// The highest time assigned to a node during this traversal is the most\\n\\t// distant node group according to that node. For any graph with a valid\\n\\t// matching, these must exist at least two nodes for which the distance to\\n\\t// the most distant node group is the number of node groups in total.\\n\\t//\\n\\t// To keep track of which nodes belong to which graph, we can use a DSU.\\n\\t//\\n\\n\\t// DSU\\n\\tparent := make([]int, n+1)\\n\\tfor i := range parent {\\n\\t\\tparent[i] = i\\n\\t}\\n\\tvar find func(a int) int\\n\\tfind = func(a int) int {\\n\\t\\tif parent[a] == a {\\n\\t\\t\\treturn a\\n\\t\\t}\\n\\t\\tra := find(parent[a])\\n\\t\\tparent[a] = ra\\n\\t\\treturn ra\\n\\t}\\n\\tunion := func(a, b int) {\\n\\t\\tra := find(a)\\n\\t\\trb := find(b)\\n\\t\\tif ra != rb {\\n\\t\\t\\tparent[rb] = ra\\n\\t\\t}\\n\\t}\\n\\n\\t// Form adjacency list, group nodes in DSU\\n\\tadj := make([][]int, n+1)\\n\\tfor _, e := range edges {\\n\\t\\tadj[e[0]] = append(adj[e[0]], e[1])\\n\\t\\tadj[e[1]] = append(adj[e[1]], e[0])\\n\\t\\tunion(e[0], e[1])\\n\\t}\\n\\n\\tcurr := []int{}\\n\\tnext := []int{}\\n\\ttimes := make([]uint16, n+1)\\n\\tlongestDistanceFromNode := func(i int) int {\\n\\t\\t// \"Color\" the graph using a monotic clock\\n\\t\\tfor i := range times {\\n\\t\\t\\ttimes[i] = math.MaxUint16\\n\\t\\t}\\n\\t\\tcurr := curr[:0]\\n\\t\\tcurr = append(curr, i)\\n\\t\\tvar t uint16\\n\\t\\ttimes[i] = 0\\n\\t\\tfor len(curr) > 0 {\\n\\t\\t\\tt++\\n\\t\\t\\tnext = next[:0]\\n\\t\\t\\tfor _, x := range curr {\\n\\t\\t\\t\\tfor _, y := range adj[x] {\\n\\t\\t\\t\\t\\tif times[y] == math.MaxUint16 {\\n\\t\\t\\t\\t\\t\\ttimes[y] = t\\n\\t\\t\\t\\t\\t\\tnext = append(next, y)\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Any previously visited node must have the expected\\n\\t\\t\\t\\t\\t// \"color\", i.e. odd or even timestamp\\n\\t\\t\\t\\t\\tif times[y]&1 != t&1 {\\n\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcurr, next = next, curr\\n\\t\\t}\\n\\t\\treturn int(t)\\n\\t}\\n\\n\\tngroups := make([]int, n+1)\\n\\tvar res int\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tdist := longestDistanceFromNode(i)\\n\\t\\tif dist == -1 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\t// Recall: for at least two nodes, the number of groups is the same\\n\\t\\t// thing as the distance\\n\\t\\troot := find(i) // Use DSU to bundle graph nodes together\\n\\t\\tngroups[root] = max(ngroups[root], dist)\\n\\t}\\n\\tfor _, c := range ngroups {\\n\\t\\tres += c\\n\\t}\\n\\treturn res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc magnificentSets(n int, edges [][]int) int {\\n\\t// The goal is to perform a Bipartite matching of the nodes in the graph(s).\\n\\t//\\n\\t// One way of doing this is to do coloring: for each node in the graph,\\n\\t// ensure that all its neighbours are either uncolored, or has a different\\n\\t// color than the node itself. For example, if a node has been assigned the\\n\\t// color \"blue\", then every neighbour must either be uncolored, or have the\\n\\t// color \"red\".\\n\\t//\\n\\t// We can make an adjustment to this algorithm and use a monotonic clock\\n\\t// instead. It the current time is, say, 4, then any valid neighbour must\\'ve\\n\\t// been seen at an odd time or not seen yet.\\n\\t//\\n\\t// The highest time assigned to a node during this traversal is the most\\n\\t// distant node group according to that node. For any graph with a valid\\n\\t// matching, these must exist at least two nodes for which the distance to\\n\\t// the most distant node group is the number of node groups in total.\\n\\t//\\n\\t// To keep track of which nodes belong to which graph, we can use a DSU.\\n\\t//\\n\\n\\t// DSU\\n\\tparent := make([]int, n+1)\\n\\tfor i := range parent {\\n\\t\\tparent[i] = i\\n\\t}\\n\\tvar find func(a int) int\\n\\tfind = func(a int) int {\\n\\t\\tif parent[a] == a {\\n\\t\\t\\treturn a\\n\\t\\t}\\n\\t\\tra := find(parent[a])\\n\\t\\tparent[a] = ra\\n\\t\\treturn ra\\n\\t}\\n\\tunion := func(a, b int) {\\n\\t\\tra := find(a)\\n\\t\\trb := find(b)\\n\\t\\tif ra != rb {\\n\\t\\t\\tparent[rb] = ra\\n\\t\\t}\\n\\t}\\n\\n\\t// Form adjacency list, group nodes in DSU\\n\\tadj := make([][]int, n+1)\\n\\tfor _, e := range edges {\\n\\t\\tadj[e[0]] = append(adj[e[0]], e[1])\\n\\t\\tadj[e[1]] = append(adj[e[1]], e[0])\\n\\t\\tunion(e[0], e[1])\\n\\t}\\n\\n\\tcurr := []int{}\\n\\tnext := []int{}\\n\\ttimes := make([]uint16, n+1)\\n\\tlongestDistanceFromNode := func(i int) int {\\n\\t\\t// \"Color\" the graph using a monotic clock\\n\\t\\tfor i := range times {\\n\\t\\t\\ttimes[i] = math.MaxUint16\\n\\t\\t}\\n\\t\\tcurr := curr[:0]\\n\\t\\tcurr = append(curr, i)\\n\\t\\tvar t uint16\\n\\t\\ttimes[i] = 0\\n\\t\\tfor len(curr) > 0 {\\n\\t\\t\\tt++\\n\\t\\t\\tnext = next[:0]\\n\\t\\t\\tfor _, x := range curr {\\n\\t\\t\\t\\tfor _, y := range adj[x] {\\n\\t\\t\\t\\t\\tif times[y] == math.MaxUint16 {\\n\\t\\t\\t\\t\\t\\ttimes[y] = t\\n\\t\\t\\t\\t\\t\\tnext = append(next, y)\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Any previously visited node must have the expected\\n\\t\\t\\t\\t\\t// \"color\", i.e. odd or even timestamp\\n\\t\\t\\t\\t\\tif times[y]&1 != t&1 {\\n\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcurr, next = next, curr\\n\\t\\t}\\n\\t\\treturn int(t)\\n\\t}\\n\\n\\tngroups := make([]int, n+1)\\n\\tvar res int\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tdist := longestDistanceFromNode(i)\\n\\t\\tif dist == -1 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\t// Recall: for at least two nodes, the number of groups is the same\\n\\t\\t// thing as the distance\\n\\t\\troot := find(i) // Use DSU to bundle graph nodes together\\n\\t\\tngroups[root] = max(ngroups[root], dist)\\n\\t}\\n\\tfor _, c := range ngroups {\\n\\t\\tres += c\\n\\t}\\n\\treturn res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2876431,
                "title": "intuitive-disjoint-sets-java-100-time-space-explained",
                "content": "**Steps:**\\n1. Find all connected components using Disjoint Sets\\n2. Find max number of groups in each component by running bfs on each node of that component and return -1     if there\\'s edge in the same level of graph \\n\\n**Explanation on 2nd step**\\nFor each connected component\\nFinding max number of groups is similar to finding the max depth of that particular sub graph which will be different for each starting node.\\n**Example**\\n![image](https://assets.leetcode.com/users/images/15f48909-6652-4c9a-aad3-005f623c0042_1670144973.0348995.png)\\nSince there\\'s only one component, we can skip the first step.\\nIn second step, \\nRunning BFS on each node will result\\nNode Level/Depth\\n1,2,4 -> 3\\n5,3,6 -> 4\\n\\nWe will take maximum of each component thus answer is 4.\\nCode\\n```\\nimport java.util.ArrayList;\\nclass Solution {\\n    int bfs(int u,List<Integer>[] adj){\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(u);\\n        int l=0;\\n        boolean[] vis = new boolean[adj.length];\\n        vis[u] = true;\\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            boolean[] temp = new boolean[adj.length];\\n            while(sz-->0){\\n                int v = q.poll();\\n                temp[v] = true;\\n                for(int x:adj[v]){\\n                    if(temp[x]) return -1;\\n                    if(!vis[x]){\\n                        vis[x] = true;\\n                        q.add(x);\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        return l;\\n    }\\n    public int magnificentSets(int n, int[][] edges) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        QuickUnionWt q = new QuickUnionWt(n);\\n        for (int[] e : edges) {\\n\\n            adj[e[0]-1].add(e[1]-1);\\n            adj[e[1]-1].add(e[0]-1);\\n            q.union(e[0]-1, e[1]-1);\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int p = q.find(i);\\n            int k = bfs(i,adj);\\n            if(k<0) return -1;\\n            map.put(p, Math.max(map.getOrDefault(p, 0),k));\\n        }\\n        return map.values().stream().mapToInt(x->x).sum();\\n        \\n\\n    }\\n}\\n\\nclass QuickUnionWt {\\n    private int[] parent;   // parent[i] = parent of i\\n    private int[] size;     // size[i] = number of elements in subtree rooted at i\\n    private int count;      // number of components\\n\\n    public QuickUnionWt(int n) {\\n        count = n;\\n        parent = new int[n];\\n        size = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    public int count() {\\n        return count;\\n    }\\n\\n    public int find(int p) {\\n        validate(p);\\n        while (p != parent[p])\\n            p = parent[p];\\n        return p;\\n    }\\n    public boolean connected(int p, int q) {\\n        return find(p) == find(q);\\n    }\\n\\n    // validate that p is a valid index\\n    private void validate(int p) {\\n        int n = parent.length;\\n        if (p < 0 || p >= n) {\\n            throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1));  \\n        }\\n    }\\n\\n    public void union(int p, int q) {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if (rootP == rootQ) return;\\n\\n        // make smaller root point to larger one\\n        if (size[rootP] < size[rootQ]) {\\n            parent[rootP] = rootQ;\\n            size[rootQ] += size[rootP];\\n        }\\n        else {\\n            parent[rootQ] = rootP;\\n            size[rootP] += size[rootQ];\\n        }\\n        count--;\\n    }\\n\\n}\\n```\\n\\nHope it helps, let me know if you any doubts!",
                "solutionTags": [
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nclass Solution {\\n    int bfs(int u,List<Integer>[] adj){\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(u);\\n        int l=0;\\n        boolean[] vis = new boolean[adj.length];\\n        vis[u] = true;\\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            boolean[] temp = new boolean[adj.length];\\n            while(sz-->0){\\n                int v = q.poll();\\n                temp[v] = true;\\n                for(int x:adj[v]){\\n                    if(temp[x]) return -1;\\n                    if(!vis[x]){\\n                        vis[x] = true;\\n                        q.add(x);\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        return l;\\n    }\\n    public int magnificentSets(int n, int[][] edges) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        QuickUnionWt q = new QuickUnionWt(n);\\n        for (int[] e : edges) {\\n\\n            adj[e[0]-1].add(e[1]-1);\\n            adj[e[1]-1].add(e[0]-1);\\n            q.union(e[0]-1, e[1]-1);\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int p = q.find(i);\\n            int k = bfs(i,adj);\\n            if(k<0) return -1;\\n            map.put(p, Math.max(map.getOrDefault(p, 0),k));\\n        }\\n        return map.values().stream().mapToInt(x->x).sum();\\n        \\n\\n    }\\n}\\n\\nclass QuickUnionWt {\\n    private int[] parent;   // parent[i] = parent of i\\n    private int[] size;     // size[i] = number of elements in subtree rooted at i\\n    private int count;      // number of components\\n\\n    public QuickUnionWt(int n) {\\n        count = n;\\n        parent = new int[n];\\n        size = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    public int count() {\\n        return count;\\n    }\\n\\n    public int find(int p) {\\n        validate(p);\\n        while (p != parent[p])\\n            p = parent[p];\\n        return p;\\n    }\\n    public boolean connected(int p, int q) {\\n        return find(p) == find(q);\\n    }\\n\\n    // validate that p is a valid index\\n    private void validate(int p) {\\n        int n = parent.length;\\n        if (p < 0 || p >= n) {\\n            throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1));  \\n        }\\n    }\\n\\n    public void union(int p, int q) {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if (rootP == rootQ) return;\\n\\n        // make smaller root point to larger one\\n        if (size[rootP] < size[rootQ]) {\\n            parent[rootP] = rootQ;\\n            size[rootQ] += size[rootP];\\n        }\\n        else {\\n            parent[rootQ] = rootP;\\n            size[rootP] += size[rootQ];\\n        }\\n        count--;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876108,
                "title": "java-straightforward-bfs-solution",
                "content": "**This is wrong answer. Does not work for below case:**\\n\\n```\\nn = 8\\nedges = [[3,5],[5,1],[1,6],[6,3],[2,6],[2,4],[4,7],[7,6],[6,8]]\\n``` \\n\\nReason: node with smallest inDegree doesn\\'t always be in a single group.\\n\\n# Intuition\\n\\nIt is kinda hard to have the idea that the graph has to be bipartite if you haven\\'t heard of it before. However luckily we don\\'t have to know that in order to solve the problem.\\n\\nIt can be solved in a pretty straightforward \"generative\"/greedy solution.\\n\\n# Approach\\nUse BFS to greedily generate the graphs from the nodes with smallest indegree. \\n\\nThis works because the nodes with smallest indegree must also be in the \"edge group\". Another way is to think the groups as a new graph, the \"nodes with smallest indegree\" must contribute to the groups with smallest indegree in the group graph.\\n\\n# Code\\n```\\nclass Solution {\\n    /*\\n    Runtime 40 ms Beats 100%\\n    Memory 43.9 MB Beats 100%\\n     */\\n    public int magnificentSets(int n, int[][] edges) {\\n        List<Integer>[] adjs = new List[n + 1];\\n        for (int i = 0; i < adjs.length; i++) {\\n            adjs[i] = new ArrayList<>();\\n        }\\n\\n        int[] inDegrees = new int[n + 1];\\n        inDegrees[0] = Integer.MAX_VALUE;\\n\\n        for (int[] edge : edges) {\\n            adjs[edge[0]].add(edge[1]);\\n            adjs[edge[1]].add(edge[0]);\\n            inDegrees[edge[0]]++;\\n            inDegrees[edge[1]]++;\\n        }\\n\\n        boolean[] visited = new boolean[n + 1];\\n        int groups = 0;\\n\\n        // inDegree == 0 means the node is not connected with any other nodes, add it to a group\\n        for (int i = 0; i < inDegrees.length; i++) {\\n            if (inDegrees[i] == 0) {\\n                groups++;\\n                visited[i] = true;\\n            }\\n        }\\n\\n        while (true) {\\n            List<Integer> starts = getStarts(inDegrees, visited);\\n            if (starts.size() == 0) {\\n                break;\\n            }\\n\\n            int minGroups = 0;\\n            int ind = 0;\\n            for (int i = 0; i < starts.size(); i++) {\\n                int num = bfs(adjs, starts.get(i), visited.clone());\\n                if (num > minGroups) {\\n                    minGroups = num;\\n                    ind = i;\\n                }\\n            }\\n            if (minGroups == 0) {\\n                return -1;\\n            }\\n\\n            // Actually update the `groups` and `visited`\\n            groups += bfs(adjs, starts.get(ind), visited);\\n        }\\n\\n        return groups;\\n    }\\n\\n    private int bfs(List<Integer>[] adjs, int start, boolean[] visited) {\\n        int groups = 0;\\n\\n        Set<Integer> parent = new HashSet<>();\\n        Set<Integer> curr = new HashSet<>();\\n        curr.add(start);\\n\\n        while (!curr.isEmpty()) {\\n            groups++;\\n\\n            Set<Integer> next = new HashSet<>();\\n\\n            for (int node : curr) {\\n                visited[node] = true;\\n                for (int nextNode : adjs[node]) {\\n                    if (visited[nextNode]) {\\n                        if (parent.contains(nextNode)) {\\n                            continue;\\n                        } else {\\n                            return -1;\\n                        }\\n                    }\\n                    next.add(nextNode);\\n                }\\n            }\\n\\n            parent = curr;\\n            curr = next;\\n        }\\n\\n        return groups;\\n    }\\n\\n    private List<Integer> getStarts(int[] inDegrees, boolean[] visited) {\\n        int minInd = 0;\\n\\n        for (int i = 1; i < visited.length; i++) {\\n            if (!visited[i] && inDegrees[i] < inDegrees[minInd]) {\\n                minInd = i;\\n            }\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 1; i < inDegrees.length; i++) {\\n            if (!visited[i] && inDegrees[i] == inDegrees[minInd]) {\\n                result.add(i);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nn = 8\\nedges = [[3,5],[5,1],[1,6],[6,3],[2,6],[2,4],[4,7],[7,6],[6,8]]\\n```\n```\\nclass Solution {\\n    /*\\n    Runtime 40 ms Beats 100%\\n    Memory 43.9 MB Beats 100%\\n     */\\n    public int magnificentSets(int n, int[][] edges) {\\n        List<Integer>[] adjs = new List[n + 1];\\n        for (int i = 0; i < adjs.length; i++) {\\n            adjs[i] = new ArrayList<>();\\n        }\\n\\n        int[] inDegrees = new int[n + 1];\\n        inDegrees[0] = Integer.MAX_VALUE;\\n\\n        for (int[] edge : edges) {\\n            adjs[edge[0]].add(edge[1]);\\n            adjs[edge[1]].add(edge[0]);\\n            inDegrees[edge[0]]++;\\n            inDegrees[edge[1]]++;\\n        }\\n\\n        boolean[] visited = new boolean[n + 1];\\n        int groups = 0;\\n\\n        // inDegree == 0 means the node is not connected with any other nodes, add it to a group\\n        for (int i = 0; i < inDegrees.length; i++) {\\n            if (inDegrees[i] == 0) {\\n                groups++;\\n                visited[i] = true;\\n            }\\n        }\\n\\n        while (true) {\\n            List<Integer> starts = getStarts(inDegrees, visited);\\n            if (starts.size() == 0) {\\n                break;\\n            }\\n\\n            int minGroups = 0;\\n            int ind = 0;\\n            for (int i = 0; i < starts.size(); i++) {\\n                int num = bfs(adjs, starts.get(i), visited.clone());\\n                if (num > minGroups) {\\n                    minGroups = num;\\n                    ind = i;\\n                }\\n            }\\n            if (minGroups == 0) {\\n                return -1;\\n            }\\n\\n            // Actually update the `groups` and `visited`\\n            groups += bfs(adjs, starts.get(ind), visited);\\n        }\\n\\n        return groups;\\n    }\\n\\n    private int bfs(List<Integer>[] adjs, int start, boolean[] visited) {\\n        int groups = 0;\\n\\n        Set<Integer> parent = new HashSet<>();\\n        Set<Integer> curr = new HashSet<>();\\n        curr.add(start);\\n\\n        while (!curr.isEmpty()) {\\n            groups++;\\n\\n            Set<Integer> next = new HashSet<>();\\n\\n            for (int node : curr) {\\n                visited[node] = true;\\n                for (int nextNode : adjs[node]) {\\n                    if (visited[nextNode]) {\\n                        if (parent.contains(nextNode)) {\\n                            continue;\\n                        } else {\\n                            return -1;\\n                        }\\n                    }\\n                    next.add(nextNode);\\n                }\\n            }\\n\\n            parent = curr;\\n            curr = next;\\n        }\\n\\n        return groups;\\n    }\\n\\n    private List<Integer> getStarts(int[] inDegrees, boolean[] visited) {\\n        int minInd = 0;\\n\\n        for (int i = 1; i < visited.length; i++) {\\n            if (!visited[i] && inDegrees[i] < inDegrees[minInd]) {\\n                minInd = i;\\n            }\\n        }\\n\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 1; i < inDegrees.length; i++) {\\n            if (!visited[i] && inDegrees[i] == inDegrees[minInd]) {\\n                result.add(i);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876054,
                "title": "java-union-find-bfs-dfs",
                "content": "# 1. union find + BFS + DFS\\n```\\n\\t//1. union find + BFS + DFS\\n    //Runtime: 1009 ms, faster than 100.00% of Java online submissions for Divide Nodes Into the Maximum Number of Groups.\\n    //Memory Usage: 45.8 MB, less than 100.00% of Java online submissions for Divide Nodes Into the Maximum Number of Groups.\\n    //Time: O(N * N + E * log(N)); Space: O(N + E)\\n    public int magnificentSets(int n, int[][] edges) {\\n\\n        //let a component be a connected graph\\n        //Time: O(N + N + E * log(N)); Space: O(N + E)\\n        UnionFind uf = new UnionFind(n + 1);\\n        List<Integer>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n            uf.union(edge[0], edge[1]);\\n        }\\n\\n        // check every component(a connected graph) if it contains a circle which has odd numbers of edges.\\n        // If it has one, then it cannot be grouped.\\n        //Time: O(N * (log(N) + N)); Space: O(N)\\n        boolean[] seen = new boolean[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            int group = uf.find(i);\\n\\n            if (seen[group]) continue;\\n            seen[group] = true;\\n\\n            int[] pos = new int[n + 1];\\n            Arrays.fill(pos, -1);\\n            if (-1 == helper_dfs(graph, pos, i, 0, new int[n + 1])) return -1;\\n        }\\n\\n        //Time: O(N * (log(N) + N)); Space: O(N)\\n        int[] maxLayers = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            int group = uf.find(i);\\n            //get the maximum numbers of layer in a connected graph via BFS\\n            maxLayers[group] = Math.max(maxLayers[group], helper_bfs_countLayer(graph, i));\\n        }\\n\\n        //sum layers\\n        //Time: O(N * (log(N)));\\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            int group = uf.find(i);\\n            res += maxLayers[group];\\n            maxLayers[group] = 0;\\n        }\\n        return res;\\n    }\\n\\n    private int helper_bfs_countLayer(List<Integer>[] graph, int node){\\n        Set<Integer> seen = new HashSet<>();\\n        seen.add(node);\\n\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(node);\\n        int layer = 0;\\n        while (!queue.isEmpty()){\\n            int queueSize = queue.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                int nodeX = queue.poll();\\n                for(int neighbour: graph[nodeX])\\n                    if (seen.add(neighbour)) queue.add(neighbour);\\n            }\\n            layer++;\\n        }\\n        return layer;\\n    }\\n\\n    //circle\\n    private int helper_dfs(List<Integer>[] graph, int[] pos, int node, int steps, int[] memo) {\\n\\n        if (pos[node] != -1) {\\n            memo[node] = 1;\\n            if (steps - pos[node] > 1 && (steps - pos[node]) % 2 != 0)\\n                memo[node] = -1;\\n            return memo[node];\\n        }\\n\\n        if (memo[node] != 0) return memo[node];\\n        memo[node] = 1;\\n        pos[node] = steps;\\n        List<Integer> neighbours = graph[node];\\n        for(int neighbour: neighbours) {\\n            memo[node] = helper_dfs(graph, pos, neighbour, steps + 1, memo);\\n            if (memo[node] == -1) return memo[node];\\n        }\\n        pos[node] = -1;\\n        return memo[node];\\n    }\\n\\n    public class UnionFind {\\n\\n        private int[] group;\\n        private int[] rank;\\n\\n        public UnionFind(int size) {\\n            group = new int[size];\\n            rank = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                group[i] = i; rank[i] = 1;\\n            }\\n        }\\n\\n        //Time: O(\\u03B1(N))\\n        public int find(int x) {\\n            return x == group[x] ? x: (group[x] = find(group[x]));\\n        }\\n\\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            if (rootX == rootY) return;\\n\\n            if (rank[rootX] < rank[rootY]){\\n                group[rootX] = rootY;\\n            }else{\\n                group[rootY] = rootX;\\n                if (rank[rootX] == rank[rootY]) rank[rootX]++;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\n\\t//1. union find + BFS + DFS\\n    //Runtime: 1009 ms, faster than 100.00% of Java online submissions for Divide Nodes Into the Maximum Number of Groups.\\n    //Memory Usage: 45.8 MB, less than 100.00% of Java online submissions for Divide Nodes Into the Maximum Number of Groups.\\n    //Time: O(N * N + E * log(N)); Space: O(N + E)\\n    public int magnificentSets(int n, int[][] edges) {\\n\\n        //let a component be a connected graph\\n        //Time: O(N + N + E * log(N)); Space: O(N + E)\\n        UnionFind uf = new UnionFind(n + 1);\\n        List<Integer>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n            uf.union(edge[0], edge[1]);\\n        }\\n\\n        // check every component(a connected graph) if it contains a circle which has odd numbers of edges.\\n        // If it has one, then it cannot be grouped.\\n        //Time: O(N * (log(N) + N)); Space: O(N)\\n        boolean[] seen = new boolean[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            int group = uf.find(i);\\n\\n            if (seen[group]) continue;\\n            seen[group] = true;\\n\\n            int[] pos = new int[n + 1];\\n            Arrays.fill(pos, -1);\\n            if (-1 == helper_dfs(graph, pos, i, 0, new int[n + 1])) return -1;\\n        }\\n\\n        //Time: O(N * (log(N) + N)); Space: O(N)\\n        int[] maxLayers = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            int group = uf.find(i);\\n            //get the maximum numbers of layer in a connected graph via BFS\\n            maxLayers[group] = Math.max(maxLayers[group], helper_bfs_countLayer(graph, i));\\n        }\\n\\n        //sum layers\\n        //Time: O(N * (log(N)));\\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            int group = uf.find(i);\\n            res += maxLayers[group];\\n            maxLayers[group] = 0;\\n        }\\n        return res;\\n    }\\n\\n    private int helper_bfs_countLayer(List<Integer>[] graph, int node){\\n        Set<Integer> seen = new HashSet<>();\\n        seen.add(node);\\n\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(node);\\n        int layer = 0;\\n        while (!queue.isEmpty()){\\n            int queueSize = queue.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                int nodeX = queue.poll();\\n                for(int neighbour: graph[nodeX])\\n                    if (seen.add(neighbour)) queue.add(neighbour);\\n            }\\n            layer++;\\n        }\\n        return layer;\\n    }\\n\\n    //circle\\n    private int helper_dfs(List<Integer>[] graph, int[] pos, int node, int steps, int[] memo) {\\n\\n        if (pos[node] != -1) {\\n            memo[node] = 1;\\n            if (steps - pos[node] > 1 && (steps - pos[node]) % 2 != 0)\\n                memo[node] = -1;\\n            return memo[node];\\n        }\\n\\n        if (memo[node] != 0) return memo[node];\\n        memo[node] = 1;\\n        pos[node] = steps;\\n        List<Integer> neighbours = graph[node];\\n        for(int neighbour: neighbours) {\\n            memo[node] = helper_dfs(graph, pos, neighbour, steps + 1, memo);\\n            if (memo[node] == -1) return memo[node];\\n        }\\n        pos[node] = -1;\\n        return memo[node];\\n    }\\n\\n    public class UnionFind {\\n\\n        private int[] group;\\n        private int[] rank;\\n\\n        public UnionFind(int size) {\\n            group = new int[size];\\n            rank = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                group[i] = i; rank[i] = 1;\\n            }\\n        }\\n\\n        //Time: O(\\u03B1(N))\\n        public int find(int x) {\\n            return x == group[x] ? x: (group[x] = find(group[x]));\\n        }\\n\\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            if (rootX == rootY) return;\\n\\n            if (rank[rootX] < rank[rootY]){\\n                group[rootX] = rootY;\\n            }else{\\n                group[rootY] = rootX;\\n                if (rank[rootX] == rank[rootY]) rank[rootX]++;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875897,
                "title": "golang-bfs-bipartite-check",
                "content": "```\\nfunc magnificentSets(n int, edges [][]int) int {\\n\\tgraph := make([][]int, n+1)\\n\\tfor _, edge := range edges {\\n\\t\\tgraph[edge[0]] = append(graph[edge[0]], edge[1])\\n\\t\\tgraph[edge[1]] = append(graph[edge[1]], edge[0])\\n\\t}\\n\\n\\tdist := make([]int, n+1)\\n\\tsteps := make([]int, n+1)\\n\\n\\tvar q []int\\n\\tfor nodeIdx := 1; nodeIdx <= n; nodeIdx++ {\\n\\t\\tfor ddx := range dist {\\n\\t\\t\\tdist[ddx] = math.MaxInt64\\n\\t\\t}\\n\\n\\t\\tq = append(q, nodeIdx)\\n\\t\\tdist[nodeIdx] = 0\\n\\n\\t\\tmaxDistance, minNodeIdx := 0, nodeIdx\\n\\t\\tfor 0 != len(q) {\\n\\t\\t\\tfromNodeIdx := q[0]\\n\\t\\t\\tq = q[1:] // pop left\\n\\n\\t\\t\\tfor _, toNodeIdx := range graph[fromNodeIdx] {\\n\\t\\t\\t\\tif math.MaxInt64 == dist[toNodeIdx] { // If not visited\\n\\t\\t\\t\\t\\tdist[toNodeIdx] = dist[fromNodeIdx] + 1\\n\\n\\t\\t\\t\\t\\tmaxDistance = max2493(maxDistance, dist[toNodeIdx])\\n\\t\\t\\t\\t\\tminNodeIdx = min2493(minNodeIdx, toNodeIdx)\\n\\n\\t\\t\\t\\t\\tq = append(q, toNodeIdx)\\n\\t\\t\\t\\t} else if dist[toNodeIdx]%2 != (dist[fromNodeIdx]+1)%2 { // If not Bipartite \\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsteps[minNodeIdx] = max2493(steps[minNodeIdx], maxDistance+1)\\n\\t}\\n\\n\\tresult := 0\\n\\tfor nodeIdx := 1; nodeIdx <= n; nodeIdx++ {\\n\\t\\tresult += steps[nodeIdx]\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc min2493(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc max2493(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc magnificentSets(n int, edges [][]int) int {\\n\\tgraph := make([][]int, n+1)\\n\\tfor _, edge := range edges {\\n\\t\\tgraph[edge[0]] = append(graph[edge[0]], edge[1])\\n\\t\\tgraph[edge[1]] = append(graph[edge[1]], edge[0])\\n\\t}\\n\\n\\tdist := make([]int, n+1)\\n\\tsteps := make([]int, n+1)\\n\\n\\tvar q []int\\n\\tfor nodeIdx := 1; nodeIdx <= n; nodeIdx++ {\\n\\t\\tfor ddx := range dist {\\n\\t\\t\\tdist[ddx] = math.MaxInt64\\n\\t\\t}\\n\\n\\t\\tq = append(q, nodeIdx)\\n\\t\\tdist[nodeIdx] = 0\\n\\n\\t\\tmaxDistance, minNodeIdx := 0, nodeIdx\\n\\t\\tfor 0 != len(q) {\\n\\t\\t\\tfromNodeIdx := q[0]\\n\\t\\t\\tq = q[1:] // pop left\\n\\n\\t\\t\\tfor _, toNodeIdx := range graph[fromNodeIdx] {\\n\\t\\t\\t\\tif math.MaxInt64 == dist[toNodeIdx] { // If not visited\\n\\t\\t\\t\\t\\tdist[toNodeIdx] = dist[fromNodeIdx] + 1\\n\\n\\t\\t\\t\\t\\tmaxDistance = max2493(maxDistance, dist[toNodeIdx])\\n\\t\\t\\t\\t\\tminNodeIdx = min2493(minNodeIdx, toNodeIdx)\\n\\n\\t\\t\\t\\t\\tq = append(q, toNodeIdx)\\n\\t\\t\\t\\t} else if dist[toNodeIdx]%2 != (dist[fromNodeIdx]+1)%2 { // If not Bipartite \\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsteps[minNodeIdx] = max2493(steps[minNodeIdx], maxDistance+1)\\n\\t}\\n\\n\\tresult := 0\\n\\tfor nodeIdx := 1; nodeIdx <= n; nodeIdx++ {\\n\\t\\tresult += steps[nodeIdx]\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc min2493(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc max2493(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2875857,
                "title": "c-dfs-bfs",
                "content": "# Intuition\\nWe can append disconected components one after other. Find disconnected components and then for each disconnected component assuming each element as start find the max depth possible if this results in cycle return -1. If in any disconnected component is cyclic return -1. Else return sum of max of depth of all disconnected component.\\n# Approach\\n1) Do Dfs to find disconnected component.\\n2) Loop for all disconnected component.\\n3) Assuming each element as root in the disconnected component do a Bfs to find depth.\\n4) Find the max depth if not cyclic from all the possible roots in component.\\n5) If any component cyclic return -1\\n6) As we can append disconnected components after each other sum up max of all the disconnected component.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(int src,vector<int>adj[],vector<int>&depth){\\n        queue<pair<int,int>>q;\\n        q.push({src,1});\\n        depth[src]=1;\\n        int ans=1;\\n        while(!q.empty()){\\n            pair<int,int> top=q.front();\\n            q.pop();\\n            for(int i=0;i<adj[top.first].size();i++){\\n                if(depth[adj[top.first][i]]==-1){\\n                    depth[adj[top.first][i]]=top.second+1;\\n                    ans=max(ans,top.second+1);\\n                    q.push({adj[top.first][i],top.second+1});\\n                }\\n                else{\\n                    if(abs(depth[top.first]-depth[adj[top.first][i]])!=1)\\n                        return -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    void dfs(vector<int>adj[],vector<bool>&visited,vector<int>&temp,int src){\\n        temp.push_back(src);\\n        for(int i=0;i<adj[src].size();i++){\\n            if(visited[adj[src][i]])\\n                continue;\\n            visited[adj[src][i]]=true;\\n            dfs(adj,visited,temp,adj[src][i]);\\n        }\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<vector<int>> disc;\\n        vector<bool> visited(n+1,false);\\n        for(int i=1;i<=n;i++){\\n            if(visited[i])\\n                continue;\\n            visited[i]=true;\\n            vector<int> temp;\\n            dfs(adj,visited,temp,i);\\n            disc.push_back(temp);\\n        }\\n        int ans=0;\\n        vector<int> answer(disc.size(),-1);\\n        for(int j=0;j<disc.size();j++){\\n            for(int i=0;i<disc[j].size();i++){\\n                \\n                vector<int> depth(n+1,-1);\\n                answer[j]=max(answer[j],bfs(disc[j][i],adj,depth));\\n            }\\n        }\\n        for(int j=0;j<disc.size();j++){\\n            if(answer[j]==-1)\\n                return -1;\\n            ans+=answer[j];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nUpVote if helped :)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(int src,vector<int>adj[],vector<int>&depth){\\n        queue<pair<int,int>>q;\\n        q.push({src,1});\\n        depth[src]=1;\\n        int ans=1;\\n        while(!q.empty()){\\n            pair<int,int> top=q.front();\\n            q.pop();\\n            for(int i=0;i<adj[top.first].size();i++){\\n                if(depth[adj[top.first][i]]==-1){\\n                    depth[adj[top.first][i]]=top.second+1;\\n                    ans=max(ans,top.second+1);\\n                    q.push({adj[top.first][i],top.second+1});\\n                }\\n                else{\\n                    if(abs(depth[top.first]-depth[adj[top.first][i]])!=1)\\n                        return -1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    void dfs(vector<int>adj[],vector<bool>&visited,vector<int>&temp,int src){\\n        temp.push_back(src);\\n        for(int i=0;i<adj[src].size();i++){\\n            if(visited[adj[src][i]])\\n                continue;\\n            visited[adj[src][i]]=true;\\n            dfs(adj,visited,temp,adj[src][i]);\\n        }\\n    }\\n    int magnificentSets(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<vector<int>> disc;\\n        vector<bool> visited(n+1,false);\\n        for(int i=1;i<=n;i++){\\n            if(visited[i])\\n                continue;\\n            visited[i]=true;\\n            vector<int> temp;\\n            dfs(adj,visited,temp,i);\\n            disc.push_back(temp);\\n        }\\n        int ans=0;\\n        vector<int> answer(disc.size(),-1);\\n        for(int j=0;j<disc.size();j++){\\n            for(int i=0;i<disc[j].size();i++){\\n                \\n                vector<int> depth(n+1,-1);\\n                answer[j]=max(answer[j],bfs(disc[j][i],adj,depth));\\n            }\\n        }\\n        for(int j=0;j<disc.size();j++){\\n            if(answer[j]==-1)\\n                return -1;\\n            ans+=answer[j];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875689,
                "title": "javascript-union-find-isbipartite-3083ms",
                "content": "prerequisite: https://leetcode.com/problems/is-graph-bipartite/\\n```\\n/////////////////////// Template ////////////////////////////////////////\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(Number.MAX_SAFE_INTEGER); d.push(t); } return d; };\\n\\nfunction DJSet(n) {\\n    // parent[i] < 0, -parent[i] is the group size which root is i. example: (i -> parent[i] -> parent[parent[i]] -> parent[parent[parent[i]]] ...)\\n    // parent[i] >= 0, i is not the root and parent[i] is i\\'s parent. example: (... parent[parent[parent[i]]] -> parent[parent[i]] -> parent[i] -> i)\\n    let parent = Array(n).fill(-1);\\n    return { find, union, count, equiv, par }\\n    function find(x) {\\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x != y) {\\n            if (parent[x] < parent[y]) [x, y] = [y, x];\\n            parent[x] += parent[y];\\n            parent[y] = x;\\n        }\\n        return x == y;\\n    }\\n    function count() { // total groups\\n        return parent.filter(v => v < 0).length;\\n    }\\n    function equiv(x, y) { // isConnected\\n        return find(x) == find(y);\\n    }\\n    function par() {\\n        return parent;\\n    }\\n}\\n\\nconst isBipartite = (g) => {\\n    let n = g.length, start = 1, visit = Array(n).fill(false), q = [], color = Array(n).fill(0); // 0: no color, 1: red  -1: blue\\n    for (let i = start; i < n; i++) {\\n        if (color[i] != 0) continue;\\n        q.push(i);\\n        color[i] = 1;\\n        if (visit[i]) continue;\\n        while (q.length) {\\n            let cur = q.shift();\\n            if (visit[cur]) continue;\\n            for (const child of g[cur]) {\\n                if (color[child] == color[cur]) return false;\\n                if (color[child]) continue;\\n                color[child] = -color[cur];\\n                q.push(child);\\n            }\\n        }\\n    }\\n    return true;\\n};\\n////////////////////////////////////////////////////////////////////\\n\\nconst magnificentSets = (n, edges) => {\\n    let g = initializeGraph(n + 1), ds = new DJSet(n + 1);\\n    packUG(g, edges);\\n    if (!isBipartite(g)) return -1;\\n    let d = initialize2DArray(n + 1, n + 1), res = Array(n + 1).fill(0);\\n    for (let i = 1; i <= n; i++) d[i][i] = 0;\\n    for (const [u, v] of edges) {\\n        d[u][v] = 1;\\n        d[v][u] = 1;\\n        ds.union(u, v);\\n    }\\n    wf(d);\\n    for (let i = 1; i <= n; i++) {\\n        let max = 0;\\n        for (let j = 1; j <= n; j++) {\\n            if (d[i][j] >= Number.MAX_SAFE_INTEGER) continue;\\n            max = Math.max(max, d[i][j]);\\n        }\\n        let par = ds.find(i);\\n        res[par] = Math.max(res[par], max + 1);\\n    }\\n    let ans = 0;\\n    for (let i = 1; i <= n; i++) ans += res[i];\\n    return ans;\\n};\\n\\nconst wf = (g) => {\\n    let n = g.length;\\n    for (let k = 0; k < n; k++) {\\n        for (let i = 0; i < n; i++) {\\n            for (let j = 0; j < n; j++) {\\n                if (g[i][j] > g[i][k] + g[k][j]) {\\n                    g[i][j] = g[i][k] + g[k][j];\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n/////////////////////// Template ////////////////////////////////////////\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(Number.MAX_SAFE_INTEGER); d.push(t); } return d; };\\n\\nfunction DJSet(n) {\\n    // parent[i] < 0, -parent[i] is the group size which root is i. example: (i -> parent[i] -> parent[parent[i]] -> parent[parent[parent[i]]] ...)\\n    // parent[i] >= 0, i is not the root and parent[i] is i\\'s parent. example: (... parent[parent[parent[i]]] -> parent[parent[i]] -> parent[i] -> i)\\n    let parent = Array(n).fill(-1);\\n    return { find, union, count, equiv, par }\\n    function find(x) {\\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x != y) {\\n            if (parent[x] < parent[y]) [x, y] = [y, x];\\n            parent[x] += parent[y];\\n            parent[y] = x;\\n        }\\n        return x == y;\\n    }\\n    function count() { // total groups\\n        return parent.filter(v => v < 0).length;\\n    }\\n    function equiv(x, y) { // isConnected\\n        return find(x) == find(y);\\n    }\\n    function par() {\\n        return parent;\\n    }\\n}\\n\\nconst isBipartite = (g) => {\\n    let n = g.length, start = 1, visit = Array(n).fill(false), q = [], color = Array(n).fill(0); // 0: no color, 1: red  -1: blue\\n    for (let i = start; i < n; i++) {\\n        if (color[i] != 0) continue;\\n        q.push(i);\\n        color[i] = 1;\\n        if (visit[i]) continue;\\n        while (q.length) {\\n            let cur = q.shift();\\n            if (visit[cur]) continue;\\n            for (const child of g[cur]) {\\n                if (color[child] == color[cur]) return false;\\n                if (color[child]) continue;\\n                color[child] = -color[cur];\\n                q.push(child);\\n            }\\n        }\\n    }\\n    return true;\\n};\\n////////////////////////////////////////////////////////////////////\\n\\nconst magnificentSets = (n, edges) => {\\n    let g = initializeGraph(n + 1), ds = new DJSet(n + 1);\\n    packUG(g, edges);\\n    if (!isBipartite(g)) return -1;\\n    let d = initialize2DArray(n + 1, n + 1), res = Array(n + 1).fill(0);\\n    for (let i = 1; i <= n; i++) d[i][i] = 0;\\n    for (const [u, v] of edges) {\\n        d[u][v] = 1;\\n        d[v][u] = 1;\\n        ds.union(u, v);\\n    }\\n    wf(d);\\n    for (let i = 1; i <= n; i++) {\\n        let max = 0;\\n        for (let j = 1; j <= n; j++) {\\n            if (d[i][j] >= Number.MAX_SAFE_INTEGER) continue;\\n            max = Math.max(max, d[i][j]);\\n        }\\n        let par = ds.find(i);\\n        res[par] = Math.max(res[par], max + 1);\\n    }\\n    let ans = 0;\\n    for (let i = 1; i <= n; i++) ans += res[i];\\n    return ans;\\n};\\n\\nconst wf = (g) => {\\n    let n = g.length;\\n    for (let k = 0; k < n; k++) {\\n        for (let i = 0; i < n; i++) {\\n            for (let j = 0; j < n; j++) {\\n                if (g[i][j] > g[i][k] + g[k][j]) {\\n                    g[i][j] = g[i][k] + g[k][j];\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2875574,
                "title": "python-set-ish-solution",
                "content": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: list[list[int]]) -> int:\\n\\n        neighbors = defaultdict(set)\\n        parents = {i: i for i in range(1, n+1)}\\n\\n        def findParent(x):\\n            if parents[x] != x:\\n                parents[x] = findParent(parents[x])\\n            return parents[x]\\n\\n        def union(x, y):\\n            xp, yp = findParent(x), findParent(y)\\n            if xp <= yp:\\n                parents[yp] = xp\\n            else:\\n                parents[xp] = yp\\n\\n        for start, end in edges:\\n            neighbors[start].add(end)\\n            neighbors[end].add(start)\\n            union(start, end)\\n        for i in range(1, n):\\n            findParent(i)\\n\\n        result = [0] * (n+1)\\n\\n        def findGroupFromX(x):\\n            nonlocal result\\n            visited = set([x])\\n            current = set([x])\\n            layer = 0\\n            while len(current) != 0:\\n                next_set = set()\\n                for item in current:\\n                    next_set = next_set.union(neighbors[item] - visited)\\n                for item in next_set:\\n                    if len(neighbors[item].intersection(next_set - set([item]))) != 0:\\n                        return True\\n                current = next_set\\n                visited = visited.union(current)\\n                layer += 1\\n            result[findParent(x)] = max(result[findParent(x)], layer)\\n\\n        for i in range(1, n+1):\\n            if findGroupFromX(i):\\n                return -1\\n        return sum(result)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def magnificentSets(self, n: int, edges: list[list[int]]) -> int:\\n\\n        neighbors = defaultdict(set)\\n        parents = {i: i for i in range(1, n+1)}\\n\\n        def findParent(x):\\n            if parents[x] != x:\\n                parents[x] = findParent(parents[x])\\n            return parents[x]\\n\\n        def union(x, y):\\n            xp, yp = findParent(x), findParent(y)\\n            if xp <= yp:\\n                parents[yp] = xp\\n            else:\\n                parents[xp] = yp\\n\\n        for start, end in edges:\\n            neighbors[start].add(end)\\n            neighbors[end].add(start)\\n            union(start, end)\\n        for i in range(1, n):\\n            findParent(i)\\n\\n        result = [0] * (n+1)\\n\\n        def findGroupFromX(x):\\n            nonlocal result\\n            visited = set([x])\\n            current = set([x])\\n            layer = 0\\n            while len(current) != 0:\\n                next_set = set()\\n                for item in current:\\n                    next_set = next_set.union(neighbors[item] - visited)\\n                for item in next_set:\\n                    if len(neighbors[item].intersection(next_set - set([item]))) != 0:\\n                        return True\\n                current = next_set\\n                visited = visited.union(current)\\n                layer += 1\\n            result[findParent(x)] = max(result[findParent(x)], layer)\\n\\n        for i in range(1, n+1):\\n            if findGroupFromX(i):\\n                return -1\\n        return sum(result)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1705239,
                "content": [
                    {
                        "username": "saranyamaity2000",
                        "content": "Am I the only one who thought the actual BFS solution won\\'t work after seeing number of edges and forget to see that n is only 500 ?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Why sum up the number of groups of all disconnected graph? The question does not restrict that disconnected nodes should not be in the same group."
                    },
                    {
                        "username": "espadandy",
                        "content": "[@Tudor67](/Tudor67) Thank you so much. I only remember this condition when maximize the path of a sub-graph but forget it when it comes to disconnect parts."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@yandyxu](/espadandy) Problem statement:\n`Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes.`\n\nTo maximize the number of groups (**for all nodes of the input graph**), it is always better to assign disconnected nodes to different groups.\n\nImagine a Graph with 5 isolated nodes (i.e., no edges):\n1.) You can create just one group for all nodes and return 1;\n(but this is not the maximum number of groups for the given graph);\n2.) Or you can create 5 groups (a group for each isolated node) and return 5;\n(this is the maximum number of groups for the given graph)."
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Am I the only one who got TL in an empty test case?\n55/55 passed.\nwtf?"
                    },
                    {
                        "username": "yjyjyj",
                        "content": "Test cases are not sufficient to identify wrong solution. \\nthis solution will fail this test case, while it could pass submission test.\\n10\\n[[3,5],[4,2],[4,7],[6,8],[2,6],[6,3],[6,1],[1,5],[6,7],[5,9],[9,6],[6,10],[10,4]]\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.adj = defaultdict(list)\\n    \\n    def getSplitCount(self, start):\\n        global_visited = {}\\n        level_nodes = [start]\\n        split_count = 0\\n        prev_nodes = set([])\\n        while len(level_nodes) > 0:\\n            split_count += 1\\n            next_level_nodes = []\\n            visited = {}\\n            for s_node in level_nodes:\\n                global_visited[s_node] = True\\n                for e_node in self.adj[s_node]:\\n                    if e_node in global_visited:\\n                        if e_node not in prev_nodes:\\n                            return -1\\n                        else:\\n                            continue\\n                    if e_node not in visited: # and e_node not in global_visited:\\n                        visited[e_node] = True\\n                        next_level_nodes.append(e_node)\\n            prev_nodes = set(level_nodes)\\n            level_nodes = next_level_nodes\\n                    \\n        return split_count\\n    \\n    \\n    def dfs(self, s_node, g_node, visited):\\n        if visited[s_node] != -1:\\n            return\\n        \\n        visited[s_node] = g_node\\n        for e_node in self.adj[s_node]:\\n            if(visited[e_node] == -1):\\n                self.dfs(e_node, g_node, visited)\\n    \\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        indeg = {i:0 for i in range(1, n+1)}\\n        \\n        for s,e in edges:\\n            self.adj[s].append(e)\\n            self.adj[e].append(s)\\n        for e in self.adj:\\n            indeg[e] = len(self.adj[e])\\n        \\n        visited = [-1] * (n+1)\\n        for i in range(1,n+1):\\n            if visited[i] == -1:\\n                self.dfs(i, i, visited)\\n        \\n        connected_components = defaultdict(list)\\n        for idx, node in enumerate(visited[1:], 1):\\n            connected_components[node].append(idx)\\n\\n        ans = 0\\n        valid_ans = True\\n        for _, components in connected_components.items():\\n            count_dict = {s:-1 for s in components}\\n            val = 0\\n            min_indegree = min([indeg[node] for node in components])\\n            for node in components:\\n                if indeg[node] > min_indegree + 1:\\n                    continue\\n                count_dict[node] = self.getSplitCount(node)\\n            if max(count_dict.values()) == -1:\\n                valid_ans = False\\n                break\\n            ans += max(count_dict.values())\\n        if not valid_ans:\\n            return -1\\n        return ans\\n        \\n```"
                    },
                    {
                        "username": "thongds",
                        "content": "The example 2 should be one group right ? Because if I say node 1,2,3 belong group 1, all conditions will be satisfied "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Condition 2 restricts that. If 2 nodes are in the same group and are connected, then y-x will not be 1"
                    },
                    {
                        "username": "_SID_",
                        "content": "In how many groups can we group the below graph when all nodes are connected to the same node?\\n\\nex:\\n1 - - 2\\n1 - - 3\\n1 - - 4\\n1 - - 5"
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor67](/Tudor67) Oh that makes sense thank you for your detailed explanation <3 ."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@sandrikosxila](/sandrikosxila) You have a graph with N = 92 nodes and E = 37 edges;\n\n1.) You can create max `3 groups` with all the nodes from the input edges;\nHow? Node 29 will be in Group 2, and the remaining nodes connected to node 29 will be distributed to Group 1 and Group 3.\n\n2.) Number of nodes (N = 92 nodes) > number of edges (E = 37 edges);\nYou have some isolated nodes: Number of nodes (N = 92) - unique nodes from the input edges (37 + 1) = 92 - 38 = 54.\nSo, you have 54 isolated nodes => You can create `another 54 groups`.\nHow? Each isolated node can create a new group.\n\nThe final answer is **57 groups** (`3 groups` from input edges + `54 groups` from isolated nodes)."
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor Buzu](/Tudor67) [@Amir Hasan](/log0i) then why is the answer `57` in this case:\\n```\\nn = 92\\nedges = [[67,29],[13,29],[77,29],[36,29],[82,29],[54,29],[57,29],[53,29],[68,29],[26,29],[21,29],[46,29],[41,29],[45,29],[56,29],[88,29],[2,29],[7,29],[5,29],[16,29],[37,29],[50,29],[79,29],[91,29],[48,29],[87,29],[25,29],[80,29],[71,29],[9,29],[78,29],[33,29],[4,29],[44,29],[72,29],[65,29],[61,29]]\\n```"
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@Siddarth Reddy](/_SID_) If the number of nodes is `n = 5` and `edges = [[1,2],[1,3],[1,4],[1,5]]` then the maximum number of groups is **m = 3**:\\n\\nGroup 1  ___  Group 2 ___ Group 3\\n2 -------------- 1 ----------- 5\\n3 ---------------|\\n4 ---------------|                        "
                    },
                    {
                        "username": "log0i",
                        "content": "2   |  g1->1 , g2->2,3,4,5    The difference of the groupIDs of the nodes connected by an edge should be 1"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "Can someone help me understand this question? \\n"
                    },
                    {
                        "username": "nonieno",
                        "content": "Why when I submitted my code the 6th time it went through with runtime better than 67% hello?"
                    },
                    {
                        "username": "raggzy",
                        "content": "I am curious if there is something better than O(V*(V+E)), anyone has ideas?"
                    }
                ]
            },
            {
                "id": 1730604,
                "content": [
                    {
                        "username": "saranyamaity2000",
                        "content": "Am I the only one who thought the actual BFS solution won\\'t work after seeing number of edges and forget to see that n is only 500 ?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Why sum up the number of groups of all disconnected graph? The question does not restrict that disconnected nodes should not be in the same group."
                    },
                    {
                        "username": "espadandy",
                        "content": "[@Tudor67](/Tudor67) Thank you so much. I only remember this condition when maximize the path of a sub-graph but forget it when it comes to disconnect parts."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@yandyxu](/espadandy) Problem statement:\n`Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes.`\n\nTo maximize the number of groups (**for all nodes of the input graph**), it is always better to assign disconnected nodes to different groups.\n\nImagine a Graph with 5 isolated nodes (i.e., no edges):\n1.) You can create just one group for all nodes and return 1;\n(but this is not the maximum number of groups for the given graph);\n2.) Or you can create 5 groups (a group for each isolated node) and return 5;\n(this is the maximum number of groups for the given graph)."
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Am I the only one who got TL in an empty test case?\n55/55 passed.\nwtf?"
                    },
                    {
                        "username": "yjyjyj",
                        "content": "Test cases are not sufficient to identify wrong solution. \\nthis solution will fail this test case, while it could pass submission test.\\n10\\n[[3,5],[4,2],[4,7],[6,8],[2,6],[6,3],[6,1],[1,5],[6,7],[5,9],[9,6],[6,10],[10,4]]\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.adj = defaultdict(list)\\n    \\n    def getSplitCount(self, start):\\n        global_visited = {}\\n        level_nodes = [start]\\n        split_count = 0\\n        prev_nodes = set([])\\n        while len(level_nodes) > 0:\\n            split_count += 1\\n            next_level_nodes = []\\n            visited = {}\\n            for s_node in level_nodes:\\n                global_visited[s_node] = True\\n                for e_node in self.adj[s_node]:\\n                    if e_node in global_visited:\\n                        if e_node not in prev_nodes:\\n                            return -1\\n                        else:\\n                            continue\\n                    if e_node not in visited: # and e_node not in global_visited:\\n                        visited[e_node] = True\\n                        next_level_nodes.append(e_node)\\n            prev_nodes = set(level_nodes)\\n            level_nodes = next_level_nodes\\n                    \\n        return split_count\\n    \\n    \\n    def dfs(self, s_node, g_node, visited):\\n        if visited[s_node] != -1:\\n            return\\n        \\n        visited[s_node] = g_node\\n        for e_node in self.adj[s_node]:\\n            if(visited[e_node] == -1):\\n                self.dfs(e_node, g_node, visited)\\n    \\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        indeg = {i:0 for i in range(1, n+1)}\\n        \\n        for s,e in edges:\\n            self.adj[s].append(e)\\n            self.adj[e].append(s)\\n        for e in self.adj:\\n            indeg[e] = len(self.adj[e])\\n        \\n        visited = [-1] * (n+1)\\n        for i in range(1,n+1):\\n            if visited[i] == -1:\\n                self.dfs(i, i, visited)\\n        \\n        connected_components = defaultdict(list)\\n        for idx, node in enumerate(visited[1:], 1):\\n            connected_components[node].append(idx)\\n\\n        ans = 0\\n        valid_ans = True\\n        for _, components in connected_components.items():\\n            count_dict = {s:-1 for s in components}\\n            val = 0\\n            min_indegree = min([indeg[node] for node in components])\\n            for node in components:\\n                if indeg[node] > min_indegree + 1:\\n                    continue\\n                count_dict[node] = self.getSplitCount(node)\\n            if max(count_dict.values()) == -1:\\n                valid_ans = False\\n                break\\n            ans += max(count_dict.values())\\n        if not valid_ans:\\n            return -1\\n        return ans\\n        \\n```"
                    },
                    {
                        "username": "thongds",
                        "content": "The example 2 should be one group right ? Because if I say node 1,2,3 belong group 1, all conditions will be satisfied "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Condition 2 restricts that. If 2 nodes are in the same group and are connected, then y-x will not be 1"
                    },
                    {
                        "username": "_SID_",
                        "content": "In how many groups can we group the below graph when all nodes are connected to the same node?\\n\\nex:\\n1 - - 2\\n1 - - 3\\n1 - - 4\\n1 - - 5"
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor67](/Tudor67) Oh that makes sense thank you for your detailed explanation <3 ."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@sandrikosxila](/sandrikosxila) You have a graph with N = 92 nodes and E = 37 edges;\n\n1.) You can create max `3 groups` with all the nodes from the input edges;\nHow? Node 29 will be in Group 2, and the remaining nodes connected to node 29 will be distributed to Group 1 and Group 3.\n\n2.) Number of nodes (N = 92 nodes) > number of edges (E = 37 edges);\nYou have some isolated nodes: Number of nodes (N = 92) - unique nodes from the input edges (37 + 1) = 92 - 38 = 54.\nSo, you have 54 isolated nodes => You can create `another 54 groups`.\nHow? Each isolated node can create a new group.\n\nThe final answer is **57 groups** (`3 groups` from input edges + `54 groups` from isolated nodes)."
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor Buzu](/Tudor67) [@Amir Hasan](/log0i) then why is the answer `57` in this case:\\n```\\nn = 92\\nedges = [[67,29],[13,29],[77,29],[36,29],[82,29],[54,29],[57,29],[53,29],[68,29],[26,29],[21,29],[46,29],[41,29],[45,29],[56,29],[88,29],[2,29],[7,29],[5,29],[16,29],[37,29],[50,29],[79,29],[91,29],[48,29],[87,29],[25,29],[80,29],[71,29],[9,29],[78,29],[33,29],[4,29],[44,29],[72,29],[65,29],[61,29]]\\n```"
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@Siddarth Reddy](/_SID_) If the number of nodes is `n = 5` and `edges = [[1,2],[1,3],[1,4],[1,5]]` then the maximum number of groups is **m = 3**:\\n\\nGroup 1  ___  Group 2 ___ Group 3\\n2 -------------- 1 ----------- 5\\n3 ---------------|\\n4 ---------------|                        "
                    },
                    {
                        "username": "log0i",
                        "content": "2   |  g1->1 , g2->2,3,4,5    The difference of the groupIDs of the nodes connected by an edge should be 1"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "Can someone help me understand this question? \\n"
                    },
                    {
                        "username": "nonieno",
                        "content": "Why when I submitted my code the 6th time it went through with runtime better than 67% hello?"
                    },
                    {
                        "username": "raggzy",
                        "content": "I am curious if there is something better than O(V*(V+E)), anyone has ideas?"
                    }
                ]
            },
            {
                "id": 1899097,
                "content": [
                    {
                        "username": "saranyamaity2000",
                        "content": "Am I the only one who thought the actual BFS solution won\\'t work after seeing number of edges and forget to see that n is only 500 ?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Why sum up the number of groups of all disconnected graph? The question does not restrict that disconnected nodes should not be in the same group."
                    },
                    {
                        "username": "espadandy",
                        "content": "[@Tudor67](/Tudor67) Thank you so much. I only remember this condition when maximize the path of a sub-graph but forget it when it comes to disconnect parts."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@yandyxu](/espadandy) Problem statement:\n`Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes.`\n\nTo maximize the number of groups (**for all nodes of the input graph**), it is always better to assign disconnected nodes to different groups.\n\nImagine a Graph with 5 isolated nodes (i.e., no edges):\n1.) You can create just one group for all nodes and return 1;\n(but this is not the maximum number of groups for the given graph);\n2.) Or you can create 5 groups (a group for each isolated node) and return 5;\n(this is the maximum number of groups for the given graph)."
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Am I the only one who got TL in an empty test case?\n55/55 passed.\nwtf?"
                    },
                    {
                        "username": "yjyjyj",
                        "content": "Test cases are not sufficient to identify wrong solution. \\nthis solution will fail this test case, while it could pass submission test.\\n10\\n[[3,5],[4,2],[4,7],[6,8],[2,6],[6,3],[6,1],[1,5],[6,7],[5,9],[9,6],[6,10],[10,4]]\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.adj = defaultdict(list)\\n    \\n    def getSplitCount(self, start):\\n        global_visited = {}\\n        level_nodes = [start]\\n        split_count = 0\\n        prev_nodes = set([])\\n        while len(level_nodes) > 0:\\n            split_count += 1\\n            next_level_nodes = []\\n            visited = {}\\n            for s_node in level_nodes:\\n                global_visited[s_node] = True\\n                for e_node in self.adj[s_node]:\\n                    if e_node in global_visited:\\n                        if e_node not in prev_nodes:\\n                            return -1\\n                        else:\\n                            continue\\n                    if e_node not in visited: # and e_node not in global_visited:\\n                        visited[e_node] = True\\n                        next_level_nodes.append(e_node)\\n            prev_nodes = set(level_nodes)\\n            level_nodes = next_level_nodes\\n                    \\n        return split_count\\n    \\n    \\n    def dfs(self, s_node, g_node, visited):\\n        if visited[s_node] != -1:\\n            return\\n        \\n        visited[s_node] = g_node\\n        for e_node in self.adj[s_node]:\\n            if(visited[e_node] == -1):\\n                self.dfs(e_node, g_node, visited)\\n    \\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        indeg = {i:0 for i in range(1, n+1)}\\n        \\n        for s,e in edges:\\n            self.adj[s].append(e)\\n            self.adj[e].append(s)\\n        for e in self.adj:\\n            indeg[e] = len(self.adj[e])\\n        \\n        visited = [-1] * (n+1)\\n        for i in range(1,n+1):\\n            if visited[i] == -1:\\n                self.dfs(i, i, visited)\\n        \\n        connected_components = defaultdict(list)\\n        for idx, node in enumerate(visited[1:], 1):\\n            connected_components[node].append(idx)\\n\\n        ans = 0\\n        valid_ans = True\\n        for _, components in connected_components.items():\\n            count_dict = {s:-1 for s in components}\\n            val = 0\\n            min_indegree = min([indeg[node] for node in components])\\n            for node in components:\\n                if indeg[node] > min_indegree + 1:\\n                    continue\\n                count_dict[node] = self.getSplitCount(node)\\n            if max(count_dict.values()) == -1:\\n                valid_ans = False\\n                break\\n            ans += max(count_dict.values())\\n        if not valid_ans:\\n            return -1\\n        return ans\\n        \\n```"
                    },
                    {
                        "username": "thongds",
                        "content": "The example 2 should be one group right ? Because if I say node 1,2,3 belong group 1, all conditions will be satisfied "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Condition 2 restricts that. If 2 nodes are in the same group and are connected, then y-x will not be 1"
                    },
                    {
                        "username": "_SID_",
                        "content": "In how many groups can we group the below graph when all nodes are connected to the same node?\\n\\nex:\\n1 - - 2\\n1 - - 3\\n1 - - 4\\n1 - - 5"
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor67](/Tudor67) Oh that makes sense thank you for your detailed explanation <3 ."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@sandrikosxila](/sandrikosxila) You have a graph with N = 92 nodes and E = 37 edges;\n\n1.) You can create max `3 groups` with all the nodes from the input edges;\nHow? Node 29 will be in Group 2, and the remaining nodes connected to node 29 will be distributed to Group 1 and Group 3.\n\n2.) Number of nodes (N = 92 nodes) > number of edges (E = 37 edges);\nYou have some isolated nodes: Number of nodes (N = 92) - unique nodes from the input edges (37 + 1) = 92 - 38 = 54.\nSo, you have 54 isolated nodes => You can create `another 54 groups`.\nHow? Each isolated node can create a new group.\n\nThe final answer is **57 groups** (`3 groups` from input edges + `54 groups` from isolated nodes)."
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor Buzu](/Tudor67) [@Amir Hasan](/log0i) then why is the answer `57` in this case:\\n```\\nn = 92\\nedges = [[67,29],[13,29],[77,29],[36,29],[82,29],[54,29],[57,29],[53,29],[68,29],[26,29],[21,29],[46,29],[41,29],[45,29],[56,29],[88,29],[2,29],[7,29],[5,29],[16,29],[37,29],[50,29],[79,29],[91,29],[48,29],[87,29],[25,29],[80,29],[71,29],[9,29],[78,29],[33,29],[4,29],[44,29],[72,29],[65,29],[61,29]]\\n```"
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@Siddarth Reddy](/_SID_) If the number of nodes is `n = 5` and `edges = [[1,2],[1,3],[1,4],[1,5]]` then the maximum number of groups is **m = 3**:\\n\\nGroup 1  ___  Group 2 ___ Group 3\\n2 -------------- 1 ----------- 5\\n3 ---------------|\\n4 ---------------|                        "
                    },
                    {
                        "username": "log0i",
                        "content": "2   |  g1->1 , g2->2,3,4,5    The difference of the groupIDs of the nodes connected by an edge should be 1"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "Can someone help me understand this question? \\n"
                    },
                    {
                        "username": "nonieno",
                        "content": "Why when I submitted my code the 6th time it went through with runtime better than 67% hello?"
                    },
                    {
                        "username": "raggzy",
                        "content": "I am curious if there is something better than O(V*(V+E)), anyone has ideas?"
                    }
                ]
            },
            {
                "id": 1745194,
                "content": [
                    {
                        "username": "saranyamaity2000",
                        "content": "Am I the only one who thought the actual BFS solution won\\'t work after seeing number of edges and forget to see that n is only 500 ?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Why sum up the number of groups of all disconnected graph? The question does not restrict that disconnected nodes should not be in the same group."
                    },
                    {
                        "username": "espadandy",
                        "content": "[@Tudor67](/Tudor67) Thank you so much. I only remember this condition when maximize the path of a sub-graph but forget it when it comes to disconnect parts."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@yandyxu](/espadandy) Problem statement:\n`Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes.`\n\nTo maximize the number of groups (**for all nodes of the input graph**), it is always better to assign disconnected nodes to different groups.\n\nImagine a Graph with 5 isolated nodes (i.e., no edges):\n1.) You can create just one group for all nodes and return 1;\n(but this is not the maximum number of groups for the given graph);\n2.) Or you can create 5 groups (a group for each isolated node) and return 5;\n(this is the maximum number of groups for the given graph)."
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Am I the only one who got TL in an empty test case?\n55/55 passed.\nwtf?"
                    },
                    {
                        "username": "yjyjyj",
                        "content": "Test cases are not sufficient to identify wrong solution. \\nthis solution will fail this test case, while it could pass submission test.\\n10\\n[[3,5],[4,2],[4,7],[6,8],[2,6],[6,3],[6,1],[1,5],[6,7],[5,9],[9,6],[6,10],[10,4]]\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.adj = defaultdict(list)\\n    \\n    def getSplitCount(self, start):\\n        global_visited = {}\\n        level_nodes = [start]\\n        split_count = 0\\n        prev_nodes = set([])\\n        while len(level_nodes) > 0:\\n            split_count += 1\\n            next_level_nodes = []\\n            visited = {}\\n            for s_node in level_nodes:\\n                global_visited[s_node] = True\\n                for e_node in self.adj[s_node]:\\n                    if e_node in global_visited:\\n                        if e_node not in prev_nodes:\\n                            return -1\\n                        else:\\n                            continue\\n                    if e_node not in visited: # and e_node not in global_visited:\\n                        visited[e_node] = True\\n                        next_level_nodes.append(e_node)\\n            prev_nodes = set(level_nodes)\\n            level_nodes = next_level_nodes\\n                    \\n        return split_count\\n    \\n    \\n    def dfs(self, s_node, g_node, visited):\\n        if visited[s_node] != -1:\\n            return\\n        \\n        visited[s_node] = g_node\\n        for e_node in self.adj[s_node]:\\n            if(visited[e_node] == -1):\\n                self.dfs(e_node, g_node, visited)\\n    \\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        indeg = {i:0 for i in range(1, n+1)}\\n        \\n        for s,e in edges:\\n            self.adj[s].append(e)\\n            self.adj[e].append(s)\\n        for e in self.adj:\\n            indeg[e] = len(self.adj[e])\\n        \\n        visited = [-1] * (n+1)\\n        for i in range(1,n+1):\\n            if visited[i] == -1:\\n                self.dfs(i, i, visited)\\n        \\n        connected_components = defaultdict(list)\\n        for idx, node in enumerate(visited[1:], 1):\\n            connected_components[node].append(idx)\\n\\n        ans = 0\\n        valid_ans = True\\n        for _, components in connected_components.items():\\n            count_dict = {s:-1 for s in components}\\n            val = 0\\n            min_indegree = min([indeg[node] for node in components])\\n            for node in components:\\n                if indeg[node] > min_indegree + 1:\\n                    continue\\n                count_dict[node] = self.getSplitCount(node)\\n            if max(count_dict.values()) == -1:\\n                valid_ans = False\\n                break\\n            ans += max(count_dict.values())\\n        if not valid_ans:\\n            return -1\\n        return ans\\n        \\n```"
                    },
                    {
                        "username": "thongds",
                        "content": "The example 2 should be one group right ? Because if I say node 1,2,3 belong group 1, all conditions will be satisfied "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Condition 2 restricts that. If 2 nodes are in the same group and are connected, then y-x will not be 1"
                    },
                    {
                        "username": "_SID_",
                        "content": "In how many groups can we group the below graph when all nodes are connected to the same node?\\n\\nex:\\n1 - - 2\\n1 - - 3\\n1 - - 4\\n1 - - 5"
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor67](/Tudor67) Oh that makes sense thank you for your detailed explanation <3 ."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@sandrikosxila](/sandrikosxila) You have a graph with N = 92 nodes and E = 37 edges;\n\n1.) You can create max `3 groups` with all the nodes from the input edges;\nHow? Node 29 will be in Group 2, and the remaining nodes connected to node 29 will be distributed to Group 1 and Group 3.\n\n2.) Number of nodes (N = 92 nodes) > number of edges (E = 37 edges);\nYou have some isolated nodes: Number of nodes (N = 92) - unique nodes from the input edges (37 + 1) = 92 - 38 = 54.\nSo, you have 54 isolated nodes => You can create `another 54 groups`.\nHow? Each isolated node can create a new group.\n\nThe final answer is **57 groups** (`3 groups` from input edges + `54 groups` from isolated nodes)."
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor Buzu](/Tudor67) [@Amir Hasan](/log0i) then why is the answer `57` in this case:\\n```\\nn = 92\\nedges = [[67,29],[13,29],[77,29],[36,29],[82,29],[54,29],[57,29],[53,29],[68,29],[26,29],[21,29],[46,29],[41,29],[45,29],[56,29],[88,29],[2,29],[7,29],[5,29],[16,29],[37,29],[50,29],[79,29],[91,29],[48,29],[87,29],[25,29],[80,29],[71,29],[9,29],[78,29],[33,29],[4,29],[44,29],[72,29],[65,29],[61,29]]\\n```"
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@Siddarth Reddy](/_SID_) If the number of nodes is `n = 5` and `edges = [[1,2],[1,3],[1,4],[1,5]]` then the maximum number of groups is **m = 3**:\\n\\nGroup 1  ___  Group 2 ___ Group 3\\n2 -------------- 1 ----------- 5\\n3 ---------------|\\n4 ---------------|                        "
                    },
                    {
                        "username": "log0i",
                        "content": "2   |  g1->1 , g2->2,3,4,5    The difference of the groupIDs of the nodes connected by an edge should be 1"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "Can someone help me understand this question? \\n"
                    },
                    {
                        "username": "nonieno",
                        "content": "Why when I submitted my code the 6th time it went through with runtime better than 67% hello?"
                    },
                    {
                        "username": "raggzy",
                        "content": "I am curious if there is something better than O(V*(V+E)), anyone has ideas?"
                    }
                ]
            },
            {
                "id": 1711943,
                "content": [
                    {
                        "username": "saranyamaity2000",
                        "content": "Am I the only one who thought the actual BFS solution won\\'t work after seeing number of edges and forget to see that n is only 500 ?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Why sum up the number of groups of all disconnected graph? The question does not restrict that disconnected nodes should not be in the same group."
                    },
                    {
                        "username": "espadandy",
                        "content": "[@Tudor67](/Tudor67) Thank you so much. I only remember this condition when maximize the path of a sub-graph but forget it when it comes to disconnect parts."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@yandyxu](/espadandy) Problem statement:\n`Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes.`\n\nTo maximize the number of groups (**for all nodes of the input graph**), it is always better to assign disconnected nodes to different groups.\n\nImagine a Graph with 5 isolated nodes (i.e., no edges):\n1.) You can create just one group for all nodes and return 1;\n(but this is not the maximum number of groups for the given graph);\n2.) Or you can create 5 groups (a group for each isolated node) and return 5;\n(this is the maximum number of groups for the given graph)."
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Am I the only one who got TL in an empty test case?\n55/55 passed.\nwtf?"
                    },
                    {
                        "username": "yjyjyj",
                        "content": "Test cases are not sufficient to identify wrong solution. \\nthis solution will fail this test case, while it could pass submission test.\\n10\\n[[3,5],[4,2],[4,7],[6,8],[2,6],[6,3],[6,1],[1,5],[6,7],[5,9],[9,6],[6,10],[10,4]]\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.adj = defaultdict(list)\\n    \\n    def getSplitCount(self, start):\\n        global_visited = {}\\n        level_nodes = [start]\\n        split_count = 0\\n        prev_nodes = set([])\\n        while len(level_nodes) > 0:\\n            split_count += 1\\n            next_level_nodes = []\\n            visited = {}\\n            for s_node in level_nodes:\\n                global_visited[s_node] = True\\n                for e_node in self.adj[s_node]:\\n                    if e_node in global_visited:\\n                        if e_node not in prev_nodes:\\n                            return -1\\n                        else:\\n                            continue\\n                    if e_node not in visited: # and e_node not in global_visited:\\n                        visited[e_node] = True\\n                        next_level_nodes.append(e_node)\\n            prev_nodes = set(level_nodes)\\n            level_nodes = next_level_nodes\\n                    \\n        return split_count\\n    \\n    \\n    def dfs(self, s_node, g_node, visited):\\n        if visited[s_node] != -1:\\n            return\\n        \\n        visited[s_node] = g_node\\n        for e_node in self.adj[s_node]:\\n            if(visited[e_node] == -1):\\n                self.dfs(e_node, g_node, visited)\\n    \\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        indeg = {i:0 for i in range(1, n+1)}\\n        \\n        for s,e in edges:\\n            self.adj[s].append(e)\\n            self.adj[e].append(s)\\n        for e in self.adj:\\n            indeg[e] = len(self.adj[e])\\n        \\n        visited = [-1] * (n+1)\\n        for i in range(1,n+1):\\n            if visited[i] == -1:\\n                self.dfs(i, i, visited)\\n        \\n        connected_components = defaultdict(list)\\n        for idx, node in enumerate(visited[1:], 1):\\n            connected_components[node].append(idx)\\n\\n        ans = 0\\n        valid_ans = True\\n        for _, components in connected_components.items():\\n            count_dict = {s:-1 for s in components}\\n            val = 0\\n            min_indegree = min([indeg[node] for node in components])\\n            for node in components:\\n                if indeg[node] > min_indegree + 1:\\n                    continue\\n                count_dict[node] = self.getSplitCount(node)\\n            if max(count_dict.values()) == -1:\\n                valid_ans = False\\n                break\\n            ans += max(count_dict.values())\\n        if not valid_ans:\\n            return -1\\n        return ans\\n        \\n```"
                    },
                    {
                        "username": "thongds",
                        "content": "The example 2 should be one group right ? Because if I say node 1,2,3 belong group 1, all conditions will be satisfied "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Condition 2 restricts that. If 2 nodes are in the same group and are connected, then y-x will not be 1"
                    },
                    {
                        "username": "_SID_",
                        "content": "In how many groups can we group the below graph when all nodes are connected to the same node?\\n\\nex:\\n1 - - 2\\n1 - - 3\\n1 - - 4\\n1 - - 5"
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor67](/Tudor67) Oh that makes sense thank you for your detailed explanation <3 ."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@sandrikosxila](/sandrikosxila) You have a graph with N = 92 nodes and E = 37 edges;\n\n1.) You can create max `3 groups` with all the nodes from the input edges;\nHow? Node 29 will be in Group 2, and the remaining nodes connected to node 29 will be distributed to Group 1 and Group 3.\n\n2.) Number of nodes (N = 92 nodes) > number of edges (E = 37 edges);\nYou have some isolated nodes: Number of nodes (N = 92) - unique nodes from the input edges (37 + 1) = 92 - 38 = 54.\nSo, you have 54 isolated nodes => You can create `another 54 groups`.\nHow? Each isolated node can create a new group.\n\nThe final answer is **57 groups** (`3 groups` from input edges + `54 groups` from isolated nodes)."
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor Buzu](/Tudor67) [@Amir Hasan](/log0i) then why is the answer `57` in this case:\\n```\\nn = 92\\nedges = [[67,29],[13,29],[77,29],[36,29],[82,29],[54,29],[57,29],[53,29],[68,29],[26,29],[21,29],[46,29],[41,29],[45,29],[56,29],[88,29],[2,29],[7,29],[5,29],[16,29],[37,29],[50,29],[79,29],[91,29],[48,29],[87,29],[25,29],[80,29],[71,29],[9,29],[78,29],[33,29],[4,29],[44,29],[72,29],[65,29],[61,29]]\\n```"
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@Siddarth Reddy](/_SID_) If the number of nodes is `n = 5` and `edges = [[1,2],[1,3],[1,4],[1,5]]` then the maximum number of groups is **m = 3**:\\n\\nGroup 1  ___  Group 2 ___ Group 3\\n2 -------------- 1 ----------- 5\\n3 ---------------|\\n4 ---------------|                        "
                    },
                    {
                        "username": "log0i",
                        "content": "2   |  g1->1 , g2->2,3,4,5    The difference of the groupIDs of the nodes connected by an edge should be 1"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "Can someone help me understand this question? \\n"
                    },
                    {
                        "username": "nonieno",
                        "content": "Why when I submitted my code the 6th time it went through with runtime better than 67% hello?"
                    },
                    {
                        "username": "raggzy",
                        "content": "I am curious if there is something better than O(V*(V+E)), anyone has ideas?"
                    }
                ]
            },
            {
                "id": 1711203,
                "content": [
                    {
                        "username": "saranyamaity2000",
                        "content": "Am I the only one who thought the actual BFS solution won\\'t work after seeing number of edges and forget to see that n is only 500 ?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Why sum up the number of groups of all disconnected graph? The question does not restrict that disconnected nodes should not be in the same group."
                    },
                    {
                        "username": "espadandy",
                        "content": "[@Tudor67](/Tudor67) Thank you so much. I only remember this condition when maximize the path of a sub-graph but forget it when it comes to disconnect parts."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@yandyxu](/espadandy) Problem statement:\n`Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes.`\n\nTo maximize the number of groups (**for all nodes of the input graph**), it is always better to assign disconnected nodes to different groups.\n\nImagine a Graph with 5 isolated nodes (i.e., no edges):\n1.) You can create just one group for all nodes and return 1;\n(but this is not the maximum number of groups for the given graph);\n2.) Or you can create 5 groups (a group for each isolated node) and return 5;\n(this is the maximum number of groups for the given graph)."
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Am I the only one who got TL in an empty test case?\n55/55 passed.\nwtf?"
                    },
                    {
                        "username": "yjyjyj",
                        "content": "Test cases are not sufficient to identify wrong solution. \\nthis solution will fail this test case, while it could pass submission test.\\n10\\n[[3,5],[4,2],[4,7],[6,8],[2,6],[6,3],[6,1],[1,5],[6,7],[5,9],[9,6],[6,10],[10,4]]\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.adj = defaultdict(list)\\n    \\n    def getSplitCount(self, start):\\n        global_visited = {}\\n        level_nodes = [start]\\n        split_count = 0\\n        prev_nodes = set([])\\n        while len(level_nodes) > 0:\\n            split_count += 1\\n            next_level_nodes = []\\n            visited = {}\\n            for s_node in level_nodes:\\n                global_visited[s_node] = True\\n                for e_node in self.adj[s_node]:\\n                    if e_node in global_visited:\\n                        if e_node not in prev_nodes:\\n                            return -1\\n                        else:\\n                            continue\\n                    if e_node not in visited: # and e_node not in global_visited:\\n                        visited[e_node] = True\\n                        next_level_nodes.append(e_node)\\n            prev_nodes = set(level_nodes)\\n            level_nodes = next_level_nodes\\n                    \\n        return split_count\\n    \\n    \\n    def dfs(self, s_node, g_node, visited):\\n        if visited[s_node] != -1:\\n            return\\n        \\n        visited[s_node] = g_node\\n        for e_node in self.adj[s_node]:\\n            if(visited[e_node] == -1):\\n                self.dfs(e_node, g_node, visited)\\n    \\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        indeg = {i:0 for i in range(1, n+1)}\\n        \\n        for s,e in edges:\\n            self.adj[s].append(e)\\n            self.adj[e].append(s)\\n        for e in self.adj:\\n            indeg[e] = len(self.adj[e])\\n        \\n        visited = [-1] * (n+1)\\n        for i in range(1,n+1):\\n            if visited[i] == -1:\\n                self.dfs(i, i, visited)\\n        \\n        connected_components = defaultdict(list)\\n        for idx, node in enumerate(visited[1:], 1):\\n            connected_components[node].append(idx)\\n\\n        ans = 0\\n        valid_ans = True\\n        for _, components in connected_components.items():\\n            count_dict = {s:-1 for s in components}\\n            val = 0\\n            min_indegree = min([indeg[node] for node in components])\\n            for node in components:\\n                if indeg[node] > min_indegree + 1:\\n                    continue\\n                count_dict[node] = self.getSplitCount(node)\\n            if max(count_dict.values()) == -1:\\n                valid_ans = False\\n                break\\n            ans += max(count_dict.values())\\n        if not valid_ans:\\n            return -1\\n        return ans\\n        \\n```"
                    },
                    {
                        "username": "thongds",
                        "content": "The example 2 should be one group right ? Because if I say node 1,2,3 belong group 1, all conditions will be satisfied "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Condition 2 restricts that. If 2 nodes are in the same group and are connected, then y-x will not be 1"
                    },
                    {
                        "username": "_SID_",
                        "content": "In how many groups can we group the below graph when all nodes are connected to the same node?\\n\\nex:\\n1 - - 2\\n1 - - 3\\n1 - - 4\\n1 - - 5"
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor67](/Tudor67) Oh that makes sense thank you for your detailed explanation <3 ."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@sandrikosxila](/sandrikosxila) You have a graph with N = 92 nodes and E = 37 edges;\n\n1.) You can create max `3 groups` with all the nodes from the input edges;\nHow? Node 29 will be in Group 2, and the remaining nodes connected to node 29 will be distributed to Group 1 and Group 3.\n\n2.) Number of nodes (N = 92 nodes) > number of edges (E = 37 edges);\nYou have some isolated nodes: Number of nodes (N = 92) - unique nodes from the input edges (37 + 1) = 92 - 38 = 54.\nSo, you have 54 isolated nodes => You can create `another 54 groups`.\nHow? Each isolated node can create a new group.\n\nThe final answer is **57 groups** (`3 groups` from input edges + `54 groups` from isolated nodes)."
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor Buzu](/Tudor67) [@Amir Hasan](/log0i) then why is the answer `57` in this case:\\n```\\nn = 92\\nedges = [[67,29],[13,29],[77,29],[36,29],[82,29],[54,29],[57,29],[53,29],[68,29],[26,29],[21,29],[46,29],[41,29],[45,29],[56,29],[88,29],[2,29],[7,29],[5,29],[16,29],[37,29],[50,29],[79,29],[91,29],[48,29],[87,29],[25,29],[80,29],[71,29],[9,29],[78,29],[33,29],[4,29],[44,29],[72,29],[65,29],[61,29]]\\n```"
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@Siddarth Reddy](/_SID_) If the number of nodes is `n = 5` and `edges = [[1,2],[1,3],[1,4],[1,5]]` then the maximum number of groups is **m = 3**:\\n\\nGroup 1  ___  Group 2 ___ Group 3\\n2 -------------- 1 ----------- 5\\n3 ---------------|\\n4 ---------------|                        "
                    },
                    {
                        "username": "log0i",
                        "content": "2   |  g1->1 , g2->2,3,4,5    The difference of the groupIDs of the nodes connected by an edge should be 1"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "Can someone help me understand this question? \\n"
                    },
                    {
                        "username": "nonieno",
                        "content": "Why when I submitted my code the 6th time it went through with runtime better than 67% hello?"
                    },
                    {
                        "username": "raggzy",
                        "content": "I am curious if there is something better than O(V*(V+E)), anyone has ideas?"
                    }
                ]
            },
            {
                "id": 1710975,
                "content": [
                    {
                        "username": "saranyamaity2000",
                        "content": "Am I the only one who thought the actual BFS solution won\\'t work after seeing number of edges and forget to see that n is only 500 ?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Why sum up the number of groups of all disconnected graph? The question does not restrict that disconnected nodes should not be in the same group."
                    },
                    {
                        "username": "espadandy",
                        "content": "[@Tudor67](/Tudor67) Thank you so much. I only remember this condition when maximize the path of a sub-graph but forget it when it comes to disconnect parts."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@yandyxu](/espadandy) Problem statement:\n`Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes.`\n\nTo maximize the number of groups (**for all nodes of the input graph**), it is always better to assign disconnected nodes to different groups.\n\nImagine a Graph with 5 isolated nodes (i.e., no edges):\n1.) You can create just one group for all nodes and return 1;\n(but this is not the maximum number of groups for the given graph);\n2.) Or you can create 5 groups (a group for each isolated node) and return 5;\n(this is the maximum number of groups for the given graph)."
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Am I the only one who got TL in an empty test case?\n55/55 passed.\nwtf?"
                    },
                    {
                        "username": "yjyjyj",
                        "content": "Test cases are not sufficient to identify wrong solution. \\nthis solution will fail this test case, while it could pass submission test.\\n10\\n[[3,5],[4,2],[4,7],[6,8],[2,6],[6,3],[6,1],[1,5],[6,7],[5,9],[9,6],[6,10],[10,4]]\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.adj = defaultdict(list)\\n    \\n    def getSplitCount(self, start):\\n        global_visited = {}\\n        level_nodes = [start]\\n        split_count = 0\\n        prev_nodes = set([])\\n        while len(level_nodes) > 0:\\n            split_count += 1\\n            next_level_nodes = []\\n            visited = {}\\n            for s_node in level_nodes:\\n                global_visited[s_node] = True\\n                for e_node in self.adj[s_node]:\\n                    if e_node in global_visited:\\n                        if e_node not in prev_nodes:\\n                            return -1\\n                        else:\\n                            continue\\n                    if e_node not in visited: # and e_node not in global_visited:\\n                        visited[e_node] = True\\n                        next_level_nodes.append(e_node)\\n            prev_nodes = set(level_nodes)\\n            level_nodes = next_level_nodes\\n                    \\n        return split_count\\n    \\n    \\n    def dfs(self, s_node, g_node, visited):\\n        if visited[s_node] != -1:\\n            return\\n        \\n        visited[s_node] = g_node\\n        for e_node in self.adj[s_node]:\\n            if(visited[e_node] == -1):\\n                self.dfs(e_node, g_node, visited)\\n    \\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        indeg = {i:0 for i in range(1, n+1)}\\n        \\n        for s,e in edges:\\n            self.adj[s].append(e)\\n            self.adj[e].append(s)\\n        for e in self.adj:\\n            indeg[e] = len(self.adj[e])\\n        \\n        visited = [-1] * (n+1)\\n        for i in range(1,n+1):\\n            if visited[i] == -1:\\n                self.dfs(i, i, visited)\\n        \\n        connected_components = defaultdict(list)\\n        for idx, node in enumerate(visited[1:], 1):\\n            connected_components[node].append(idx)\\n\\n        ans = 0\\n        valid_ans = True\\n        for _, components in connected_components.items():\\n            count_dict = {s:-1 for s in components}\\n            val = 0\\n            min_indegree = min([indeg[node] for node in components])\\n            for node in components:\\n                if indeg[node] > min_indegree + 1:\\n                    continue\\n                count_dict[node] = self.getSplitCount(node)\\n            if max(count_dict.values()) == -1:\\n                valid_ans = False\\n                break\\n            ans += max(count_dict.values())\\n        if not valid_ans:\\n            return -1\\n        return ans\\n        \\n```"
                    },
                    {
                        "username": "thongds",
                        "content": "The example 2 should be one group right ? Because if I say node 1,2,3 belong group 1, all conditions will be satisfied "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Condition 2 restricts that. If 2 nodes are in the same group and are connected, then y-x will not be 1"
                    },
                    {
                        "username": "_SID_",
                        "content": "In how many groups can we group the below graph when all nodes are connected to the same node?\\n\\nex:\\n1 - - 2\\n1 - - 3\\n1 - - 4\\n1 - - 5"
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor67](/Tudor67) Oh that makes sense thank you for your detailed explanation <3 ."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@sandrikosxila](/sandrikosxila) You have a graph with N = 92 nodes and E = 37 edges;\n\n1.) You can create max `3 groups` with all the nodes from the input edges;\nHow? Node 29 will be in Group 2, and the remaining nodes connected to node 29 will be distributed to Group 1 and Group 3.\n\n2.) Number of nodes (N = 92 nodes) > number of edges (E = 37 edges);\nYou have some isolated nodes: Number of nodes (N = 92) - unique nodes from the input edges (37 + 1) = 92 - 38 = 54.\nSo, you have 54 isolated nodes => You can create `another 54 groups`.\nHow? Each isolated node can create a new group.\n\nThe final answer is **57 groups** (`3 groups` from input edges + `54 groups` from isolated nodes)."
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor Buzu](/Tudor67) [@Amir Hasan](/log0i) then why is the answer `57` in this case:\\n```\\nn = 92\\nedges = [[67,29],[13,29],[77,29],[36,29],[82,29],[54,29],[57,29],[53,29],[68,29],[26,29],[21,29],[46,29],[41,29],[45,29],[56,29],[88,29],[2,29],[7,29],[5,29],[16,29],[37,29],[50,29],[79,29],[91,29],[48,29],[87,29],[25,29],[80,29],[71,29],[9,29],[78,29],[33,29],[4,29],[44,29],[72,29],[65,29],[61,29]]\\n```"
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@Siddarth Reddy](/_SID_) If the number of nodes is `n = 5` and `edges = [[1,2],[1,3],[1,4],[1,5]]` then the maximum number of groups is **m = 3**:\\n\\nGroup 1  ___  Group 2 ___ Group 3\\n2 -------------- 1 ----------- 5\\n3 ---------------|\\n4 ---------------|                        "
                    },
                    {
                        "username": "log0i",
                        "content": "2   |  g1->1 , g2->2,3,4,5    The difference of the groupIDs of the nodes connected by an edge should be 1"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "Can someone help me understand this question? \\n"
                    },
                    {
                        "username": "nonieno",
                        "content": "Why when I submitted my code the 6th time it went through with runtime better than 67% hello?"
                    },
                    {
                        "username": "raggzy",
                        "content": "I am curious if there is something better than O(V*(V+E)), anyone has ideas?"
                    }
                ]
            },
            {
                "id": 1706701,
                "content": [
                    {
                        "username": "saranyamaity2000",
                        "content": "Am I the only one who thought the actual BFS solution won\\'t work after seeing number of edges and forget to see that n is only 500 ?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Why sum up the number of groups of all disconnected graph? The question does not restrict that disconnected nodes should not be in the same group."
                    },
                    {
                        "username": "espadandy",
                        "content": "[@Tudor67](/Tudor67) Thank you so much. I only remember this condition when maximize the path of a sub-graph but forget it when it comes to disconnect parts."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@yandyxu](/espadandy) Problem statement:\n`Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes.`\n\nTo maximize the number of groups (**for all nodes of the input graph**), it is always better to assign disconnected nodes to different groups.\n\nImagine a Graph with 5 isolated nodes (i.e., no edges):\n1.) You can create just one group for all nodes and return 1;\n(but this is not the maximum number of groups for the given graph);\n2.) Or you can create 5 groups (a group for each isolated node) and return 5;\n(this is the maximum number of groups for the given graph)."
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Am I the only one who got TL in an empty test case?\n55/55 passed.\nwtf?"
                    },
                    {
                        "username": "yjyjyj",
                        "content": "Test cases are not sufficient to identify wrong solution. \\nthis solution will fail this test case, while it could pass submission test.\\n10\\n[[3,5],[4,2],[4,7],[6,8],[2,6],[6,3],[6,1],[1,5],[6,7],[5,9],[9,6],[6,10],[10,4]]\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.adj = defaultdict(list)\\n    \\n    def getSplitCount(self, start):\\n        global_visited = {}\\n        level_nodes = [start]\\n        split_count = 0\\n        prev_nodes = set([])\\n        while len(level_nodes) > 0:\\n            split_count += 1\\n            next_level_nodes = []\\n            visited = {}\\n            for s_node in level_nodes:\\n                global_visited[s_node] = True\\n                for e_node in self.adj[s_node]:\\n                    if e_node in global_visited:\\n                        if e_node not in prev_nodes:\\n                            return -1\\n                        else:\\n                            continue\\n                    if e_node not in visited: # and e_node not in global_visited:\\n                        visited[e_node] = True\\n                        next_level_nodes.append(e_node)\\n            prev_nodes = set(level_nodes)\\n            level_nodes = next_level_nodes\\n                    \\n        return split_count\\n    \\n    \\n    def dfs(self, s_node, g_node, visited):\\n        if visited[s_node] != -1:\\n            return\\n        \\n        visited[s_node] = g_node\\n        for e_node in self.adj[s_node]:\\n            if(visited[e_node] == -1):\\n                self.dfs(e_node, g_node, visited)\\n    \\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        indeg = {i:0 for i in range(1, n+1)}\\n        \\n        for s,e in edges:\\n            self.adj[s].append(e)\\n            self.adj[e].append(s)\\n        for e in self.adj:\\n            indeg[e] = len(self.adj[e])\\n        \\n        visited = [-1] * (n+1)\\n        for i in range(1,n+1):\\n            if visited[i] == -1:\\n                self.dfs(i, i, visited)\\n        \\n        connected_components = defaultdict(list)\\n        for idx, node in enumerate(visited[1:], 1):\\n            connected_components[node].append(idx)\\n\\n        ans = 0\\n        valid_ans = True\\n        for _, components in connected_components.items():\\n            count_dict = {s:-1 for s in components}\\n            val = 0\\n            min_indegree = min([indeg[node] for node in components])\\n            for node in components:\\n                if indeg[node] > min_indegree + 1:\\n                    continue\\n                count_dict[node] = self.getSplitCount(node)\\n            if max(count_dict.values()) == -1:\\n                valid_ans = False\\n                break\\n            ans += max(count_dict.values())\\n        if not valid_ans:\\n            return -1\\n        return ans\\n        \\n```"
                    },
                    {
                        "username": "thongds",
                        "content": "The example 2 should be one group right ? Because if I say node 1,2,3 belong group 1, all conditions will be satisfied "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Condition 2 restricts that. If 2 nodes are in the same group and are connected, then y-x will not be 1"
                    },
                    {
                        "username": "_SID_",
                        "content": "In how many groups can we group the below graph when all nodes are connected to the same node?\\n\\nex:\\n1 - - 2\\n1 - - 3\\n1 - - 4\\n1 - - 5"
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor67](/Tudor67) Oh that makes sense thank you for your detailed explanation <3 ."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@sandrikosxila](/sandrikosxila) You have a graph with N = 92 nodes and E = 37 edges;\n\n1.) You can create max `3 groups` with all the nodes from the input edges;\nHow? Node 29 will be in Group 2, and the remaining nodes connected to node 29 will be distributed to Group 1 and Group 3.\n\n2.) Number of nodes (N = 92 nodes) > number of edges (E = 37 edges);\nYou have some isolated nodes: Number of nodes (N = 92) - unique nodes from the input edges (37 + 1) = 92 - 38 = 54.\nSo, you have 54 isolated nodes => You can create `another 54 groups`.\nHow? Each isolated node can create a new group.\n\nThe final answer is **57 groups** (`3 groups` from input edges + `54 groups` from isolated nodes)."
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor Buzu](/Tudor67) [@Amir Hasan](/log0i) then why is the answer `57` in this case:\\n```\\nn = 92\\nedges = [[67,29],[13,29],[77,29],[36,29],[82,29],[54,29],[57,29],[53,29],[68,29],[26,29],[21,29],[46,29],[41,29],[45,29],[56,29],[88,29],[2,29],[7,29],[5,29],[16,29],[37,29],[50,29],[79,29],[91,29],[48,29],[87,29],[25,29],[80,29],[71,29],[9,29],[78,29],[33,29],[4,29],[44,29],[72,29],[65,29],[61,29]]\\n```"
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@Siddarth Reddy](/_SID_) If the number of nodes is `n = 5` and `edges = [[1,2],[1,3],[1,4],[1,5]]` then the maximum number of groups is **m = 3**:\\n\\nGroup 1  ___  Group 2 ___ Group 3\\n2 -------------- 1 ----------- 5\\n3 ---------------|\\n4 ---------------|                        "
                    },
                    {
                        "username": "log0i",
                        "content": "2   |  g1->1 , g2->2,3,4,5    The difference of the groupIDs of the nodes connected by an edge should be 1"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "Can someone help me understand this question? \\n"
                    },
                    {
                        "username": "nonieno",
                        "content": "Why when I submitted my code the 6th time it went through with runtime better than 67% hello?"
                    },
                    {
                        "username": "raggzy",
                        "content": "I am curious if there is something better than O(V*(V+E)), anyone has ideas?"
                    }
                ]
            },
            {
                "id": 1704990,
                "content": [
                    {
                        "username": "saranyamaity2000",
                        "content": "Am I the only one who thought the actual BFS solution won\\'t work after seeing number of edges and forget to see that n is only 500 ?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Why sum up the number of groups of all disconnected graph? The question does not restrict that disconnected nodes should not be in the same group."
                    },
                    {
                        "username": "espadandy",
                        "content": "[@Tudor67](/Tudor67) Thank you so much. I only remember this condition when maximize the path of a sub-graph but forget it when it comes to disconnect parts."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@yandyxu](/espadandy) Problem statement:\n`Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes.`\n\nTo maximize the number of groups (**for all nodes of the input graph**), it is always better to assign disconnected nodes to different groups.\n\nImagine a Graph with 5 isolated nodes (i.e., no edges):\n1.) You can create just one group for all nodes and return 1;\n(but this is not the maximum number of groups for the given graph);\n2.) Or you can create 5 groups (a group for each isolated node) and return 5;\n(this is the maximum number of groups for the given graph)."
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Am I the only one who got TL in an empty test case?\n55/55 passed.\nwtf?"
                    },
                    {
                        "username": "yjyjyj",
                        "content": "Test cases are not sufficient to identify wrong solution. \\nthis solution will fail this test case, while it could pass submission test.\\n10\\n[[3,5],[4,2],[4,7],[6,8],[2,6],[6,3],[6,1],[1,5],[6,7],[5,9],[9,6],[6,10],[10,4]]\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.adj = defaultdict(list)\\n    \\n    def getSplitCount(self, start):\\n        global_visited = {}\\n        level_nodes = [start]\\n        split_count = 0\\n        prev_nodes = set([])\\n        while len(level_nodes) > 0:\\n            split_count += 1\\n            next_level_nodes = []\\n            visited = {}\\n            for s_node in level_nodes:\\n                global_visited[s_node] = True\\n                for e_node in self.adj[s_node]:\\n                    if e_node in global_visited:\\n                        if e_node not in prev_nodes:\\n                            return -1\\n                        else:\\n                            continue\\n                    if e_node not in visited: # and e_node not in global_visited:\\n                        visited[e_node] = True\\n                        next_level_nodes.append(e_node)\\n            prev_nodes = set(level_nodes)\\n            level_nodes = next_level_nodes\\n                    \\n        return split_count\\n    \\n    \\n    def dfs(self, s_node, g_node, visited):\\n        if visited[s_node] != -1:\\n            return\\n        \\n        visited[s_node] = g_node\\n        for e_node in self.adj[s_node]:\\n            if(visited[e_node] == -1):\\n                self.dfs(e_node, g_node, visited)\\n    \\n    \\n    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:\\n        indeg = {i:0 for i in range(1, n+1)}\\n        \\n        for s,e in edges:\\n            self.adj[s].append(e)\\n            self.adj[e].append(s)\\n        for e in self.adj:\\n            indeg[e] = len(self.adj[e])\\n        \\n        visited = [-1] * (n+1)\\n        for i in range(1,n+1):\\n            if visited[i] == -1:\\n                self.dfs(i, i, visited)\\n        \\n        connected_components = defaultdict(list)\\n        for idx, node in enumerate(visited[1:], 1):\\n            connected_components[node].append(idx)\\n\\n        ans = 0\\n        valid_ans = True\\n        for _, components in connected_components.items():\\n            count_dict = {s:-1 for s in components}\\n            val = 0\\n            min_indegree = min([indeg[node] for node in components])\\n            for node in components:\\n                if indeg[node] > min_indegree + 1:\\n                    continue\\n                count_dict[node] = self.getSplitCount(node)\\n            if max(count_dict.values()) == -1:\\n                valid_ans = False\\n                break\\n            ans += max(count_dict.values())\\n        if not valid_ans:\\n            return -1\\n        return ans\\n        \\n```"
                    },
                    {
                        "username": "thongds",
                        "content": "The example 2 should be one group right ? Because if I say node 1,2,3 belong group 1, all conditions will be satisfied "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Condition 2 restricts that. If 2 nodes are in the same group and are connected, then y-x will not be 1"
                    },
                    {
                        "username": "_SID_",
                        "content": "In how many groups can we group the below graph when all nodes are connected to the same node?\\n\\nex:\\n1 - - 2\\n1 - - 3\\n1 - - 4\\n1 - - 5"
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor67](/Tudor67) Oh that makes sense thank you for your detailed explanation <3 ."
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@sandrikosxila](/sandrikosxila) You have a graph with N = 92 nodes and E = 37 edges;\n\n1.) You can create max `3 groups` with all the nodes from the input edges;\nHow? Node 29 will be in Group 2, and the remaining nodes connected to node 29 will be distributed to Group 1 and Group 3.\n\n2.) Number of nodes (N = 92 nodes) > number of edges (E = 37 edges);\nYou have some isolated nodes: Number of nodes (N = 92) - unique nodes from the input edges (37 + 1) = 92 - 38 = 54.\nSo, you have 54 isolated nodes => You can create `another 54 groups`.\nHow? Each isolated node can create a new group.\n\nThe final answer is **57 groups** (`3 groups` from input edges + `54 groups` from isolated nodes)."
                    },
                    {
                        "username": "sandrikosxila",
                        "content": "[@Tudor Buzu](/Tudor67) [@Amir Hasan](/log0i) then why is the answer `57` in this case:\\n```\\nn = 92\\nedges = [[67,29],[13,29],[77,29],[36,29],[82,29],[54,29],[57,29],[53,29],[68,29],[26,29],[21,29],[46,29],[41,29],[45,29],[56,29],[88,29],[2,29],[7,29],[5,29],[16,29],[37,29],[50,29],[79,29],[91,29],[48,29],[87,29],[25,29],[80,29],[71,29],[9,29],[78,29],[33,29],[4,29],[44,29],[72,29],[65,29],[61,29]]\\n```"
                    },
                    {
                        "username": "Tudor67",
                        "content": "[@Siddarth Reddy](/_SID_) If the number of nodes is `n = 5` and `edges = [[1,2],[1,3],[1,4],[1,5]]` then the maximum number of groups is **m = 3**:\\n\\nGroup 1  ___  Group 2 ___ Group 3\\n2 -------------- 1 ----------- 5\\n3 ---------------|\\n4 ---------------|                        "
                    },
                    {
                        "username": "log0i",
                        "content": "2   |  g1->1 , g2->2,3,4,5    The difference of the groupIDs of the nodes connected by an edge should be 1"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "Can someone help me understand this question? \\n"
                    },
                    {
                        "username": "nonieno",
                        "content": "Why when I submitted my code the 6th time it went through with runtime better than 67% hello?"
                    },
                    {
                        "username": "raggzy",
                        "content": "I am curious if there is something better than O(V*(V+E)), anyone has ideas?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Merge Overlapping Events in the Same Hall",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1717011,
                "content": [
                    {
                        "username": "thehawk",
                        "content": "Every time I hit the run button, the page crashes.. "
                    },
                    {
                        "username": "hlin125",
                        "content": " `with recursive cte as (select *, row_number() over (partition by hall_id order by start_day) as rn\\n            from HallEvents),\\na as (select hall_id, start_day, end_day, rn\\n                    from cte\\n                    where rn = 1\\n                    union all\\n                    select cte.hall_id,\\n                    (case when cte.start_day <= a.end_day then a.start_day else cte.start_day end) start_day,\\n                    (case when cte.end_day >= a.end_day then cte.end_day else a.end_day end) end_day, cte.rn\\n                    from cte\\n                    join a\\n                    on cte.rn = a.rn + 1\\n                    and cte.hall_id = a.hall_id)\\nselect hall_id, start_day, max(end_day) end_day\\nfrom a\\ngroup by hall_id, start_day.`"
                    },
                    {
                        "username": "thehawk",
                        "content": "The below is the code generated by ChatGpt. It almost got it correct. I fed ChatGpt with the exact question and example from leetcode.\\n\\nWITH overlapping_events AS (\\n  SELECT\\n    e1.hall_id,\\n    e1.start_day AS start_day,\\n    e1.end_day AS end_day,\\n    e2.start_day AS overlap_start,\\n    e2.end_day AS overlap_end\\n  FROM HallEvents e1\\n  JOIN HallEvents e2 ON e1.hall_id = e2.hall_id\\n    AND e1.start_day <= e2.end_day\\n    AND e1.end_day >= e2.start_day\\n    AND e1.start_day != e2.start_day\\n)\\nSELECT hall_id, MIN(start_day) AS start_day, MAX(end_day) AS end_day\\nFROM overlapping_events\\nGROUP BY hall_id, overlap_start, overlap_end\\n"
                    }
                ]
            },
            {
                "id": 1721721,
                "content": [
                    {
                        "username": "thehawk",
                        "content": "Every time I hit the run button, the page crashes.. "
                    },
                    {
                        "username": "hlin125",
                        "content": " `with recursive cte as (select *, row_number() over (partition by hall_id order by start_day) as rn\\n            from HallEvents),\\na as (select hall_id, start_day, end_day, rn\\n                    from cte\\n                    where rn = 1\\n                    union all\\n                    select cte.hall_id,\\n                    (case when cte.start_day <= a.end_day then a.start_day else cte.start_day end) start_day,\\n                    (case when cte.end_day >= a.end_day then cte.end_day else a.end_day end) end_day, cte.rn\\n                    from cte\\n                    join a\\n                    on cte.rn = a.rn + 1\\n                    and cte.hall_id = a.hall_id)\\nselect hall_id, start_day, max(end_day) end_day\\nfrom a\\ngroup by hall_id, start_day.`"
                    },
                    {
                        "username": "thehawk",
                        "content": "The below is the code generated by ChatGpt. It almost got it correct. I fed ChatGpt with the exact question and example from leetcode.\\n\\nWITH overlapping_events AS (\\n  SELECT\\n    e1.hall_id,\\n    e1.start_day AS start_day,\\n    e1.end_day AS end_day,\\n    e2.start_day AS overlap_start,\\n    e2.end_day AS overlap_end\\n  FROM HallEvents e1\\n  JOIN HallEvents e2 ON e1.hall_id = e2.hall_id\\n    AND e1.start_day <= e2.end_day\\n    AND e1.end_day >= e2.start_day\\n    AND e1.start_day != e2.start_day\\n)\\nSELECT hall_id, MIN(start_day) AS start_day, MAX(end_day) AS end_day\\nFROM overlapping_events\\nGROUP BY hall_id, overlap_start, overlap_end\\n"
                    }
                ]
            },
            {
                "id": 1770740,
                "content": [
                    {
                        "username": "thehawk",
                        "content": "Every time I hit the run button, the page crashes.. "
                    },
                    {
                        "username": "hlin125",
                        "content": " `with recursive cte as (select *, row_number() over (partition by hall_id order by start_day) as rn\\n            from HallEvents),\\na as (select hall_id, start_day, end_day, rn\\n                    from cte\\n                    where rn = 1\\n                    union all\\n                    select cte.hall_id,\\n                    (case when cte.start_day <= a.end_day then a.start_day else cte.start_day end) start_day,\\n                    (case when cte.end_day >= a.end_day then cte.end_day else a.end_day end) end_day, cte.rn\\n                    from cte\\n                    join a\\n                    on cte.rn = a.rn + 1\\n                    and cte.hall_id = a.hall_id)\\nselect hall_id, start_day, max(end_day) end_day\\nfrom a\\ngroup by hall_id, start_day.`"
                    },
                    {
                        "username": "thehawk",
                        "content": "The below is the code generated by ChatGpt. It almost got it correct. I fed ChatGpt with the exact question and example from leetcode.\\n\\nWITH overlapping_events AS (\\n  SELECT\\n    e1.hall_id,\\n    e1.start_day AS start_day,\\n    e1.end_day AS end_day,\\n    e2.start_day AS overlap_start,\\n    e2.end_day AS overlap_end\\n  FROM HallEvents e1\\n  JOIN HallEvents e2 ON e1.hall_id = e2.hall_id\\n    AND e1.start_day <= e2.end_day\\n    AND e1.end_day >= e2.start_day\\n    AND e1.start_day != e2.start_day\\n)\\nSELECT hall_id, MIN(start_day) AS start_day, MAX(end_day) AS end_day\\nFROM overlapping_events\\nGROUP BY hall_id, overlap_start, overlap_end\\n"
                    }
                ]
            }
        ]
    }
]