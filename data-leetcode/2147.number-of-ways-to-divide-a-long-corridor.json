[
    {
        "title": "Number of Ways to Divide a Long Corridor",
        "question_content": "Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.\nOne room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.\nDivide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.\nReturn the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.\n&nbsp;\nExample 1:\n\nInput: corridor = \"SSPPSPS\"\nOutput: 3\nExplanation: There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, each section has exactly two seats.\n\nExample 2:\n\nInput: corridor = \"PPSPSP\"\nOutput: 1\nExplanation: There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats.\n\nExample 3:\n\nInput: corridor = \"S\"\nOutput: 0\nExplanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats.\n\n&nbsp;\nConstraints:\n\n\tn == corridor.length\n\t1 <= n <= 105\n\tcorridor[i] is either 'S' or 'P'.",
        "solutions": [
            {
                "id": 1709704,
                "title": "greedy-solution-c",
                "content": "We need to group two **S** along with some **P** (may be zero as well).\\n\\n- Since we need to divide **S** into group of 2, If the number of **S** is not even return 0.\\n\\nDivide the array of characters into subarrays, such that each subarray has two **S**. \\n\\n![image](https://assets.leetcode.com/users/images/0b93490c-2410-43b4-a2ce-ec8408a3b053_1642865916.276211.png)\\n\\n\\nIn the above figure, the green sections show the subarrays with exactly two **S**.\\n\\nNow, we need to decide for **P**. The **P\\'s** on the left of the first green group and the ones on the right of last green group have no choice than to be included in the respective subarrays. Shown by the arrows.\\n\\nFor the other **P\\'s** in blue section, we need to decide. We need to put a divider in the blue section between every two green sections. Hence, if we have a blue section of length **K** then we have **K + 1** options to put the divider. 4 options for blue section of lenght 3 is shown below.\\n\\n![image](https://assets.leetcode.com/users/images/135aaa85-4f9c-4b97-8878-75c9ac8bdce2_1642865952.0643842.png)\\n\\n\\nSince, all these choices are independent of each other, multiply the number of choices for each blue section to find the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    \\n    int numberOfWays(string corridor) {\\n        vector<int> pos;\\n        for (int i = 0; i < corridor.size(); i++) {\\n            if (corridor[i] == \\'S\\') {\\n                pos.push_back(i);\\n            }\\n        }\\n        \\n        if (pos.size() % 2 || pos.size() == 0)\\n            return 0;\\n        \\n        long long ans = 1;\\n        int prev = pos[1];\\n        for (int i = 2; i < pos.size(); i += 2) {\\n            int length = pos[i] - prev;\\n            ans = (ans * length) % mod;\\n            \\n            prev = pos[i + 1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n- `prev` stores the last index of first green section\\n- `pos[i]` stores the first index of second green section\\n- The difference of above two is the length of blue section plus 1",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    \\n    int numberOfWays(string corridor) {\\n        vector<int> pos;\\n        for (int i = 0; i < corridor.size(); i++) {\\n            if (corridor[i] == \\'S\\') {\\n                pos.push_back(i);\\n            }\\n        }\\n        \\n        if (pos.size() % 2 || pos.size() == 0)\\n            return 0;\\n        \\n        long long ans = 1;\\n        int prev = pos[1];\\n        for (int i = 2; i < pos.size(); i += 2) {\\n            int length = pos[i] - prev;\\n            ans = (ans * length) % mod;\\n            \\n            prev = pos[i + 1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709725,
                "title": "java-c-python-two-solutions-with-explanation",
                "content": "# **Solution 1: Combination**\\nAssume `a[i]` is the index of `i`th seat,\\nthere are `a[i+1] - a[i]` ways to put a divider between `i`th and `i+1`th seats.\\nWe only needs to calculate the produit of all these `a[i+1] - a[i]`.\\n\\nIf the number of seat is odd or is less than 2, then no way to divide the corridor.\\n\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**C++**\\n```cpp [tag-C++]\\n    int numberOfWays(string s) {\\n        long res = 1, j = 0, k = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'S\\') {\\n                if (++k > 2 && k % 2 == 1)\\n                    res = res * (i - j) % mod;\\n                j = i;\\n            }\\n        }\\n        return k % 2 == 0 && k > 0 ? res : 0;\\n    }\\n```\\n\\n**Java**\\n```java [tag-Java]\\n    public int numberOfWays(String s) {\\n        long res = 1, j = 0, k = 0, mod = (long)1e9 + 7;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'S\\') {\\n                if (++k > 2 && k % 2 == 1)\\n                    res = res * (i - j) % mod;\\n                j = i;\\n            }\\n        }\\n        return k % 2 == 0 && k > 0 ? (int)res : 0;\\n    }\\n```\\n\\n**Python**\\n`O(n)` space\\n```py [tag-Python]\\n    def numberOfWays(self, s):\\n        a = [i for i,c in enumerate(s) if c == \\'S\\']\\n        res = 1\\n        for i in xrange(1,len(a) - 1,2):\\n            res *= a[i+1] - a[i]\\n        return res % (10**9+7) * (len(a) % 2 == 0 and len(a) >= 2)     \\n```\\n<br>\\n\\n# **Solution 2: DP**\\n`a` the number of 0 seat\\n`b` the number of 1 seat\\n`c` the number of 2 seats\\n\\nTime `O(n)`\\nSpace `O(1)`\\n\\n**C++**\\n```cpp [tag2-C++]\\n    int numberOfWays(string s) {\\n        int a = 1, b = 0, b2 = 0, c = 0, mod = 1e9 + 7;\\n        for (char& ch: s)\\n            if (ch == \\'S\\')\\n                a = (a + c) % mod, c = b, b = a, a = 0;\\n            else\\n                a = (a + c) % mod;\\n        return c;\\n    }\\n```\\n**Java**\\n```java [tag2-Java]\\n    public int numberOfWays(String s) {\\n        int a = 1, b = 0, b2 = 0, c = 0, mod = (int)1e9 + 7;\\n        for (int i = 0; i < s.length(); ++i)\\n            if (s.charAt(i) == \\'S\\') {\\n                a = (a + c) % mod;\\n                c = b; \\n                b = a;\\n                a = 0;\\n            } else {\\n                a = (a + c) % mod;\\n            }\\n        return c;\\n    }\\n```\\n\\n**Python**\\n```py [tag3-Python]\\n    def numberOfWays(self, s):\\n        a, b, c = 1, 0, 0\\n        for ch in s:\\n            if ch == \\'S\\':\\n                a, b, c = 0, a + c, b\\n            else:\\n                a, b, c = a + c, b, c\\n        return c % (10**9+7)  \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp [tag-C++]\\n    int numberOfWays(string s) {\\n        long res = 1, j = 0, k = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'S\\') {\\n                if (++k > 2 && k % 2 == 1)\\n                    res = res * (i - j) % mod;\\n                j = i;\\n            }\\n        }\\n        return k % 2 == 0 && k > 0 ? res : 0;\\n    }\\n```\n```java [tag-Java]\\n    public int numberOfWays(String s) {\\n        long res = 1, j = 0, k = 0, mod = (long)1e9 + 7;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'S\\') {\\n                if (++k > 2 && k % 2 == 1)\\n                    res = res * (i - j) % mod;\\n                j = i;\\n            }\\n        }\\n        return k % 2 == 0 && k > 0 ? (int)res : 0;\\n    }\\n```\n```py [tag-Python]\\n    def numberOfWays(self, s):\\n        a = [i for i,c in enumerate(s) if c == \\'S\\']\\n        res = 1\\n        for i in xrange(1,len(a) - 1,2):\\n            res *= a[i+1] - a[i]\\n        return res % (10**9+7) * (len(a) % 2 == 0 and len(a) >= 2)     \\n```\n```cpp [tag2-C++]\\n    int numberOfWays(string s) {\\n        int a = 1, b = 0, b2 = 0, c = 0, mod = 1e9 + 7;\\n        for (char& ch: s)\\n            if (ch == \\'S\\')\\n                a = (a + c) % mod, c = b, b = a, a = 0;\\n            else\\n                a = (a + c) % mod;\\n        return c;\\n    }\\n```\n```java [tag2-Java]\\n    public int numberOfWays(String s) {\\n        int a = 1, b = 0, b2 = 0, c = 0, mod = (int)1e9 + 7;\\n        for (int i = 0; i < s.length(); ++i)\\n            if (s.charAt(i) == \\'S\\') {\\n                a = (a + c) % mod;\\n                c = b; \\n                b = a;\\n                a = 0;\\n            } else {\\n                a = (a + c) % mod;\\n            }\\n        return c;\\n    }\\n```\n```py [tag3-Python]\\n    def numberOfWays(self, s):\\n        a, b, c = 1, 0, 0\\n        for ch in s:\\n            if ch == \\'S\\':\\n                a, b, c = 0, a + c, b\\n            else:\\n                a, b, c = a + c, b, c\\n        return c % (10**9+7)  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1710038,
                "title": "dynamic-programming-solution-memoization-c",
                "content": "```\\n/**\\n * \\n * k = current number of seats\\n * i = current position\\n * Time complexity = O(N)\\n * \\n**/\\nclass Solution {\\npublic:\\n    const int MOD = (int)1e9 + 7;\\n    long long dp[100001][3];\\n    long long getAns(string & a, int i, int k) {\\n        if(i >= a.size()) {\\n            return k == 2;\\n        }\\n        \\n        if(dp[i][k] != -1)return dp[i][k];\\n        \\n\\t\\t//if total number of seats in current segment is 2\\n        if(k == 2) {\\n            if(a[i] == \\'P\\') {\\n\\t\\t\\t\\t//choice either to add divider before current plant or not.\\n                return dp[i][k] = (getAns(a, i + 1, 0) % MOD + getAns(a, i + 1, k) % MOD) % MOD;\\n            }\\n            else {\\n\\t\\t\\t\\t//necessary to put a divider before current seat, as current count of seat is 2\\n                return dp[i][k] = getAns(a, i + 1, 1) % MOD;\\n            }\\n        }\\n        else {\\n\\t\\t\\t//current seat is less than 2 so, move ahead\\n            return dp[i][k] = getAns(a, i + 1, k + (a[i] == \\'S\\')) % MOD;\\n        }\\n        \\n        \\n    }\\n    int numberOfWays(string corridor) {\\n        memset(dp, -1, sizeof(dp));\\n        return getAns(corridor, 0, 0); \\n    }\\n};\\n```\\nDo **Upvote** if you liked the solution.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * \\n * k = current number of seats\\n * i = current position\\n * Time complexity = O(N)\\n * \\n**/\\nclass Solution {\\npublic:\\n    const int MOD = (int)1e9 + 7;\\n    long long dp[100001][3];\\n    long long getAns(string & a, int i, int k) {\\n        if(i >= a.size()) {\\n            return k == 2;\\n        }\\n        \\n        if(dp[i][k] != -1)return dp[i][k];\\n        \\n\\t\\t//if total number of seats in current segment is 2\\n        if(k == 2) {\\n            if(a[i] == \\'P\\') {\\n\\t\\t\\t\\t//choice either to add divider before current plant or not.\\n                return dp[i][k] = (getAns(a, i + 1, 0) % MOD + getAns(a, i + 1, k) % MOD) % MOD;\\n            }\\n            else {\\n\\t\\t\\t\\t//necessary to put a divider before current seat, as current count of seat is 2\\n                return dp[i][k] = getAns(a, i + 1, 1) % MOD;\\n            }\\n        }\\n        else {\\n\\t\\t\\t//current seat is less than 2 so, move ahead\\n            return dp[i][k] = getAns(a, i + 1, k + (a[i] == \\'S\\')) % MOD;\\n        }\\n        \\n        \\n    }\\n    int numberOfWays(string corridor) {\\n        memset(dp, -1, sizeof(dp));\\n        return getAns(corridor, 0, 0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709656,
                "title": "python-short-math-solution-explained",
                "content": "It is more like medium problem in my opinion. We know that we need to have exaclty `2` seats in each room. First of all it means that if number of seats is odd or less than `2`, we return `0`. Also, imagine the case `???SPPPPS????`, where we need to put wall somewhere between two `S`. How many ways we have? Exactly `5`, which is distance between these two seats. So, if we have say seats on places `1, 3, 7, 12, 20, 30`, then we have `7 - 3` options to put one wall and `20 - 12` for another wall.\\n\\n#### Complexity\\nIt is `O(n)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def numberOfWays(self, C):\\n        places = [i for i, x in enumerate(C) if C[i] == \"S\"]\\n        m = len(places)\\n        if m % 2 == 1 or m < 2: return 0\\n        \\n        ans = 1\\n        for i in range(m//2 - 1):\\n            ans = (ans * (places[2*i+2] - places[2*i+1])) % (10**9 + 7)\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def numberOfWays(self, C):\\n        places = [i for i, x in enumerate(C) if C[i] == \"S\"]\\n        m = len(places)\\n        if m % 2 == 1 or m < 2: return 0\\n        \\n        ans = 1\\n        for i in range(m//2 - 1):\\n            ans = (ans * (places[2*i+2] - places[2*i+1])) % (10**9 + 7)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709733,
                "title": "dp-solution-with-explation-c-recurion-memoization",
                "content": "This question is based on dp:\\n\\nNote: Here cnt keep the count of seats in left of present index, took moduls to avoid overflow.\\n\\nBase Cases:\\n1. we will chek if count of seats in left have crossed 2 then there cann\\'t be division\\n2. If reached end of corrider then weither we have 2 seats in left or not\\n```\\nif(cnt > 2)return 0;\\n    if(idx == s.size()){\\n      return cnt == 2;\\n    }\\n```\\n\\nIn each call we will check the present element:\\n1. If it\\'s a plant \\n\\t1. Then go for next index and add to present ans (don\\'t increase the cnt),\\n\\t2. Also if cnt has already reached 2 then, go for next index and initialise the cnt with 0\\n2. If it\\'s a seat\\n\\t1.  Then go for next index and increase the cnt by 1\\n\\t2.  Check if cnt has already reached 2 then, go for next index and initialise the cnt with 1(consider present seat)\\n3.  Now return the ans \\n\\n```\\nif(s[idx] == \\'P\\'){\\n      ans = (ans + help(idx + 1, s, cnt)) % MOD;\\n      if(cnt == 2) \\n        ans = (ans + help(idx + 1, s, 0)) % MOD;\\n    }\\n    else{\\n      ans = (ans + help(idx +  1, s , cnt + 1) % MOD);\\n      if(cnt == 2){    \\n        ans = (ans + help(idx + 1, s, 1)) % MOD;\\n      }\\n    }\\n    return dp[idx][cnt] = ans;\\n```\\n\\t\\n```\\n\\tComplete Code:\\n\\t``class Solution {\\npublic:\\n    #define ll long long\\n  #define MOD 1\\'000\\'000\\'007\\n  int dp[100005][3];\\n  ll help(int idx, string &s, int  cnt){\\n      // base cases\\n    if(cnt > 2)return 0;\\n      //if we reach the end of string and have found 2 seats in left then return 1 else 0\\n    if(idx == s.size()){\\n      return cnt == 2;\\n    }\\n      // dp condition\\n    if(dp[idx][cnt] != -1)\\n      return dp[idx][cnt];\\n      \\n    ll ans = 0;\\n      \\n      // check present element is plant or seat\\n    if(s[idx] == \\'P\\'){\\n      ans = (ans + help(idx + 1, s, cnt)) % MOD;\\n      if(cnt == 2) // chek if already we have 2 seats in left, so skip this and initialise cnt\\n        ans = (ans + help(idx + 1, s, 0)) % MOD;\\n    }\\n    else{\\n      ans = (ans + help(idx +  1, s , cnt + 1) % MOD);\\n      if(cnt == 2){    // chek if already we have 2 seats in left, then consider this seat for next Division\\n        ans = (ans + help(idx + 1, s, 1)) % MOD;\\n      }\\n    }\\n    return dp[idx][cnt] = ans;\\n  }\\n    \\n    int numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));  // initialise dp\\n        return help(0,s,0);\\n    }\\n};\\n```\\n\\nPlease do upvote if found helpful :)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nif(cnt > 2)return 0;\\n    if(idx == s.size()){\\n      return cnt == 2;\\n    }\\n```\n```\\nif(s[idx] == \\'P\\'){\\n      ans = (ans + help(idx + 1, s, cnt)) % MOD;\\n      if(cnt == 2) \\n        ans = (ans + help(idx + 1, s, 0)) % MOD;\\n    }\\n    else{\\n      ans = (ans + help(idx +  1, s , cnt + 1) % MOD);\\n      if(cnt == 2){    \\n        ans = (ans + help(idx + 1, s, 1)) % MOD;\\n      }\\n    }\\n    return dp[idx][cnt] = ans;\\n```\n```\\n\\tComplete Code:\\n\\t``class Solution {\\npublic:\\n    #define ll long long\\n  #define MOD 1\\'000\\'000\\'007\\n  int dp[100005][3];\\n  ll help(int idx, string &s, int  cnt){\\n      // base cases\\n    if(cnt > 2)return 0;\\n      //if we reach the end of string and have found 2 seats in left then return 1 else 0\\n    if(idx == s.size()){\\n      return cnt == 2;\\n    }\\n      // dp condition\\n    if(dp[idx][cnt] != -1)\\n      return dp[idx][cnt];\\n      \\n    ll ans = 0;\\n      \\n      // check present element is plant or seat\\n    if(s[idx] == \\'P\\'){\\n      ans = (ans + help(idx + 1, s, cnt)) % MOD;\\n      if(cnt == 2) // chek if already we have 2 seats in left, so skip this and initialise cnt\\n        ans = (ans + help(idx + 1, s, 0)) % MOD;\\n    }\\n    else{\\n      ans = (ans + help(idx +  1, s , cnt + 1) % MOD);\\n      if(cnt == 2){    // chek if already we have 2 seats in left, then consider this seat for next Division\\n        ans = (ans + help(idx + 1, s, 1)) % MOD;\\n      }\\n    }\\n    return dp[idx][cnt] = ans;\\n  }\\n    \\n    int numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));  // initialise dp\\n        return help(0,s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714433,
                "title": "count-gaps",
                "content": "This problem can be solved in O(n) because each group must include exactly two chairs. We just need to count and multiply plants between each pair of chairs. However, there are few edge cases to watch for.\\n\\n1. Count and collect the number of plants between any pair of chairs into the `gaps` array.\\n2. Ignore any plants between the first and the second chair in a pair.\\n3. Multiply the gaps (plus 1) to get the number of ways.\\n\\t- Example: for case \"SSPPSSPPPSSS\" we have `[2, 3]` in the gaps array, and the result is `(2 + 1) * (3 + 1) = 12`.\\n4. Edge cases:\\n\\t- Number of seats is odd. Cannot divide.\\n\\t- There are no seats. Cannot divide.\\n\\t- We need to ignore the gap before the first group of chairs.\\n\\t- We also exclude the gap after the last group of chairs - because we add counts to the `gap` array when we encounter another group of chairs.\\n\\n**C++**\\n```cpp\\nint numberOfWays(string corridor) {\\n    int chairs = 0, gap = 0;\\n    vector<int> gaps;\\n    for (char ch : corridor) {\\n        if (ch == \\'S\\' && ++chairs % 2)\\n            gaps.push_back(gap);\\n        gap = ch == \\'P\\' && chairs % 2 == 0 ? gap + 1 : 0;\\n    }\\n    return chairs == 0 || chairs % 2 ? 0 : \\n        accumulate(begin(gaps) + 1, end(gaps), 1LL, [](long long res, int gap){ return res * (gap + 1) % 1000000007; });\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numberOfWays(string corridor) {\\n    int chairs = 0, gap = 0;\\n    vector<int> gaps;\\n    for (char ch : corridor) {\\n        if (ch == \\'S\\' && ++chairs % 2)\\n            gaps.push_back(gap);\\n        gap = ch == \\'P\\' && chairs % 2 == 0 ? gap + 1 : 0;\\n    }\\n    return chairs == 0 || chairs % 2 ? 0 : \\n        accumulate(begin(gaps) + 1, end(gaps), 1LL, [](long long res, int gap){ return res * (gap + 1) % 1000000007; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709655,
                "title": "python3-java-c-combinations-o-n",
                "content": "* If total seats is not a multiple of 2 or are 0, return 0\\n* We will have a total of `count(\\'S\\')/2 - 1` dividers\\n* After encountering even number of seats, we count the plants. `curr` records the number of seats encountered till now\\n* The number of positions where the divider can be kept between 2 groups(group size = 2) of seats is equal to (1 + number of plants between the groups)\\n* We record the number of possible positions of each divider: `currd`\\n* `dividers[currd]` stores the number of positions where the current divider can be placed i.e = 1 + number of plants between the groups\\n* **If there are n1 possible positions for divider1, n2 possible positions for divider2 and n3 possible positions for divider3, \\nthe total combinations are = <sup>n1</sup>C<sub>1</sub> * <sup>n2</sup>C<sub>1</sub> * <sup>n3</sup>C<sub>1</sub> = n1 * n2 * n3**\\n* Multiply all of the possible positions of all the dividers together and that\\'s your answer\\n\\n<iframe src=\"https://leetcode.com/playground/MyugeuXP/shared\" frameBorder=\"0\" width=\"400\" height=\"400\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C",
                    "Math"
                ],
                "code": "* If total seats is not a multiple of 2 or are 0, return 0\\n* We will have a total of `count(\\'S\\')/2 - 1` dividers\\n* After encountering even number of seats, we count the plants. `curr` records the number of seats encountered till now\\n* The number of positions where the divider can be kept between 2 groups(group size = 2) of seats is equal to (1 + number of plants between the groups)\\n* We record the number of possible positions of each divider: `currd`\\n* `dividers[currd]` stores the number of positions where the current divider can be placed i.e = 1 + number of plants between the groups\\n* **If there are n1 possible positions for divider1, n2 possible positions for divider2 and n3 possible positions for divider3, \\nthe total combinations are = <sup>n1</sup>C<sub>1</sub> * <sup>n2</sup>C<sub>1</sub> * <sup>n3</sup>C<sub>1</sub> = n1 * n2 * n3**\\n* Multiply all of the possible positions of all the dividers together and that\\'s your answer\\n\\n<iframe src=\"https://leetcode.com/playground/MyugeuXP/shared\" frameBorder=\"0\" width=\"400\" height=\"400\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1710196,
                "title": "java-greedy-camouflaged-as-dp",
                "content": "The problem statement makes you think that a DP solution is required.\\nBut it turns out to be Greedy - there is no optionality in correct choices of corridor dividers (all options in between every 2 seats are correct).\\n```\\nstatic int MOD= 1_000_000_007;\\n\\npublic int numberOfWays(String corridor){\\n\\tlong ways= 1, seats= 0, plants= 0;\\n\\tfor(char c:corridor.toCharArray()){\\n\\t\\tif(c==\\'S\\'){\\n\\t\\t\\tif(seats==2){\\n\\t\\t\\t    // multiply the counts of plants (+1) in between every 2 seats\\n\\t\\t\\t\\tways= ways*(plants+1)%MOD;\\n\\t\\t\\t\\tseats= plants= 0;\\n\\t\\t\\t}\\n\\t\\t\\tseats++;\\n\\t\\t// only count plants after you\\'ve seen 2 seats (ignore in-between plants)\\n\\t\\t}else if(seats==2) plants++;    \\n\\t}\\n\\t// ensure the last section has 2 seats i.e. the total number of seats is >=2 and even\\n\\treturn seats==2 ? (int)ways : 0;\\n}",
                "solutionTags": [],
                "code": "The problem statement makes you think that a DP solution is required.\\nBut it turns out to be Greedy - there is no optionality in correct choices of corridor dividers (all options in between every 2 seats are correct).\\n```\\nstatic int MOD= 1_000_000_007;\\n\\npublic int numberOfWays(String corridor){\\n\\tlong ways= 1, seats= 0, plants= 0;\\n\\tfor(char c:corridor.toCharArray()){\\n\\t\\tif(c==\\'S\\'){\\n\\t\\t\\tif(seats==2){\\n\\t\\t\\t    // multiply the counts of plants (+1) in between every 2 seats\\n\\t\\t\\t\\tways= ways*(plants+1)%MOD;\\n\\t\\t\\t\\tseats= plants= 0;\\n\\t\\t\\t}\\n\\t\\t\\tseats++;\\n\\t\\t// only count plants after you\\'ve seen 2 seats (ignore in-between plants)\\n\\t\\t}else if(seats==2) plants++;    \\n\\t}\\n\\t// ensure the last section has 2 seats i.e. the total number of seats is >=2 and even\\n\\treturn seats==2 ? (int)ways : 0;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1709665,
                "title": "c-scan-section-by-section-o-n-time-o-1-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\n**Intuition**: If there are `p` plants between two sections, we multiply the answer by `p + 1`.\\n\\n**Algorithm**:\\n\\nIf the total number of seats is not a positive even number, return 0\\n\\nScan `corridor` section by section, count the number of plants between sections, and multiply the answer by `plant + 1`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-70/problems/number-of-ways-to-divide-a-long-corridor/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        long ans = 1, mod = 1e9 + 7, N = s.size(), total = 0, section = 0;\\n        for (int i = 0; i < N; ) {\\n            int seat = 0, plant = 0;\\n            for (; i < N && seat < 2; ++i) {\\n                seat += s[i] == \\'S\\';\\n                if (seat == 0) plant += s[i] == \\'P\\'; // Only count the plants in the front of the first seat of this section\\n            }\\n            if (seat && section++ > 0) ans = ans * (plant + 1) % mod;\\n            total += seat;\\n        }\\n        return total % 2 == 0 && total ? ans : 0; // if the total number of seats is not a positive even number, return 0\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-70/problems/number-of-ways-to-divide-a-long-corridor/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        long ans = 1, mod = 1e9 + 7, N = s.size(), total = 0, section = 0;\\n        for (int i = 0; i < N; ) {\\n            int seat = 0, plant = 0;\\n            for (; i < N && seat < 2; ++i) {\\n                seat += s[i] == \\'S\\';\\n                if (seat == 0) plant += s[i] == \\'P\\'; // Only count the plants in the front of the first seat of this section\\n            }\\n            if (seat && section++ > 0) ans = ans * (plant + 1) % mod;\\n            total += seat;\\n        }\\n        return total % 2 == 0 && total ? ans : 0; // if the total number of seats is not a positive even number, return 0\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282549,
                "title": "c-java-python-easy-to-understand-o-n-time-o-1-space",
                "content": "C++:\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int mod = 1000000007;\\n        int numSeats = 0, numPlants = 0;\\n        long dividers = 1;\\n        \\n        for(char &item : corridor) {\\n            if(item == \\'S\\') \\n                numSeats += 1;\\n            // as we only care about plants when we crossed 2 seats\\n            if(numSeats == 2 and item == \\'P\\')\\n                numPlants += 1;\\n            // its time to divide as we got a 3rd seat\\n            if(numSeats == 3) {\\n                // + 1 as we count the position of the 3rd seat as well\\n                // number of dividers installed till now will be reused in future for total number of dividers\\n                dividers *= (numPlants + 1);\\n                dividers %= mod;\\n                numPlants = 0;\\n                // after installing a divider before or on the 3rd seat, its considered as our 1st seat now\\n                numSeats = 1;\\n            }\\n        }\\n        \\n        // no need to divide\\n        if(numSeats < 2) return 0;\\n        \\n        return dividers;\\n    }\\n};\\n```\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        int numSeats = 0, numPlants = 0;\\n        long dividers = 1;\\n        \\n        for(int i = 0; i < corridor.length(); ++i) {\\n            if(corridor.charAt(i) == \\'S\\') numSeats += 1;\\n            if(numSeats == 2 && corridor.charAt(i) == \\'P\\') numPlants += 1;\\n            if(numSeats == 3) {\\n                dividers *= (numPlants + 1);\\n                dividers %= 1000000007;\\n                numSeats = 1;\\n                numPlants = 0;\\n            }\\n        }\\n        \\n        if(numSeats < 2) return 0;\\n        return (int)dividers;\\n    }\\n}\\n```\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        numSeats = 0\\n        numPlants = 0\\n        dividers = 1\\n        mod = 1000000007\\n        \\n        for i in corridor:\\n            if i == \\'S\\':\\n                numSeats += 1\\n            if numSeats == 2 and i == \\'P\\':\\n                numPlants += 1\\n            if numSeats == 3:\\n                dividers *= (numPlants + 1)\\n                dividers %= mod\\n                numSeats = 1\\n                numPlants = 0\\n        \\n        if numSeats < 2: return 0\\n        return dividers\\n```\\n\\nThanks for reading. An upvote would be appreciated! ^_^",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int mod = 1000000007;\\n        int numSeats = 0, numPlants = 0;\\n        long dividers = 1;\\n        \\n        for(char &item : corridor) {\\n            if(item == \\'S\\') \\n                numSeats += 1;\\n            // as we only care about plants when we crossed 2 seats\\n            if(numSeats == 2 and item == \\'P\\')\\n                numPlants += 1;\\n            // its time to divide as we got a 3rd seat\\n            if(numSeats == 3) {\\n                // + 1 as we count the position of the 3rd seat as well\\n                // number of dividers installed till now will be reused in future for total number of dividers\\n                dividers *= (numPlants + 1);\\n                dividers %= mod;\\n                numPlants = 0;\\n                // after installing a divider before or on the 3rd seat, its considered as our 1st seat now\\n                numSeats = 1;\\n            }\\n        }\\n        \\n        // no need to divide\\n        if(numSeats < 2) return 0;\\n        \\n        return dividers;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        int numSeats = 0, numPlants = 0;\\n        long dividers = 1;\\n        \\n        for(int i = 0; i < corridor.length(); ++i) {\\n            if(corridor.charAt(i) == \\'S\\') numSeats += 1;\\n            if(numSeats == 2 && corridor.charAt(i) == \\'P\\') numPlants += 1;\\n            if(numSeats == 3) {\\n                dividers *= (numPlants + 1);\\n                dividers %= 1000000007;\\n                numSeats = 1;\\n                numPlants = 0;\\n            }\\n        }\\n        \\n        if(numSeats < 2) return 0;\\n        return (int)dividers;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        numSeats = 0\\n        numPlants = 0\\n        dividers = 1\\n        mod = 1000000007\\n        \\n        for i in corridor:\\n            if i == \\'S\\':\\n                numSeats += 1\\n            if numSeats == 2 and i == \\'P\\':\\n                numPlants += 1\\n            if numSeats == 3:\\n                dividers *= (numPlants + 1)\\n                dividers %= mod\\n                numSeats = 1\\n                numPlants = 0\\n        \\n        if numSeats < 2: return 0\\n        return dividers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822668,
                "title": "simple-logic-and-solution",
                "content": "The first case we have to take care is the no of occurence of \\'S\\', if the number of occurence is odd or zero then answer would be 0. Else we will find no of occurence of \\'P\\' in between the pairs of \\'S\\' and multiply their occuroccurrences.\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        int ans=0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'S\\'){\\n                ans++;\\n            }\\n        }\\n        if(ans%2==1||ans==0){\\n            return 0;\\n        }\\n        int c=0;\\n        int p=0;\\n        int ass=1;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'S\\'){\\n                c++;\\n            }\\n            if(c==2&&s[i]==\\'P\\'){\\n                p++;\\n            }\\n            if(c==3){\\n                c=1;\\n                ass=(ass*1LL*(p+1))%1000000007;\\n                p=0;\\n            }\\n        }\\n        return ass;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        int ans=0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'S\\'){\\n                ans++;\\n            }\\n        }\\n        if(ans%2==1||ans==0){\\n            return 0;\\n        }\\n        int c=0;\\n        int p=0;\\n        int ass=1;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'S\\'){\\n                c++;\\n            }\\n            if(c==2&&s[i]==\\'P\\'){\\n                p++;\\n            }\\n            if(c==3){\\n                c=1;\\n                ass=(ass*1LL*(p+1))%1000000007;\\n                p=0;\\n            }\\n        }\\n        return ass;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757990,
                "title": "c-beginner-friendly-linear-time-constant-space",
                "content": "```\\nint numberOfWays(string c) {\\n        int curSeat=0,curPlant=0;\\n        long long ans=1;\\n        for(auto i:c){\\n            if(i==\\'S\\'){curSeat++;}\\n            if(curSeat==2 && i==\\'P\\') curPlant++;\\n            if(curSeat==3){\\n                ans*=(curPlant+1);                     //calculating number of ways\\n                ans=ans%1000000007;\\n                curPlant=0;\\n                curSeat=1;\\n            }\\n        }\\n        if(curSeat<2) return 0;           // if last room doesn\\'t have 2 chairs\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numberOfWays(string c) {\\n        int curSeat=0,curPlant=0;\\n        long long ans=1;\\n        for(auto i:c){\\n            if(i==\\'S\\'){curSeat++;}\\n            if(curSeat==2 && i==\\'P\\') curPlant++;\\n            if(curSeat==3){\\n                ans*=(curPlant+1);                     //calculating number of ways\\n                ans=ans%1000000007;\\n                curPlant=0;\\n                curSeat=1;\\n            }\\n        }\\n        if(curSeat<2) return 0;           // if last room doesn\\'t have 2 chairs\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1710068,
                "title": "simple-solution-with-explanation-is-this-really-hard-problem",
                "content": "<br/>\\nif there are odd numbers of seats, then answer will be 0 <br/>\\nif seats are even, then there is always a possible division\\n\\n**suppose if position (indices) of all seats are as follows:**\\n\\na b c d e f g h\\nthen we can only put a dividor after every 2 seats, such that there are exactly 2 seats in each division\\nso number of total divisions will be\\n(c - b) * (e - d) * (g - f)\\n\\n<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        \\n        vector<int> seats;\\n        int n = corridor.size();\\n        long long ans = 1, mod = 1e9+7;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(corridor[i] == \\'S\\') seats.push_back(i);\\n        }\\n        \\n        if(seats.size() % 2 == 1 or seats.size() == 0) {\\n            return 0;\\n        }\\n        \\n        for(int i = 2; i <= seats.size()-2; i += 2) {\\n            ans = (ans % mod * (seats[i] - seats[i-1]) % mod) % mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n};\\n```\\n\\n<br/>",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        \\n        vector<int> seats;\\n        int n = corridor.size();\\n        long long ans = 1, mod = 1e9+7;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(corridor[i] == \\'S\\') seats.push_back(i);\\n        }\\n        \\n        if(seats.size() % 2 == 1 or seats.size() == 0) {\\n            return 0;\\n        }\\n        \\n        for(int i = 2; i <= seats.size()-2; i += 2) {\\n            ans = (ans % mod * (seats[i] - seats[i-1]) % mod) % mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783054,
                "title": "multiple-approaches-dp-memoization-greedy-c-clean-code",
                "content": "\\n# Code : DP (memoization)\\n\\n```\\nclass Solution {\\npublic:\\n\\tint mod = 1e9 + 7;\\n    int dp[100005][3];\\n    \\n    int solve(string& s, int cnt, int idx, int n) {\\n        if(idx == n) {\\n            return (cnt == 2);\\n        }\\n        \\n        if(dp[idx][cnt]  != -1) return dp[idx][cnt];\\n        \\n        int res = 0;\\n        \\n        if(cnt == 2) {\\n            if(s[idx] == \\'S\\') {\\n                res += solve(s, 1, idx+1, n);\\n            }\\n            else {\\n                res += solve(s, 0, idx+1, n) + solve(s, cnt, idx+1, n);\\n            }\\n        }\\n        else {\\n            res += solve(s, cnt + (s[idx] == \\'S\\') , idx+1, n);\\n        }\\n        \\n        return dp[idx][cnt] = res % mod;\\n    }\\n    \\n    int numberOfWays(string corridor) {\\n        \\n        int n = corridor.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(corridor, 0, 0, n);\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(3 * N)`\\n* Space : `O(3 * 1e5)`\\n--------------------------------------------\\n# Code : Greedy \\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    \\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        vector<int> seats;\\n        for (int i = 0; i < n; i++) {\\n            if (corridor[i] == \\'S\\') seats.push_back(i);\\n        }\\n        \\n        if (seats.size() == 0 || (seats.size() & 1)) return 0;\\n        \\n        long long res = 1;\\n        int prev = seats[1];\\n        for (int i = 2; i < seats.size(); i += 2) {\\n            res = (res * (seats[i] - prev)) % mod;\\n            prev = seats[i+1];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N)`\\n* Space : `O(N)`\\n\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint mod = 1e9 + 7;\\n    int dp[100005][3];\\n    \\n    int solve(string& s, int cnt, int idx, int n) {\\n        if(idx == n) {\\n            return (cnt == 2);\\n        }\\n        \\n        if(dp[idx][cnt]  != -1) return dp[idx][cnt];\\n        \\n        int res = 0;\\n        \\n        if(cnt == 2) {\\n            if(s[idx] == \\'S\\') {\\n                res += solve(s, 1, idx+1, n);\\n            }\\n            else {\\n                res += solve(s, 0, idx+1, n) + solve(s, cnt, idx+1, n);\\n            }\\n        }\\n        else {\\n            res += solve(s, cnt + (s[idx] == \\'S\\') , idx+1, n);\\n        }\\n        \\n        return dp[idx][cnt] = res % mod;\\n    }\\n    \\n    int numberOfWays(string corridor) {\\n        \\n        int n = corridor.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(corridor, 0, 0, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    \\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        vector<int> seats;\\n        for (int i = 0; i < n; i++) {\\n            if (corridor[i] == \\'S\\') seats.push_back(i);\\n        }\\n        \\n        if (seats.size() == 0 || (seats.size() & 1)) return 0;\\n        \\n        long long res = 1;\\n        int prev = seats[1];\\n        for (int i = 2; i < seats.size(); i += 2) {\\n            res = (res * (seats[i] - prev)) % mod;\\n            prev = seats[i+1];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712718,
                "title": "java-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        int i=0;\\n        int noOfPlants=1;\\n        int noOfSeats=0;\\n        int count=0;\\n        long ans=1;\\n        int mod=(int)1e9+7;\\n        while(i<corridor.length()){\\n            char ch=corridor.charAt(i);\\n            if(count<2){\\n                if(ch==\\'S\\'){\\n                    count++;\\n                    noOfSeats++;\\n                }\\n            }else{\\n                if(ch==\\'S\\'){\\n                  ans=ans*noOfPlants%mod;\\n                    noOfPlants=1;\\n                    noOfSeats++;\\n                    count=1;\\n                }else{\\n                 noOfPlants++;   \\n                }\\n            }\\n            i++;\\n        }\\n        if(noOfSeats==0 || noOfSeats%2!=0){\\n            return 0;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        int i=0;\\n        int noOfPlants=1;\\n        int noOfSeats=0;\\n        int count=0;\\n        long ans=1;\\n        int mod=(int)1e9+7;\\n        while(i<corridor.length()){\\n            char ch=corridor.charAt(i);\\n            if(count<2){\\n                if(ch==\\'S\\'){\\n                    count++;\\n                    noOfSeats++;\\n                }\\n            }else{\\n                if(ch==\\'S\\'){\\n                  ans=ans*noOfPlants%mod;\\n                    noOfPlants=1;\\n                    noOfSeats++;\\n                    count=1;\\n                }else{\\n                 noOfPlants++;   \\n                }\\n            }\\n            i++;\\n        }\\n        if(noOfSeats==0 || noOfSeats%2!=0){\\n            return 0;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711588,
                "title": "c-clean-and-concise-dp-easy-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    const long long mod=1e9+7;\\n    int dp[100001][3];\\n    int recur(string &cor,int idx,int seats)\\n    {\\n        //Base Cases\\n        if(seats>2)\\n            return 0;\\n        \\n        //Limiting Case\\n        if(idx>=cor.size())\\n        {\\n            return seats==2;\\n            \\n        }\\n        \\n        // Memoization \\n        if(dp[idx][seats]!=-1)\\n            return dp[idx][seats]%mod;\\n        \\n        \\n        // I don\\'t Partition Here and move forward\\n        int op1=recur(cor,idx+1,seats+(cor[idx]==\\'S\\'));\\n        \\n        \\n        // I partition only if my Seat count is exactly = 2 and\\n        // add the result to previous count\\n        if(seats==2)\\n            op1=(op1+(recur(cor,idx,0)))%mod;\\n        \\n        \\n        return dp[idx][seats]=op1%mod;\\n        \\n        \\n        \\n    }\\n    int numberOfWays(string corridor) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        return recur(corridor,0,0)%mod;\\n    }\\n};\\n```\\n\\n**Pls upvote if you found helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long mod=1e9+7;\\n    int dp[100001][3];\\n    int recur(string &cor,int idx,int seats)\\n    {\\n        //Base Cases\\n        if(seats>2)\\n            return 0;\\n        \\n        //Limiting Case\\n        if(idx>=cor.size())\\n        {\\n            return seats==2;\\n            \\n        }\\n        \\n        // Memoization \\n        if(dp[idx][seats]!=-1)\\n            return dp[idx][seats]%mod;\\n        \\n        \\n        // I don\\'t Partition Here and move forward\\n        int op1=recur(cor,idx+1,seats+(cor[idx]==\\'S\\'));\\n        \\n        \\n        // I partition only if my Seat count is exactly = 2 and\\n        // add the result to previous count\\n        if(seats==2)\\n            op1=(op1+(recur(cor,idx,0)))%mod;\\n        \\n        \\n        return dp[idx][seats]=op1%mod;\\n        \\n        \\n        \\n    }\\n    int numberOfWays(string corridor) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        return recur(corridor,0,0)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709853,
                "title": "c-easy-to-understand",
                "content": "```\\nint numberOfWays(string corridor) {\\n        int count=0;\\n        for(int i=0;i<corridor.size();i++){\\n            if(corridor[i]==\\'S\\') count++;\\n        }\\n        if(count%2==1 or count==0) return 0;\\n        vector<long long> vec;\\n        for(int i=0;i<corridor.size();i++){\\n            if(corridor[i]==\\'S\\') vec.push_back(i);\\n        }\\n        long long p=1;\\n        for(int i=1;i<vec.size()-1;i+=2){\\n            p*=(vec[i+1]-vec[i]);\\n            p%=1000000007;\\n        }\\n        return p;\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nint numberOfWays(string corridor) {\\n        int count=0;\\n        for(int i=0;i<corridor.size();i++){\\n            if(corridor[i]==\\'S\\') count++;\\n        }\\n        if(count%2==1 or count==0) return 0;\\n        vector<long long> vec;\\n        for(int i=0;i<corridor.size();i++){\\n            if(corridor[i]==\\'S\\') vec.push_back(i);\\n        }\\n        long long p=1;\\n        for(int i=1;i<vec.size()-1;i+=2){\\n            p*=(vec[i+1]-vec[i]);\\n            p%=1000000007;\\n        }\\n        return p;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709734,
                "title": "c-time-o-n-easy-to-understand-greedy",
                "content": "Observation: If there are 2 seats and then 2 plants and at last 2 seats are there:\\n\\n  s s p p p s s \\n\\n s => seat\\np => plant\\n\\nthen to make valid pairing of seats we can place a divider in between of any plant (including before the first plant and after the last plant).\\n\\ni.e: \\ns s | p p p s s\\ns s p | p p s s\\ns s p p | p s s\\ns s p p p | s s\\n\\nSo, the number of extra plants between two pair of seats will cause extra positions for placing dividers and such that \\'n\\' extra plants will create (n+1) positions to place a divider.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll mod = 1E9+7;\\n    \\n    int numberOfWays(string s) {\\n        // Flag to check, whether at least 1 pair of seat exists or not.\\n        bool f = false;\\n\\n        ll ans = 0;\\n        ll plants = 0;\\n        ll seats = 0;\\n        \\n        for(auto x:s){\\n            if(x == \\'S\\'){\\n                // If we have picked up a pair then mark seats as 0 again.\\n                if(seats==2){\\n                    seats = 0;\\n                }\\n                seats++;\\n            }\\n            // If seats are \\'2\\' then count extra positions to place a divider.\\n            else if(seats==2){\\n                plants++;\\n            }\\n            // Answer will be updated if and only if at least a single pair of seats already picked and new pair is going to start.\\n            if(seats==1 && f){\\n                ans  = (ans%mod * (plants+1)%mod)%mod;\\n                plants = 0;\\n            }\\n            // First occurence of pair found.\\n            if(!f && seats==2){\\n                ans = 1;\\n                f = true;\\n            }  \\n        }\\n        // If all seats are unable to paired up.\\n        if(seats==1){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll mod = 1E9+7;\\n    \\n    int numberOfWays(string s) {\\n        // Flag to check, whether at least 1 pair of seat exists or not.\\n        bool f = false;\\n\\n        ll ans = 0;\\n        ll plants = 0;\\n        ll seats = 0;\\n        \\n        for(auto x:s){\\n            if(x == \\'S\\'){\\n                // If we have picked up a pair then mark seats as 0 again.\\n                if(seats==2){\\n                    seats = 0;\\n                }\\n                seats++;\\n            }\\n            // If seats are \\'2\\' then count extra positions to place a divider.\\n            else if(seats==2){\\n                plants++;\\n            }\\n            // Answer will be updated if and only if at least a single pair of seats already picked and new pair is going to start.\\n            if(seats==1 && f){\\n                ans  = (ans%mod * (plants+1)%mod)%mod;\\n                plants = 0;\\n            }\\n            // First occurence of pair found.\\n            if(!f && seats==2){\\n                ans = 1;\\n                f = true;\\n            }  \\n        }\\n        // If all seats are unable to paired up.\\n        if(seats==1){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709701,
                "title": "linear-javascript-solution-explained",
                "content": "Divide all the space to groups of seats. Store index of first and second chair for each group.\\nFor every subsequent 2 groupt number of dicisions will be:\\nres[i]=\"Index of first seat from group[i]\" - \"Index of second seat from group[i-1]\"\\nAnd overrall result will be:\\nres = res * res[i] (i = 0...number of set groups)\\n\\n```\\nvar numberOfWays = function(corridor) {\\n    let numberOfSeats = 0\\n    \\n    let positions = []\\n    let pi = 0\\n    let seats = []\\n\\n    // Accamulate all the groups by 2 chair\\n    for(let i = 0; i < corridor.length; i++){\\n        if(corridor[i] === \\'S\\'){\\n            numberOfSeats++\\n            seats.push(i)\\n        }\\n        \\n        if(seats.length == 2){\\n            positions.push([seats[0], seats[1]])\\n            seats=[]\\n        }\\n    }\\n    \\n    let res = 1\\n    let mod = 1000000007\\n    if(numberOfSeats < 2 || numberOfSeats % 2 === 1){\\n        return 0\\n    }\\n    \\n    // Combinatorically calculate all possible divisions\\n    for(let i = 1; i < positions.length; i++){\\n        res *= positions[i][0] - positions[i-1][1]\\n        res = res % mod\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar numberOfWays = function(corridor) {\\n    let numberOfSeats = 0\\n    \\n    let positions = []\\n    let pi = 0\\n    let seats = []\\n\\n    // Accamulate all the groups by 2 chair\\n    for(let i = 0; i < corridor.length; i++){\\n        if(corridor[i] === \\'S\\'){\\n            numberOfSeats++\\n            seats.push(i)\\n        }\\n        \\n        if(seats.length == 2){\\n            positions.push([seats[0], seats[1]])\\n            seats=[]\\n        }\\n    }\\n    \\n    let res = 1\\n    let mod = 1000000007\\n    if(numberOfSeats < 2 || numberOfSeats % 2 === 1){\\n        return 0\\n    }\\n    \\n    // Combinatorically calculate all possible divisions\\n    for(let i = 1; i < positions.length; i++){\\n        res *= positions[i][0] - positions[i-1][1]\\n        res = res % mod\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3362897,
                "title": "easiest-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfWays(self, c: str) -> int:\\n        cnt=c.count(\\'S\\')\\n        if cnt%2==1:\\n            return 0\\n        if cnt==0:\\n            return 0\\n        sc=0\\n        ans=1\\n        pc=0\\n        for i in c:\\n            if sc<=1:\\n                if i == \"S\":\\n                    sc+=1\\n            else:\\n                if i == \"P\":\\n                    pc+=1\\n                elif i==\"S\":\\n                    ans=(ans*(pc+1))%(10**9+7)\\n                    pc=0\\n                    sc=1\\n        return ans%(10**9+7)\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, c: str) -> int:\\n        cnt=c.count(\\'S\\')\\n        if cnt%2==1:\\n            return 0\\n        if cnt==0:\\n            return 0\\n        sc=0\\n        ans=1\\n        pc=0\\n        for i in c:\\n            if sc<=1:\\n                if i == \"S\":\\n                    sc+=1\\n            else:\\n                if i == \"P\":\\n                    pc+=1\\n                elif i==\"S\":\\n                    ans=(ans*(pc+1))%(10**9+7)\\n                    pc=0\\n                    sc=1\\n        return ans%(10**9+7)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762173,
                "title": "number-of-ways-to-divide-a-long-corridor",
                "content": "**Please upvote if you lunderstood**\\n**This problem can be done greedy way but I discussed two method DP+MEMO and Greedy One**\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dp[100004][3];\\n    int solve(string &cor , int seats , int i ){\\n      // base case \\n      if(i == cor.size()){\\n        // S S | P P S S --> end of corrior we have 2 seats \\n        \\n        \\n        // we are successfully put all barrier\\n        // with exactly 2 seats and we reach end\\n        // of the corrior\\n        if(seats == 2){\\n          return 1;\\n        }else{\\n          return 0;\\n        }\\n      }\\n      if(dp[i][seats] != -1){return dp[i][seats];}\\n      // in every patition there are must be 2 seats\\n      // if seats is  == 2\\n      int results = 0;\\n      if(seats == 2){\\n        // if this index is Plants\\n        // two choices eighter put a barrier or not\\n        if(cor[i] == \\'P\\'){\\n          // put a barrier \\n          results+=solve(cor ,  0 , i+1 );\\n          results%=mod;\\n          // not put a barrier\\n          \\n          results+=solve(cor, seats , i+1);\\n            results%=mod;\\n        }\\n        // if this index is a seats before the \\n        // we have already 2 seats \\n        else{\\n          // seats now start 1 for this index\\n          results+=solve(cor , 1 , i+1 );\\n            results%=mod;\\n        }\\n      }\\n      // seats till now is not 2 \\n      // try to make 2 seats\\n      else{\\n        // call for next index, and add up if it is seat\\n        results+=solve(cor ,seats+(cor[i] == \\'S\\') , i+1 );\\n          results%=mod;\\n      }\\n      dp[i][seats]   =  results;\\n      return dp[i][seats];\\n    }\\n  \\n    int numberOfWays(string cor) {\\n        int n = cor.size();\\n        //vector<vector<int>> dp( n , vector<int>(3,-1));\\n        memset(dp , -1 , sizeof dp);\\n        return solve(cor , 0 ,0);\\n    }\\n};\\n```\\n\\n**One more easy greedy solution is  --- >> **\\n```\\nint mod = 1e9+7\\nint numberOfWays(string corr) {\\n        int curS=0,curP=0;\\n        long long ans=1;\\n        for(auto i:corr){\\n            if(i==\\'S\\'){curS++;}\\n            if(curS==2 && i==\\'P\\') curP++;\\n\\t\\t\\t// you can make partition now \\n            if(curS==3){\\n                ans*=(curP+1);                    \\n                ans=ans%mod;\\n                curP=0;\\n                curS=1;\\n            }\\n        }\\n\\t\\t// if seats is not 2 \\n        if(curS<2) return 0;        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dp[100004][3];\\n    int solve(string &cor , int seats , int i ){\\n      // base case \\n      if(i == cor.size()){\\n        // S S | P P S S --> end of corrior we have 2 seats \\n        \\n        \\n        // we are successfully put all barrier\\n        // with exactly 2 seats and we reach end\\n        // of the corrior\\n        if(seats == 2){\\n          return 1;\\n        }else{\\n          return 0;\\n        }\\n      }\\n      if(dp[i][seats] != -1){return dp[i][seats];}\\n      // in every patition there are must be 2 seats\\n      // if seats is  == 2\\n      int results = 0;\\n      if(seats == 2){\\n        // if this index is Plants\\n        // two choices eighter put a barrier or not\\n        if(cor[i] == \\'P\\'){\\n          // put a barrier \\n          results+=solve(cor ,  0 , i+1 );\\n          results%=mod;\\n          // not put a barrier\\n          \\n          results+=solve(cor, seats , i+1);\\n            results%=mod;\\n        }\\n        // if this index is a seats before the \\n        // we have already 2 seats \\n        else{\\n          // seats now start 1 for this index\\n          results+=solve(cor , 1 , i+1 );\\n            results%=mod;\\n        }\\n      }\\n      // seats till now is not 2 \\n      // try to make 2 seats\\n      else{\\n        // call for next index, and add up if it is seat\\n        results+=solve(cor ,seats+(cor[i] == \\'S\\') , i+1 );\\n          results%=mod;\\n      }\\n      dp[i][seats]   =  results;\\n      return dp[i][seats];\\n    }\\n  \\n    int numberOfWays(string cor) {\\n        int n = cor.size();\\n        //vector<vector<int>> dp( n , vector<int>(3,-1));\\n        memset(dp , -1 , sizeof dp);\\n        return solve(cor , 0 ,0);\\n    }\\n};\\n```\n```\\nint mod = 1e9+7\\nint numberOfWays(string corr) {\\n        int curS=0,curP=0;\\n        long long ans=1;\\n        for(auto i:corr){\\n            if(i==\\'S\\'){curS++;}\\n            if(curS==2 && i==\\'P\\') curP++;\\n\\t\\t\\t// you can make partition now \\n            if(curS==3){\\n                ans*=(curP+1);                    \\n                ans=ans%mod;\\n                curP=0;\\n                curS=1;\\n            }\\n        }\\n\\t\\t// if seats is not 2 \\n        if(curS<2) return 0;        \\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712945,
                "title": "solution-without-dp-full-explanation",
                "content": "Here is the code with comments . Please see the explanation after the code\\n```\\nint mod = 1000000007;\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        string x; \\n        int cnt = 0;  //to count the number of seats\\n        bool start = false;\\n\\t\\t\\n\\t//to count the number of paired seat and making a string which depicts the paired seat as one               //seat. \\n\\t//i.e. make SS to S or make something like SPPPS to S\\n\\t//if corridor = \"PPSPSPPPSSP\"\\n\\t//then x = \"PPSPPSP\"\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t\\t//counting the number of seats\\n            if(corridor[i] == \\'S\\')\\n                cnt++;\\n            if(corridor[i] == \\'P\\' && start == false)\\n            {\\n                x.push_back(corridor[i]);\\n            }\\n            else if(corridor[i] == \\'S\\' && start == true)\\n            {\\n                x.push_back(\\'S\\');\\n                start = false;\\n            }\\n            else if(corridor[i] == \\'S\\' && start == false)\\n            {\\n                start = true;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//number of seat is zero or number of seat is odd then partition not possible\\n        if(cnt ==0 || cnt%2 == 1)\\n            return 0;\\n\\t\\t\\t\\n\\t\\t//finding the first S from left and first S from right\\n        int left =0;\\n        while(x[left] != \\'S\\')\\n        {\\n            left++;\\n        }\\n        int right = x.size() -1;\\n        while(x[right] != \\'S\\')\\n            right--;\\n\\t\\t\\t\\n\\t\\t\\t\\n        long long answer =1;\\n        long long count = 0;\\n\\t\\t\\n\\t\\t//Solution based on formula.\\n        for(int i=left ;i<=right;i++)\\n        {\\n            if(x[i] == \\'S\\'){\\n                answer *= (count+1);\\n                answer = answer % mod;\\n                count=0;\\n                continue;\\n            }\\n            count++;\\n        }\\n        return answer;\\n    }\\n```\\n\\n```\\nHow I reached to soultion ?\\nWhen the solution not exist ?\\n\\t-> no seat or number of seat is odd.\\n\\t\\nFirst club the pairs of chairs i.e.\\n\\t->convert SS to S\\n\\t->convert something like S[any-number-of-P)S to S.\\n\\t\\tex - convert SPPPS to S\\n\\nHow to achieve above thing ? (Refer second loop . I have used a variable called start)\\nSuppose corridor = \"PPSPPSPPSS\" x = \"\"\\nindex = 0 => start is false . push p => x=P\\nindex = 1 => start is false . push P => x=PP\\nindex =2 => S encountered , make start = true\\nindex = 3 => P encountered but start is true . This means there is one S we have met before but \\n\\t\\t\\t\\t\\tthat S is still not paired.\\nindex = 4 => P encoutered but start is true . \\nindex = 5=> S encountered but start is true .push S => PPS . So we use current S and pair it\\n\\t\\t\\t\\t\\t\\twith previous S\\n\\t\\t\\t\\t\\ti.e. SPPS becomes S\\nindex = 6 =>  P encountered and start is false . push p => x = PPSP\\nindex = 7 => x = PPSPP\\nindex = 8 => S encountered and start is false. make start = true\\nindex = 9 => S encountered and start is true . push S = > PPSPS\\n```\\n![image](https://assets.leetcode.com/users/images/96ddf599-81f3-4514-8283-f857a960556f_1642939766.3337946.jpeg)\\n\\n```\\nNow how to get soluton - I have founded first S from left and first S from right . This is done so that all P from left till first S is included in that S i.e. NO partition in the left of first S will be done. Similar reason to find first S from right.\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6a1f99e8-562b-4704-a4aa-d833e1b4fb06_1642940054.1478806.jpeg)\\n\\nRefer for below image for further explanation . If I choose to partition just right to first S then rest of the P become part of Second S . In this particular partition there are 4 possibilities for second S -\\n\\t-> It will partition just right to first S . Rest P will become part of the next S\\n\\t-> it will include one P in its right then do partition . Rest P will become part of the next S.\\n\\t .....and so on. \\n\\t\\nSimilarly , If first S keeps one P in its right and then do Partition . In this case again 4 posiibilty.\\n\\nSo the formula we get is\\n\\tif x = S1....S2.....S3....\\n\\tthen formula = (number of way to partition after S1 till S2) * (number of way to partition after S2 till S3) * (.................................\\n\\t\\n![image](https://assets.leetcode.com/users/images/0d4c23ac-d037-4bd0-aa2e-cd9539ccfc7a_1642941380.103665.jpeg)\\n\\n\\nPlease comment if found something wrond :)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint mod = 1000000007;\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        string x; \\n        int cnt = 0;  //to count the number of seats\\n        bool start = false;\\n\\t\\t\\n\\t//to count the number of paired seat and making a string which depicts the paired seat as one               //seat. \\n\\t//i.e. make SS to S or make something like SPPPS to S\\n\\t//if corridor = \"PPSPSPPPSSP\"\\n\\t//then x = \"PPSPPSP\"\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t\\t//counting the number of seats\\n            if(corridor[i] == \\'S\\')\\n                cnt++;\\n            if(corridor[i] == \\'P\\' && start == false)\\n            {\\n                x.push_back(corridor[i]);\\n            }\\n            else if(corridor[i] == \\'S\\' && start == true)\\n            {\\n                x.push_back(\\'S\\');\\n                start = false;\\n            }\\n            else if(corridor[i] == \\'S\\' && start == false)\\n            {\\n                start = true;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//number of seat is zero or number of seat is odd then partition not possible\\n        if(cnt ==0 || cnt%2 == 1)\\n            return 0;\\n\\t\\t\\t\\n\\t\\t//finding the first S from left and first S from right\\n        int left =0;\\n        while(x[left] != \\'S\\')\\n        {\\n            left++;\\n        }\\n        int right = x.size() -1;\\n        while(x[right] != \\'S\\')\\n            right--;\\n\\t\\t\\t\\n\\t\\t\\t\\n        long long answer =1;\\n        long long count = 0;\\n\\t\\t\\n\\t\\t//Solution based on formula.\\n        for(int i=left ;i<=right;i++)\\n        {\\n            if(x[i] == \\'S\\'){\\n                answer *= (count+1);\\n                answer = answer % mod;\\n                count=0;\\n                continue;\\n            }\\n            count++;\\n        }\\n        return answer;\\n    }\\n```\n```\\nHow I reached to soultion ?\\nWhen the solution not exist ?\\n\\t-> no seat or number of seat is odd.\\n\\t\\nFirst club the pairs of chairs i.e.\\n\\t->convert SS to S\\n\\t->convert something like S[any-number-of-P)S to S.\\n\\t\\tex - convert SPPPS to S\\n\\nHow to achieve above thing ? (Refer second loop . I have used a variable called start)\\nSuppose corridor = \"PPSPPSPPSS\" x = \"\"\\nindex = 0 => start is false . push p => x=P\\nindex = 1 => start is false . push P => x=PP\\nindex =2 => S encountered , make start = true\\nindex = 3 => P encountered but start is true . This means there is one S we have met before but \\n\\t\\t\\t\\t\\tthat S is still not paired.\\nindex = 4 => P encoutered but start is true . \\nindex = 5=> S encountered but start is true .push S => PPS . So we use current S and pair it\\n\\t\\t\\t\\t\\t\\twith previous S\\n\\t\\t\\t\\t\\ti.e. SPPS becomes S\\nindex = 6 =>  P encountered and start is false . push p => x = PPSP\\nindex = 7 => x = PPSPP\\nindex = 8 => S encountered and start is false. make start = true\\nindex = 9 => S encountered and start is true . push S = > PPSPS\\n```\n```\\nNow how to get soluton - I have founded first S from left and first S from right . This is done so that all P from left till first S is included in that S i.e. NO partition in the left of first S will be done. Similar reason to find first S from right.\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1710011,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        int count =0;\\n        int sfc = 0;\\n        int pc = 0;//plant count\\n        boolean atleastTwoSeats = false;\\n        List<Integer> list = new ArrayList<>();\\n        for(char c: corridor.toCharArray()){\\n            if(c==\\'S\\'){\\n                sfc++;\\n                if(count==2){\\n                    count = count%2;\\n                    list.add(pc);\\n                    pc =0;\\n                }\\n                count++;\\n                \\n            }else{\\n            if(count==2)\\n            pc++;    \\n            }\\n            if(count ==2)\\n                atleastTwoSeats =true;\\n        }\\n        if(sfc%2==1)\\n            return 0;//if odd number of sofas\\n                \\n        int n = list.size(); \\n        long result = 1;\\n        for(int val : list){\\n            result = (result*((val+1)%1000000007))%1000000007;\\n        }\\n        return (int)((n==0)?0+(atleastTwoSeats?1:0):result%1000000007);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numberOfWays(String corridor) {\\n        int count =0;\\n        int sfc = 0;\\n        int pc = 0;//plant count\\n        boolean atleastTwoSeats = false;\\n        List<Integer> list = new ArrayList<>();\\n        for(char c: corridor.toCharArray()){\\n            if(c==\\'S\\'){\\n                sfc++;\\n                if(count==2){\\n                    count = count%2;\\n                    list.add(pc);\\n                    pc =0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1709910,
                "title": "python3-runtime-o-n",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        l = []\\n        c = 0\\n        n = len(corridor)\\n        for i in range(n):\\n            if corridor[i]==\"S\":\\n                l.append(i)\\n                c+=1\\n        if c%2 or c==0:\\n            return 0\\n        ans = 1\\n        for i in range(2,c,2):\\n            ans*=l[i]-l[i-1]\\n            ans%=1000000007\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        l = []\\n        c = 0\\n        n = len(corridor)\\n        for i in range(n):\\n            if corridor[i]==\"S\":\\n                l.append(i)\\n                c+=1\\n        if c%2 or c==0:\\n            return 0\\n        ans = 1\\n        for i in range(2,c,2):\\n            ans*=l[i]-l[i-1]\\n            ans%=1000000007\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709825,
                "title": "python-o-n-explanation",
                "content": "`indeces` is list of index `i` where `corridor[i] == \\'S\\'`\\nif `len(indeces)` is odd or `0`, there is no way to divide that corridor\\n\\nthere n + 1 combinations to divide n PLANTS into two groups\\n`0 and n`\\n`1 and n - 1`\\n`2 and n - 2`\\n`...`\\n`n- 1 and 1`\\n`n and 0`\\n\\nSo, to get total number of combinations we need multiply number of combinations for each group of `P`\\'s surrounded by two `S`\\'s\\nwhich we can get using `indeces[i + 1] - indeces[i]`\\n\\n```\\ndef numberOfWays(self, corr: str) -> int:\\n\\tindeces = [i for i, c in enumerate(corr) if c == \\'S\\']\\n\\tl = len(indeces)\\n\\tif l % 2 or l == 0:\\n\\t\\treturn 0\\n\\n\\tans = 1\\n\\tfor i in range(1, l - 1, 2):\\n\\t\\tans *= indeces[i + 1] - indeces[i]\\n\\n\\treturn ans % (10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numberOfWays(self, corr: str) -> int:\\n\\tindeces = [i for i, c in enumerate(corr) if c == \\'S\\']\\n\\tl = len(indeces)\\n\\tif l % 2 or l == 0:\\n\\t\\treturn 0\\n\\n\\tans = 1\\n\\tfor i in range(1, l - 1, 2):\\n\\t\\tans *= indeces[i + 1] - indeces[i]\\n\\n\\treturn ans % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1709706,
                "title": "simple-python-solution-time-o-n-space-o-1",
                "content": "First, if the total number of S is 0 or odd number, then it\\'s impossible to divide into valid sections, so we just return 0.\\n\\n![image](https://assets.leetcode.com/users/images/5e9d992f-2ddc-4188-8640-72145e24944a_1642867308.6085112.jpeg)\\n\\n\\nNext, we want to know the each divisible spot. Each divisible spot must be somewhere between the pair or 2 seats. For example, if corridor is \\'SSSPPSPSSPSPSPPPSPPSPP\\', then, the divisible spots are [1, 2, 2, 4]. The final answer should be 1 * 2 * 2 * 4.\\n\\n**Time: O(N), Space: O(N)**\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        #edge case\\n        num_S = corridor.count(\\'S\\')\\n        if num_S == 0 or num_S % 2 == 1:\\n            return 0\\n        \\n        mod = 10 ** 9 + 7\\n        curr_s = 0\\n        divide_spots = []\\n        \\n        for char in corridor:\\n\\t\\t\\tcurr_s += (char == \\'S\\')\\n            if curr_s > 0 and curr_s % 2 == 0:\\n                divide_spots[-1] += 1\\n            else:\\n                if not divide_spots or divide_spots[-1] > 0:\\n                    divide_spots.append(0)\\n        \\n        res = 1\\n        for num in divide_spots[:-1]:\\n            res = res * num % mod\\n        return res\\n```\\n\\nFurthermore, you can reduce the space by just keeping track of the last number of spots.\\n**Time: O(N), Space: O(1)**\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        #edge case\\n        num_S = corridor.count(\\'S\\')\\n        if num_S == 0 or num_S % 2 == 1:\\n            return 0\\n        \\n        mod = 10 ** 9 + 7\\n        curr_s = 0\\n        res = 1\\n        spots = 0\\n        \\n        for char in corridor:\\n            curr_s += (char == \\'S\\')\\n            if curr_s > 0 and curr_s % 2 == 0:\\n                spots += 1\\n            else:\\n                if spots != 0:\\n                    res = res * spots % mod\\n                    spots = 0\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        #edge case\\n        num_S = corridor.count(\\'S\\')\\n        if num_S == 0 or num_S % 2 == 1:\\n            return 0\\n        \\n        mod = 10 ** 9 + 7\\n        curr_s = 0\\n        divide_spots = []\\n        \\n        for char in corridor:\\n\\t\\t\\tcurr_s += (char == \\'S\\')\\n            if curr_s > 0 and curr_s % 2 == 0:\\n                divide_spots[-1] += 1\\n            else:\\n                if not divide_spots or divide_spots[-1] > 0:\\n                    divide_spots.append(0)\\n        \\n        res = 1\\n        for num in divide_spots[:-1]:\\n            res = res * num % mod\\n        return res\\n```\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        #edge case\\n        num_S = corridor.count(\\'S\\')\\n        if num_S == 0 or num_S % 2 == 1:\\n            return 0\\n        \\n        mod = 10 ** 9 + 7\\n        curr_s = 0\\n        res = 1\\n        spots = 0\\n        \\n        for char in corridor:\\n            curr_s += (char == \\'S\\')\\n            if curr_s > 0 and curr_s % 2 == 0:\\n                spots += 1\\n            else:\\n                if spots != 0:\\n                    res = res * spots % mod\\n                    spots = 0\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709690,
                "title": "a-few-solutions",
                "content": "Perform a linear scan of the input string `A` one pair of seats at a time to count the plants `p` in between seats.  Let `P` be an array of plant counts upon which we use the rule-of-product to formulate the answer.\\n\\nNote: when formulating the answer, we ignore the last group of plants since there are no seats to-the-right of the last group of plants\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun numberOfWays(A: String): Int {\\n        var S = A.split(\"\").filter{ it == \"S\" }.size\\n        if (S % 2 == 1 || S == 0)\\n            return 0\\n        var P = mutableListOf<Int>()\\n        var (i, N) = Pair(0, A.length)\\n        while (i < N) {\\n            var (s, p) = Pair(0, 0)\\n            while (i < N && s < 2)\\n                s += if (A[i++] == \\'S\\') 1 else 0\\n            while (i < N && A[i] == \\'P\\') {\\n                ++p; ++i\\n            }\\n            P.add(p + 1)\\n        }\\n        var cnt = 1L\\n        for (x in P.slice(0 until P.lastIndex))\\n            cnt = (cnt * x) % (1e9 + 7).toInt()\\n        return cnt.toInt()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numberOfWays = (A, P = [], cnt = 1) => {\\n    let S = A.split(\\'\\').filter(x => x == \\'S\\').length;\\n    if (S & 1 || !S)\\n        return 0;\\n    let N = A.length,\\n        i = 0;\\n    while (i < N) {\\n        let [s, p] = [0, 0];\\n        while (i < N && s < 2)\\n            s += Number(A[i++] == \\'S\\');\\n        while (i < N && A[i] == \\'P\\')\\n            ++p, ++i;\\n        P.push(p + 1);\\n    }\\n    for (let x of P.slice(0, P.length - 1))\\n        cnt = (cnt * x) % Number(1e9 + 7);\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numberOfWays(self, A: str, cnt = 1) -> int:\\n        S = len([x for x in A if x == \\'S\\'])\\n        if S & 1 or not S:\\n            return 0\\n        P = []\\n        N = len(A)\\n        i = 0\\n        while i < N:\\n            s, p = 0, 0\\n            while i < N and s < 2:\\n                s += int(A[i] == \\'S\\'); i += 1\\n            while i < N and A[i] == \\'P\\':\\n                p += 1; i += 1\\n            P.append(p + 1)\\n        for x in P[:len(P) - 1]:\\n            cnt = (cnt * x) % int(1e9 + 7)\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    int numberOfWays(string A, VI P = {}, LL cnt = 1) {\\n        int S = count_if(A.begin(), A.end(), [](auto x) { return x == \\'S\\'; });\\n        if (S & 1 || !S)\\n            return 0;\\n        auto [i, N] = make_pair<int>(0, A.size());\\n        while (i < N) {\\n            auto [s, p] = make_pair(0, 0);\\n            while (i < N && s < 2)\\n                s += int(A[i++] == \\'S\\');\\n            while (i < N && A[i] == \\'P\\')\\n                ++p, ++i;\\n            P.push_back(p + 1);\\n        }\\n        for (auto x: VI{ P.begin(), prev(P.end()) })\\n            cnt = (cnt * x) % int(1e9 + 7);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numberOfWays(A: String): Int {\\n        var S = A.split(\"\").filter{ it == \"S\" }.size\\n        if (S % 2 == 1 || S == 0)\\n            return 0\\n        var P = mutableListOf<Int>()\\n        var (i, N) = Pair(0, A.length)\\n        while (i < N) {\\n            var (s, p) = Pair(0, 0)\\n            while (i < N && s < 2)\\n                s += if (A[i++] == \\'S\\') 1 else 0\\n            while (i < N && A[i] == \\'P\\') {\\n                ++p; ++i\\n            }\\n            P.add(p + 1)\\n        }\\n        var cnt = 1L\\n        for (x in P.slice(0 until P.lastIndex))\\n            cnt = (cnt * x) % (1e9 + 7).toInt()\\n        return cnt.toInt()\\n    }\\n}\\n```\n```\\nlet numberOfWays = (A, P = [], cnt = 1) => {\\n    let S = A.split(\\'\\').filter(x => x == \\'S\\').length;\\n    if (S & 1 || !S)\\n        return 0;\\n    let N = A.length,\\n        i = 0;\\n    while (i < N) {\\n        let [s, p] = [0, 0];\\n        while (i < N && s < 2)\\n            s += Number(A[i++] == \\'S\\');\\n        while (i < N && A[i] == \\'P\\')\\n            ++p, ++i;\\n        P.push(p + 1);\\n    }\\n    for (let x of P.slice(0, P.length - 1))\\n        cnt = (cnt * x) % Number(1e9 + 7);\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def numberOfWays(self, A: str, cnt = 1) -> int:\\n        S = len([x for x in A if x == \\'S\\'])\\n        if S & 1 or not S:\\n            return 0\\n        P = []\\n        N = len(A)\\n        i = 0\\n        while i < N:\\n            s, p = 0, 0\\n            while i < N and s < 2:\\n                s += int(A[i] == \\'S\\'); i += 1\\n            while i < N and A[i] == \\'P\\':\\n                p += 1; i += 1\\n            P.append(p + 1)\\n        for x in P[:len(P) - 1]:\\n            cnt = (cnt * x) % int(1e9 + 7)\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    int numberOfWays(string A, VI P = {}, LL cnt = 1) {\\n        int S = count_if(A.begin(), A.end(), [](auto x) { return x == \\'S\\'; });\\n        if (S & 1 || !S)\\n            return 0;\\n        auto [i, N] = make_pair<int>(0, A.size());\\n        while (i < N) {\\n            auto [s, p] = make_pair(0, 0);\\n            while (i < N && s < 2)\\n                s += int(A[i++] == \\'S\\');\\n            while (i < N && A[i] == \\'P\\')\\n                ++p, ++i;\\n            P.push_back(p + 1);\\n        }\\n        for (auto x: VI{ P.begin(), prev(P.end()) })\\n            cnt = (cnt * x) % int(1e9 + 7);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976245,
                "title": "top-down-approach-o-n-java",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final int modulo = 1000000007;\\n    public int numberOfWays(String corridor) {\\n        int seatCount = countSeats(corridor);\\n        if (seatCount < 2 || seatCount % 2 != 0) return 0;\\n        int[][] memo = new int[corridor.length()][3];\\n        for (int[] row: memo) Arrays.fill(row, -1);\\n        return slv(0, 0, seatCount, corridor, memo);\\n    }\\n\\n    private int slv(int n, int currSeats, int target, String corridor, int[][] memo) {\\n        if (n == corridor.length() - 1) return 1;\\n        target -= addSeat(n, corridor);\\n        currSeats += addSeat(n, corridor);\\n        if(target == 0) return 1;\\n        if (currSeats > 2) return 0;\\n        if (memo[n][currSeats] != -1) return memo[n][currSeats];\\n        if (currSeats == 2) {\\n            memo[n][currSeats] = (slv(n + 1, 0, target, corridor, memo) % modulo) +\\n                    (slv(n + 1, currSeats, target, corridor, memo) % modulo);\\n        } else {\\n            memo[n][currSeats] = slv(n + 1, currSeats, target, corridor, memo);\\n        }\\n        return memo[n][currSeats] % modulo;\\n    }\\n\\n    private int addSeat(int n, String corridor) {\\n        return corridor.charAt(n) == \\'S\\' ? 1 : 0;\\n    }\\n\\n    private int countSeats(String corridor) {\\n        int seatCount = 0;\\n        for (char c: corridor.toCharArray()) if (c == \\'S\\') seatCount++;\\n        return seatCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private final int modulo = 1000000007;\\n    public int numberOfWays(String corridor) {\\n        int seatCount = countSeats(corridor);\\n        if (seatCount < 2 || seatCount % 2 != 0) return 0;\\n        int[][] memo = new int[corridor.length()][3];\\n        for (int[] row: memo) Arrays.fill(row, -1);\\n        return slv(0, 0, seatCount, corridor, memo);\\n    }\\n\\n    private int slv(int n, int currSeats, int target, String corridor, int[][] memo) {\\n        if (n == corridor.length() - 1) return 1;\\n        target -= addSeat(n, corridor);\\n        currSeats += addSeat(n, corridor);\\n        if(target == 0) return 1;\\n        if (currSeats > 2) return 0;\\n        if (memo[n][currSeats] != -1) return memo[n][currSeats];\\n        if (currSeats == 2) {\\n            memo[n][currSeats] = (slv(n + 1, 0, target, corridor, memo) % modulo) +\\n                    (slv(n + 1, currSeats, target, corridor, memo) % modulo);\\n        } else {\\n            memo[n][currSeats] = slv(n + 1, currSeats, target, corridor, memo);\\n        }\\n        return memo[n][currSeats] % modulo;\\n    }\\n\\n    private int addSeat(int n, String corridor) {\\n        return corridor.charAt(n) == \\'S\\' ? 1 : 0;\\n    }\\n\\n    private int countSeats(String corridor) {\\n        int seatCount = 0;\\n        for (char c: corridor.toCharArray()) if (c == \\'S\\') seatCount++;\\n        return seatCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704342,
                "title": "c-super-easy-combinatorics-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        vector<int> seats;\\n        for(int i=0; i<corridor.size(); i++){\\n            if(corridor[i] == \\'S\\') seats.push_back(i);\\n        }\\n\\n        int s = seats.size();\\n        if(s == 0 || s&1) return 0;\\n\\n        int ans = 1;\\n        for(int i=2; i<s; i+=2){\\n            ans = 1LL * ans%mod * (seats[i] - seats[i-1])%mod;\\n            ans %= mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nconst int mod = 1e9+7;\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        vector<int> seats;\\n        for(int i=0; i<corridor.size(); i++){\\n            if(corridor[i] == \\'S\\') seats.push_back(i);\\n        }\\n\\n        int s = seats.size();\\n        if(s == 0 || s&1) return 0;\\n\\n        int ans = 1;\\n        for(int i=2; i<s; i+=2){\\n            ans = 1LL * ans%mod * (seats[i] - seats[i-1])%mod;\\n            ans %= mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681867,
                "title": "c-super-easy-memoization-space-optimised-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int mod = 1e9+7;\\nclass Solution {\\nprivate:\\n    int dividers(int index, int seats, string& corridor, vector<vector<int>>& dp){\\n        if(index == corridor.size()) return seats==2;\\n        if(dp[index][seats] != -1) return dp[index][seats];\\n\\n        int total = 0;\\n\\n        if(seats == 2){\\n            if(corridor[index] == \\'P\\'){\\n                int place = dividers(index+1,0,corridor,dp);\\n                int notPlace = dividers(index+1,seats,corridor,dp);\\n                total += (place%mod + notPlace%mod)%mod;\\n            }\\n            else{\\n                total += dividers(index+1,1,corridor,dp)%mod;\\n            }\\n        }\\n        else{\\n            total += dividers(index+1,seats+(corridor[index] == \\'S\\'),corridor,dp)%mod;\\n        }\\n\\n        return dp[index][seats] = total%mod;\\n    }\\npublic:\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        //vector<vector<int>> dp(n+1,vector<int>(3,0));\\n        vector<int> next(3,0);\\n        vector<int> curr(3,0);\\n        next[2] = 1;\\n        for(int index=n-1; index>=0; index--){\\n            for(int seats=2; seats>=0; seats--){\\n                int total = 0;\\n                if(seats == 2){\\n                    if(corridor[index] == \\'P\\'){\\n                        int place = next[0];\\n                        int notPlace = next[seats];\\n                        total += (place%mod + notPlace%mod)%mod;\\n                    }\\n                    else{\\n                        total += next[1]%mod;\\n                    }\\n                }\\n                else{\\n                    total += next[seats+(corridor[index] == \\'S\\')]%mod;\\n                }\\n                curr[seats] = total%mod;\\n            }\\n            next = curr;\\n        }\\n        return next[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nconst int mod = 1e9+7;\\nclass Solution {\\nprivate:\\n    int dividers(int index, int seats, string& corridor, vector<vector<int>>& dp){\\n        if(index == corridor.size()) return seats==2;\\n        if(dp[index][seats] != -1) return dp[index][seats];\\n\\n        int total = 0;\\n\\n        if(seats == 2){\\n            if(corridor[index] == \\'P\\'){\\n                int place = dividers(index+1,0,corridor,dp);\\n                int notPlace = dividers(index+1,seats,corridor,dp);\\n                total += (place%mod + notPlace%mod)%mod;\\n            }\\n            else{\\n                total += dividers(index+1,1,corridor,dp)%mod;\\n            }\\n        }\\n        else{\\n            total += dividers(index+1,seats+(corridor[index] == \\'S\\'),corridor,dp)%mod;\\n        }\\n\\n        return dp[index][seats] = total%mod;\\n    }\\npublic:\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        //vector<vector<int>> dp(n+1,vector<int>(3,0));\\n        vector<int> next(3,0);\\n        vector<int> curr(3,0);\\n        next[2] = 1;\\n        for(int index=n-1; index>=0; index--){\\n            for(int seats=2; seats>=0; seats--){\\n                int total = 0;\\n                if(seats == 2){\\n                    if(corridor[index] == \\'P\\'){\\n                        int place = next[0];\\n                        int notPlace = next[seats];\\n                        total += (place%mod + notPlace%mod)%mod;\\n                    }\\n                    else{\\n                        total += next[1]%mod;\\n                    }\\n                }\\n                else{\\n                    total += next[seats+(corridor[index] == \\'S\\')]%mod;\\n                }\\n                curr[seats] = total%mod;\\n            }\\n            next = curr;\\n        }\\n        return next[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774207,
                "title": "python3-commented-single-pass-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing to recognize is, that we need to split as soon as we hit a multiple of two chairs.\\n\\nAs soon as we need to split the amount of possibilities at after the chair is 1 + amount of plants that come in between. E.G. S|PPS + SP|PS + SPP|S\\n\\nAlso, if we encounter a split it multuplies the previous amount of possibilities by the current one. If we already had three possibilities to split and we encounter two new ones, we have 3*2 possibilities.\\n\\nOther than that we need to take care that we can\\'t split if the amount of chairs is odd. Then we return zero.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI do one pass through all elements and count the amount of chairs. If we have an even amount of chairs we need to check how many plants are in between. As soon as we hit another chair, we multiply with the number of positions between the chairs and it is back to counting chairs.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) - We do one pass through the elements\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n\\n        # go through the corridor and count seats\\n        # after that check whether there are plants\\n        # and we have several places to divide\\n\\n        # go through the chairs and count\\n        chairs = 0\\n        positions = 1\\n        plants = 1\\n        for idx, element in enumerate(corridor):\\n\\n            # check if we reached two chairs\\n            if chairs > 0 and chairs % 2 == 0:\\n\\n                # check if current element is plant\\n                if element == \\'S\\':\\n                    positions *= plants\\n                    plants = 1\\n                \\n                elif element == \\'P\\':\\n                    plants += 1\\n\\n            # count the chairs\\n            if element == \\'S\\':\\n                chairs += 1\\n        return (positions % 1_000_000_007) if chairs > 0 and chairs % 2 == 0 else 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n\\n        # go through the corridor and count seats\\n        # after that check whether there are plants\\n        # and we have several places to divide\\n\\n        # go through the chairs and count\\n        chairs = 0\\n        positions = 1\\n        plants = 1\\n        for idx, element in enumerate(corridor):\\n\\n            # check if we reached two chairs\\n            if chairs > 0 and chairs % 2 == 0:\\n\\n                # check if current element is plant\\n                if element == \\'S\\':\\n                    positions *= plants\\n                    plants = 1\\n                \\n                elif element == \\'P\\':\\n                    plants += 1\\n\\n            # count the chairs\\n            if element == \\'S\\':\\n                chairs += 1\\n        return (positions % 1_000_000_007) if chairs > 0 and chairs % 2 == 0 else 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537718,
                "title": "2147-python",
                "content": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, corridor: str) -> int:\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tans = 1\\n\\t\\t\\tprevi = -1\\n\\t\\t\\tseats = 0\\n\\n\\t\\t\\tfor i,c in enumerate(corridor):\\n\\t\\t\\t\\tif c ==\"S\":\\n\\t\\t\\t\\t\\tseats += 1\\n\\t\\t\\t\\t\\tif seats > 2 and seats%2 == 1:\\n\\t\\t\\t\\t\\t\\tans = ans*(i-previ)%mod\\n\\t\\t\\t\\t\\tprevi = i\\n\\n\\t\\t\\treturn ans if seats > 0 and seats%2 == 0 else 0",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, corridor: str) -> int:\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tans = 1\\n\\t\\t\\tprevi = -1\\n\\t\\t\\tseats = 0\\n\\n\\t\\t\\tfor i,c in enumerate(corridor):\\n\\t\\t\\t\\tif c ==\"S\":\\n\\t\\t\\t\\t\\tseats += 1\\n\\t\\t\\t\\t\\tif seats > 2 and seats%2 == 1:\\n\\t\\t\\t\\t\\t\\tans = ans*(i-previ)%mod\\n\\t\\t\\t\\t\\tprevi = i\\n\\n\\t\\t\\treturn ans if seats > 0 and seats%2 == 0 else 0",
                "codeTag": "Java"
            },
            {
                "id": 2332058,
                "title": "python-simple-sliding-window",
                "content": "the idea is very intuitive.\\nevery time we get a new count of 2 seats, check the immedidate right seats, one can take either 0 or any number of the plants, as long as it is not the last room.\\nwe precompute the right plants for each position first.\\ntime complexity: O(n)\\n\\n```\\ndef numberOfWays(self, corridor: str) -> int:\\n        n=len(corridor)\\n        mod=10**9+7\\n        rightp=[0]*n ## the count of plants to the right of idx\\n        cnt=0\\n        tots=0\\n        for i in range(n-1,-1,-1):\\n            tots+=corridor[i]==\\'S\\'\\n            rightp[i]=cnt\\n            if corridor[i]==\\'P\\':\\n                cnt+=1\\n            else:\\n                cnt=0\\n        if tots<2 or tots%2==1:\\n            return 0\\n        res=1\\n        cnt=0\\n        for i,c in enumerate(corridor):\\n            cnt+=c==\\'S\\'\\n            if cnt==2:\\n                tots-=2\\n                cnt=0\\n                if tots>=2:\\n                    res=(res*(1+rightp[i]))%mod\\n        return res%mod\\n",
                "solutionTags": [],
                "code": "the idea is very intuitive.\\nevery time we get a new count of 2 seats, check the immedidate right seats, one can take either 0 or any number of the plants, as long as it is not the last room.\\nwe precompute the right plants for each position first.\\ntime complexity: O(n)\\n\\n```\\ndef numberOfWays(self, corridor: str) -> int:\\n        n=len(corridor)\\n        mod=10**9+7\\n        rightp=[0]*n ## the count of plants to the right of idx\\n        cnt=0\\n        tots=0\\n        for i in range(n-1,-1,-1):\\n            tots+=corridor[i]==\\'S\\'\\n            rightp[i]=cnt\\n            if corridor[i]==\\'P\\':\\n                cnt+=1\\n            else:\\n                cnt=0\\n        if tots<2 or tots%2==1:\\n            return 0\\n        res=1\\n        cnt=0\\n        for i,c in enumerate(corridor):\\n            cnt+=c==\\'S\\'\\n            if cnt==2:\\n                tots-=2\\n                cnt=0\\n                if tots>=2:\\n                    res=(res*(1+rightp[i]))%mod\\n        return res%mod\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2292381,
                "title": "python3-dp",
                "content": "Count how many plants are between each 2-seat pairs\\nExample: \\nSSPPSS -> 2 plants -> equals to 3 ways to divide\\nSPSPPSS -> also 2 plants are between 2-seat pairs -> 3 ways to divide\\nFrom this example we can see that plants within the 2-seat are not contributing to the ways to divide\\n\\n```\\ndef numberOfWays(self, corridor: str) -> int:\\n        num_seat = 0\\n        ans = 1 # there is one way to divide if seat number is not odd\\n        cur_divider = 1 # cur_divider counts how many plants are between 2-seat pairs\\n        m = 10**9+7\\n        for c in corridor:\\n            if num_seat == 2:\\n                if c==\"S\":\\n                    num_seat = 1\\n                    ans = (ans*cur_divider)%m\\n                    cur_divider = 1\\n                else:\\n                    cur_divider += 1\\n            else:\\n                if c==\"S\":\\n                    num_seat += 1\\n                    \\n        if num_seat != 2:\\n            return 0\\n        else:\\n            return ans%m",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "Count how many plants are between each 2-seat pairs\\nExample: \\nSSPPSS -> 2 plants -> equals to 3 ways to divide\\nSPSPPSS -> also 2 plants are between 2-seat pairs -> 3 ways to divide\\nFrom this example we can see that plants within the 2-seat are not contributing to the ways to divide\\n\\n```\\ndef numberOfWays(self, corridor: str) -> int:\\n        num_seat = 0\\n        ans = 1 # there is one way to divide if seat number is not odd\\n        cur_divider = 1 # cur_divider counts how many plants are between 2-seat pairs\\n        m = 10**9+7\\n        for c in corridor:\\n            if num_seat == 2:\\n                if c==\"S\":\\n                    num_seat = 1\\n                    ans = (ans*cur_divider)%m\\n                    cur_divider = 1\\n                else:\\n                    cur_divider += 1\\n            else:\\n                if c==\"S\":\\n                    num_seat += 1\\n                    \\n        if num_seat != 2:\\n            return 0\\n        else:\\n            return ans%m",
                "codeTag": "Python3"
            },
            {
                "id": 2290394,
                "title": "c-dp-memoization-partition-problem-good-question",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int dp[100005][4];\\n    \\n    ll mod=1e9+7;\\n    \\n    int func(string &s , int i , int n , int count)\\n    {\\n        if(count>2)\\n        {\\n            return 0;\\n        }\\n        \\n        if(i>=n)\\n        {\\n            if(count==2)\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][count]!=-1)\\n        {\\n            return dp[i][count];\\n        }\\n        \\n        if(s[i]==\\'S\\')\\n        {\\n            count++;\\n        }\\n        \\n        if(count>2)\\n        {\\n            return 0;\\n        }\\n        \\n        int ans=0;\\n        \\n        ans=func(s , i+1 , n , count);\\n        \\n        if(count==2)\\n        {\\n            ans = (ans%mod + func(s , i+1 , n , 0)%mod)%mod;\\n        }\\n        \\n        return dp[i][count]=ans;\\n    }\\n    \\n    int numberOfWays(string s) {\\n        \\n        int n=s.size();\\n        \\n        memset(dp , -1 , sizeof(dp));\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'S\\')\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        if(count%2!=0)\\n        {\\n            return 0;\\n        }\\n        \\n         count=0;\\n        \\n        return func(s , 0 , n , count );\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int dp[100005][4];\\n    \\n    ll mod=1e9+7;\\n    \\n    int func(string &s , int i , int n , int count)\\n    {\\n        if(count>2)\\n        {\\n            return 0;\\n        }\\n        \\n        if(i>=n)\\n        {\\n            if(count==2)\\n            {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][count]!=-1)\\n        {\\n            return dp[i][count];\\n        }\\n        \\n        if(s[i]==\\'S\\')\\n        {\\n            count++;\\n        }\\n        \\n        if(count>2)\\n        {\\n            return 0;\\n        }\\n        \\n        int ans=0;\\n        \\n        ans=func(s , i+1 , n , count);\\n        \\n        if(count==2)\\n        {\\n            ans = (ans%mod + func(s , i+1 , n , 0)%mod)%mod;\\n        }\\n        \\n        return dp[i][count]=ans;\\n    }\\n    \\n    int numberOfWays(string s) {\\n        \\n        int n=s.size();\\n        \\n        memset(dp , -1 , sizeof(dp));\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'S\\')\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        if(count%2!=0)\\n        {\\n            return 0;\\n        }\\n        \\n         count=0;\\n        \\n        return func(s , 0 , n , count );\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154402,
                "title": "c-time-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int cntseat = 0, mod = 1000000007;\\n        for(auto &ch : corridor){\\n            if(ch == \\'S\\'){\\n                cntseat++;\\n            }\\n        }\\n        // If count of seats are odd or 0, then it is not possible to divide the corridor as required\\n        if((cntseat%2) or (cntseat == 0)){\\n            return 0;\\n        }\\n        // Do not put any divider\\n        if(cntseat == 2){\\n            return 1;\\n        }\\n        int cnt = 0, last = 0;\\n        long long ans = 1;\\n        // Whenever count of S become odd (!= 1), find the position available between current S and its previous S.(These are the positions where you will place the divider)\\n        for(int i = 0; i < corridor.size(); i++){\\n            if(corridor[i] == \\'S\\'){\\n                cnt++;\\n                if(cnt % 2 == 0){\\n                    last = i;\\n                }\\n                if(cnt%2 != 0 && cnt != 1){\\n                    ans *= (i - last);\\n                    ans %= mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int cntseat = 0, mod = 1000000007;\\n        for(auto &ch : corridor){\\n            if(ch == \\'S\\'){\\n                cntseat++;\\n            }\\n        }\\n        // If count of seats are odd or 0, then it is not possible to divide the corridor as required\\n        if((cntseat%2) or (cntseat == 0)){\\n            return 0;\\n        }\\n        // Do not put any divider\\n        if(cntseat == 2){\\n            return 1;\\n        }\\n        int cnt = 0, last = 0;\\n        long long ans = 1;\\n        // Whenever count of S become odd (!= 1), find the position available between current S and its previous S.(These are the positions where you will place the divider)\\n        for(int i = 0; i < corridor.size(); i++){\\n            if(corridor[i] == \\'S\\'){\\n                cnt++;\\n                if(cnt % 2 == 0){\\n                    last = i;\\n                }\\n                if(cnt%2 != 0 && cnt != 1){\\n                    ans *= (i - last);\\n                    ans %= mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154154,
                "title": "python-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        n=len(s)\\n        c0,c1,c2=0,0,1\\n        for i in range(n-1,-1,-1):\\n            nc1=nc2=nc0=0\\n            nc2+=c1 if s[i]==\\'S\\' else c0\\n            if s[i]==\\'P\\':\\n                nc2+=c2\\n            if s[i]==\\'S\\':\\n                nc1+=c2\\n                nc0+=c1\\n            else:\\n                nc1+=c1\\n                nc0+=c0\\n            c0,c1,c2=nc0,nc1,nc2\\n        return nc0%(10**9+7)\\n```\\nAlso, a 4 liner verison of this......\\n```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        c0,c1,c2=0,0,1\\n        for i in range(len(s)):\\n            c0,c1,c2=(c1 if s[i]==\\'S\\' else c0),(c2 if s[i]==\\'S\\' else c1),(c1 if s[i]==\\'S\\' else c0)+(c2 if s[i]==\\'P\\' else 0)\\n        return c0%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        n=len(s)\\n        c0,c1,c2=0,0,1\\n        for i in range(n-1,-1,-1):\\n            nc1=nc2=nc0=0\\n            nc2+=c1 if s[i]==\\'S\\' else c0\\n            if s[i]==\\'P\\':\\n                nc2+=c2\\n            if s[i]==\\'S\\':\\n                nc1+=c2\\n                nc0+=c1\\n            else:\\n                nc1+=c1\\n                nc0+=c0\\n            c0,c1,c2=nc0,nc1,nc2\\n        return nc0%(10**9+7)\\n```\n```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        c0,c1,c2=0,0,1\\n        for i in range(len(s)):\\n            c0,c1,c2=(c1 if s[i]==\\'S\\' else c0),(c2 if s[i]==\\'S\\' else c1),(c1 if s[i]==\\'S\\' else c0)+(c2 if s[i]==\\'P\\' else 0)\\n        return c0%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028093,
                "title": "python3-dp-detailed-explanation",
                "content": "DP is hard to understand. Referring to Lee215\\'s solution incorporated with my own understanding.\\n\\n\\'c\\' is the current result. If we go to the end, \\'c\\' is the final result.\\n\\'a\\' means \"if 2 more seats added immediately, what will the result be\". \\n\\'b\\' means \"if 1 more seat added immediately, what will the result be\". \\nSuppose we are currently at s[i]==\\'S\\', and even number of seats until now, the result until now is 100, then \\'c\\'=100.\\nThen we add 5 flowers after that, \\'a\\' becomes \\'6\\\\*c\\' because after 5 flowers and 2 seats, the result will become \\'6\\\\*c\\'.\\nThen we add 1 seat after that. \\'c\\' will become \\'b\\' because the \\'1 more seat\\' that \\'b\\' is waiting for has come. \\'b\\' will become \\'a\\', because if adding one more seat immediately, the result will become \\'6\\\\*c\\'. \\'a\\' will become \\'c\\' because adding 2 seats immediately after a seat will not change the currently result c.\\n\\n```\\n    def numberOfWays(self, s: str) -> int:\\n        a, b, c = 1, 0, 0\\n        for ch in s:\\n            if ch == \\'S\\':\\n                a, b, c = b, a, b\\n            elif ch == \\'P\\':\\n\\t\\t\\t\\t# for odd seats, c==0, \\'a\\' will always be 0\\n                a, b, c = 2*c if a==0 else a+c, b, c\\n        return c % (10**9+7)  \\n```",
                "solutionTags": [],
                "code": "```\\n    def numberOfWays(self, s: str) -> int:\\n        a, b, c = 1, 0, 0\\n        for ch in s:\\n            if ch == \\'S\\':\\n                a, b, c = b, a, b\\n            elif ch == \\'P\\':\\n\\t\\t\\t\\t# for odd seats, c==0, \\'a\\' will always be 0\\n                a, b, c = 2*c if a==0 else a+c, b, c\\n        return c % (10**9+7)  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2010322,
                "title": "why-is-this-giving-memory-limit-exceeded",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int mod=1e9+7;\\n    int f(int x,string c)\\n    {\\n        if(x>=c.length())return 1;\\n        int count=0;\\n        int ans=0;\\n        if(dp[x]!=-1)return dp[x];\\n        for(int i=x;i<c.length();i++)\\n        {\\n            if(c[i]==\\'S\\')count++;\\n            if(count==2)\\n            {\\n                int temp=f(i+1,c);\\n                ans=(ans+temp)%mod;\\n            }\\n            else if(count>2)break;\\n        }\\n        return dp[x]=ans;\\n    }\\n    int numberOfWays(string corridor) {\\n        dp=vector<int>(corridor.length()+1,-1);\\n        return f(0,corridor);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int mod=1e9+7;\\n    int f(int x,string c)\\n    {\\n        if(x>=c.length())return 1;\\n        int count=0;\\n        int ans=0;\\n        if(dp[x]!=-1)return dp[x];\\n        for(int i=x;i<c.length();i++)\\n        {\\n            if(c[i]==\\'S\\')count++;\\n            if(count==2)\\n            {\\n                int temp=f(i+1,c);\\n                ans=(ans+temp)%mod;\\n            }\\n            else if(count>2)break;\\n        }\\n        return dp[x]=ans;\\n    }\\n    int numberOfWays(string corridor) {\\n        dp=vector<int>(corridor.length()+1,-1);\\n        return f(0,corridor);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774736,
                "title": "simple-sollution",
                "content": "it\\'s pretty easy problem all we have to do is devide it in parts in which each parts contain 2 seats and then find plants between each of groups and then we can do the partition in muntiplication of (all plants +) beacuse suppose we have two plants in between so we can devide in 3 parts see  first test case and then it\\'s done and some base cases like if n is odd so no answer because we have to devide all the groups  in exactly two seats \\nthanks , if any query comment below sorry for bad english\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, c: str) -> int:\\n        cnt = c.count(\"S\")\\n        if cnt<2 or cnt%2!=0:\\n            return 0\\n        if cnt<=3:\\n            return 1\\n        #p = cnt//2\\n        ans=[]\\n        cnt = 0\\n        p=0\\n        for i in range(len(c)):\\n            if c[i]==\"S\":\\n                if cnt<2:\\n                    cnt+=1\\n                else:\\n                    ans.append(p)\\n                    p=0\\n                    cnt = 1\\n            if c[i]==\"P\":\\n                if cnt==2:\\n                    p+=1\\n        res=1\\n        for i in range(len(ans)):\\n            res*=(ans[i]+1)\\n            res%=(10**9+7)\\n        return res",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "it\\'s pretty easy problem all we have to do is devide it in parts in which each parts contain 2 seats and then find plants between each of groups and then we can do the partition in muntiplication of (all plants +) beacuse suppose we have two plants in between so we can devide in 3 parts see  first test case and then it\\'s done and some base cases like if n is odd so no answer because we have to devide all the groups  in exactly two seats \\nthanks , if any query comment below sorry for bad english\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, c: str) -> int:\\n        cnt = c.count(\"S\")\\n        if cnt<2 or cnt%2!=0:\\n            return 0\\n        if cnt<=3:\\n            return 1\\n        #p = cnt//2\\n        ans=[]\\n        cnt = 0\\n        p=0\\n        for i in range(len(c)):\\n            if c[i]==\"S\":\\n                if cnt<2:\\n                    cnt+=1\\n                else:\\n                    ans.append(p)\\n                    p=0\\n                    cnt = 1\\n            if c[i]==\"P\":\\n                if cnt==2:\\n                    p+=1\\n        res=1\\n        for i in range(len(ans)):\\n            res*=(ans[i]+1)\\n            res%=(10**9+7)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1718171,
                "title": "easy-c-code",
                "content": "class Solution {\\npublic:\\n    \\n    int numberOfWays(string corridor) {\\n        long long mod=1000000007;\\n        int n=corridor.size();\\n        vector<int> v;\\n        long long ans=1;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(corridor[i]==\\'S\\')\\n            {\\n                count++;\\n                v.push_back(i);//WE ARE STORING POSITIONS OF GIVEN SEATS\\n            }\\n        }\\n        if(count%2!=0 || count<2)  // IF NO. OF S IS GIVEN IN SUCH A WAY THAT WE CAN NOT MAKE PAIR OF THEN THEN RETURN 0\\n        {\\n            return 0;\\n        }\\n        for(int i=2;i<v.size();i++)\\n        {\\n            ans=(ans*(v[i]-v[i-1]))%mod;\\n            i++;\\n        }\\n        return ans%mod;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int numberOfWays(string corridor) {\\n        long long mod=1000000007;\\n        int n=corridor.size();\\n        vector<int> v;\\n        long long ans=1;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(corridor[i]==\\'S\\')\\n            {\\n                count++;\\n                v.push_back(i);//WE ARE STORING POSITIONS OF GIVEN SEATS\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1715397,
                "title": "c-easy-solution-with-comments-time-complexity-o-n-and-space-complexity-o-1",
                "content": "```\\nclass Solution\\n{\\npublic:\\n  int numberOfWays(string corridor)\\n  {\\n    int n = corridor.size(); // Size of corridor\\n    int mod = pow(10, 9) + 7; // value of mod\\n    int seat = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n      if (corridor[i] == \\'S\\')\\n        seat++;\\n    }                          // counting total number of seats\\n    if (seat == 0)\\n    {\\n      return 0;\\n    }\\n    if (seat % 2 != 0)\\n    {\\n      return 0;\\n    }                         // if seats are not even , no possible solution is present\\n    seat = 0;                 \\n    long long int total = 1;  // number of total solutions\\n    int plant = 0;\\n    bool start = false;       // bool to check if the plant will be solution or not\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (corridor[i] == \\'S\\')\\n        {\\n          seat++;\\n        }\\n        if (seat == 2)\\n        {\\n          start = true;         // if seats are 2 we can start counting plants\\n          seat = 0;\\n        }                    \\n        if (seat == 1)\\n        {\\n          start = false;\\n          total *= (plant + 1) % mod;\\n          total = total % mod;\\n          plant = 0;              // as we again reach the seat number of ways will be total*(plant+1)\\n        }                        \\n        if (start and corridor[i] == \\'P\\')\\n        {\\n          plant++;\\n        }\\n    }\\n    return total % mod;\\n  }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int numberOfWays(string corridor)\\n  {\\n    int n = corridor.size(); // Size of corridor\\n    int mod = pow(10, 9) + 7; // value of mod\\n    int seat = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n      if (corridor[i] == \\'S\\')\\n        seat++;\\n    }                          // counting total number of seats\\n    if (seat == 0)\\n    {\\n      return 0;\\n    }\\n    if (seat % 2 != 0)\\n    {\\n      return 0;\\n    }                         // if seats are not even , no possible solution is present\\n    seat = 0;                 \\n    long long int total = 1;  // number of total solutions\\n    int plant = 0;\\n    bool start = false;       // bool to check if the plant will be solution or not\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (corridor[i] == \\'S\\')\\n        {\\n          seat++;\\n        }\\n        if (seat == 2)\\n        {\\n          start = true;         // if seats are 2 we can start counting plants\\n          seat = 0;\\n        }                    \\n        if (seat == 1)\\n        {\\n          start = false;\\n          total *= (plant + 1) % mod;\\n          total = total % mod;\\n          plant = 0;              // as we again reach the seat number of ways will be total*(plant+1)\\n        }                        \\n        if (start and corridor[i] == \\'P\\')\\n        {\\n          plant++;\\n        }\\n    }\\n    return total % mod;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713983,
                "title": "greedy-solution-c",
                "content": "This question can be using two approaches one is DP which is kind of more intutive than the Greedy approach.\\n\\nNOTE:- the DP solution can be further optimised to O(n)\\n\\nHere is the recursive + memoized version (intutive approach) :- \\n\\n\\t\\'\\'\\'\\n\\t lli help(string corridor,int index,vector<lli>&dp){\\n        int n = corridor.size();\\n        if(index== n){\\n            return 1;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int seats =0;\\n        lli ans=0;\\n        for(int i=index;i<n;i++){\\n            if(corridor[i]==\\'S\\'){\\n                seats++;\\n            }\\n            if(seats>2){\\n                break;\\n            }\\n            if(seats==2){\\n                ans+=help(corridor,i+1,dp);\\n                ans%=MOD;\\n            }\\n        }\\n        return dp[index]=ans;\\n        \\n    }\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        vector<lli> dp(n+5,-1);\\n        return (int)help(corridor,0,dp);\\n    }\\n\\t\\n\\t\\'\\'\\'\\n\\t\\n\\t\\nbut it can be further omptimized using the greedy approach what i have done in this approach is to traverse from the back of string and calculate how many ways are there to consider 2 seats (answer to this problem is the of plants that lies at position greater that those two seats) we can mutiply such small answers to get are final answer\\n\\nNOTE:- for the last two seats in the string the answer is 1\\n\\n\\t\\'\\'\\'\\n\\t\\tbool check(string s){\\n        int ans=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'S\\'){\\n                ans++;\\n            }\\n        }\\n        return ans%2==0;\\n    }\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        lli ans=0;\\n        if(!check(corridor)){\\n            return 0;\\n        }\\n        int i=n-1;\\n        int cnt=0;\\n        for(;i>=0;i--){\\n            if(corridor[i]==\\'S\\'){\\n                cnt++;\\n            }\\n            if(cnt==2){\\n                break;\\n            }\\n        }\\n        if(cnt<2){\\n            return 0;\\n        }\\n        ans++;\\n        i--;\\n        for(;i>=0;){\\n            //int s = i;\\n            lli cntplants=0;\\n            int cntseats=0;\\n            bool firstseatfound  = false;\\n            bool bothseatfound=false;\\n            while(i>=0&&cntseats<2){\\n                if(!firstseatfound&&corridor[i]==\\'P\\'){\\n                    cntplants++;\\n                }\\n                if(corridor[i]==\\'S\\'){\\n                    if(firstseatfound){\\n                        bothseatfound=true;\\n                    }\\n                    firstseatfound=true;\\n                    cntseats++;\\n                }\\n                i--;\\n            }\\n            if(bothseatfound){\\n            ans = (ans*(cntplants+1))%MOD;}\\n        }\\n        return (int)ans;\\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "This question can be using two approaches one is DP which is kind of more intutive than the Greedy approach.\\n\\nNOTE:- the DP solution can be further optimised to O(n)\\n\\nHere is the recursive + memoized version (intutive approach) :- \\n\\n\\t\\'\\'\\'\\n\\t lli help(string corridor,int index,vector<lli>&dp){\\n        int n = corridor.size();\\n        if(index== n){\\n            return 1;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int seats =0;\\n        lli ans=0;\\n        for(int i=index;i<n;i++){\\n            if(corridor[i]==\\'S\\'){\\n                seats++;\\n            }\\n            if(seats>2){\\n                break;\\n            }\\n            if(seats==2){\\n                ans+=help(corridor,i+1,dp);\\n                ans%=MOD;\\n            }\\n        }\\n        return dp[index]=ans;\\n        \\n    }\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        vector<lli> dp(n+5,-1);\\n        return (int)help(corridor,0,dp);\\n    }\\n\\t\\n\\t\\'\\'\\'\\n\\t\\n\\t\\nbut it can be further omptimized using the greedy approach what i have done in this approach is to traverse from the back of string and calculate how many ways are there to consider 2 seats (answer to this problem is the of plants that lies at position greater that those two seats) we can mutiply such small answers to get are final answer\\n\\nNOTE:- for the last two seats in the string the answer is 1\\n\\n\\t\\'\\'\\'\\n\\t\\tbool check(string s){\\n        int ans=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'S\\'){\\n                ans++;\\n            }\\n        }\\n        return ans%2==0;\\n    }\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        lli ans=0;\\n        if(!check(corridor)){\\n            return 0;\\n        }\\n        int i=n-1;\\n        int cnt=0;\\n        for(;i>=0;i--){\\n            if(corridor[i]==\\'S\\'){\\n                cnt++;\\n            }\\n            if(cnt==2){\\n                break;\\n            }\\n        }\\n        if(cnt<2){\\n            return 0;\\n        }\\n        ans++;\\n        i--;\\n        for(;i>=0;){\\n            //int s = i;\\n            lli cntplants=0;\\n            int cntseats=0;\\n            bool firstseatfound  = false;\\n            bool bothseatfound=false;\\n            while(i>=0&&cntseats<2){\\n                if(!firstseatfound&&corridor[i]==\\'P\\'){\\n                    cntplants++;\\n                }\\n                if(corridor[i]==\\'S\\'){\\n                    if(firstseatfound){\\n                        bothseatfound=true;\\n                    }\\n                    firstseatfound=true;\\n                    cntseats++;\\n                }\\n                i--;\\n            }\\n            if(bothseatfound){\\n            ans = (ans*(cntplants+1))%MOD;}\\n        }\\n        return (int)ans;\\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1713279,
                "title": "simple-solution-c-o-n",
                "content": "first of  all one observaion is that it is given in each partition there should be two seats , so if there are odd number of seats then clearly number of ways to make partition is zero.\\n\\nwait wait there is another case when answer should be zero (guess what) --> when no of seats are zero.\\n\\nnow we will be storing the indices of seats in the vector seats and then we will just iterate our seats vector by jump length of 2 and calculate how many plants are in between these seats as (no of plants + 1 == no of room dividers that can be placed).\\n\\nso here is my simple c++ solution :\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n      \\n        vector<int> seats;\\n        int  n = s.size();\\n        for(int  i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'S\\')\\n                seats.push_back(i);\\n        }\\n       \\n        if(seats.size()%2)\\n        {\\n            return 0;\\n        }\\n        if(seats.size()<=1)\\n        {\\n            return 0;\\n        }\\n        const int MOD  = 1e9  +7;\\n        long long ans  = 1LL;\\n        for(int  i = 2;i<seats.size();i+=2)\\n        {\\n            int val = seats[i] - seats[i-1];\\n            ans = (ans * 1LL * val);\\n            ans%=MOD;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nTime Complexity : O(n)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n      \\n        vector<int> seats;\\n        int  n = s.size();\\n        for(int  i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'S\\')\\n                seats.push_back(i);\\n        }\\n       \\n        if(seats.size()%2)\\n        {\\n            return 0;\\n        }\\n        if(seats.size()<=1)\\n        {\\n            return 0;\\n        }\\n        const int MOD  = 1e9  +7;\\n        long long ans  = 1LL;\\n        for(int  i = 2;i<seats.size();i+=2)\\n        {\\n            int val = seats[i] - seats[i-1];\\n            ans = (ans * 1LL * val);\\n            ans%=MOD;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713191,
                "title": "c-greedy-o-n-explanation",
                "content": "Approach is :  Make groups of adjacent pair seats\\nConsider example,\\n\\n```\\nIndex:     0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19\\nCorridor:  P  P  S  P  S  P  P  S  S  P   P   P   S   P   P   P   P   S   P   P \\n```\\n\\nSo here , **2-4** seats are one pair/group **(G1)** , and **7-8** are one pair/group **(G2)** and finally **12-17** as third group/pair **(G3)**\\n\\nIf number of seats are odd or 0 , then no pairs/division cannot be made so return 0 in that case.\\nNow, \\nIf we rewrite above Corridor   **P  P S   P S   P  P  S  S  P   P    P    S    P   P    P    P    S     P   P**  as  **P P G1 P P G2 P P P G3 P P**  \\n\\nHere answer will be 3*4 = 12 , why??\\nSee\\n                 \\n**P P G1 P P G2 P P P G3 P P**  \\n               ^ ^        \\n             These will contribute to 3 ie (2+1) , ie 2 continious occuring plants\\n\\t\\t\\t \\n**P P G1 P P G2 P P P G3 P P**  \\n                           ^ ^ ^ \\n             These will contribute to 4 ie (3+1), ie 3 continious occuring plants \\n\\nSo multiplication of all such occurence ie 3*4 = 12.\\n\\nOverall , **continious plants at start and at end will not matter** beacuse we are not allowed to put barrier there,\\n\\n\\nQues: Why 3 continious plants will contribute 4?\\n:: \\n\\tHere in this example possible places to put barrier are,\\n\\t\\tG1  P   P  P  G2\\n            ^  ^  ^  ^ \\nSo for 3 plants, we have option to put barrier at 4 places. \\n\\n\\nCode:\\nCount number of plants between groups and keep multipling them to count.\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n     \\n        int seats=0,mod = 1000000007,prev =-1;\\n        long long int count=1;\\n        \\n      for(int i=0;i<corridor.size();i++)\\n      {\\n          if(corridor[i]==\\'S\\')\\n          {\\n              seats++;\\n              if(seats%2==1)\\n              {\\n                    if(prev!=-1)\\n                        count = (count * (i-prev))%mod;\\n              }\\n              else\\n                  prev=i;\\n              \\n          }\\n              \\n      }\\n\\n        if(seats%2==1||seats==0)\\n            return 0;\\n        return count;\\n     \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nIndex:     0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19\\nCorridor:  P  P  S  P  S  P  P  S  S  P   P   P   S   P   P   P   P   S   P   P \\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n     \\n        int seats=0,mod = 1000000007,prev =-1;\\n        long long int count=1;\\n        \\n      for(int i=0;i<corridor.size();i++)\\n      {\\n          if(corridor[i]==\\'S\\')\\n          {\\n              seats++;\\n              if(seats%2==1)\\n              {\\n                    if(prev!=-1)\\n                        count = (count * (i-prev))%mod;\\n              }\\n              else\\n                  prev=i;\\n              \\n          }\\n              \\n      }\\n\\n        if(seats%2==1||seats==0)\\n            return 0;\\n        return count;\\n     \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712821,
                "title": "c-dp-memoization",
                "content": "The first thought that came to my mind was to explore on the DP approach, so I went ahead with it. Greedy works as well in this case. Let me know if there are any doubts!\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll n, mod = 1e9 + 7; \\n    vector<ll> dp; \\n    \\n    ll memo(string & corridor, int start, int seats){\\n        if(start == n ) return seats == 2; \\n        if(dp[start] != -1) return dp[start]; \\n        ll res = 0, count = 0, i = start; \\n        while(i < n && count != 2){\\n            if(corridor[i++] == \\'S\\') count ++; \\n        }\\n        res = memo(corridor, i, count); \\n        ll peas = 0; \\n        while(i<n && corridor[i] != \\'S\\'){\\n            peas ++; \\n            i ++; \\n        }\\n        if(i == n && corridor.back() == \\'P\\') peas = 1; \\n        res = (res + (peas*memo(corridor, i, count))%mod) %mod; \\n        return dp[start] = res; \\n    }\\n    \\n    int numberOfWays(string corridor) {\\n        n = corridor.size(); \\n        dp.resize(n, -1); \\n        return memo(corridor, 0, 0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll n, mod = 1e9 + 7; \\n    vector<ll> dp; \\n    \\n    ll memo(string & corridor, int start, int seats){\\n        if(start == n ) return seats == 2; \\n        if(dp[start] != -1) return dp[start]; \\n        ll res = 0, count = 0, i = start; \\n        while(i < n && count != 2){\\n            if(corridor[i++] == \\'S\\') count ++; \\n        }\\n        res = memo(corridor, i, count); \\n        ll peas = 0; \\n        while(i<n && corridor[i] != \\'S\\'){\\n            peas ++; \\n            i ++; \\n        }\\n        if(i == n && corridor.back() == \\'P\\') peas = 1; \\n        res = (res + (peas*memo(corridor, i, count))%mod) %mod; \\n        return dp[start] = res; \\n    }\\n    \\n    int numberOfWays(string corridor) {\\n        n = corridor.size(); \\n        dp.resize(n, -1); \\n        return memo(corridor, 0, 0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712615,
                "title": "c-easy",
                "content": "# This is my 900th accepted solution in LC\\nthe vector P at a given index i will have how many consecutive Ps will have till there is the next **S**\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int>P(n,0);\\n        int count = 1;\\n        int seats = 0;\\n        int total_seat = 0;\\n        int mod = 1e9 + 7;\\n        if(s[n - 1] == \\'P\\')\\n            P[n - 1] = 1;\\n        else\\n            total_seat++;\\n        for(int i = n - 2; i >= 0 ; i--)\\n        {\\n            if(s[i] == \\'P\\')\\n                P[i] = 1 + P[i + 1];\\n            else\\n                total_seat++;\\n        }\\n        if(total_seat == 2)\\n            return 1;\\n        \\n        if(total_seat % 2 == 1 or total_seat == 0)\\n            return 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'S\\')\\n            {\\n                seats++;\\n                total_seat--;\\n                if(seats == 2)\\n                {\\n                    seats = 0;\\n                    count  = (1ll*count % mod * 1ll*(P[i + 1] + 1) % mod ) % mod;\\n                }\\n                 if(total_seat == 2)\\n                     break;\\n            }   \\n        }\\n        return count;\\n    }\\n};\\n```\\n**please UPVOTE I really wanna know if this was not really a hard question or I am improving lol**\\n",
                "solutionTags": [
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int>P(n,0);\\n        int count = 1;\\n        int seats = 0;\\n        int total_seat = 0;\\n        int mod = 1e9 + 7;\\n        if(s[n - 1] == \\'P\\')\\n            P[n - 1] = 1;\\n        else\\n            total_seat++;\\n        for(int i = n - 2; i >= 0 ; i--)\\n        {\\n            if(s[i] == \\'P\\')\\n                P[i] = 1 + P[i + 1];\\n            else\\n                total_seat++;\\n        }\\n        if(total_seat == 2)\\n            return 1;\\n        \\n        if(total_seat % 2 == 1 or total_seat == 0)\\n            return 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'S\\')\\n            {\\n                seats++;\\n                total_seat--;\\n                if(seats == 2)\\n                {\\n                    seats = 0;\\n                    count  = (1ll*count % mod * 1ll*(P[i + 1] + 1) % mod ) % mod;\\n                }\\n                 if(total_seat == 2)\\n                     break;\\n            }   \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712545,
                "title": "java-o-n-simple-greedy-solution",
                "content": "1) There is no solution possible if the number of seats (\\'S\\') are less than 2 or not divisible by 2, hence return 0 in this case.\\n2) We basically need to group 2 seats together and find the number of plants between any two pair of seats. For example, In the testcase: \"SSPPSPS\", there are 2 plants between the two pair of seats. Now there are 2+1 ways of adding a divider.\\n3) Similarly we will find the number of plants between two consecutive pairs of seats and multiply them to find the answer. \\n4) Please Like, Share and Comment if you got my solution :)\\n\\n```\\nclass Solution \\n{\\n    public int numberOfWays(String str) \\n    {\\n        int n = str.length();\\n        long ans = 1;\\n        int mod = (int)1e9+7;\\n        int ss = 0;\\n        for(int i=0; i<n; i++)\\n            if(str.charAt(i) == \\'S\\')\\n                ss++;\\n        if(ss < 2 || ss % 2 != 0)\\n            return 0;\\n        ss = 0;\\n        int i = 0;\\n        while(i < n)\\n        {\\n            if(str.charAt(i) == \\'S\\')\\n               ss++;\\n            if(ss == 2)\\n            {\\n                ss = 0;\\n                int j = i+1;\\n                while(j < n && str.charAt(j) == \\'P\\')\\n                    j++;\\n                if(j == n)\\n                    break;\\n                ans *= (j-i);\\n                ans %= mod;\\n                i = j;\\n            }\\n            else\\n                i++;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int numberOfWays(String str) \\n    {\\n        int n = str.length();\\n        long ans = 1;\\n        int mod = (int)1e9+7;\\n        int ss = 0;\\n        for(int i=0; i<n; i++)\\n            if(str.charAt(i) == \\'S\\')\\n                ss++;\\n        if(ss < 2 || ss % 2 != 0)\\n            return 0;\\n        ss = 0;\\n        int i = 0;\\n        while(i < n)\\n        {\\n            if(str.charAt(i) == \\'S\\')\\n               ss++;\\n            if(ss == 2)\\n            {\\n                ss = 0;\\n                int j = i+1;\\n                while(j < n && str.charAt(j) == \\'P\\')\\n                    j++;\\n                if(j == n)\\n                    break;\\n                ans *= (j-i);\\n                ans %= mod;\\n                i = j;\\n            }\\n            else\\n                i++;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712132,
                "title": "python-greedy-o-n-time-o-1-space",
                "content": "**Base Cases**\\n* There is no way of dividing seats into equal blocks (i.e Two seats in each block), if the number of seats are odd.\\n* Also cant divide if number of seats are zero.\\n\\n**General Case**\\n* The Idea is to traverse the String and count for the intermediate plants in between two consecutive blocks.\\n* To make it easy, count the number of plants after two seats until a new seat arrived and multiply the existing answer with number of plants, so on until the end of string.\\n\\n**Idea Behind Multiplication**\\nFor Example: s = \"SSPPSPSPSS\"\\n\\nPossible dividors for first block are:\\n* \\t\\t\\t\\t\\tSS|PPSPS|PSS\\n* \\t\\t\\t\\t\\tSSP|PSPS|PSS\\n* \\t\\t\\t\\t\\tSSPP|SPS|PSS\\n\\nPossible dividors for second block are:\\n* \\t\\t\\t\\t   SS|PPSPSP|SS\\n* \\t\\t\\t\\t   SSP|PSPSP|SS\\n* \\t\\t\\t\\t   SSPP|SPSP|SS\\n\\nTotal blocks are 6\\nOtherwise, Multiplication of plants in First block and Second block\\n\\n**PYTHON**\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        n = len(corridor)\\n        scount = 0 # count the number of seats\\n        for i in range(n):\\n            if corridor[i] == \"S\":\\n                scount += 1\\n        \\n        # return 0 if number of seats are odd (or) zero\\n        if scount % 2 != 0 or scount == 0:\\n            return 0\\n        \\n        # count number of plants in between two dividors\\n        ans, seats, plants = 1, 0, 0\\n        for i in range(n): \\n            if seats == 2 and corridor[i] == \"P\":\\n                plants += 1\\n            elif seats == 2 and corridor[i] == \"S\":\\n                ans = ans * (plants + 1) # answer is combinations of number of plants\\n                plants = 0\\n                seats = 1\\n            elif corridor[i] == \"S\":\\n                seats += 1\\n        return ans % ((10 ** 9) + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        n = len(corridor)\\n        scount = 0 # count the number of seats\\n        for i in range(n):\\n            if corridor[i] == \"S\":\\n                scount += 1\\n        \\n        # return 0 if number of seats are odd (or) zero\\n        if scount % 2 != 0 or scount == 0:\\n            return 0\\n        \\n        # count number of plants in between two dividors\\n        ans, seats, plants = 1, 0, 0\\n        for i in range(n): \\n            if seats == 2 and corridor[i] == \"P\":\\n                plants += 1\\n            elif seats == 2 and corridor[i] == \"S\":\\n                ans = ans * (plants + 1) # answer is combinations of number of plants\\n                plants = 0\\n                seats = 1\\n            elif corridor[i] == \"S\":\\n                seats += 1\\n        return ans % ((10 ** 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710303,
                "title": "c-greedy-approach-o-n",
                "content": "```\\n #define mod 1000000007     \\n    int numberOfWays(string corridor) {\\n    long long m=corridor.length(),count=1;\\n    vector<int> seats; //stores indices of all seats\\n    for (int i = 0; i < m; i++) { \\n        if (corridor[i] == \\'S\\') {\\n            seats.push_back(i);\\n        }\\n    }\\n    int n = seats.size();\\n\\n    if (n==0 || n%2!=0) {\\n        return 0;\\n    }\\n\\n//seats[i]-seats[i-1] will give us number of Ps between each pair of S\\n    for (int i = 2; i < n; i += 2) {\\n        count = (count * (seats[i]- seats[i - 1]))%mod;\\n    }\\n\\n    return count;\\n    \\n    }\\n```\\nHope you found this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n #define mod 1000000007     \\n    int numberOfWays(string corridor) {\\n    long long m=corridor.length(),count=1;\\n    vector<int> seats; //stores indices of all seats\\n    for (int i = 0; i < m; i++) { \\n        if (corridor[i] == \\'S\\') {\\n            seats.push_back(i);\\n        }\\n    }\\n    int n = seats.size();\\n\\n    if (n==0 || n%2!=0) {\\n        return 0;\\n    }\\n\\n//seats[i]-seats[i-1] will give us number of Ps between each pair of S\\n    for (int i = 2; i < n; i += 2) {\\n        count = (count * (seats[i]- seats[i - 1]))%mod;\\n    }\\n\\n    return count;\\n    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710294,
                "title": "cpp-easy-to-understand-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numberOfWays(string co) {\\n        int n=co.size();\\n        int mod=1e9+7;\\n        vector<long long> v;\\n        long long c=0,flag=0,cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(co[i]==\\'S\\')\\n            {\\n                if(c==2)\\n                {\\n                    flag=0;\\n                    v.push_back(cnt);\\n                    c=1;\\n                    cnt=0;\\n                }\\n                else if(c==1)\\n                {\\n                    flag=1;\\n                    c=2;\\n                    cnt=1;\\n                }\\n                else\\n                    c++;\\n            }\\n            else\\n            {\\n                if(c==2)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        if(c!=2)\\n            return 0;\\n        if(v.size()==0&&c==2)\\n            return 1;\\n        if(v.size()==0)\\n            return 0;\\n        long long ans=1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans=(ans*v[i])%mod;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numberOfWays(string co) {\\n        int n=co.size();\\n        int mod=1e9+7;\\n        vector<long long> v;\\n        long long c=0,flag=0,cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(co[i]==\\'S\\')\\n            {\\n                if(c==2)\\n                {\\n                    flag=0;\\n                    v.push_back(cnt);\\n                    c=1;\\n                    cnt=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1710269,
                "title": "dp-c-o-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9 + 7;\\n    int dp[100001][3];\\n    int solve(int ind, string &s, int curr)\\n    {\\n        if(curr>2)return 0;\\n        if(ind==s.size())\\n        {\\n            if(curr==2)return 1;\\n            return 0;\\n        }\\n        if(dp[ind][curr]!=-1)return dp[ind][curr];\\n        if(s[ind]==\\'S\\')curr++;\\n        if(curr>2)return 0;\\n        int ans=0;\\n        ans=solve(ind+1,s,curr);\\n        if(curr==2)\\n        {\\n            ans=(ans+solve(ind+1,s,0))%mod;\\n        }\\n        return dp[ind][curr]=ans%mod;\\n    }\\n    int numberOfWays(string s) {\\n        int n=s.size();\\n        int total=0;\\n        for(auto c: s)if(c==\\'S\\')total++;\\n        if(total%2)return 0;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,s,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9 + 7;\\n    int dp[100001][3];\\n    int solve(int ind, string &s, int curr)\\n    {\\n        if(curr>2)return 0;\\n        if(ind==s.size())\\n        {\\n            if(curr==2)return 1;\\n            return 0;\\n        }\\n        if(dp[ind][curr]!=-1)return dp[ind][curr];\\n        if(s[ind]==\\'S\\')curr++;\\n        if(curr>2)return 0;\\n        int ans=0;\\n        ans=solve(ind+1,s,curr);\\n        if(curr==2)\\n        {\\n            ans=(ans+solve(ind+1,s,0))%mod;\\n        }\\n        return dp[ind][curr]=ans%mod;\\n    }\\n    int numberOfWays(string s) {\\n        int n=s.size();\\n        int total=0;\\n        for(auto c: s)if(c==\\'S\\')total++;\\n        if(total%2)return 0;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710268,
                "title": "c-clean-and-concise-o-n-time-o-1-space",
                "content": "PLEASE UPVOTE IF YOU FIND IT HELPFUL!\\nALSO IF YOU HAVE ANY QUERIES/DOUBTS , FEEL FREE TO ASK IN COMMENT SECTION BELOW!!\\n```\\nint numberOfWays(string c) {\\n    int s=0,div=1; //s is number of sofa and div is number of divisions/partitions\\n    long long ans=1;\\n    for(int i=0;i<c.length();i++)\\n    {if(c[i]==\\'S\\' && s==2)\\n        {   s=0;\\n            ans*=div;\\n            ans=ans%1000000007;\\n            div=1;\\n        }\\n            if(c[i]==\\'S\\')\\n                s++,div=1;\\n            else\\n            div++;    }\\n        \\n        if(s!=2)\\n            return 0;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numberOfWays(string c) {\\n    int s=0,div=1; //s is number of sofa and div is number of divisions/partitions\\n    long long ans=1;\\n    for(int i=0;i<c.length();i++)\\n    {if(c[i]==\\'S\\' && s==2)\\n        {   s=0;\\n            ans*=div;\\n            ans=ans%1000000007;\\n            div=1;\\n        }\\n            if(c[i]==\\'S\\')\\n                s++,div=1;\\n            else\\n            div++;    }\\n        \\n        if(s!=2)\\n            return 0;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710028,
                "title": "easy-python-o-n-time-and-o-n-space-complexity-with-explanation",
                "content": "eg. \"SSPPSPSPPSS\"\\n\\n* Maintain the indices of all the seats ->here [0,1,4,6,9,10]\\n* The difference between the indices give us the number of plants\\n* We are concerned with number of plants between each section (group of 2 seats)\\n* We can place the divider in (number of plants + 1) ways between 2 sections, say P1 ways between section 1 and 2, P2 ways between section 2 and 3 -> here P1 = 3 and P2 =3\\n* Using counting principle P1 * P2 ... Pn we get the total number of ways -> 3 * 3 = 9\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        seat_idx = list()\\n        for i in range(len(corridor)):\\n            if corridor[i] == \\'S\\':\\n                seat_idx.append(i)\\n                \\n        if len(seat_idx) == 0 or len(seat_idx) % 2:\\n\\t\\t# if there are 0 or odd number of seats, we cannot divide sections with 2 seats each\\n            return 0\\n        \\n        ways = 1\\n        \\n        for i in range(2, len(seat_idx)-1, 2):  # ignore first and last seat\\n            ways *= seat_idx[i] - seat_idx[i-1]\\n        \\n        return ways % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        seat_idx = list()\\n        for i in range(len(corridor)):\\n            if corridor[i] == \\'S\\':\\n                seat_idx.append(i)\\n                \\n        if len(seat_idx) == 0 or len(seat_idx) % 2:\\n\\t\\t# if there are 0 or odd number of seats, we cannot divide sections with 2 seats each\\n            return 0\\n        \\n        ways = 1\\n        \\n        for i in range(2, len(seat_idx)-1, 2):  # ignore first and last seat\\n            ways *= seat_idx[i] - seat_idx[i-1]\\n        \\n        return ways % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710027,
                "title": "burst-balloons-memo-intuitive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[100001][5];\\n    int solve(string& s, int start, int curr)\\n    {\\n        int mod = pow(10,9)+7;\\n        int n = s.size();\\n        if(curr>2) return 0;\\n        if(start==n-1)\\n        {\\n            curr+=(s[start]==\\'S\\'?1:0);\\n            if(curr==2)\\n                return 1;\\n            else return 0;\\n        }\\n        if(memo[start][curr]!=-1) return memo[start][curr];\\n        int ans;\\n        if(curr<2)\\n        {\\n            ans = solve(s,start+1,curr+(s[start]==\\'S\\'?1:0))%mod;\\n        }\\n        else\\n        if(curr==2)\\n        {\\n            if(s[start]==\\'P\\')\\n                ans = (solve(s,start+1,curr)%mod+solve(s,start+1,0)%mod)%mod;\\n            else\\n            {\\n                ans = solve(s,start+1,0+s[start]==\\'S\\'?1:0);\\n            }\\n                \\n        }\\n        return memo[start][curr] = ans;\\n    }\\n    \\n\\n    int numberOfWays(string s) {\\n        int n = s.size();\\n        memset(memo,-1,sizeof(memo));\\n  \\n        if(n<2) return 0;\\n       return solve(s,0,0);\\n       \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int memo[100001][5];\\n    int solve(string& s, int start, int curr)\\n    {\\n        int mod = pow(10,9)+7;\\n        int n = s.size();\\n        if(curr>2) return 0;\\n        if(start==n-1)\\n        {\\n            curr+=(s[start]==\\'S\\'?1:0);\\n            if(curr==2)\\n                return 1;\\n            else return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1709946,
                "title": "java-easy-solution-just-by-observation",
                "content": "```\\nclass Solution {\\n    int pre[];\\n    public int numberOfWays(String corridor) {\\n        int n=corridor.length();\\n        long mod=(long)1e9+7;\\n        int totalSeats=0;\\n        pre=new int[n];\\n        for(int i=0;i<corridor.length();i++){\\n\\n            if(corridor.charAt(i)==\\'S\\')totalSeats++;\\n        }\\n        \\n\\n        if(totalSeats==2)return 1;//if total seats are 2 only one possible distribution\\n        if(totalSeats<=1||totalSeats%2!=0)return 0;// if total seats are less than 1 or are odd no possible way to distribute exactly 2 seats.\\n        int count=0;//Number of seats in current partition\\n        long ans=1;\\n        int cc=1;//current Count for valid partions between recent 2 seats group and upcoming recent 2 seats group\\n        for(int i=0;i<corridor.length();i++){\\n            if(corridor.charAt(i)==\\'S\\'){\\n                count++;//seat Count\\n            }\\n            if(count==2){//set of 2 seats found\\n                int j=i+1;\\n                while(j<n&&corridor.charAt(j)!=\\'S\\'){// All the positions where I can place partition\\n                    j++;cc++;\\n                }\\n                \\n                if(j!=n)ans=((ans%mod)*(cc%mod));\\n                cc=1;\\n                i=j-1;\\n                count=0;\\n            }\\n\\n            \\n        }\\n        return(int) (ans%mod);\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int pre[];\\n    public int numberOfWays(String corridor) {\\n        int n=corridor.length();\\n        long mod=(long)1e9+7;\\n        int totalSeats=0;\\n        pre=new int[n];\\n        for(int i=0;i<corridor.length();i++){\\n\\n            if(corridor.charAt(i)==\\'S\\')totalSeats++;\\n        }\\n        \\n\\n        if(totalSeats==2)return 1;//if total seats are 2 only one possible distribution\\n        if(totalSeats<=1||totalSeats%2!=0)return 0;// if total seats are less than 1 or are odd no possible way to distribute exactly 2 seats.\\n        int count=0;//Number of seats in current partition\\n        long ans=1;\\n        int cc=1;//current Count for valid partions between recent 2 seats group and upcoming recent 2 seats group\\n        for(int i=0;i<corridor.length();i++){\\n            if(corridor.charAt(i)==\\'S\\'){\\n                count++;//seat Count\\n            }\\n            if(count==2){//set of 2 seats found\\n                int j=i+1;\\n                while(j<n&&corridor.charAt(j)!=\\'S\\'){// All the positions where I can place partition\\n                    j++;cc++;\\n                }\\n                \\n                if(j!=n)ans=((ans%mod)*(cc%mod));\\n                cc=1;\\n                i=j-1;\\n                count=0;\\n            }\\n\\n            \\n        }\\n        return(int) (ans%mod);\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709925,
                "title": "c-easy-answer-o-n",
                "content": "```\\nCounted the number of plants = pc, between every possible place where divider can be placed (that is, between every even seat and the next seat). \\nThere are pc+1 ways to place dividers. Multiply everytime to get answer\\n```\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string c) {\\n        long mod = 1e9 + 7;\\n        long res = 0;\\n        int count = 0; //int flag = 0;\\n        for(int i=0; i<c.size(); i++){\\n            if(c[i]==\\'S\\') count++;\\n        }\\n        if(count%2 or count<2) return 0;\\n        res = 1;\\n        int pc = 0; //plant counter\\n        int sc = 0; //seat counter\\n        \\n        for(int i=0; i<c.size(); i++){\\n            if(sc%2 == 0 and sc<count and sc>0){\\n                if(c[i] == \\'P\\') pc++;\\n            }\\n            \\n            if(c[i] == \\'S\\') sc++;\\n            if(sc%2) {\\n                res*= (long)(pc+1);\\n                res%=mod;\\n                pc = 0;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nCounted the number of plants = pc, between every possible place where divider can be placed (that is, between every even seat and the next seat). \\nThere are pc+1 ways to place dividers. Multiply everytime to get answer\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string c) {\\n        long mod = 1e9 + 7;\\n        long res = 0;\\n        int count = 0; //int flag = 0;\\n        for(int i=0; i<c.size(); i++){\\n            if(c[i]==\\'S\\') count++;\\n        }\\n        if(count%2 or count<2) return 0;\\n        res = 1;\\n        int pc = 0; //plant counter\\n        int sc = 0; //seat counter\\n        \\n        for(int i=0; i<c.size(); i++){\\n            if(sc%2 == 0 and sc<count and sc>0){\\n                if(c[i] == \\'P\\') pc++;\\n            }\\n            \\n            if(c[i] == \\'S\\') sc++;\\n            if(sc%2) {\\n                res*= (long)(pc+1);\\n                res%=mod;\\n                pc = 0;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709851,
                "title": "permutation-combination-c-simple-code",
                "content": "Approach:-\\n1. Find start and end of the subarrays which have two sofas, observe that irrespective of what partition you make, the same set of sofas will be together only the plants would change.\\n2. If there are \"a\" plants between two pairs - partition can be made in (a+1) ways \\n3. Ans is multiplied with the number of divisions possible. \\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        \\n        int n = corridor.size();\\n        long long mod = 1e9 + 7;\\n        vector<int> number(n,0);\\n\\t\\t//Convert to an bool array ( not necessary )\\n        for(int i=0;i<n;++i){\\n           number[i] = (corridor[i] == \\'S\\');\\n        }\\n        long long xd = accumulate(number.begin(),number.end(),0);\\n        if(xd%2 != 0) return 0;\\n        vector<pair<int,int>> s; // stores what are the start and end indices which have two sofas\\n        int start = 0;\\n        long long sum = 0;\\n        for(int i=0;i<n;++i){\\n            sum += number[i];\\n            if(number[i] == 1 && sum ==1) start = i;\\n\\t\\t\\t//Once we find the window with 2 sofas, push it to array\\n            if(sum == 2){\\n                s.push_back({start,i});\\n                sum = 0;\\n                start = -1;\\n            }\\n        }\\n        if(s.size()==0) return 0;\\n        int ans = 1;\\n        for(int i=1;i<s.size();++i){\\n\\t\\t\\t// The difference between end of one section and start of another is one more than the number of plants \\n            long long x = (s[i].first - s[i-1].second); \\n            ans  = (ans*x)%mod;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        \\n        int n = corridor.size();\\n        long long mod = 1e9 + 7;\\n        vector<int> number(n,0);\\n\\t\\t//Convert to an bool array ( not necessary )\\n        for(int i=0;i<n;++i){\\n           number[i] = (corridor[i] == \\'S\\');\\n        }\\n        long long xd = accumulate(number.begin(),number.end(),0);\\n        if(xd%2 != 0) return 0;\\n        vector<pair<int,int>> s; // stores what are the start and end indices which have two sofas\\n        int start = 0;\\n        long long sum = 0;\\n        for(int i=0;i<n;++i){\\n            sum += number[i];\\n            if(number[i] == 1 && sum ==1) start = i;\\n\\t\\t\\t//Once we find the window with 2 sofas, push it to array\\n            if(sum == 2){\\n                s.push_back({start,i});\\n                sum = 0;\\n                start = -1;\\n            }\\n        }\\n        if(s.size()==0) return 0;\\n        int ans = 1;\\n        for(int i=1;i<s.size();++i){\\n\\t\\t\\t// The difference between end of one section and start of another is one more than the number of plants \\n            long long x = (s[i].first - s[i-1].second); \\n            ans  = (ans*x)%mod;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709747,
                "title": "swift",
                "content": "```\\n func numberOfWays(_ corridor: String) -> Int {\\n        var arr = Array(corridor) \\n        var s: [Int] = []\\n        for i in 0..<arr.count {\\n            if arr[i] == \"S\" {\\n                s.append(i)\\n            }\\n        }\\n        if s.count % 2 != 0 || s.isEmpty {\\n            return 0\\n        }\\n        \\n        var i = 0\\n        var count = 1\\n        while(i<s.count) {\\n            if ((i+2) < s.count) && ((s[i+2] - s[i+1]) != 1) {\\n                count = (count * (s[i+2] - s[i+1])) % 1000000007\\n            }\\n            i = i + 2\\n        }\\n        \\n        return count\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n func numberOfWays(_ corridor: String) -> Int {\\n        var arr = Array(corridor) \\n        var s: [Int] = []\\n        for i in 0..<arr.count {\\n            if arr[i] == \"S\" {\\n                s.append(i)\\n            }\\n        }\\n        if s.count % 2 != 0 || s.isEmpty {\\n            return 0\\n        }\\n        \\n        var i = 0\\n        var count = 1\\n        while(i<s.count) {\\n            if ((i+2) < s.count) && ((s[i+2] - s[i+1]) != 1) {\\n                count = (count * (s[i+2] - s[i+1])) % 1000000007\\n            }\\n            i = i + 2\\n        }\\n        \\n        return count\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1709735,
                "title": "short-and-clear-solution-to-understand",
                "content": "If the count of S is odd or zero then here is going to be zero ways, the reason is because they have mentioned that there should be exactly two seats in each segment if count of seat is odd then there will be one seat left out and if count is zero then we can\\u2019t divide it.\\n\\nFind the distance between the second seat and then next seat. Lets say the distance is x then there will be x+1 ways to divide it. Example\\n\\nLet the string be P S S P P P S\\n\\nP S S | P P P S\\n\\nP S S P | P P S\\n\\nP S S P P | P S\\n\\nP S S P P P | S\\n\\nSimilarly find the no of ways for upcoming two seats and finally multiply it. If it distance between them are 3,3 then there will be 3*3 which is 9 ways.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) \\n    {\\n        vector<long long int> store;\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'S\\')\\n            {\\n                c++;\\n            }\\n        }\\n        if(c%2 || c==0)\\n        {\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'S\\')\\n            {\\n                count++;\\n                if(count%2==0)\\n                {\\n                    int prev=i;\\n                    while(i+1<s.length() && s[i+1]!=\\'S\\')\\n                    {\\n                        i++;\\n                    }\\n                    \\n                    if(i!=s.length()-1)\\n                    {\\n                        store.push_back(i-prev+1);\\n                    }\\n                }\\n            }\\n        }\\n        long long int ans=1;\\n        for(int i=0;i<store.size();i++)\\n        {\\n            ans*=store[i];\\n            ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) \\n    {\\n        vector<long long int> store;\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'S\\')\\n            {\\n                c++;\\n            }\\n        }\\n        if(c%2 || c==0)\\n        {\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'S\\')\\n            {\\n                count++;\\n                if(count%2==0)\\n                {\\n                    int prev=i;\\n                    while(i+1<s.length() && s[i+1]!=\\'S\\')\\n                    {\\n                        i++;\\n                    }\\n                    \\n                    if(i!=s.length()-1)\\n                    {\\n                        store.push_back(i-prev+1);\\n                    }\\n                }\\n            }\\n        }\\n        long long int ans=1;\\n        for(int i=0;i<store.size();i++)\\n        {\\n            ans*=store[i];\\n            ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709713,
                "title": "python3-multiplication",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/8fc8469e823a229654fc858172dfa9383d805e39) for solutions of biweekly 70. \\n\\n**Intuition**\\nHere, we just count the number of `seats` that we\\'ve seen so far. If there are even number of seats other than 0, we count `pines` and multiply `pines+1` to the final answer. Finally, if there are even number of seats, we output this mulplied number. \\n\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        ans = 1\\n        seats = ii = 0 \\n        for i, x in enumerate(corridor): \\n            if x == \\'S\\': \\n                if seats and seats % 2 == 0: ans = ans * (i-ii) % 1_000_000_007\\n                seats += 1\\n                ii = i\\n        return ans if seats and seats % 2 == 0 else 0 \\n```\\n\\n**AofA**\\ntime complexity `O(N)`\\nspace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        ans = 1\\n        seats = ii = 0 \\n        for i, x in enumerate(corridor): \\n            if x == \\'S\\': \\n                if seats and seats % 2 == 0: ans = ans * (i-ii) % 1_000_000_007\\n                seats += 1\\n                ii = i\\n        return ans if seats and seats % 2 == 0 else 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709680,
                "title": "java-simple-math-o-n-time-o-1-space",
                "content": "```\\n\\n/*\\n    edge cases :\\n        seats are zero -> answer is 0\\n        seats are odd in count -> answer is 0\\n\\telse\\n\\t\\tfind number of plants between 2nd and 3rd seat = p1\\n\\t\\tfind number of plants between 4th and 5th seat = p2\\n\\t\\t.\\n\\t\\t.\\n\\t\\t.\\n\\t\\tand so on .................................... = pi\\n\\t\\t\\tanswer = ((1 + p1) * (1 + p2) * ...... * (1 + pi))\\n*/\\n\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        int n = corridor.length(), index = 0;\\n        long totalSeat = 0, seat = 0, plant = 0, product = 1, mod = 1000000007;\\n        for(char ch : corridor.toCharArray()) {\\n            if(ch == \\'S\\') {\\n                totalSeat++;\\n            }\\n        }\\n        if((totalSeat == 0) || ((totalSeat % 2) == 1)) {\\n            return 0;\\n        }\\n        while(index < n) {\\n            if(corridor.charAt(index) == \\'S\\') {\\n                seat++;\\n                if(seat == totalSeat) {\\n                    break;\\n                }\\n                if((seat > 2) && ((seat % 2) == 1)) {\\n                    product = ((product * (plant + 1)) % mod);\\n                    plant = 0;\\n                }\\n            } else {\\n                if((seat >= 2) && ((seat % 2) == 0)) {\\n                    plant++;\\n                }\\n            }\\n            index++;\\n        }\\n        return ((int) product);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/*\\n    edge cases :\\n        seats are zero -> answer is 0\\n        seats are odd in count -> answer is 0\\n\\telse\\n\\t\\tfind number of plants between 2nd and 3rd seat = p1\\n\\t\\tfind number of plants between 4th and 5th seat = p2\\n\\t\\t.\\n\\t\\t.\\n\\t\\t.\\n\\t\\tand so on .................................... = pi\\n\\t\\t\\tanswer = ((1 + p1) * (1 + p2) * ...... * (1 + pi))\\n*/\\n\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        int n = corridor.length(), index = 0;\\n        long totalSeat = 0, seat = 0, plant = 0, product = 1, mod = 1000000007;\\n        for(char ch : corridor.toCharArray()) {\\n            if(ch == \\'S\\') {\\n                totalSeat++;\\n            }\\n        }\\n        if((totalSeat == 0) || ((totalSeat % 2) == 1)) {\\n            return 0;\\n        }\\n        while(index < n) {\\n            if(corridor.charAt(index) == \\'S\\') {\\n                seat++;\\n                if(seat == totalSeat) {\\n                    break;\\n                }\\n                if((seat > 2) && ((seat % 2) == 1)) {\\n                    product = ((product * (plant + 1)) % mod);\\n                    plant = 0;\\n                }\\n            } else {\\n                if((seat >= 2) && ((seat % 2) == 0)) {\\n                    plant++;\\n                }\\n            }\\n            index++;\\n        }\\n        return ((int) product);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709657,
                "title": "python-o-n-detailed-explanation-with-illustrations",
                "content": "We must divide the corridor so that every block has exactly `2` seats.\\nSo if we ignore the plants, the blocks of seats should be divided as the red blocks shown below:\\n![](https://i.imgur.com/CT01OqV.png)\\n\\nNow take the plants into consideration. We must decide where to put the dividers between the red blocks:\\n* Between the first and the second red block, there are `2` plants and we have `3` choices to put the divider.\\n* Between the second and the third red blocks, there are `1` plants and we have `2` choices to put the divider.\\n* Between the first and the second red blocks, there are `4` plants and we have `5` choices to put the divider.\\n* We **cannot** put the divider before the first red block or after the last red block.\\n* So there are `3 * 2 * 5 = 30` ways to put the dividers.\\n\\n![](https://i.imgur.com/Kcuc4fs.png)\\nWe can transform the string `corridor` into an array containing the count of the plants between every two adjancent seats. For example, the illustration above can be transformed into `arr = [2, 0, 2, 1, 1, 3, 4, 1, 3]`.\\n\\n\\n* If the length of `arr` is even, then the count of seats is odd and the `answer` should be `0`.\\n* If the length of `arr` is `1`, then the count of seats is `0` and the `answer` should also be `0`.\\n* The first element and last element in `arr` should be ignored since we cannot put a divider on the first of last block.\\n* The answer will be the product of `[(arr[2] + 1), (arr[4] + 1), (arr[6] + 1), ...]`\\n\\n\\n**Complexity:**\\n* Calculating the block array: `Time: O(N), Space: O(N)`\\n* Calculating the product: `Time: O(N), Space: O(1)`\\n* Total: `Time: O(N), Space: O(N)` (can be done in `O(1)` space)\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n\\n        # append a final \\'S\\' to update the last block\\n        corridor += \\'S\\'\\n\\n        # calculate the length of continuous plants\\n        blocks = []\\n        curr_block = 0\\n        for char in corridor:\\n            if char == \\'S\\':\\n                blocks.append(curr_block)\\n                curr_block = 0\\n            else:\\n                curr_block += 1\\n        \\n        # no way to arrange the divider\\n        if len(blocks) % 2 == 0 or len(blocks) == 1:\\n            return 0\\n\\n        # calculate the cumulative product \\n        ans = 1\\n        for block in blocks[2:-2:2]: # start from index 2, stop at index (N - 2), step size = 2\\n            ans = (ans * (block + 1)) % (10 ** 9 + 7)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n\\n        # append a final \\'S\\' to update the last block\\n        corridor += \\'S\\'\\n\\n        # calculate the length of continuous plants\\n        blocks = []\\n        curr_block = 0\\n        for char in corridor:\\n            if char == \\'S\\':\\n                blocks.append(curr_block)\\n                curr_block = 0\\n            else:\\n                curr_block += 1\\n        \\n        # no way to arrange the divider\\n        if len(blocks) % 2 == 0 or len(blocks) == 1:\\n            return 0\\n\\n        # calculate the cumulative product \\n        ans = 1\\n        for block in blocks[2:-2:2]: # start from index 2, stop at index (N - 2), step size = 2\\n            ans = (ans * (block + 1)) % (10 ** 9 + 7)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081694,
                "title": "c-greedy-easiest-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        // Intuition\\n        // The idea in here is really very simple. What we will do is we will maintain three total pointers one for stroing the number of seats and one for storing the number of plants with in the space and third to store the final number of possible values.\\n        int seats  = 0;\\n        long long answer = 1;\\n        int plants = 0;\\n        int mod = 1e9 + 7;\\n        int total = 0;\\n        for(auto &ch : corridor){\\n            total += (ch == \\'S\\');\\n        }\\n        if(total % 2 != 0 or total == 0) return 0;\\n        int size = corridor.size();\\n        for(int i = 0 ; i < size ; i++){\\n            seats += (corridor[i] == \\'S\\');\\n            if(seats == 2 and corridor[i] == \\'P\\') plants++;\\n            if(seats == 3){\\n                answer *= (plants + 1) % mod;\\n                answer = answer % mod;\\n                seats = 1;\\n                plants = 0;\\n            }\\n        }\\n        return answer % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        // Intuition\\n        // The idea in here is really very simple. What we will do is we will maintain three total pointers one for stroing the number of seats and one for storing the number of plants with in the space and third to store the final number of possible values.\\n        int seats  = 0;\\n        long long answer = 1;\\n        int plants = 0;\\n        int mod = 1e9 + 7;\\n        int total = 0;\\n        for(auto &ch : corridor){\\n            total += (ch == \\'S\\');\\n        }\\n        if(total % 2 != 0 or total == 0) return 0;\\n        int size = corridor.size();\\n        for(int i = 0 ; i < size ; i++){\\n            seats += (corridor[i] == \\'S\\');\\n            if(seats == 2 and corridor[i] == \\'P\\') plants++;\\n            if(seats == 3){\\n                answer *= (plants + 1) % mod;\\n                answer = answer % mod;\\n                seats = 1;\\n                plants = 0;\\n            }\\n        }\\n        return answer % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040309,
                "title": "17-ms-beats-100-simple-math-solution-in-java-o-n-time",
                "content": "# Intuition\\nThe same seats will always be paired together regardless of the division as each section will have exactly 2 seats (ie seats 1 and 2 will always be paired, seats 3 and 4 will always be paired, etc.). Therefore, walls will always have to be placed in the sections of plants between pairs of seats. There will always be at least 1 possible division between pairs of seats even if they are directly adjacent. Each plant between pairs of seats gives an extra possible location for a wall placement. This means we only have to confirm there is an even and positive number of chairs and count the number of plants in each section between chairs. We can add the 1 base wall placement to the number of plants to get our total number of possible divisions at that section. Multiplying all these values together will give the result.\\n\\n# Approach\\nWe simply iterate through the array, incrementing a counter that tracks the number of seats every time one is encountered. When the second seat in a pair is encountered, we begin counting the number of plants before the next seat is found. When the next seat is encountered, we can multiply our result by the number of possible divisions. After we have iterated through the full array, we confirm that we have an even number of seats that is greater than 0 and return our result if so.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - We do a single pass through the char array representation of the string.\\n\\n- Space complexity:\\n$$O(n)$$ - We convert the string to its char array representation and store this as a new array to allow for faster access of array elements. If the String.charAt() method is used instead, space complexity becomes $$O(1)$$ at the cost of longer runtime.\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n\\n        char[] array = corridor.toCharArray();\\n        int chairs = 0;\\n        long result = 1;\\n\\n        for (int i = 0; i < array.length; i++) {\\n\\n            // seat encountered\\n            if (array[i] == \\'S\\') {\\n                chairs++;\\n\\n                // advance to the next seat ignoring plants along the way\\n                while (++i < array.length && array[i] != \\'S\\');\\n                if (i < array.length && array[i] == \\'S\\') {\\n                    chairs++;\\n                }\\n\\n\\n                // there is one guaranteed division between adjacent pairs of seats\\n                // each plant between them adds an extra 1 division\\n                int divisions = 1;\\n                while (++i < array.length && array[i] != \\'S\\') {\\n                    divisions++;\\n                }\\n\\n                // if any extra divisions are possible, multiply our result by the divisions                \\n                if (divisions > 1 && i < array.length) {\\n                    result = (result * divisions) % 1000000007;\\n                }\\n                i--;\\n            }\\n        }\\n\\n        // if there are no chairs or an odd number of chairs there are no possible divisions\\n        // otherwise return our calculated result\\n        return (chairs != 0 && chairs % 2 == 0) ? (int) result : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n\\n        char[] array = corridor.toCharArray();\\n        int chairs = 0;\\n        long result = 1;\\n\\n        for (int i = 0; i < array.length; i++) {\\n\\n            // seat encountered\\n            if (array[i] == \\'S\\') {\\n                chairs++;\\n\\n                // advance to the next seat ignoring plants along the way\\n                while (++i < array.length && array[i] != \\'S\\');\\n                if (i < array.length && array[i] == \\'S\\') {\\n                    chairs++;\\n                }\\n\\n\\n                // there is one guaranteed division between adjacent pairs of seats\\n                // each plant between them adds an extra 1 division\\n                int divisions = 1;\\n                while (++i < array.length && array[i] != \\'S\\') {\\n                    divisions++;\\n                }\\n\\n                // if any extra divisions are possible, multiply our result by the divisions                \\n                if (divisions > 1 && i < array.length) {\\n                    result = (result * divisions) % 1000000007;\\n                }\\n                i--;\\n            }\\n        }\\n\\n        // if there are no chairs or an odd number of chairs there are no possible divisions\\n        // otherwise return our calculated result\\n        return (chairs != 0 && chairs % 2 == 0) ? (int) result : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936232,
                "title": "iterative-dp-solution-c",
                "content": "# Intuition\\nIt is an obvious Combinatorics DP problem, \\n\\n# Approach\\nPlease check the comments in code\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int MOD = (int)1e9 + 7;\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        vector<vector<long long>> dp(n + 1, vector<long long>(3, 0));\\n        // dp[i][k] means what are the number of ways to have k seats in  \\n        //the at ith index considering I have placed a division somewhere \\n        // in the suffix and constructing my answer backwards\\n        dp[n][2] = 1; // no. of ways to have a 2 seat divion ending at end\\n        // is 1\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int k = 0; k <= 2; ++k) {\\n                if (k == 2) {\\n                    if (corridor[i] == \\'P\\') {\\n                        dp[i][k] = (dp[i + 1][0] + dp[i + 1][k]) % MOD;// continue or place a div\\n                    } else {\\n                        dp[i][k] = dp[i + 1][1] % MOD;// have to place a division\\n                    }\\n                } else {\\n                    dp[i][k] = dp[i + 1][k + (corridor[i] == \\'S\\')] % MOD; // at ith index i have k seats, number of ways to do this is\\n                    // if s[i]is \\'P\\' then i have to continue and cant place a div then dp[i][k]=dp[i+1][k],\\n                    // s[i] is \\'S\\' then dp[i][k]= dp[i+1][k+1] no. of ways k+1 seats by i+1th state\\n                }\\n            }\\n        }\\n\\n        return dp[0][0]; // if i started at 0 index with zero states what will be my answer\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = (int)1e9 + 7;\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        vector<vector<long long>> dp(n + 1, vector<long long>(3, 0));\\n        // dp[i][k] means what are the number of ways to have k seats in  \\n        //the at ith index considering I have placed a division somewhere \\n        // in the suffix and constructing my answer backwards\\n        dp[n][2] = 1; // no. of ways to have a 2 seat divion ending at end\\n        // is 1\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int k = 0; k <= 2; ++k) {\\n                if (k == 2) {\\n                    if (corridor[i] == \\'P\\') {\\n                        dp[i][k] = (dp[i + 1][0] + dp[i + 1][k]) % MOD;// continue or place a div\\n                    } else {\\n                        dp[i][k] = dp[i + 1][1] % MOD;// have to place a division\\n                    }\\n                } else {\\n                    dp[i][k] = dp[i + 1][k + (corridor[i] == \\'S\\')] % MOD; // at ith index i have k seats, number of ways to do this is\\n                    // if s[i]is \\'P\\' then i have to continue and cant place a div then dp[i][k]=dp[i+1][k],\\n                    // s[i] is \\'S\\' then dp[i][k]= dp[i+1][k+1] no. of ways k+1 seats by i+1th state\\n                }\\n            }\\n        }\\n\\n        return dp[0][0]; // if i started at 0 index with zero states what will be my answer\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917266,
                "title": "c-python-solution-with-explanation",
                "content": "We can put a divider between the left side of the 3rd, 5th, .. seat and the previous seat.\\n\\ntc is O(n), sc is O(1)\\n\\n### python\\n```python\\nmod = int(1e9+7)\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        ans = 1\\n        cnt_seat = 0\\n        pre = 0\\n        for i, ch in enumerate(corridor):\\n            if ch == \\'S\\':\\n                cnt_seat += 1\\n                if cnt_seat >= 3 and cnt_seat % 2:\\n                    ans = ans * (i - pre) % mod\\n                pre = i\\n        return ans if cnt_seat and cnt_seat % 2 == 0 else 0\\n```\\n\\n### c++\\n\\n```cpp\\nconst int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int cnt_seat = 0, ans = 1, pre = 0;\\n        \\n        for (int i = 0; i < corridor.size(); i+=1) {\\n            if (corridor[i] == \\'S\\') {\\n                cnt_seat += 1;\\n                if (cnt_seat >= 3 && cnt_seat % 2)\\n                    ans = (long) ans * (i - pre) % mod;\\n                pre = i;\\n            }\\n        }\\n        return cnt_seat && cnt_seat % 2 == 0? ans: 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nmod = int(1e9+7)\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        ans = 1\\n        cnt_seat = 0\\n        pre = 0\\n        for i, ch in enumerate(corridor):\\n            if ch == \\'S\\':\\n                cnt_seat += 1\\n                if cnt_seat >= 3 and cnt_seat % 2:\\n                    ans = ans * (i - pre) % mod\\n                pre = i\\n        return ans if cnt_seat and cnt_seat % 2 == 0 else 0\\n```\n```cpp\\nconst int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int cnt_seat = 0, ans = 1, pre = 0;\\n        \\n        for (int i = 0; i < corridor.size(); i+=1) {\\n            if (corridor[i] == \\'S\\') {\\n                cnt_seat += 1;\\n                if (cnt_seat >= 3 && cnt_seat % 2)\\n                    ans = (long) ans * (i - pre) % mod;\\n                pre = i;\\n            }\\n        }\\n        return cnt_seat && cnt_seat % 2 == 0? ans: 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764944,
                "title": "simple-recursion-approach-beats-60-in-runtime-and-memory",
                "content": "# Complexity\\n- Time complexity:\\nO(N), where N is size of the corridor array\\n\\n# Code\\n```\\n#define M 1000000007\\n\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        unsigned long long result = dividerPlacement(corridor.c_str(), 0, corridor.length());\\n\\n        return result;\\n    }\\n\\n    unsigned long long dividerPlacement(const char* corridor, unsigned int i, const unsigned int n){\\n        char number_of_seats = 0;\\n\\n        while((number_of_seats < 2) && (i < n)){\\n            if(corridor[i] == \\'S\\'){\\n                number_of_seats++;\\n            }\\n\\n            i++;\\n        }\\n\\n        if(i >= n - 1){\\n            unsigned short num_of_seats = 0;\\n            for(int j = 0; j < n; j++){\\n                if(corridor[j] == \\'S\\')\\n                    num_of_seats++;\\n            }\\n\\n            if(num_of_seats % 2 != 0 || num_of_seats == 0){\\n                return 0;\\n            }\\n\\n            return 1;\\n        }\\n\\n        unsigned int k = 1;\\n        while((corridor[i] != \\'S\\') && (i < n)){\\n            k++;\\n            i++;\\n        }\\n\\n        if(i >= n - 1)\\n            k = 1;\\n\\n        return (k * dividerPlacement(corridor, i, n)) % M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define M 1000000007\\n\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        unsigned long long result = dividerPlacement(corridor.c_str(), 0, corridor.length());\\n\\n        return result;\\n    }\\n\\n    unsigned long long dividerPlacement(const char* corridor, unsigned int i, const unsigned int n){\\n        char number_of_seats = 0;\\n\\n        while((number_of_seats < 2) && (i < n)){\\n            if(corridor[i] == \\'S\\'){\\n                number_of_seats++;\\n            }\\n\\n            i++;\\n        }\\n\\n        if(i >= n - 1){\\n            unsigned short num_of_seats = 0;\\n            for(int j = 0; j < n; j++){\\n                if(corridor[j] == \\'S\\')\\n                    num_of_seats++;\\n            }\\n\\n            if(num_of_seats % 2 != 0 || num_of_seats == 0){\\n                return 0;\\n            }\\n\\n            return 1;\\n        }\\n\\n        unsigned int k = 1;\\n        while((corridor[i] != \\'S\\') && (i < n)){\\n            k++;\\n            i++;\\n        }\\n\\n        if(i >= n - 1)\\n            k = 1;\\n\\n        return (k * dividerPlacement(corridor, i, n)) % M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710223,
                "title": "java-o-n-solution-without-dp-implementation-easy",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculating the no of plants between well formed pair of seats.\\nFor example:\\n**SSPPSSSSPSS** \\n:-- solution\\ncount of p in between 2 well formed pairs = 2 **(pair 1 and pair 2 or between index 1 and index 4)**\\nprod=***prod****(**count_p**+1)=***1****(**2**+1);\\nthen again the no of p between well formed pair = 1 **pair 3 and pair 4 or between index 7 and index 9**\\ntherefore:- prod=***prod****(**count_p**+1)=***3****(**1**+1);\\n**Final Answer: prod = 6**\\n# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfWays(String s) {\\n        int c=0;\\n        int countp=0;\\n        long po=1;\\n        int prev=0;\\n        long mod=(long)1e9+7;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'S\\')\\n            {\\n                c+=1;\\n                if (c%2==0)\\n                {\\n                if((countp-prev)!=0&&c>=2)\\n                {\\n                    po=(po*(countp-prev+1))%mod;\\n                    prev=countp;\\n                }\\n                }\\n            }\\n            else if(c%2==0&&c>=2)\\n            {\\n\\n                countp+=1;\\n            }\\n        }\\n        if(c%2!=0||c==0)\\n        po=0;\\n        return (int)po;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfWays(String s) {\\n        int c=0;\\n        int countp=0;\\n        long po=1;\\n        int prev=0;\\n        long mod=(long)1e9+7;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'S\\')\\n            {\\n                c+=1;\\n                if (c%2==0)\\n                {\\n                if((countp-prev)!=0&&c>=2)\\n                {\\n                    po=(po*(countp-prev+1))%mod;\\n                    prev=countp;\\n                }\\n                }\\n            }\\n            else if(c%2==0&&c>=2)\\n            {\\n\\n                countp+=1;\\n            }\\n        }\\n        if(c%2!=0||c==0)\\n        po=0;\\n        return (int)po;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700515,
                "title": "solution-in-python-beats-100-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n    Key to Solve this is to find the even Indices Of the Seat and find the gap between the two pairs and permutate.\\n\\n# Approach\\n    Linear Search\\n\\n# Complexity\\n- Time complexity:      O(n)\\n\\n- Space complexity:     O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numberOfWays(self, corridor):\\n        \"\"\"\\n        :type corridor: str\\n        :rtype: int\\n        \"\"\"\\n        list=Counter(corridor)\\n        if list[\"S\"]==0 or list[\"S\"]%2!=0:\\n            return 0\\n        elif(list[\"S\"]>2):\\n            ans=1\\n            c=0\\n            j=0\\n            k=0\\n            for i in corridor:\\n                if(i==\\'S\\'):\\n                    c+=1\\n                    if(c!=1):\\n                        if(c%2==0):\\n                            j=k\\n                        else:\\n                            ans*=(k-j)\\n                k+=1\\n            return ans%1000000007\\n        else:\\n            return 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfWays(self, corridor):\\n        \"\"\"\\n        :type corridor: str\\n        :rtype: int\\n        \"\"\"\\n        list=Counter(corridor)\\n        if list[\"S\"]==0 or list[\"S\"]%2!=0:\\n            return 0\\n        elif(list[\"S\"]>2):\\n            ans=1\\n            c=0\\n            j=0\\n            k=0\\n            for i in corridor:\\n                if(i==\\'S\\'):\\n                    c+=1\\n                    if(c!=1):\\n                        if(c%2==0):\\n                            j=k\\n                        else:\\n                            ans*=(k-j)\\n                k+=1\\n            return ans%1000000007\\n        else:\\n            return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694855,
                "title": "o-n-time-o-1-space-rule-of-product",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n\\n        int numChairs = 0, chCount = 0, plCount = 0;\\n        long long res = 1;\\n        const long long mod = 1e9 + 7;\\n\\n        for (auto c : corridor)\\n        {\\n            if (chCount == 2)\\n            {\\n                if (c == \\'S\\')\\n                {\\n                    res = (res * (plCount + 1)) % mod;\\n                    plCount = 0;\\n                    chCount = 1;\\n                    ++numChairs;\\n                }\\n                else\\n                    ++plCount;\\n            }\\n            else if (c == \\'S\\')\\n                ++chCount, ++numChairs;\\n        }\\n\\n        if (numChairs & 1 || numChairs < 1)\\n            return 0;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n\\n        int numChairs = 0, chCount = 0, plCount = 0;\\n        long long res = 1;\\n        const long long mod = 1e9 + 7;\\n\\n        for (auto c : corridor)\\n        {\\n            if (chCount == 2)\\n            {\\n                if (c == \\'S\\')\\n                {\\n                    res = (res * (plCount + 1)) % mod;\\n                    plCount = 0;\\n                    chCount = 1;\\n                    ++numChairs;\\n                }\\n                else\\n                    ++plCount;\\n            }\\n            else if (c == \\'S\\')\\n                ++chCount, ++numChairs;\\n        }\\n\\n        if (numChairs & 1 || numChairs < 1)\\n            return 0;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665267,
                "title": "o-n-greedy-beats-92-readable-c",
                "content": "# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        string corr = \"\";\\n        int n = s.size(), i, j, count=0;\\n\\n        //edge cases:\\n        //1. all plants -> should return 0\\n        //2. all seats -> return 1 if #seats is even else 0\\n        for(i=0; i<n; i++) {\\n            if(s[i] == \\'P\\') {\\n                corr += \\'P\\';\\n                continue;\\n            }\\n            //s[i] == \\'S\\'\\n            j = i+1;\\n            while(j < n && s[j] != \\'S\\') {\\n                j++;\\n            }\\n\\n            //odd #seats\\n            if(j > n-1)\\n                return 0;\\n\\n            corr += \\'S\\';\\n            count++;\\n            \\n            i=j;\\n        }\\n        //all plants no seats\\n        if(count == 0)\\n            return 0;\\n\\n        //string corr contains a single \\'S\\' for each section with exactly 2 seats in original string.         \\n        long long res = 1, MOD = 1e9+7;\\n        n = corr.size();\\n        for(i=0; i<n; i++) {\\n            if(corr[i] == \\'P\\')\\n                continue;\\n            \\n            j=i+1;\\n            while(j<n && corr[j] != \\'S\\'){\\n                j++;\\n            }\\n            if(j > n-1)\\n                return res;\\n            res = (res%MOD * (j-i)%MOD)%MOD;\\n            i=j-1;\\n        }\\n\\n        return (int)res%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        string corr = \"\";\\n        int n = s.size(), i, j, count=0;\\n\\n        //edge cases:\\n        //1. all plants -> should return 0\\n        //2. all seats -> return 1 if #seats is even else 0\\n        for(i=0; i<n; i++) {\\n            if(s[i] == \\'P\\') {\\n                corr += \\'P\\';\\n                continue;\\n            }\\n            //s[i] == \\'S\\'\\n            j = i+1;\\n            while(j < n && s[j] != \\'S\\') {\\n                j++;\\n            }\\n\\n            //odd #seats\\n            if(j > n-1)\\n                return 0;\\n\\n            corr += \\'S\\';\\n            count++;\\n            \\n            i=j;\\n        }\\n        //all plants no seats\\n        if(count == 0)\\n            return 0;\\n\\n        //string corr contains a single \\'S\\' for each section with exactly 2 seats in original string.         \\n        long long res = 1, MOD = 1e9+7;\\n        n = corr.size();\\n        for(i=0; i<n; i++) {\\n            if(corr[i] == \\'P\\')\\n                continue;\\n            \\n            j=i+1;\\n            while(j<n && corr[j] != \\'S\\'){\\n                j++;\\n            }\\n            if(j > n-1)\\n                return res;\\n            res = (res%MOD * (j-i)%MOD)%MOD;\\n            i=j-1;\\n        }\\n\\n        return (int)res%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572908,
                "title": "sliding-window-time-o-n-space-o-1",
                "content": "class Solution(object):\\n    def numberOfWays(self, corridor):\\n        \"\"\"\\n        :type corridor: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        cur = 0\\n        last_index = 0\\n        res = 1\\n        \\n        for i,c in enumerate(corridor):\\n            if c == \\'S\\':\\n                if cur == 2:\\n                    res *= (i-last_index)\\n                    cur = 1\\n                    last_index = i\\n                else:\\n                    cur += 1\\n                    last_index = i\\n        \\n        if cur != 2:\\n            return 0\\n        else:\\n            return res %(10**9 + 7)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numberOfWays(self, corridor):\\n        \"\"\"\\n        :type corridor: str\\n        :rtype: int\\n        \"\"\"\\n        \\n        cur = 0\\n        last_index = 0\\n        res = 1\\n        \\n        for i,c in enumerate(corridor):\\n            if c == \\'S\\':\\n                if cur == 2:\\n                    res *= (i-last_index)\\n                    cur = 1\\n                    last_index = i\\n                else:\\n                    cur += 1\\n                    last_index = i\\n        \\n        if cur != 2:\\n            return 0\\n        else:\\n            return res %(10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 3572829,
                "title": "java-easy-approach",
                "content": "# Intuition\\nDivide the corridor into segments containing two seats only and each segment must start and ends with a seat. Then calculate the numbers of plants between adjacent segments  ```P``` then we can divide from ```p+1``` different positions. At last multiply all positions where we can place the wall.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        int firstSeat = 0;\\n        int i=0;\\n        while(i<corridor.length()&&corridor.charAt(i)==\\'P\\'){\\n            i++;\\n        }\\n        firstSeat = i;\\n        \\n        int count = 1;\\n        long ans = 1;\\n        int plant = 0;\\n        while(i<corridor.length()){\\n            char ch = corridor.charAt(i);\\n            if(ch==\\'S\\'){\\n                if(count%2==1){\\n                    // System.out.println(plant);\\n                    ans = (ans * (plant+1))%1000000007;\\n                    plant = 0;\\n                }\\n                else{\\n                    plant = 0;\\n                }\\n                count++;\\n            }\\n            else{\\n                plant++;\\n            }\\n            i++;\\n        }\\n        return (count-1)%2==0&&count!=1?(int)ans:0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```P```\n```p+1```\n```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        int firstSeat = 0;\\n        int i=0;\\n        while(i<corridor.length()&&corridor.charAt(i)==\\'P\\'){\\n            i++;\\n        }\\n        firstSeat = i;\\n        \\n        int count = 1;\\n        long ans = 1;\\n        int plant = 0;\\n        while(i<corridor.length()){\\n            char ch = corridor.charAt(i);\\n            if(ch==\\'S\\'){\\n                if(count%2==1){\\n                    // System.out.println(plant);\\n                    ans = (ans * (plant+1))%1000000007;\\n                    plant = 0;\\n                }\\n                else{\\n                    plant = 0;\\n                }\\n                count++;\\n            }\\n            else{\\n                plant++;\\n            }\\n            i++;\\n        }\\n        return (count-1)%2==0&&count!=1?(int)ans:0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571522,
                "title": "c-recursion-logic-clean-and-intuitive",
                "content": "```\\nclass Solution {\\n    long long countWays(string &corridor, int idx, int n, long long mod){\\n        if(idx == n)\\n            return 0;\\n        \\n        bool flag = false;\\n        int secondChairIdx = -1;\\n        \\n        for(int i = idx; i < n; i++){\\n            if(corridor[i] == \\'S\\'){\\n                if(flag){\\n\\t\\t\\t\\t\\t// if flag is alreaady true means this is our second chair of the section,\\n\\t\\t\\t\\t\\t// so we save the index of second chair and break from the loop\\n                    secondChairIdx = i;\\n                    break;\\n                }else{\\n\\t\\t\\t\\t   // if we see the first chair we make flag = true\\n                    flag = true;\\n                }\\n            }\\n        }\\n\\t\\t\\n        // if second chair does not exist that means odd number of chairs so we return 0\\n        if(secondChairIdx == -1)\\n            return 0;\\n        \\n        long long count = 1;\\n        for(int i = secondChairIdx+1; i < n; i++){\\n            if(corridor[i] == \\'P\\'){\\n\\t\\t\\t   // if we are in the last section than we have no option but to include all the plants\\n                if(i == n-1) return 1;\\n\\t\\t\\t\\t// if we are not in the last section we have option to put this plant in current section or next section\\n                count++;\\n            }\\n            else{\\n\\t\\t\\t   // if we find a third chair that means from here our next section will start, \\n\\t\\t\\t   // so we call count ways function recursively for that index and break out from current section\\n                count = (count * countWays(corridor, i, n, mod)) %mod;\\n                break;\\n            }\\n        }\\n        \\n        return count%mod;\\n    }\\n    \\npublic:\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        long long mod = 1e9+7;\\n        return countWays(corridor, 0, n, mod);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    long long countWays(string &corridor, int idx, int n, long long mod){\\n        if(idx == n)\\n            return 0;\\n        \\n        bool flag = false;\\n        int secondChairIdx = -1;\\n        \\n        for(int i = idx; i < n; i++){\\n            if(corridor[i] == \\'S\\'){\\n                if(flag){\\n\\t\\t\\t\\t\\t// if flag is alreaady true means this is our second chair of the section,\\n\\t\\t\\t\\t\\t// so we save the index of second chair and break from the loop\\n                    secondChairIdx = i;\\n                    break;\\n                }else{\\n\\t\\t\\t\\t   // if we see the first chair we make flag = true\\n                    flag = true;\\n                }\\n            }\\n        }\\n\\t\\t\\n        // if second chair does not exist that means odd number of chairs so we return 0\\n        if(secondChairIdx == -1)\\n            return 0;\\n        \\n        long long count = 1;\\n        for(int i = secondChairIdx+1; i < n; i++){\\n            if(corridor[i] == \\'P\\'){\\n\\t\\t\\t   // if we are in the last section than we have no option but to include all the plants\\n                if(i == n-1) return 1;\\n\\t\\t\\t\\t// if we are not in the last section we have option to put this plant in current section or next section\\n                count++;\\n            }\\n            else{\\n\\t\\t\\t   // if we find a third chair that means from here our next section will start, \\n\\t\\t\\t   // so we call count ways function recursively for that index and break out from current section\\n                count = (count * countWays(corridor, i, n, mod)) %mod;\\n                break;\\n            }\\n        }\\n        \\n        return count%mod;\\n    }\\n    \\npublic:\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        long long mod = 1e9+7;\\n        return countWays(corridor, 0, n, mod);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570687,
                "title": "without-dp-just-multiplication",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    int numberOfWays(string s) {\\n        int n =  s.length();\\n        long long cnt = 1;\\n        int index = n-1;\\n        while(index>=0){\\n            int st = 0;\\n            while(index>=0){\\n                if(s[index]==\\'S\\'){\\n                    st++;\\n                }\\n                if(st==2){\\n                    break;\\n                }\\n                index--;\\n            }\\n            if(st!=2){\\n                return 0;\\n            }\\n            if(st==2){\\n                int plt = 0;\\n                int j = index-1;\\n                while(j>=0 && s[j]==\\'P\\'){\\n                    plt++;\\n                    j--;\\n                }\\n                index = j;\\n                if(j<0){\\n                    cnt *= 1;\\n                }\\n                else{\\n                    cnt = (plt+1)*cnt;\\n                    cnt %= mod;\\n                }\\n            }\\n            \\n        }\\n        return (int)cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    int numberOfWays(string s) {\\n        int n =  s.length();\\n        long long cnt = 1;\\n        int index = n-1;\\n        while(index>=0){\\n            int st = 0;\\n            while(index>=0){\\n                if(s[index]==\\'S\\'){\\n                    st++;\\n                }\\n                if(st==2){\\n                    break;\\n                }\\n                index--;\\n            }\\n            if(st!=2){\\n                return 0;\\n            }\\n            if(st==2){\\n                int plt = 0;\\n                int j = index-1;\\n                while(j>=0 && s[j]==\\'P\\'){\\n                    plt++;\\n                    j--;\\n                }\\n                index = j;\\n                if(j<0){\\n                    cnt *= 1;\\n                }\\n                else{\\n                    cnt = (plt+1)*cnt;\\n                    cnt %= mod;\\n                }\\n            }\\n            \\n        }\\n        return (int)cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570128,
                "title": "number-of-ways-to-divide-a-long-corridor-c-explained-solution",
                "content": "***Upvote If Found Helpful !!!***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite interesting and needs a bit of observation. Basically the number of ways are decided by the number of free plants that are left between each set of 2 seats. For this purpose, one can just simply run a for loop to find all such number of free plant patches. Now the answer to the problem is just : **\\u03A0 (free[i] + 1) for all i from 1 to M**, where **M** is the number of patches and **\\u03A0** indicates multiplication. **1** is added to each plant patch length to account for the combination when no plant is taken. The implementation of the above logic goes below : \\n\\n# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int numberOfWays(string corridor) {\\n        ios_base::sync_with_stdio(0);\\n        ll mod = 1e9+7LL;\\n        int c = count(corridor.begin(),corridor.end(),\\'S\\'),n = corridor.size();\\n        if(c % 2 || c == 0){\\n            return 0;\\n        }\\n        else{\\n            vector<int>plants;\\n            int start = 0,i = 0;\\n            while(i < n){\\n                c = 0; bool check = false;\\n                while(i < n && c < 3){\\n                    if(corridor[i] == \\'S\\'){\\n                        c++;\\n                    }\\n                    if(c == 2 && !check){\\n                        start = i;\\n                        check = true;\\n                    }\\n                    i++;\\n                }\\n                if(c == 3){\\n                    i--;\\n                    plants.push_back(i - start);\\n                }\\n            }\\n            ll ans = 1LL;\\n            for(auto it : plants){\\n                ans *= it;\\n                ans %= mod;\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int numberOfWays(string corridor) {\\n        ios_base::sync_with_stdio(0);\\n        ll mod = 1e9+7LL;\\n        int c = count(corridor.begin(),corridor.end(),\\'S\\'),n = corridor.size();\\n        if(c % 2 || c == 0){\\n            return 0;\\n        }\\n        else{\\n            vector<int>plants;\\n            int start = 0,i = 0;\\n            while(i < n){\\n                c = 0; bool check = false;\\n                while(i < n && c < 3){\\n                    if(corridor[i] == \\'S\\'){\\n                        c++;\\n                    }\\n                    if(c == 2 && !check){\\n                        start = i;\\n                        check = true;\\n                    }\\n                    i++;\\n                }\\n                if(c == 3){\\n                    i--;\\n                    plants.push_back(i - start);\\n                }\\n            }\\n            ll ans = 1LL;\\n            for(auto it : plants){\\n                ans *= it;\\n                ans %= mod;\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568702,
                "title": "rust-easy-with-explanation-100-runtime",
                "content": "# Intuition\\nAs there must be exactly two seats per section, exactly one subdivider must be placed between the `(2 * i)th` and `(2 * i + 1)th` seat. Freedom in placing subdividers only occurs when there are plants between `(2 * i)th` and `(2 * i + 1)th`. When there are `x` plants between those two seats, there are `x + 1` possbile places for the subdivider. \\nPlacement of one subdivider does not influence where other subdividers can be placed.\\n\\n# Approach\\nThe problem can be solved easily by iterating over the string once. We need two counters to keep track of the number of seats and plants we encountered, respectively.\\n- If we encounter a seat, we increment the seat counter.\\n    - We check if this is the third seat we encountered since the last subdivider placement.\\n        - Should that be the case, a subdivider must be placed between this seat and the one before. The number of possible places for this subdivider is given by `(number of plants since last seat + 1)`.\\n    - We reset the plants counter.\\n- If we encounter a plant, we increment the plant counter.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ additional space\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn number_of_ways(corridor: String) -> i32 {\\n        let modulo = 1000000007;\\n        let mut ans: i64 = 1;\\n        let mut seats = 0;\\n        let mut plants = 0;\\n\\n        for x in corridor.chars() {\\n            if x == \\'S\\' {\\n                seats += 1;\\n                if seats == 3 {\\n                    //place a subdivider\\n                    seats = 1;\\n                    ans = ((plants + 1) * ans) % modulo;\\n                }\\n                plants = 0;\\n            }\\n            else {\\n                plants += 1;\\n            }\\n        }\\n\\n        if seats != 2 {\\n            //uneven number of or zero seats in total,\\n            //therefore no valid subdivider placement\\n            return 0;\\n        }\\n        ans as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "String"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn number_of_ways(corridor: String) -> i32 {\\n        let modulo = 1000000007;\\n        let mut ans: i64 = 1;\\n        let mut seats = 0;\\n        let mut plants = 0;\\n\\n        for x in corridor.chars() {\\n            if x == \\'S\\' {\\n                seats += 1;\\n                if seats == 3 {\\n                    //place a subdivider\\n                    seats = 1;\\n                    ans = ((plants + 1) * ans) % modulo;\\n                }\\n                plants = 0;\\n            }\\n            else {\\n                plants += 1;\\n            }\\n        }\\n\\n        if seats != 2 {\\n            //uneven number of or zero seats in total,\\n            //therefore no valid subdivider placement\\n            return 0;\\n        }\\n        ans as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545294,
                "title": "c-short-code-simple-sweep",
                "content": "```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\npublic:\\n    int numberOfWays(string corridor) {\\n        long long ans = 1;\\n        int i = corridor.find(\"S\"), chairs = 0;\\n        while (i != -1) {\\n            int j = corridor.find(\"S\", i);\\n            if (j == -1) break;\\n            \\n            if (chairs++ % 2 == 0) (ans *= j - i + 1) %= MOD;\\n            i = j+1;\\n        }\\n        if (chairs == 0 || chairs % 2) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\npublic:\\n    int numberOfWays(string corridor) {\\n        long long ans = 1;\\n        int i = corridor.find(\"S\"), chairs = 0;\\n        while (i != -1) {\\n            int j = corridor.find(\"S\", i);\\n            if (j == -1) break;\\n            \\n            if (chairs++ % 2 == 0) (ans *= j - i + 1) %= MOD;\\n            i = j+1;\\n        }\\n        if (chairs == 0 || chairs % 2) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491979,
                "title": "simple-c-solution-t-n-o-n-s-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Count the number of plants between the second and third chair, between 4th and 5th chair.. so on between 2m and 2m+1 chair for m = 1 to .....\\nLet\\'s say that there are x plants between 2m and 2m+1 chair, then we can place the bar in x+1 ways.Similarly for others, and then multiply ways for each bar.\\n\\nIf number of seats are zero or odd, no possible way, return 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int numberOfWays(string corridor) {\\n        \\n        //n - number, c - count\\n        int n = corridor.size(), ns = 0, cs = 0, cp = 0;\\n        long long rv = 1;\\n\\n        for(char c: corridor){\\n            if(c == \\'S\\'){\\n                ns++;\\n                if(cs==2){\\n                    if(cp)rv = (rv*(cp+1))%mod;\\n                    cs = 1; cp = 0;\\n                }\\n                else cs++;\\n            }\\n            else if(cs==2)cp++;\\n        }\\n        if(ns & 1 || !ns)return 0;\\n        else return rv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int numberOfWays(string corridor) {\\n        \\n        //n - number, c - count\\n        int n = corridor.size(), ns = 0, cs = 0, cp = 0;\\n        long long rv = 1;\\n\\n        for(char c: corridor){\\n            if(c == \\'S\\'){\\n                ns++;\\n                if(cs==2){\\n                    if(cp)rv = (rv*(cp+1))%mod;\\n                    cs = 1; cp = 0;\\n                }\\n                else cs++;\\n            }\\n            else if(cs==2)cp++;\\n        }\\n        if(ns & 1 || !ns)return 0;\\n        else return rv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489956,
                "title": "java-o-n-time-o-1-space-pure-observation-with-taste-of-dp",
                "content": "# Intuition\\nIf you look at the problem closely you can see that plants on both ends don\\'t matter and there is no point in them, and also you can see that seats amount should be even. With that said, we only care about plants which will be at positions between even and odd seats, the ones located between odd and even we can\\'t do anything about. Now, each interval between even and odd seat + 1 will represent the amount of borders you can place as long as you know that there are still seats left on right side, in case there are more seats on the right side still left, it means that you will have such same interval on the right side and for each such interval you can create a number of other intervals from the right side - with this we come to combinations - meaning you need to multiply the intervals by the result you are currently in.\\n\\n# Approach\\nI did one additional pass in the beginning to find number of seats and starting position, since we need to ignore first plants for being useless. And then countP counts plants after 2 seats being visited, whenever count of seats (count variable) reached 3 - it means that we can update answer and reset variables.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private static long MOD = 100_000_000_7L;\\n    public static int numberOfWays(String s) {\\n        int[] meta = getMeta(s);\\n        int seatsLeft = meta[0];\\n        int i = meta[1];\\n        if (i == -1 || seatsLeft % 2 == 1) return 0;\\n\\n        int count = 0;\\n        int countP = 0;\\n        long answer = 1;\\n        while (seatsLeft > 0) {\\n            if (s.charAt(i) == \\'S\\') {\\n                count++;\\n                seatsLeft--;\\n            } else if (count == 2) {\\n                countP++;\\n            }\\n\\n            if (count == 3) {\\n                answer = (answer * (countP+1)) % MOD;\\n                countP = 0;\\n                count = 1;\\n            }\\n            i++;\\n        }\\n        return (int)(answer % MOD);\\n    }\\n\\n    private static int[] getMeta(String s) {\\n        int count = 0;\\n        int start = -1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'S\\') {\\n                if (start == -1) start = i;\\n                count++;\\n            }\\n        }\\n        return new int[]{count, start};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static long MOD = 100_000_000_7L;\\n    public static int numberOfWays(String s) {\\n        int[] meta = getMeta(s);\\n        int seatsLeft = meta[0];\\n        int i = meta[1];\\n        if (i == -1 || seatsLeft % 2 == 1) return 0;\\n\\n        int count = 0;\\n        int countP = 0;\\n        long answer = 1;\\n        while (seatsLeft > 0) {\\n            if (s.charAt(i) == \\'S\\') {\\n                count++;\\n                seatsLeft--;\\n            } else if (count == 2) {\\n                countP++;\\n            }\\n\\n            if (count == 3) {\\n                answer = (answer * (countP+1)) % MOD;\\n                countP = 0;\\n                count = 1;\\n            }\\n            i++;\\n        }\\n        return (int)(answer % MOD);\\n    }\\n\\n    private static int[] getMeta(String s) {\\n        int count = 0;\\n        int start = -1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'S\\') {\\n                if (start == -1) start = i;\\n                count++;\\n            }\\n        }\\n        return new int[]{count, start};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462885,
                "title": "treat-a-pair-of-seats-as-one-and-multiply-plants-between-all-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n    Observations:\\n    1. Since each section has exactly two seats, total number of seats\\n       in the corridor should be 2 * x (x >= 1) to have a valid answer.\\n       e.g.,\\n       \"PPP\" 0\\n       \"PPSP\" 0\\n       \"PPSSPS\" 0\\n\\n       \"PPSSSS\" 1\\n       \"PSPSPPSSP\" 3\\n    2. In order of occurrecen in the corridor, 1st section must\\n       include seat 1 and 2, 2nd section must include seat 3 and 4, so on.\\n       So we can treat each pair of S as an atomic token, and only compute\\n       the number of ways at the 2nd S of each token.\\n\\n       \\'PSPSPPSPSSSPPPPSSPPPP\\'\\n           1    3 3     15  15\\n\\n        It\\'s not difficult to observe that starting from the second token,\\n        number of ways = (1 + number of plants between) * previous number of ways.\\n\\n        It means the plants in between two adjacent tokens can provide x + 1\\n        ways to divide. Remaining plants in the end can only belong to the last\\n        token, such are plants in the beginning only to the first.\\n\\n        plants within a single token are ignored.\\n\\n    3. Be careful with extra 1 seat in the end, the result is 0;\\n       \"PSSPPSPSPPS\" -> 0\\n\\n       Be careful with unable to form the first token, result is also 0.\\n       \"PPP\"\\n       \"PSPP\"\\n\\n       O(n) time O(1) space;\\n    */\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size(), mod = 1e9 + 7;\\n        int ways = -1, plants = 0, seats = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (corridor[i] == \\'S\\') {\\n                seats++;\\n            } else if (seats == 0) {\\n                plants++;\\n            }\\n\\n            if (seats == 2) {\\n                if (ways == -1) {\\n                    ways = 1;\\n                } else {\\n                    ways = 1LL * ways * (plants + 1) % mod;\\n                }\\n\\n                seats = 0;\\n                plants = 0;\\n            }\\n        }\\n\\n        if (ways == -1 || seats > 0) {\\n            return 0;\\n        }\\n\\n        return ways;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Observations:\\n    1. Since each section has exactly two seats, total number of seats\\n       in the corridor should be 2 * x (x >= 1) to have a valid answer.\\n       e.g.,\\n       \"PPP\" 0\\n       \"PPSP\" 0\\n       \"PPSSPS\" 0\\n\\n       \"PPSSSS\" 1\\n       \"PSPSPPSSP\" 3\\n    2. In order of occurrecen in the corridor, 1st section must\\n       include seat 1 and 2, 2nd section must include seat 3 and 4, so on.\\n       So we can treat each pair of S as an atomic token, and only compute\\n       the number of ways at the 2nd S of each token.\\n\\n       \\'PSPSPPSPSSSPPPPSSPPPP\\'\\n           1    3 3     15  15\\n\\n        It\\'s not difficult to observe that starting from the second token,\\n        number of ways = (1 + number of plants between) * previous number of ways.\\n\\n        It means the plants in between two adjacent tokens can provide x + 1\\n        ways to divide. Remaining plants in the end can only belong to the last\\n        token, such are plants in the beginning only to the first.\\n\\n        plants within a single token are ignored.\\n\\n    3. Be careful with extra 1 seat in the end, the result is 0;\\n       \"PSSPPSPSPPS\" -> 0\\n\\n       Be careful with unable to form the first token, result is also 0.\\n       \"PPP\"\\n       \"PSPP\"\\n\\n       O(n) time O(1) space;\\n    */\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size(), mod = 1e9 + 7;\\n        int ways = -1, plants = 0, seats = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (corridor[i] == \\'S\\') {\\n                seats++;\\n            } else if (seats == 0) {\\n                plants++;\\n            }\\n\\n            if (seats == 2) {\\n                if (ways == -1) {\\n                    ways = 1;\\n                } else {\\n                    ways = 1LL * ways * (plants + 1) % mod;\\n                }\\n\\n                seats = 0;\\n                plants = 0;\\n            }\\n        }\\n\\n        if (ways == -1 || seats > 0) {\\n            return 0;\\n        }\\n\\n        return ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449927,
                "title": "c-recursive-memoized-dp",
                "content": "# Recursive Code\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n\\n    int find(int ind,int n,string&str,int cnt)\\n    {\\n        if(ind==n-1)\\n        {\\n            if(str[ind]==\\'S\\')\\n            ++cnt;\\n            return cnt==2;   \\n        }\\n        if(cnt>=3)  // not possible as we want exactly two seats \\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        if(str[ind]==\\'S\\')\\n        ++cnt;\\n        if(cnt==2)    // if cnt of seats is 2 i have two choices\\n        {\\n            ans=ans+find(ind+1,n,str,0);  // make a partition at current index\\n            ans=ans+find(ind+1,n,str,2); // try to include aplnt if possible \\n        }\\n        \\n        else\\n        {\\n            ans=ans+find(ind+1,n,str,cnt);\\n        }\\n        return ans;\\n    }\\n    int numberOfWays(string corridor) \\n    {\\n        int ans=find(0,corridor.size(),corridor,0);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Memoized Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n\\n    int find(int ind,int n,string&str,int cnt,vector<vector<int>>&dp)\\n    {\\n        if(ind==n-1)\\n        {\\n            if(str[ind]==\\'S\\')\\n            ++cnt;\\n            return cnt==2;\\n        }\\n        if(cnt==3)\\n        {\\n            return 0;\\n        }\\n        if(dp[ind][cnt]!=-1) // if already computed then return \\n         return dp[ind][cnt];\\n        int ans=0;\\n        if(str[ind]==\\'S\\')\\n        ++cnt;\\n        if(cnt==2)\\n        {\\n            ans=(ans%mod+find(ind+1,n,str,0,dp)%mod)%mod;\\n            ans=(ans%mod+find(ind+1,n,str,2,dp)%mod)%mod;\\n        }\\n        \\n        else\\n        {\\n            ans=(ans%mod+find(ind+1,n,str,cnt,dp)%mod)%mod;\\n        }\\n        return dp[ind][cnt]=ans; // memeozing the result \\n    }\\n    int numberOfWays(string corridor) \\n    {\\n        int n=corridor.size();\\n\\n       vector<vector<int>>dp(n,vector<int>(4,-1)); // creating dp array \\n        int ans=find(0,corridor.size(),corridor,0,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n\\n    int find(int ind,int n,string&str,int cnt)\\n    {\\n        if(ind==n-1)\\n        {\\n            if(str[ind]==\\'S\\')\\n            ++cnt;\\n            return cnt==2;   \\n        }\\n        if(cnt>=3)  // not possible as we want exactly two seats \\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        if(str[ind]==\\'S\\')\\n        ++cnt;\\n        if(cnt==2)    // if cnt of seats is 2 i have two choices\\n        {\\n            ans=ans+find(ind+1,n,str,0);  // make a partition at current index\\n            ans=ans+find(ind+1,n,str,2); // try to include aplnt if possible \\n        }\\n        \\n        else\\n        {\\n            ans=ans+find(ind+1,n,str,cnt);\\n        }\\n        return ans;\\n    }\\n    int numberOfWays(string corridor) \\n    {\\n        int ans=find(0,corridor.size(),corridor,0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n\\n    int find(int ind,int n,string&str,int cnt,vector<vector<int>>&dp)\\n    {\\n        if(ind==n-1)\\n        {\\n            if(str[ind]==\\'S\\')\\n            ++cnt;\\n            return cnt==2;\\n        }\\n        if(cnt==3)\\n        {\\n            return 0;\\n        }\\n        if(dp[ind][cnt]!=-1) // if already computed then return \\n         return dp[ind][cnt];\\n        int ans=0;\\n        if(str[ind]==\\'S\\')\\n        ++cnt;\\n        if(cnt==2)\\n        {\\n            ans=(ans%mod+find(ind+1,n,str,0,dp)%mod)%mod;\\n            ans=(ans%mod+find(ind+1,n,str,2,dp)%mod)%mod;\\n        }\\n        \\n        else\\n        {\\n            ans=(ans%mod+find(ind+1,n,str,cnt,dp)%mod)%mod;\\n        }\\n        return dp[ind][cnt]=ans; // memeozing the result \\n    }\\n    int numberOfWays(string corridor) \\n    {\\n        int n=corridor.size();\\n\\n       vector<vector<int>>dp(n,vector<int>(4,-1)); // creating dp array \\n        int ans=find(0,corridor.size(),corridor,0,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427359,
                "title": "python3-easy-to-understand-supa-ultra-fast",
                "content": "\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        c = Counter(corridor)\\n        if c[\\'S\\']%2 != 0:\\n            return 0\\n        if c[\\'S\\'] == 0:\\n            return 0\\n        if c[\\'S\\'] == 2:\\n            return 1\\n        tot = 1\\n        c = 0\\n        last = 0\\n        firstTime = True\\n        for idx,e in enumerate(corridor):\\n            if e == \\'S\\' and c==0:\\n                c+=1\\n                if last == idx:\\n                    if firstTime:\\n                        firstTime = not firstTime\\n                    continue\\n                if firstTime:\\n                    firstTime = not firstTime\\n                    continue\\n                tot *= (idx-last)\\n            elif e == \\'S\\' and c == 1:\\n                c=0\\n                last = idx\\n        return tot%1000000007\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        c = Counter(corridor)\\n        if c[\\'S\\']%2 != 0:\\n            return 0\\n        if c[\\'S\\'] == 0:\\n            return 0\\n        if c[\\'S\\'] == 2:\\n            return 1\\n        tot = 1\\n        c = 0\\n        last = 0\\n        firstTime = True\\n        for idx,e in enumerate(corridor):\\n            if e == \\'S\\' and c==0:\\n                c+=1\\n                if last == idx:\\n                    if firstTime:\\n                        firstTime = not firstTime\\n                    continue\\n                if firstTime:\\n                    firstTime = not firstTime\\n                    continue\\n                tot *= (idx-last)\\n            elif e == \\'S\\' and c == 1:\\n                c=0\\n                last = idx\\n        return tot%1000000007\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296498,
                "title": "c-solution-recursion-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    The main idea to solve this problem is you have to count the total no of consective 2 you can form..\\n    like is string conversion into \\'S\\' -> 1 and \\'P\\'-> 0 then \\n    example case for \\n    1100 10010000111\\n    if(total_sum is odd) answer is zero\\n    else\\n    like case 10100001001001100000101\\n    you need to calculate the how many times running sum starting from i is there.\\n    add to the answer and now again call the function from after that index thus\\n    giveing answer = answer * solve();\\n    // we have calculated the prev because we need to go to only index where from back we can made sum 2..\\n    */\\n    const int mod = 1e9+7;\\n    #define int2 long long\\n    int2 solve(vector<int>&t,int i,int prev){\\n        int2 ans = 0;\\n        int2 sum = 0;\\n        for(int j = i;j<prev;j++){\\n            sum += t[j];\\n            if(sum == 2){\\n                ans++;\\n            }\\n            else if(sum >2){\\n                ans = (ans%mod*solve(t,j,prev)%mod)%mod;\\n                break;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        int sum = 0;\\n        vector<int>t(n);\\n        for(int i = 0;i<n;i++){\\n            if(corridor[i] == \\'S\\'){\\n                sum ++;\\n                t[i] = 1;\\n            }\\n            else{\\n                t[i] = 0;\\n            }\\n        }\\n        \\n        if(sum%2 != 0 || sum == 0){\\n            return 0;\\n        }\\n        int prev;\\n        sum = 0;\\n        for(int i = n-1;i>=0;i--){\\n            sum += t[i];\\n            if(sum == 2){\\n                prev  = i;\\n                break;\\n            }\\n        }\\n        int2 ans= max((int2)1,solve(t,0,prev)%mod);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    The main idea to solve this problem is you have to count the total no of consective 2 you can form..\\n    like is string conversion into \\'S\\' -> 1 and \\'P\\'-> 0 then \\n    example case for \\n    1100 10010000111\\n    if(total_sum is odd) answer is zero\\n    else\\n    like case 10100001001001100000101\\n    you need to calculate the how many times running sum starting from i is there.\\n    add to the answer and now again call the function from after that index thus\\n    giveing answer = answer * solve();\\n    // we have calculated the prev because we need to go to only index where from back we can made sum 2..\\n    */\\n    const int mod = 1e9+7;\\n    #define int2 long long\\n    int2 solve(vector<int>&t,int i,int prev){\\n        int2 ans = 0;\\n        int2 sum = 0;\\n        for(int j = i;j<prev;j++){\\n            sum += t[j];\\n            if(sum == 2){\\n                ans++;\\n            }\\n            else if(sum >2){\\n                ans = (ans%mod*solve(t,j,prev)%mod)%mod;\\n                break;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        int sum = 0;\\n        vector<int>t(n);\\n        for(int i = 0;i<n;i++){\\n            if(corridor[i] == \\'S\\'){\\n                sum ++;\\n                t[i] = 1;\\n            }\\n            else{\\n                t[i] = 0;\\n            }\\n        }\\n        \\n        if(sum%2 != 0 || sum == 0){\\n            return 0;\\n        }\\n        int prev;\\n        sum = 0;\\n        for(int i = n-1;i>=0;i--){\\n            sum += t[i];\\n            if(sum == 2){\\n                prev  = i;\\n                break;\\n            }\\n        }\\n        int2 ans= max((int2)1,solve(t,0,prev)%mod);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284537,
                "title": "c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string c) {\\n        int n = c.size(), mod = (int) 1000000007;\\n        int seats = 0;\\n        for(auto i: c) {\\n            if(i == \\'S\\') seats++;\\n        }\\n\\n        if(seats % 2 != 0 or seats == 0) return 0; // seats should be even and greater than 0\\n\\n        long long ans = 1L;\\n        seats = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(c[i] == \\'S\\') seats++;\\n            if(seats == 2) {\\n                int divider = 1;\\n                i++;\\n                \\n                while(i < n and c[i] == \\'P\\') \\n                    divider++, i++;\\n                \\n                if(i == n) break;\\n                ans = (ans * divider) % mod;\\n                seats = 0;\\n                i--;\\n            } /* else if(c[i] == \\'P\\') seats = 0; */\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string c) {\\n        int n = c.size(), mod = (int) 1000000007;\\n        int seats = 0;\\n        for(auto i: c) {\\n            if(i == \\'S\\') seats++;\\n        }\\n\\n        if(seats % 2 != 0 or seats == 0) return 0; // seats should be even and greater than 0\\n\\n        long long ans = 1L;\\n        seats = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(c[i] == \\'S\\') seats++;\\n            if(seats == 2) {\\n                int divider = 1;\\n                i++;\\n                \\n                while(i < n and c[i] == \\'P\\') \\n                    divider++, i++;\\n                \\n                if(i == n) break;\\n                ans = (ans * divider) % mod;\\n                seats = 0;\\n                i--;\\n            } /* else if(c[i] == \\'P\\') seats = 0; */\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268714,
                "title": "c-easy-solution-using-dp-memoization-tc-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //using take not take variation\\n    //tc=o(n)\\n    //sc=o(n)+o(stack space)\\n    int mod=1e9+7;\\n    int find(int i,int c,string& s,vector<vector<int>>& dp,int n){\\n        if(i==n){           \\n            return 1;\\n        }\\n        if(dp[i][c]!=-1){\\n            return dp[i][c]%mod;\\n        }\\n        if(s[i]==\\'S\\'){\\n            c++;\\n        }\\n        int ways=0;\\n        if(c==2){            \\n            ways=(ways+find(i+1,0,s,dp,n))%mod;           \\n        }\\n        if(i!=n-1){\\n             if(c<=2){\\n                 ways=(ways+find(i+1,c,s,dp,n))%mod;\\n             }\\n        } \\n        return dp[i][c]=ways%mod;\\n    }\\n    int numberOfWays(string corridor) {\\n        int n=corridor.size();\\n        vector<vector<int>> dp(n,vector<int>(4,-1));\\n        return find(0,0,corridor,dp,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //using take not take variation\\n    //tc=o(n)\\n    //sc=o(n)+o(stack space)\\n    int mod=1e9+7;\\n    int find(int i,int c,string& s,vector<vector<int>>& dp,int n){\\n        if(i==n){           \\n            return 1;\\n        }\\n        if(dp[i][c]!=-1){\\n            return dp[i][c]%mod;\\n        }\\n        if(s[i]==\\'S\\'){\\n            c++;\\n        }\\n        int ways=0;\\n        if(c==2){            \\n            ways=(ways+find(i+1,0,s,dp,n))%mod;           \\n        }\\n        if(i!=n-1){\\n             if(c<=2){\\n                 ways=(ways+find(i+1,c,s,dp,n))%mod;\\n             }\\n        } \\n        return dp[i][c]=ways%mod;\\n    }\\n    int numberOfWays(string corridor) {\\n        int n=corridor.size();\\n        vector<vector<int>> dp(n,vector<int>(4,-1));\\n        return find(0,0,corridor,dp,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254735,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn number_of_ways(corridor: String) -> i32 {\\n        let mut res = 1;\\n        let mut j = 0;\\n        let mut k = 0;\\n        let mod_ = 1_000_000_007;\\n        for (i, c) in corridor.chars().enumerate() {\\n            if c == \\'S\\' {\\n                k += 1;\\n                if k > 2 && k % 2 == 1 {\\n                    res = res * (i as i64 - j) % mod_;\\n                }\\n                j = i as i64;\\n            }\\n        }\\n        if k % 2 == 0 && k > 0 {\\n            res as _\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn number_of_ways(corridor: String) -> i32 {\\n        let mut res = 1;\\n        let mut j = 0;\\n        let mut k = 0;\\n        let mod_ = 1_000_000_007;\\n        for (i, c) in corridor.chars().enumerate() {\\n            if c == \\'S\\' {\\n                k += 1;\\n                if k > 2 && k % 2 == 1 {\\n                    res = res * (i as i64 - j) % mod_;\\n                }\\n                j = i as i64;\\n            }\\n        }\\n        if k % 2 == 0 && k > 0 {\\n            res as _\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3251066,
                "title": "c-o-n-little-explantation-faster-than-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int count = 0, left = 0;\\n        int n = corridor.size();\\n        long long int res = 1;\\n        for(int i=0;i<n;i++){\\n            if(corridor[i] == \\'S\\'){\\n                // start record how many space to the next \\'S\\n                if(count == 1){\\n                    left = i;\\n                    count++;\\n                }\\n                // end record of space\\n                else if(count == 2){\\n                    res *= (i-left);\\n                    res %= 1000000007;\\n                    count = 1;\\n                }\\n                else{\\n                    count++;\\n                }\\n            }\\n        }\\n        // \\'S\\'\\'s count is lower than 2\\n        if(count < 2){\\n            return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int count = 0, left = 0;\\n        int n = corridor.size();\\n        long long int res = 1;\\n        for(int i=0;i<n;i++){\\n            if(corridor[i] == \\'S\\'){\\n                // start record how many space to the next \\'S\\n                if(count == 1){\\n                    left = i;\\n                    count++;\\n                }\\n                // end record of space\\n                else if(count == 2){\\n                    res *= (i-left);\\n                    res %= 1000000007;\\n                    count = 1;\\n                }\\n                else{\\n                    count++;\\n                }\\n            }\\n        }\\n        // \\'S\\'\\'s count is lower than 2\\n        if(count < 2){\\n            return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198395,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor):\\n        ans = [i for i,c in enumerate(corridor) if c == \"S\"]\\n\\n        if len(ans)%2 == 1 or not ans: return 0\\n\\n        total = 1\\n\\n        for i in range(1,len(ans)-1,2):\\n            total *= ans[i+1] - ans[i]\\n\\n        return total%(10**9+7)\\n\\n        \\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor):\\n        ans = [i for i,c in enumerate(corridor) if c == \"S\"]\\n\\n        if len(ans)%2 == 1 or not ans: return 0\\n\\n        total = 1\\n\\n        for i in range(1,len(ans)-1,2):\\n            total *= ans[i+1] - ans[i]\\n\\n        return total%(10**9+7)\\n\\n        \\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184916,
                "title": "python-solution-using-dp",
                "content": "# Complexity\\n- Time complexity:\\n    $$O(3*n)$$\\n\\n- Space complexity:\\n    $$O(3*n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        dp=[[-1,-1,-1] for _ in range(len(corridor))]\\n        return self.get(corridor,0,0,dp)\\n    def get(self,corridor,i,r,dp):\\n        if(i>=len(corridor)):\\n            if(r==2):\\n                return 1\\n            return 0\\n        elif(dp[i][r]!=-1):\\n            return dp[i][r]\\n        else:\\n            if(corridor[i]==\\'P\\'):\\n                if(r==2):\\n                    dp[i][r]=self.get(corridor,i+1,r,dp)+self.get(corridor,i+1,0,dp)\\n                else:\\n                    dp[i][r]=self.get(corridor,i+1,r,dp)\\n            else:\\n                if(r==2):\\n                    dp[i][r]=self.get(corridor,i+1,1,dp)\\n                else:\\n                    dp[i][r]=self.get(corridor,i+1,r+1,dp)\\n            dp[i][r]%=(int(1e9+7))\\n            return dp[i][r]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        dp=[[-1,-1,-1] for _ in range(len(corridor))]\\n        return self.get(corridor,0,0,dp)\\n    def get(self,corridor,i,r,dp):\\n        if(i>=len(corridor)):\\n            if(r==2):\\n                return 1\\n            return 0\\n        elif(dp[i][r]!=-1):\\n            return dp[i][r]\\n        else:\\n            if(corridor[i]==\\'P\\'):\\n                if(r==2):\\n                    dp[i][r]=self.get(corridor,i+1,r,dp)+self.get(corridor,i+1,0,dp)\\n                else:\\n                    dp[i][r]=self.get(corridor,i+1,r,dp)\\n            else:\\n                if(r==2):\\n                    dp[i][r]=self.get(corridor,i+1,1,dp)\\n                else:\\n                    dp[i][r]=self.get(corridor,i+1,r+1,dp)\\n            dp[i][r]%=(int(1e9+7))\\n            return dp[i][r]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128335,
                "title": "greedy-combinations-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int cnt = 0;\\n        for(char c : corridor) cnt += c == \\'S\\';\\n        if(!cnt || cnt % 2) return 0;\\n\\n        long long cntS = 0, cntP = 0, n = corridor.size(), ans = 1, mod = 1e9 + 7;\\n        for(int i=0; i<n; i++) {\\n            cntS += corridor[i] == \\'S\\';\\n            if(cntS == 2) {\\n                while(i < n - 1 && corridor[i + 1] == \\'P\\') cntP++, i++;\\n                if(i < n - 1) ans = (ans * ++cntP) % mod;\\n                cntP = cntS = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int cnt = 0;\\n        for(char c : corridor) cnt += c == \\'S\\';\\n        if(!cnt || cnt % 2) return 0;\\n\\n        long long cntS = 0, cntP = 0, n = corridor.size(), ans = 1, mod = 1e9 + 7;\\n        for(int i=0; i<n; i++) {\\n            cntS += corridor[i] == \\'S\\';\\n            if(cntS == 2) {\\n                while(i < n - 1 && corridor[i + 1] == \\'P\\') cntP++, i++;\\n                if(i < n - 1) ans = (ans * ++cntP) % mod;\\n                cntP = cntS = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068111,
                "title": "simple-counting-solution-c-o-n-time-o-1-space",
                "content": "# Intuition\\nThe only thing that matters here is the number of plants between groups of two chairs. If there\\'re X plants between two such groups, then there\\'re X + 1 ways to place a divider there. Plants inside a group don\\'t matter.\\n\\n# Approach\\nIterate the corridor. Count the chairs. If we\\'ve completed a group of two chairs:\\n1. Count plants between the current group and the next one\\n2. Update the result (the total number of ways)\\n3. Reset the counters and start counting chairs again\\n\\nDon\\'t forget to check if the last group of chairs was complete.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumberOfWays(string corridor) {\\n        const long MOD = 1_000_000_007L;\\n\\n        long result = 1;\\n        int chairCount = 0;\\n        int plantCount = 0;\\n\\n        foreach (char c in corridor) {\\n            if (c == \\'P\\') {\\n                plantCount++;\\n                continue;\\n            }\\n\\n            chairCount++;\\n\\n            if (chairCount == 2) {\\n                // We\\'ve completed a group of two chairs. Number of plants between these chairs\\n                // doesn\\'t matter. Reset the plant counter to start counting plants after\\n                // the current group and before the next group of two chairs;\\n\\n                plantCount = 0;\\n            } else if (chairCount == 3) {\\n                // We\\'re starting a new group of two chairs, so we must place a divider between\\n                // the current group and the previous one.\\n                // There\\'re (plantCount + 1) ways to do it\\n                result = result * (plantCount + 1) % MOD;\\n                \\n                // Reset the counters and start over\\n                chairCount = 1;\\n                plantCount = 0;\\n            }\\n        }\\n\\n        // If the last group of chairs is incomplete, then it\\'s impossible to\\n        // divide the corridor\\n        if (chairCount != 2)\\n            return 0;\\n\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumberOfWays(string corridor) {\\n        const long MOD = 1_000_000_007L;\\n\\n        long result = 1;\\n        int chairCount = 0;\\n        int plantCount = 0;\\n\\n        foreach (char c in corridor) {\\n            if (c == \\'P\\') {\\n                plantCount++;\\n                continue;\\n            }\\n\\n            chairCount++;\\n\\n            if (chairCount == 2) {\\n                // We\\'ve completed a group of two chairs. Number of plants between these chairs\\n                // doesn\\'t matter. Reset the plant counter to start counting plants after\\n                // the current group and before the next group of two chairs;\\n\\n                plantCount = 0;\\n            } else if (chairCount == 3) {\\n                // We\\'re starting a new group of two chairs, so we must place a divider between\\n                // the current group and the previous one.\\n                // There\\'re (plantCount + 1) ways to do it\\n                result = result * (plantCount + 1) % MOD;\\n                \\n                // Reset the counters and start over\\n                chairCount = 1;\\n                plantCount = 0;\\n            }\\n        }\\n\\n        // If the last group of chairs is incomplete, then it\\'s impossible to\\n        // divide the corridor\\n        if (chairCount != 2)\\n            return 0;\\n\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871050,
                "title": "javasscript-solution-with-linear-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I was confused on what the question was asking. So i focused on being able to solve the three test conditions it gave in the description. I found an approach that would solve that by counting the Ps between Ss. However, it had memory problems\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy main problem was memory. I couldn\\'t save all the data to one variable and report it at the end, some of the rows were way too long for that. So I looked at the modulo and got an understanding of that (i had not encountered a modulo utilized in this purpose before so my first solution omitted it). However, I then realized that I could save the number of spaces for dividers in between the two viable seats and then use a reduction to calculate the total.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time Complexity I believe is linear because it increases proportionally to the length of the string (corridor) that is submitted\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI believe the space complexity is log because some data is being saved along the way to the solution but it is much smaller than the entire corridor; it only contains a 4 seats of information at a time.\\n\\n# Code\\n```\\n/**\\n * @param {string} corridor\\n * @return {number}\\n */\\nvar numberOfWays = function(corridor) {\\n    let numberOfSeats = 0;\\n    let indeciesOfSeats = [];\\n    let dividers = [];\\n    const mod = 10 **9 + 7;\\n    for (let i=0; i < corridor.length; i++) {\\n        if (corridor[i] === \\'S\\') {\\n            numberOfSeats++;\\n            indeciesOfSeats.push(i);\\n\\n            if (indeciesOfSeats.length === 4) {\\n                const dividerBeginning = indeciesOfSeats[1];\\n                const dividerEnding = indeciesOfSeats[2];\\n                dividers.push( dividerEnding-dividerBeginning );\\n                indeciesOfSeats.shift();\\n                indeciesOfSeats.shift();\\n            }\\n        }\\n    }\\n    \\n    if (numberOfSeats % 2 || numberOfSeats < 2) {\\n        return 0;\\n    }\\n    if (dividers.length < 1) {\\n        return 1;\\n    }\\n    return dividers.reduce((a,c) => ( a * c % mod));\\n    };\\n\\n\\n            \\n    \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} corridor\\n * @return {number}\\n */\\nvar numberOfWays = function(corridor) {\\n    let numberOfSeats = 0;\\n    let indeciesOfSeats = [];\\n    let dividers = [];\\n    const mod = 10 **9 + 7;\\n    for (let i=0; i < corridor.length; i++) {\\n        if (corridor[i] === \\'S\\') {\\n            numberOfSeats++;\\n            indeciesOfSeats.push(i);\\n\\n            if (indeciesOfSeats.length === 4) {\\n                const dividerBeginning = indeciesOfSeats[1];\\n                const dividerEnding = indeciesOfSeats[2];\\n                dividers.push( dividerEnding-dividerBeginning );\\n                indeciesOfSeats.shift();\\n                indeciesOfSeats.shift();\\n            }\\n        }\\n    }\\n    \\n    if (numberOfSeats % 2 || numberOfSeats < 2) {\\n        return 0;\\n    }\\n    if (dividers.length < 1) {\\n        return 1;\\n    }\\n    return dividers.reduce((a,c) => ( a * c % mod));\\n    };\\n\\n\\n            \\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2860711,
                "title": "python-easy-and-90-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        \\n        l=len(corridor)\\n        count=0\\n        last=-1\\n        ans=1\\n        for i in range(l):\\n            if corridor[i]==\\'S\\':\\n                count+=1\\n                if count%2==0:\\n                    last=i\\n                elif count%2==1 and last!=-1:\\n                    ans*=(i-last)\\n        if count%2!=0 or count==0:\\n            return 0\\n        return ans%1000000007\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        \\n        l=len(corridor)\\n        count=0\\n        last=-1\\n        ans=1\\n        for i in range(l):\\n            if corridor[i]==\\'S\\':\\n                count+=1\\n                if count%2==0:\\n                    last=i\\n                elif count%2==1 and last!=-1:\\n                    ans*=(i-last)\\n        if count%2!=0 or count==0:\\n            return 0\\n        return ans%1000000007\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830510,
                "title": "javascript-o-n",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {string} corridor\\n * @return {number}\\n */\\nvar numberOfWays = function(corridor) {\\n\\n  let ans = 1;\\n  let start = 0;\\n\\n  // remove left side plants\\n  while(start < corridor.length && corridor[start] != \"S\") start++;\\n  if(start == corridor.length) return 0;\\n\\n  //remove right plants\\n  let end = corridor.length-1;\\n  while(corridor[end] == \"P\") end--;\\n\\n  corridor = corridor.substring(start, end+1);\\n  start = 0;\\n  end = corridor.length\\n  while(start < end){\\n      let chairs = 0;\\n      let plants = 1;\\n\\n      // get 2 chairs  \\n      while(start < end && chairs != 2) {\\n          if(corridor[start++] == \"S\") chairs++;\\n      }\\n      \\n      // if chairs != 2, we can not have this combination  \\n      if(start == end && chairs != 2) return 0;\\n\\n      // find out number of plants between two groups of 2 chairs\\n      while(start < end && corridor[start]!= \"S\"){\\n          plants++;\\n          start++;\\n      }\\n      \\n      ans = (ans * plants) % (1e9+7);\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} corridor\\n * @return {number}\\n */\\nvar numberOfWays = function(corridor) {\\n\\n  let ans = 1;\\n  let start = 0;\\n\\n  // remove left side plants\\n  while(start < corridor.length && corridor[start] != \"S\") start++;\\n  if(start == corridor.length) return 0;\\n\\n  //remove right plants\\n  let end = corridor.length-1;\\n  while(corridor[end] == \"P\") end--;\\n\\n  corridor = corridor.substring(start, end+1);\\n  start = 0;\\n  end = corridor.length\\n  while(start < end){\\n      let chairs = 0;\\n      let plants = 1;\\n\\n      // get 2 chairs  \\n      while(start < end && chairs != 2) {\\n          if(corridor[start++] == \"S\") chairs++;\\n      }\\n      \\n      // if chairs != 2, we can not have this combination  \\n      if(start == end && chairs != 2) return 0;\\n\\n      // find out number of plants between two groups of 2 chairs\\n      while(start < end && corridor[start]!= \"S\"){\\n          plants++;\\n          start++;\\n      }\\n      \\n      ans = (ans * plants) % (1e9+7);\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2817973,
                "title": "easy-c-o-n-solution-tc-o-n",
                "content": "**IF YOU FOUND THIS SOLUTION HELPFUL THEN PLEASE LIKE IT**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numberOfWays(string s) {\\n\\t\\t\\tint m=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'S\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(m==0 or m%2!=0)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint c=0;\\n\\t\\t\\tint k=-1;\\n\\t\\t\\tlong long x=1;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'S\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(c==2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tk=i;\\n\\t\\t\\t\\t\\tc=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(k!=-1 and c==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tx=(x*(i-k))%1000000007;\\n\\t\\t\\t\\t\\tk=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numberOfWays(string s) {\\n\\t\\t\\tint m=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'S\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2775739,
                "title": "javascript-relatively-simple",
                "content": "```js\\nvar numberOfWays = function(core) {\\n    let memo = new Array(core.length+1).fill(-1);\\n    let dfs = function(lastDivider, memo) {\\n        var k;\\n        var count=0;\\n        let answers=0;\\n        \\n        if( lastDivider == core.length ) return 1;\\n                \\n        if( memo[lastDivider] != -1 ) {\\n            return memo[lastDivider];\\n        }\\n        \\n        for( k=lastDivider; count<2&&k<core.length; k++ ) {\\n            if( core[k] == \\'S\\' ) count++;\\n        }\\n        \\n        if( k == core.length ) {\\n            if( count == 2 )\\n                answers = 1;\\n        } else {\\n            \\n            while( k<core.length && core[k] != \\'S\\' ) {\\n                k++;\\n                answers++;\\n            }\\n            if( k != core.length ) {\\n                answers++;\\n                let sub = dfs(k, memo);\\n                answers = answers*sub;\\n            } else {\\n                answers = 1;\\n            }\\n            \\n        }\\n        \\n        while( answers >= 1000000007 ) answers -= 1000000007;\\n        memo[lastDivider] = answers;\\n        return answers;\\n    };\\n    \\n    return dfs(0, memo);\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar numberOfWays = function(core) {\\n    let memo = new Array(core.length+1).fill(-1);\\n    let dfs = function(lastDivider, memo) {\\n        var k;\\n        var count=0;\\n        let answers=0;\\n        \\n        if( lastDivider == core.length ) return 1;\\n                \\n        if( memo[lastDivider] != -1 ) {\\n            return memo[lastDivider];\\n        }\\n        \\n        for( k=lastDivider; count<2&&k<core.length; k++ ) {\\n            if( core[k] == \\'S\\' ) count++;\\n        }\\n        \\n        if( k == core.length ) {\\n            if( count == 2 )\\n                answers = 1;\\n        } else {\\n            \\n            while( k<core.length && core[k] != \\'S\\' ) {\\n                k++;\\n                answers++;\\n            }\\n            if( k != core.length ) {\\n                answers++;\\n                let sub = dfs(k, memo);\\n                answers = answers*sub;\\n            } else {\\n                answers = 1;\\n            }\\n            \\n        }\\n        \\n        while( answers >= 1000000007 ) answers -= 1000000007;\\n        memo[lastDivider] = answers;\\n        return answers;\\n    };\\n    \\n    return dfs(0, memo);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2773868,
                "title": "simple-dp-solution-java",
                "content": "```\\nclass Solution {\\n    int MAX = (int)1e8 + 5;\\n    long MOD = (int)1e9 + 7;\\n    Long[][] dp;\\n    long helper(int i, char[] co, int cnt){\\n        if(i >= co.length){\\n            if(cnt == 2) return 1L;\\n            else return 0L;\\n        }\\n        \\n        if(co[i] == \\'S\\') cnt++;\\n        \\n        if(cnt > 2) return 0L;\\n        \\n        if(dp[i][cnt] != null) return dp[i][cnt];\\n        if(cnt == 2){\\n            // not make zero\\n            long a = helper(i+1, co, cnt);\\n            long b = helper(i+1, co, 0);\\n            return (a + b)%MOD;\\n        }\\n        return dp[i][cnt] = helper(i+1, co, cnt)%MOD;\\n    }\\n    public int numberOfWays(String co) {\\n        dp = new Long[co.length()+1][3];\\n        return (int)helper(0, co.toCharArray(), 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MAX = (int)1e8 + 5;\\n    long MOD = (int)1e9 + 7;\\n    Long[][] dp;\\n    long helper(int i, char[] co, int cnt){\\n        if(i >= co.length){\\n            if(cnt == 2) return 1L;\\n            else return 0L;\\n        }\\n        \\n        if(co[i] == \\'S\\') cnt++;\\n        \\n        if(cnt > 2) return 0L;\\n        \\n        if(dp[i][cnt] != null) return dp[i][cnt];\\n        if(cnt == 2){\\n            // not make zero\\n            long a = helper(i+1, co, cnt);\\n            long b = helper(i+1, co, 0);\\n            return (a + b)%MOD;\\n        }\\n        return dp[i][cnt] = helper(i+1, co, cnt)%MOD;\\n    }\\n    public int numberOfWays(String co) {\\n        dp = new Long[co.length()+1][3];\\n        return (int)helper(0, co.toCharArray(), 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730082,
                "title": "simple-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int numberOfWays(string corridor) {\\n         long cnt = 2 , borders = 0 , ans = 1 , s = count(corridor.begin(),corridor.end(),\\'S\\');\\n         if(!s || s % 2) return 0;\\n         for(int i=0; i<corridor.size(); i++) {\\n               if(cnt == 0 && corridor[i] == \\'S\\') { \\n                   ans = (ans * borders) % mod; // combine the adjacent borders!\\n                   cnt = 2 , borders = 0; \\n               }\\n               if(corridor[i] == \\'S\\') cnt--;\\n               if(cnt == 0) borders++; // you can border after every plant or no plant when two seats are found!\\n         }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int numberOfWays(string corridor) {\\n         long cnt = 2 , borders = 0 , ans = 1 , s = count(corridor.begin(),corridor.end(),\\'S\\');\\n         if(!s || s % 2) return 0;\\n         for(int i=0; i<corridor.size(); i++) {\\n               if(cnt == 0 && corridor[i] == \\'S\\') { \\n                   ans = (ans * borders) % mod; // combine the adjacent borders!\\n                   cnt = 2 , borders = 0; \\n               }\\n               if(corridor[i] == \\'S\\') cnt--;\\n               if(cnt == 0) borders++; // you can border after every plant or no plant when two seats are found!\\n         }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683363,
                "title": "simple-backtracking-solution-python",
                "content": "You dont need to cache/store data for all the calls.\\nYou can store it but there are no benefits\\nThe below code is recurssive but can easily be translated into iterative\\nFor each section with two chairs you just need to number of ways to divide prev section and multiply their results.\\nWhy multiply? well if I can divide left section in 2 ways and right section is 2 ways there are 4 ways.\\nThe way you divide sections can vary, I made sure that beginning of curr_section is always a chair, but ending of a section can have plants\\n(number of ending plants + 1 = number of positions you can put the wall.)\\n```\\ndef numberOfWays(self, corridor: str) -> int:\\n    #you must have even number of seats in order for each section to have two seats\\n    if corridor.count(\"S\")%2: return 0\\n    n = len(corridor)\\n    \\n    def dp(i, j):\\n        chairCount = 0\\n        k = i\\n        while k <= j and chairCount < 2:\\n            if corridor[k] == \"S\":\\n                chairCount += 1\\n            k += 1\\n        #if the no. of chair in curr section < 2 return 0 since its not a valid section\\n        if chairCount != 2:\\n            return 0\\n        #e_i = 2nd chair index\\n        e_i = k \\n        while k <= j and corridor[k]!=\"S\":\\n            k += 1\\n        #if there is no section to the right return 1 because you can only place divider at the end of curr_section\\n        if k > j:\\n            return 1\\n        #k - e_i = number of plant b/w 2nd chair ans start of new section   \\n        return (k - e_i + 1) * dp(k, j)\\n    \\n    return dp(0, len(corridor) - 1) % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\ndef numberOfWays(self, corridor: str) -> int:\\n    #you must have even number of seats in order for each section to have two seats\\n    if corridor.count(\"S\")%2: return 0\\n    n = len(corridor)\\n    \\n    def dp(i, j):\\n        chairCount = 0\\n        k = i\\n        while k <= j and chairCount < 2:\\n            if corridor[k] == \"S\":\\n                chairCount += 1\\n            k += 1\\n        #if the no. of chair in curr section < 2 return 0 since its not a valid section\\n        if chairCount != 2:\\n            return 0\\n        #e_i = 2nd chair index\\n        e_i = k \\n        while k <= j and corridor[k]!=\"S\":\\n            k += 1\\n        #if there is no section to the right return 1 because you can only place divider at the end of curr_section\\n        if k > j:\\n            return 1\\n        #k - e_i = number of plant b/w 2nd chair ans start of new section   \\n        return (k - e_i + 1) * dp(k, j)\\n    \\n    return dp(0, len(corridor) - 1) % 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2666017,
                "title": "python3-indicies-combinatorial",
                "content": "Split the chairs into pairs. The only choices are where to put the dividers between pairs, so it only matters how many plants are between each pair. In Python we can just use indices to compute this.\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, A: str) -> int:\\n        # edge cases\\n        count = Counter(A)\\n        if count[\"S\"] % 2 != 0:\\n            return 0\\n        if count[\"S\"] == 0:\\n            return 0\\n        if count[\"S\"] == 2:\\n            return 1\\n        # count chairs by twos, between which there must be put a divider\\n        # if there are n plants between two pairs, there are n + 1 options \\n        # for where to put the divider\\n        # multiply these options to get the final count\\n        chairlocs = [i for i, val in enumerate(A) if val == \"S\"]\\n        pairdists = [chairlocs[i] - chairlocs[i-1] for i in range(2, len(chairlocs), 2)]\\n        return reduce((lambda x, y: (x * y) % (10 ** 9 + 7)), pairdists)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, A: str) -> int:\\n        # edge cases\\n        count = Counter(A)\\n        if count[\"S\"] % 2 != 0:\\n            return 0\\n        if count[\"S\"] == 0:\\n            return 0\\n        if count[\"S\"] == 2:\\n            return 1\\n        # count chairs by twos, between which there must be put a divider\\n        # if there are n plants between two pairs, there are n + 1 options \\n        # for where to put the divider\\n        # multiply these options to get the final count\\n        chairlocs = [i for i, val in enumerate(A) if val == \"S\"]\\n        pairdists = [chairlocs[i] - chairlocs[i-1] for i in range(2, len(chairlocs), 2)]\\n        return reduce((lambda x, y: (x * y) % (10 ** 9 + 7)), pairdists)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654796,
                "title": "python-solution-fatser-90",
                "content": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, s):\\n\\t\\t\\ta = [i for i,c in enumerate(s) if c == \\'S\\']\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor i in xrange(1,len(a) - 1,2):\\n\\t\\t\\t\\tres *= a[i+1] - a[i]\\n\\t\\t\\treturn res % (10**9+7) * (len(a) % 2 == 0 and len(a) >= 2)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, s):\\n\\t\\t\\ta = [i for i,c in enumerate(s) if c == \\'S\\']\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor i in xrange(1,len(a) - 1,2):\\n\\t\\t\\t\\tres *= a[i+1] - a[i]\\n\\t\\t\\treturn res % (10**9+7) * (len(a) % 2 == 0 and len(a) >= 2)",
                "codeTag": "Java"
            },
            {
                "id": 2618097,
                "title": "python-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        numSeats = corridor.count(\\'S\\')\\n        if not numSeats or numSeats % 2:\\n            return 0\\n        curSeats, inBetweenPlants, ans = 0, 0, 1\\n        for obj in corridor:\\n            if obj == \\'S\\':\\n                curSeats += 1\\n            if curSeats == 2 and obj == \\'P\\':\\n                inBetweenPlants += 1\\n            if curSeats > 2:\\n                ans *= (inBetweenPlants + 1)\\n                curSeats -= 2\\n                inBetweenPlants = 0\\n        return ans % 1000000007\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        numSeats = corridor.count(\\'S\\')\\n        if not numSeats or numSeats % 2:\\n            return 0\\n        curSeats, inBetweenPlants, ans = 0, 0, 1\\n        for obj in corridor:\\n            if obj == \\'S\\':\\n                curSeats += 1\\n            if curSeats == 2 and obj == \\'P\\':\\n                inBetweenPlants += 1\\n            if curSeats > 2:\\n                ans *= (inBetweenPlants + 1)\\n                curSeats -= 2\\n                inBetweenPlants = 0\\n        return ans % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608934,
                "title": "python-simple-solution",
                "content": "```\\ndef numberOfWays(self, strs: str) -> int:\\n\\ts = strs.count(\\'S\\')\\n\\tif s%2 or not s:\\n\\t\\treturn 0\\n\\t# number of \\'s\\' should be positive even number\\n\\n\\ts, p, ans = 0, 0, 1  # seats, plants, answer\\n\\tfor a in strs:\\n\\t\\tif a==\\'S\\':\\n\\t\\t\\ts += 1\\n\\t\\tif s==2 and a==\\'P\\':\\n\\t\\t\\tp += 1\\n\\t\\tif s>2:\\n\\t\\t\\tans *= (p+1)\\n\\t\\t\\ts -= 2\\n\\t\\t\\tp = 0\\n\\treturn ans % (10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\ndef numberOfWays(self, strs: str) -> int:\\n\\ts = strs.count(\\'S\\')\\n\\tif s%2 or not s:\\n\\t\\treturn 0\\n\\t# number of \\'s\\' should be positive even number\\n\\n\\ts, p, ans = 0, 0, 1  # seats, plants, answer\\n\\tfor a in strs:\\n\\t\\tif a==\\'S\\':\\n\\t\\t\\ts += 1\\n\\t\\tif s==2 and a==\\'P\\':\\n\\t\\t\\tp += 1\\n\\t\\tif s>2:\\n\\t\\t\\tans *= (p+1)\\n\\t\\t\\ts -= 2\\n\\t\\t\\tp = 0\\n\\treturn ans % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2579869,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    \\n    int numberOfWays(string s) {\\n        int mod=1000000007;\\n        int n=s.size();\\n     int seat=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'S\\')seat++;\\n        }\\n        \\n        if(seat%2!=0||seat==0)return 0;\\n        \\n        int count=0;\\n        long long ans=1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n           if(count==2){\\n               int p=0;\\n               \\n               while(i<n&&s[i]==\\'P\\'){\\n                   p++; \\n                   i++;\\n               }\\n               \\n               if(i!=n)\\n               ans=(ans*(p+1))%mod;\\n               \\n               count=0;\\n               i--;    \\n           } \\n            \\n            \\n           else if(s[i]==\\'S\\')count++;        \\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n    \\n    \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int numberOfWays(string s) {\\n        int mod=1000000007;\\n        int n=s.size();\\n     int seat=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'S\\')seat++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2553240,
                "title": "c-permutations",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll M = 1e9+7;\\n    int numberOfWays(string corridor) {\\n        int seats = 0, n = corridor.size();\\n\\t\\t// no of seats in current segment\\n        int  curr = 0;\\n        ll ans = 1;\\n        for(int i=0; i<n; i++){\\n            if(corridor[i] == \\'S\\') seats++;\\n\\t\\t\\t// if seats in curr segment is 2 then we can place a division here\\n            if(seats == 2) curr++;\\n\\t\\t\\t// if seats in curr segment crossed 2\\n            else if(seats > 2){\\n\\t\\t\\t\\t// update ans by multiplying previous divisions\\n                ans = ans*curr;\\n                ans %= M;\\n\\t\\t\\t\\t// set divisions to zero\\n                curr = 0;\\n\\t\\t\\t\\t// seats to 1\\n                seats = 1;\\n            }\\n        }\\n\\t\\t// if in last division we don\\'t have 2 seats, return 0\\n        if(curr == 0) return 0;\\n\\t\\t// else return ans, we don\\'t need to consider the last division as that can only be marked as one\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll M = 1e9+7;\\n    int numberOfWays(string corridor) {\\n        int seats = 0, n = corridor.size();\\n\\t\\t// no of seats in current segment\\n        int  curr = 0;\\n        ll ans = 1;\\n        for(int i=0; i<n; i++){\\n            if(corridor[i] == \\'S\\') seats++;\\n\\t\\t\\t// if seats in curr segment is 2 then we can place a division here\\n            if(seats == 2) curr++;\\n\\t\\t\\t// if seats in curr segment crossed 2\\n            else if(seats > 2){\\n\\t\\t\\t\\t// update ans by multiplying previous divisions\\n                ans = ans*curr;\\n                ans %= M;\\n\\t\\t\\t\\t// set divisions to zero\\n                curr = 0;\\n\\t\\t\\t\\t// seats to 1\\n                seats = 1;\\n            }\\n        }\\n\\t\\t// if in last division we don\\'t have 2 seats, return 0\\n        if(curr == 0) return 0;\\n\\t\\t// else return ans, we don\\'t need to consider the last division as that can only be marked as one\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535411,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        \\n        // if(corridor.size()<=1)return 0;\\n        vector<int> cnt;\\n        int seat = 0, plant = 0, m = 1e9+7;\\n        for(int i=0;i<corridor.size();i++){\\n            if(corridor[i] == \\'S\\'){\\n                seat++;\\n                if(plant){\\n                    cnt.push_back(plant);\\n                    plant = 0;\\n                }\\n            }\\n            else{\\n                if(seat!=0 && seat%2==0){\\n                    plant++;\\n                }\\n            }\\n        }\\n        if(seat == 0 || seat%2!=0)return 0;\\n        \\n        long long int ans = 1;\\n        for(auto v: cnt){\\n            ans *= v+1;\\n            ans %= m;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        \\n        // if(corridor.size()<=1)return 0;\\n        vector<int> cnt;\\n        int seat = 0, plant = 0, m = 1e9+7;\\n        for(int i=0;i<corridor.size();i++){\\n            if(corridor[i] == \\'S\\'){\\n                seat++;\\n                if(plant){\\n                    cnt.push_back(plant);\\n                    plant = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2529698,
                "title": "greedy-solution-easy-to-understand",
                "content": "1st of all we will find the index at which we have seats in the sequence.\\ns=\"SPSPPSPPS\"\\nvec={0,2,5,8}  index at which we have seats.\\ncondition 1->      if number of seats in the sequence are odd then there is no ways to install the room divider such that there is exactly two seats    along with any number of plants b/w two room divider   so answer will be 0.\\n\\nif condition 1 is not satisfied then \\n we will be grouping the value of vector (vec) which contain the position at which we have seats as follow \\n 1st group==vec[0],vec[1];\\n 2nd group==vec[2],vec[3];\\n 3rd group==vec[4],vec[5];\\n so on---;\\n \\nP1-- we will take two consecutive group  and \\n     then  we will find out that how many plants we have b/w the indexes  starting from   index equal to 2nd value of 1st group to   index   equal to 1st value of 2nd group. \\n\\t i.e ind1=g [1][1]\\n\\t  ind2=g[2][0]   where g represent group;\\n\\t  cnt =total number of plants b/w indexs ind1 and ind2;\\n\\t  Now we have to find out Number of ways in which we can can distributes the plants to these two groups \\n\\t  \\nwe will do process \\tP1    for all two consecutive group possible.\\nand all the  ans we get each time from process P1 will be multiplied together(while utilising the vey essence of MOD operation) that will be our final answer.\\n\\n\\n```\\n#define MOD 1000000007;\\nclass Solution {\\npublic:\\n Solution(){\\n   std::ios_base::sync_with_stdio(false);\\n   std::cin.tie(nullptr);\\n           }\\n    int numberOfWays(string s) {\\n      \\n      int n=s.length();\\n      int i=0;\\n      \\n      vector<int>st;\\n      \\n      while(i<n){\\n       if(s[i]==\\'S\\')\\n            st.push_back(i);\\n        \\n        i++;\\n         \\n                 }\\n      \\n      \\n      n=st.size();\\n      \\n      if(n<=2)\\n         return n==0?0:n-1;\\n      if(n&2!=0)\\n         return 0;\\n      \\n      int cnt;\\n      long long  sum=1LL;\\n       i=1;\\n      while(i<n&&i+1<n){\\n        //cout<<\" abhi\";\\n        cnt=(st[i+1]-st[i]);\\n        sum*=cnt;\\n        sum%=MOD;\\n        i+=2;\\n                           \\n                  }\\n      \\n      return sum;\\n      \\n        \\n    }\\n};\\n```\\n\\n\\t \\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n#define MOD 1000000007;\\nclass Solution {\\npublic:\\n Solution(){\\n   std::ios_base::sync_with_stdio(false);\\n   std::cin.tie(nullptr);\\n           }\\n    int numberOfWays(string s) {\\n      \\n      int n=s.length();\\n      int i=0;\\n      \\n      vector<int>st;\\n      \\n      while(i<n){\\n       if(s[i]==\\'S\\')\\n            st.push_back(i);\\n        \\n        i++;\\n         \\n                 }\\n      \\n      \\n      n=st.size();\\n      \\n      if(n<=2)\\n         return n==0?0:n-1;\\n      if(n&2!=0)\\n         return 0;\\n      \\n      int cnt;\\n      long long  sum=1LL;\\n       i=1;\\n      while(i<n&&i+1<n){\\n        //cout<<\" abhi\";\\n        cnt=(st[i+1]-st[i]);\\n        sum*=cnt;\\n        sum%=MOD;\\n        i+=2;\\n                           \\n                  }\\n      \\n      return sum;\\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2529059,
                "title": "c-o-n-dynamic-programming-solution-without-and-with-segment-tree",
                "content": "The code which uses segment tree is commented out. It should run comfortably but due to leetcode running multiple test cases on a single file, it is giving TLE. So, i did a simple two pointer based approach later.\\n\\n```\\nconst int M = 1e9+7;\\nclass Solution {\\n    // class SegTree{\\n    //     vector<int>st;\\n    //     int siz;\\n    // public:\\n    //     SegTree(int n){\\n    //         st.resize(n*2,0);\\n    //         siz=n;\\n    //     }\\n    //     void update(int i, int x){\\n    //         i+=siz;\\n    //         st[i]=x;\\n    //         i/=2;\\n    //         while(i>0){\\n    //             st[i] = (st[i*2]+st[i*2+1])%M;\\n    //             i/=2;\\n    //         }\\n    //     }\\n    //     int query(int l, int r){\\n    //         l+=siz; r+=siz;\\n    //         int ans=0;\\n    //         while(l<=r){\\n    //             if(l%2==1)ans = (ans + st[l++])%M;\\n    //             if(r%2==0)ans = (ans + st[r--])%M;\\n    //             l/=2;\\n    //             r/=2;\\n    //         }\\n    //         return ans;\\n    //     }\\n    // };\\n    \\npublic:\\n    int numberOfWays(string s) {\\n        int n=s.size();\\n        vector<vector<int>>nex(n+1, vector<int>(3)); \\n        //0-> next chair, 1-> 2nd next, 2->3rd next\\n        nex[n][0] = nex[n][1] = nex[n][2] = n;\\n        for(int i=n-1; i>=0; i--){\\n            nex[i] = nex[i+1];\\n            if(s[i]==\\'S\\'){\\n                nex[i][0] = i;\\n                nex[i][1] = nex[i+1][0];\\n                nex[i][2] = nex[i+1][1];\\n            }\\n        }\\n        // SegTree st(n+1);\\n        int DP[n+1];\\n        DP[n]=1;\\n        // st.update(n, 1);\\n        int curl=n, curr=n;\\n        int curSum=0;\\n        for(int i=n-1; i>=0; i--){\\n            int sec = nex[i][1], th = nex[i][2];\\n            if(sec==n){ //if there aren\\'t two chairs in front of i -> no way to segregate\\n                DP[i] = 0;\\n                // st.update(i, 0);\\n                continue;\\n            }\\n            while(curl>sec){\\n                curSum = (curSum+DP[curl])%M;\\n                curl--;\\n            }\\n            while(curr>th){\\n                curSum = ((curSum-DP[curr])%M+M)%M;\\n                curr--;\\n            }\\n            DP[i] = curSum;\\n            // DP[i] = st.query(sec+1, th);\\n            // st.update(i, DP[i]);\\n        }\\n        return DP[0];\\n    }\\n    //Assuming there is a divider just before i,\\n    // DP[i] = number of ways to put further dividers such that each section....\\n    // DP[i] = DP[second chair+1]+DP[sec Chair+2]+...+DP[third chair-1]\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nconst int M = 1e9+7;\\nclass Solution {\\n    // class SegTree{\\n    //     vector<int>st;\\n    //     int siz;\\n    // public:\\n    //     SegTree(int n){\\n    //         st.resize(n*2,0);\\n    //         siz=n;\\n    //     }\\n    //     void update(int i, int x){\\n    //         i+=siz;\\n    //         st[i]=x;\\n    //         i/=2;\\n    //         while(i>0){\\n    //             st[i] = (st[i*2]+st[i*2+1])%M;\\n    //             i/=2;\\n    //         }\\n    //     }\\n    //     int query(int l, int r){\\n    //         l+=siz; r+=siz;\\n    //         int ans=0;\\n    //         while(l<=r){\\n    //             if(l%2==1)ans = (ans + st[l++])%M;\\n    //             if(r%2==0)ans = (ans + st[r--])%M;\\n    //             l/=2;\\n    //             r/=2;\\n    //         }\\n    //         return ans;\\n    //     }\\n    // };\\n    \\npublic:\\n    int numberOfWays(string s) {\\n        int n=s.size();\\n        vector<vector<int>>nex(n+1, vector<int>(3)); \\n        //0-> next chair, 1-> 2nd next, 2->3rd next\\n        nex[n][0] = nex[n][1] = nex[n][2] = n;\\n        for(int i=n-1; i>=0; i--){\\n            nex[i] = nex[i+1];\\n            if(s[i]==\\'S\\'){\\n                nex[i][0] = i;\\n                nex[i][1] = nex[i+1][0];\\n                nex[i][2] = nex[i+1][1];\\n            }\\n        }\\n        // SegTree st(n+1);\\n        int DP[n+1];\\n        DP[n]=1;\\n        // st.update(n, 1);\\n        int curl=n, curr=n;\\n        int curSum=0;\\n        for(int i=n-1; i>=0; i--){\\n            int sec = nex[i][1], th = nex[i][2];\\n            if(sec==n){ //if there aren\\'t two chairs in front of i -> no way to segregate\\n                DP[i] = 0;\\n                // st.update(i, 0);\\n                continue;\\n            }\\n            while(curl>sec){\\n                curSum = (curSum+DP[curl])%M;\\n                curl--;\\n            }\\n            while(curr>th){\\n                curSum = ((curSum-DP[curr])%M+M)%M;\\n                curr--;\\n            }\\n            DP[i] = curSum;\\n            // DP[i] = st.query(sec+1, th);\\n            // st.update(i, DP[i]);\\n        }\\n        return DP[0];\\n    }\\n    //Assuming there is a divider just before i,\\n    // DP[i] = number of ways to put further dividers such that each section....\\n    // DP[i] = DP[second chair+1]+DP[sec Chair+2]+...+DP[third chair-1]\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498774,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    void mul(int& a, int b) {\\n        a = ((long long)a * b) % mod;\\n    }\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        int seat = 0;\\n        for (char c : corridor) {\\n            if (c == \\'S\\') ++seat;\\n        }\\n        if (seat & 1 || seat == 0) return 0;\\n        int sol = 1;\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (corridor[i] == \\'S\\') {\\n                ++count;\\n            }\\n            if (corridor[i] == \\'S\\' && i + 1 < n && corridor[i + 1] == \\'P\\') {\\n                if (count % 2 == 0) {\\n                    int j = i + 1;\\n                    while (j < n && corridor[j] == \\'P\\') {\\n                        ++j;\\n                    }\\n                    if (j < n) {\\n                        int len = j - i;\\n                        mul(sol, len);\\n                    }\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    void mul(int& a, int b) {\\n        a = ((long long)a * b) % mod;\\n    }\\n    int numberOfWays(string corridor) {\\n        int n = corridor.size();\\n        int seat = 0;\\n        for (char c : corridor) {\\n            if (c == \\'S\\') ++seat;\\n        }\\n        if (seat & 1 || seat == 0) return 0;\\n        int sol = 1;\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (corridor[i] == \\'S\\') {\\n                ++count;\\n            }\\n            if (corridor[i] == \\'S\\' && i + 1 < n && corridor[i + 1] == \\'P\\') {\\n                if (count % 2 == 0) {\\n                    int j = i + 1;\\n                    while (j < n && corridor[j] == \\'P\\') {\\n                        ++j;\\n                    }\\n                    if (j < n) {\\n                        int len = j - i;\\n                        mul(sol, len);\\n                    }\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498340,
                "title": "java-dp-recursion-memoization-tabulation-t-o-n-s-o-n",
                "content": "\\tclass Solution {\\n    static int mod = 1000000007;\\n    static int[][] dp;\\n\\t\\n\\t//Recursion + Memoization\\n\\tpublic int count(int index, int seat, char[] arr){\\n        if(index >= arr.length){\\n            return (seat == 2)? 1: 0;\\n        }\\n\\t\\t\\tif(dp[index][seat] != -1) return dp[index][seat];\\n        \\n        int pick = 0;\\n        if(seat == 2){\\n            if(arr[index] == \\'P\\'){\\n                pick += (count(index+1, 0, arr) + count(index+1, seat, arr))%mod;\\n            }else{\\n                pick += count(index+1, 1, arr)%mod;\\n            }\\n        }else{\\n            if(arr[index] == \\'S\\'){\\n                pick += count(index+1, seat+1, arr)%mod;\\n            }else{\\n                pick += count(index+1, seat, arr)%mod;\\n            }\\n        }\\n        return dp[index][seat] = pick%mod;\\n    }\\n    public int numberOfWays(String corridor) {\\n        char[] arr = corridor.toCharArray();\\n        int n = arr.length;\\n        //dp = new int[n+1][3];\\n        // for(int[] row: dp) Arrays.fill(row, -1);\\n        // return count(0, 0, arr);\\n        \\n\\t\\t//Tabulation Approach\\n        int[] above = new int[3]; above[2] = 1;\\n        \\n        for(int index=n-1; index>=0; index--){\\n            int[] cur = new int[3];\\n            for(int seat=0; seat <=2; seat++){\\n                int pick = 0;\\n                if(seat == 2){\\n                    if(arr[index] == \\'P\\'){\\n                        pick += (above[0] + above[seat])%mod;\\n                    }else{\\n                        pick += above[1] % mod;\\n                    }\\n                }else{\\n                    if(arr[index] == \\'S\\'){\\n                        pick += above[seat+1]%mod;\\n                    }else{\\n                        pick += above[seat]%mod;\\n                    }\\n                }\\n                cur[seat] = pick%mod;\\n            }\\n            above = cur;\\n        }\\n        return above[0];\\n      }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    static int mod = 1000000007;\\n    static int[][] dp;\\n\\t\\n\\t//Recursion + Memoization\\n\\tpublic int count(int index, int seat, char[] arr){\\n        if(index >= arr.length){\\n            return (seat == 2)? 1: 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2476121,
                "title": "python-3-simple-o-n-o-1",
                "content": "```\\nclass Solution:\\n    M = 10 ** 9 + 7\\n    \\n    def numberOfWays(self, corridor: str) -> int:\\n        prevSeat = corridor.find(\\'S\\')\\n        divide = False\\n        res = 1\\n\\n        for i in range(prevSeat + 1, len(corridor)):\\n            if corridor[i] == \\'P\\':\\n                continue\\n            if divide:\\n                res = (res * (i - prevSeat)) % Solution.M\\n            prevSeat = i\\n            divide = not divide\\n        \\n        return res if divide else 0",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    M = 10 ** 9 + 7\\n    \\n    def numberOfWays(self, corridor: str) -> int:\\n        prevSeat = corridor.find(\\'S\\')\\n        divide = False\\n        res = 1\\n\\n        for i in range(prevSeat + 1, len(corridor)):\\n            if corridor[i] == \\'P\\':\\n                continue\\n            if divide:\\n                res = (res * (i - prevSeat)) % Solution.M\\n            prevSeat = i\\n            divide = not divide\\n        \\n        return res if divide else 0",
                "codeTag": "Java"
            },
            {
                "id": 2424369,
                "title": "python-3-simple-counting",
                "content": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, corridor: str) -> int:\\n\\t\\t\\tres,mod=1,10**9+7\\n\\t\\t\\tl=count=0\\n\\t\\t\\tfor x in corridor:\\n\\t\\t\\t\\tif x==\\'S\\':\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\t\\tif count>1 and count%2:\\n\\t\\t\\t\\t\\t\\tres=(res*l)%mod\\n\\t\\t\\t\\t\\t\\tl=0\\n\\t\\t\\t\\tif count>0 and count%2==0:\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\treturn res if (count and count%2==0) else 0",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, corridor: str) -> int:\\n\\t\\t\\tres,mod=1,10**9+7\\n\\t\\t\\tl=count=0\\n\\t\\t\\tfor x in corridor:\\n\\t\\t\\t\\tif x==\\'S\\':\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\t\\tif count>1 and count%2:\\n\\t\\t\\t\\t\\t\\tres=(res*l)%mod\\n\\t\\t\\t\\t\\t\\tl=0\\n\\t\\t\\t\\tif count>0 and count%2==0:\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\treturn res if (count and count%2==0) else 0",
                "codeTag": "Java"
            },
            {
                "id": 2376673,
                "title": "python-2-solutions-5-lines-with-thought-process-when-being-asked-during-interviews",
                "content": "### Recursion + Memoziation\\nBrainlessly use dynamic programming when being asked the way of cutting line, installing dividor, setting up mail box, building houses etc.\\nI misread the description and thought the each section has at least 2 seats, but it was exactly 2 seats, which makes the problem quite simple.\\nSo let\\'s start with base case\\n * the number of seats is not even, return 0\\n * there are only 2 seats, then return 1\\n\\nfor non base case, we have multiple choices? stop this is the solution to the case where each section has at least 2 seats. We have only one choice instead, which is to install dividor after 2 seats. \\nHere comes the most difficult part, that is we can also install in plants as well. But it doesn\\'t change the seats assignment and just multiple the ways we have done. \\nFor example, `...SSPPPS...`, for each `P` we can install, each installation addes the number of ways we have done at the second `S`, so if we say the number of ways is `x` at the second `S`, then we need calculate it as `x * 4 (1S + 3P)`. \\nIt means we only care about the number of plants between each `S`, so we can extract `S` and the number of plants can be calculated easily by `indices[i + 1] - indices[i]`. \\n\\n```python\\ndef numberOfWays(self, corridor: str) -> int:\\n\\tindices = [i for i, c in enumerate(corridor) if c == \\'S\\'] \\n\\tM = 10 ** 9 + 7\\n            \\n\\t@cache    \\n\\tdef helper(i, j):\\n\\t\\tif (j - i) % 2 or i >= j:\\n\\t\\t\\treturn 0\\n\\t\\tif i + 2 == j:\\n\\t\\t\\treturn 1\\n\\t\\treturn (indices[i + 2] - indices[i + 1]) * helper(i + 2, j) % M\\n\\treturn helper(0, len(indices))\\n```\\n\\n### Dynamic Programming\\nRecursion actually is alternative to DP, so we can easily change it to botttom -top DP. \\nBesides, we find that each transition only needs previous value, so we can reduce space to constant as similar as we use for fibonacci numbers.\\n\\n```python\\ndef numberOfWays(self, corridor: str) -> int:\\n\\tindices = [i for i, c in enumerate(corridor) if c == \\'S\\'] \\n\\tif not indices or len(indices) % 2:\\n\\t\\treturn 0\\n\\tM, ans = 10 ** 9 + 7, 1\\n\\tindices.append(indices[-1] + 1)\\n\\tfor i in range(2, len(indices), 2):\\n\\t\\tans = ans * (indices[i] - indices[i - 1]) % M\\n\\treturn ans\\n```\\n\\n*Time Complexity*= **O(N)**\\n*Space Complexity*= **O(1)**\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\ndef numberOfWays(self, corridor: str) -> int:\\n\\tindices = [i for i, c in enumerate(corridor) if c == \\'S\\'] \\n\\tM = 10 ** 9 + 7\\n            \\n\\t@cache    \\n\\tdef helper(i, j):\\n\\t\\tif (j - i) % 2 or i >= j:\\n\\t\\t\\treturn 0\\n\\t\\tif i + 2 == j:\\n\\t\\t\\treturn 1\\n\\t\\treturn (indices[i + 2] - indices[i + 1]) * helper(i + 2, j) % M\\n\\treturn helper(0, len(indices))\\n```\n```python\\ndef numberOfWays(self, corridor: str) -> int:\\n\\tindices = [i for i, c in enumerate(corridor) if c == \\'S\\'] \\n\\tif not indices or len(indices) % 2:\\n\\t\\treturn 0\\n\\tM, ans = 10 ** 9 + 7, 1\\n\\tindices.append(indices[-1] + 1)\\n\\tfor i in range(2, len(indices), 2):\\n\\t\\tans = ans * (indices[i] - indices[i - 1]) % M\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2374503,
                "title": "c-2d-dp",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    static const int mod=1e9+7;\\n    int dp[100001][3];\\n    int func(string&s,int idx,int seats){\\n        if(idx<0){\\n            if(seats==2) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][seats]!=-1) return dp[idx][seats];\\n        int ans=0;\\n        if(s[idx]==\\'P\\'){\\n            if(seats==2){\\n                if(idx-1>=0&&s[idx-1]==\\'S\\') ans=(ans+func(s,idx-1,0))%mod;\\n                else{\\n                    ans=(ans+func(s,idx-1,0))%mod;\\n                    ans=(ans+func(s,idx-1,seats))%mod;\\n                }\\n            }\\n            else{\\n                ans=(ans+func(s,idx-1,seats))%mod;\\n            }\\n        }\\n        else{\\n            if(seats==0){\\n                ans=(ans+func(s,idx-1,seats+1))%mod;\\n            }\\n            else if(seats==1){\\n                ans=(ans+func(s,idx-1,seats+1))%mod;\\n                ans=(ans+func(s,idx-1,0))%mod;\\n            }\\n        }\\n        return dp[idx][seats]=ans;\\n    }\\n    int numberOfWays(string s){\\n        memset(dp,-1,sizeof(dp));\\n        return func(s,s.length()-1,0);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    static const int mod=1e9+7;\\n    int dp[100001][3];\\n    int func(string&s,int idx,int seats){\\n        if(idx<0){\\n            if(seats==2) return 1;\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2254977,
                "title": "simple-solution-with-picture",
                "content": "![image](https://assets.leetcode.com/users/images/6bc01f28-0744-484b-94ba-3d0d8821ad6f_1657286338.7147539.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n       vector<int>pos;\\n        int n= s.length();\\n//         store the  position of s \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'S\\')\\n            pos.push_back(i);\\n        }\\n        \\n        n = pos.size();\\n        if(n&1||n<2)return 0;\\n        if(n==2)return 1;\\n         vector<int>sec;\\n//     this vector store the gap as we discuss above \\n        for(int i=2;i<n;i+=2)\\n        {\\n            sec.push_back(pos[i]-pos[i-1]);\\n           \\n            \\n        }\\n  \\n        long res=1,mod=1e9+7;\\n        for(int i=0;i<size(sec);i++)\\n        {\\n            res = (res*(long(sec[i])))%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n       vector<int>pos;\\n        int n= s.length();\\n//         store the  position of s \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'S\\')\\n            pos.push_back(i);\\n        }\\n        \\n        n = pos.size();\\n        if(n&1||n<2)return 0;\\n        if(n==2)return 1;\\n         vector<int>sec;\\n//     this vector store the gap as we discuss above \\n        for(int i=2;i<n;i+=2)\\n        {\\n            sec.push_back(pos[i]-pos[i-1]);\\n           \\n            \\n        }\\n  \\n        long res=1,mod=1e9+7;\\n        for(int i=0;i<size(sec);i++)\\n        {\\n            res = (res*(long(sec[i])))%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165728,
                "title": "c-solution-o-n-for-any-value-of-k",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int numberOfWays(string corr) {\\n        long ans=1,sum=0,count=0,mod=1e9+7;\\n        int k=2;\\n        for(int i=0;i<corr.size();i++){\\n            sum+=(corr[i]==\\'S\\');\\n            if(sum==k)\\n                count++;\\n            if(sum>k){\\n                ans*=count;\\n                ans%=mod;\\n                count=0;\\n                sum=1;\\n            }\\n        }\\n        if(sum<k)\\n            return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numberOfWays(string corr) {\\n        long ans=1,sum=0,count=0,mod=1e9+7;\\n        int k=2;\\n        for(int i=0;i<corr.size();i++){\\n            sum+=(corr[i]==\\'S\\');\\n            if(sum==k)\\n                count++;\\n            if(sum>k){\\n                ans*=count;\\n                ans%=mod;\\n                count=0;\\n                sum=1;\\n            }\\n        }\\n        if(sum<k)\\n            return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135812,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(char ch:s)\\n        {\\n            if(ch==\\'S\\')\\n            {\\n                count++;\\n            }\\n        }\\n        if((count&1)||count==0)\\n        {\\n            return 0;\\n        }\\n        if(count==2)\\n        {\\n            return 1;\\n        }\\n        ll mul=1,curr=0;\\n        ll prev=0,next=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=s[i];\\n            if(ch==\\'S\\')\\n            {\\n                curr++;\\n                if(curr==1)\\n                {\\n                    next=i;\\n                    if(prev!=0)\\n                    mul=(mul%mod*(next-prev)%mod)%mod;\\n                }\\n                if(curr==2)\\n                {\\n                    prev=i;\\n                    curr=0;\\n                }\\n            }\\n        }\\n        return mul;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(char ch:s)\\n        {\\n            if(ch==\\'S\\')\\n            {\\n                count++;\\n            }\\n        }\\n        if((count&1)||count==0)\\n        {\\n            return 0;\\n        }\\n        if(count==2)\\n        {\\n            return 1;\\n        }\\n        ll mul=1,curr=0;\\n        ll prev=0,next=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=s[i];\\n            if(ch==\\'S\\')\\n            {\\n                curr++;\\n                if(curr==1)\\n                {\\n                    next=i;\\n                    if(prev!=0)\\n                    mul=(mul%mod*(next-prev)%mod)%mod;\\n                }\\n                if(curr==2)\\n                {\\n                    prev=i;\\n                    curr=0;\\n                }\\n            }\\n        }\\n        return mul;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135808,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int m=1e9+7;\\n    \\n    int numberOfWays(string c) {\\n        int n=c.size();\\n        \\n        long long res=1;\\n        int i=0;\\n        vector<int> v;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(c[i]==\\'S\\')\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        if(v.size()%2!=0) return 0;\\n        if(v.size()==0) return 0;\\n        \\n        int limit=v[v.size()-1];\\n        \\n        i=0;\\n        \\n        while(i<limit)\\n        {\\n            int countseat=0;\\n            while(i<limit && countseat<2)\\n            {\\n                if(c[i]==\\'S\\')\\n                {\\n                    countseat++;\\n                }\\n                i++;\\n            }\\n            \\n            int count=1;\\n            while(i<limit && c[i]==\\'P\\')\\n            {\\n                count++;\\n                i++;\\n            }\\n            res=((res%m)*(count%m))%m;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m=1e9+7;\\n    \\n    int numberOfWays(string c) {\\n        int n=c.size();\\n        \\n        long long res=1;\\n        int i=0;\\n        vector<int> v;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(c[i]==\\'S\\')\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        if(v.size()%2!=0) return 0;\\n        if(v.size()==0) return 0;\\n        \\n        int limit=v[v.size()-1];\\n        \\n        i=0;\\n        \\n        while(i<limit)\\n        {\\n            int countseat=0;\\n            while(i<limit && countseat<2)\\n            {\\n                if(c[i]==\\'S\\')\\n                {\\n                    countseat++;\\n                }\\n                i++;\\n            }\\n            \\n            int count=1;\\n            while(i<limit && c[i]==\\'P\\')\\n            {\\n                count++;\\n                i++;\\n            }\\n            res=((res%m)*(count%m))%m;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127092,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, cor: str) -> int:\\n        \\n        n=len(cor)\\n        if n==1:\\n            return 0\\n        if cor.count(\\'P\\')==n:\\n            return 0\\n        if cor.count(\\'S\\')%2==1:\\n            return 0\\n        elif cor.count(\\'S\\')==2:\\n            return 1\\n        \\n        i=-1\\n        j=-1\\n        ff=0\\n        fs=0\\n        \\n        sf=0\\n        ss=0\\n        fc=0\\n        sc=0\\n        \\n        res=1\\n        \\n        for i in range(n):\\n            if cor[i]==\\'S\\':\\n                fc+=1\\n            \\n            if fc==1:\\n                ff=i\\n            elif fc==2:\\n                fs=i\\n                j=i\\n                break\\n        #print(ff,fs,j)\\n        while(j<n-1):\\n            \\n            j+=1\\n            \\n            if cor[j]==\\'S\\':\\n                #print(j,sc)\\n                sc+=1\\n            \\n                if sc==1:\\n                \\n                    sf=j\\n                \\n                elif sc==2:\\n                    ss=j\\n                    #print(sf,fs)\\n                    res=res*(sf-fs)\\n                \\n                    ff=sf\\n                    fs=ss\\n                    sc=0\\n        return res%(10**9+7)\\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, cor: str) -> int:\\n        \\n        n=len(cor)\\n        if n==1:\\n            return 0\\n        if cor.count(\\'P\\')==n:\\n            return 0\\n        if cor.count(\\'S\\')%2==1:\\n            return 0\\n        elif cor.count(\\'S\\')==2:\\n            return 1\\n        \\n        i=-1\\n        j=-1\\n        ff=0\\n        fs=0\\n        \\n        sf=0\\n        ss=0\\n        fc=0\\n        sc=0\\n        \\n        res=1\\n        \\n        for i in range(n):\\n            if cor[i]==\\'S\\':\\n                fc+=1\\n            \\n            if fc==1:\\n                ff=i\\n            elif fc==2:\\n                fs=i\\n                j=i\\n                break\\n        #print(ff,fs,j)\\n        while(j<n-1):\\n            \\n            j+=1\\n            \\n            if cor[j]==\\'S\\':\\n                #print(j,sc)\\n                sc+=1\\n            \\n                if sc==1:\\n                \\n                    sf=j\\n                \\n                elif sc==2:\\n                    ss=j\\n                    #print(sf,fs)\\n                    res=res*(sf-fs)\\n                \\n                    ff=sf\\n                    fs=ss\\n                    sc=0\\n        return res%(10**9+7)\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096402,
                "title": "javascript-iterative-o-n-time-o-1-space",
                "content": "```\\nvar numberOfWays = function(corridor) {\\n    const modulo = 10 ** 9 + 7;\\n    let seats = 0;\\n    // Keep track of dividers that can be placed between a four seat section\\n    let dividers = [];\\n    // Keep track of each seat\\'s index\\n    let seatIdx = [];\\n    for (let i = 0; i < corridor.length; i++) {\\n        let val = corridor[i];\\n        if (val === \\'S\\') {\\n            seats++;\\n            seatIdx.push(i);\\n            if (seatIdx.length === 4) {\\n                // If we find four seats, find how many plants there are between seat 2 and seat 3\\n                dividers.push(seatIdx[2] - seatIdx[1]);\\n                seatIdx.shift(), seatIdx.shift();\\n            }\\n        }\\n    }\\n    \\n    // If there are no seats or total seats is not divisible by 2, then there is no way to divide\\n    if (!seats || seats % 2) return 0;\\n    // If total seats === 2, then there is only one way to divide\\n    if (!dividers.length) return 1;\\n    return dividers.reduce((a, c) =>  (a * c % modulo));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfWays = function(corridor) {\\n    const modulo = 10 ** 9 + 7;\\n    let seats = 0;\\n    // Keep track of dividers that can be placed between a four seat section\\n    let dividers = [];\\n    // Keep track of each seat\\'s index\\n    let seatIdx = [];\\n    for (let i = 0; i < corridor.length; i++) {\\n        let val = corridor[i];\\n        if (val === \\'S\\') {\\n            seats++;\\n            seatIdx.push(i);\\n            if (seatIdx.length === 4) {\\n                // If we find four seats, find how many plants there are between seat 2 and seat 3\\n                dividers.push(seatIdx[2] - seatIdx[1]);\\n                seatIdx.shift(), seatIdx.shift();\\n            }\\n        }\\n    }\\n    \\n    // If there are no seats or total seats is not divisible by 2, then there is no way to divide\\n    if (!seats || seats % 2) return 0;\\n    // If total seats === 2, then there is only one way to divide\\n    if (!dividers.length) return 1;\\n    return dividers.reduce((a, c) =>  (a * c % modulo));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088075,
                "title": "this-should-be-easy-medium",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        plants = []\\n        cntseat = 0\\n        cntplant = 0\\n        shouldCountPlant = 0\\n        if corridor.count(\"S\")%2!=0 or corridor.count(\"S\")==0:\\n            return 0\\n        for i in range(len(corridor)):\\n            if shouldCountPlant==0:\\n                if corridor[i]==\"S\":\\n                    cntseat+=1\\n                    if cntseat==2:\\n                        cntseat = 0\\n                        shouldCountPlant = 1\\n                else:\\n                    continue \\n            else:\\n                if corridor[i]==\"S\":\\n                    shouldCountPlant = 0\\n                    cntseat=1\\n                    plants.append(cntplant)\\n                    cntplant = 0\\n                else:\\n                    cntplant += 1 \\n        \\n        ans = 1\\n        for i in plants:\\n            ans *= (1+i)\\n            ans%=1000000007\\n        return ans\\n                \\n                \\n                \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        plants = []\\n        cntseat = 0\\n        cntplant = 0\\n        shouldCountPlant = 0\\n        if corridor.count(\"S\")%2!=0 or corridor.count(\"S\")==0:\\n            return 0\\n        for i in range(len(corridor)):\\n            if shouldCountPlant==0:\\n                if corridor[i]==\"S\":\\n                    cntseat+=1\\n                    if cntseat==2:\\n                        cntseat = 0\\n                        shouldCountPlant = 1\\n                else:\\n                    continue \\n            else:\\n                if corridor[i]==\"S\":\\n                    shouldCountPlant = 0\\n                    cntseat=1\\n                    plants.append(cntplant)\\n                    cntplant = 0\\n                else:\\n                    cntplant += 1 \\n        \\n        ans = 1\\n        for i in plants:\\n            ans *= (1+i)\\n            ans%=1000000007\\n        return ans\\n                \\n                \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057385,
                "title": "no-dp-simple-math-c-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    \\n    int mod = 1e9 + 7;\\n    int numberOfWays(string str) \\n    {\\n        int chair = 0;\\n        int plant = 0;\\n        int totChair = 0;\\n        long int ans = 1;\\n        int n = str.length();\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(chair<2)\\n            {\\n                if(str[i]==\\'S\\')chair++;\\n            }\\n            else\\n            {\\n                if(str[i]==\\'P\\')plant++;\\n                else\\n                {\\n                    ans*=(plant+1);\\n                    ans%=mod;\\n                    plant=0;\\n                    chair=1;\\n                }\\n            }\\n            \\n            if(str[i]==\\'S\\')totChair++;\\n        }\\n        \\n        if(totChair<2 || totChair%2)return 0;\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    int mod = 1e9 + 7;\\n    int numberOfWays(string str) \\n    {\\n        int chair = 0;\\n        int plant = 0;\\n        int totChair = 0;\\n        long int ans = 1;\\n        int n = str.length();\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(chair<2)\\n            {\\n                if(str[i]==\\'S\\')chair++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2050826,
                "title": "c-o-n-easy-solution",
                "content": "```\\n int numberOfWays(string corridor){\\n      int count=0,temp=0,k=0;\\n      for(int i=0;i<corridor.size();i++) \\n      {\\n        if(corridor[i]==\\'S\\') count++;\\n      }\\n      if(count%2!=0 || count<2) return 0;\\n      long long c=(1e9+7),ans=1;\\n      for(int i=0;i<corridor.size();i++)\\n      {\\n        if(corridor[i]==\\'S\\' && temp%2!=0) temp++;\\n        else if(corridor[i]==\\'S\\' && temp%2==0) \\n        {\\n          ans=((ans%c)*((k+1)%c))%c;\\n          k=0,temp++;\\n        }\\n        else if(temp!=0 && temp%2==0 && corridor[i]==\\'P\\')\\n        {\\n          k++;\\n        }\\n      }\\n      return ans%c;\\n    }",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n int numberOfWays(string corridor){\\n      int count=0,temp=0,k=0;\\n      for(int i=0;i<corridor.size();i++) \\n      {\\n        if(corridor[i]==\\'S\\') count++;\\n      }\\n      if(count%2!=0 || count<2) return 0;\\n      long long c=(1e9+7),ans=1;\\n      for(int i=0;i<corridor.size();i++)\\n      {\\n        if(corridor[i]==\\'S\\' && temp%2!=0) temp++;\\n        else if(corridor[i]==\\'S\\' && temp%2==0) \\n        {\\n          ans=((ans%c)*((k+1)%c))%c;\\n          k=0,temp++;\\n        }\\n        else if(temp!=0 && temp%2==0 && corridor[i]==\\'P\\')\\n        {\\n          k++;\\n        }\\n      }\\n      return ans%c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2045874,
                "title": "python-dynamic-programming-commented-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    INT_MAX = 10**9 + 7\\n\\n    def numberOfWays(self, corridor: str) -> int:\\n        \\n        def get_next_section(corridor: str, start_idx: int) -> Tuple[int,int]:\\n\\t\\t    \\'\\'\\'Get the index of first and second chair after the starting index\\n\\t\\t\\t\\n\\t\\t\\tArgs:\\n\\t\\t\\tcorridor: corridor string\\n\\t\\t\\tstart_idx: starting index in corridor from where to find the next two chairs\\n\\t\\t\\t\\n\\t\\t\\tReturns:\\n\\t\\t\\tfirst_index, second_index: index of first and second chair. For each of the chairs that is not found the returned value is -1\\n\\t\\t\\t\\'\\'\\'\\n            first_idx = second_idx = -1\\n            for idx in range(start_idx, len(corridor)):\\n                if corridor[idx] != \"S\":\\n                    continue\\n                elif first_idx == -1:\\n                    first_idx = idx\\n                else:\\n                    second_idx = idx\\n                    break\\n                    \\n            return first_idx, second_idx\\n        \\n        # find first section ending after first chair\\n        first_idx, second_idx = get_next_section(corridor, 0)\\n        \\n        # didn\\'t found any section with two seats\\n        if second_idx == -1:\\n            return 0\\n\\n        # first section ending at first chair has only one conbination\\n        result = 1\\n        \\n        while True:\\n            # this is where the next section starts\\n            start_idx = second_idx + 1\\n            \\n            # where we found the first and second seat in the next section\\n            first_idx, second_idx = get_next_section(corridor, start_idx)\\n            \\n            # check if second chair was found so we have a next section\\n            if second_idx == -1:\\n                # if first chair was found but not second then\\n                if first_idx != -1:\\n                    # we have an incomplete ending section\\n                    result = 0\\n\\t\\t\\t\\t# stop the loop as we do not have any more sections in the corridor\\n                break\\n\\t\\t\\telse:\\n\\t\\t\\t    # all the plants from section start up to the first chair can be differently separated\\n                result *= (first_idx - start_idx + 1)\\n\\t\\t\\t\\tresult %= Solution.INT_MAX\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    INT_MAX = 10**9 + 7\\n\\n    def numberOfWays(self, corridor: str) -> int:\\n        \\n        def get_next_section(corridor: str, start_idx: int) -> Tuple[int,int]:\\n\\t\\t    \\'\\'\\'Get the index of first and second chair after the starting index\\n\\t\\t\\t\\n\\t\\t\\tArgs:\\n\\t\\t\\tcorridor: corridor string\\n\\t\\t\\tstart_idx: starting index in corridor from where to find the next two chairs\\n\\t\\t\\t\\n\\t\\t\\tReturns:\\n\\t\\t\\tfirst_index, second_index: index of first and second chair. For each of the chairs that is not found the returned value is -1\\n\\t\\t\\t\\'\\'\\'\\n            first_idx = second_idx = -1\\n            for idx in range(start_idx, len(corridor)):\\n                if corridor[idx] != \"S\":\\n                    continue\\n                elif first_idx == -1:\\n                    first_idx = idx\\n                else:\\n                    second_idx = idx\\n                    break\\n                    \\n            return first_idx, second_idx\\n        \\n        # find first section ending after first chair\\n        first_idx, second_idx = get_next_section(corridor, 0)\\n        \\n        # didn\\'t found any section with two seats\\n        if second_idx == -1:\\n            return 0\\n\\n        # first section ending at first chair has only one conbination\\n        result = 1\\n        \\n        while True:\\n            # this is where the next section starts\\n            start_idx = second_idx + 1\\n            \\n            # where we found the first and second seat in the next section\\n            first_idx, second_idx = get_next_section(corridor, start_idx)\\n            \\n            # check if second chair was found so we have a next section\\n            if second_idx == -1:\\n                # if first chair was found but not second then\\n                if first_idx != -1:\\n                    # we have an incomplete ending section\\n                    result = 0\\n\\t\\t\\t\\t# stop the loop as we do not have any more sections in the corridor\\n                break\\n\\t\\t\\telse:\\n\\t\\t\\t    # all the plants from section start up to the first chair can be differently separated\\n                result *= (first_idx - start_idx + 1)\\n\\t\\t\\t\\tresult %= Solution.INT_MAX\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039162,
                "title": "c-combinatorics-o-n",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        constexpr int ModBase = 1\\'000\\'000\\'007;\\n        int64_t ways = 1;\\n        int seats = 0;\\n        for (int i = 0, plants = 0; i < corridor.size(); ++i) {\\n            if (corridor[i] == \\'S\\') { // seat\\n                ++seats;\\n                if ((seats & 1) == 0) { // is even?\\n                    plants = 0;\\n                } else { // is odd\\n                    if (seats >= 3) {\\n                        ways *= plants + 1;\\n                        ways %= ModBase;\\n                        plants = 0;\\n                    }\\n                }\\n            } else { // plant\\n                ++plants;\\n            }\\n        }\\n        bool isValid = (seats >= 2) && (seats & 1) == 0;\\n        return isValid ? ways : 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        constexpr int ModBase = 1\\'000\\'000\\'007;\\n        int64_t ways = 1;\\n        int seats = 0;\\n        for (int i = 0, plants = 0; i < corridor.size(); ++i) {\\n            if (corridor[i] == \\'S\\') { // seat\\n                ++seats;\\n                if ((seats & 1) == 0) { // is even?\\n                    plants = 0;\\n                } else { // is odd\\n                    if (seats >= 3) {\\n                        ways *= plants + 1;\\n                        ways %= ModBase;\\n                        plants = 0;\\n                    }\\n                }\\n            } else { // plant\\n                ++plants;\\n            }\\n        }\\n        bool isValid = (seats >= 2) && (seats & 1) == 0;\\n        return isValid ? ways : 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028037,
                "title": "seat-of-the-plants-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string cor) {\\n        int plants = 0;\\n        int seats = 0;\\n        bool countplants = false;\\n        long res = 1;\\n        for (char c : cor) {\\n            if (countplants) {\\n                if (c == \\'P\\') {\\n                    plants++;\\n                } else {\\n                    countplants = false;\\n                    res = (res * (plants + 1)) % 1000000007;\\n                    plants = 0;\\n                    seats = 1;\\n                }\\n            } else if (c == \\'S\\') {\\n                seats++;\\n                if (seats == 2) {\\n                    countplants = true;\\n                    seats = 0;\\n                }\\n            }\\n        }\\n        if (!countplants)\\n            return 0;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string cor) {\\n        int plants = 0;\\n        int seats = 0;\\n        bool countplants = false;\\n        long res = 1;\\n        for (char c : cor) {\\n            if (countplants) {\\n                if (c == \\'P\\') {\\n                    plants++;\\n                } else {\\n                    countplants = false;\\n                    res = (res * (plants + 1)) % 1000000007;\\n                    plants = 0;\\n                    seats = 1;\\n                }\\n            } else if (c == \\'S\\') {\\n                seats++;\\n                if (seats == 2) {\\n                    countplants = true;\\n                    seats = 0;\\n                }\\n            }\\n        }\\n        if (!countplants)\\n            return 0;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003671,
                "title": "golang-solution-easy-to-understand",
                "content": "```\\nfunc numberOfWays(corridor string) int {\\n    seats := 0\\n    for _, val := range corridor {\\n        if val == \\'S\\' {\\n            seats++\\n        }\\n    }\\n    if seats < 2 || seats % 2 != 0{\\n        return 0\\n    }\\n    numbers := []int{}\\n    idx := 0\\n    for idx < len(corridor){\\n        for idx < len(corridor) && corridor[idx] == \\'P\\' {\\n            idx++\\n        }\\n        idx++\\n        for idx < len(corridor) && corridor[idx] == \\'P\\' {\\n            idx++\\n        }\\n        idx++\\n        pc := 0\\n        for idx < len(corridor) && corridor[idx] == \\'P\\' {\\n            pc++\\n            idx++\\n        }\\n        if idx == len(corridor) {\\n            break\\n        }\\n        numbers = append(numbers, pc+1)\\n    }\\n    result := 1\\n    for _, val := range numbers {\\n        result *= val\\n        result %= (10*10*10*10*10*10*10*10*10+7)\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numberOfWays(corridor string) int {\\n    seats := 0\\n    for _, val := range corridor {\\n        if val == \\'S\\' {\\n            seats++\\n        }\\n    }\\n    if seats < 2 || seats % 2 != 0{\\n        return 0\\n    }\\n    numbers := []int{}\\n    idx := 0\\n    for idx < len(corridor){\\n        for idx < len(corridor) && corridor[idx] == \\'P\\' {\\n            idx++\\n        }\\n        idx++\\n        for idx < len(corridor) && corridor[idx] == \\'P\\' {\\n            idx++\\n        }\\n        idx++\\n        pc := 0\\n        for idx < len(corridor) && corridor[idx] == \\'P\\' {\\n            pc++\\n            idx++\\n        }\\n        if idx == len(corridor) {\\n            break\\n        }\\n        numbers = append(numbers, pc+1)\\n    }\\n    result := 1\\n    for _, val := range numbers {\\n        result *= val\\n        result %= (10*10*10*10*10*10*10*10*10+7)\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975759,
                "title": "fully-explained-simple-logic-cpp",
                "content": "if number of seats are even then only we can satify the condition given in the problem otherwise solution doesn\\'t exist.\\nif solution exist, we will insert (seat/2)-1 walls to make the partition.\\ncheck number of Plants after every second seat and multiply the answer by (count+1).\\n\\n    int mod=1e9+7;\\n    \\n    int numberOfWays(string corridor) {\\n        int seat=0,n=corridor.size();\\n        for(int i=0;i<n;i++) \\n            if(corridor[i]==\\'S\\') seat++;\\n        if(seat==0 || seat%2) return 0;\\n        int ans=1;\\n        int i=0,cnt=0;\\n        seat/=2;\\n        seat--;\\n        while(i<n){\\n            if(!seat) break;\\n            if(cnt==2){\\n                int temp=0;\\n                while(i<n && corridor[i]!=\\'S\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                cnt=0;\\n                seat--;\\n                ans=(ans*1LL*(temp+1))%mod;\\n            }\\n            else if(corridor[i]==\\'S\\'){\\n                cnt++;\\n                i++;\\n            }\\n            else i++;\\n            \\n        }\\n        return ans;\\n    }\\n\\t\\nComment for any clarification, Happy Coding:)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "if number of seats are even then only we can satify the condition given in the problem otherwise solution doesn\\'t exist.\\nif solution exist, we will insert (seat/2)-1 walls to make the partition.\\ncheck number of Plants after every second seat and multiply the answer by (count+1).\\n\\n    int mod=1e9+7;\\n    \\n    int numberOfWays(string corridor) {\\n        int seat=0,n=corridor.size();\\n        for(int i=0;i<n;i++) \\n            if(corridor[i]==\\'S\\') seat++;\\n        if(seat==0 || seat%2) return 0;\\n        int ans=1;\\n        int i=0,cnt=0;\\n        seat/=2;\\n        seat--;\\n        while(i<n){\\n            if(!seat) break;\\n            if(cnt==2){\\n                int temp=0;\\n                while(i<n && corridor[i]!=\\'S\\'){\\n                    temp++;\\n                    i++;\\n                }\\n                cnt=0;\\n                seat--;\\n                ans=(ans*1LL*(temp+1))%mod;\\n            }\\n            else if(corridor[i]==\\'S\\'){\\n                cnt++;\\n                i++;\\n            }\\n            else i++;\\n            \\n        }\\n        return ans;\\n    }\\n\\t\\nComment for any clarification, Happy Coding:)",
                "codeTag": "Unknown"
            },
            {
                "id": 1961692,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {String} corridor\\n# @return {Integer}\\ndef number_of_ways(corridor)\\n  (t = corridor.count(\\'S\\')).odd? || t == 0 ? 0 : corridor.sub(\\'S\\', \\'P\\').scan(/SP*S/).reduce(1) { _1 * (_2.size - 1) % (10**9+7) }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} corridor\\n# @return {Integer}\\ndef number_of_ways(corridor)\\n  (t = corridor.count(\\'S\\')).odd? || t == 0 ? 0 : corridor.sub(\\'S\\', \\'P\\').scan(/SP*S/).reduce(1) { _1 * (_2.size - 1) % (10**9+7) }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1897780,
                "title": "simple-solution-with-comments",
                "content": "Time: O(n)\\nSpace: O(1)\\n\\n    public int NumberOfWays(string corridor) {\\n        \\n        long ans = 1;       // answer \\n        int curr = 0;       // current seat count\\n        int prevIdx = -1;   // previous seat index\\n        int scount = 0;     // total seat count\\n        \\n        int div = 1000000007;   // mod divisor\\n        \\n        for(int i=0;i<corridor.Length;i++)\\n        {\\n            if(corridor[i] == \\'S\\')\\n            {\\n                curr++;\\n                scount++;\\n                \\n                // every third seat, we need to multiply the previous\\n                // answer by the distance between the seat indexes,\\n                // which is equal to the number of ways to divide the newest\\n                // group of plants between the seats\\n                if(curr == 3)\\n                {\\n                    int dist = i-prevIdx;\\n                    \\n                    if(ans == 0) ans = dist;\\n                    else ans = (ans * dist) % div;\\n                    \\n                    curr = 1;\\n                }\\n                \\n                prevIdx = i;\\n            }\\n            \\n        }\\n        \\n        // if odd number of seats or no seats, return 0\\n        if(scount % 2 == 1 || scount == 0) return 0;\\n        \\n        return (int)ans;\\n    }\\n",
                "solutionTags": [],
                "code": "Time: O(n)\\nSpace: O(1)\\n\\n    public int NumberOfWays(string corridor) {\\n        \\n        long ans = 1;       // answer \\n        int curr = 0;       // current seat count\\n        int prevIdx = -1;   // previous seat index\\n        int scount = 0;     // total seat count\\n        \\n        int div = 1000000007;   // mod divisor\\n        \\n        for(int i=0;i<corridor.Length;i++)\\n        {\\n            if(corridor[i] == \\'S\\')\\n            {\\n                curr++;\\n                scount++;\\n                \\n                // every third seat, we need to multiply the previous\\n                // answer by the distance between the seat indexes,\\n                // which is equal to the number of ways to divide the newest\\n                // group of plants between the seats\\n                if(curr == 3)\\n                {\\n                    int dist = i-prevIdx;\\n                    \\n                    if(ans == 0) ans = dist;\\n                    else ans = (ans * dist) % div;\\n                    \\n                    curr = 1;\\n                }\\n                \\n                prevIdx = i;\\n            }\\n            \\n        }\\n        \\n        // if odd number of seats or no seats, return 0\\n        if(scount % 2 == 1 || scount == 0) return 0;\\n        \\n        return (int)ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1884887,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func numberOfWays(_ corridor: String) -> Int {\\n        var arr = Array(corridor) \\n        var s: [Int] = []\\n        for i in 0..<arr.count {\\n            if arr[i] == \"S\" {\\n                s.append(i)\\n            }\\n        }\\n        if s.count % 2 != 0 || s.isEmpty {\\n            return 0\\n        }\\n        \\n        var i = 0\\n        var count = 1\\n        while(i<s.count) {\\n            if ((i+2) < s.count) && ((s[i+2] - s[i+1]) != 1) {\\n                count = (count * (s[i+2] - s[i+1])) % 1000000007\\n            }\\n            i = i + 2\\n        }\\n        \\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numberOfWays(_ corridor: String) -> Int {\\n        var arr = Array(corridor) \\n        var s: [Int] = []\\n        for i in 0..<arr.count {\\n            if arr[i] == \"S\" {\\n                s.append(i)\\n            }\\n        }\\n        if s.count % 2 != 0 || s.isEmpty {\\n            return 0\\n        }\\n        \\n        var i = 0\\n        var count = 1\\n        while(i<s.count) {\\n            if ((i+2) < s.count) && ((s[i+2] - s[i+1]) != 1) {\\n                count = (count * (s[i+2] - s[i+1])) % 1000000007\\n            }\\n            i = i + 2\\n        }\\n        \\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879793,
                "title": "java-90-simple-with-2-counters",
                "content": "```\\nclass Solution {\\n  public int numberOfWays(String corridor) {\\n      long s = 0;\\n      long p = 0;\\n      long ans = 1;\\n      int sumSeats = 0;\\n      for(char c : corridor.toCharArray()){\\n          if(c == \\'S\\'){\\n              sumSeats++;\\n              s++;\\n              if(s == 3){\\n                  ans*=(p+1);\\n                  ans%=1000000007;\\n                  s = 1;\\n                  p = 0;\\n              }\\n          }else if(c == \\'P\\'){\\n              if(s == 2){\\n                  p++;\\n              }\\n          }\\n      }\\n      if(sumSeats == 0 || sumSeats%2 == 1) return 0;\\n      return (int)ans;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int numberOfWays(String corridor) {\\n      long s = 0;\\n      long p = 0;\\n      long ans = 1;\\n      int sumSeats = 0;\\n      for(char c : corridor.toCharArray()){\\n          if(c == \\'S\\'){\\n              sumSeats++;\\n              s++;\\n              if(s == 3){\\n                  ans*=(p+1);\\n                  ans%=1000000007;\\n                  s = 1;\\n                  p = 0;\\n              }\\n          }else if(c == \\'P\\'){\\n              if(s == 2){\\n                  p++;\\n              }\\n          }\\n      }\\n      if(sumSeats == 0 || sumSeats%2 == 1) return 0;\\n      return (int)ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870882,
                "title": "python-greedy-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        count=0\\n        a=0\\n        ans=1\\n        countseat=0\\n        for item in corridor:\\n            if item==\"S\":\\n                countseat+=1\\n        if countseat==0 or countseat%2!=0:\\n            return 0\\n        for item in corridor:\\n            if item==\"S\":\\n                countseat-=1\\n                count+=1\\n            if countseat==0:\\n                return ans\\n            if count>2:\\n                count=1\\n                ans*=a\\n                ans%=(10**9+7)\\n                a=0\\n            if count==2:\\n                a+=1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        count=0\\n        a=0\\n        ans=1\\n        countseat=0\\n        for item in corridor:\\n            if item==\"S\":\\n                countseat+=1\\n        if countseat==0 or countseat%2!=0:\\n            return 0\\n        for item in corridor:\\n            if item==\"S\":\\n                countseat-=1\\n                count+=1\\n            if countseat==0:\\n                return ans\\n            if count>2:\\n                count=1\\n                ans*=a\\n                ans%=(10**9+7)\\n                a=0\\n            if count==2:\\n                a+=1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1860017,
                "title": "greedy-time-o-n-space-o-1",
                "content": "\\t/*\\n\\tPlease first see the hints given in question.\\n\\tIf stuck see the hints I have mentioned below. \\n\\tIf still stuck please refer to the soultion. Peace!\\n\\t*/\\n\\t\\n\\t/* Explanation of greedy algorithm:-\\n\\t\\t1> Maintain a boolean to tell whether a pair of sofas is complete or incomplete\\n\\t\\t2> If the pair is complete count plants between two distinct pairs else ignore.\\n\\t\\t3> Multiply the ans by (count+1).\\n\\t*/\\n\\t\\n\\tconst int mod = 1e9 + 7;\\n    int numberOfWays(string corridor) {\\n        int n = corridor.length();\\n        \\n        /*Trimming starting plants and ending plants*/\\n        int start_idx = -1, end_idx = -1;\\n        for(int i=0; i<n; i++){\\n            if(corridor[i]==\\'S\\'){\\n                start_idx = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(corridor[i]==\\'S\\'){\\n                end_idx = i;\\n                break;\\n            }\\n        }\\n        /* Trimming ends */\\n        \\n        if(start_idx == end_idx || start_idx == -1 || end_idx == -1) return 0;\\n        \\n        long ans=1;\\n        int p_count=0, i = 0;\\n        bool pair_complete = true;\\n        i = start_idx,  n = end_idx;\\n        \\n        while(i<=n){\\n            if(pair_complete == true){\\n                while(i<n and corridor[i]!=\\'S\\') \\n                    i++, p_count++;\\n                ans = (ans*(++p_count))%mod;\\n                p_count = 0;\\n                pair_complete = false;\\n            }else{\\n                while(i<n and corridor[i]!=\\'S\\')\\n                    i++;\\n                pair_complete = true;\\n            }\\n            i++;\\n        }\\n        if(!pair_complete) return 0;\\n        return (int)ans;\\n    }",
                "solutionTags": [],
                "code": "\\t/*\\n\\tPlease first see the hints given in question.\\n\\tIf stuck see the hints I have mentioned below. \\n\\tIf still stuck please refer to the soultion. Peace!\\n\\t*/\\n\\t\\n\\t/* Explanation of greedy algorithm:-\\n\\t\\t1> Maintain a boolean to tell whether a pair of sofas is complete or incomplete\\n\\t\\t2> If the pair is complete count plants between two distinct pairs else ignore.\\n\\t\\t3> Multiply the ans by (count+1).\\n\\t*/\\n\\t\\n\\tconst int mod = 1e9 + 7;\\n    int numberOfWays(string corridor) {\\n        int n = corridor.length();\\n        \\n        /*Trimming starting plants and ending plants*/\\n        int start_idx = -1, end_idx = -1;\\n        for(int i=0; i<n; i++){\\n            if(corridor[i]==\\'S\\'){\\n                start_idx = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(corridor[i]==\\'S\\'){\\n                end_idx = i;\\n                break;\\n            }\\n        }\\n        /* Trimming ends */\\n        \\n        if(start_idx == end_idx || start_idx == -1 || end_idx == -1) return 0;\\n        \\n        long ans=1;\\n        int p_count=0, i = 0;\\n        bool pair_complete = true;\\n        i = start_idx,  n = end_idx;\\n        \\n        while(i<=n){\\n            if(pair_complete == true){\\n                while(i<n and corridor[i]!=\\'S\\') \\n                    i++, p_count++;\\n                ans = (ans*(++p_count))%mod;\\n                p_count = 0;\\n                pair_complete = false;\\n            }else{\\n                while(i<n and corridor[i]!=\\'S\\')\\n                    i++;\\n                pair_complete = true;\\n            }\\n            i++;\\n        }\\n        if(!pair_complete) return 0;\\n        return (int)ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1842134,
                "title": "c-o-n-solution-2147",
                "content": "1. We can only add dividers if the seats are greater than 2 and in even number\\n2. We need to place the room dividers only in between two alternative seats because we need exactly two seats in between.\\n3. So we can count the number of plants in between the two alternating seats and multiply to get the result\\n4. We can also note the number Indices where there are seats and then multiply every alternating difference with previous index starting from 2nd seat (first room)\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        vector<int>seatIdx;\\n        int n = corridor.length();\\n        for(int i=0;i<n;i++){\\n            if(corridor[i] == \\'S\\'){\\n                seatIdx.push_back(i);\\n            }\\n        }\\n        n = seatIdx.size();\\n        if(n==0 || (n%2)==1){return 0;}\\n        long long res = 1;\\n        int M = 1e9 + 7;\\n        for(int i=2;i<n;i+=2){\\n            res = (res * (long long)(seatIdx[i]-seatIdx[i-1]))%M;\\n        }\\n        return res%M;\\n    }\\n};\\n```\\n\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank You :)**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        vector<int>seatIdx;\\n        int n = corridor.length();\\n        for(int i=0;i<n;i++){\\n            if(corridor[i] == \\'S\\'){\\n                seatIdx.push_back(i);\\n            }\\n        }\\n        n = seatIdx.size();\\n        if(n==0 || (n%2)==1){return 0;}\\n        long long res = 1;\\n        int M = 1e9 + 7;\\n        for(int i=2;i<n;i+=2){\\n            res = (res * (long long)(seatIdx[i]-seatIdx[i-1]))%M;\\n        }\\n        return res%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812166,
                "title": "simple-math",
                "content": "class Solution {\\npublic:\\n    int numberOfWays(string co) {\\n        \\n        int s = 0;\\n        for(auto x:co)\\n            if(x == \\'S\\')\\n                s++;\\n        const int mod = 1e9+7;\\n        if(s<=1 || s%2!=0)\\n            return 0;\\n        if(s == 2)\\n            return 1;\\n        long long int ans = 1;\\n        int c = 0;\\n        for(int i = 0;i<co.size();i++)\\n        {\\n           if(co[i] == \\'S\\')\\n           {\\n               c++;\\n           }\\n            \\n            if(c == 2)\\n            {\\n                int l = i;\\n                i++;\\n                while(i<co.size() && co[i] == \\'P\\')\\n                {\\n                    i++;\\n                }\\n                if(i == co.size())\\n                    break;\\n                ans = ans%mod*(i-l)%mod;\\n                ans = ans%mod;\\n                // cout<<\"YES\"<<\" \";\\n                i--;\\n                c = 0;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numberOfWays(string co) {\\n        \\n        int s = 0;\\n        for(auto x:co)\\n            if(x == \\'S\\')\\n                s++;\\n        const int mod = 1e9+7;\\n        if(s<=1 || s%2!=0)\\n            return 0;\\n        if(s == 2)\\n            return 1;\\n        long long int ans = 1;\\n        int c = 0;\\n        for(int i = 0;i<co.size();i++)\\n        {\\n           if(co[i] == \\'S\\')\\n           {\\n               c++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1800482,
                "title": "golang-dp-with-buckets",
                "content": "```\\nfunc numberOfWays(c string) int {\\n\\tv := 0\\n\\tfor i := range c {\\n\\t\\tif c[i] == 83 {\\n\\t\\t\\tv++\\n\\t\\t}\\n\\t}\\n\\tif v&1 != 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tl := v / 2\\n\\tlm := l - 1\\n\\ts := make([][2]int, 0, l)\\n\\tif cap(s) == 1 || cap(s) == 0 {\\n\\t\\treturn cap(s)\\n\\t}\\n\\tf := -1\\n\\tfor i := range c {\\n\\t\\tif c[i] == 83 {\\n\\t\\t\\tif f == -1 {\\n\\t\\t\\t\\tf = i\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = append(s, [2]int{f, i})\\n\\t\\t\\t\\tf = -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tmem := make([]int, l)\\n\\tfor i := range mem {\\n\\t\\tmem[i] = -1\\n\\t}\\n\\n\\tvar dp func(int) int\\n\\tdp = func(si int) int {\\n\\t\\tif mem[si] != -1 {\\n\\t\\t\\treturn mem[si]\\n\\t\\t}\\n\\t\\tif si >= l {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif si == lm {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\n\\t\\tdd := (s[si+1][0] - s[si][1]) * dp(si+1)\\n\\t\\tmem[si] = dd % 1000000007\\n\\t\\treturn mem[si]\\n\\t}\\n\\n\\treturn dp(0) % 1000000007\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numberOfWays(c string) int {\\n\\tv := 0\\n\\tfor i := range c {\\n\\t\\tif c[i] == 83 {\\n\\t\\t\\tv++\\n\\t\\t}\\n\\t}\\n\\tif v&1 != 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tl := v / 2\\n\\tlm := l - 1\\n\\ts := make([][2]int, 0, l)\\n\\tif cap(s) == 1 || cap(s) == 0 {\\n\\t\\treturn cap(s)\\n\\t}\\n\\tf := -1\\n\\tfor i := range c {\\n\\t\\tif c[i] == 83 {\\n\\t\\t\\tif f == -1 {\\n\\t\\t\\t\\tf = i\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = append(s, [2]int{f, i})\\n\\t\\t\\t\\tf = -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tmem := make([]int, l)\\n\\tfor i := range mem {\\n\\t\\tmem[i] = -1\\n\\t}\\n\\n\\tvar dp func(int) int\\n\\tdp = func(si int) int {\\n\\t\\tif mem[si] != -1 {\\n\\t\\t\\treturn mem[si]\\n\\t\\t}\\n\\t\\tif si >= l {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif si == lm {\\n\\t\\t\\treturn 1\\n\\t\\t}\\n\\n\\t\\tdd := (s[si+1][0] - s[si][1]) * dp(si+1)\\n\\t\\tmem[si] = dd % 1000000007\\n\\t\\treturn mem[si]\\n\\t}\\n\\n\\treturn dp(0) % 1000000007\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795584,
                "title": "c-simple-solution",
                "content": "If there are odd number of seats or if there are no seats then we cannot devide. Therefore return 0. If there are two seats then we can divide in only one way so return one. Otherwise, find the end index of the first division **(startindex)** and the starting index of the last division **(lastindex)**. Iterate from (startindex + 1) to (lastindex - 1) and count the difference between the start of a new division and the previous division. Multiply the difference with the product. \\n\\nFinally return the product.\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int findFirst(string corridor)  \\n    {\\n        int count = 0;\\n        int i=0;\\n        while(count<2)\\n        {\\n            if(corridor[i]==\\'S\\')\\n                count++;\\n            i++;\\n        }\\n        return (i-1);\\n    }\\n    \\n    int findLast(string corridor)\\n    {\\n        int count=0;\\n        int i=corridor.length() - 1;\\n        while(count<2)\\n        {\\n            if(corridor[i]==\\'S\\')\\n                count++;\\n            i--;\\n        }\\n        return (i+1);\\n    }\\n    \\n    \\n    int numberOfWays(string corridor) {\\n        \\n        int countseats = 0;\\n        for(int i=0; i<corridor.length(); i++)\\n        {\\n            if(corridor[i] == \\'S\\')\\n                countseats++;\\n        }\\n        if(countseats%2==1 || countseats==0)\\n            return 0;\\n        if(countseats==2)\\n            return 1;\\n        \\n        int startindex = findFirst(corridor);\\n        int lastindex = findLast(corridor);\\n        int count = 0;\\n        int previndex = startindex;\\n        long long prod = 1;\\n        for(int i=(startindex+1); i<lastindex; i++)\\n        {\\n            if(corridor[i]==\\'S\\')\\n            {\\n                if(count%2==0)\\n                {\\n                    prod = (prod * (i - previndex))%1000000007;\\n                    count++;\\n                }\\n                else\\n                {\\n                    previndex = i;\\n                    count++;\\n                }\\n            }   \\n        }\\n        \\n        prod = (prod * (lastindex - previndex)%1000000007)%1000000007;\\n        int pr = prod;\\n        return pr;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int findFirst(string corridor)  \\n    {\\n        int count = 0;\\n        int i=0;\\n        while(count<2)\\n        {\\n            if(corridor[i]==\\'S\\')\\n                count++;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1767670,
                "title": "simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int n = corridor.length();\\n        int count=0;\\n        for(char ch:corridor){\\n            if(ch==\\'S\\') count++;\\n        }\\n        if(count&1 || count<2) return 0;\\n        count=0;\\n        vector<int> ans;\\n        vector<int> see;\\n        for(int i=0;i<n;i++){\\n            if(corridor[i]==\\'P\\') continue;\\n            if(corridor[i]==\\'S\\') count++;\\n            if(count==2) {\\n                ans.push_back(i);\\n                count=0;\\n            }\\n            if(count==1) see.push_back(i);\\n        }\\n        long long answer =1;\\n        int anss=ans.size();\\n        \\n        for(int i=1;i<anss;i++){\\n            answer = answer * (see[i]-ans[i-1]);\\n            answer%=(1000000000 + 7);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int n = corridor.length();\\n        int count=0;\\n        for(char ch:corridor){\\n            if(ch==\\'S\\') count++;\\n        }\\n        if(count&1 || count<2) return 0;\\n        count=0;\\n        vector<int> ans;\\n        vector<int> see;\\n        for(int i=0;i<n;i++){\\n            if(corridor[i]==\\'P\\') continue;\\n            if(corridor[i]==\\'S\\') count++;\\n            if(count==2) {\\n                ans.push_back(i);\\n                count=0;\\n            }\\n            if(count==1) see.push_back(i);\\n        }\\n        long long answer =1;\\n        int anss=ans.size();\\n        \\n        for(int i=1;i<anss;i++){\\n            answer = answer * (see[i]-ans[i-1]);\\n            answer%=(1000000000 + 7);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757082,
                "title": "easy-o-n-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string cr) {\\n        int n=cr.size();\\n        vector<long long> dp(n+1,0);\\n        int md=1000000000 + 7;\\n        int cnt=0;\\n        dp[0]=1;\\n        for(int i=0;i<n;i++) if(cr[i]==\\'S\\')cnt++;\\n        if(!cnt || cnt%2) return 0;             // if  number of chairs are 0 or odd no solution available\\n        int x=-1,y=-1,k=0;        \\n        for(int i=1;i<=n;i++){\\n                if(cr[i-1]==\\'S\\'){k++;\\n                if(k==1) y=i;                         // y stores last known location where k=1\\n                if(k==2){\\n                    if(x!=-1){\\n                        dp[i]=(y-x)*dp[x];           // between y and x there are only plants present and we can insert a divider at each location between them\\n                        dp[i]=dp[i]%md;\\n                    }\\n                    else{\\n                        dp[i]=1;\\n                    }\\n                    x=i;                             // X stores last known location where k=2\\n                }\\n                k=k%2;\\n                }\\n            else dp[i]=dp[i-1];\\n        }\\n     \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string cr) {\\n        int n=cr.size();\\n        vector<long long> dp(n+1,0);\\n        int md=1000000000 + 7;\\n        int cnt=0;\\n        dp[0]=1;\\n        for(int i=0;i<n;i++) if(cr[i]==\\'S\\')cnt++;\\n        if(!cnt || cnt%2) return 0;             // if  number of chairs are 0 or odd no solution available\\n        int x=-1,y=-1,k=0;        \\n        for(int i=1;i<=n;i++){\\n                if(cr[i-1]==\\'S\\'){k++;\\n                if(k==1) y=i;                         // y stores last known location where k=1\\n                if(k==2){\\n                    if(x!=-1){\\n                        dp[i]=(y-x)*dp[x];           // between y and x there are only plants present and we can insert a divider at each location between them\\n                        dp[i]=dp[i]%md;\\n                    }\\n                    else{\\n                        dp[i]=1;\\n                    }\\n                    x=i;                             // X stores last known location where k=2\\n                }\\n                k=k%2;\\n                }\\n            else dp[i]=dp[i-1];\\n        }\\n     \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756555,
                "title": "no-dp-soln-simple-implentation",
                "content": "Hi guys I have solved the problem without DP (No recurrence relation is used here.) I have used an auxiliary where I am storing the start and ending of a segmentation. And I am storing the number of P\\'s between each segments and multiplying them to return the final result.\\n```\\nclass Solution {\\n    \\n    public int numberOfWays(String c) {\\n        \\n        int h[] = new int[c.length()];\\n        int count = 0;\\n        int tc = 0;\\n\\t\\t\\n\\t\\t// filling segmentation boundaries in the array  as per the hint\\n        for(int i=0;i<c.length();i++){\\n            if(c.charAt(i)==\\'S\\'){\\n                tc++;\\n                count++;\\n                if(count==1){\\n                    h[i] = 1;\\n                }\\n                if(count==2){\\n                    h[i] = 2;\\n                    count = 0;\\n                }\\n            }\\n        }\\n\\t\\t// if totalcount is 0 or not even return 0\\n        if(tc%2!=0 || tc==0){return 0;}\\n        int start = 0;\\n        List<Integer> countps = new ArrayList<>();\\n        int MOD = 1_000_000_007;\\n        while(start<h.length){\\n            int countp = 0;\\n\\t\\t\\t// if h[0] = 1 it means my segment starting and h[0] = 2 my segmentation is ending there. In // //between 1 and 2 we have to number of 0s. If there are 0s after 2 in the end they won\\'t be considered //because we cannot establish partition when there are no seats\\n            if(h[start]==2){\\n                countp = 0;\\n\\t\\t\\t\\t// Here I am trying to find how many P\\'s are between each segment.\\n                while(h[start]!=1){\\n                    start++;\\n                    countp = (countp%MOD+1%MOD)%MOD;\\n                    if(start==h.length){break;}\\n                    if(h[start]==1){countps.add(countp);break;}\\n                }\\n            }\\n            start++;\\n        }\\n        long ans = 1;\\n        for(int i: countps){\\n            ans = (long)(((ans%MOD)*(i%MOD))%MOD);\\n        }\\n        return (int)(ans%MOD);\\n    }\\n    \\n\\t/// Only for debugging purposes\\n    public void printArr(int[] arr){\\n        for(int i: arr){\\n            System.out.print(i+\" \");\\n        }\\n        System.out.println(\"\");    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int numberOfWays(String c) {\\n        \\n        int h[] = new int[c.length()];\\n        int count = 0;\\n        int tc = 0;\\n\\t\\t\\n\\t\\t// filling segmentation boundaries in the array  as per the hint\\n        for(int i=0;i<c.length();i++){\\n            if(c.charAt(i)==\\'S\\'){\\n                tc++;\\n                count++;\\n                if(count==1){\\n                    h[i] = 1;\\n                }\\n                if(count==2){\\n                    h[i] = 2;\\n                    count = 0;\\n                }\\n            }\\n        }\\n\\t\\t// if totalcount is 0 or not even return 0\\n        if(tc%2!=0 || tc==0){return 0;}\\n        int start = 0;\\n        List<Integer> countps = new ArrayList<>();\\n        int MOD = 1_000_000_007;\\n        while(start<h.length){\\n            int countp = 0;\\n\\t\\t\\t// if h[0] = 1 it means my segment starting and h[0] = 2 my segmentation is ending there. In // //between 1 and 2 we have to number of 0s. If there are 0s after 2 in the end they won\\'t be considered //because we cannot establish partition when there are no seats\\n            if(h[start]==2){\\n                countp = 0;\\n\\t\\t\\t\\t// Here I am trying to find how many P\\'s are between each segment.\\n                while(h[start]!=1){\\n                    start++;\\n                    countp = (countp%MOD+1%MOD)%MOD;\\n                    if(start==h.length){break;}\\n                    if(h[start]==1){countps.add(countp);break;}\\n                }\\n            }\\n            start++;\\n        }\\n        long ans = 1;\\n        for(int i: countps){\\n            ans = (long)(((ans%MOD)*(i%MOD))%MOD);\\n        }\\n        return (int)(ans%MOD);\\n    }\\n    \\n\\t/// Only for debugging purposes\\n    public void printArr(int[] arr){\\n        for(int i: arr){\\n            System.out.print(i+\" \");\\n        }\\n        System.out.println(\"\");    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750784,
                "title": "greedy-c",
                "content": "```\\n/*\\n    we have to make two seats enclosed, and in the remaining gaps, we can place the dividers anywhere\\n    the first divider has to be mandatorily installed\\n\\n*/\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        int len = s.length();\\n        bool isFirstDividerInstalled = false;\\n        int seats = 0;\\n        int plants = 0;\\n        int mod = 1e9 + 7;\\n        int total = 0;\\n        long long ans = 1;\\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'S\\') {\\n                total++;\\n                seats++;\\n            }  else if (seats == 0) {\\n                plants++;\\n            }\\n\\n            if (seats == 2) {\\n                seats = 0;\\n                plants = 0;\\n                if (!isFirstDividerInstalled) isFirstDividerInstalled = true;\\n            }\\n\\n            if (s[i] == \\'S\\' && seats == 1) {\\n                if (isFirstDividerInstalled) {\\n                    /* do this answer update only when the first divider has been placed\\n                        if we have something like PPPPS, then it will unncesearily multiply 5 (4 + 1)\\n                    */\\n                    ans  = (ans % mod * (plants + 1) % mod) % mod;\\n                }\\n            }\\n        }\\n        if (total == 0 || total % 2) return 0;\\n        else return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n/*\\n    we have to make two seats enclosed, and in the remaining gaps, we can place the dividers anywhere\\n    the first divider has to be mandatorily installed\\n\\n*/\\nclass Solution {\\npublic:\\n    int numberOfWays(string s) {\\n        int len = s.length();\\n        bool isFirstDividerInstalled = false;\\n        int seats = 0;\\n        int plants = 0;\\n        int mod = 1e9 + 7;\\n        int total = 0;\\n        long long ans = 1;\\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'S\\') {\\n                total++;\\n                seats++;\\n            }  else if (seats == 0) {\\n                plants++;\\n            }\\n\\n            if (seats == 2) {\\n                seats = 0;\\n                plants = 0;\\n                if (!isFirstDividerInstalled) isFirstDividerInstalled = true;\\n            }\\n\\n            if (s[i] == \\'S\\' && seats == 1) {\\n                if (isFirstDividerInstalled) {\\n                    /* do this answer update only when the first divider has been placed\\n                        if we have something like PPPPS, then it will unncesearily multiply 5 (4 + 1)\\n                    */\\n                    ans  = (ans % mod * (plants + 1) % mod) % mod;\\n                }\\n            }\\n        }\\n        if (total == 0 || total % 2) return 0;\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745400,
                "title": "python-o-n-with-explanation-easiest-to-understand",
                "content": "**CORNER CASES**\\nIf the number of seats is odd or 0, return 0. Impossible.\\n\\n**THEN: TRIM PLANTS ON EDGES**\\n\\nThese don\\'t affect our solution. If you have\\n\\n...SSPP == ...SS\\nand likewise\\nPPSS... == SS..\\n\\nYou can\\'t place the dividers in plants. May as well get rid of them.\\n\\n**ALGORITHM**\\nNow we know our string is in the form:\\n\\nS P\\\\* S [**PLANT DIVIDER SECTION!**] S P\\\\* S [**PLANT DIVIDER SECTION!**] S P\\\\* S\\n(P\\\\* means 0 or more plants)\\n\\nAnd so on.\\n\\nOur answer will be:\\n\\n1 \\xD7 (number of plants in first PLANT DIVIDER SECTION + 1) \\xD7 (number of plants in second PLANT DIVIDER SECTION + 1) \\xD7 ... \\xD7 (number of plants in last PLANT DIVIDER SECTION + 1)\\n\\nThis is because combinatorics: If you have a PLANT DIVIDER SECTION which is PP, you can divide it like:\\n|PP or P|P or PP|\\n2 plants + 1 = 3 possibilities. \\n\\nMultiply all the possibilities together for each PLANT DIVIDER SECTION.\\n\\n**CODE**\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        totalNumberSeats = corridor.count(\\'S\\')\\n        if totalNumberSeats % 2 == 1 or totalNumberSeats == 0:\\n            return 0\\n        \\n        corridor = corridor.strip(\\'P\\')\\n\\n        ans = 1\\n        \\n        i = 0\\n        while i < len(corridor):\\n            chairsFound = 0\\n            while chairsFound != 2:\\n                chairsFound += 1 if corridor[i] == \\'S\\' else 0\\n                i += 1\\n                \\n            numPlants = 0\\n            while i < len(corridor) and corridor[i] == \\'P\\':\\n                numPlants += 1\\n                i += 1\\n                \\n            ans = (ans * (numPlants + 1)) % 1000000007\\n            \\n        return ans\\n        \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        totalNumberSeats = corridor.count(\\'S\\')\\n        if totalNumberSeats % 2 == 1 or totalNumberSeats == 0:\\n            return 0\\n        \\n        corridor = corridor.strip(\\'P\\')\\n\\n        ans = 1\\n        \\n        i = 0\\n        while i < len(corridor):\\n            chairsFound = 0\\n            while chairsFound != 2:\\n                chairsFound += 1 if corridor[i] == \\'S\\' else 0\\n                i += 1\\n                \\n            numPlants = 0\\n            while i < len(corridor) and corridor[i] == \\'P\\':\\n                numPlants += 1\\n                i += 1\\n                \\n            ans = (ans * (numPlants + 1)) % 1000000007\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731884,
                "title": "linear-solution-83-speed",
                "content": "![image](https://assets.leetcode.com/users/images/3c02187d-3dc3-427e-b558-e3543b520373_1643556179.3571796.png)\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        seat_idx = [i for i, c in enumerate(corridor) if c == \"S\"]\\n        len_seat_idx = len(seat_idx)\\n        if not len_seat_idx % 2 and len_seat_idx > 1:\\n            ans = 1\\n            for i, idx in enumerate(seat_idx):\\n                if i > 0 and not i % 2:\\n                    ans *= (idx - seat_idx[i - 1])\\n            return ans % 1_000_000_007\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        seat_idx = [i for i, c in enumerate(corridor) if c == \"S\"]\\n        len_seat_idx = len(seat_idx)\\n        if not len_seat_idx % 2 and len_seat_idx > 1:\\n            ans = 1\\n            for i, idx in enumerate(seat_idx):\\n                if i > 0 and not i % 2:\\n                    ans *= (idx - seat_idx[i - 1])\\n            return ans % 1_000_000_007\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729425,
                "title": "so-much-of-edge-cases-i-loved-this-question-o-n-o-1",
                "content": "``` \\nTime Complexity : O(n)\\nSpace Complexity: O(1)\\n```\\n\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        seat = plant = 0\\n        ans, MOD = 1, 10**9 +7\\n        \\n        for i in corridor:\\n            if seat and seat % 2 == 0 and i == \\'P\\': plant += 1\\n            if i == \\'S\\': seat += 1\\n            if seat and seat % 4 == 0:\\n                ans = (ans * (plant+1)) % MOD\\n                seat, plant = 2, 0\\n        if seat & 1 or not seat: return 0\\n        return ans\\n```",
                "solutionTags": [],
                "code": "``` \\nTime Complexity : O(n)\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution:\\n    def numberOfWays(self, corridor: str) -> int:\\n        seat = plant = 0\\n        ans, MOD = 1, 10**9 +7\\n        \\n        for i in corridor:\\n            if seat and seat % 2 == 0 and i == \\'P\\': plant += 1\\n            if i == \\'S\\': seat += 1\\n            if seat and seat % 4 == 0:\\n                ans = (ans * (plant+1)) % MOD\\n                seat, plant = 2, 0\\n        if seat & 1 or not seat: return 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728790,
                "title": "basic-mathematics",
                "content": "We can place dividers after 2 seats are present\\nSuppose a case like SPS,P,P,P,SS,P,SS\\nHere the possible places for divider are represented via \" , \"\\nSo possible no of combinations are 4*2 = 8\\nSo basically we have to count no. of possible places for dividers after 2seats(which are obtained) before and it will be (No of plants present on between + 1)\\nImplementation is shown below:\\n```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int mod=1e9+7;\\n        int n=corridor.length();\\n        int scnt=0,curr=1;\\n        long long res=1;\\n        for(int i=0;i<n;i++){\\n\\t\\t// if < 2 seat are present before we can\\'t place divider\\n            if(scnt<2){\\n                scnt += (corridor[i]==\\'S\\');\\n            }\\n\\t\\t// otherwise we count possible places by incrementing cnt by 1 for each \\'P\\'\\n\\t\\t\\telse{\\n                if(corridor[i]==\\'P\\'){\\n                    curr++;\\n                }\\n\\t\\t\\t\\t// when another seat is encountered curr stores maxm. possible places\\n\\t\\t\\t\\t// so we multiply curr by res and update scount and curr\\n\\t\\t\\t\\telse{\\n                    scnt=1;\\n                    res = ((res%mod)*(curr%mod))%mod;\\n                    curr=1;\\n                }\\n            }\\n        }\\n\\t\\t// scnt will be =2 for possible solutions as in the end 2 seats will be present\\n        return (scnt==2)?res:0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int mod=1e9+7;\\n        int n=corridor.length();\\n        int scnt=0,curr=1;\\n        long long res=1;\\n        for(int i=0;i<n;i++){\\n\\t\\t// if < 2 seat are present before we can\\'t place divider\\n            if(scnt<2){\\n                scnt += (corridor[i]==\\'S\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1727898,
                "title": "java-recursive-top-down-dp",
                "content": "Recursion (TLE):\\n```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        return helper(0,0,corridor);\\n    }\\n    \\n    private int helper(int ind,int seats,String corr){\\n        if(ind==corr.length()){\\n            if(seats==2) return 1; //if we have seen 2 seats after last partition then only it is valid\\n            return 0; //if not then return 0 bcz not correct way of partition.\\n        }\\n        \\n        int res=0;\\n        if(seats==2){\\n            //if this is plant and we have seen two seats\\n            if(corr.charAt(ind)==\\'P\\'){\\n                //partition\\n                res+=helper(ind+1,0,corr);\\n                \\n                //do not part\\n                res+=helper(ind+1,seats,corr);\\n            }\\n            //if current element is seat we have to do partition\\n            else{\\n                res+=helper(ind+1,1,corr);\\n            }\\n        }\\n        //if seats are not 2\\n        else{\\n            if (corr.charAt(ind)==\\'S\\')  res+=helper(ind+1,seats+1,corr);\\n            else    res+=helper(ind+1,seats,corr);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nTOP/Down Approach:-\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int numberOfWays(String corridor) {\\n        int[][] dp=new int[corridor.length()][3];\\n        for(int[] d:dp){\\n            Arrays.fill(d,-1);\\n        } \\n        return helper(0,0,corridor,dp);\\n    }\\n    \\n    private int helper(int ind,int seats,String corr,int[][] dp){\\n        if(ind==corr.length()){\\n            if(seats==2) return 1; //if we have seen 2 seats after last partition then only it is valid\\n            return 0; //if not then return 0 bcz not correct way of partition.\\n        }\\n        if(dp[ind][seats]!=-1) return dp[ind][seats];\\n        int res=0;\\n        if(seats==2){\\n            //if this is plant and we have seen two seats\\n            if(corr.charAt(ind)==\\'P\\'){\\n                //partition\\n                res+=helper(ind+1,0,corr,dp);\\n                \\n                //do not part\\n                res+=helper(ind+1,seats,corr,dp);\\n            }\\n            //if current element is seat we have to do partition\\n            else{\\n                res+=helper(ind+1,1,corr,dp);\\n            }\\n        }\\n        //if seats are not 2\\n        else{\\n            if (corr.charAt(ind)==\\'S\\')  res+=helper(ind+1,seats+1,corr,dp);\\n            else    res+=helper(ind+1,seats,corr,dp);\\n        }\\n        res%=mod;\\n        return dp[ind][seats]=res;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfWays(String corridor) {\\n        return helper(0,0,corridor);\\n    }\\n    \\n    private int helper(int ind,int seats,String corr){\\n        if(ind==corr.length()){\\n            if(seats==2) return 1; //if we have seen 2 seats after last partition then only it is valid\\n            return 0; //if not then return 0 bcz not correct way of partition.\\n        }\\n        \\n        int res=0;\\n        if(seats==2){\\n            //if this is plant and we have seen two seats\\n            if(corr.charAt(ind)==\\'P\\'){\\n                //partition\\n                res+=helper(ind+1,0,corr);\\n                \\n                //do not part\\n                res+=helper(ind+1,seats,corr);\\n            }\\n            //if current element is seat we have to do partition\\n            else{\\n                res+=helper(ind+1,1,corr);\\n            }\\n        }\\n        //if seats are not 2\\n        else{\\n            if (corr.charAt(ind)==\\'S\\')  res+=helper(ind+1,seats+1,corr);\\n            else    res+=helper(ind+1,seats,corr);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int numberOfWays(String corridor) {\\n        int[][] dp=new int[corridor.length()][3];\\n        for(int[] d:dp){\\n            Arrays.fill(d,-1);\\n        } \\n        return helper(0,0,corridor,dp);\\n    }\\n    \\n    private int helper(int ind,int seats,String corr,int[][] dp){\\n        if(ind==corr.length()){\\n            if(seats==2) return 1; //if we have seen 2 seats after last partition then only it is valid\\n            return 0; //if not then return 0 bcz not correct way of partition.\\n        }\\n        if(dp[ind][seats]!=-1) return dp[ind][seats];\\n        int res=0;\\n        if(seats==2){\\n            //if this is plant and we have seen two seats\\n            if(corr.charAt(ind)==\\'P\\'){\\n                //partition\\n                res+=helper(ind+1,0,corr,dp);\\n                \\n                //do not part\\n                res+=helper(ind+1,seats,corr,dp);\\n            }\\n            //if current element is seat we have to do partition\\n            else{\\n                res+=helper(ind+1,1,corr,dp);\\n            }\\n        }\\n        //if seats are not 2\\n        else{\\n            if (corr.charAt(ind)==\\'S\\')  res+=helper(ind+1,seats+1,corr,dp);\\n            else    res+=helper(ind+1,seats,corr,dp);\\n        }\\n        res%=mod;\\n        return dp[ind][seats]=res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725092,
                "title": "c-t-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int mod=1000000007;\\n        \\n        if(corridor.length()==1) return 0;\\n        \\n        int c=0;\\n        for(int i=0;i<corridor.length();i++){\\n            if(corridor[i]==\\'S\\') c++;\\n        }\\n        \\n        if(c<2 || c%2!=0) return 0;\\n        if(c==2) return 1;\\n        \\n        int dividor=(c/2)-1;\\n        int d=0;\\n        long long int ans=1;\\n        int s=0;\\n        \\n        int last_value=0;\\n        int flag=0;\\n        \\n        for(int i=0;i<corridor.length();i++){\\n            if(corridor[i]==\\'S\\') s++;\\n            \\n            if(s==2){\\n                last_value=i;\\n                flag=1;\\n                s=0;\\n            } \\n            \\n            if(s==1 && flag==1){\\n                i%=mod;\\n                last_value%=mod;\\n                ans*=(i-last_value)%mod;\\n                flag=0;\\n                d++;\\n            }\\n            ans%=mod;\\n        }\\n        \\n        return (int)ans%mod;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        int mod=1000000007;\\n        \\n        if(corridor.length()==1) return 0;\\n        \\n        int c=0;\\n        for(int i=0;i<corridor.length();i++){\\n            if(corridor[i]==\\'S\\') c++;\\n        }\\n        \\n        if(c<2 || c%2!=0) return 0;\\n        if(c==2) return 1;\\n        \\n        int dividor=(c/2)-1;\\n        int d=0;\\n        long long int ans=1;\\n        int s=0;\\n        \\n        int last_value=0;\\n        int flag=0;\\n        \\n        for(int i=0;i<corridor.length();i++){\\n            if(corridor[i]==\\'S\\') s++;\\n            \\n            if(s==2){\\n                last_value=i;\\n                flag=1;\\n                s=0;\\n            } \\n            \\n            if(s==1 && flag==1){\\n                i%=mod;\\n                last_value%=mod;\\n                ans*=(i-last_value)%mod;\\n                flag=0;\\n                d++;\\n            }\\n            ans%=mod;\\n        }\\n        \\n        return (int)ans%mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1856826,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "I think this is a medium level question."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Yeah, hard questions should have a trick. This is simply rule of product."
                    },
                    {
                        "username": "532124670",
                        "content": "Easy problem, doesn\\'t deserve HARD."
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "What does this line means? I am confused.\\n\\n```\\nTwo ways are different if there is a position\\nwith a room divider installed in the first way\\nbut not in the second way\\n```"
                    },
                    {
                        "username": "timmy1691",
                        "content": "I am trying to do the question via combinations, but is anyone running into time limit error? Anyone have any suggestions to optimize the process?\\n\\nI assume the time error is ran into during finding the numbers and the multiplications and modulo arithmetic."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Solution 1: Combination\\nAssume a[i] is the index of ith seat,\\nthere are a[i+1] - a[i] ways to put a divider between ith and i+1th seats.\\nWe only needs to calculate the produit of all these a[i+1] - a[i].\\n\\nIf the number of seat is odd or is less than 2, then no way to divide the corridor.\\n\\nTime O(n)\\nSpace O(1)\\n\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        long res = 1, j = 0, k = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < corridor.size(); ++i) {\\n            if (corridor[i] == \\'S\\') {\\n                if (++k > 2 && k % 2 == 1)\\n                    res = res * (i - j) % mod;\\n                j = i;\\n            }\\n        }\\n        return k % 2 == 0 && k > 0 ? res : 0;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1743841,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "I think this is a medium level question."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Yeah, hard questions should have a trick. This is simply rule of product."
                    },
                    {
                        "username": "532124670",
                        "content": "Easy problem, doesn\\'t deserve HARD."
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "What does this line means? I am confused.\\n\\n```\\nTwo ways are different if there is a position\\nwith a room divider installed in the first way\\nbut not in the second way\\n```"
                    },
                    {
                        "username": "timmy1691",
                        "content": "I am trying to do the question via combinations, but is anyone running into time limit error? Anyone have any suggestions to optimize the process?\\n\\nI assume the time error is ran into during finding the numbers and the multiplications and modulo arithmetic."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Solution 1: Combination\\nAssume a[i] is the index of ith seat,\\nthere are a[i+1] - a[i] ways to put a divider between ith and i+1th seats.\\nWe only needs to calculate the produit of all these a[i+1] - a[i].\\n\\nIf the number of seat is odd or is less than 2, then no way to divide the corridor.\\n\\nTime O(n)\\nSpace O(1)\\n\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        long res = 1, j = 0, k = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < corridor.size(); ++i) {\\n            if (corridor[i] == \\'S\\') {\\n                if (++k > 2 && k % 2 == 1)\\n                    res = res * (i - j) % mod;\\n                j = i;\\n            }\\n        }\\n        return k % 2 == 0 && k > 0 ? res : 0;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1908891,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "I think this is a medium level question."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Yeah, hard questions should have a trick. This is simply rule of product."
                    },
                    {
                        "username": "532124670",
                        "content": "Easy problem, doesn\\'t deserve HARD."
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "What does this line means? I am confused.\\n\\n```\\nTwo ways are different if there is a position\\nwith a room divider installed in the first way\\nbut not in the second way\\n```"
                    },
                    {
                        "username": "timmy1691",
                        "content": "I am trying to do the question via combinations, but is anyone running into time limit error? Anyone have any suggestions to optimize the process?\\n\\nI assume the time error is ran into during finding the numbers and the multiplications and modulo arithmetic."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Solution 1: Combination\\nAssume a[i] is the index of ith seat,\\nthere are a[i+1] - a[i] ways to put a divider between ith and i+1th seats.\\nWe only needs to calculate the produit of all these a[i+1] - a[i].\\n\\nIf the number of seat is odd or is less than 2, then no way to divide the corridor.\\n\\nTime O(n)\\nSpace O(1)\\n\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        long res = 1, j = 0, k = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < corridor.size(); ++i) {\\n            if (corridor[i] == \\'S\\') {\\n                if (++k > 2 && k % 2 == 1)\\n                    res = res * (i - j) % mod;\\n                j = i;\\n            }\\n        }\\n        return k % 2 == 0 && k > 0 ? res : 0;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1786550,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "I think this is a medium level question."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Yeah, hard questions should have a trick. This is simply rule of product."
                    },
                    {
                        "username": "532124670",
                        "content": "Easy problem, doesn\\'t deserve HARD."
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "What does this line means? I am confused.\\n\\n```\\nTwo ways are different if there is a position\\nwith a room divider installed in the first way\\nbut not in the second way\\n```"
                    },
                    {
                        "username": "timmy1691",
                        "content": "I am trying to do the question via combinations, but is anyone running into time limit error? Anyone have any suggestions to optimize the process?\\n\\nI assume the time error is ran into during finding the numbers and the multiplications and modulo arithmetic."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Solution 1: Combination\\nAssume a[i] is the index of ith seat,\\nthere are a[i+1] - a[i] ways to put a divider between ith and i+1th seats.\\nWe only needs to calculate the produit of all these a[i+1] - a[i].\\n\\nIf the number of seat is odd or is less than 2, then no way to divide the corridor.\\n\\nTime O(n)\\nSpace O(1)\\n\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        long res = 1, j = 0, k = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < corridor.size(); ++i) {\\n            if (corridor[i] == \\'S\\') {\\n                if (++k > 2 && k % 2 == 1)\\n                    res = res * (i - j) % mod;\\n                j = i;\\n            }\\n        }\\n        return k % 2 == 0 && k > 0 ? res : 0;\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1694016,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "I think this is a medium level question."
                    },
                    {
                        "username": "uneducatedPerson",
                        "content": "Yeah, hard questions should have a trick. This is simply rule of product."
                    },
                    {
                        "username": "532124670",
                        "content": "Easy problem, doesn\\'t deserve HARD."
                    },
                    {
                        "username": "harshitanjanajaiswal",
                        "content": "What does this line means? I am confused.\\n\\n```\\nTwo ways are different if there is a position\\nwith a room divider installed in the first way\\nbut not in the second way\\n```"
                    },
                    {
                        "username": "timmy1691",
                        "content": "I am trying to do the question via combinations, but is anyone running into time limit error? Anyone have any suggestions to optimize the process?\\n\\nI assume the time error is ran into during finding the numbers and the multiplications and modulo arithmetic."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Solution 1: Combination\\nAssume a[i] is the index of ith seat,\\nthere are a[i+1] - a[i] ways to put a divider between ith and i+1th seats.\\nWe only needs to calculate the produit of all these a[i+1] - a[i].\\n\\nIf the number of seat is odd or is less than 2, then no way to divide the corridor.\\n\\nTime O(n)\\nSpace O(1)\\n\\nclass Solution {\\npublic:\\n    int numberOfWays(string corridor) {\\n        long res = 1, j = 0, k = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < corridor.size(); ++i) {\\n            if (corridor[i] == \\'S\\') {\\n                if (++k > 2 && k % 2 == 1)\\n                    res = res * (i - j) % mod;\\n                j = i;\\n            }\\n        }\\n        return k % 2 == 0 && k > 0 ? res : 0;\\n        \\n    }\\n};"
                    }
                ]
            }
        ]
    }
]