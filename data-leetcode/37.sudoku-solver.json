[
    {
        "title": "Sudoku Solver",
        "question_content": "Write a program to solve a Sudoku puzzle by filling the empty cells.\nA sudoku solution must satisfy all of the following rules:\n\n\tEach of the digits 1-9 must occur exactly once in each row.\n\tEach of the digits 1-9 must occur exactly once in each column.\n\tEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n\nThe '.' character indicates empty cells.\n&nbsp;\nExample 1:\n\nInput: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation:&nbsp;The input board is shown above and the only valid solution is shown below:\n\n\n&nbsp;\nConstraints:\n\n\tboard.length == 9\n\tboard[i].length == 9\n\tboard[i][j] is a digit or '.'.\n\tIt is guaranteed that the input board has only one solution.",
        "solutions": [
            {
                "id": 15752,
                "title": "straight-forward-java-solution-using-backtracking",
                "content": "Try 1 through 9 for each cell. The time complexity should be 9 ^ m (m represents the number of blanks to be filled in), since each blank can have 9 choices. Details see comments inside code.\\n\\n```\\npublic class Solution {\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0)\\n            return;\\n        solve(board);\\n    }\\n    \\n    public boolean solve(char[][] board){\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == '.'){\\n                    for(char c = '1'; c <= '9'; c++){//trial. Try 1 through 9\\n                        if(isValid(board, i, j, c)){\\n                            board[i][j] = c; //Put c for this cell\\n                            \\n                            if(solve(board))\\n                                return true; //If it's the solution return true\\n                            else\\n                                board[i][j] = '.'; //Otherwise go back\\n                        }\\n                    }\\n                    \\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isValid(char[][] board, int row, int col, char c){\\n        for(int i = 0; i < 9; i++) {\\n            if(board[i][col] != '.' && board[i][col] == c) return false; //check row\\n            if(board[row][i] != '.' && board[row][i] == c) return false; //check column\\n            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && \\nboard[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0)\\n            return;\\n        solve(board);\\n    }\\n    \\n    public boolean solve(char[][] board){\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == '.'){\\n                    for(char c = '1'; c <= '9'; c++){//trial. Try 1 through 9\\n                        if(isValid(board, i, j, c)){\\n                            board[i][j] = c; //Put c for this cell\\n                            \\n                            if(solve(board))\\n                                return true; //If it's the solution return true\\n                            else\\n                                board[i][j] = '.'; //Otherwise go back\\n                        }\\n                    }\\n                    \\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isValid(char[][] board, int row, int col, char c){\\n        for(int i = 0; i < 9; i++) {\\n            if(board[i][col] != '.' && board[i][col] == c) return false; //check row\\n            if(board[row][i] != '.' && board[row][i] == c) return false; //check column\\n            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && \\nboard[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15853,
                "title": "simple-and-clean-solution-c",
                "content": "\\n    bool check(vector<vector<char>> &board, int i, int j, char val)\\n    {\\n        int row = i - i%3, column = j - j%3;\\n        for(int x=0; x<9; x++) if(board[x][j] == val) return false;\\n        for(int y=0; y<9; y++) if(board[i][y] == val) return false;\\n        for(int x=0; x<3; x++)\\n        for(int y=0; y<3; y++)\\n            if(board[row+x][column+y] == val) return false;\\n        return true;\\n    }\\n    bool solveSudoku(vector<vector<char>> &board, int i, int j)\\n    {\\n        if(i==9) return true;\\n        if(j==9) return solveSudoku(board, i+1, 0);\\n        if(board[i][j] != '.') return solveSudoku(board, i, j+1);\\n\\n        for(char c='1'; c<='9'; c++)\\n        {\\n            if(check(board, i, j, c))\\n            {\\n                board[i][j] = c;\\n                if(solveSudoku(board, i, j+1)) return true;\\n                board[i][j] = '.';\\n            }\\n        }\\n            \\n        return false;\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solveSudoku(board, 0, 0);\\n    }",
                "solutionTags": [],
                "code": "\\n    bool check(vector<vector<char>> &board, int i, int j, char val)\\n    {\\n        int row = i - i%3, column = j - j%3;\\n        for(int x=0; x<9; x++) if(board[x][j] == val) return false;\\n        for(int y=0; y<9; y++) if(board[i][y] == val) return false;\\n        for(int x=0; x<3; x++)\\n        for(int y=0; y<3; y++)\\n            if(board[row+x][column+y] == val) return false;\\n        return true;\\n    }\\n    bool solveSudoku(vector<vector<char>> &board, int i, int j)\\n    {\\n        if(i==9) return true;\\n        if(j==9) return solveSudoku(board, i+1, 0);\\n        if(board[i][j] != '.') return solveSudoku(board, i, j+1);\\n\\n        for(char c='1'; c<='9'; c++)\\n        {\\n            if(check(board, i, j, c))\\n            {\\n                board[i][j] = c;\\n                if(solveSudoku(board, i, j+1)) return true;\\n                board[i][j] = '.';\\n            }\\n        }\\n            \\n        return false;\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solveSudoku(board, 0, 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15796,
                "title": "singapore-prime-minister-lee-hsien-loong-s-sudoku-solver-code-runs-in-1ms",
                "content": "Singapore's prime minister [Lee Hsien Loong][1] showcased his Sudoku Solver C code. You can read his original Facebook post [here][2] and another news reporting it [here][3].\\n\\nI have made some slight modification to adapt it so it can be [tested on LeetCode OJ][4]. It passed all 6/6 test cases with a runtime of **1 ms**. Pretty impressive for a prime minister, huh?\\n\\n    // Original author: Hsien Loong Lee (http://bit.ly/1zfIGMc)\\n    // Slight modification by @1337c0d3r to adapt to run on LeetCode OJ.\\n    // https://leetcode.com/problems/sudoku-solver/\\n    int InBlock[81], InRow[81], InCol[81];\\n    \\n    const int BLANK = 0;\\n    const int ONES = 0x3fe; \\t// Binary 1111111110\\n    \\n    int Entry[81];\\t// Records entries 1-9 in the grid, as the corresponding bit set to 1\\n    int Block[9], Row[9], Col[9];\\t// Each int is a 9-bit array\\n    \\n    int SeqPtr = 0;\\n    int Sequence[81];\\n    \\n    \\n    \\n    void SwapSeqEntries(int S1, int S2)\\n    {\\n         int temp = Sequence[S2];\\n         Sequence[S2] = Sequence[S1];\\n         Sequence[S1] = temp;\\n    }\\n    \\n    \\n    void InitEntry(int i, int j, int val)\\n    {\\n    \\t int Square = 9 * i + j;\\n    \\t int valbit = 1 << val;\\n         int SeqPtr2;\\n    \\n         // add suitable checks for data consistency\\n         \\n    \\t Entry[Square] = valbit;\\n    \\t Block[InBlock[Square]] &= ~valbit;\\n    \\t Col[InCol[Square]] &= ~valbit; // Simpler Col[j] &= ~valbit;\\n    \\t Row[InRow[Square]] &= ~valbit; // Simpler Row[i] &= ~valbit;\\n    \\n         SeqPtr2 = SeqPtr;\\n         while (SeqPtr2 < 81 && Sequence[SeqPtr2] != Square)\\n               SeqPtr2++ ;\\n    \\n         SwapSeqEntries(SeqPtr, SeqPtr2);\\n         SeqPtr++;\\n    }\\n    \\n    \\n    void PrintArray(char **board)\\n    {\\n         int i, j, valbit, val, Square;\\n         char ch;\\n         \\n         Square = 0;\\n    \\n         for (i = 0; i < 9; i++) {\\n             for (j = 0; j < 9; j++) {\\n                 valbit = Entry[Square++];\\n                 if (valbit == 0) ch = '-';\\n                 else {\\n                     for (val = 1; val <= 9; val++) \\n                         if (valbit == (1 << val)) {\\n                            ch = '0' + val;\\n                            break;\\n                         }\\n                 }    \\n                 board[i][j] = ch;\\n             }\\n         }\\n    }\\n    \\n    \\n    int NextSeq(int S)\\n    {\\n        int S2, Square, Possibles, BitCount;\\n        int T, MinBitCount = 100;\\n    \\n        for (T = S; T < 81; T++) {\\n            Square = Sequence[T];\\n            Possibles = Block[InBlock[Square]] & Row[InRow[Square]] & Col[InCol[Square]];\\n            BitCount = 0;\\n            while (Possibles) {\\n               Possibles &= ~(Possibles & -Possibles);\\n               BitCount++;\\n            }\\n    \\n            if (BitCount < MinBitCount) {\\n               MinBitCount = BitCount;\\n               S2 = T;\\n            }\\n        }\\n    \\n        return S2;\\n    }\\n    \\n    \\n    void Place(int S, char** board)\\n    {\\n        if (S >= 81) {\\n            PrintArray(board);\\n            return;\\n        }\\n    \\n        int S2 = NextSeq(S);\\n        SwapSeqEntries(S, S2);\\n    \\n        int Square = Sequence[S];\\n    \\n        int \\tBlockIndex = InBlock[Square],\\n    \\t\\t\\tRowIndex = InRow[Square],\\n    \\t\\t\\tColIndex = InCol[Square];\\n    \\n        int \\tPossibles = Block[BlockIndex] & Row[RowIndex] & Col[ColIndex];\\n        while (Possibles) {\\n              int valbit = Possibles & (-Possibles); // Lowest 1 bit in Possibles\\n              Possibles &= ~valbit;\\n              Entry[Square] = valbit;\\n              Block[BlockIndex] &= ~valbit;\\n              Row[RowIndex] &= ~valbit;\\n              Col[ColIndex] &= ~valbit;\\n    \\t\\t\\t\\t\\n              Place(S + 1, board);\\n    \\n              Entry[Square] = BLANK; // Could be moved out of the loop\\n              Block[BlockIndex] |= valbit;\\n              Row[RowIndex] |= valbit;\\n              Col[ColIndex] |= valbit;\\n    \\t}\\n    \\n        SwapSeqEntries(S, S2);\\n    }\\n    \\n    void solveSudoku(char **board, int m, int n) {\\n        SeqPtr = 0;\\n        int i, j, Square;\\n    \\n    \\tfor (i = 0; i < 9; i++)\\n    \\t\\tfor (j = 0; j < 9; j++) {\\n    \\t\\t\\tSquare = 9 * i + j;\\n    \\t\\t\\tInRow[Square] = i;\\n    \\t\\t\\tInCol[Square] = j;\\n    \\t\\t\\tInBlock[Square] = (i / 3) * 3 + ( j / 3);\\n    \\t\\t}\\n    \\n    \\n    \\tfor (Square = 0; Square < 81; Square++) {\\n            Sequence[Square] = Square;\\n    \\t\\tEntry[Square] = BLANK;\\n        }\\n        \\n    \\tfor (i = 0; i < 9; i++) \\n    \\t\\tBlock[i] = Row[i] = Col[i] = ONES;\\n        \\n        for (int i = 0; i < 9; ++i)\\n           for (int j = 0; j < 9; ++j) {\\n               if ('.' != board[i][j])\\n                    InitEntry(i, j, board[i][j] - '0');\\n           }\\n           \\n        Place(SeqPtr, board);\\n    }\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Lee_Hsien_Loong\\n  [2]: https://www.facebook.com/leehsienloong/photos/a.344710778924968.83425.125845680811480/905828379479869/?type=3&permPage=1\\n  [3]: http://arstechnica.com/information-technology/2015/05/04/prime-minister-of-singapore-shares-his-c-code-for-sudoku-solver/\\n  [4]: https://leetcode.com/problems/sudoku-solver/",
                "solutionTags": [],
                "code": "Singapore's prime minister [Lee Hsien Loong][1] showcased his Sudoku Solver C code. You can read his original Facebook post [here][2] and another news reporting it [here][3].\\n\\nI have made some slight modification to adapt it so it can be [tested on LeetCode OJ][4]. It passed all 6/6 test cases with a runtime of **1 ms**. Pretty impressive for a prime minister, huh?\\n\\n    // Original author: Hsien Loong Lee (http://bit.ly/1zfIGMc)\\n    // Slight modification by @1337c0d3r to adapt to run on LeetCode OJ.\\n    // https://leetcode.com/problems/sudoku-solver/\\n    int InBlock[81], InRow[81], InCol[81];\\n    \\n    const int BLANK = 0;\\n    const int ONES = 0x3fe; \\t// Binary 1111111110\\n    \\n    int Entry[81];\\t// Records entries 1-9 in the grid, as the corresponding bit set to 1\\n    int Block[9], Row[9], Col[9];\\t// Each int is a 9-bit array\\n    \\n    int SeqPtr = 0;\\n    int Sequence[81];\\n    \\n    \\n    \\n    void SwapSeqEntries(int S1, int S2)\\n    {\\n         int temp = Sequence[S2];\\n         Sequence[S2] = Sequence[S1];\\n         Sequence[S1] = temp;\\n    }\\n    \\n    \\n    void InitEntry(int i, int j, int val)\\n    {\\n    \\t int Square = 9 * i + j;\\n    \\t int valbit = 1 << val;\\n         int SeqPtr2;\\n    \\n         // add suitable checks for data consistency\\n         \\n    \\t Entry[Square] = valbit;\\n    \\t Block[InBlock[Square]] &= ~valbit;\\n    \\t Col[InCol[Square]] &= ~valbit; // Simpler Col[j] &= ~valbit;\\n    \\t Row[InRow[Square]] &= ~valbit; // Simpler Row[i] &= ~valbit;\\n    \\n         SeqPtr2 = SeqPtr;\\n         while (SeqPtr2 < 81 && Sequence[SeqPtr2] != Square)\\n               SeqPtr2++ ;\\n    \\n         SwapSeqEntries(SeqPtr, SeqPtr2);\\n         SeqPtr++;\\n    }\\n    \\n    \\n    void PrintArray(char **board)\\n    {\\n         int i, j, valbit, val, Square;\\n         char ch;\\n         \\n         Square = 0;\\n    \\n         for (i = 0; i < 9; i++) {\\n             for (j = 0; j < 9; j++) {\\n                 valbit = Entry[Square++];\\n                 if (valbit == 0) ch = '-';\\n                 else {\\n                     for (val = 1; val <= 9; val++) \\n                         if (valbit == (1 << val)) {\\n                            ch = '0' + val;\\n                            break;\\n                         }\\n                 }    \\n                 board[i][j] = ch;\\n             }\\n         }\\n    }\\n    \\n    \\n    int NextSeq(int S)\\n    {\\n        int S2, Square, Possibles, BitCount;\\n        int T, MinBitCount = 100;\\n    \\n        for (T = S; T < 81; T++) {\\n            Square = Sequence[T];\\n            Possibles = Block[InBlock[Square]] & Row[InRow[Square]] & Col[InCol[Square]];\\n            BitCount = 0;\\n            while (Possibles) {\\n               Possibles &= ~(Possibles & -Possibles);\\n               BitCount++;\\n            }\\n    \\n            if (BitCount < MinBitCount) {\\n               MinBitCount = BitCount;\\n               S2 = T;\\n            }\\n        }\\n    \\n        return S2;\\n    }\\n    \\n    \\n    void Place(int S, char** board)\\n    {\\n        if (S >= 81) {\\n            PrintArray(board);\\n            return;\\n        }\\n    \\n        int S2 = NextSeq(S);\\n        SwapSeqEntries(S, S2);\\n    \\n        int Square = Sequence[S];\\n    \\n        int \\tBlockIndex = InBlock[Square],\\n    \\t\\t\\tRowIndex = InRow[Square],\\n    \\t\\t\\tColIndex = InCol[Square];\\n    \\n        int \\tPossibles = Block[BlockIndex] & Row[RowIndex] & Col[ColIndex];\\n        while (Possibles) {\\n              int valbit = Possibles & (-Possibles); // Lowest 1 bit in Possibles\\n              Possibles &= ~valbit;\\n              Entry[Square] = valbit;\\n              Block[BlockIndex] &= ~valbit;\\n              Row[RowIndex] &= ~valbit;\\n              Col[ColIndex] &= ~valbit;\\n    \\t\\t\\t\\t\\n              Place(S + 1, board);\\n    \\n              Entry[Square] = BLANK; // Could be moved out of the loop\\n              Block[BlockIndex] |= valbit;\\n              Row[RowIndex] |= valbit;\\n              Col[ColIndex] |= valbit;\\n    \\t}\\n    \\n        SwapSeqEntries(S, S2);\\n    }\\n    \\n    void solveSudoku(char **board, int m, int n) {\\n        SeqPtr = 0;\\n        int i, j, Square;\\n    \\n    \\tfor (i = 0; i < 9; i++)\\n    \\t\\tfor (j = 0; j < 9; j++) {\\n    \\t\\t\\tSquare = 9 * i + j;\\n    \\t\\t\\tInRow[Square] = i;\\n    \\t\\t\\tInCol[Square] = j;\\n    \\t\\t\\tInBlock[Square] = (i / 3) * 3 + ( j / 3);\\n    \\t\\t}\\n    \\n    \\n    \\tfor (Square = 0; Square < 81; Square++) {\\n            Sequence[Square] = Square;\\n    \\t\\tEntry[Square] = BLANK;\\n        }\\n        \\n    \\tfor (i = 0; i < 9; i++) \\n    \\t\\tBlock[i] = Row[i] = Col[i] = ONES;\\n        \\n        for (int i = 0; i < 9; ++i)\\n           for (int j = 0; j < 9; ++j) {\\n               if ('.' != board[i][j])\\n                    InitEntry(i, j, board[i][j] - '0');\\n           }\\n           \\n        Place(SeqPtr, board);\\n    }\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Lee_Hsien_Loong\\n  [2]: https://www.facebook.com/leehsienloong/photos/a.344710778924968.83425.125845680811480/905828379479869/?type=3&permPage=1\\n  [3]: http://arstechnica.com/information-technology/2015/05/04/prime-minister-of-singapore-shares-his-c-code-for-sudoku-solver/\\n  [4]: https://leetcode.com/problems/sudoku-solver/",
                "codeTag": "Unknown"
            },
            {
                "id": 4034246,
                "title": "readable-solution-youtube-walkthrough",
                "content": "[https://youtu.be/uwvz4AnaF-0]()\\n\\nCode:\\n```\\nclass Solution {\\n    private int[][] result = new int[9][9];\\n    private boolean[][] modifiable = new boolean[9][9];\\n\\n    public void solveSudoku(char[][] board) {\\n        markModifiable(board);\\n        recurse(0);\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                board[i][j] = Integer.toString(result[i][j]).charAt(0);\\n            }\\n        }\\n    }\\n\\n    private void markModifiable(char[][] board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                modifiable[i][j] = (board[i][j] == \\'.\\');\\n                if (!modifiable[i][j]) {\\n                    result[i][j] = Integer.parseInt(String.valueOf(board[i][j]));\\n                }\\n            }\\n        }\\n    }\\n\\n    private boolean recurse(int idx) {\\n        if (idx == 81) {\\n            return true;\\n        }\\n\\n        int row = idx / 9;\\n        int column = idx % 9;\\n\\n        for (int candidate = 1; candidate < 10; candidate++) {\\n            if (modifiable[row][column]) {\\n                result[row][column] = candidate;\\n                if (isValid(row, column) && recurse(idx + 1)) {\\n                    return true;\\n                }\\n            } else {\\n                return recurse(idx + 1);\\n            }\\n        }\\n        result[row][column] = 0;\\n        return false;\\n    }\\n\\n    private boolean isValid(int i, int j) {\\n        return isValidRow(i) && isValidColumn(j) && isValidBlock(i, j);\\n    }\\n\\n    private boolean isValidRow(int i) {\\n        boolean[] seen = new boolean[10];\\n        for (int j = 0; j < 9; j++) {\\n            int value = result[i][j];\\n            if (seen[value] && value != 0) {\\n                return false;\\n            }\\n            seen[value] = true;\\n        }\\n        return true;\\n    }\\n\\n    private boolean isValidColumn(int j) {\\n        boolean[] seen = new boolean[10];\\n        for (int i = 0; i < 9; i++) {\\n            int value = result[i][j];\\n            if (seen[value] && value != 0) {\\n                return false;\\n            }\\n            seen[value] = true;\\n        }\\n        return true;\\n    }\\n\\n    private boolean isValidBlock(int i, int j) {\\n        boolean[] seen = new boolean[10];\\n        for (int row = (i / 3) * 3; row < (i / 3) * 3 + 3; row++) {\\n            for (int column = (j / 3) * 3; column < (j / 3) * 3 + 3; column++) {\\n                int value = result[row][column];\\n                if (seen[value] && value != 0) {\\n                    return false;\\n                }\\n                seen[value] = true;\\n           }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] result = new int[9][9];\\n    private boolean[][] modifiable = new boolean[9][9];\\n\\n    public void solveSudoku(char[][] board) {\\n        markModifiable(board);\\n        recurse(0);\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                board[i][j] = Integer.toString(result[i][j]).charAt(0);\\n            }\\n        }\\n    }\\n\\n    private void markModifiable(char[][] board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                modifiable[i][j] = (board[i][j] == \\'.\\');\\n                if (!modifiable[i][j]) {\\n                    result[i][j] = Integer.parseInt(String.valueOf(board[i][j]));\\n                }\\n            }\\n        }\\n    }\\n\\n    private boolean recurse(int idx) {\\n        if (idx == 81) {\\n            return true;\\n        }\\n\\n        int row = idx / 9;\\n        int column = idx % 9;\\n\\n        for (int candidate = 1; candidate < 10; candidate++) {\\n            if (modifiable[row][column]) {\\n                result[row][column] = candidate;\\n                if (isValid(row, column) && recurse(idx + 1)) {\\n                    return true;\\n                }\\n            } else {\\n                return recurse(idx + 1);\\n            }\\n        }\\n        result[row][column] = 0;\\n        return false;\\n    }\\n\\n    private boolean isValid(int i, int j) {\\n        return isValidRow(i) && isValidColumn(j) && isValidBlock(i, j);\\n    }\\n\\n    private boolean isValidRow(int i) {\\n        boolean[] seen = new boolean[10];\\n        for (int j = 0; j < 9; j++) {\\n            int value = result[i][j];\\n            if (seen[value] && value != 0) {\\n                return false;\\n            }\\n            seen[value] = true;\\n        }\\n        return true;\\n    }\\n\\n    private boolean isValidColumn(int j) {\\n        boolean[] seen = new boolean[10];\\n        for (int i = 0; i < 9; i++) {\\n            int value = result[i][j];\\n            if (seen[value] && value != 0) {\\n                return false;\\n            }\\n            seen[value] = true;\\n        }\\n        return true;\\n    }\\n\\n    private boolean isValidBlock(int i, int j) {\\n        boolean[] seen = new boolean[10];\\n        for (int row = (i / 3) * 3; row < (i / 3) * 3 + 3; row++) {\\n            for (int column = (j / 3) * 3; column < (j / 3) * 3 + 3; column++) {\\n                int value = result[row][column];\\n                if (seen[value] && value != 0) {\\n                    return false;\\n                }\\n                seen[value] = true;\\n           }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15959,
                "title": "accepted-python-solution",
                "content": "    class Solution:\\n        # @param board, a 9x9 2D array\\n        # Solve the Sudoku by modifying the input board in-place.\\n        # Do not return any value.\\n        def solveSudoku(self, board):\\n            self.board = board\\n            self.solve()\\n        \\n        def findUnassigned(self):\\n            for row in range(9):\\n                for col in range(9):\\n                    if self.board[row][col] == \".\":\\n                        return row, col\\n            return -1, -1\\n        \\n        def solve(self):\\n            row, col = self.findUnassigned()\\n            #no unassigned position is found, puzzle solved\\n            if row == -1 and col == -1:\\n                return True\\n            for num in [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]:\\n                if self.isSafe(row, col, num):\\n                    self.board[row][col] = num\\n                    if self.solve():\\n                        return True\\n                    self.board[row][col] = \".\"\\n            return False\\n                \\n        def isSafe(self, row, col, ch):\\n            boxrow = row - row%3\\n            boxcol = col - col%3\\n            if self.checkrow(row,ch) and self.checkcol(col,ch) and self.checksquare(boxrow, boxcol, ch):\\n                return True\\n            return False\\n        \\n        def checkrow(self, row, ch):\\n            for col in range(9):\\n                if self.board[row][col] == ch:\\n                    return False\\n            return True\\n        \\n        def checkcol(self, col, ch):\\n            for row in range(9):\\n                if self.board[row][col] == ch:\\n                    return False\\n            return True\\n           \\n        def checksquare(self, row, col, ch):\\n            for r in range(row, row+3):\\n                for c in range(col, col+3):\\n                    if self.board[r][c] == ch:\\n                        return False\\n            return True\\n\\n\\nIt's a simple backtracking solution.",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param board, a 9x9 2D array\\n        # Solve the Sudoku by modifying the input board in-place.\\n        # Do not return any value.\\n        def solveSudoku(self, board):\\n            self.board = board\\n            self.solve()\\n        \\n        def findUnassigned(self):\\n            for row in range(9):\\n                for col in range(9):\\n                    if self.board[row][col] == \".\":\\n                        return row, col\\n            return -1, -1\\n        \\n        def solve(self):\\n            row, col = self.findUnassigned()\\n            #no unassigned position is found, puzzle solved\\n            if row == -1 and col == -1:\\n                return True\\n            for num in [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]:\\n                if self.isSafe(row, col, num):\\n                    self.board[row][col] = num\\n                    if self.solve():\\n                        return True\\n                    self.board[row][col] = \".\"\\n            return False\\n                \\n        def isSafe(self, row, col, ch):\\n            boxrow = row - row%3\\n            boxcol = col - col%3\\n            if self.checkrow(row,ch) and self.checkcol(col,ch) and self.checksquare(boxrow, boxcol, ch):\\n                return True\\n            return False\\n        \\n        def checkrow(self, row, ch):\\n            for col in range(9):\\n                if self.board[row][col] == ch:\\n                    return False\\n            return True\\n        \\n        def checkcol(self, col, ch):\\n            for row in range(9):\\n                if self.board[row][col] == ch:\\n                    return False\\n            return True\\n           \\n        def checksquare(self, row, col, ch):\\n            for r in range(row, row+3):\\n                for c in range(col, col+3):\\n                    if self.board[r][c] == ch:\\n                        return False\\n            return True\\n\\n\\nIt's a simple backtracking solution.",
                "codeTag": "Java"
            },
            {
                "id": 15748,
                "title": "sharing-my-2ms-c-solution-with-comments-and-explanations",
                "content": "Update: there's a [follow-up 0ms solution which is even more optimized][1]\\n\\nThis is one of the fastest Sudoku solvers I've ever written. It is compact enough - just 150 lines of C++ code with comments. I thought it'd be interesting to share it, since it combines several techniques like reactive network update propagation and backtracking with very aggressive pruning.\\n\\nThe algorithm is online - it starts with an empty board and as you add numbers to it, it starts solving the Sudoku.\\n\\nUnlike in other solutions where you have bitmasks of allowed/disallowed values per row/column/square, this solution track bitmask for every(!) cell, forming a set of constraints for the allowed values for each particular cell. Once a value is written into a cell, new constraints are immediately propagated to row, column and 3x3 square of the cell. If during this process a value of other cell can be unambiguously deduced - then the value is set, new constraints are propagated, so on.... You can think about this as an implicit reactive network of cells.\\n\\nIf we're lucky (and we'll be lucky for 19 of 20 of Sudokus published in magazines) then Sudoku is solved at the end (or even before!) processing of the input.\\n\\nOtherwise, there will be empty cells which have to be resolved. Algorithm uses backtracking for this purpose. To optimize it, algorithm starts with the cell with the smallest ambiguity. This could be improved even further by using priority queue (but it's not implemented here). Backtracking is more or less standard, however, at each step we guess the number, the reactive update propagation comes back into play and it either quickly proves that the guess is unfeasible or significantly prunes the remaining search space.\\n\\nIt's interesting to note, that in this case taking and restoring snapshots of the compact representation of the state is faster than doing backtracking rollback by \"undoing the moves\".\\n\\n    class Solution {\\n    \\tstruct cell // encapsulates a single cell on a Sudoku board\\n    \\t{\\n    \\t\\tuint8_t value; // cell value 1..9 or 0 if unset\\n    \\t\\t// number of possible (unconstrained) values for the cell\\n    \\t\\tuint8_t numPossibilities;\\n    \\t\\t// if bitset[v] is 1 then value can't be v\\n    \\t\\tbitset<10> constraints;\\n    \\t\\tcell() : value(0), numPossibilities(9),constraints() {};\\n    \\t};\\n    \\tarray<array<cell,9>,9> cells;\\n    \\n    \\t// sets the value of the cell to [v]\\n    \\t// the function also propagates constraints to other cells and deduce new values where possible\\n    \\tbool set(int i, int j, int v)\\n    \\t{ \\n    \\t\\t// updating state of the cell\\n    \\t\\tcell& c = cells[i][j];\\n    \\t\\tif (c.value == v)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (c.constraints[v])\\n    \\t\\t\\treturn false;\\n    \\t\\tc.constraints = bitset<10>(0x3FE); // all 1s\\n    \\t\\tc.constraints.reset(v);\\n    \\t\\tc.numPossibilities = 1;\\n    \\t\\tc.value = v;\\n    \\n    \\t\\t// propagating constraints\\n    \\t\\tfor (int k = 0; k<9; k++) {\\n    \\t\\t\\t// to the row: \\n    \\t\\t\\tif (i != k && !updateConstraints(k, j, v))\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t// to the column:\\n    \\t\\t\\tif (j != k && !updateConstraints(i, k, v))\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t// to the 3x3 square:\\n    \\t\\t\\tint ix = (i / 3) * 3 + k / 3;\\n    \\t\\t\\tint jx = (j / 3) * 3 + k % 3;\\n    \\t\\t\\tif (ix != i && jx != j && !updateConstraints(ix, jx, v))\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    \\t// update constraints of the cell i,j by excluding possibility of 'excludedValue'\\n    \\t// once there's one possibility left the function recurses back into set()\\n    \\tbool updateConstraints(int i, int j, int excludedValue)\\n    \\t{\\n    \\t\\tcell& c = cells[i][j];\\n    \\t\\tif (c.constraints[excludedValue]) {\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\tif (c.value == excludedValue) {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\tc.constraints.set(excludedValue);\\n    \\t\\tif (--c.numPossibilities > 1)\\n    \\t\\t\\treturn true;\\n    \\t\\tfor (int v = 1; v <= 9; v++) {\\n    \\t\\t\\tif (!c.constraints[v]) {\\n    \\t\\t\\t\\treturn set(i, j, v);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tassert(false);\\n    \\t}\\n    \\n    \\t// backtracking state - list of empty cells\\n    \\tvector<pair<int, int>> bt;\\n    \\n    \\t// find values for empty cells\\n    \\tbool findValuesForEmptyCells()\\n    \\t{\\n    \\t\\t// collecting all empty cells\\n    \\t\\tbt.clear();\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tfor (int j = 0; j < 9; j++) {\\n    \\t\\t\\t\\tif (!cells[i][j].value)\\n    \\t\\t\\t\\t\\tbt.push_back(make_pair(i, j));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// making backtracking efficient by pre-sorting empty cells by numPossibilities\\n    \\t\\tsort(bt.begin(), bt.end(), [this](const pair<int, int>&a, const pair<int, int>&b) {\\n    \\t\\t\\treturn cells[a.first][a.second].numPossibilities < cells[b.first][b.second].numPossibilities; });\\n    \\t\\treturn backtrack(0);\\n    \\t}\\n    \\n    \\t// Finds value for all empty cells with index >=k\\n    \\tbool backtrack(int k)\\n    \\t{\\n    \\t\\tif (k >= bt.size())\\n    \\t\\t\\treturn true;\\n    \\t\\tint i = bt[k].first;\\n    \\t\\tint j = bt[k].second;\\n    \\t\\t// fast path - only 1 possibility\\n    \\t\\tif (cells[i][j].value)\\n    \\t\\t\\treturn backtrack(k + 1);\\n    \\t\\tauto constraints = cells[i][j].constraints;\\n    \\t\\t// slow path >1 possibility.\\n    \\t\\t// making snapshot of the state\\n    \\t\\tarray<array<cell,9>,9> snapshot(cells);\\n    \\t\\tfor (int v = 1; v <= 9; v++) {\\n    \\t\\t\\tif (!constraints[v]) {\\n    \\t\\t\\t\\tif (set(i, j, v)) {\\n    \\t\\t\\t\\t\\tif (backtrack(k + 1))\\n    \\t\\t\\t\\t\\t\\treturn true;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\t// restoring from snapshot,\\n    \\t\\t\\t\\t// note: computationally this is cheaper\\n    \\t\\t\\t\\t// than alternative implementation with undoing the changes\\n    \\t\\t\\t\\tcells = snapshot;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    public:\\n    \\tvoid solveSudoku(vector<vector<char>> &board) {\\n    \\t\\tcells = array<array<cell,9>,9>(); // clear array\\n    \\t\\t// Decoding input board into the internal cell matrix.\\n    \\t\\t// As we do it - constraints are propagated and even additional values are set as we go\\n    \\t\\t// (in the case if it is possible to unambiguously deduce them).\\n    \\t\\tfor (int i = 0; i < 9; i++)\\n    \\t\\t{\\n    \\t\\t\\tfor (int j = 0; j < 9; j++) {\\n    \\t\\t\\t\\tif (board[i][j] != '.' && !set(i, j, board[i][j] - '0'))\\n    \\t\\t\\t\\t\\treturn; // sudoku is either incorrect or unsolvable\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t// if we're lucky we've already got a solution,\\n    \\t\\t// however, if we have empty cells we need to use backtracking to fill them\\n    \\t\\tif (!findValuesForEmptyCells())\\n    \\t\\t\\treturn; // sudoku is unsolvable\\n    \\n    \\t\\t// copying the solution back to the board\\n    \\t\\tfor (int i = 0; i < 9; i++)\\n    \\t\\t{\\n    \\t\\t\\tfor (int j = 0; j < 9; j++) {\\n    \\t\\t\\t\\tif (cells[i][j].value)\\n    \\t\\t\\t\\t\\tboard[i][j] = cells[i][j].value + '0';\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/59649/yet-another-0ms-c-solution",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    \\tstruct cell // encapsulates a single cell on a Sudoku board\\n    \\t{\\n    \\t\\tuint8_t value; // cell value 1..9 or 0 if unset\\n    \\t\\t// number of possible (unconstrained) values for the cell\\n    \\t\\tuint8_t numPossibilities;\\n    \\t\\t// if bitset[v] is 1 then value can't be v\\n    \\t\\tbitset<10> constraints;\\n    \\t\\tcell() : value(0), numPossibilities(9),constraints() {}",
                "codeTag": "Java"
            },
            {
                "id": 140837,
                "title": "python-very-simple-backtracking-solution-using-dictionaries-and-queue-100-ms-beats-90",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board):\\n        rows, cols, triples, visit = collections.defaultdict(set), collections.defaultdict(set), collections.defaultdict(set), collections.deque([])\\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] != \".\":\\n                    rows[r].add(board[r][c])\\n                    cols[c].add(board[r][c])\\n                    triples[(r // 3, c // 3)].add(board[r][c])\\n                else:\\n                    visit.append((r, c))\\n        def dfs():\\n            if not visit:\\n                return True\\n            r, c = visit[0]\\n            t = (r // 3, c // 3)\\n            for dig in {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}:\\n                if dig not in rows[r] and dig not in cols[c] and dig not in triples[t]:\\n                    board[r][c] = dig\\n                    rows[r].add(dig)\\n                    cols[c].add(dig)\\n                    triples[t].add(dig)\\n                    visit.popleft()\\n                    if dfs():\\n                        return True\\n                    else:\\n                        board[r][c] = \".\"\\n                        rows[r].discard(dig)\\n                        cols[c].discard(dig)\\n                        triples[t].discard(dig)\\n                        visit.appendleft((r, c))\\n            return False\\n        dfs()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board):\\n        rows, cols, triples, visit = collections.defaultdict(set), collections.defaultdict(set), collections.defaultdict(set), collections.deque([])\\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] != \".\":\\n                    rows[r].add(board[r][c])\\n                    cols[c].add(board[r][c])\\n                    triples[(r // 3, c // 3)].add(board[r][c])\\n                else:\\n                    visit.append((r, c))\\n        def dfs():\\n            if not visit:\\n                return True\\n            r, c = visit[0]\\n            t = (r // 3, c // 3)\\n            for dig in {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}:\\n                if dig not in rows[r] and dig not in cols[c] and dig not in triples[t]:\\n                    board[r][c] = dig\\n                    rows[r].add(dig)\\n                    cols[c].add(dig)\\n                    triples[t].add(dig)\\n                    visit.popleft()\\n                    if dfs():\\n                        return True\\n                    else:\\n                        board[r][c] = \".\"\\n                        rows[r].discard(dig)\\n                        cols[c].discard(dig)\\n                        triples[t].discard(dig)\\n                        visit.appendleft((r, c))\\n            return False\\n        dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417032,
                "title": "c-java-python-backtracking-with-bitmasking-efficient-clean",
                "content": "**Idea**\\n- We use **backtracking to try to fill empty cells** with values in range **[1..9]**.\\n- For a blank cell, we **only fill it with a valid value**, where there are **no duplicates** in the **same row** and **same column**, and the **same box**.\\n- We can use the bitmasking by `rows`, `cols`, `boxes` (which I reused from [36. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/discuss/1414911)) to achieve high performance.\\n\\n<iframe src=\"https://leetcode.com/playground/3PvdeP3E/shared\" frameBorder=\"0\" width=\"100%\" height=\"800\"></iframe>\\n\\n**Complexity**\\n- Time: `O(9^m)`, where `m` is number of empty cells. In the worst case, with each empty cell, we have maximum `9` options. But since the board only have 1 valid solution, so this time complexity is reduced a lot.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**Idea**\\n- We use **backtracking to try to fill empty cells** with values in range **[1..9]**.\\n- For a blank cell, we **only fill it with a valid value**, where there are **no duplicates** in the **same row** and **same column**, and the **same box**.\\n- We can use the bitmasking by `rows`, `cols`, `boxes` (which I reused from [36. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/discuss/1414911)) to achieve high performance.\\n\\n<iframe src=\"https://leetcode.com/playground/3PvdeP3E/shared\" frameBorder=\"0\" width=\"100%\" height=\"800\"></iframe>\\n\\n**Complexity**\\n- Time: `O(9^m)`, where `m` is number of empty cells. In the worst case, with each empty cell, we have maximum `9` options. But since the board only have 1 valid solution, so this time complexity is reduced a lot.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 15911,
                "title": "less-than-30-line-clean-java-solution-using-dfs",
                "content": "Should be very easy to understand.\\n\\n    public class Solution {\\n        public void solveSudoku(char[][] board) {\\n            dfs(board,0);\\n        }\\n        private boolean dfs(char[][] board, int d) {\\n            if (d==81) return true; //found solution\\n            int i=d/9, j=d%9;\\n            if (board[i][j]!='.') return dfs(board,d+1);//prefill number skip\\n            \\n            boolean[] flag=new boolean[10];\\n            validate(board,i,j,flag);\\n            for (int k=1; k<=9; k++) {\\n                if (flag[k]) {\\n                    board[i][j]=(char)('0'+k);\\n                    if (dfs(board,d+1)) return true;\\n                }\\n            }\\n            board[i][j]='.'; //if can not solve, in the wrong path, change back to '.' and out\\n            return false;\\n        }\\n        private void validate(char[][] board, int i, int j, boolean[] flag) {\\n            Arrays.fill(flag,true);\\n            for (int k=0; k<9; k++) {\\n                if (board[i][k]!='.') flag[board[i][k]-'0']=false;\\n                if (board[k][j]!='.') flag[board[k][j]-'0']=false;\\n                int r=i/3*3+k/3;\\n                int c=j/3*3+k%3;\\n                if (board[r][c]!='.') flag[board[r][c]-'0']=false;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        public void solveSudoku(char[][] board) {\\n            dfs(board,0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 537173,
                "title": "simple-and-clean-backtrack",
                "content": "Returning is required because we normally store the result in a vector in question of this type, but since it\\'s a bactracking solution, intial and final states of the board will be same, so to avoid we return and stop it from backtracking after solution is made.\\n```\\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\\n    // row check\\n    for(int i = 0; i < 9; i++) \\n\\t\\tif(board[i][col] == c) \\n\\t\\t\\treturn false;\\n\\t// col check\\n    for(int i = 0; i < 9; i++) \\n\\t\\tif(board[row][i] == c) \\n\\t\\t\\treturn false;\\n    // box check\\n    int x0 = (row/3) * 3, y0 = (col/3) * 3;\\n    for(int i = 0; i < 3; i++) {\\n        for(int j = 0; j < 3; j++) {\\n            if(board[x0 + i][y0 + j] == c) return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nbool helper(vector<vector<char>> &board, int row, int col) {\\n    // done\\n    if(row == 9) \\n\\t\\treturn true;\\n    // time for next row\\n    if(col == 9) \\n\\t\\treturn helper(board, row + 1, 0);\\n    // already marked\\n    if(board[row][col] != \\'.\\') \\n\\t\\treturn helper(board, row, col + 1);\\n\\n    for(char c = \\'1\\'; c <= \\'9\\'; c++) {\\n        if(isValid(board, row, col, c)) {\\n            board[row][col] = c;\\n            // without return here, the board reverts to initial state\\n            if(helper(board, row, col + 1))\\n\\t\\t\\t\\treturn true;\\n            board[row][col] = \\'.\\';\\n        }\\n    }\\n    return false;\\n}\\n\\nvoid solveSudoku(vector<vector<char>>& board) {\\n    helper(board, 0, 0);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\\n    // row check\\n    for(int i = 0; i < 9; i++) \\n\\t\\tif(board[i][col] == c) \\n\\t\\t\\treturn false;\\n\\t// col check\\n    for(int i = 0; i < 9; i++) \\n\\t\\tif(board[row][i] == c) \\n\\t\\t\\treturn false;\\n    // box check\\n    int x0 = (row/3) * 3, y0 = (col/3) * 3;\\n    for(int i = 0; i < 3; i++) {\\n        for(int j = 0; j < 3; j++) {\\n            if(board[x0 + i][y0 + j] == c) return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nbool helper(vector<vector<char>> &board, int row, int col) {\\n    // done\\n    if(row == 9) \\n\\t\\treturn true;\\n    // time for next row\\n    if(col == 9) \\n\\t\\treturn helper(board, row + 1, 0);\\n    // already marked\\n    if(board[row][col] != \\'.\\') \\n\\t\\treturn helper(board, row, col + 1);\\n\\n    for(char c = \\'1\\'; c <= \\'9\\'; c++) {\\n        if(isValid(board, row, col, c)) {\\n            board[row][col] = c;\\n            // without return here, the board reverts to initial state\\n            if(helper(board, row, col + 1))\\n\\t\\t\\t\\treturn true;\\n            board[row][col] = \\'.\\';\\n        }\\n    }\\n    return false;\\n}\\n\\nvoid solveSudoku(vector<vector<char>>& board) {\\n    helper(board, 0, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294215,
                "title": "simple-concise-clear-python-solution",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        assert(self.backtrack(board, 0, 0))\\n        return\\n                    \\n    def backtrack(self, board: List[List[str]], r: int, c: int) -> bool:\\n        # Go to next empty space\\n        while board[r][c] != \\'.\\':\\n            c += 1\\n            if c == 9: c, r = 0, r+1\\n            if r == 9: return True\\n        # Try all options, backtracking if not work\\n        for k in range(1, 10):\\n            if self.isValidSudokuMove(board, r, c, str(k)):\\n                board[r][c] = str(k)\\n                if self.backtrack(board, r, c):\\n                    return True\\n        board[r][c] = \\'.\\'\\n        return False\\n    \\n    def isValidSudokuMove(self, board: List[List[str]], r: int, c: int, cand: int) -> bool:\\n        # Check row\\n        if any(board[r][j] == cand for j in range(9)): return False\\n        # Check col\\n        if any(board[i][c] == cand for i in range(9)): return False\\n        # Check block\\n        br, bc = 3*(r//3), 3*(c//3)\\n        if any(board[i][j] == cand for i in range(br, br+3) for j in range(bc, bc+3)): return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        assert(self.backtrack(board, 0, 0))\\n        return\\n                    \\n    def backtrack(self, board: List[List[str]], r: int, c: int) -> bool:\\n        # Go to next empty space\\n        while board[r][c] != \\'.\\':\\n            c += 1\\n            if c == 9: c, r = 0, r+1\\n            if r == 9: return True\\n        # Try all options, backtracking if not work\\n        for k in range(1, 10):\\n            if self.isValidSudokuMove(board, r, c, str(k)):\\n                board[r][c] = str(k)\\n                if self.backtrack(board, r, c):\\n                    return True\\n        board[r][c] = \\'.\\'\\n        return False\\n    \\n    def isValidSudokuMove(self, board: List[List[str]], r: int, c: int, cand: int) -> bool:\\n        # Check row\\n        if any(board[r][j] == cand for j in range(9)): return False\\n        # Check col\\n        if any(board[i][c] == cand for i in range(9)): return False\\n        # Check block\\n        br, bc = 3*(r//3), 3*(c//3)\\n        if any(board[i][j] == cand for i in range(br, br+3) for j in range(bc, bc+3)): return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947604,
                "title": "python-easiest-recursive-solution",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        n = 9\\n        \\n        \\n        def isValid(row, col, ch):\\n            row, col = int(row), int(col)\\n            \\n            for i in range(9):\\n                \\n                if board[i][col] == ch:\\n                    return False\\n                if board[row][i] == ch:\\n                    return False\\n                \\n                if board[3*(row//3) + i//3][3*(col//3) + i%3] == ch:\\n                    return False\\n            \\n            return True\\n            \\n        def solve(row, col):\\n            if row == n:\\n                return True\\n            if col == n:\\n                return solve(row+1, 0)\\n            \\n            if board[row][col] == \".\":\\n                for i in range(1, 10):\\n                    if isValid(row, col, str(i)):\\n                        board[row][col] = str(i)\\n                        \\n                        if solve(row, col + 1):\\n                            return True\\n                        else:\\n                            board[row][col] = \".\"\\n                return False\\n            else:\\n                return solve(row, col + 1)\\n            \\n            \\n        \\n        solve(0, 0)\\n\\t\\t\\n\\t\\t#do upvote if it helps.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        n = 9\\n        \\n        \\n        def isValid(row, col, ch):\\n            row, col = int(row), int(col)\\n            \\n            for i in range(9):\\n                \\n                if board[i][col] == ch:\\n                    return False\\n                if board[row][i] == ch:\\n                    return False\\n                \\n                if board[3*(row//3) + i//3][3*(col//3) + i%3] == ch:\\n                    return False\\n            \\n            return True\\n            \\n        def solve(row, col):\\n            if row == n:\\n                return True\\n            if col == n:\\n                return solve(row+1, 0)\\n            \\n            if board[row][col] == \".\":\\n                for i in range(1, 10):\\n                    if isValid(row, col, str(i)):\\n                        board[row][col] = str(i)\\n                        \\n                        if solve(row, col + 1):\\n                            return True\\n                        else:\\n                            board[row][col] = \".\"\\n                return False\\n            else:\\n                return solve(row, col + 1)\\n            \\n            \\n        \\n        solve(0, 0)\\n\\t\\t\\n\\t\\t#do upvote if it helps.",
                "codeTag": "Java"
            },
            {
                "id": 3226518,
                "title": "best-c-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question Matrix + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(9^(N*N)) : For every unassigned index there are 9 possible options so the worst-case time complexity of sudoku solver is O(9^(N*N)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant space.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(9^(N*N)) : For every unassigned index there are 9 possible options so the worst-case time\\n    complexity of sudoku solver is O(9^(N*N)).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool isValid(vector<vector<char>>& board, int row, int col, char ch){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] == ch){\\n                return false;\\n            }\\n            if(board[row][i] == ch){\\n                return false;\\n            }\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == ch){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board) {\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch=\\'1\\'; ch<=\\'9\\'; ch++){\\n                        if(isValid(board, i, j, ch)){\\n                            board[i][j] = ch;\\n                            if(solve(board) == true){\\n                                return true;\\n                            }\\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(9^(N*N)) : For every unassigned index there are 9 possible options so the worst-case time\\n    complexity of sudoku solver is O(9^(N*N)).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool isValid(vector<vector<char>>& board, int row, int col, char ch){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] == ch){\\n                return false;\\n            }\\n            if(board[row][i] == ch){\\n                return false;\\n            }\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == ch){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board) {\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch=\\'1\\'; ch<=\\'9\\'; ch++){\\n                        if(isValid(board, i, j, ch)){\\n                            board[i][j] = ch;\\n                            if(solve(board) == true){\\n                                return true;\\n                            }\\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469400,
                "title": "java-easiest-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(9^(n*n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n^2) \\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/cd9232bf-fd92-4a55-bf8d-3b9732e4ca43_1682846131.0732913.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        // Start solving sudoku from the first cell\\n        solve(board, 0, 0);\\n    }\\n\\n    private boolean solve(char[][] board, int row, int col) {\\n        // Base case: If row is equal to board length, entire board has been filled\\n        if (row == board.length) {\\n            return true;\\n        }\\n        \\n        // Move to next row when current row is fully filled\\n        if (col == board[0].length) {\\n            return solve(board, row + 1, 0);\\n        }\\n        \\n        // Skip cells that are already filled\\n        if (board[row][col] != \\'.\\') {\\n            return solve(board, row, col + 1);\\n        }\\n        \\n        // Try different numbers in current cell\\n        for (char num = \\'1\\'; num <= \\'9\\'; num++) {\\n            if (isValidPlacement(board, row, col, num)) {\\n                board[row][col] = num; // Fill current cell with valid number\\n                \\n                // Move to next cell\\n                if (solve(board, row, col + 1)) {\\n                    return true;\\n                }\\n                \\n                // Backtrack to previous state if solution not found\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n        \\n        // No valid solution found\\n        return false;\\n    }\\n\\n    private boolean isValidPlacement(char[][] board, int row, int col, char num) {\\n        // Check if num is already in the same row, column or 3x3 subgrid\\n        for (int i = 0; i < board.length; i++) {\\n            // Check row\\n            if (board[i][col] == num) {\\n                return false;\\n            }\\n\\n            // Check column\\n            if (board[row][i] == num) {\\n                return false;\\n            }\\n \\n            // Check 3x3 subgrid\\n            int subgridRow = 3 * (row / 3) + i / 3; // Calculate row index of subgrid\\n            int subgridCol = 3 * (col / 3) + i % 3; // Calculate column index of subgrid\\n \\n            if (board[subgridRow][subgridCol] == num) {\\n                return false;\\n            }\\n        }\\n\\n        // Placement is valid\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        // Start solving sudoku from the first cell\\n        solve(board, 0, 0);\\n    }\\n\\n    private boolean solve(char[][] board, int row, int col) {\\n        // Base case: If row is equal to board length, entire board has been filled\\n        if (row == board.length) {\\n            return true;\\n        }\\n        \\n        // Move to next row when current row is fully filled\\n        if (col == board[0].length) {\\n            return solve(board, row + 1, 0);\\n        }\\n        \\n        // Skip cells that are already filled\\n        if (board[row][col] != \\'.\\') {\\n            return solve(board, row, col + 1);\\n        }\\n        \\n        // Try different numbers in current cell\\n        for (char num = \\'1\\'; num <= \\'9\\'; num++) {\\n            if (isValidPlacement(board, row, col, num)) {\\n                board[row][col] = num; // Fill current cell with valid number\\n                \\n                // Move to next cell\\n                if (solve(board, row, col + 1)) {\\n                    return true;\\n                }\\n                \\n                // Backtrack to previous state if solution not found\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n        \\n        // No valid solution found\\n        return false;\\n    }\\n\\n    private boolean isValidPlacement(char[][] board, int row, int col, char num) {\\n        // Check if num is already in the same row, column or 3x3 subgrid\\n        for (int i = 0; i < board.length; i++) {\\n            // Check row\\n            if (board[i][col] == num) {\\n                return false;\\n            }\\n\\n            // Check column\\n            if (board[row][i] == num) {\\n                return false;\\n            }\\n \\n            // Check 3x3 subgrid\\n            int subgridRow = 3 * (row / 3) + i / 3; // Calculate row index of subgrid\\n            int subgridCol = 3 * (col / 3) + i % 3; // Calculate column index of subgrid\\n \\n            if (board[subgridRow][subgridCol] == num) {\\n                return false;\\n            }\\n        }\\n\\n        // Placement is valid\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15903,
                "title": "two-very-simple-and-neat-java-dfs-backtracking-solutions",
                "content": "1.The first one uses three `2D-array` to check valid. Running time is about 256-320ms.\\n\\n    private char[][] b;\\n    private boolean[][] row = new boolean[9][9];\\n    private boolean[][] col = new boolean[9][9];\\n    private boolean[][] block = new boolean[9][9];\\n    public void solveSudoku(char[][] board) {\\n        b = board;\\n        int num, k;\\n        for (int i=0; i<9; i++) {\\n            for (int j=0; j<9; j++) {\\n                if(board[i][j]!='.') {\\n                    num = board[i][j]-'1'; \\n                    k = i/3*3 + j/3;\\n                    row[i][num] = col[j][num] = block[k][num] = true;\\n                }\\n            }\\n        }\\n        Helper(0);\\n    }\\n    public boolean Helper(int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9, num, k;\\n        if(b[i][j]!='.') return Helper(ind+1);\\n        else{\\n            for(char f='1'; f<='9'; f++){\\n                num = f-'1'; \\n                k= i/3*3 + j/3;\\n                if(!row[i][num] && !col[j][num] && !block[k][num]){\\n                    b[i][j]= f;\\n                    row[i][num] = col[j][num] = block[k][num] = true;\\n                    if(Helper(ind+1)) return true;                \\n                    b[i][j]='.';\\n                    row[i][num] = col[j][num] = block[k][num] = false;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n2.The second one check with `board itself`. The code is neat and simple. Running time is about 252-332ms. The time difference between these two version is small. But it's huge in [C++ answer][1].\\n\\n    private char[][] b;\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length < 9) return;\\n        b = board;\\n        solve(0);\\n    }\\n    public boolean solve(int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9;\\n        if(b[i][j]!='.') return solve(ind+1);\\n        else{\\n            for(char f = '1'; f <= '9'; f++){\\n                if(isValidFill(i, j, f)){\\n                    b[i][j]= f;\\n                    if(solve(ind+1)) return true;                \\n                    b[i][j]='.';\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n    public boolean isValidFill(int i, int j, char fill){\\n        for(int k=0; k<9; k++){\\n            int r= i/3*3+j/3;   //select the block\\n            if(b[i][k]==fill || b[k][j]==fill || b[r/3*3+k/3][r%3*3+k%3]==fill) \\n                return false; //check row, column, block\\n        }            \\n        return true;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/51303/two-very-simple-and-neat-c-dfs-backtracking-solutions",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "1.The first one uses three `2D-array` to check valid. Running time is about 256-320ms.\\n\\n    private char[][] b;\\n    private boolean[][] row = new boolean[9][9];\\n    private boolean[][] col = new boolean[9][9];\\n    private boolean[][] block = new boolean[9][9];\\n    public void solveSudoku(char[][] board) {\\n        b = board;\\n        int num, k;\\n        for (int i=0; i<9; i++) {\\n            for (int j=0; j<9; j++) {\\n                if(board[i][j]!='.') {\\n                    num = board[i][j]-'1'; \\n                    k = i/3*3 + j/3;\\n                    row[i][num] = col[j][num] = block[k][num] = true;\\n                }\\n            }\\n        }\\n        Helper(0);\\n    }\\n    public boolean Helper(int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9, num, k;\\n        if(b[i][j]!='.') return Helper(ind+1);\\n        else{\\n            for(char f='1'; f<='9'; f++){\\n                num = f-'1'; \\n                k= i/3*3 + j/3;\\n                if(!row[i][num] && !col[j][num] && !block[k][num]){\\n                    b[i][j]= f;\\n                    row[i][num] = col[j][num] = block[k][num] = true;\\n                    if(Helper(ind+1)) return true;                \\n                    b[i][j]='.';\\n                    row[i][num] = col[j][num] = block[k][num] = false;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n2.The second one check with `board itself`. The code is neat and simple. Running time is about 252-332ms. The time difference between these two version is small. But it's huge in [C++ answer][1].\\n\\n    private char[][] b;\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length < 9) return;\\n        b = board;\\n        solve(0);\\n    }\\n    public boolean solve(int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9;\\n        if(b[i][j]!='.') return solve(ind+1);\\n        else{\\n            for(char f = '1'; f <= '9'; f++){\\n                if(isValidFill(i, j, f)){\\n                    b[i][j]= f;\\n                    if(solve(ind+1)) return true;                \\n                    b[i][j]='.';\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n    public boolean isValidFill(int i, int j, char fill){\\n        for(int k=0; k<9; k++){\\n            int r= i/3*3+j/3;   //select the block\\n            if(b[i][k]==fill || b[k][j]==fill || b[r/3*3+k/3][r%3*3+k%3]==fill) \\n                return false; //check row, column, block\\n        }            \\n        return true;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/51303/two-very-simple-and-neat-c-dfs-backtracking-solutions",
                "codeTag": "Unknown"
            },
            {
                "id": 1351806,
                "title": "solution-swift-sudoku-solver",
                "content": "```swift\\nclass Solution {\\n    internal typealias Char = Character\\n    func solveSudoku(_ board: inout [[Char]]) {\\n        guard board.count != 0 || board[0].count != 0 else { return }\\n        helper(&board)\\n    }\\n    \\n    private func helper(_ board: inout [[Char]]) -> Bool {\\n        for r in 0..<board.count {\\n            for c in 0..<board[0].count where board[r][c] == \".\" {\\n                for n in 1...9 where isValid(board, Char(\"\\\\(n)\"), r, c) {\\n                    board[r][c] = Char(\"\\\\(n)\")\\n                    if helper(&board) {\\n                        return true\\n                    } else {\\n                        board[r][c] = \".\"\\n                    }\\n                }\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n\\t\\n\\t// Special thanks to @punk9595 for the optimization suggestion \\n    private func isValid(_ board: [[Char]], _ ch: Char, _ r: Int,  _ c: Int) -> Bool {\\n        for i in 0...8 {\\n            if board[r][i] == ch || board[i][c] == ch { return false }\\n            if board[(r / 3) * 3 + i / 3][(c / 3) * 3 + i % 3] == ch { return false }\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 1 test, with 0 failures (0 unexpected) in 0.265 (0.267) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        var arrChars: [[Character]] = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                       [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                       [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                       [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                       [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                       [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                       [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                       [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                       [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n        solution.solveSudoku(&arrChars)\\n        XCTAssertEqual(arrChars, [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],\\n                                  [\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],\\n                                  [\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\\n                                  [\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\\n                                  [\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\\n                                  [\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],\\n                                  [\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\\n                                  [\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\\n                                  [\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n\\n<br>\\n\\n<details>\\n<summary><b>My past solution</b></summary>\\n\\n```swift\\nclass Solution {\\n    func solveSudoku(_ board: inout [[Character]]) {\\n        guard board.count != 0 || board[0].count != 0 else { return }\\n        helper(&board)\\n    }\\n    \\n    private func helper(_ board: inout [[Character]]) -> Bool {\\n        func isValid(_ i: Int, _ j: Int, _ num: Character) -> Bool {\\n            let m = board.count, n = board[0].count\\n            // row\\n            for x in 0..<n where board[i][x] == num { return false }\\n            // col\\n            for y in 0..<m where board[y][j] == num { return false }\\n            // square\\n            for x in i / 3 * 3..<i / 3 * 3 + 3 {\\n                for y in j / 3 * 3..<j / 3 * 3 + 3 where board[x][y] == num { return false }\\n            }\\n            return true\\n        }\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count where board[i][j] == \".\" {\\n                for num in 1...9 where isValid(i, j, Character(\"\\\\(num)\")) {\\n                    board[i][j] = Character(\"\\\\(num)\")\\n                    if helper(&board) {\\n                        return true\\n                    } else {\\n                        board[i][j] = \".\"\\n                    }\\n                }\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    internal typealias Char = Character\\n    func solveSudoku(_ board: inout [[Char]]) {\\n        guard board.count != 0 || board[0].count != 0 else { return }\\n        helper(&board)\\n    }\\n    \\n    private func helper(_ board: inout [[Char]]) -> Bool {\\n        for r in 0..<board.count {\\n            for c in 0..<board[0].count where board[r][c] == \".\" {\\n                for n in 1...9 where isValid(board, Char(\"\\\\(n)\"), r, c) {\\n                    board[r][c] = Char(\"\\\\(n)\")\\n                    if helper(&board) {\\n                        return true\\n                    } else {\\n                        board[r][c] = \".\"\\n                    }\\n                }\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n\\t\\n\\t// Special thanks to @punk9595 for the optimization suggestion \\n    private func isValid(_ board: [[Char]], _ ch: Char, _ r: Int,  _ c: Int) -> Bool {\\n        for i in 0...8 {\\n            if board[r][i] == ch || board[i][c] == ch { return false }\\n            if board[(r / 3) * 3 + i / 3][(c / 3) * 3 + i % 3] == ch { return false }\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        var arrChars: [[Character]] = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                       [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                       [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                       [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                       [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                       [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                       [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                       [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                       [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n        solution.solveSudoku(&arrChars)\\n        XCTAssertEqual(arrChars, [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],\\n                                  [\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],\\n                                  [\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\\n                                  [\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\\n                                  [\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\\n                                  [\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],\\n                                  [\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\\n                                  [\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\\n                                  [\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\nclass Solution {\\n    func solveSudoku(_ board: inout [[Character]]) {\\n        guard board.count != 0 || board[0].count != 0 else { return }\\n        helper(&board)\\n    }\\n    \\n    private func helper(_ board: inout [[Character]]) -> Bool {\\n        func isValid(_ i: Int, _ j: Int, _ num: Character) -> Bool {\\n            let m = board.count, n = board[0].count\\n            // row\\n            for x in 0..<n where board[i][x] == num { return false }\\n            // col\\n            for y in 0..<m where board[y][j] == num { return false }\\n            // square\\n            for x in i / 3 * 3..<i / 3 * 3 + 3 {\\n                for y in j / 3 * 3..<j / 3 * 3 + 3 where board[x][y] == num { return false }\\n            }\\n            return true\\n        }\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count where board[i][j] == \".\" {\\n                for num in 1...9 where isValid(i, j, Character(\"\\\\(num)\")) {\\n                    board[i][j] = Character(\"\\\\(num)\")\\n                    if helper(&board) {\\n                        return true\\n                    } else {\\n                        board[i][j] = \".\"\\n                    }\\n                }\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100767,
                "title": "java-5ms-backtracking-solution-using-dfs-with-line-by-line-explanation",
                "content": "This solution avoids for loops; instead we just check each box one by one and iterate to the next value. Very simple and intuitive, something you can come up with on an interview.\\n\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        // We are going to need to edit our sudoku board\\n        solve(board, 0, 0);\\n    }\\n\\n    public boolean solve(char[][] board, int row, int col) {\\n        // If the col is 9, that means you\\'ve filled out a whole row. Start the search on the next row by resetting column and incrementing the row by 1\\n        if (col == board[0].length) {\\n            col = 0;\\n            row += 1;\\n        }\\n        // If you\\'ve reached 9, that means you didn\\'t run into any errors with your blocks in the previous rows, so you have a valid solution\\n        if (row == board.length) {\\n            return true; \\n        }\\n        // If this piece already has a value, check the next square\\n        if (board[row][col] != \\'.\\') return solve(board, row, col+1);\\n        // We want to try every number for this block\\n        for (char num = \\'1\\'; num <= \\'9\\'; num++) {\\n            // Self explanatory, don\\'t run this if the number isn\\'t a valid answer\\n            if (checkIfValid(board, row, col, num)) {\\n                // Set the value of the current square to the valid num\\n                board[row][col] = num;\\n                // Run this algo for the next square over\\n                boolean solved = solve(board, row, col+1);\\n                // The only way we can trigger a true is if we got to the end, so if it\\'s true that means we have a solved board so you just keep returning\\n                if (solved) return true;\\n                // If our board isn\\'t solved, backtrack and try the next number\\n                else board[row][col] = \\'.\\';\\n            }\\n        }\\n        // You get this when every value of the board is filled, because you don\\'t run anything on it\\n        // If you get to this step, that means that no values fit, which means the current iteration of the board is wrong so return false and try the previous step again with a different value\\n        return false;\\n    }\\n\\n    public boolean checkIfValid(char[][] board, int row, int col, char value) {\\n        for (int i = 0; i < board.length; i++) {\\n            // Check the column for duplicates\\n            if (board[i][col] == value) return false; \\n            // Check the row for duplicates\\n            if (board[row][i] == value) return false;\\n        }\\n        // This generates our \"box\", for [1, 1] for example, this pair will be the box bound by [0, 2] and [0,2]\\n        int boxRow = row / 3;\\n        int boxCol = col / 3;\\n        for (int i = boxRow * 3; i < (boxRow + 1) * 3; i++) {\\n            for (int j = boxCol * 3; j < (boxCol + 1) * 3; j++) {\\n                // Check the box for duplicates\\n                if (board[i][j] == value) return false;\\n            }\\n        }\\n\\t\\t// There are no falses, therefore this is a valid number to put on the square\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public void solveSudoku(char[][] board) {\\n        // We are going to need to edit our sudoku board\\n        solve(board, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 15892,
                "title": "a-simple-dfs-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n    \\tbool isValidSudoku(vector<vector<char> > &board) {\\n    \\t\\treturn true;\\n    \\t}\\n    \\tvoid solveSudoku(vector<vector<char> > &board) {\\n    \\t\\tutil(board, 0);\\n    \\t}\\n    \\tbool util(vector<vector<char>>& board, int pos)\\n    \\t{\\n    \\t\\tif (pos >= 81)\\n    \\t\\t\\treturn true;\\n    \\t\\tint i = pos / 9;\\n    \\t\\tint j = pos % 9;\\n    \\t\\tif (board[i][j] != '.')\\n    \\t\\t\\treturn util(board, pos + 1);\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tfor (char c = '1'; c <= '9'; c++)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tif (!isInRow(board, i,c) && !isInCol(board, j, c) && !isInRec(board, i, j, c))\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tboard[i][j] = c;\\n    \\t\\t\\t\\t\\tif (util(board, pos + 1))\\n    \\t\\t\\t\\t\\t\\treturn true;\\n    \\t\\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\t\\tboard[i][j] = '.';\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tbool isInRow(vector<vector<char>>& board, int i, char c)\\n    \\t{\\n    \\t\\tvector<char>& row = board[i];\\n    \\t\\tfor (int k = 0; k < 9; k++)\\n    \\t\\t{\\n    \\t\\t\\tif (row[k] == c)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    \\tbool isInCol(vector<vector<char>>& board,int j, char c)\\n    \\t{\\n    \\t\\tfor (int k = 0; k < 9; k++)\\n    \\t\\t{\\n    \\t\\t\\tif (board[k][j] == c)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    \\tbool isInRec(vector<vector<char>>& board, int i, int j, char c)\\n    \\t{\\n    \\t\\tint bigrow = i / 3, bigcol = j / 3;\\n    \\t\\tfor (int m = 3 * bigrow; m < 3 * (bigrow + 1); m++)\\n    \\t\\t{\\n    \\t\\t\\tfor (int n = 3 * bigcol; n < 3 * (bigcol + 1); n++)\\n    \\t\\t\\t\\tif (board[m][n] == c)\\n    \\t\\t\\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool isValidSudoku(vector<vector<char> > &board) {\\n    \\t\\treturn true;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1417073,
                "title": "97-faster-clean-concise-well-explained",
                "content": "## IDEA:\\n*The simple idea here is to fill a position and take the updated board as the new board and check if this new board has a possible solution.\\nIf there is no valid solution for our new board we revert back to our previous state of the board and try by filling the next possible solution.*\\n\\nChecking if a value is valid in the respective empty slot:\\nBefore intialising a value to our empty spot we need to check if that value is valid at that spot. For that we should check three cases:\\n1) If value is already present in the row\\n2) If value is already presnt in the column\\n3) If value is already presnt in the smaller(3*3)box .(This is a bit tricky)\\n\\n****\\nFeel free to ask and get your answer within 24hrs if you have any doubts. \\uD83E\\uDD16\\n**Upvote** if you got any help !! \\uD83E\\uDD1E\\n****\\n\\n\\'\\'\\'\\n\\n\\tfrom collections import defaultdict,deque\\n\\tclass Solution:\\n\\t\\tdef solveSudoku(self, board: List[List[str]]) -> None:\\n        \\n        rows,cols,block,seen = defaultdict(set),defaultdict(set),defaultdict(set),deque([])\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j]!=\".\":\\n                    rows[i].add(board[i][j])\\n                    cols[j].add(board[i][j])\\n                    block[(i//3,j//3)].add(board[i][j])\\n                else:\\n                    seen.append((i,j))\\n        \\n        def dfs():\\n            if not seen:\\n                return True\\n            \\n            r,c = seen[0]\\n            t = (r//3,c//3)\\n            for n in {\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\'}:\\n                if n not in rows[r] and n not in cols[c] and n not in block[t]:\\n                    board[r][c]=n\\n                    rows[r].add(n)\\n                    cols[c].add(n)\\n                    block[t].add(n)\\n                    seen.popleft()\\n                    if dfs():\\n                        return True\\n                    else:\\n                        board[r][c]=\".\"\\n                        rows[r].discard(n)\\n                        cols[c].discard(n)\\n                        block[t].discard(n)\\n                        seen.appendleft((r,c))\\n            return False\\n        \\n        dfs()\\n\\n### Thanks \\uD83E\\uDD17",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n\\t\\tdef solveSudoku(self, board: List[List[str]]) -> None:\\n        \\n        rows,cols,block,seen = defaultdict(set),defaultdict(set),defaultdict(set),deque([])\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j]!=\".\":\\n                    rows[i].add(board[i][j])\\n                    cols[j].add(board[i][j])\\n                    block[(i//3,j//3)].add(board[i][j])\\n                else:\\n                    seen.append((i,j))\\n        \\n        def dfs():\\n            if not seen:\\n                return True\\n            \\n            r,c = seen[0]\\n            t = (r//3,c//3)\\n            for n in {\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\'}",
                "codeTag": "Java"
            },
            {
                "id": 15759,
                "title": "48ms-straitforward-python-dfs-solution-with-explanations",
                "content": "It's similar to how human solve Sudoku. <br>\\n1. create a hash table (dictionary) `val` to store possible values in every location.<br>\\n2. Each time, start from the location with fewest possible values, choose one value from it and then update the board and possible values at other locations. If this update is valid, keep solving (DFS). If this update is invalid (leaving zero possible values at some locations) or this value doesn't lead to the solution, undo the updates and then choose the next value. <br>\\n\\nSince we calculated `val` at the beginning and start filling the board from the location with fewest possible values, the amount of calculation and thus the runtime can be significantly reduced: <br><br>\\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest python solutions here.<br><br>\\nThe `PossibleVals` function may be further simplified/optimized, but it works just fine for now. (it would look less lengthy if we are allowed to use numpy array for the board lol). <br>\\n\\n<br>\\n\\n    def solveSudoku(self, board):\\n        self.board = board\\n        self.val = self.PossibleVals()\\n        self.Solver()\\n\\n    def PossibleVals(self):\\n        a = \"123456789\"\\n        d, val = {}, {}\\n        for i in xrange(9):\\n            for j in xrange(9):\\n                ele = self.board[i][j]\\n                if ele != \".\":\\n                    d[(\"r\", i)] = d.get((\"r\", i), []) + [ele]\\n                    d[(\"c\", j)] = d.get((\"c\", j), []) + [ele]\\n                    d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele]\\n                else:\\n                    val[(i,j)] = []\\n        for (i,j) in val.keys():\\n            inval = d.get((\"r\",i),[])+d.get((\"c\",j),[])+d.get((i/3,j/3),[])\\n            val[(i,j)] = [n for n in a if n not in inval ]\\n        return val\\n\\n    def Solver(self):\\n        if len(self.val)==0:\\n            return True\\n        kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\\n        nums = self.val[kee]\\n        for n in nums:\\n            update = {kee:self.val[kee]}\\n            if self.ValidOne(n, kee, update): # valid choice\\n                if self.Solver(): # keep solving\\n                    return True\\n            self.undo(kee, update) # invalid choice or didn't solve it => undo\\n        return False\\n        \\n    def ValidOne(self, n, kee, update):\\n        self.board[kee[0]][kee[1]] = n\\n        del self.val[kee]\\n        i, j = kee\\n        for ind in self.val.keys():\\n            if n in self.val[ind]:\\n                if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3):\\n                    update[ind] = n\\n                    self.val[ind].remove(n)\\n                    if len(self.val[ind])==0:\\n                        return False\\n        return True\\n\\n    def undo(self, kee, update):\\n        self.board[kee[0]][kee[1]]=\".\"\\n        for k in update:            \\n            if k not in self.val:\\n                self.val[k]= update[k]\\n            else:\\n                self.val[k].append(update[k])\\n        return None",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "It's similar to how human solve Sudoku. <br>\\n1. create a hash table (dictionary) `val` to store possible values in every location.<br>\\n2. Each time, start from the location with fewest possible values, choose one value from it and then update the board and possible values at other locations. If this update is valid, keep solving (DFS). If this update is invalid (leaving zero possible values at some locations) or this value doesn't lead to the solution, undo the updates and then choose the next value. <br>\\n\\nSince we calculated `val` at the beginning and start filling the board from the location with fewest possible values, the amount of calculation and thus the runtime can be significantly reduced: <br><br>\\nThe run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest python solutions here.<br><br>\\nThe `PossibleVals` function may be further simplified/optimized, but it works just fine for now. (it would look less lengthy if we are allowed to use numpy array for the board lol). <br>\\n\\n<br>\\n\\n    def solveSudoku(self, board):\\n        self.board = board\\n        self.val = self.PossibleVals()\\n        self.Solver()\\n\\n    def PossibleVals(self):\\n        a = \"123456789\"\\n        d, val = {}, {}\\n        for i in xrange(9):\\n            for j in xrange(9):\\n                ele = self.board[i][j]\\n                if ele != \".\":\\n                    d[(\"r\", i)] = d.get((\"r\", i), []) + [ele]\\n                    d[(\"c\", j)] = d.get((\"c\", j), []) + [ele]\\n                    d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele]\\n                else:\\n                    val[(i,j)] = []\\n        for (i,j) in val.keys():\\n            inval = d.get((\"r\",i),[])+d.get((\"c\",j),[])+d.get((i/3,j/3),[])\\n            val[(i,j)] = [n for n in a if n not in inval ]\\n        return val\\n\\n    def Solver(self):\\n        if len(self.val)==0:\\n            return True\\n        kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\\n        nums = self.val[kee]\\n        for n in nums:\\n            update = {kee:self.val[kee]}\\n            if self.ValidOne(n, kee, update): # valid choice\\n                if self.Solver(): # keep solving\\n                    return True\\n            self.undo(kee, update) # invalid choice or didn't solve it => undo\\n        return False\\n        \\n    def ValidOne(self, n, kee, update):\\n        self.board[kee[0]][kee[1]] = n\\n        del self.val[kee]\\n        i, j = kee\\n        for ind in self.val.keys():\\n            if n in self.val[ind]:\\n                if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3):\\n                    update[ind] = n\\n                    self.val[ind].remove(n)\\n                    if len(self.val[ind])==0:\\n                        return False\\n        return True\\n\\n    def undo(self, kee, update):\\n        self.board[kee[0]][kee[1]]=\".\"\\n        for k in update:            \\n            if k not in self.val:\\n                self.val[k]= update[k]\\n            else:\\n                self.val[k].append(update[k])\\n        return None",
                "codeTag": "Python3"
            },
            {
                "id": 2104660,
                "title": "c-solution-with-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here for every empty position, we\\u2019ll try every char from 1 to 9 & check if the char is valid for that position.\\n- We\\u2019re using the bool function ***solve***, where at any moment we get a possible solution it will return the function without checking the following possible solutions. And if there\\u2019s no solution, it\\u2019ll simply backtrack & remove the element.\\n- Before putting any char we\\u2019ll check if that is valid for the position using the ***valid*** function. There are 3 things to check:\\n    1. Check the row: `if(board[i][col] == c) return false;`\\n    2. Check the column:  `if(board[row][i] == c) return false;`\\n    3. Check 3*3 matrix: `if(board[3*(row/3)+(i/3)][3*(col/3)+(i%3)] == c) return false;`\\n        \\n     ![image](https://assets.leetcode.com/users/images/26a4cc8d-75d1-458a-90a5-3c2dcae59451_1654229477.9858193.jpeg)\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n    \\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c=\\'1\\'; c<=\\'9\\'; c++){\\n                        if(valid(c, board, i, j)){\\n                            board[i][j] = c;\\n                            if(solve(board) == true) return true;\\n                            else board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool valid(char c, vector<vector<char>>& board, int row, int col){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] == c) return false;\\n            if(board[row][i] == c) return false;\\n            if(board[3*(row/3)+(i/3)][3*(col/3)+(i%3)] == c) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n    \\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c=\\'1\\'; c<=\\'9\\'; c++){\\n                        if(valid(c, board, i, j)){\\n                            board[i][j] = c;\\n                            if(solve(board) == true) return true;\\n                            else board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool valid(char c, vector<vector<char>>& board, int row, int col){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] == c) return false;\\n            if(board[row][i] == c) return false;\\n            if(board[3*(row/3)+(i/3)][3*(col/3)+(i%3)] == c) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513192,
                "title": "java-tc-o-9-n-sc-o-n-most-optimized-backtracking-solution-using-bit-manipulation",
                "content": "```java\\n/**\\n * Most Optimized Backtracking solution using Bit Manipulation\\n *\\n * Time Complexity: T(N) = 9 * T(N-1) + O(9) ==> TC = (9^N). Also, O(9*9) is\\n * required for checking validity and finding blanks.\\n *\\n * Space Complexity: O(3*9 + 2*N). 3*9 for rows, cols and boxes int array. N for\\n * blanks list. N will be the recursion depth.\\n *\\n * N = Number of blank spaces. In worst case it can be 9*9 = 81.\\n */\\nclass Solution1 {\\n    public void solveSudoku(char[][] board) {\\n        if (board == null || board.length != 9 || board[0].length != 9) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int[] rows = new int[9];\\n        int[] cols = new int[9];\\n        int[] boxes = new int[9];\\n        List<int[]> blanks = new ArrayList<>();\\n\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char c = board[i][j];\\n                // To Blanks List\\n                if (c == \\'.\\') {\\n                    blanks.add(new int[] { i, j });\\n                    continue;\\n                }\\n\\n                // Check for Invalid Chars\\n                if (c < \\'1\\' || c > \\'9\\') {\\n                    throw new IllegalArgumentException(\"Invalid sudoku board\");\\n                }\\n\\n                int b = 3 * (i / 3) + (j / 3);\\n                int mask = 1 << (c - \\'1\\');\\n\\n                // Check for unsolvable board\\n                if (((rows[i] & mask) != 0) || ((cols[j] & mask) != 0) || ((boxes[b] & mask) != 0)) {\\n                    throw new IllegalArgumentException(\"Invalid sudoku board\");\\n                }\\n\\n                // Add the cell to rows, cols and boxes.\\n                rows[i] |= mask;\\n                cols[j] |= mask;\\n                boxes[b] |= mask;\\n            }\\n        }\\n\\n        if (!solveSudokuHelper(board, rows, cols, boxes, blanks, 0)) {\\n            throw new RuntimeException(\"Input sudoku does not have a valid solution\");\\n        }\\n    }\\n\\n    private boolean solveSudokuHelper(char[][] board, int[] rows, int[] cols, int[] boxes, List<int[]> blanks,\\n            int idx) {\\n        if (idx == blanks.size()) {\\n            return true;\\n        }\\n\\n        int[] cell = blanks.get(idx);\\n        int i = cell[0];\\n        int j = cell[1];\\n        int b = 3 * (i / 3) + (j / 3);\\n\\n        for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            int mask = 1 << (c - \\'1\\');\\n\\n            // Check if the number already used in row, column and sub-box.\\n            if (((rows[i] & mask) != 0) || ((cols[j] & mask) != 0) || ((boxes[b] & mask) != 0)) {\\n                continue;\\n            }\\n\\n            // Add the cell to rows, cols and boxes.\\n            rows[i] |= mask;\\n            cols[j] |= mask;\\n            boxes[b] |= mask;\\n            board[i][j] = c;\\n\\n            if (solveSudokuHelper(board, rows, cols, boxes, blanks, idx + 1)) {\\n                return true;\\n            }\\n\\n            // Backtrack\\n            // Remove the cell to rows, cols and boxes.\\n            rows[i] &= ~mask;\\n            cols[j] &= ~mask;\\n            boxes[b] &= ~mask;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Sudoku question on LeetCode:\\n- [36. Valid Sudoku](https://leetcode.com/problems/valid-sudoku/discuss/1513191/Java-or-TC:-O(9*9)-or-SC:-O(1)-or-Most-Optimized-solution-using-Bit-Manipulation)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Bit Manipulation",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Most Optimized Backtracking solution using Bit Manipulation\\n *\\n * Time Complexity: T(N) = 9 * T(N-1) + O(9) ==> TC = (9^N). Also, O(9*9) is\\n * required for checking validity and finding blanks.\\n *\\n * Space Complexity: O(3*9 + 2*N). 3*9 for rows, cols and boxes int array. N for\\n * blanks list. N will be the recursion depth.\\n *\\n * N = Number of blank spaces. In worst case it can be 9*9 = 81.\\n */\\nclass Solution1 {\\n    public void solveSudoku(char[][] board) {\\n        if (board == null || board.length != 9 || board[0].length != 9) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int[] rows = new int[9];\\n        int[] cols = new int[9];\\n        int[] boxes = new int[9];\\n        List<int[]> blanks = new ArrayList<>();\\n\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char c = board[i][j];\\n                // To Blanks List\\n                if (c == \\'.\\') {\\n                    blanks.add(new int[] { i, j });\\n                    continue;\\n                }\\n\\n                // Check for Invalid Chars\\n                if (c < \\'1\\' || c > \\'9\\') {\\n                    throw new IllegalArgumentException(\"Invalid sudoku board\");\\n                }\\n\\n                int b = 3 * (i / 3) + (j / 3);\\n                int mask = 1 << (c - \\'1\\');\\n\\n                // Check for unsolvable board\\n                if (((rows[i] & mask) != 0) || ((cols[j] & mask) != 0) || ((boxes[b] & mask) != 0)) {\\n                    throw new IllegalArgumentException(\"Invalid sudoku board\");\\n                }\\n\\n                // Add the cell to rows, cols and boxes.\\n                rows[i] |= mask;\\n                cols[j] |= mask;\\n                boxes[b] |= mask;\\n            }\\n        }\\n\\n        if (!solveSudokuHelper(board, rows, cols, boxes, blanks, 0)) {\\n            throw new RuntimeException(\"Input sudoku does not have a valid solution\");\\n        }\\n    }\\n\\n    private boolean solveSudokuHelper(char[][] board, int[] rows, int[] cols, int[] boxes, List<int[]> blanks,\\n            int idx) {\\n        if (idx == blanks.size()) {\\n            return true;\\n        }\\n\\n        int[] cell = blanks.get(idx);\\n        int i = cell[0];\\n        int j = cell[1];\\n        int b = 3 * (i / 3) + (j / 3);\\n\\n        for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            int mask = 1 << (c - \\'1\\');\\n\\n            // Check if the number already used in row, column and sub-box.\\n            if (((rows[i] & mask) != 0) || ((cols[j] & mask) != 0) || ((boxes[b] & mask) != 0)) {\\n                continue;\\n            }\\n\\n            // Add the cell to rows, cols and boxes.\\n            rows[i] |= mask;\\n            cols[j] |= mask;\\n            boxes[b] |= mask;\\n            board[i][j] = c;\\n\\n            if (solveSudokuHelper(board, rows, cols, boxes, blanks, idx + 1)) {\\n                return true;\\n            }\\n\\n            // Backtrack\\n            // Remove the cell to rows, cols and boxes.\\n            rows[i] &= ~mask;\\n            cols[j] &= ~mask;\\n            boxes[b] &= ~mask;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15904,
                "title": "c-clear-solution-using-dfs-beating-90-c-coder",
                "content": "    class Solution {\\n    public:\\n        bool col[10][10],row[10][10],f[10][10];\\n        bool flag = false;\\n        void solveSudoku(vector<vector<char>>& board) {\\n             memset(col,false,sizeof(col));\\n             memset(row,false,sizeof(row));\\n             memset(f,false,sizeof(f));\\n             for(int i = 0; i < 9;i++){\\n                 for(int j = 0; j < 9;j++){\\n                     if(board[i][j] == '.')   continue;\\n                     int temp = 3*(i/3)+j/3;\\n                     int num = board[i][j]-'0';\\n                     col[j][num] = row[i][num] = f[temp][num] = true;\\n                 }\\n             }\\n             dfs(board,0,0);\\n        }\\n        void dfs(vector<vector<char>>& board,int i,int j){\\n            if(flag == true)  return ;\\n            if(i >= 9){\\n                flag = true;\\n                return ;\\n            }\\n            if(board[i][j] != '.'){\\n                 if(j < 8)  dfs(board,i,j+1);\\n                 else dfs(board,i+1,0);\\n                 if(flag)  return;\\n            }\\n            \\n            else{\\n                int temp = 3*(i/3)+j/3;\\n                for(int n = 1; n <= 9; n++){\\n                    if(!col[j][n] && !row[i][n] && !f[temp][n]){\\n                        board[i][j] = n + '0';\\n                        col[j][n] = row[i][n] = f[temp][n] = true;\\n                        if(j < 8)  dfs(board,i,j+1);\\n                        else dfs(board,i+1,0);\\n                        col[j][n] = row[i][n] = f[temp][n] = false;\\n                        if(flag)  return;\\n                    }\\n                }\\n                board[i][j] = '.';\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        bool col[10][10],row[10][10],f[10][10];\\n        bool flag = false;\\n        void solveSudoku(vector<vector<char>>& board) {\\n             memset(col,false,sizeof(col));\\n             memset(row,false,sizeof(row));\\n             memset(f,false,sizeof(f));\\n             for(int i = 0; i < 9;i++){\\n                 for(int j = 0; j < 9;j++){\\n                     if(board[i][j] == '.')   continue;\\n                     int temp = 3*(i/3)+j/3;\\n                     int num = board[i][j]-'0';\\n                     col[j][num] = row[i][num] = f[temp][num] = true;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 988304,
                "title": "concise-javascript-dfs-with-line-by-line-explanation",
                "content": "```\\nfunction solveSudoku(board) {\\n  const n = board.length;\\n  dfs(board, n);\\n}\\n\\nfunction dfs(board, n) {\\n  // for every cell in the sudoku\\n  for (let row = 0; row < n; row++) {\\n    for (let col = 0; col < n; col++) {\\n      // if its empty\\n      if (board[row][col] !== \\'.\\') continue;\\n      // try every number 1-9\\n      for (let i = 1; i <= 9; i++) {\\n        const c = i.toString();\\n        // if that number is valid\\n        if (isValid(board, row, col, n, c)) {\\n          board[row][col] = c;\\n          // continue search for that board, ret true if solution is reached\\n          if (dfs(board, n)) return true;\\n        }\\n      }\\n      // solution wasnt found for any num 1-9 here, must be a dead end...\\n      // set the current cell back to empty\\n      board[row][col] = \\'.\\';\\n      // ret false to signal dead end \\n      return false;\\n    }\\n  }\\n  // all cells filled, must be a solution\\n  return true;\\n}\\n\\nfunction isValid(board, row, col, n, c) {\\n  const blockRow = Math.floor(row / 3) * 3;\\n  const blockCol = Math.floor(col / 3) * 3;\\n  for (let i = 0; i < n; i++) {\\n    if (board[row][i] === c || board[i][col] === c) return false;\\n    const curRow = blockRow +  Math.floor(i / 3);\\n    const curCol = blockCol +  Math.floor(i % 3);\\n    if (board[curRow][curCol] === c) return false;\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nfunction solveSudoku(board) {\\n  const n = board.length;\\n  dfs(board, n);\\n}\\n\\nfunction dfs(board, n) {\\n  // for every cell in the sudoku\\n  for (let row = 0; row < n; row++) {\\n    for (let col = 0; col < n; col++) {\\n      // if its empty\\n      if (board[row][col] !== \\'.\\') continue;\\n      // try every number 1-9\\n      for (let i = 1; i <= 9; i++) {\\n        const c = i.toString();\\n        // if that number is valid\\n        if (isValid(board, row, col, n, c)) {\\n          board[row][col] = c;\\n          // continue search for that board, ret true if solution is reached\\n          if (dfs(board, n)) return true;\\n        }\\n      }\\n      // solution wasnt found for any num 1-9 here, must be a dead end...\\n      // set the current cell back to empty\\n      board[row][col] = \\'.\\';\\n      // ret false to signal dead end \\n      return false;\\n    }\\n  }\\n  // all cells filled, must be a solution\\n  return true;\\n}\\n\\nfunction isValid(board, row, col, n, c) {\\n  const blockRow = Math.floor(row / 3) * 3;\\n  const blockCol = Math.floor(col / 3) * 3;\\n  for (let i = 0; i < n; i++) {\\n    if (board[row][i] === c || board[i][col] === c) return false;\\n    const curRow = blockRow +  Math.floor(i / 3);\\n    const curCol = blockCol +  Math.floor(i % 3);\\n    if (board[curRow][curCol] === c) return false;\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298365,
                "title": "fast-python-3-solution-with-comments-40ms-faster-than-99-51",
                "content": "Result on LeetCode:\\n* Runtime: 40 ms, faster than 99.51% of Python3 online submissions for Sudoku Solver.\\n* Memory Usage: 13.1 MB, less than 65.46% of Python3 online submissions for Sudoku Solver.\\n\\nAlgorithm: backtracking (dfs) in an optimal order\\n1. Keep track of candidates of each cell.\\n2. Find the cell with fewest candidates. Fill the cell with one of the candidates. Update the candidates of other cells.\\n3. Repeat step 2 until solved. Or if the board is not solvable anymore (there\\'s any cell that is empty but has no candidates), undo step 2 and try the next candidate.\\n\\n```python\\nclass Solution:\\n    col_size = 9  # len(self.board)\\n    row_size = 9  # len(self.board[0])\\n    block_col_size = 3\\n    block_row_size = 3\\n    digits = \\'123456789\\'\\n    empty_symbol = \\'.\\'\\n\\n    # def solveSudoku(self, board: List[List[str]]) -> None:\\n    def solveSudoku(self, board):\\n        self.init(board)\\n        self.solve()\\n\\n    def init(self, board):\\n        self.board = board\\n\\n        # list all empty cells. a `cell` is a tuple `(row_index, col_index)`\\n        self.empty_cells = set([(ri, ci) for ri in range(self.row_size) for ci in range(self.col_size) if self.board[ri][ci] == self.empty_symbol])\\n\\n        # find candidates of each cell\\n        self.candidates = [[set(self.digits) for ci in range(self.col_size)] for ri in range(self.row_size)]\\n        for ri in range(self.row_size):\\n            for ci in range(self.col_size):\\n                digit = self.board[ri][ci]\\n                if digit != self.empty_symbol:\\n                    self.candidates[ri][ci] = set()\\n                    self.update_candidates((ri, ci), digit)\\n\\n    def solve(self):\\n        # if there are no empty cells, it\\'s solved\\n        if not self.empty_cells:\\n            return True\\n\\n        # get the cell with fewest candidates\\n        cell = min(self.empty_cells, key=lambda cell: len(self.candidates[cell[0]][cell[1]]))\\n\\n        # try filling the cell with one of the candidates, and solve recursively\\n        ri, ci = cell\\n        for digit in list(self.candidates[ri][ci]):\\n            candidate_updated_cells = self.fill_cell(cell, digit)\\n            solved = self.solve()\\n            if solved:\\n                return True\\n            self.unfill_cell(cell, digit, candidate_updated_cells)\\n\\n        # if no solution found, go back and try the next candidates\\n        return False\\n\\n    def fill_cell(self, cell, digit):\\n        # fill the cell with the digit\\n        ri, ci = cell\\n        self.board[ri][ci] = digit\\n\\n        # remove the cell from empty_cells\\n        self.empty_cells.remove(cell)\\n\\n        # update the candidates of other cells\\n        # keep a list of updated cells. will be used when unfilling cells\\n        candidate_updated_cells = self.update_candidates(cell, digit)\\n\\n        return candidate_updated_cells\\n\\n    def unfill_cell(self, cell, digit, candidate_updated_cells):\\n        # unfill cell\\n        ri, ci = cell\\n        self.board[ri][ci] = self.empty_symbol\\n\\n        # add the cell back to empty_cells\\n        self.empty_cells.add(cell)\\n\\n        # add back candidates of other cells\\n        for ri, ci in candidate_updated_cells:\\n            self.candidates[ri][ci].add(digit)\\n\\n    def update_candidates(self, filled_cell, digit):\\n        candidate_updated_cells = []\\n        for ri, ci in self.related_cells(filled_cell):\\n            if (self.board[ri][ci] == self.empty_symbol) and (digit in self.candidates[ri][ci]):\\n                self.candidates[ri][ci].remove(digit)\\n                candidate_updated_cells.append((ri, ci))\\n        return candidate_updated_cells\\n\\n    def related_cells(self, cell):\\n        return list(set(self.cells_in_same_row(cell) + self.cells_in_same_col(cell) + self.cells_in_same_block(cell)))\\n\\n    def cells_in_same_row(self, cell):\\n        return [(cell[0], ci) for ci in range(self.col_size)]\\n\\n    def cells_in_same_col(self, cell):\\n        return [(ri, cell[1]) for ri in range(self.row_size)]\\n\\n    def cells_in_same_block(self, cell):\\n        block_first_cell_ri = (cell[0] // self.block_row_size) * self.block_row_size\\n        block_first_cell_ci = (cell[1] // self.block_col_size) * self.block_col_size\\n        return [\\n            (block_first_cell_ri + in_block_ri, block_first_cell_ci + in_block_ci)\\n            for in_block_ri in range(self.block_row_size)\\n            for in_block_ci in range(self.block_col_size)\\n        ]\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    col_size = 9  # len(self.board)\\n    row_size = 9  # len(self.board[0])\\n    block_col_size = 3\\n    block_row_size = 3\\n    digits = \\'123456789\\'\\n    empty_symbol = \\'.\\'\\n\\n    # def solveSudoku(self, board: List[List[str]]) -> None:\\n    def solveSudoku(self, board):\\n        self.init(board)\\n        self.solve()\\n\\n    def init(self, board):\\n        self.board = board\\n\\n        # list all empty cells. a `cell` is a tuple `(row_index, col_index)`\\n        self.empty_cells = set([(ri, ci) for ri in range(self.row_size) for ci in range(self.col_size) if self.board[ri][ci] == self.empty_symbol])\\n\\n        # find candidates of each cell\\n        self.candidates = [[set(self.digits) for ci in range(self.col_size)] for ri in range(self.row_size)]\\n        for ri in range(self.row_size):\\n            for ci in range(self.col_size):\\n                digit = self.board[ri][ci]\\n                if digit != self.empty_symbol:\\n                    self.candidates[ri][ci] = set()\\n                    self.update_candidates((ri, ci), digit)\\n\\n    def solve(self):\\n        # if there are no empty cells, it\\'s solved\\n        if not self.empty_cells:\\n            return True\\n\\n        # get the cell with fewest candidates\\n        cell = min(self.empty_cells, key=lambda cell: len(self.candidates[cell[0]][cell[1]]))\\n\\n        # try filling the cell with one of the candidates, and solve recursively\\n        ri, ci = cell\\n        for digit in list(self.candidates[ri][ci]):\\n            candidate_updated_cells = self.fill_cell(cell, digit)\\n            solved = self.solve()\\n            if solved:\\n                return True\\n            self.unfill_cell(cell, digit, candidate_updated_cells)\\n\\n        # if no solution found, go back and try the next candidates\\n        return False\\n\\n    def fill_cell(self, cell, digit):\\n        # fill the cell with the digit\\n        ri, ci = cell\\n        self.board[ri][ci] = digit\\n\\n        # remove the cell from empty_cells\\n        self.empty_cells.remove(cell)\\n\\n        # update the candidates of other cells\\n        # keep a list of updated cells. will be used when unfilling cells\\n        candidate_updated_cells = self.update_candidates(cell, digit)\\n\\n        return candidate_updated_cells\\n\\n    def unfill_cell(self, cell, digit, candidate_updated_cells):\\n        # unfill cell\\n        ri, ci = cell\\n        self.board[ri][ci] = self.empty_symbol\\n\\n        # add the cell back to empty_cells\\n        self.empty_cells.add(cell)\\n\\n        # add back candidates of other cells\\n        for ri, ci in candidate_updated_cells:\\n            self.candidates[ri][ci].add(digit)\\n\\n    def update_candidates(self, filled_cell, digit):\\n        candidate_updated_cells = []\\n        for ri, ci in self.related_cells(filled_cell):\\n            if (self.board[ri][ci] == self.empty_symbol) and (digit in self.candidates[ri][ci]):\\n                self.candidates[ri][ci].remove(digit)\\n                candidate_updated_cells.append((ri, ci))\\n        return candidate_updated_cells\\n\\n    def related_cells(self, cell):\\n        return list(set(self.cells_in_same_row(cell) + self.cells_in_same_col(cell) + self.cells_in_same_block(cell)))\\n\\n    def cells_in_same_row(self, cell):\\n        return [(cell[0], ci) for ci in range(self.col_size)]\\n\\n    def cells_in_same_col(self, cell):\\n        return [(ri, cell[1]) for ri in range(self.row_size)]\\n\\n    def cells_in_same_block(self, cell):\\n        block_first_cell_ri = (cell[0] // self.block_row_size) * self.block_row_size\\n        block_first_cell_ci = (cell[1] // self.block_col_size) * self.block_col_size\\n        return [\\n            (block_first_cell_ri + in_block_ri, block_first_cell_ci + in_block_ci)\\n            for in_block_ri in range(self.block_row_size)\\n            for in_block_ci in range(self.block_col_size)\\n        ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866333,
                "title": "python-backtracking-hashmaps-sets-complexity-explanation",
                "content": "My solution is below. The intuition and complexity analysis follow.\\n\\n```python\\n\\ndef __init__(self):\\n\\tself.size = 9\\n\\t\\n\\tself.sudoku_values = {\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'}\\n\\tself.empty = \\'.\\'\\n\\t\\n\\tself.row_no = lambda cell_no: cell_no // self.size # Get row from cell. no\\n    self.col_no = lambda cell_no: cell_no % self.size  # Get col from cell. no\\n\\tself.box_no = lambda r, c: 3 * (r // 3) + c // 3   # Get box from row and column\\n\\t\\n\\tself.rows_values = {}  # {row: sudoku values set}\\n\\tself.cols_values = {}  # {col: sudoku values set}\\n\\tself.boxs_values = {}  # {box: sudoku values set}\\n\\ndef solveSudoku(self, board: List[List[str]]) -> None:\\n\\t\\n\\t# 1. Initialization: Store all board values\\n\\tfor i in range(self.size):\\n\\t\\tself.rows_values[i] = set()\\n\\t\\tself.cols_values[i] = set()\\n\\t\\tself.boxs_values[i] = set()\\n\\n\\tfor r in range(self.size):\\n\\t\\tfor c in range(self.size):\\n\\t\\t\\tif board[r][c] != self.empty:\\n\\t\\t\\t\\tself.rows_values[r].add(board[r][c])\\n                self.cols_values[c].add(board[r][c])\\n                self.boxs_values[self.box_no(r, c)].add(board[r][c])\\n\\t\\n\\t# 2. Backtrack from cell no: 0\\n\\tself.backtrack(0, board)\\n\\n\\treturn board\\n\\ndef backtrack(self, cell_no, board):\\n\\t# Base case: we filled all empty cells\\n\\tif cell_no == 81: \\n\\t\\treturn True\\n\\n\\tr, c = self.row_no(cell_no), self.col_no(cell_no)\\n\\n\\tif board[r][c] != self.empty:\\n\\t\\treturn self.backtrack(cell_no + 1, board)\\n\\n\\tfor val in self.sudoku_values:\\n\\t\\t# could_place? Is valid?\\n\\t\\tif val in self.rows_values[r] or val in self.cols_values[c] or val in self.boxs_values[self.box_no(r, c)]:\\n\\t\\t\\tcontinue\\n\\n\\t\\t# place:\\n\\t\\tboard[r][c] = val\\n\\t\\tself.rows_values[r].add(val)\\n\\t\\tself.cols_values[c].add(val)\\n\\t\\tself.boxs_values[self.box_no(r, c)].add(val)\\n\\t\\t\\n\\t\\t# next:\\n\\t\\tif self.backtrack(cell_no + 1, board):\\n\\t\\t\\treturn True\\n\\n\\t\\t# remove:\\n\\t\\tboard[r][c] = self.empty\\n\\t\\tself.rows_values[r].remove(val)\\n\\t\\tself.cols_values[c].remove(val)\\n\\t\\tself.boxs_values[self.box_no(r, c)].remove(val)\\n\\n\\treturn False\\n\\t\\t\\n```\\n\\nIntuition:\\n\\n- To use Backtracking since we need to try multiple combinations of values.\\n- To Store filled values in 3 dictionaries of sets: \\n\\t- `rows: {row_no: values set}`\\n\\t- `columns: {col_no: values set}`\\n\\t- `boxes: {box_no: values set}`\\n\\t- `box_no = 3 * (r // 3) + c // 3`\\n- To use cell. no to identify cells (see below):\\n\\t- This make simple passing to a next cell: `next cell = curr cell + 1`\\n\\t- `col = curr cell % 9`\\n\\t- `row = curr cell // 9`\\n\\t\\t\\n\\t\\t\\tCell No:\\n            ---------------------------------------\\n            | 0   1   2 |  3   4   5 |  6   7   8 |\\n            | 9  10  11 | 12  13  14 | 15  16  17 |\\n            |18  19  20 | 21  22  23 | 24  25  26 |\\n            |-----------|------------|------------|\\n            |27  28  29 | 30  31  32 | 33  34  35 |\\n            |36  37  38 | 39  40  41 | 42  43  44 |\\n            |45  46  47 | 48  49  50 | 51  52  53 |\\n            |-----------|------------|------------|\\n            |54  55  56 | 57  58  59 | 60  61  62 |\\n            |63  64  65 | 66  67  68 | 69  70  71 |\\n            |72  73  74 | 75  76  77 | 78  79  80 |\\n            ---------------------------------------\\n\\nComplexity Analysis:\\n- Time Complexity: O(9! * 8! * 7! * 6! * 5! * 4! * 3! * 2! * 1!) = O((9!)^9) = O(1)\\n- Space Complexity: O(81) = O(1) (recursion depth)\\n-",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\n\\ndef __init__(self):\\n\\tself.size = 9\\n\\t\\n\\tself.sudoku_values = {\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'}\\n\\tself.empty = \\'.\\'\\n\\t\\n\\tself.row_no = lambda cell_no: cell_no // self.size # Get row from cell. no\\n    self.col_no = lambda cell_no: cell_no % self.size  # Get col from cell. no\\n\\tself.box_no = lambda r, c: 3 * (r // 3) + c // 3   # Get box from row and column\\n\\t\\n\\tself.rows_values = {}  # {row: sudoku values set}\\n\\tself.cols_values = {}  # {col: sudoku values set}\\n\\tself.boxs_values = {}  # {box: sudoku values set}\\n\\ndef solveSudoku(self, board: List[List[str]]) -> None:\\n\\t\\n\\t# 1. Initialization: Store all board values\\n\\tfor i in range(self.size):\\n\\t\\tself.rows_values[i] = set()\\n\\t\\tself.cols_values[i] = set()\\n\\t\\tself.boxs_values[i] = set()\\n\\n\\tfor r in range(self.size):\\n\\t\\tfor c in range(self.size):\\n\\t\\t\\tif board[r][c] != self.empty:\\n\\t\\t\\t\\tself.rows_values[r].add(board[r][c])\\n                self.cols_values[c].add(board[r][c])\\n                self.boxs_values[self.box_no(r, c)].add(board[r][c])\\n\\t\\n\\t# 2. Backtrack from cell no: 0\\n\\tself.backtrack(0, board)\\n\\n\\treturn board\\n\\ndef backtrack(self, cell_no, board):\\n\\t# Base case: we filled all empty cells\\n\\tif cell_no == 81: \\n\\t\\treturn True\\n\\n\\tr, c = self.row_no(cell_no), self.col_no(cell_no)\\n\\n\\tif board[r][c] != self.empty:\\n\\t\\treturn self.backtrack(cell_no + 1, board)\\n\\n\\tfor val in self.sudoku_values:\\n\\t\\t# could_place? Is valid?\\n\\t\\tif val in self.rows_values[r] or val in self.cols_values[c] or val in self.boxs_values[self.box_no(r, c)]:\\n\\t\\t\\tcontinue\\n\\n\\t\\t# place:\\n\\t\\tboard[r][c] = val\\n\\t\\tself.rows_values[r].add(val)\\n\\t\\tself.cols_values[c].add(val)\\n\\t\\tself.boxs_values[self.box_no(r, c)].add(val)\\n\\t\\t\\n\\t\\t# next:\\n\\t\\tif self.backtrack(cell_no + 1, board):\\n\\t\\t\\treturn True\\n\\n\\t\\t# remove:\\n\\t\\tboard[r][c] = self.empty\\n\\t\\tself.rows_values[r].remove(val)\\n\\t\\tself.cols_values[c].remove(val)\\n\\t\\tself.boxs_values[self.box_no(r, c)].remove(val)\\n\\n\\treturn False\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 15806,
                "title": "yet-another-0ms-c-solution",
                "content": "This is an extension of my [previous 2ms solution posted earlier][1].\\n\\nIt is much faster than pure DFS/Backtracking, since it primarily relies on reactive constraint propagation and uses backtracking only as a fallback. This aspect of the algorithm remains unchanged. See the link above for more detailed description.\\n\\nThe new version posted here, uses the same algorithm, but optimized with the help of moderately-crazy bithacks and modulo-n arithmetic tricks to speedup some things.\\n\\n    class Solution {\\n        // Table which allows compute the value of the cell\\n        // from the unambiguous bit mask as maskToValue[(mask%11)-1] \\n        // uses the fact that (1<<i)%11 is unique for i = [0..8] and never produces 0\\n        const char maskToValue[10] = {'1','2','9','3','5','6','8','4','7','6'};\\n        struct SudokuSolver {\\n            // Using mask for each cell which constraints values which can be in the cell\\n            // Yeap, it is more storage, comparing to rows/cols/sqrs approach\\n            // but it allows to do super-fast reactive constraint propagation\\n            array<array<uint16_t,9>,9> board;\\n            SudokuSolver()\\n            {\\n                // Initializing the board with mask, which permits all numbers\\n                for (int i=0; i<9; i++)\\n                    for (int j=0; j<9; j++)\\n                        board[i][j] = 0x1ff;\\n            }\\n            \\n            // adds value v [1..9] to the board, return false if it violates constraints\\n            bool add(int i, int j, int v)\\n            {\\n                return set(i, j, 1<<(v-1));\\n            }\\n    \\n            // set a value mask to the cell (i,j) and reactively updates constraints\\n            bool set(int i, int j, uint16_t mask)\\n            {\\n                int16_t prev = board[i][j];\\n                if (prev == mask) return true;\\n                if (!(prev&mask)) return false;\\n                board[i][j] = mask;\\n                return propagate(i,j,mask);\\n            }\\n            \\n            // propagates constraints as a result of setting i,j to mask\\n            bool propagate(int i, int j, uint16_t mask)\\n            {\\n                for (int k=0; k<9; k++) {\\n                    if (k!=j && !addConstraint(i, k, mask)) return false;\\n                    if (k!=i && !addConstraint(k, j, mask)) return false;\\n                    int ii = (i/3)*3 + (k/3);\\n                    int jj = (j/3)*3 + (k%3);\\n                    if ((i != ii || j != jj) && !addConstraint(ii, jj, mask)) return false;\\n                }\\n                return true;\\n            }\\n            \\n            // prohibits putting value in mask to the cell (i,j)\\n            bool addConstraint(int i, int j, uint16_t mask)\\n            {\\n                int16_t newMask = board[i][j] &~ mask;\\n                if (newMask != board[i][j]) {\\n                    if (newMask == 0) return false;\\n                    board[i][j] = newMask;\\n                    if (((newMask-1)&newMask)==0) {\\n                        // good news - we have only one possibility for the cell (i,j)\\n                        return propagate(i, j, newMask);\\n                    }\\n                }\\n                return true;\\n            }\\n            \\n            // list of cell coordinates with >1 possibilities for values\\n            vector<pair<int,int>> v;\\n            void solve()\\n            {\\n                // finding all ambiguous cells\\n                for (int i=0; i<9; i++) {\\n                    for (int j=0; j<9; j++) {\\n                        uint16_t mask = board[i][j];\\n                        if (mask&(mask-1)) v.push_back(make_pair(i,j));\\n                    }\\n                }\\n                // note: it is also a good idea to sort v by the hamming weight, but\\n                // without sorting it is still super-fast\\n                // running backtracking as is\\n                backtrack(0);\\n            }\\n    \\n            // backtracking        \\n            bool backtrack(int k) {\\n                if (k == v.size()) return true;\\n                int i = v[k].first;\\n                int j = v[k].second;\\n                uint16_t mask = board[i][j];\\n                if (mask&(mask-1)) {\\n                    // the board state is so compact and backtracking depth is so shallow, so\\n                    // it is cheaper to make a snapshot of the state vs. doing classical\\n                    // undo at each move\\n                    auto snapshot = board;\\n                    for (uint16_t cand = 1; cand<=0x1ff; cand = cand <<1) {\\n                        if (set(i, j, cand) && backtrack(k+1)) return true;\\n                        board = snapshot;\\n                    }\\n                    return false;\\n                }\\n                else {\\n                    return backtrack(k + 1);\\n                }\\n            }\\n            \\n        };\\n        \\n    public:\\n        void solveSudoku(vector<vector<char>>& board) {\\n            SudokuSolver solver;\\n            for (int i=0; i<9; i++) {\\n                for (int j=0; j<9; j++) {\\n                    char c = board[i][j];\\n                    if (c != '.' && !solver.add(i,j,c-'0')) return;\\n                }\\n            }\\n            // At this point 9 of 10 sudokus published in magazines will be solved by constraint propagation\\n            // only 'hard' sudokus will require some (limited) backtracking \\n            solver.solve();\\n            for (int i=0; i<9; i++)\\n                for (int j=0; j<9; j++)\\n                    board[i][j] = maskToValue[(solver.board[i][j]%11)-1];\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/21452/sharing-my-2ms-c-solution-with-comments-and-explanations?show=21452#q21452",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        // Table which allows compute the value of the cell\\n        // from the unambiguous bit mask as maskToValue[(mask%11)-1] \\n        // uses the fact that (1<<i)%11 is unique for i = [0..8] and never produces 0\\n        const char maskToValue[10] = {'1','2','9','3','5','6','8','4','7','6'}",
                "codeTag": "Java"
            },
            {
                "id": 3343447,
                "title": "easy-c-solution-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis problem is classical example of recursion + backtracking to find \\nbest possible solution.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need to place digits according to the rule of sudoku solver \\ni.e Rule1:each row should only consist unique digits ranging from 0-9\\n Rule2:each coloumn should only consist unique digits ranging from 0-9\\nRule 3 : Each smaller 3*3 matrix should also contain unique digits ranging from 1 to 9.\\n\\nNow , first we need to traverse in each row to find whether the element is empty or allready filled.\\nwe can use use nested for loops for traversing the element od this matrix.\\n int n=board.size();\\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<n;j++){\\n                //checking for empty cell\\n                if(board[i][j]==\\'.\\'){\\n                    now run a loop for possible values ranging from 1-9 to assign the value to elemnts of board[i][j];\\nfor further clarity you can see the solution code.\\n                        now we need to check is the assigned value safe to assign or not .\\n\\nhere we check the safety by making another function isSafe.\\nafter checking Safety we will make a recursive call to find the next solution,\\nif it is succesfull then we will return true ,but if not then we have to make bactracting step to correct the possible mistake done before.\\n\\n\\nHope it this explanation helps you little bit in understanding the approach.\\n\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/8d3e5ed9-008e-493b-a8b5-d96029921226_1679827780.1769168.webp)\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(9^(NN)) : For every unassigned index there are 9 possible options so the worst-case time complexity of sudoku solver is O(9^(NN)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nit uses O(1)constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isSafe(int row, int col, vector<vector<char>>& board, char val){\\n        int n=board.size();\\n        for(int i=0; i<n; i++){\\n            //row check\\n            if(board[row][i]==val){\\n                return false;\\n            }\\n            //col check\\n            if(board[i][col]==val){\\n                return false;\\n            }\\n            //3*3 small matrix check\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==val){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>>& board){\\n        int n=board.size();\\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<n;j++){\\n                //checking for empty cell\\n                if(board[i][j]==\\'.\\'){\\n                    //now each empty cell can be filled with 1 to 9 digits, \\n //So lets check them one by one.\\n                    for(char val=\\'1\\'; val<=\\'9\\';val++){\\n                        //checking is the value which we are trying  to put int board[i][j]\\n                        //is valid or not according to rule\\n                        //here basically we are checking the specified rule\\n                        //calling isSafe function\\n                        if(isSafe(i, j, board,val)){\\n                            board[i][j]=val;\\n                            //recursive call\\n                            //recursive call to find next solution\\n                            bool aageKaSolution=solve(board);\\n                            if(aageKaSolution==true){\\n                                return true;\\n                            }\\n                            else{\\n                            //backtracking\\n                            board[i][j]=\\'.\\';\\n                            }\\n\\n                        }\\n                    }\\n                    //if 1 to 9 tak koi bhi solution nhi nikala, current cell pr \\n                    //that means ki piche kahi wrong value put ho gyi hai \\n                    //therefore go back by returning false\\n                    return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isSafe(int row, int col, vector<vector<char>>& board, char val){\\n        int n=board.size();\\n        for(int i=0; i<n; i++){\\n            //row check\\n            if(board[row][i]==val){\\n                return false;\\n            }\\n            //col check\\n            if(board[i][col]==val){\\n                return false;\\n            }\\n            //3*3 small matrix check\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==val){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>>& board){\\n        int n=board.size();\\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<n;j++){\\n                //checking for empty cell\\n                if(board[i][j]==\\'.\\'){\\n                    //now each empty cell can be filled with 1 to 9 digits, \\n //So lets check them one by one.\\n                    for(char val=\\'1\\'; val<=\\'9\\';val++){\\n                        //checking is the value which we are trying  to put int board[i][j]\\n                        //is valid or not according to rule\\n                        //here basically we are checking the specified rule\\n                        //calling isSafe function\\n                        if(isSafe(i, j, board,val)){\\n                            board[i][j]=val;\\n                            //recursive call\\n                            //recursive call to find next solution\\n                            bool aageKaSolution=solve(board);\\n                            if(aageKaSolution==true){\\n                                return true;\\n                            }\\n                            else{\\n                            //backtracking\\n                            board[i][j]=\\'.\\';\\n                            }\\n\\n                        }\\n                    }\\n                    //if 1 to 9 tak koi bhi solution nhi nikala, current cell pr \\n                    //that means ki piche kahi wrong value put ho gyi hai \\n                    //therefore go back by returning false\\n                    return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372506,
                "title": "c-simple-short-and-clean-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        backtrack(board);\\n    }\\n    \\n    bool backtrack(vector<vector<char>>& board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') {\\n                    \\n                    // Try each number, if canPlace - go on with recursion\\n                    for (char num = \\'1\\'; num <= \\'9\\'; num++) {\\n                        \\n                        if (canPlace(board, i, j, num)) {\\n                            board[i][j] = num;\\n                            if (backtrack(board)) \\n                                return true;\\n                            \\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    \\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool canPlace(vector<vector<char>>& board, int i, int j, char num) {\\n        for (int idx = 0; idx < 9; idx++) {\\n            \\n            if (board[i][idx] == num) return false;\\n            if (board[idx][j] == num) return false;\\n            if (board[(i/3)*3 + (idx/3)][(j/3)*3 + (idx%3)] == num) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        backtrack(board);\\n    }\\n    \\n    bool backtrack(vector<vector<char>>& board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') {\\n                    \\n                    // Try each number, if canPlace - go on with recursion\\n                    for (char num = \\'1\\'; num <= \\'9\\'; num++) {\\n                        \\n                        if (canPlace(board, i, j, num)) {\\n                            board[i][j] = num;\\n                            if (backtrack(board)) \\n                                return true;\\n                            \\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    \\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool canPlace(vector<vector<char>>& board, int i, int j, char num) {\\n        for (int idx = 0; idx < 9; idx++) {\\n            \\n            if (board[i][idx] == num) return false;\\n            if (board[idx][j] == num) return false;\\n            if (board[(i/3)*3 + (idx/3)][(j/3)*3 + (idx%3)] == num) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450514,
                "title": "c-easy-to-understand-fast-and-efficient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int row,int col,vector<vector<char>>& board,char c)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            if(board[row][i]==c)\\n                return false;\\n            if(board[i][col]==c)\\n                return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board)\\n    {\\n         for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==\\'.\\')\\n                {\\n                    for(char c=\\'1\\';c<=\\'9\\';c++)\\n                    {\\n                        if(isValid(i,j,board,c))\\n                        {\\n                            board[i][j]=c;\\n                            if(solve(board))\\n                             return true;\\n                            else\\n                            board[i][j]=\\'.\\';  \\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n     solve(board);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int row,int col,vector<vector<char>>& board,char c)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            if(board[row][i]==c)\\n                return false;\\n            if(board[i][col]==c)\\n                return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board)\\n    {\\n         for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==\\'.\\')\\n                {\\n                    for(char c=\\'1\\';c<=\\'9\\';c++)\\n                    {\\n                        if(isValid(i,j,board,c))\\n                        {\\n                            board[i][j]=c;\\n                            if(solve(board))\\n                             return true;\\n                            else\\n                            board[i][j]=\\'.\\';  \\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n     solve(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416914,
                "title": "python-backtracking-solution-explained",
                "content": "The idea here is to use `dfs(board, empty, rows, cols, boxes)` function, where:\\n1. `board` is current board we have.\\n2. `empty` is list of empty cells.\\n3. `rows` is defaultict, where for each of `9` rows we have set of values we have in this row, similar logic for `cols` and `boxes`.\\n    \\nWhat we do in our dfs backtracking algorithm is to choose any empty cell, and then try to put some number in this cell from the numbers we did not have on the same row, column or box, and run dfs with new arguments:\\n\\n1. We look at `row[r]`, `cols[c]` and `boxes[3*(r//3)+c//3]`, and remove this elements from `set(\"123456789\")`\\n2. Make `board[r][c] = k`.\\n3. Add `k` to corresponding row, column and box.\\n4. Run `dfs` recursively and if we found solution, return `True`.\\n5. Delete `k` from corresponding row, column and box.\\n\\n#### Complexity\\nTime complexity of one dfs step is `O(1)`, because we actually need to check row, column and box. However it is difficult to estimate overall complexity of algorithm - I think it is exponential at least. Space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:    \\n    def solveSudoku(self, board):\\n        def dfs(board, empty, rows, cols, boxes):\\n            if not empty: return True\\n            r, c = empty[-1]\\n            for k in set(\"123456789\") - (rows[r]|cols[c]|boxes[3*(r//3)+c//3]):\\n                board[r][c] = k\\n                for dic in [rows[r], cols[c], boxes[3*(r//3)+c//3]]:\\n                    dic.add(k)\\n                if dfs(board, empty[:-1], rows, cols, boxes): return True\\n                board[r][c] = \\'.\\'\\n                for dic in [rows[r], cols[c], boxes[3*(r//3)+c//3]]:\\n                    dic.remove(k)\\n\\n            return False\\n        \\n        cols, rows, boxes, empty = defaultdict(set), defaultdict(set), defaultdict(set), []\\n        for r, c in product(range(9), range(9)):\\n            if board[r][c] == \".\":\\n                empty.append((r,c))\\n            else:\\n                for dic in [rows[r], cols[c], boxes[3*(r//3)+c//3]]:\\n                    dic.add(board[r][c])\\n               \\n        dfs(board, empty, rows, cols, boxes)\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:    \\n    def solveSudoku(self, board):\\n        def dfs(board, empty, rows, cols, boxes):\\n            if not empty: return True\\n            r, c = empty[-1]\\n            for k in set(\"123456789\") - (rows[r]|cols[c]|boxes[3*(r//3)+c//3]):\\n                board[r][c] = k\\n                for dic in [rows[r], cols[c], boxes[3*(r//3)+c//3]]:\\n                    dic.add(k)\\n                if dfs(board, empty[:-1], rows, cols, boxes): return True\\n                board[r][c] = \\'.\\'\\n                for dic in [rows[r], cols[c], boxes[3*(r//3)+c//3]]:\\n                    dic.remove(k)\\n\\n            return False\\n        \\n        cols, rows, boxes, empty = defaultdict(set), defaultdict(set), defaultdict(set), []\\n        for r, c in product(range(9), range(9)):\\n            if board[r][c] == \".\":\\n                empty.append((r,c))\\n            else:\\n                for dic in [rows[r], cols[c], boxes[3*(r//3)+c//3]]:\\n                    dic.add(board[r][c])\\n               \\n        dfs(board, empty, rows, cols, boxes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416935,
                "title": "sudoku-solver-easy-understanding-c-java-python",
                "content": "**IDEA**\\nWe are checking `1-9` through each cell.\\nComplexity- `9^n` (m is the number of blank cells to be filled in)\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\n    public:\\n        void solveSudoku(vector<vector<char>>& board) {\\n            solve(board , 0 , 0);\\n        }\\n    private:\\n        bool solve(vector<vector<char>>& board , int i , int j) {\\n            if(i == 9 && j == 0) \\n                return true;\\n            if(board[i][j] != \\'.\\') \\n                return solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1);\\n\\n            for(char num = \\'1\\'; num <= \\'9\\'; num++) {\\n                if(isValid(board, i, j, num)){\\n                    board[i][j] = num;\\n                    if(solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1)) \\n                        return true;\\n                    board[i][j] = \\'.\\';\\n                }\\n            }\\n            return false;\\n        }\\n        bool isValid(vector<vector<char>>& board, int r, int c, char d) {\\n            int allrow = 3 * (r / 3);\\n            int allcol = 3 * (c / 3);\\n            for (int i = 0; i < 9; i++) {\\n                if (board[i][c] == d) \\n                    return false; //check row\\n                if (board[r][i] == d) \\n                    return false; //check column\\n                if (board[allrow + i / 3][allcol + i % 3] == d) \\n                    return false; //check 3*3 block\\n            }\\n            return true;\\n        }\\n    };\\n```\\n`In JAVA`\\n```\\npublic class Solution {\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0)\\n            return ;\\n        solve(board , 0 , 0);\\n    }\\n    \\n     public boolean solve(char[][] board, int i, int j) {\\n        if(i == 9 && j == 0) return true;\\n        if(board[i][j] != \\'.\\') \\n            return solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1);\\n        \\n        for(char num = \\'1\\'; num <= \\'9\\'; num++) {\\n            if(isValid(board, i, j, num)){\\n                board[i][j] = num;\\n                if(solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1)) \\n                    return true;\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n     private boolean isValid(char[][] board, int row, int col, char c){\\n        int allrow = 3 * (row / 3);\\n        int allcol = 3 * (col / 3);\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == c) \\n                return false; //check row\\n            if (board[row][i] == c) \\n                return false; //check column\\n            if (board[allrow + i / 3][allcol + i % 3] == c) \\n                return false; //check 3*3 block\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def solveSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: None Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if not board or len(board) == 0:\\n            return\\n        self.solve(board , 0 , 0)\\n        \\n    def solve(self, board , i , j):\\n        \"\"\"\\n        rtype: boolean\\n        \"\"\"\\n        if i == 9 and j == 0:\\n            return True \\n        if board[i][j] != \\'.\\':\\n            if j+1 == 9:\\n                x = i + 1\\n                y = 0 \\n            else:\\n                x = i \\n                y = j + 1 \\n            return self.solve(board, x , y) ;\\n        for c in \"123456789\":\\n            if self.isValid(board, i, j, c):\\n                board[i][j] = c\\n                if j+1 == 9:\\n                    g = i + 1\\n                    h = 0 \\n                else:\\n                    g = i \\n                    h = j + 1\\n                if self.solve(board , g , h): \\n                # If it\\'s the solution return true\\n                    return True\\n                # Otherwise go back\\n                else:\\n                    board[i][j] = \\'.\\'\\n        return False\\n        \\n    def isValid(self, board, x, y, ch):\\n        ar = 3*(x/3) \\n        ac = 3*(y/3)\\n        for i in xrange(9):\\n            if board[i][y] == ch: \\n                return False\\n        for j in xrange(9):\\n            if board[x][j] == ch:\\n                return False\\n        for i in xrange(3):\\n            for j in xrange(3):\\n                if board[ar + i][ac + j] == ch:\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n        void solveSudoku(vector<vector<char>>& board) {\\n            solve(board , 0 , 0);\\n        }\\n    private:\\n        bool solve(vector<vector<char>>& board , int i , int j) {\\n            if(i == 9 && j == 0) \\n                return true;\\n            if(board[i][j] != \\'.\\') \\n                return solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1);\\n\\n            for(char num = \\'1\\'; num <= \\'9\\'; num++) {\\n                if(isValid(board, i, j, num)){\\n                    board[i][j] = num;\\n                    if(solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1)) \\n                        return true;\\n                    board[i][j] = \\'.\\';\\n                }\\n            }\\n            return false;\\n        }\\n        bool isValid(vector<vector<char>>& board, int r, int c, char d) {\\n            int allrow = 3 * (r / 3);\\n            int allcol = 3 * (c / 3);\\n            for (int i = 0; i < 9; i++) {\\n                if (board[i][c] == d) \\n                    return false; //check row\\n                if (board[r][i] == d) \\n                    return false; //check column\\n                if (board[allrow + i / 3][allcol + i % 3] == d) \\n                    return false; //check 3*3 block\\n            }\\n            return true;\\n        }\\n    };\\n```\n```\\npublic class Solution {\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0)\\n            return ;\\n        solve(board , 0 , 0);\\n    }\\n    \\n     public boolean solve(char[][] board, int i, int j) {\\n        if(i == 9 && j == 0) return true;\\n        if(board[i][j] != \\'.\\') \\n            return solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1);\\n        \\n        for(char num = \\'1\\'; num <= \\'9\\'; num++) {\\n            if(isValid(board, i, j, num)){\\n                board[i][j] = num;\\n                if(solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1)) \\n                    return true;\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n     private boolean isValid(char[][] board, int row, int col, char c){\\n        int allrow = 3 * (row / 3);\\n        int allcol = 3 * (col / 3);\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == c) \\n                return false; //check row\\n            if (board[row][i] == c) \\n                return false; //check column\\n            if (board[allrow + i / 3][allcol + i % 3] == c) \\n                return false; //check 3*3 block\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def solveSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: None Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if not board or len(board) == 0:\\n            return\\n        self.solve(board , 0 , 0)\\n        \\n    def solve(self, board , i , j):\\n        \"\"\"\\n        rtype: boolean\\n        \"\"\"\\n        if i == 9 and j == 0:\\n            return True \\n        if board[i][j] != \\'.\\':\\n            if j+1 == 9:\\n                x = i + 1\\n                y = 0 \\n            else:\\n                x = i \\n                y = j + 1 \\n            return self.solve(board, x , y) ;\\n        for c in \"123456789\":\\n            if self.isValid(board, i, j, c):\\n                board[i][j] = c\\n                if j+1 == 9:\\n                    g = i + 1\\n                    h = 0 \\n                else:\\n                    g = i \\n                    h = j + 1\\n                if self.solve(board , g , h): \\n                # If it\\'s the solution return true\\n                    return True\\n                # Otherwise go back\\n                else:\\n                    board[i][j] = \\'.\\'\\n        return False\\n        \\n    def isValid(self, board, x, y, ch):\\n        ar = 3*(x/3) \\n        ac = 3*(y/3)\\n        for i in xrange(9):\\n            if board[i][y] == ch: \\n                return False\\n        for j in xrange(9):\\n            if board[x][j] == ch:\\n                return False\\n        for i in xrange(3):\\n            for j in xrange(3):\\n                if board[ar + i][ac + j] == ch:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487823,
                "title": "python3-a-concise-backtracking-implementation",
                "content": "Algorithm: \\nProgressively try filling empty spots and backtrack when the current setup isn\\'t working. \\n\\nImplementation (240ms, 50.44%): \\n```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        spots = [] #empty spots\\n        row = [set() for _ in range(9)]\\n        col = [set() for _ in range(9)]\\n        sub = [set() for _ in range(9)]\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] == \".\": spots.append((i, j))\\n                else: \\n                    row[i].add(board[i][j])\\n                    col[j].add(board[i][j])\\n                    sub[i//3*3+j//3].add(board[i][j])\\n                    \\n        def fn(k):\\n            \"\"\"return True if kth spot is filled properly\"\"\"\\n            if k == len(spots): return True\\n            i, j = spots[k]\\n            for n in map(str, range(1, 10)): \\n                if n not in row[i] and n not in col[j] and n not in sub[i//3*3+j//3]: \\n                    board[i][j] = n\\n                    row[i].add(n)\\n                    col[j].add(n)\\n                    sub[i//3*3+j//3].add(n)\\n                    if fn(k+1): return True\\n                    else:\\n                        row[i].remove(n)\\n                        col[j].remove(n)\\n                        sub[i//3*3+j//3].remove(n)\\n            return False \\n        \\n        fn(0) #change in place \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        spots = [] #empty spots\\n        row = [set() for _ in range(9)]\\n        col = [set() for _ in range(9)]\\n        sub = [set() for _ in range(9)]\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] == \".\": spots.append((i, j))\\n                else: \\n                    row[i].add(board[i][j])\\n                    col[j].add(board[i][j])\\n                    sub[i//3*3+j//3].add(board[i][j])\\n                    \\n        def fn(k):\\n            \"\"\"return True if kth spot is filled properly\"\"\"\\n            if k == len(spots): return True\\n            i, j = spots[k]\\n            for n in map(str, range(1, 10)): \\n                if n not in row[i] and n not in col[j] and n not in sub[i//3*3+j//3]: \\n                    board[i][j] = n\\n                    row[i].add(n)\\n                    col[j].add(n)\\n                    sub[i//3*3+j//3].add(n)\\n                    if fn(k+1): return True\\n                    else:\\n                        row[i].remove(n)\\n                        col[j].remove(n)\\n                        sub[i//3*3+j//3].remove(n)\\n            return False \\n        \\n        fn(0) #change in place \\n```",
                "codeTag": "Java"
            },
            {
                "id": 149432,
                "title": "clean-python-20-lines-using-dfs-and-two-stacks",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board):\\n        def dfs(board, stack1, stack2):\\n            if not stack1: return\\n            x, y = stack1.pop()\\n            stack2.append((x, y))\\n            box = [board[x//3*3+i][y//3*3+j] for i in range(3) for j in range(3)]\\n            row = [board[x][j] for j in range(9)]\\n            col = [board[i][y] for i in range(9)]\\n            for i in \"123456789\":\\n                if not any([i in box, i in col, i in row]):\\n                    board[x][y] = i\\n                    dfs(board, stack1, stack2)\\n                    if not stack1: return\\n            board[x][y] = \".\"\\n            pos = stack2.pop()\\n            stack1.append(pos)\\n        \\n        stack1 = [(i, j) for i in range(9) for j in range(9) if board[i][j] == \".\"]\\n        stack2 = []\\n        dfs(board, stack1, stack2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board):\\n        def dfs(board, stack1, stack2):\\n            if not stack1: return\\n            x, y = stack1.pop()\\n            stack2.append((x, y))\\n            box = [board[x//3*3+i][y//3*3+j] for i in range(3) for j in range(3)]\\n            row = [board[x][j] for j in range(9)]\\n            col = [board[i][y] for i in range(9)]\\n            for i in \"123456789\":\\n                if not any([i in box, i in col, i in row]):\\n                    board[x][y] = i\\n                    dfs(board, stack1, stack2)\\n                    if not stack1: return\\n            board[x][y] = \".\"\\n            pos = stack2.pop()\\n            stack1.append(pos)\\n        \\n        stack1 = [(i, j) for i in range(9) for j in range(9) if board[i][j] == \".\"]\\n        stack2 = []\\n        dfs(board, stack1, stack2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650838,
                "title": "c-simple-solution-using-backtracking-with-explanatory-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n    \\n    bool solve(vector<vector<char>>& board) {\\n        //Tranversing the given sudoku\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[0].size();j++) {\\n                if(board[i][j] == \\'.\\') {    //blank found\\n                    \\n                    for(char c = \\'1\\';c <= \\'9\\'; c++) {   //trying all the possible numbers from 1-9\\n                        if(isValid(board,i,j,c)) {\\n                            board[i][j] = c;\\n                            \\n                            if(solve(board) == true)  //checking for the next blank \\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';  //if blank cannot be filled after checking then revert the changes\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;    //if everything is filled then return true\\n    }\\n    \\n    bool isValid(vector<vector<char>>& board , int row , int col , char c) {\\n        for(int i=0;i<9;i++) {\\n            if(board[row][i] == c)  //checking row if the value already there\\n                return false;\\n            if(board[i][col] == c)  //checking column if value already there\\n                return false;\\n            //checking the 3X3 sub box where the blank value is present to check if element is there\\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3] == c) \\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Do give a upvote if the solution helps you**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n    \\n    bool solve(vector<vector<char>>& board) {\\n        //Tranversing the given sudoku\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[0].size();j++) {\\n                if(board[i][j] == \\'.\\') {    //blank found\\n                    \\n                    for(char c = \\'1\\';c <= \\'9\\'; c++) {   //trying all the possible numbers from 1-9\\n                        if(isValid(board,i,j,c)) {\\n                            board[i][j] = c;\\n                            \\n                            if(solve(board) == true)  //checking for the next blank \\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';  //if blank cannot be filled after checking then revert the changes\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;    //if everything is filled then return true\\n    }\\n    \\n    bool isValid(vector<vector<char>>& board , int row , int col , char c) {\\n        for(int i=0;i<9;i++) {\\n            if(board[row][i] == c)  //checking row if the value already there\\n                return false;\\n            if(board[i][col] == c)  //checking column if value already there\\n                return false;\\n            //checking the 3X3 sub box where the blank value is present to check if element is there\\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3] == c) \\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957919,
                "title": "simplest-and-shortest-approach-in-c-and-also-space-effiecient",
                "content": "a better, shorter and simpler approch\\nalso very space efficeint\\n\\n```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n     \\n         helper(board,0,0);\\n        return ; \\n    }\\n    \\n    bool helper(vector<vector<char>>& board,int i,int j)\\n    {   if(i==9){return true;}\\n        if(j==9){ return helper(board,i+1,0);}\\n        if(board[i][j]!=\\'.\\'){return helper(board,i,j+1);}\\n             \\n     for(int number=1;number<=9;number++)\\n        { if(can_place(board,i,j,\\'0\\'+ number))\\n            {  board[i][j]=\\'0\\'+ number;\\n            \\n              bool can_solve=helper(board,i,j+1);\\n              if(can_solve==true){return true;}  \\n            }              \\n        }   \\n        board[i][j]=\\'.\\';\\n        return false;\\n    }   \\n    \\n    bool can_place(vector<vector<char>>& board,int i,int j,char val)\\n    {\\n       int row = i - i%3, column = j - j%3;\\n    for(int x=0; x<9; x++) if(board[x][j] == val) return false;\\n    for(int y=0; y<9; y++) if(board[i][y] == val) return false;\\n    for(int x=0; x<3; x++)\\n    for(int y=0; y<3; y++)\\n        if(board[row+x][column+y] == val) return false;\\n    return true;\\n}\\n    \\n};\\n```\\n\\nplease upvote\\nhappy coding :)\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n     \\n         helper(board,0,0);\\n        return ; \\n    }\\n    \\n    bool helper(vector<vector<char>>& board,int i,int j)\\n    {   if(i==9){return true;}\\n        if(j==9){ return helper(board,i+1,0);}\\n        if(board[i][j]!=\\'.\\'){return helper(board,i,j+1);}\\n             \\n     for(int number=1;number<=9;number++)\\n        { if(can_place(board,i,j,\\'0\\'+ number))\\n            {  board[i][j]=\\'0\\'+ number;\\n            \\n              bool can_solve=helper(board,i,j+1);\\n              if(can_solve==true){return true;}  \\n            }              \\n        }   \\n        board[i][j]=\\'.\\';\\n        return false;\\n    }   \\n    \\n    bool can_place(vector<vector<char>>& board,int i,int j,char val)\\n    {\\n       int row = i - i%3, column = j - j%3;\\n    for(int x=0; x<9; x++) if(board[x][j] == val) return false;\\n    for(int y=0; y<9; y++) if(board[i][y] == val) return false;\\n    for(int x=0; x<3; x++)\\n    for(int y=0; y<3; y++)\\n        if(board[row+x][column+y] == val) return false;\\n    return true;\\n}\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15877,
                "title": "13-line-python-solution-dfs-beats-47-79",
                "content": "    def solveSudoku(self, board):\\n      def dfs():\\n        for i, row in enumerate(board):\\n          for j, char in enumerate(row):\\n            if char == '.':\\n              for x in s9 - {row[k] for k in r9} - {board[k][j] for k in r9} - \\\\\\n                  {board[i / 3 * 3 + m][j / 3 * 3 + n] for m in r3 for n in r3}:\\n                board[i][j] = x\\n                if dfs(): return True\\n                board[i][j] = '.'\\n              return False\\n        return True\\n            \\n      r3, r9, s9 = range(3), range(9), {'1', '2', '3', '4', '5', '6', '7', '8', '9'}\\n      dfs()",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    def solveSudoku(self, board):\\n      def dfs():\\n        for i, row in enumerate(board):\\n          for j, char in enumerate(row):\\n            if char == '.':\\n              for x in s9 - {row[k] for k in r9} - {board[k][j] for k in r9} - \\\\\\n                  {board[i / 3 * 3 + m][j / 3 * 3 + n] for m in r3 for n in r3}:\\n                board[i][j] = x\\n                if dfs(): return True\\n                board[i][j] = '.'\\n              return False\\n        return True\\n            \\n      r3, r9, s9 = range(3), range(9), {'1', '2', '3', '4', '5', '6', '7', '8', '9'}\\n      dfs()",
                "codeTag": "Python3"
            },
            {
                "id": 3062184,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<vector<char>>& board, int row, int col, char c)\\n    {\\n        for(int i = 0; i < 9; i++) \\n            if(board[i][col] == c) \\n                return false;\\n\\n        for(int i = 0; i < 9; i++) \\n            if(board[row][i] == c) \\n                return false;\\n\\n        int x0 = (row/3) * 3, y0 = (col/3) * 3;\\n        for(int i = 0; i < 3; i++) {\\n            for(int j = 0; j < 3; j++) {\\n                if(board[x0 + i][y0 + j] == c) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool solve(vector<vector<char>>& board, int r, int c)\\n    {\\n        if(r==9)\\n        return true;\\n        if(c==9)\\n        return solve(board, r+1, 0);\\n        if(board[r][c]!=\\'.\\')\\n        return solve(board, r, c+1);\\n        for(char i=\\'1\\';i<=\\'9\\';i++)\\n        {\\n            if(check(board, r, c, i))\\n            {\\n                board[r][c]=i;\\n                if(solve(board, r, c+1))\\n                return true;\\n                board[r][c]=\\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board, 0, 0);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<vector<char>>& board, int row, int col, char c)\\n    {\\n        for(int i = 0; i < 9; i++) \\n            if(board[i][col] == c) \\n                return false;\\n\\n        for(int i = 0; i < 9; i++) \\n            if(board[row][i] == c) \\n                return false;\\n\\n        int x0 = (row/3) * 3, y0 = (col/3) * 3;\\n        for(int i = 0; i < 3; i++) {\\n            for(int j = 0; j < 3; j++) {\\n                if(board[x0 + i][y0 + j] == c) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool solve(vector<vector<char>>& board, int r, int c)\\n    {\\n        if(r==9)\\n        return true;\\n        if(c==9)\\n        return solve(board, r+1, 0);\\n        if(board[r][c]!=\\'.\\')\\n        return solve(board, r, c+1);\\n        for(char i=\\'1\\';i<=\\'9\\';i++)\\n        {\\n            if(check(board, r, c, i))\\n            {\\n                board[r][c]=i;\\n                if(solve(board, r, c+1))\\n                return true;\\n                board[r][c]=\\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417115,
                "title": "c-clean-and-commented-for-better-understanding",
                "content": "See my Leetcode-36 (Valid Sudoku) solution for diagrams as well.\\nLink : https://leetcode.com/problems/valid-sudoku/discuss/1416689/C%2B%2B-(3-approaches-with-diagrams)\\n\\nTIME COMPLEXITY EXPLANATION :\\n```\\nSince we have a certain number of empty cells where we try all possibilities\\n(1, 2, 3, 4, 5, 6, 7, 8 or 9).\\nSo, let\\'s say number of empty cells = e\\nFor each e cells, we have 9 possibilities, hence time complexity = O(9^e)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<vector<char>>& board, int i, int j, char& ch) {\\n        //validate current row\\n        for(int col = 0; col<9; col++) {\\n            if(board[i][col] == ch) return false;\\n        }\\n        \\n        //validate current column\\n        for(int row = 0; row<9; row++) {\\n            if(board[row][j] == ch) return false;\\n        }\\n        \\n        //validate current box\\n        /*\\n            If you want to get the start index ([start_i][start_j] i.e. top left) of a box\\n            given i and j\\n            start_i = i/3 * 3;\\n            start_j = j/3 * 3;\\n            \\n            Now, you can check current box\\n        */\\n        \\n        int start_i = i/3 * 3;\\n        int start_j = j/3 * 3;\\n        for(int k = 0; k<3; k++) {\\n            for(int l = 0; l<3; l++) {\\n                if(board[start_i + k][start_j + l] == ch) return false;\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n    \\n    bool backtrack(vector<vector<char>>& board, int i, int j) {\\n        //all rows checked\\n        if(i == 9)\\n            return true;\\n        \\n        //current row over, go to next row starting from 0th column\\n        if(j == 9)\\n            return backtrack(board, i+1, 0);\\n        \\n        //if it\\'s filled go for next column\\n        if(board[i][j] != \\'.\\')\\n            return backtrack(board, i, j+1);\\n        \\n        //else try putting \\'1\\' to \\'9\\' and see if you find the result in any\\n        for(char ch = \\'1\\'; ch<=\\'9\\'; ch++) {\\n            if(isValid(board, i, j, ch)) {\\n                board[i][j] = ch;\\n                if(backtrack(board, i, j+1)) {\\n                    return true;\\n                }\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>>& board) {\\n        backtrack(board, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nSince we have a certain number of empty cells where we try all possibilities\\n(1, 2, 3, 4, 5, 6, 7, 8 or 9).\\nSo, let\\'s say number of empty cells = e\\nFor each e cells, we have 9 possibilities, hence time complexity = O(9^e)\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<vector<char>>& board, int i, int j, char& ch) {\\n        //validate current row\\n        for(int col = 0; col<9; col++) {\\n            if(board[i][col] == ch) return false;\\n        }\\n        \\n        //validate current column\\n        for(int row = 0; row<9; row++) {\\n            if(board[row][j] == ch) return false;\\n        }\\n        \\n        //validate current box\\n        /*\\n            If you want to get the start index ([start_i][start_j] i.e. top left) of a box\\n            given i and j\\n            start_i = i/3 * 3;\\n            start_j = j/3 * 3;\\n            \\n            Now, you can check current box\\n        */\\n        \\n        int start_i = i/3 * 3;\\n        int start_j = j/3 * 3;\\n        for(int k = 0; k<3; k++) {\\n            for(int l = 0; l<3; l++) {\\n                if(board[start_i + k][start_j + l] == ch) return false;\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n    \\n    bool backtrack(vector<vector<char>>& board, int i, int j) {\\n        //all rows checked\\n        if(i == 9)\\n            return true;\\n        \\n        //current row over, go to next row starting from 0th column\\n        if(j == 9)\\n            return backtrack(board, i+1, 0);\\n        \\n        //if it\\'s filled go for next column\\n        if(board[i][j] != \\'.\\')\\n            return backtrack(board, i, j+1);\\n        \\n        //else try putting \\'1\\' to \\'9\\' and see if you find the result in any\\n        for(char ch = \\'1\\'; ch<=\\'9\\'; ch++) {\\n            if(isValid(board, i, j, ch)) {\\n                board[i][j] = ch;\\n                if(backtrack(board, i, j+1)) {\\n                    return true;\\n                }\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>>& board) {\\n        backtrack(board, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401341,
                "title": "python-straightforward-backtracking-exhaustive-search",
                "content": "```python\\ndef solveSudoku(self, board):\\n\\t# Check if digit can be placed at position (i,j)\\n\\tdef is_valid(digit, i, j):\\n\\t\\t# check row\\n\\t\\tfor y in range(len(board)):\\n\\t\\t\\tif board[i][y] == str(digit):\\n\\t\\t\\t\\treturn False\\n\\t\\t# check column\\n\\t\\tfor x in range(len(board)):\\n\\t\\t\\tif board[x][j] == str(digit):\\n\\t\\t\\t\\treturn False\\n\\t\\t# check square\\n\\t\\tsquare_x, square_y = i/3, j/3\\n\\t\\tfor x in range(square_x*3, square_x*3+3):\\n\\t\\t\\tfor y in range(square_y*3, square_y*3+3):\\n\\t\\t\\t\\tif board[x][y] == str(digit):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\t# Find a valid digit for position (i, j), if possible, and recurse / backtrack\\n\\tdef search(i, j):\\n\\t\\tif i == len(board):\\n\\t\\t\\treturn True\\n\\t\\telif j == len(board):\\n\\t\\t\\treturn search(i+1, 0)\\n\\t\\tif board[i][j] == \".\":\\n\\t\\t\\tfor digit in range(1, 10):\\n\\t\\t\\t\\tif is_valid(digit, i, j):\\n\\t\\t\\t\\t\\tboard[i][j] = str(digit)\\n\\t\\t\\t\\t\\tif search(i, j+1): \\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\tboard[i][j] = \".\"\\n\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\treturn search(i, j+1)\\n\\n\\tsearch(0,0)\\n\\treturn board\\n```",
                "solutionTags": [],
                "code": "```python\\ndef solveSudoku(self, board):\\n\\t# Check if digit can be placed at position (i,j)\\n\\tdef is_valid(digit, i, j):\\n\\t\\t# check row\\n\\t\\tfor y in range(len(board)):\\n\\t\\t\\tif board[i][y] == str(digit):\\n\\t\\t\\t\\treturn False\\n\\t\\t# check column\\n\\t\\tfor x in range(len(board)):\\n\\t\\t\\tif board[x][j] == str(digit):\\n\\t\\t\\t\\treturn False\\n\\t\\t# check square\\n\\t\\tsquare_x, square_y = i/3, j/3\\n\\t\\tfor x in range(square_x*3, square_x*3+3):\\n\\t\\t\\tfor y in range(square_y*3, square_y*3+3):\\n\\t\\t\\t\\tif board[x][y] == str(digit):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\t# Find a valid digit for position (i, j), if possible, and recurse / backtrack\\n\\tdef search(i, j):\\n\\t\\tif i == len(board):\\n\\t\\t\\treturn True\\n\\t\\telif j == len(board):\\n\\t\\t\\treturn search(i+1, 0)\\n\\t\\tif board[i][j] == \".\":\\n\\t\\t\\tfor digit in range(1, 10):\\n\\t\\t\\t\\tif is_valid(digit, i, j):\\n\\t\\t\\t\\t\\tboard[i][j] = str(digit)\\n\\t\\t\\t\\t\\tif search(i, j+1): \\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\tboard[i][j] = \".\"\\n\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\treturn search(i, j+1)\\n\\n\\tsearch(0,0)\\n\\treturn board\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 15818,
                "title": "beats-99-really-really-fast-and-with-explanation-and-chinese-comment",
                "content": " \\u6211\\u4eec\\u53ef\\u4ee5\\u4f9d\\u6b21\\u5c06\\u2018.\\u2019\\u5b57\\u7b26\\u66ff\\u6362\\u4e3a\\u67d0\\u4e2a\\u517c\\u5bb9\\u7684\\u6570\\u5b57\\uff0c\\u5982\\u679c\\u5728\\u66ff\\u6362\\u8fc7\\u7a0b\\u4e2d\\u53d1\\u73b0\\u6ca1\\u6709\\u517c\\u5bb9\\u7684\\u6570\\u5b57\\uff0c\\u8bf4\\u660e\\u6211\\u8981\\u56de\\u9000\\u5230\\u524d\\u9762\\u53bb\\u66f4\\u6539\\u524d\\u9762\\u7684\\u6570\\u5b57\\uff0c\\u7136\\u540e\\u7ee7\\u7eed\\u4e0b\\u53bb\\u76f4\\u5230\\u6c42\\u5f97\\u89e3\\uff0c\\u8fd9\\u5c31\\u662f\\u56de\\u6eaf\\u3002\\n\\u542f\\u53d1\\u5f0f\\u505a\\u6cd5\\uff1a\\u95ee\\u9898\\u7684\\u7126\\u70b9\\u5728\\u4e8e\\u6211\\u4eec\\u5e94\\u8be5\\u5148\\u66ff\\u6362\\u54ea\\u4e2a\\u65b9\\u683c\\u3002\\u76f4\\u89c9\\u4e0a\\u6211\\u4eec\\u5e94\\u8be5\\u5c3d\\u65e9\\u66ff\\u6362\\u8fd9\\u6837\\u7684\\u65b9\\u683c\\uff0c\\u4ed6\\u7684\\u517c\\u5bb9\\u6570\\u5b57\\u4e2a\\u6570\\u6700\\u5c11\\uff0c\\u6216\\u8005\\u8bf4\\u81ea\\u7531\\u5ea6\\u6700\\u4f4e\\uff0c\\u56e0\\u4e3a\\u6211\\u4eec\\u8d8a\\u65e9\\u66ff\\u6362\\u7684\\u683c\\u5b50\\uff0c\\u586b\\u9519\\u5176\\u6570\\u5b57\\u7684\\u4ee3\\u4ef7\\u5c31\\u8d8a\\u5230\\u9ad8\\u3002\\u6240\\u4ee5\\u6211\\u4eec\\u9009\\u62e9\\u81ea\\u7531\\u5ea6\\u6700\\u4f4e\\u7684\\u683c\\u5b50\\uff0c\\u4fdd\\u8bc1\\u6211\\u4eec\\u586b\\u9519\\u6570\\u5b57\\u7684\\u6982\\u7387\\u6700\\u5c0f\\u3002\\n\\u4ee3\\u7801\\u7684\\u5b9e\\u73b0\\u4e0a\\u96be\\u70b9\\u5728\\u4e8e\\u6709\\u6548\\u7684\\u627e\\u5230\\u81ea\\u7531\\u5ea6\\u6700\\u5c0f\\u7684\\u70b9\\uff0c\\u6b22\\u8fce\\u5927\\u5bb6\\u81ea\\u5df1\\u53bb\\u5b9e\\u9a8c\\u4e00\\u4e9b\\u66f4\\u6709\\u6548\\u7684\\u65b9\\u6848\\u3002\\nWe could replace '.' one by one with a digit that is compatible, if we can't find a compatible digit for a cube, we backtrace to a cube and fill it with another compatible digit. if we have replace all '.' with a compatible digit, we get a solution\\nHeuristic method: The key point is which '.' should we replace first? we should first replace intuitively a '.' which has the fewest compatible digit. why? let\\u2018s say\\uff0cwe chosed a digit for the first '.' and finally we find it is a wrong digit, we have to traceback to this first '.', it would be painfully inefficient, so, we should first replace a '.' which we are most likely choose a right digit for it. The fewer compatible digits the '.' has, the more likely we can choose a right digits for it. \\nThe code can be improved, Welcome to share your own tricks and implementation\\n````\\npublic class Solution {\\n    public boolean finded = false;      // Have we finded out the solution? \\u662f\\u5426\\u627e\\u5230\\u4e86\\u89e3\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n    \\n    // \\u9012\\u5f52\\u7684\\u5e76\\u542f\\u53d1\\u6c42\\u89e3 Recursively and Heuristic solve it\\n    // \\u4f7f\\u7528\\u542f\\u53d1\\u5f0f\\u7684\\u89e3\\u6cd5\\uff0c\\u6bcf\\u4e00\\u6b65\\u90fd\\u5bfb\\u627e\\u81ea\\u7531\\u5ea6\\u6700\\u5c0f\\u7684\\u683c\\u5b50\\uff0c\\u5f53\\u7136\\u5982\\u679c\\u9047\\u5230\\u81ea\\u7531\\u5ea6\\u4e3a0\\u7684\\u683c\\u5b50\\u8fd9\\u4e2a\\u65f6\\u5019\\u8fd4\\u56de\\uff0c\\u5f53\\u5bfb\\u627e\\u5230\\u4e00\\u4e2a\\u89e3\\u65f6\\u8fd4\\u56de\\n    public void solve(char[][] board) {\\n        if(finded || isFull(board)) {\\n            finded = true;\\n            return;\\n        }\\n        int[] index = findIndex(board);    // \\u6839\\u636e\\u542f\\u53d1\\u89c4\\u5219\\u5bfb\\u627e\\u81ea\\u7531\\u5ea6\\u6700\\u4f4e\\u7684\\u683c\\u5b50\\uff0cfindout the \\u2019.\\u2018 we should replace\\n        if(index != null) {\\n            char[] values = findAvaible(index[2], index[3]);   // \\u5c06\\u81ea\\u7531\\u5ea6\\u6700\\u4f4e\\u7684\\u683c\\u5b50\\u7684\\u53ef\\u80fd\\u53d6\\u503c\\u627e\\u51fa\\u6765. what digits can we replace\\n            for(char e : values) {\\n                board[index[0]][index[1]] = e;\\n                solve(board);\\n                if(finded) return;\\n            }\\n            board[index[0]][ index[1]] = '.';    // \\u5982\\u679c\\u5728\\u8fd9\\u4e9b\\u53d6\\u503c\\u4e0b\\u90fd\\u6ca1\\u6709\\u89e3\\u5219\\u8fd4\\u56de,\\u4e0d\\u8fc7\\u5148\\u5c06\\u5176\\u8fd8\\u539f\\n        }\\n    }\\n    \\n    // return int[4]:null if that board can't be a solution. [0] and [1] is the index, [2] is the total compatible digits it has, [3] is a vector record those digits\\n    // for example: if [3] = 00..001110, then we have compatible digits 2,3,4 (the 2th, 3th, 4th bits is 1)\\n    // \\u8be5\\u51fd\\u6570\\u8fd4\\u56de\\u8be5\\u88ab\\u66ff\\u6362\\u7684'.'\\u7684\\u4e0b\\u6807\\uff0c\\u81ea\\u7531\\u5ea6\\uff0c\\u5e76\\u4e14\\u8fd4\\u56de\\u4e00\\u4e2a\\u4ee3\\u8868\\u517c\\u5bb9\\u6570\\u5b57\\u7684\\u6574\\u6570\\u5411\\u91cf\\uff0c\\u5982\\u679c\\u65e0\\u89e3\\u5219\\u8fd4\\u56denull\\n    // \\u6bd4\\u5982\\u8bf4\\uff1a\\u5982\\u679c\\u5411\\u91cf\\u6574\\u6570\\u4e3a00...001110, \\u90a3\\u4e48\\u517c\\u5bb9\\u7684\\u6570\\u4e3a2,3,4\\uff08\\u5411\\u91cf\\u7b2c2,3,4\\u4f4dbit\\u4e3a1\\uff09\\n    public int[] findIndex(char[][] board) {\\n        int[] result = null;    // \\u8bb0\\u5f55\\u81ea\\u7531\\u5ea6\\u6700\\u4f4e\\u7684\\u89e3\\u7684\\u4f4d\\u7f6e,\\u4ee5\\u53ca\\u53ef\\u884c\\u89e3\\n        short[] r = new short[9];   // \\u4ee3\\u8868\\u6ca1\\u884c\\u5269\\u4f59\\u5143\\u7d20\\u7684\\u5411\\u91cf\\n        short[] c = new short[9];   // \\u4ee3\\u8868\\u6bcf\\u5217...\\n        short[] g = new short[9];   // \\u4ee3\\u8868\\u6ca1\\u4e2a3*3\\u65b9\\u683c\\n        short mask = 0x01FF;\\n        // \\u6a2a\\u5411\\uff0c\\u7eb5\\u5411\\u6c42\\u5411\\u91cf\\n        for(int i = 0; i < board.length; i++) {\\n            short sr = 0, sc = 0;    // \\u8bb0\\u5f55\\u88ab\\u5360\\u7528\\u7684\\u4f4d\\u7f6e\\n            for(int j = 0; j < board.length; j++) {\\n                if(board[i][j] != '.') {\\n                    sr |= (1 << (board[i][j] - '1'));\\n                }\\n                if(board[j][i] != '.') {\\n                    sc |= (1 << (board[j][i] - '1'));\\n                }\\n            }\\n            sr = (short)((~sr) & mask);    // \\u73b0\\u5728sr\\u4e2d\\u4e3a1\\u7684\\u4f4d\\u4ee3\\u8868\\u53ef\\u53d6\\u7684\\u5b57\\u7b26\\n            sc = (short)((~sc) & mask);\\n            r[i] = sr;\\n            c[i] = sc;\\n        }\\n        \\n        // \\u6c42\\u89e33*3\\u65b9\\u683c\\u7684\\u76f8\\u5173\\u5411\\u91cf\\n        for(int i = 0; i < 9; i += 3) {\\n            for(int j = 0; j < 9; j += 3) {\\n                short sg = 0;\\n                for(int m = 0; m < 3; m++) {\\n                    for(int n = 0; n < 3; n++) {\\n                        if(board[i + m][j + n] != '.')\\n                            sg |= (short)(1 << (board[i + m][j + n] - '1'));\\n                    }\\n                }\\n                sg = (short)((~sg) & mask);\\n                g[i + j / 3] = sg;\\n            }\\n        }\\n        \\n        // \\u5df2\\u7ecf\\u5c06\\u6240\\u6709\\u7ef4\\u5ea6\\u7684\\u89e3\\u5411\\u91cf\\u6c42\\u5f97\\uff0c\\u73b0\\u5728\\u9700\\u8981\\u6c42\\u89e3\\u6bcf\\u4e2a\\u4f4d\\u7f6e\\u7684\\u89e3\\uff0c\\u5e76\\u5c06\\u81ea\\u7531\\u5ea6\\u6700\\u5c0f\\u7684\\u89e3\\u7684\\u4e0b\\u6807,\\u81ea\\u7531\\u5ea6\\uff0c\\u4ee5\\u53ca\\u5411\\u91cf\\u8fd4\\u56de\\n        int min = Integer.MAX_VALUE;    // \\u6700\\u5c0f\\u7684\\u81ea\\u7531\\u5ea6\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board.length; j++) {\\n                if(board[i][j] == '.') {\\n                    short m = (short) (r[i] & c[j] & g[(i / 3) * 3 + j / 3]);\\n                    if(m == 0) return null;\\n                    int n = countBit(m);\\n                    if(min > n) {\\n                        min = n;\\n                        result = new int[]{i, j, min, m};\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // \\u8ba1\\u7b97\\u6574\\u6570\\u4e2d\\u4f4d\\u4e3a1\\u7684bit\\u6570\\n    // count the bits with value 1 in the integer vector\\n    public int countBit(int x) {\\n        int count = 0;\\n        while(x != 0) {\\n            count++;\\n            x &= (x - 1);\\n        }\\n        return count;\\n    }\\n    \\n    // \\u6839\\u636e\\u5411\\u91cfm\\u6c42\\u89e3\\u5bf9\\u5e94\\u4f4d\\u4e0a\\u7684\\u5b57\\u7b26\\n    public char[] findAvaible(int n, int m) {\\n        char[] r = new char[n];\\n        for(int i = 0, j = 0; j < n; i++) {\\n            if((m & (1 << i)) != 0) {\\n                r[j++] = \"123456789\".charAt(i);\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    public boolean isFull(char[][] board) {\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board.length; j++) {\\n                if(board[i][j] == '.') return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean finded = false;      // Have we finded out the solution? \\u662f\\u5426\\u627e\\u5230\\u4e86\\u89e3\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3750106,
                "title": "well-explained-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:(9^m) where,m is number of empty places\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool  isSafe(vector<vector<char>>&board,int row,int col,char value,int n){\\n        for(int i=0;i<n;i++){\\n            //for row\\n            if(board[row][i]==value){ // mean for any col of ith row if data is equal to value retunr false\\n                return false;\\n            }\\n\\n            //for col\\n            if(board[i][col]==value){ // for any row(ith) with col if data is equal to value return false \\n                return false;\\n            }\\n\\n            //for 3*3 matrix\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==value){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>&board){\\n        //get the size\\n        int n=board.size();\\n\\n        for(int row=0;row<n;row++){\\n            for(int col=0;col<n;col++){\\n                //This 2 loops are for iterating the matrix\\n\\n                //in case we found the empty place\\n                if(board[row][col]==\\'.\\'){\\n\\n                    //we can fill that place with values from 1-9 \\n                    for(char i=\\'1\\';i<=\\'9\\';i++){\\n\\n                        if(isSafe(board,row,col,i,n))//mean we can place this value here\\n                        {\\n                            board[row][col]=i;\\n                            //now check will this value give the solution\\n                            bool isSolutionPossible=solve(board);\\n\\n                            if(isSolutionPossible){\\n                                return true;\\n                            }\\n                            else{\\n                                //backtrack // mean we cannot find the solution by putting this value at this place\\n                                board[row][col]=\\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false; // if any of the value form 1-9 could fit in\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        //make another function\\n        bool possible = solve(board);\\n        return ;\\n    }\\n};\\n```\\n![leetcode.jpeg](https://assets.leetcode.com/users/images/19503308-805c-4755-beae-13a5eff9d57a_1689078100.598394.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool  isSafe(vector<vector<char>>&board,int row,int col,char value,int n){\\n        for(int i=0;i<n;i++){\\n            //for row\\n            if(board[row][i]==value){ // mean for any col of ith row if data is equal to value retunr false\\n                return false;\\n            }\\n\\n            //for col\\n            if(board[i][col]==value){ // for any row(ith) with col if data is equal to value return false \\n                return false;\\n            }\\n\\n            //for 3*3 matrix\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==value){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>&board){\\n        //get the size\\n        int n=board.size();\\n\\n        for(int row=0;row<n;row++){\\n            for(int col=0;col<n;col++){\\n                //This 2 loops are for iterating the matrix\\n\\n                //in case we found the empty place\\n                if(board[row][col]==\\'.\\'){\\n\\n                    //we can fill that place with values from 1-9 \\n                    for(char i=\\'1\\';i<=\\'9\\';i++){\\n\\n                        if(isSafe(board,row,col,i,n))//mean we can place this value here\\n                        {\\n                            board[row][col]=i;\\n                            //now check will this value give the solution\\n                            bool isSolutionPossible=solve(board);\\n\\n                            if(isSolutionPossible){\\n                                return true;\\n                            }\\n                            else{\\n                                //backtrack // mean we cannot find the solution by putting this value at this place\\n                                board[row][col]=\\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false; // if any of the value form 1-9 could fit in\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        //make another function\\n        bool possible = solve(board);\\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844011,
                "title": "easiest-solution-c-plus-plus-backtracking-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isSafe(int row,int col,vector<vector<char>> &b,char v){\\n    for(int i = 0 ; i < b.size();i++){\\n        if(b[row][i]==v) return false;\\n        if(b[i][col]==v) return false;\\n        if(b[3*(row/3) + i/3][3*(col/3)+i%3]==v) return false;\\n    }\\n    return true;\\n}\\nchar aaa = \\'.\\';\\nbool solve(vector<vector<char>> &b){\\n    int n = b[0].size();\\n    for(int r = 0;r<n;r++){\\n        for(int c = 0;c<n;c++){\\n            if(b[r][c]==aaa){\\n                for(char v = \\'1\\';v<=\\'9\\';v++){\\n                    if(isSafe(r,c,b,v)){\\n                        b[r][c]=v;\\n                        bool a = solve(b);\\n                        if(a) return true;\\n                        else b[r][c]=\\'.\\';\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isSafe(int row,int col,vector<vector<char>> &b,char v){\\n    for(int i = 0 ; i < b.size();i++){\\n        if(b[row][i]==v) return false;\\n        if(b[i][col]==v) return false;\\n        if(b[3*(row/3) + i/3][3*(col/3)+i%3]==v) return false;\\n    }\\n    return true;\\n}\\nchar aaa = \\'.\\';\\nbool solve(vector<vector<char>> &b){\\n    int n = b[0].size();\\n    for(int r = 0;r<n;r++){\\n        for(int c = 0;c<n;c++){\\n            if(b[r][c]==aaa){\\n                for(char v = \\'1\\';v<=\\'9\\';v++){\\n                    if(isSafe(r,c,b,v)){\\n                        b[r][c]=v;\\n                        bool a = solve(b);\\n                        if(a) return true;\\n                        else b[r][c]=\\'.\\';\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789627,
                "title": "sudoku-solver-solution-recursion-and-backtracking-approach-easy-explanation",
                "content": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        helper(board);\\n    }\\n    boolean helper(char[][] board)\\n    {\\n        for(int row=0; row<board.length; row++)\\n        {\\n            for(int col=0; col<board.length; col++)\\n            {\\n              //check for an empty cell\\n                if(board[row][col]==\\'.\\')\\n                {\\n                  //try every value from 1 to 9 \\n                    for(int val=1; val<=9; val++)\\n                    {\\n                      //check that value before inserting into board it is suitable or not by satisfying all three conditions\\n                        if(isSafe(row,col,(char)(val+\\'0\\'),board))\\n                        {\\n                          //if value if safe to enter at that position insert it into board\\n                            char c = (char)(val+\\'0\\');\\n                            board[row][col] = c;\\n                          \\n                          //and again call recursion for remaining cell\\n                            boolean temp = helper(board);\\n                            if(temp)   //if recursion will give ans true we can assume that we found one possible way of filling and we simply return true\\n                                return true;\\n                            else{   // else try another value by backtracking means change that cell again to empty cell\\n                                board[row][col] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                  //if we reached here means we tried all value from 1 to 9 at that cell but no one satisfying the all the three conditions it means current\\n                  //state of board is wrong we have to backtrack to change it\\'s previous state so return false\\n                  //that mean temp will store false and it goes to backtracking step\\n                       return false;\\n                }\\n            }\\n        }\\n      //if we reached here means our board if filled return true\\n        return true;\\n    }\\n    boolean isSafe(int row,int col,char val,char[][] board)\\n    {\\n        for(int i=0; i<board.length; i++)\\n        {\\n          //check row\\n            if(board[row][i]==val)\\n                return false;\\n          \\n          //check column\\n            if(board[i][col]==val)\\n                return false;\\n          \\n          //check 3*3 matrix\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==val)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\nT.C :-O(9^(n^2)), for each cell in the n^2 board, we have 9 possible numbers\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        helper(board);\\n    }\\n    boolean helper(char[][] board)\\n    {\\n        for(int row=0; row<board.length; row++)\\n        {\\n            for(int col=0; col<board.length; col++)\\n            {\\n              //check for an empty cell\\n                if(board[row][col]==\\'.\\')\\n                {\\n                  //try every value from 1 to 9 \\n                    for(int val=1; val<=9; val++)\\n                    {\\n                      //check that value before inserting into board it is suitable or not by satisfying all three conditions\\n                        if(isSafe(row,col,(char)(val+\\'0\\'),board))\\n                        {\\n                          //if value if safe to enter at that position insert it into board\\n                            char c = (char)(val+\\'0\\');\\n                            board[row][col] = c;\\n                          \\n                          //and again call recursion for remaining cell\\n                            boolean temp = helper(board);\\n                            if(temp)   //if recursion will give ans true we can assume that we found one possible way of filling and we simply return true\\n                                return true;\\n                            else{   // else try another value by backtracking means change that cell again to empty cell\\n                                board[row][col] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                  //if we reached here means we tried all value from 1 to 9 at that cell but no one satisfying the all the three conditions it means current\\n                  //state of board is wrong we have to backtrack to change it\\'s previous state so return false\\n                  //that mean temp will store false and it goes to backtracking step\\n                       return false;\\n                }\\n            }\\n        }\\n      //if we reached here means our board if filled return true\\n        return true;\\n    }\\n    boolean isSafe(int row,int col,char val,char[][] board)\\n    {\\n        for(int i=0; i<board.length; i++)\\n        {\\n          //check row\\n            if(board[row][i]==val)\\n                return false;\\n          \\n          //check column\\n            if(board[i][col]==val)\\n                return false;\\n          \\n          //check 3*3 matrix\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==val)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\nT.C :-O(9^(n^2)), for each cell in the n^2 board, we have 9 possible numbers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905782,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func solveSudoku(_ board: inout [[Character]]) {\\n        func backtrack(_ path: [Character], _ input: [[Character]], _ index: Int) {\\n            if path.count == 81 {\\n                if isValidSudoku(input) { board = input }\\n                return\\n            }\\n            let x = index / 9\\n            let y = index % 9\\n            let chars = available(input, x, y)\\n            var path = path\\n            var input = input\\n            let tmp = input[x][y]\\n\\n            for c in chars {\\n                path.append(c)\\n                input[x][y] = c\\n                backtrack(path, input, index + 1)\\n                input[x][y] = tmp\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        var loop = false\\n        repeat {\\n            var tmp = false\\n            for x in 0..<9 {\\n                for y in 0..<9 {\\n                    if board[x][y] != \".\" { continue }\\n                    tmp = tmp || fill(&board, x, y)\\n                }\\n            }\\n            loop = tmp\\n        } while loop\\n        \\n        backtrack([], board, 0)\\n    }\\n\\n\\n    func fill(_ board: inout [[Character]], _ x: Int, _ y: Int) -> Bool {\\n        let chars = available(board, x, y)\\n        if chars.count == 1 {\\n            board[x][y] = chars[0]\\n            return true\\n        } else {\\n            return false\\n        }\\n    }\\n\\n\\n    func available(_ board: [[Character]], _ x: Int, _ y: Int) -> [Character] {\\n        if board[x][y] != \".\" { return [board[x][y]] }\\n\\n        let j = (x / 3) * 3 + (y / 3)   \\n        var res: [Character] = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n        var c: Character\\n\\n        for i in 0..<9 {\\n            c = board[x][i]\\n            if let index = res.firstIndex(of: c) { res.remove(at: index) }\\n        \\n            c = board[i][y]\\n            if let index = res.firstIndex(of: c) { res.remove(at: index) }\\n            \\n            let x = (j / 3) * 3 + i / 3\\n            let y = (j % 3) * 3 + i % 3\\n            \\n            c = board[x][y]\\n            if let index = res.firstIndex(of: c) { res.remove(at: index) }\\n        }\\n\\n        return res\\n    }\\n\\n\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        func isInvalid(_ box: [Character]) -> Bool {\\n            var chars: [Character] = []\\n            for c in box where c != \".\" {\\n                if chars.contains(c) { return true } else { chars.append(c) }\\n            }\\n            return false\\n        }\\n\\n        for i in 0..<9 {\\n            if isInvalid(board[i]) { return false }\\n            if isInvalid(board.map({ $0[i] })) { return false }\\n            let col = (i % 3) * 3\\n            let row = (i / 3) * 3\\n            let box = Array(board[row][col..<col + 3]) + Array(board[row + 1][col..<col + 3]) + Array(board[row + 2][col..<col + 3])\\n            if isInvalid(box) { return false }\\n        }\\n        return true\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func solveSudoku(_ board: inout [[Character]]) {\\n        func backtrack(_ path: [Character], _ input: [[Character]], _ index: Int) {\\n            if path.count == 81 {\\n                if isValidSudoku(input) { board = input }\\n                return\\n            }\\n            let x = index / 9\\n            let y = index % 9\\n            let chars = available(input, x, y)\\n            var path = path\\n            var input = input\\n            let tmp = input[x][y]\\n\\n            for c in chars {\\n                path.append(c)\\n                input[x][y] = c\\n                backtrack(path, input, index + 1)\\n                input[x][y] = tmp\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n\\n        var loop = false\\n        repeat {\\n            var tmp = false\\n            for x in 0..<9 {\\n                for y in 0..<9 {\\n                    if board[x][y] != \".\" { continue }\\n                    tmp = tmp || fill(&board, x, y)\\n                }\\n            }\\n            loop = tmp\\n        } while loop\\n        \\n        backtrack([], board, 0)\\n    }\\n\\n\\n    func fill(_ board: inout [[Character]], _ x: Int, _ y: Int) -> Bool {\\n        let chars = available(board, x, y)\\n        if chars.count == 1 {\\n            board[x][y] = chars[0]\\n            return true\\n        } else {\\n            return false\\n        }\\n    }\\n\\n\\n    func available(_ board: [[Character]], _ x: Int, _ y: Int) -> [Character] {\\n        if board[x][y] != \".\" { return [board[x][y]] }\\n\\n        let j = (x / 3) * 3 + (y / 3)   \\n        var res: [Character] = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\\n        var c: Character\\n\\n        for i in 0..<9 {\\n            c = board[x][i]\\n            if let index = res.firstIndex(of: c) { res.remove(at: index) }\\n        \\n            c = board[i][y]\\n            if let index = res.firstIndex(of: c) { res.remove(at: index) }\\n            \\n            let x = (j / 3) * 3 + i / 3\\n            let y = (j % 3) * 3 + i % 3\\n            \\n            c = board[x][y]\\n            if let index = res.firstIndex(of: c) { res.remove(at: index) }\\n        }\\n\\n        return res\\n    }\\n\\n\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        func isInvalid(_ box: [Character]) -> Bool {\\n            var chars: [Character] = []\\n            for c in box where c != \".\" {\\n                if chars.contains(c) { return true } else { chars.append(c) }\\n            }\\n            return false\\n        }\\n\\n        for i in 0..<9 {\\n            if isInvalid(board[i]) { return false }\\n            if isInvalid(board.map({ $0[i] })) { return false }\\n            let col = (i % 3) * 3\\n            let row = (i / 3) * 3\\n            let box = Array(board[row][col..<col + 3]) + Array(board[row + 1][col..<col + 3]) + Array(board[row + 2][col..<col + 3])\\n            if isInvalid(box) { return false }\\n        }\\n        return true\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758146,
                "title": "c-backtracking-hashset-clean-and-commented",
                "content": "**STEPS**\\n1. create three hashsets/array to keep track of elements in current row,col and 3x3 square\\n2. travel the input board, add all the filled cells to their corresponding hashsets and empty cells to a new vector empty_pos\\n3. call dfs on empty_pos vector and try out all values for each empty_cell and backtrack when ever be violate any sudoku rule\\n\\n```\\nclass Solution {\\npublic:\\n    //3 hashsets to keep track of values of encountered so far for each row,col and 3x3 square\\n    bool row[9][9]={};\\n    bool col[9][9]={};\\n    bool sq[3][3][9]={};\\n    \\n    //return true if value z is valid for the index x,y\\n    bool valid(int x,int y,int z){\\n        if(row[x][z] || col[y][z] || sq[x/3][y/3][z]) return false;\\n        return true;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& nums,vector<vector<int>>& empty_pos,int i){\\n        //if i==empty_pos.size() means we were able to fill up all empty values hence return true;\\n        if(i==empty_pos.size()) return true;\\n        int x=empty_pos[i][0]; int y=empty_pos[i][1];\\n        //try all possible values\\n        for(int z=0;z<9;z++){\\n            if(valid(x,y,z)){\\n                //if a value if valid update the board, hashsets and recursively call dfs for the next empty_pos\\n                nums[x][y]=(z+\\'1\\');\\n                row[x][z]=true; col[y][z]=true; sq[x/3][y/3][z]=true;\\n                if(dfs(nums,empty_pos,i+1)) return true;\\n                //no ans found hence backtrack\\n                nums[x][y]=\\'.\\';\\n                row[x][z]=false; col[y][z]=false; sq[x/3][y/3][z]=false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //fill up hashsets and empty_pos with i,j where board[i][j]=\\'.\\'\\n    void solveSudoku(vector<vector<char>>& board){\\n        vector<vector<int>> empty_pos;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    int val=board[i][j]-\\'1\\';\\n                    row[i][val]=true; col[j][val]=true; sq[i/3][j/3][val]=true;\\n                }else empty_pos.push_back({i,j});\\n            }\\n        }\\n        dfs(board,empty_pos,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //3 hashsets to keep track of values of encountered so far for each row,col and 3x3 square\\n    bool row[9][9]={};\\n    bool col[9][9]={};\\n    bool sq[3][3][9]={};\\n    \\n    //return true if value z is valid for the index x,y\\n    bool valid(int x,int y,int z){\\n        if(row[x][z] || col[y][z] || sq[x/3][y/3][z]) return false;\\n        return true;\\n    }\\n    \\n    bool dfs(vector<vector<char>>& nums,vector<vector<int>>& empty_pos,int i){\\n        //if i==empty_pos.size() means we were able to fill up all empty values hence return true;\\n        if(i==empty_pos.size()) return true;\\n        int x=empty_pos[i][0]; int y=empty_pos[i][1];\\n        //try all possible values\\n        for(int z=0;z<9;z++){\\n            if(valid(x,y,z)){\\n                //if a value if valid update the board, hashsets and recursively call dfs for the next empty_pos\\n                nums[x][y]=(z+\\'1\\');\\n                row[x][z]=true; col[y][z]=true; sq[x/3][y/3][z]=true;\\n                if(dfs(nums,empty_pos,i+1)) return true;\\n                //no ans found hence backtrack\\n                nums[x][y]=\\'.\\';\\n                row[x][z]=false; col[y][z]=false; sq[x/3][y/3][z]=false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //fill up hashsets and empty_pos with i,j where board[i][j]=\\'.\\'\\n    void solveSudoku(vector<vector<char>>& board){\\n        vector<vector<int>> empty_pos;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    int val=board[i][j]-\\'1\\';\\n                    row[i][val]=true; col[j][val]=true; sq[i/3][j/3][val]=true;\\n                }else empty_pos.push_back({i,j});\\n            }\\n        }\\n        dfs(board,empty_pos,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693002,
                "title": "java-easy-to-understand-read-code",
                "content": "This problem is solved using backtracking, that is I think not too difficult to find.\\nThe tricky part is to find the duplicate in the 3x3 sub block.\\nThe following solution make that mathematics simpler, by using string operation.\\n\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                addToSet(set, i, j, board[i][j]);\\n            }\\n        }\\n        backtrack(board, set);\\n    }\\n\\n    private boolean backtrack(char[][] board, Set<String> set) {\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') continue;\\n                for(char k = \\'1\\'; k <= \\'9\\'; k++) {\\n                    if(!isValid(set, i, j, k)) continue;\\n                    board[i][j] = k;\\n                    addToSet(set, i, j, k);\\n                    if(backtrack(board, set)) return true;\\n                    removeFromSet(set, i, j, k);\\n                    board[i][j] = \\'.\\';\\n                }\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isValid(Set<String> set, int i, int j, char k) {\\n        if(set.contains(\"\" + k + \"row-\" + i)) return false; \\n        if(set.contains(\"\" + k + \"col-\" + j)) return false;           \\n        if(set.contains(\"\" + k + \"block-\" + (i / 3) + (j / 3))) return false; \\n        return true;\\n\\n    }\\n    \\n    private void addToSet(Set<String> set, int i, int j, char k) {\\n        set.add(\"\" + k + \"row-\" + i);\\n        set.add(\"\" + k + \"col-\" + j);\\n        set.add(\"\" + k + \"block-\" + (i / 3) + (j / 3));\\n    }\\n    \\n    private void removeFromSet(Set<String> set, int i, int j, char k) {\\n        set.remove(\"\" + k + \"row-\" + i);\\n        set.remove(\"\" + k + \"col-\" + j);\\n        set.remove(\"\" + k + \"block-\" + (i / 3) + (j / 3));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                addToSet(set, i, j, board[i][j]);\\n            }\\n        }\\n        backtrack(board, set);\\n    }\\n\\n    private boolean backtrack(char[][] board, Set<String> set) {\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') continue;\\n                for(char k = \\'1\\'; k <= \\'9\\'; k++) {\\n                    if(!isValid(set, i, j, k)) continue;\\n                    board[i][j] = k;\\n                    addToSet(set, i, j, k);\\n                    if(backtrack(board, set)) return true;\\n                    removeFromSet(set, i, j, k);\\n                    board[i][j] = \\'.\\';\\n                }\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isValid(Set<String> set, int i, int j, char k) {\\n        if(set.contains(\"\" + k + \"row-\" + i)) return false; \\n        if(set.contains(\"\" + k + \"col-\" + j)) return false;           \\n        if(set.contains(\"\" + k + \"block-\" + (i / 3) + (j / 3))) return false; \\n        return true;\\n\\n    }\\n    \\n    private void addToSet(Set<String> set, int i, int j, char k) {\\n        set.add(\"\" + k + \"row-\" + i);\\n        set.add(\"\" + k + \"col-\" + j);\\n        set.add(\"\" + k + \"block-\" + (i / 3) + (j / 3));\\n    }\\n    \\n    private void removeFromSet(Set<String> set, int i, int j, char k) {\\n        set.remove(\"\" + k + \"row-\" + i);\\n        set.remove(\"\" + k + \"col-\" + j);\\n        set.remove(\"\" + k + \"block-\" + (i / 3) + (j / 3));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 604592,
                "title": "most-simple-45-lines-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findunassignedindex(int &row,int &col,vector<vector<char>>& board)\\n    {\\n        for(row=0;row<9;row++)\\n        {\\n            for(col=0;col<9;col++)\\n            {\\n                if(board[row][col]==\\'.\\') return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool issafe(int row,int col,int num,vector<vector<char>>& board)\\n    {\\n        for(int i=0;i<9;i++) if(board[row][i]==num+48) return false;  // check safe row\\n        for(int i=0;i<9;i++) if(board[i][col]==num+48) return false;  // check safe col\\n        int boxrow = row - row%3;\\n        int boxcol = col - col%3;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(board[i+boxrow][j+boxcol]==num+48) return false;  // checks box\\n            }\\n        }\\n        return true;\\n    }\\n    bool valid(vector<vector<char>>& board)\\n    {\\n        int row,col;\\n        if(!findunassignedindex(row,col,board)) return true;\\n        \\n        for(int num=1;num<=9;num++)\\n        {\\n            if(issafe(row,col,num,board))\\n            {\\n                board[row][col] = num+48;\\n                if(valid(board)) return true;\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        valid(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findunassignedindex(int &row,int &col,vector<vector<char>>& board)\\n    {\\n        for(row=0;row<9;row++)\\n        {\\n            for(col=0;col<9;col++)\\n            {\\n                if(board[row][col]==\\'.\\') return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool issafe(int row,int col,int num,vector<vector<char>>& board)\\n    {\\n        for(int i=0;i<9;i++) if(board[row][i]==num+48) return false;  // check safe row\\n        for(int i=0;i<9;i++) if(board[i][col]==num+48) return false;  // check safe col\\n        int boxrow = row - row%3;\\n        int boxcol = col - col%3;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(board[i+boxrow][j+boxcol]==num+48) return false;  // checks box\\n            }\\n        }\\n        return true;\\n    }\\n    bool valid(vector<vector<char>>& board)\\n    {\\n        int row,col;\\n        if(!findunassignedindex(row,col,board)) return true;\\n        \\n        for(int num=1;num<=9;num++)\\n        {\\n            if(issafe(row,col,num,board))\\n            {\\n                board[row][col] = num+48;\\n                if(valid(board)) return true;\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        valid(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309684,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public void SolveSudoku(char[][] board) \\n    {\\n        if(board==null|| board.Length==0) return; \\n        SolveSudokuInternal(board);\\n    }\\n    \\n    public bool SolveSudokuInternal(char[][] board)\\n    {\\n         for(int i = 0; i < board.Length; i++)\\n         {\\n            for(int j = 0; j < board[0].Length; j++)\\n            {\\n                if(board[i][j] == \\'.\\')\\n                {\\n                    for(char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if(IsValid(board, c, i, j))\\n                        {\\n                            board[i][j] = c;\\n                            if(SolveSudokuInternal(board))\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    \\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public bool IsValid(char[][] board, char ch, int row, int col)\\n    {\\n        for(int i=0;i<9; i++)\\n            if(board[row][i]==ch) \\n                return false; \\n        \\n        for(int i=0; i < 9 ; i++)\\n             if(board[i][col]==ch) \\n                 return false; \\n        \\n        int r=(row/3)*3, c=(col/3)*3;\\n        \\n        for(int i=r; i < r+3; i++)\\n            for(int j=c; j<c+3;j++)\\n                if(board[i][j]==ch) \\n                    return false; \\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public void SolveSudoku(char[][] board) \\n    {\\n        if(board==null|| board.Length==0) return; \\n        SolveSudokuInternal(board);\\n    }\\n    \\n    public bool SolveSudokuInternal(char[][] board)\\n    {\\n         for(int i = 0; i < board.Length; i++)\\n         {\\n            for(int j = 0; j < board[0].Length; j++)\\n            {\\n                if(board[i][j] == \\'.\\')\\n                {\\n                    for(char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if(IsValid(board, c, i, j))\\n                        {\\n                            board[i][j] = c;\\n                            if(SolveSudokuInternal(board))\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    \\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public bool IsValid(char[][] board, char ch, int row, int col)\\n    {\\n        for(int i=0;i<9; i++)\\n            if(board[row][i]==ch) \\n                return false; \\n        \\n        for(int i=0; i < 9 ; i++)\\n             if(board[i][col]==ch) \\n                 return false; \\n        \\n        int r=(row/3)*3, c=(col/3)*3;\\n        \\n        for(int i=r; i < r+3; i++)\\n            for(int j=c; j<c+3;j++)\\n                if(board[i][j]==ch) \\n                    return false; \\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140022,
                "title": "logical-thinking-with-clear-java-code",
                "content": "If we define a List `emptyCells` to represent all of the empty cells, `curIdx` as the index of the current empty cell we are are doint with,\\n**Start State**: curIdx = 0\\n**End State**(Base Case for the Recursion): curIdx = emptyCells.size()\\n**State Transformation**:\\nFor each empty cell `curCell`, we exclude impossible values according to the Sudoku Solution rules. Then we try each possible value of `curCell`, and check if it can lay the foundation for an valid Sudoku Solution using Recursion.\\nThe clear Java code is as below:\\n```\\n    public void solveSudoku(char[][] board) {\\n        List<Cell> emptyCells = new ArrayList<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    emptyCells.add(new Cell(i, j));\\n                }\\n            }\\n        }\\n        solveSudokuFrom(board, emptyCells, 0);\\n    }\\n\\n    private boolean solveSudokuFrom(char[][] board, List<Cell> emptyCells, int curIdx) {\\n        if (curIdx == emptyCells.size()) {\\n            return true;\\n        }\\n        Cell curCell = emptyCells.get(curIdx);\\n        Set<Integer> impossibleValues = getImpossibleValues(curCell.x, curCell.y, board);\\n        for (char i = \\'1\\'; i <= \\'9\\'; i++) {\\n            if (impossibleValues.contains(i - \\'0\\')) {\\n                continue;\\n            }\\n            board[curCell.x][curCell.y] = i;\\n            if (solveSudokuFrom(board, emptyCells, curIdx + 1)) {\\n                return true;\\n            }\\n            impossibleValues.add(i - \\'0\\');\\n            board[curCell.x][curCell.y] = \\'.\\';\\n        }\\n        return false;\\n    }\\n\\n    private Set<Integer> getImpossibleValues(int x, int y, char[][] board) {\\n        Set<Integer> impossibleValues = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][y] == \\'.\\') {\\n                continue;\\n            }\\n            impossibleValues.add(board[i][y] - \\'0\\');\\n        }\\n        for (int i = 0; i < 9; i++) {\\n            if (board[x][i] == \\'.\\') {\\n                continue;\\n            }\\n            impossibleValues.add(board[x][i] - \\'0\\');\\n        }\\n        int si = getBoundary(x);\\n        int sj = getBoundary(y);\\n        for (int i = si; i <= si + 2; i++) {\\n            for (int j = sj; j <= sj + 2; j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    continue;\\n                }\\n                impossibleValues.add(board[i][j] - \\'0\\');\\n            }\\n        }\\n        return impossibleValues;\\n    }\\n\\n    private int getBoundary(int val) {\\n        if (val >= 0 && val <= 2) {\\n            return 0;\\n        }\\n        if (val >= 3 && val <= 5) {\\n            return 3;\\n        }\\n        return 6;\\n    }\\n\\n    class Cell {\\n        int x, y;\\n\\n        public Cell(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n```\\n*I would appreciate your **Vote Up*** ;)",
                "solutionTags": [],
                "code": "```\\n    public void solveSudoku(char[][] board) {\\n        List<Cell> emptyCells = new ArrayList<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    emptyCells.add(new Cell(i, j));\\n                }\\n            }\\n        }\\n        solveSudokuFrom(board, emptyCells, 0);\\n    }\\n\\n    private boolean solveSudokuFrom(char[][] board, List<Cell> emptyCells, int curIdx) {\\n        if (curIdx == emptyCells.size()) {\\n            return true;\\n        }\\n        Cell curCell = emptyCells.get(curIdx);\\n        Set<Integer> impossibleValues = getImpossibleValues(curCell.x, curCell.y, board);\\n        for (char i = \\'1\\'; i <= \\'9\\'; i++) {\\n            if (impossibleValues.contains(i - \\'0\\')) {\\n                continue;\\n            }\\n            board[curCell.x][curCell.y] = i;\\n            if (solveSudokuFrom(board, emptyCells, curIdx + 1)) {\\n                return true;\\n            }\\n            impossibleValues.add(i - \\'0\\');\\n            board[curCell.x][curCell.y] = \\'.\\';\\n        }\\n        return false;\\n    }\\n\\n    private Set<Integer> getImpossibleValues(int x, int y, char[][] board) {\\n        Set<Integer> impossibleValues = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][y] == \\'.\\') {\\n                continue;\\n            }\\n            impossibleValues.add(board[i][y] - \\'0\\');\\n        }\\n        for (int i = 0; i < 9; i++) {\\n            if (board[x][i] == \\'.\\') {\\n                continue;\\n            }\\n            impossibleValues.add(board[x][i] - \\'0\\');\\n        }\\n        int si = getBoundary(x);\\n        int sj = getBoundary(y);\\n        for (int i = si; i <= si + 2; i++) {\\n            for (int j = sj; j <= sj + 2; j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    continue;\\n                }\\n                impossibleValues.add(board[i][j] - \\'0\\');\\n            }\\n        }\\n        return impossibleValues;\\n    }\\n\\n    private int getBoundary(int val) {\\n        if (val >= 0 && val <= 2) {\\n            return 0;\\n        }\\n        if (val >= 3 && val <= 5) {\\n            return 3;\\n        }\\n        return 6;\\n    }\\n\\n    class Cell {\\n        int x, y;\\n\\n        public Cell(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129911,
                "title": "fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Java ***\\n\\n```\\n\\nclass Solution {\\n   private static final char EMPTY_ENTRY = \\'.\\';\\n\\n/*\\n  Driver function to kick off the recursion\\n*/\\npublic static boolean solveSudoku(char[][] board){\\n  return solveSudokuCell(0, 0, board);\\n}\\n\\n/*\\n  This function chooses a placement for the cell at (row, col)\\n  and continues solving based on the rules we define.\\n  \\n  Our strategy:\\n  We will start at row 0.\\n  We will solve every column in that row.\\n  When we reach the last column we move to the next row.\\n  If this is past the last row (row == board.length) we are done.\\n  The whole board has been solved.\\n*/\\nprivate static boolean solveSudokuCell(int row, int col, char[][] board) {\\n\\n  /*\\n    Have we finished placements in all columns for\\n    the row we are working on?\\n  */\\n  if (col == board[row].length){\\n\\n    /*\\n      Yes. Reset to col 0 and advance the row by 1.\\n      We will work on the next row.\\n    */\\n    col = 0;\\n    row++;\\n\\n    /*\\n      Have we completed placements in all rows? If so then we are done.\\n      If not, drop through to the logic below and keep solving things.\\n    */\\n    if (row == board.length){\\n      return true; // Entire board has been filled without conflict.\\n    }\\n\\n  }\\n\\n  // Skip non-empty entries. They already have a value in them.\\n  if (board[row][col] != EMPTY_ENTRY) {\\n    return solveSudokuCell(row, col + 1, board);\\n  }\\n\\n  /*\\n    Try all values 1 through 9 in the cell at (row, col).\\n    Recurse on the placement if it doesn\\'t break the constraints of Sudoku.\\n  */\\n  for (int value = 1; value <= board.length; value++) {\\n\\n    char charToPlace = (char) (value + \\'0\\'); // convert int value to char\\n\\n    /*\\n      Apply constraints. We will only add the value to the cell if\\n      adding it won\\'t cause us to break sudoku rules.\\n    */\\n    if (canPlaceValue(board, row, col, charToPlace)) {\\n      board[row][col] = charToPlace;\\n      if (solveSudokuCell(row, col + 1, board)) { // recurse with our VALID placement\\n        return true;\\n      }\\n    }\\n\\n  }\\n\\n  /*\\n    Undo assignment to this cell. No values worked in it meaning that\\n    previous states put us in a position we cannot solve from. Hence,\\n    we backtrack by returning \"false\" to our caller.\\n  */\\n  board[row][col] = EMPTY_ENTRY;\\n  return false; // No valid placement was found, this path is faulty, return false\\n}\\n\\n/*\\n  Will the placement at (row, col) break the Sudoku properties?\\n*/\\nprivate static boolean canPlaceValue(char[][] board, int row, int col, char charToPlace) {\\n\\n  // Check column constraint. For each row, we do a check on column \"col\".\\n  for (char[] element : board) {\\n    if (charToPlace == element[col]){\\n      return false;\\n    }\\n  }\\n\\n  // Check row constraint. For each column in row \"row\", we do a check.\\n  for (int i = 0; i < board.length; i++) {\\n    if (charToPlace == board[row][i]) {\\n      return false;\\n    }\\n  }\\n\\n  /*\\n    Check region constraints.\\n    \\n    In a 9 x 9 board, we will have 9 sub-boxes (3 rows of 3 sub-boxes).\\n    \\n    The \"I\" tells us that we are in the Ith sub-box row. (there are 3 sub-box rows)\\n    The \"J\" tells us that we are in the Jth sub-box column. (there are 3 sub-box columns)\\n    \\n    I tried to think of better variable names for like 20 minutes but couldn\\'t so just left\\n    I and J.\\n    \\n    Integer properties will truncate the decimal place so we just know the sub-box number we are in.\\n    Each coordinate we touch will be found by an offset from topLeftOfSubBoxRow and topLeftOfSubBoxCol.\\n  */\\n  int regionSize = (int) Math.sqrt(board.length); // gives us the size of a sub-box\\n\\n  int I = row / regionSize;\\n  int J = col / regionSize;\\n\\n  /*\\n    This multiplication takes us to the EXACT top left of the sub-box. We keep the (row, col)\\n    of these values because it is important. It lets us traverse the sub-box with our double for loop.\\n  */\\n  int topLeftOfSubBoxRow = regionSize * I; // the row of the top left of the block\\n  int topLeftOfSubBoxCol = regionSize * J; // the column of the tol left of the block\\n\\n  for (int i = 0; i < regionSize; i++) {\\n    for (int j = 0; j < regionSize; j++) {\\n\\n      /*\\n        i and j just define our offsets from topLeftOfBlockRow\\n        and topLeftOfBlockCol respectively\\n      */\\n      if (charToPlace == board[topLeftOfSubBoxRow + i][topLeftOfSubBoxCol + j]) {\\n        return false;\\n      }\\n\\n    }\\n  }\\n\\n  return true; // placement is valid\\n}\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n   private static final char EMPTY_ENTRY = \\'.\\';\\n\\n/*\\n  Driver function to kick off the recursion\\n*/\\npublic static boolean solveSudoku(char[][] board){\\n  return solveSudokuCell(0, 0, board);\\n}\\n\\n/*\\n  This function chooses a placement for the cell at (row, col)\\n  and continues solving based on the rules we define.\\n  \\n  Our strategy:\\n  We will start at row 0.\\n  We will solve every column in that row.\\n  When we reach the last column we move to the next row.\\n  If this is past the last row (row == board.length) we are done.\\n  The whole board has been solved.\\n*/\\nprivate static boolean solveSudokuCell(int row, int col, char[][] board) {\\n\\n  /*\\n    Have we finished placements in all columns for\\n    the row we are working on?\\n  */\\n  if (col == board[row].length){\\n\\n    /*\\n      Yes. Reset to col 0 and advance the row by 1.\\n      We will work on the next row.\\n    */\\n    col = 0;\\n    row++;\\n\\n    /*\\n      Have we completed placements in all rows? If so then we are done.\\n      If not, drop through to the logic below and keep solving things.\\n    */\\n    if (row == board.length){\\n      return true; // Entire board has been filled without conflict.\\n    }\\n\\n  }\\n\\n  // Skip non-empty entries. They already have a value in them.\\n  if (board[row][col] != EMPTY_ENTRY) {\\n    return solveSudokuCell(row, col + 1, board);\\n  }\\n\\n  /*\\n    Try all values 1 through 9 in the cell at (row, col).\\n    Recurse on the placement if it doesn\\'t break the constraints of Sudoku.\\n  */\\n  for (int value = 1; value <= board.length; value++) {\\n\\n    char charToPlace = (char) (value + \\'0\\'); // convert int value to char\\n\\n    /*\\n      Apply constraints. We will only add the value to the cell if\\n      adding it won\\'t cause us to break sudoku rules.\\n    */\\n    if (canPlaceValue(board, row, col, charToPlace)) {\\n      board[row][col] = charToPlace;\\n      if (solveSudokuCell(row, col + 1, board)) { // recurse with our VALID placement\\n        return true;\\n      }\\n    }\\n\\n  }\\n\\n  /*\\n    Undo assignment to this cell. No values worked in it meaning that\\n    previous states put us in a position we cannot solve from. Hence,\\n    we backtrack by returning \"false\" to our caller.\\n  */\\n  board[row][col] = EMPTY_ENTRY;\\n  return false; // No valid placement was found, this path is faulty, return false\\n}\\n\\n/*\\n  Will the placement at (row, col) break the Sudoku properties?\\n*/\\nprivate static boolean canPlaceValue(char[][] board, int row, int col, char charToPlace) {\\n\\n  // Check column constraint. For each row, we do a check on column \"col\".\\n  for (char[] element : board) {\\n    if (charToPlace == element[col]){\\n      return false;\\n    }\\n  }\\n\\n  // Check row constraint. For each column in row \"row\", we do a check.\\n  for (int i = 0; i < board.length; i++) {\\n    if (charToPlace == board[row][i]) {\\n      return false;\\n    }\\n  }\\n\\n  /*\\n    Check region constraints.\\n    \\n    In a 9 x 9 board, we will have 9 sub-boxes (3 rows of 3 sub-boxes).\\n    \\n    The \"I\" tells us that we are in the Ith sub-box row. (there are 3 sub-box rows)\\n    The \"J\" tells us that we are in the Jth sub-box column. (there are 3 sub-box columns)\\n    \\n    I tried to think of better variable names for like 20 minutes but couldn\\'t so just left\\n    I and J.\\n    \\n    Integer properties will truncate the decimal place so we just know the sub-box number we are in.\\n    Each coordinate we touch will be found by an offset from topLeftOfSubBoxRow and topLeftOfSubBoxCol.\\n  */\\n  int regionSize = (int) Math.sqrt(board.length); // gives us the size of a sub-box\\n\\n  int I = row / regionSize;\\n  int J = col / regionSize;\\n\\n  /*\\n    This multiplication takes us to the EXACT top left of the sub-box. We keep the (row, col)\\n    of these values because it is important. It lets us traverse the sub-box with our double for loop.\\n  */\\n  int topLeftOfSubBoxRow = regionSize * I; // the row of the top left of the block\\n  int topLeftOfSubBoxCol = regionSize * J; // the column of the tol left of the block\\n\\n  for (int i = 0; i < regionSize; i++) {\\n    for (int j = 0; j < regionSize; j++) {\\n\\n      /*\\n        i and j just define our offsets from topLeftOfBlockRow\\n        and topLeftOfBlockCol respectively\\n      */\\n      if (charToPlace == board[topLeftOfSubBoxRow + i][topLeftOfSubBoxCol + j]) {\\n        return false;\\n      }\\n\\n    }\\n  }\\n\\n  return true; // placement is valid\\n}\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903116,
                "title": "c-10ms-fastest-clean-code-recursion",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool isSafe(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        // for every row and column\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[row][i] == c || board[i][col] == c)\\n            {\\n                return false;\\n            }\\n        }\\n        // for every 3x3 squre\\n        // findinding first element of square\\n        row -= (row % 3);\\n        col -= (col % 3);\\n        if (board[row][col] == c || board[row][col + 1] == c || board[row][col + 2] == c ||\\n            board[row + 1][col] == c || board[row + 1][col + 1] == c || board[row + 1][col + 2] == c ||\\n            board[row + 2][col] == c || board[row + 2][col + 1] == c || board[row + 2][col + 2] == c)\\n        {\\n\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n    bool sodukuSolver(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            for (int j = 0; j < 9; j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isSafe(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n                            if (sodukuSolver(board))\\n                            {\\n                                return true;\\n                            }\\n                            else\\n                            {\\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        sodukuSolver(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool isSafe(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        // for every row and column\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[row][i] == c || board[i][col] == c)\\n            {\\n                return false;\\n            }\\n        }\\n        // for every 3x3 squre\\n        // findinding first element of square\\n        row -= (row % 3);\\n        col -= (col % 3);\\n        if (board[row][col] == c || board[row][col + 1] == c || board[row][col + 2] == c ||\\n            board[row + 1][col] == c || board[row + 1][col + 1] == c || board[row + 1][col + 2] == c ||\\n            board[row + 2][col] == c || board[row + 2][col + 1] == c || board[row + 2][col + 2] == c)\\n        {\\n\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n    bool sodukuSolver(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            for (int j = 0; j < 9; j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isSafe(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n                            if (sodukuSolver(board))\\n                            {\\n                                return true;\\n                            }\\n                            else\\n                            {\\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        sodukuSolver(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690422,
                "title": "c-0-ms",
                "content": "For each empty spot, we are counting possible numbers we can insert there. Then, we sort empty spots and fill the board using the backtracking. Since the empty spots are sorted, we process less ambigous spots first, reducing the number of times we have to backtrack.\\n\\nWe are tracking \"used\" numbers using boolean arrays; we can do even better with bit masks, but the runtime is already 0 ms, so here you have it.\\n\\n```\\nbool r[9][9] = {}, c[9][9] = {}, b[9][9] = {};\\nbool dfs(vector<vector<char>>& bd, vector<pair<int, int>> &pos, int p) {\\n    if (p >= pos.size())\\n        return true;\\n    auto i = pos[p].second / 9, j = pos[p].second % 9;\\n    for (int n = 0; n < 9; ++n)\\n        if (!r[i][n] && !c[j][n] && !b[(i / 3) * 3 + j / 3][n]) {\\n            bd[i][j] = n + \\'1\\';\\n            r[i][n] = c[j][n] = b[(i / 3) * 3 + j / 3][n] = true;\\n            if (dfs(bd, pos, p + 1))\\n                return true;               \\n            r[i][n] = c[j][n] = b[(i / 3) * 3 + j / 3][n] = false;\\n        }\\n    return false;\\n}\\nvoid solveSudoku(vector<vector<char>>& bd) {\\n    for (int i = 0; i < 9; ++i)\\n        for (int j = 0; j < 9; ++j)\\n            if (bd[i][j] != \\'.\\') {\\n                r[i][bd[i][j] - \\'1\\'] = true;\\n                c[j][bd[i][j] - \\'1\\'] = true;\\n                b[(i / 3) * 3 + j / 3][bd[i][j] - \\'1\\'] = true;\\n            }\\n    vector<pair<int, int>> pos;\\n    for (int i = 0; i < 9; ++i)\\n        for (int j = 0; j < 9; ++j)\\n            if (bd[i][j] == \\'.\\') {\\n                int nums = 0;\\n                 for (int n = 0; n < 9; ++n)\\n                     nums += !r[i][n] && !c[j][n] && !b[(i / 3) * 3 + j / 3][n];\\n                 pos.push_back({nums, i * 9 + j});\\n            }\\n    sort(begin(pos), end(pos));\\n    dfs(bd, pos, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool r[9][9] = {}, c[9][9] = {}, b[9][9] = {};\\nbool dfs(vector<vector<char>>& bd, vector<pair<int, int>> &pos, int p) {\\n    if (p >= pos.size())\\n        return true;\\n    auto i = pos[p].second / 9, j = pos[p].second % 9;\\n    for (int n = 0; n < 9; ++n)\\n        if (!r[i][n] && !c[j][n] && !b[(i / 3) * 3 + j / 3][n]) {\\n            bd[i][j] = n + \\'1\\';\\n            r[i][n] = c[j][n] = b[(i / 3) * 3 + j / 3][n] = true;\\n            if (dfs(bd, pos, p + 1))\\n                return true;               \\n            r[i][n] = c[j][n] = b[(i / 3) * 3 + j / 3][n] = false;\\n        }\\n    return false;\\n}\\nvoid solveSudoku(vector<vector<char>>& bd) {\\n    for (int i = 0; i < 9; ++i)\\n        for (int j = 0; j < 9; ++j)\\n            if (bd[i][j] != \\'.\\') {\\n                r[i][bd[i][j] - \\'1\\'] = true;\\n                c[j][bd[i][j] - \\'1\\'] = true;\\n                b[(i / 3) * 3 + j / 3][bd[i][j] - \\'1\\'] = true;\\n            }\\n    vector<pair<int, int>> pos;\\n    for (int i = 0; i < 9; ++i)\\n        for (int j = 0; j < 9; ++j)\\n            if (bd[i][j] == \\'.\\') {\\n                int nums = 0;\\n                 for (int n = 0; n < 9; ++n)\\n                     nums += !r[i][n] && !c[j][n] && !b[(i / 3) * 3 + j / 3][n];\\n                 pos.push_back({nums, i * 9 + j});\\n            }\\n    sort(begin(pos), end(pos));\\n    dfs(bd, pos, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375207,
                "title": "python-backtracking-solution-with-explanation",
                "content": "This is certainly not the fastest solution, but I believe it is much easier to understand than other Python solutions posted.\\n\\n```python\\nclass Solution:\\n\\tdef solveSudoku(self, board: List[List[str]]) -> None:\\n\\t\\tEMPTY = \".\"\\n\\t\\t\\n\\t\\tdef solve() -> bool:\\n\\t\\t\\t# traverse the board one entry at a time, updating empty entries with a\\n\\t\\t\\t# potential value, and backtracking if the updated board isn\\'t valid\\n\\t\\t\\tfor i in range(9):\\n\\t\\t\\t\\tfor j in range(9):\\n\\t\\t\\t\\t\\tif board[i][j] == EMPTY:\\n\\t\\t\\t\\t\\t\\t# entry is empty, try each value (1-9) and see if the updated board\\n\\t\\t\\t\\t\\t\\t# is still valid\\n\\t\\t\\t\\t\\t\\tfor n in range(1, 10):\\n\\t\\t\\t\\t\\t\\t\\tif is_valid(i, j, str(n)):\\n\\t\\t\\t\\t\\t\\t\\t\\t# n doesn\\'t violate any constraints, update the board\\n\\t\\t\\t\\t\\t\\t\\t\\tboard[i][j] = str(n)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# check if the updated board is valid\\n\\t\\t\\t\\t\\t\\t\\t\\tif solve():\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# updated board is valid\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# updated board is invalid\\n\\t\\t\\t\\t\\t\\t\\t\\tboard[i][j] = EMPTY\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# did not find any n that were valid, backtrack\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\t\\t\\n\\t\\tdef is_valid(row: int, col: int, entry: str) -> bool:\\n\\t\\t\"\"\"Return True if no constraints are violated, False otherwise.\"\"\"\\n\\t\\t\\tif any(\\n\\t\\t\\t\\t# check if entry violates the row constraint\\n\\t\\t\\t\\tboard[row][i] == entry or\\n\\t\\t\\t\\t# check if entry violates the column constraint\\n\\t\\t\\t\\tboard[i][col] == entry or\\n\\t\\t\\t\\t# check if entry violates the subgrid constraint\\n\\t\\t\\t\\tboard[(row//3)*3+i%3][(col//3)*3+i//3] == entry\\n\\t\\t\\t\\tfor i in range(9)\\n\\t\\t\\t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\t\\t\\n\\t\\tsolve()\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\tdef solveSudoku(self, board: List[List[str]]) -> None:\\n\\t\\tEMPTY = \".\"\\n\\t\\t\\n\\t\\tdef solve() -> bool:\\n\\t\\t\\t# traverse the board one entry at a time, updating empty entries with a\\n\\t\\t\\t# potential value, and backtracking if the updated board isn\\'t valid\\n\\t\\t\\tfor i in range(9):\\n\\t\\t\\t\\tfor j in range(9):\\n\\t\\t\\t\\t\\tif board[i][j] == EMPTY:\\n\\t\\t\\t\\t\\t\\t# entry is empty, try each value (1-9) and see if the updated board\\n\\t\\t\\t\\t\\t\\t# is still valid\\n\\t\\t\\t\\t\\t\\tfor n in range(1, 10):\\n\\t\\t\\t\\t\\t\\t\\tif is_valid(i, j, str(n)):\\n\\t\\t\\t\\t\\t\\t\\t\\t# n doesn\\'t violate any constraints, update the board\\n\\t\\t\\t\\t\\t\\t\\t\\tboard[i][j] = str(n)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# check if the updated board is valid\\n\\t\\t\\t\\t\\t\\t\\t\\tif solve():\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# updated board is valid\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# updated board is invalid\\n\\t\\t\\t\\t\\t\\t\\t\\tboard[i][j] = EMPTY\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# did not find any n that were valid, backtrack\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\t\\t\\n\\t\\tdef is_valid(row: int, col: int, entry: str) -> bool:\\n\\t\\t\"\"\"Return True if no constraints are violated, False otherwise.\"\"\"\\n\\t\\t\\tif any(\\n\\t\\t\\t\\t# check if entry violates the row constraint\\n\\t\\t\\t\\tboard[row][i] == entry or\\n\\t\\t\\t\\t# check if entry violates the column constraint\\n\\t\\t\\t\\tboard[i][col] == entry or\\n\\t\\t\\t\\t# check if entry violates the subgrid constraint\\n\\t\\t\\t\\tboard[(row//3)*3+i%3][(col//3)*3+i//3] == entry\\n\\t\\t\\t\\tfor i in range(9)\\n\\t\\t\\t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\t\\t\\n\\t\\tsolve()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341766,
                "title": "best-backtrack-solution-java",
                "content": "```\\nprivate static final char EMPTY_ENTRY = \\'.\\';\\n\\n/*\\n  Driver function to kick off the recursion\\n*/\\npublic static boolean solveSudoku(char[][] board){\\n  return solveSudokuCell(0, 0, board);\\n}\\n\\n/*\\n  This function chooses a placement for the cell at (row, col)\\n  and continues solving based on the rules we define.\\n  \\n  Our strategy:\\n  We will start at row 0.\\n  We will solve every column in that row.\\n  When we reach the last column we move to the next row.\\n  If this is past the last row (row == board.length) we are done.\\n  The whole board has been solved.\\n*/\\nprivate static boolean solveSudokuCell(int row, int col, char[][] board) {\\n\\n  /*\\n    Have we finished placements in all columns for\\n    the row we are working on?\\n  */\\n  if (col == board[row].length){\\n\\n    /*\\n      Yes. Reset to col 0 and advance the row by 1.\\n      We will work on the next row.\\n    */\\n    col = 0;\\n    row++;\\n\\n    /*\\n      Have we completed placements in all rows? If so then we are done.\\n      If not, drop through to the logic below and keep solving things.\\n    */\\n    if (row == board.length){\\n      return true; // Entire board has been filled without conflict.\\n    }\\n\\n  }\\n\\n  // Skip non-empty entries. They already have a value in them.\\n  if (board[row][col] != EMPTY_ENTRY) {\\n    return solveSudokuCell(row, col + 1, board);\\n  }\\n\\n  /*\\n    Try all values 1 through 9 in the cell at (row, col).\\n    Recurse on the placement if it doesn\\'t break the constraints of Sudoku.\\n  */\\n  for (int value = 1; value <= board.length; value++) {\\n\\n    char charToPlace = (char) (value + \\'0\\'); // convert int value to char\\n\\n    /*\\n      Apply constraints. We will only add the value to the cell if\\n      adding it won\\'t cause us to break sudoku rules.\\n    */\\n    if (canPlaceValue(board, row, col, charToPlace)) {\\n      board[row][col] = charToPlace;\\n      if (solveSudokuCell(row, col + 1, board)) { // recurse with our VALID placement\\n        return true;\\n      }\\n    }\\n\\n  }\\n\\n  /*\\n    Undo assignment to this cell. No values worked in it meaning that\\n    previous states put us in a position we cannot solve from. Hence,\\n    we backtrack by returning \"false\" to our caller.\\n  */\\n  board[row][col] = EMPTY_ENTRY;\\n  return false; // No valid placement was found, this path is faulty, return false\\n}\\n\\n/*\\n  Will the placement at (row, col) break the Sudoku properties?\\n*/\\nprivate static boolean canPlaceValue(char[][] board, int row, int col, char charToPlace) {\\n\\n  // Check column constraint. For each row, we do a check on column \"col\".\\n  for (char[] element : board) {\\n    if (charToPlace == element[col]){\\n      return false;\\n    }\\n  }\\n\\n  // Check row constraint. For each column in row \"row\", we do a check.\\n  for (int i = 0; i < board.length; i++) {\\n    if (charToPlace == board[row][i]) {\\n      return false;\\n    }\\n  }\\n\\n  /*\\n    Check region constraints.\\n    \\n    In a 9 x 9 board, we will have 9 sub-boxes (3 rows of 3 sub-boxes).\\n    \\n    The \"I\" tells us that we are in the Ith sub-box row. (there are 3 sub-box rows)\\n    The \"J\" tells us that we are in the Jth sub-box column. (there are 3 sub-box columns)\\n    \\n    I tried to think of better variable names for like 20 minutes but couldn\\'t so just left\\n    I and J.\\n    \\n    Integer properties will truncate the decimal place so we just know the sub-box number we are in.\\n    Each coordinate we touch will be found by an offset from topLeftOfSubBoxRow and topLeftOfSubBoxCol.\\n  */\\n  int regionSize = (int) Math.sqrt(board.length); // gives us the size of a sub-box\\n\\n  int I = row / regionSize;\\n  int J = col / regionSize;\\n\\n  /*\\n    This multiplication takes us to the EXACT top left of the sub-box. We keep the (row, col)\\n    of these values because it is important. It lets us traverse the sub-box with our double for loop.\\n  */\\n  int topLeftOfSubBoxRow = regionSize * I; // the row of the top left of the block\\n  int topLeftOfSubBoxCol = regionSize * J; // the column of the tol left of the block\\n\\n  for (int i = 0; i < regionSize; i++) {\\n    for (int j = 0; j < regionSize; j++) {\\n\\n      /*\\n        i and j just define our offsets from topLeftOfBlockRow\\n        and topLeftOfBlockCol respectively\\n      */\\n      if (charToPlace == board[topLeftOfSubBoxRow + i][topLeftOfSubBoxCol + j]) {\\n        return false;\\n      }\\n\\n    }\\n  }\\n\\n  return true; // placement is valid\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nprivate static final char EMPTY_ENTRY = \\'.\\';\\n\\n/*\\n  Driver function to kick off the recursion\\n*/\\npublic static boolean solveSudoku(char[][] board){\\n  return solveSudokuCell(0, 0, board);\\n}\\n\\n/*\\n  This function chooses a placement for the cell at (row, col)\\n  and continues solving based on the rules we define.\\n  \\n  Our strategy:\\n  We will start at row 0.\\n  We will solve every column in that row.\\n  When we reach the last column we move to the next row.\\n  If this is past the last row (row == board.length) we are done.\\n  The whole board has been solved.\\n*/\\nprivate static boolean solveSudokuCell(int row, int col, char[][] board) {\\n\\n  /*\\n    Have we finished placements in all columns for\\n    the row we are working on?\\n  */\\n  if (col == board[row].length){\\n\\n    /*\\n      Yes. Reset to col 0 and advance the row by 1.\\n      We will work on the next row.\\n    */\\n    col = 0;\\n    row++;\\n\\n    /*\\n      Have we completed placements in all rows? If so then we are done.\\n      If not, drop through to the logic below and keep solving things.\\n    */\\n    if (row == board.length){\\n      return true; // Entire board has been filled without conflict.\\n    }\\n\\n  }\\n\\n  // Skip non-empty entries. They already have a value in them.\\n  if (board[row][col] != EMPTY_ENTRY) {\\n    return solveSudokuCell(row, col + 1, board);\\n  }\\n\\n  /*\\n    Try all values 1 through 9 in the cell at (row, col).\\n    Recurse on the placement if it doesn\\'t break the constraints of Sudoku.\\n  */\\n  for (int value = 1; value <= board.length; value++) {\\n\\n    char charToPlace = (char) (value + \\'0\\'); // convert int value to char\\n\\n    /*\\n      Apply constraints. We will only add the value to the cell if\\n      adding it won\\'t cause us to break sudoku rules.\\n    */\\n    if (canPlaceValue(board, row, col, charToPlace)) {\\n      board[row][col] = charToPlace;\\n      if (solveSudokuCell(row, col + 1, board)) { // recurse with our VALID placement\\n        return true;\\n      }\\n    }\\n\\n  }\\n\\n  /*\\n    Undo assignment to this cell. No values worked in it meaning that\\n    previous states put us in a position we cannot solve from. Hence,\\n    we backtrack by returning \"false\" to our caller.\\n  */\\n  board[row][col] = EMPTY_ENTRY;\\n  return false; // No valid placement was found, this path is faulty, return false\\n}\\n\\n/*\\n  Will the placement at (row, col) break the Sudoku properties?\\n*/\\nprivate static boolean canPlaceValue(char[][] board, int row, int col, char charToPlace) {\\n\\n  // Check column constraint. For each row, we do a check on column \"col\".\\n  for (char[] element : board) {\\n    if (charToPlace == element[col]){\\n      return false;\\n    }\\n  }\\n\\n  // Check row constraint. For each column in row \"row\", we do a check.\\n  for (int i = 0; i < board.length; i++) {\\n    if (charToPlace == board[row][i]) {\\n      return false;\\n    }\\n  }\\n\\n  /*\\n    Check region constraints.\\n    \\n    In a 9 x 9 board, we will have 9 sub-boxes (3 rows of 3 sub-boxes).\\n    \\n    The \"I\" tells us that we are in the Ith sub-box row. (there are 3 sub-box rows)\\n    The \"J\" tells us that we are in the Jth sub-box column. (there are 3 sub-box columns)\\n    \\n    I tried to think of better variable names for like 20 minutes but couldn\\'t so just left\\n    I and J.\\n    \\n    Integer properties will truncate the decimal place so we just know the sub-box number we are in.\\n    Each coordinate we touch will be found by an offset from topLeftOfSubBoxRow and topLeftOfSubBoxCol.\\n  */\\n  int regionSize = (int) Math.sqrt(board.length); // gives us the size of a sub-box\\n\\n  int I = row / regionSize;\\n  int J = col / regionSize;\\n\\n  /*\\n    This multiplication takes us to the EXACT top left of the sub-box. We keep the (row, col)\\n    of these values because it is important. It lets us traverse the sub-box with our double for loop.\\n  */\\n  int topLeftOfSubBoxRow = regionSize * I; // the row of the top left of the block\\n  int topLeftOfSubBoxCol = regionSize * J; // the column of the tol left of the block\\n\\n  for (int i = 0; i < regionSize; i++) {\\n    for (int j = 0; j < regionSize; j++) {\\n\\n      /*\\n        i and j just define our offsets from topLeftOfBlockRow\\n        and topLeftOfBlockCol respectively\\n      */\\n      if (charToPlace == board[topLeftOfSubBoxRow + i][topLeftOfSubBoxCol + j]) {\\n        return false;\\n      }\\n\\n    }\\n  }\\n\\n  return true; // placement is valid\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15922,
                "title": "two-very-simple-and-neat-c-dfs-backtracking-solutions",
                "content": "1.The first one uses three `2D-array` to check valid. Running time is about 4-8ms.\\n\\n    bool row[9][9]={}, col[9][9]={}, block[9][9]={};\\n    void solveSudoku(vector<vector<char>>& board) {\\n        int num, k;\\n        for (int i=0; i<9; i++) {\\n            for (int j=0; j<9; j++) {\\n                if(board[i][j]!='.') {\\n                    num = board[i][j]-'1'; \\n                    k = i/3*3 + j/3;\\n                    row[i][num] = col[j][num] = block[k][num] = 1;\\n                }\\n            }\\n        }\\n        Helper(board, 0);\\n    }\\n    bool Helper(vector<vector<char>>& b, int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9, num, k;\\n        if(b[i][j]!='.') return Helper(b, ind+1);\\n        else{\\n            for(char f='1'; f<='9'; f++){\\n                num = f-'1'; \\n                k= i/3*3 + j/3;\\n                if(!row[i][num] && !col[j][num] && !block[k][num]){\\n                    b[i][j]= f;\\n                    row[i][num] = col[j][num] = block[k][num] = 1;\\n                    if(Helper(b, ind+1)) return true;                \\n                    b[i][j]='.';\\n                    row[i][num] = col[j][num] = block[k][num] = 0;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n2.The second one check with `board itself`. The code is neat and simple, but it runs so slow. Running time is about 52ms. Copy my own code from [here][1]. And there is the [Java version][2].\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 0);\\n    }\\n    bool helper(vector<vector<char>>& b, int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9;\\n        if(b[i][j]!='.') return helper(b, ind+1);\\n        else{\\n            for(char f = '1'; f <= '9'; f++){\\n                if(isValidFill(b, i, j, f)){\\n                    b[i][j]= f;\\n                    if(helper(b, ind+1)) return true;                \\n                    b[i][j]='.';\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n    bool isValidFill(vector<vector<char>>& b, int i, int j, char fill) {\\n        for(int k=0; k<9; k++){\\n            int r= i/3*3+j/3;   //select the block\\n            if(b[i][k]==fill || b[k][j]==fill || b[r/3*3+k/3][r%3*3+k%3]==fill) \\n                return false; //check row, column, block\\n        }            \\n        return true;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/15808/a-simple-dfs-solution\\n  [2]: https://leetcode.com/discuss/51308/two-very-simple-and-neat-java-dfs-backtracking-solutions",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "1.The first one uses three `2D-array` to check valid. Running time is about 4-8ms.\\n\\n    bool row[9][9]={}, col[9][9]={}, block[9][9]={};\\n    void solveSudoku(vector<vector<char>>& board) {\\n        int num, k;\\n        for (int i=0; i<9; i++) {\\n            for (int j=0; j<9; j++) {\\n                if(board[i][j]!='.') {\\n                    num = board[i][j]-'1'; \\n                    k = i/3*3 + j/3;\\n                    row[i][num] = col[j][num] = block[k][num] = 1;\\n                }\\n            }\\n        }\\n        Helper(board, 0);\\n    }\\n    bool Helper(vector<vector<char>>& b, int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9, num, k;\\n        if(b[i][j]!='.') return Helper(b, ind+1);\\n        else{\\n            for(char f='1'; f<='9'; f++){\\n                num = f-'1'; \\n                k= i/3*3 + j/3;\\n                if(!row[i][num] && !col[j][num] && !block[k][num]){\\n                    b[i][j]= f;\\n                    row[i][num] = col[j][num] = block[k][num] = 1;\\n                    if(Helper(b, ind+1)) return true;                \\n                    b[i][j]='.';\\n                    row[i][num] = col[j][num] = block[k][num] = 0;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n2.The second one check with `board itself`. The code is neat and simple, but it runs so slow. Running time is about 52ms. Copy my own code from [here][1]. And there is the [Java version][2].\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 0);\\n    }\\n    bool helper(vector<vector<char>>& b, int ind){\\n        if(ind==81) return true; \\n        int i=ind/9, j=ind%9;\\n        if(b[i][j]!='.') return helper(b, ind+1);\\n        else{\\n            for(char f = '1'; f <= '9'; f++){\\n                if(isValidFill(b, i, j, f)){\\n                    b[i][j]= f;\\n                    if(helper(b, ind+1)) return true;                \\n                    b[i][j]='.';\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n    bool isValidFill(vector<vector<char>>& b, int i, int j, char fill) {\\n        for(int k=0; k<9; k++){\\n            int r= i/3*3+j/3;   //select the block\\n            if(b[i][k]==fill || b[k][j]==fill || b[r/3*3+k/3][r%3*3+k%3]==fill) \\n                return false; //check row, column, block\\n        }            \\n        return true;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/15808/a-simple-dfs-solution\\n  [2]: https://leetcode.com/discuss/51308/two-very-simple-and-neat-java-dfs-backtracking-solutions",
                "codeTag": "Unknown"
            },
            {
                "id": 3764177,
                "title": "superb-logic-backtracking",
                "content": "# Backtracking\\n```\\nclass Solution:\\n    def solveSudoku(self, grid: List[List[str]]) -> None:\\n        return self.solve(grid)\\n    def solve(self,grid):\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\".\":\\n                    for c in range(1,len(grid)+1):\\n                        c=str(c)\\n                        if self.isvalid(i,j,c,grid):\\n                            grid[i][j]=c\\n                            if self.solve(grid)==True:\\n                                return True\\n                            else:\\n                                grid[i][j]=\".\"\\n                    return False\\n        return True\\n    def isvalid(self,row,col,c,grid):\\n        for i in range(len(grid)):\\n            if grid[row][i]==c:\\n                return False\\n            if grid[i][col]==c:\\n                return False\\n            if grid[(3*(row//3)+i//3)][3*(col//3)+i%3]==c:\\n                return False\\n        return True\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, grid: List[List[str]]) -> None:\\n        return self.solve(grid)\\n    def solve(self,grid):\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\".\":\\n                    for c in range(1,len(grid)+1):\\n                        c=str(c)\\n                        if self.isvalid(i,j,c,grid):\\n                            grid[i][j]=c\\n                            if self.solve(grid)==True:\\n                                return True\\n                            else:\\n                                grid[i][j]=\".\"\\n                    return False\\n        return True\\n    def isvalid(self,row,col,c,grid):\\n        for i in range(len(grid)):\\n            if grid[row][i]==c:\\n                return False\\n            if grid[i][col]==c:\\n                return False\\n            if grid[(3*(row//3)+i//3)][3*(col//3)+i%3]==c:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870321,
                "title": "simple-java-solution-just-40-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  - O( 9^k )\\n  - Where k is no of empty spaces in sudoku board.\\n  \\n\\n- Space complexity:\\n    - Recursion stack O(K)\\n    - Variable Created O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public void solveSudoku(char[][] board) {\\n        solve( board , 0 , 0 );\\n    }\\n\\n    public boolean solve( char[][] board, int row, int col ){\\n\\n        if( row==9 ) return true;\\n        if( col==9 ) return solve( board , row+1, 0 );\\n\\n        if( board[row][col] != \\'.\\'  )  return solve( board , row , col+1 );\\n        \\n\\n        for( int i = \\'1\\'; i<=\\'9\\'; i++ ){\\n        \\n            char c = (char) i;\\n            if( isSafe( board , c, row, col ) ){\\n\\n                board[row][col] = c;\\n                if( solve( board , row , col+1 ) ) return true;\\n                board[row][col] = \\'.\\';\\n\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public boolean isSafe( char[][] board, char toPlace, int x, int y  ){\\n\\n        for( int i=0; i<9; i++ ){\\n            if( board[i][y] == toPlace ) return false;\\n            if( board[x][i] == toPlace ) return false;\\n        }\\n        int v = (x/3) * 3;\\n        int h = (y/3) * 3;\\n\\n        for( int i = v; i<v+3; i++  ){\\n            for( int j = h; j<h+3; j++ ){\\n                if( board[i][j]==toPlace ) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public void solveSudoku(char[][] board) {\\n        solve( board , 0 , 0 );\\n    }\\n\\n    public boolean solve( char[][] board, int row, int col ){\\n\\n        if( row==9 ) return true;\\n        if( col==9 ) return solve( board , row+1, 0 );\\n\\n        if( board[row][col] != \\'.\\'  )  return solve( board , row , col+1 );\\n        \\n\\n        for( int i = \\'1\\'; i<=\\'9\\'; i++ ){\\n        \\n            char c = (char) i;\\n            if( isSafe( board , c, row, col ) ){\\n\\n                board[row][col] = c;\\n                if( solve( board , row , col+1 ) ) return true;\\n                board[row][col] = \\'.\\';\\n\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public boolean isSafe( char[][] board, char toPlace, int x, int y  ){\\n\\n        for( int i=0; i<9; i++ ){\\n            if( board[i][y] == toPlace ) return false;\\n            if( board[x][i] == toPlace ) return false;\\n        }\\n        int v = (x/3) * 3;\\n        int h = (y/3) * 3;\\n\\n        for( int i = v; i<v+3; i++  ){\\n            for( int j = h; j<h+3; j++ ){\\n                if( board[i][j]==toPlace ) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580324,
                "title": "python-3-backtracking",
                "content": "Hey all!\\n\\nThis is my first post. I wanted to share because I had a great conversation with my colleague when explaining my solution.\\n\\nI\\'ve tried to comment and use variable names that are descriptive and think everything speaks for itself - so feel free to jump straight to my solution. Otherwise I\\'ll walk it through here:\\n\\nI started w/ brute force (testing every combination) and thought about the amount of \\'re-analyzing\\' of each row/col that was going on. Seeing the amount of iterations, I thought to instead throw terms in a set and add/remove them as we go on instead of going through each element in a list\\nThe same can be said for the subgrids. I think it is fairly transparent how we can convert the coordinate into a subgrid. \\n\\nI make an initial pass to collect all the information I can about the board - particularly what has already been used in each row, col, and subgrid.\\n\\nHere I set aside some space as well as define \\'moves\\' or `choices` for a sudoku cell\\n```\\nchoices = set({\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'})\\nrows = [set() for _ in range(9)]\\ncols = [set() for _ in range(9)]\\nsub_grid = [[set() for _ in range(3)] for _ in range(3)]\\n```\\n\\nNow I\\'ll populate it with a pass on the board. And while we\\'re at it, we can build a list of \"jobs\" to do. Since there is at most 81 cells, we can say at most there is 81 jobs. So this can be a fixed length with some \"size\" variable but I just had it append. \\n\\n```\\njobs = []\\nfor r, row in enumerate(board):\\n\\tsub_r = int(r / 3)\\n\\tfor c, cell in enumerate(row):\\n\\t\\tsub_c = int(c / 3)\\n\\t\\t# this cell is a number - I should add it to my \\'seen\\' sets          \\n\\t\\tif cell != \".\":\\n\\t\\t\\trows[r].add(cell)\\n\\t\\t\\tcols[c].add(cell)\\n\\t\\t\\tsub_grid[sub_r][sub_c].add(cell)\\n\\t\\t# this cell is something I\\'ll need to fill out myself\\n\\t\\t# I\\'ll add it to my jobs\\n\\t\\telse:\\n\\t\\t\\tjobs.append((r, c))\\n```\\n\\nOnce we have our sets and jobs sorted out, lets try to think about our approach:\\n(We\\'ll end up using backtracking)\\n\\nWhat are my options for a cell? (given r, c)\\nWell I can\\'t using anything found in my rows[r] set\\nand I can\\'t use anything in my cols[c] set\\nnor my sub_grid set for [r/3][c/3]\\n\\nIn other words:\\ngiven what I\\'ve seen in the *row*, *col*, **and** *sub-grid*, what *choices* **remain**?\\n```\\nsub_r = int(r / 3)\\nsub_c = int(c / 3)\\noptions = choices ^ (rows[r] | cols[c] | sub_grid[sub_r][sub_c])\\n```\\n\\nGiven you magically know what the operations are for a set, you can get a list of options to pick from.\\nWe\\'ll wanna try each one - one at a time:\\n```\\nfor op in options:\\n\\t# we\\'ll adopt this option for our grid and sets           \\n\\trows[r].add(op)\\n\\tcols[c].add(op)\\n\\tsub_grid[sub_r][sub_c].add(op)\\n\\tboard[r][c] = op\\n```\\n\\nGiven I\\'ve chosen to adopt this option - what\\'s next?\\n... well the next job.\\nSo lets do the next job\\n```\\nsolve(job_num + 1)\\n```\\nOkay, I\\'ve done a lot of jobs...\\nHow do we know when it\\'s done?\\n\\nWe know we\\'re done when our `job_num` or job index, exceeds what\\'s in our jobs array\\nso let\\'s check that **before** we schedule our next job\\n\\n```\\nif job_num + 1 == len(jobs):\\n\\tself.solved = True                \\nelse: \\n\\tsolve(job_num + 1)\\n```\\n\\nOkay, so lets think about the \\'states\\' of each job/option:\\n\\nLets say there was 2 jobs, `job0` and `job1`:\\nif `job0` was valid, and `job1` said \"I solved it!\" what should `job0` do?\\n`job0` shoud do nothing since it was valid. We have valid options and solved the board - it should quit\\n```\\n# the job ahead of I was solved - the board is done\\nif self.solved: return\\n```\\n\\nif `job1` failed - then that means our choice in `job0` also failed ~ no amount of changing `job1` resulted in a solved board so we ***need*** to try changing something before it (`job1` in this case). \\nThis means we should \\'reset\\' for our next option since we had several options to pick from.\\n```\\n# I\\'ll remove what I inserted since this didn\\'t solve the board\\nrows[r].remove(op)\\ncols[c].remove(op)\\nsub_grid[sub_r][sub_c].remove(op)\\nboard[r][c] = \".\"\\n```\\n\\nGreat! so all that\\'s left to really set this in motion is to start with our first job!\\n```\\nsolve(0)\\n```\\n\\n\\nHere is my full solution:\\n```\\nclass Solution:\\n    \\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        choices = set({\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'})\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        sub_grid = [[set() for _ in range(3)] for _ in range(3)]\\n        # define valid choices for any sudoku cell   \\n        # I will make sets for all numbers I\\'ve seen:               \\n        # in each row\\n        # in each col\\n        # and lastly, in each sub-grid\\n        \\n        jobs = []\\n        # while we\\'re at it, lets add all the empty cells so\\n        # we\\'re not aimlessly guessing which is next\\n        for r, row in enumerate(board):\\n            sub_r = int(r / 3)\\n            for c, cell in enumerate(row):\\n                sub_c = int(c / 3)\\n                # this cell is a number - I should add it to my \\'seen\\' sets          \\n                if cell != \".\":\\n                    rows[r].add(cell)\\n                    cols[c].add(cell)\\n                    sub_grid[sub_r][sub_c].add(cell)\\n                # this cell is something I\\'ll need to fill out myself\\n                # I\\'ll add it to my jobs\\n                else:\\n                    jobs.append((r, c))\\n        \\n        # We\\'ll use backtracking and this boolean will help us know when to stop         \\n        self.solved = False\\n        \\n        # we can kinda think of this as dfs where:\\n        # A cell is the root and 0-9 are branches\\n        # job_num would be what layer we\\'re down\\n        # but more simply, job_num is the number of cells we\\'ve solved\\n        def solve(job_num):\\n            r, c = jobs[job_num]\\n            sub_r = int(r / 3)\\n            sub_c = int(c / 3)\\n            # This is some set opperations - options represents:\\n            # what options do I have if I pick all possible choices \\n            # minus everything found in in rows, cols, and subgrid of this cell?\\n            options = choices ^ (rows[r] | cols[c] | sub_grid[sub_r][sub_c])\\n            \\n            for op in options:\\n                # we\\'ll adopt this option for our grid and sets           \\n                rows[r].add(op)\\n                cols[c].add(op)\\n                sub_grid[sub_r][sub_c].add(op)\\n                board[r][c] = op\\n                \\n                # if that was the last job, we solved it!\\n                if job_num + 1 == len(jobs):\\n                    self.solved = True\\n                    \\n                # if it is not solved (IE more jobs left)\\n                # do the next job                 \\n                else: \\n                    solve(job_num + 1)\\n                    \\n                # if that next job/s solved it, I\\'m also done\\n                if self.solved: return\\n                \\n                # I\\'ll remove what I inserted since this didn\\'t solve the board\\n                rows[r].remove(op)\\n                cols[c].remove(op)\\n                sub_grid[sub_r][sub_c].remove(op)\\n                board[r][c] = \".\"\\n                \\n        # let\\'s start solving from the first job           \\n        solve(0)\\n        \\n        # We\\'re guaranteed a solution so technically we\\'re done\\n        # alternatively - we could check if we did in fact solve it\\n        # if self.solved:\\n        #     return board\\n        # return None\\n                    \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nchoices = set({\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'})\\nrows = [set() for _ in range(9)]\\ncols = [set() for _ in range(9)]\\nsub_grid = [[set() for _ in range(3)] for _ in range(3)]\\n```\n```\\njobs = []\\nfor r, row in enumerate(board):\\n\\tsub_r = int(r / 3)\\n\\tfor c, cell in enumerate(row):\\n\\t\\tsub_c = int(c / 3)\\n\\t\\t# this cell is a number - I should add it to my \\'seen\\' sets          \\n\\t\\tif cell != \".\":\\n\\t\\t\\trows[r].add(cell)\\n\\t\\t\\tcols[c].add(cell)\\n\\t\\t\\tsub_grid[sub_r][sub_c].add(cell)\\n\\t\\t# this cell is something I\\'ll need to fill out myself\\n\\t\\t# I\\'ll add it to my jobs\\n\\t\\telse:\\n\\t\\t\\tjobs.append((r, c))\\n```\n```\\nsub_r = int(r / 3)\\nsub_c = int(c / 3)\\noptions = choices ^ (rows[r] | cols[c] | sub_grid[sub_r][sub_c])\\n```\n```\\nfor op in options:\\n\\t# we\\'ll adopt this option for our grid and sets           \\n\\trows[r].add(op)\\n\\tcols[c].add(op)\\n\\tsub_grid[sub_r][sub_c].add(op)\\n\\tboard[r][c] = op\\n```\n```\\nsolve(job_num + 1)\\n```\n```\\nif job_num + 1 == len(jobs):\\n\\tself.solved = True                \\nelse: \\n\\tsolve(job_num + 1)\\n```\n```\\n# the job ahead of I was solved - the board is done\\nif self.solved: return\\n```\n```\\n# I\\'ll remove what I inserted since this didn\\'t solve the board\\nrows[r].remove(op)\\ncols[c].remove(op)\\nsub_grid[sub_r][sub_c].remove(op)\\nboard[r][c] = \".\"\\n```\n```\\nsolve(0)\\n```\n```\\nclass Solution:\\n    \\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        choices = set({\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'})\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        sub_grid = [[set() for _ in range(3)] for _ in range(3)]\\n        # define valid choices for any sudoku cell   \\n        # I will make sets for all numbers I\\'ve seen:               \\n        # in each row\\n        # in each col\\n        # and lastly, in each sub-grid\\n        \\n        jobs = []\\n        # while we\\'re at it, lets add all the empty cells so\\n        # we\\'re not aimlessly guessing which is next\\n        for r, row in enumerate(board):\\n            sub_r = int(r / 3)\\n            for c, cell in enumerate(row):\\n                sub_c = int(c / 3)\\n                # this cell is a number - I should add it to my \\'seen\\' sets          \\n                if cell != \".\":\\n                    rows[r].add(cell)\\n                    cols[c].add(cell)\\n                    sub_grid[sub_r][sub_c].add(cell)\\n                # this cell is something I\\'ll need to fill out myself\\n                # I\\'ll add it to my jobs\\n                else:\\n                    jobs.append((r, c))\\n        \\n        # We\\'ll use backtracking and this boolean will help us know when to stop         \\n        self.solved = False\\n        \\n        # we can kinda think of this as dfs where:\\n        # A cell is the root and 0-9 are branches\\n        # job_num would be what layer we\\'re down\\n        # but more simply, job_num is the number of cells we\\'ve solved\\n        def solve(job_num):\\n            r, c = jobs[job_num]\\n            sub_r = int(r / 3)\\n            sub_c = int(c / 3)\\n            # This is some set opperations - options represents:\\n            # what options do I have if I pick all possible choices \\n            # minus everything found in in rows, cols, and subgrid of this cell?\\n            options = choices ^ (rows[r] | cols[c] | sub_grid[sub_r][sub_c])\\n            \\n            for op in options:\\n                # we\\'ll adopt this option for our grid and sets           \\n                rows[r].add(op)\\n                cols[c].add(op)\\n                sub_grid[sub_r][sub_c].add(op)\\n                board[r][c] = op\\n                \\n                # if that was the last job, we solved it!\\n                if job_num + 1 == len(jobs):\\n                    self.solved = True\\n                    \\n                # if it is not solved (IE more jobs left)\\n                # do the next job                 \\n                else: \\n                    solve(job_num + 1)\\n                    \\n                # if that next job/s solved it, I\\'m also done\\n                if self.solved: return\\n                \\n                # I\\'ll remove what I inserted since this didn\\'t solve the board\\n                rows[r].remove(op)\\n                cols[c].remove(op)\\n                sub_grid[sub_r][sub_c].remove(op)\\n                board[r][c] = \".\"\\n                \\n        # let\\'s start solving from the first job           \\n        solve(0)\\n        \\n        # We\\'re guaranteed a solution so technically we\\'re done\\n        # alternatively - we could check if we did in fact solve it\\n        # if self.solved:\\n        #     return board\\n        # return None\\n                    \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311631,
                "title": "simple-and-optimized-approach-line-by-line-explanation-of-java-code",
                "content": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board); // Simple backtracking function\\n    }\\n    \\n    public boolean solve(char[][] board){\\n        for(int i=0;i<board.length;i++){ // start traversing from row 0 to 8\\n            for(int j=0;j<board.length;j++){ // Now check for every col in each row\\n                if(board[i][j]==\\'.\\'){  // If \\'.\\' is in that row col then it shows it is empty\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){ // Now we will try to fill from 1 to 9\\n                        if(isValid(board,i,j,c)){ //this function will return true if the corresponding ch is not in row,col,nor in 3x3 matrix\\n                            board[i][j]=c; // if it returns true then we will add c to board\\n                            if(solve(board)){ // Now we will further recurse for next empty space\\n                                return true;  // if this function return true it means that board is completely filled \\n                            }\\n                            else{ // it shows that the c we filled is a deadend and we have to backtrack\\n                                board[i][j]=\\'.\\'; //so we remove that ch\\n                            }\\n                        }\\n                    }\\n                    return false;   if it does return true for any ch 1 to 9 then it means we are in a deadend and we will return false\\n                }\\n            }\\n        }//finally we will return true as we completely filled the matrix\\n        return true;\\n    }\\n    \\n\\t// to check if the corresponding character is valid or not which means the charcater is not in the corresponding row or column or 3x3 matrix\\n\\t// we will check this in only one loop by using 3 formulaes\\n\\t// for row we will keep row constant and change col from 0 to 8 and check if the corresponding character is present or not\\n\\t// for col we will keep col constant and change row from 0 to 8 and check if the corresponding character is present or not\\n\\t// for 3x3 matrix for row it will be 3*(row/3) + i/3\\n\\t// for col = 3*(col/3) + i%3\\n\\t// board[row][col]=c return false\\n\\t// below code will help you understand this\\n\\t\\n\\t\\n    public boolean isValid(char board[][], int row, int col, char ch){\\n        for(int i=0;i<9;i++){\\n            if(board[row][i]==ch){\\n                return false;\\n            }\\n            if(board[i][col]==ch){\\n                return false;\\n            }\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==ch){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board); // Simple backtracking function\\n    }\\n    \\n    public boolean solve(char[][] board){\\n        for(int i=0;i<board.length;i++){ // start traversing from row 0 to 8\\n            for(int j=0;j<board.length;j++){ // Now check for every col in each row\\n                if(board[i][j]==\\'.\\'){  // If \\'.\\' is in that row col then it shows it is empty\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){ // Now we will try to fill from 1 to 9\\n                        if(isValid(board,i,j,c)){ //this function will return true if the corresponding ch is not in row,col,nor in 3x3 matrix\\n                            board[i][j]=c; // if it returns true then we will add c to board\\n                            if(solve(board)){ // Now we will further recurse for next empty space\\n                                return true;  // if this function return true it means that board is completely filled \\n                            }\\n                            else{ // it shows that the c we filled is a deadend and we have to backtrack\\n                                board[i][j]=\\'.\\'; //so we remove that ch\\n                            }\\n                        }\\n                    }\\n                    return false;   if it does return true for any ch 1 to 9 then it means we are in a deadend and we will return false\\n                }\\n            }\\n        }//finally we will return true as we completely filled the matrix\\n        return true;\\n    }\\n    \\n\\t// to check if the corresponding character is valid or not which means the charcater is not in the corresponding row or column or 3x3 matrix\\n\\t// we will check this in only one loop by using 3 formulaes\\n\\t// for row we will keep row constant and change col from 0 to 8 and check if the corresponding character is present or not\\n\\t// for col we will keep col constant and change row from 0 to 8 and check if the corresponding character is present or not\\n\\t// for 3x3 matrix for row it will be 3*(row/3) + i/3\\n\\t// for col = 3*(col/3) + i%3\\n\\t// board[row][col]=c return false\\n\\t// below code will help you understand this\\n\\t\\n\\t\\n    public boolean isValid(char board[][], int row, int col, char ch){\\n        for(int i=0;i<9;i++){\\n            if(board[row][i]==ch){\\n                return false;\\n            }\\n            if(board[i][col]==ch){\\n                return false;\\n            }\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==ch){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304255,
                "title": "c-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<char>>& board,int row,int col,char c)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            if(board[i][col]==c)\\n                return false;\\n            if(board[row][i]==c)\\n                return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board) \\n    {\\n       for(int i=0;i<board.size();i++)\\n       {\\n           for(int j=0;j<board[0].size();j++)\\n           {\\n               if(board[i][j]==\\'.\\')\\n               {\\n                   for(char c=\\'1\\';c<=\\'9\\';c++)\\n                   {\\n                       if(isvalid(board,i,j,c))\\n                       {\\n                           board[i][j]=c;\\n                           if(solve(board))\\n                               return true;\\n                           else\\n                              board[i][j]=\\'.\\';\\n                       }\\n                   }\\n                   return false;\\n               }\\n           }\\n       }\\n       return true;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>>& board) \\n    {\\n        solve(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<char>>& board,int row,int col,char c)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            if(board[i][col]==c)\\n                return false;\\n            if(board[row][i]==c)\\n                return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board) \\n    {\\n       for(int i=0;i<board.size();i++)\\n       {\\n           for(int j=0;j<board[0].size();j++)\\n           {\\n               if(board[i][j]==\\'.\\')\\n               {\\n                   for(char c=\\'1\\';c<=\\'9\\';c++)\\n                   {\\n                       if(isvalid(board,i,j,c))\\n                       {\\n                           board[i][j]=c;\\n                           if(solve(board))\\n                               return true;\\n                           else\\n                              board[i][j]=\\'.\\';\\n                       }\\n                   }\\n                   return false;\\n               }\\n           }\\n       }\\n       return true;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>>& board) \\n    {\\n        solve(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659100,
                "title": "concise-python-solution",
                "content": "Useful tricks to know:\\n1. \\'list(zip(*A))\\' is the [transpose](https://en.wikipedia.org/wiki/Transpose) of A\\n2. for a general matrix, the nth element is at row n // len(col) and col n % len(col)\\n3. in python, setA - setB is equivalent to setA.difference(setB)\\n4. string.digits is equivalent to \\'0123456789\\'\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        def unique_vals(row, col):\\n            transpose = list(map(list, zip(*board)))\\n            colstart, rowstart = (col // 3) * 3, (row // 3) * 3 # topleft corner of each 3 by 3 square\\n            three_by_three = [board[i][j] \\n\\t\\t\\t\\t\\t\\t\\t  for i in range(rowstart, rowstart + 3) \\n\\t\\t\\t\\t\\t\\t\\t  for j in range(colstart, colstart + 3)]\\n            return set(string.digits[1:]) - set(board[row] + transpose[col] + three_by_three) - set(\\'.\\')\\n            \\n        def solve(i):\\n            if i == 81:\\n                return True\\n            row, col = i // 9, i % 9\\n            if board[row][col] == \\'.\\':\\n                for val in unique_vals(row, col):\\n                    board[row][col] = val\\n                    if solve(i + 1):\\n                        return True\\n                    board[row][col] = \\'.\\'\\n            else:\\n                 if solve(i + 1):\\n                    return True\\n            return False\\n\\n        solve(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        def unique_vals(row, col):\\n            transpose = list(map(list, zip(*board)))\\n            colstart, rowstart = (col // 3) * 3, (row // 3) * 3 # topleft corner of each 3 by 3 square\\n            three_by_three = [board[i][j] \\n\\t\\t\\t\\t\\t\\t\\t  for i in range(rowstart, rowstart + 3) \\n\\t\\t\\t\\t\\t\\t\\t  for j in range(colstart, colstart + 3)]\\n            return set(string.digits[1:]) - set(board[row] + transpose[col] + three_by_three) - set(\\'.\\')\\n            \\n        def solve(i):\\n            if i == 81:\\n                return True\\n            row, col = i // 9, i % 9\\n            if board[row][col] == \\'.\\':\\n                for val in unique_vals(row, col):\\n                    board[row][col] = val\\n                    if solve(i + 1):\\n                        return True\\n                    board[row][col] = \\'.\\'\\n            else:\\n                 if solve(i + 1):\\n                    return True\\n            return False\\n\\n        solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021938,
                "title": "simple-and-easily-explained",
                "content": "# Intuition\\nWe have to check for the row, column, and the 3*3 matrix inorder to insert in the particular cell.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Traverse through each cell one by one. Check whether the cell is empty, if empty check for all value which is suitable from 1 to 9 in order to insert value in it,whatever is suitable insert that value. If that value is inserted check again the matrix after inserting .If for no value the cell can be inserted return false.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(9^k), where k is the empty space.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k), recursion stack space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int row, int col, char c, vector<vector<char>>&board)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            if(board[row][i]==c)\\n            {\\n                return false;\\n            }\\n            if(board[i][col]==c)\\n            {\\n                return false;\\n            }\\n           if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j]==\\'.\\')\\n                {\\n                    for(char k=\\'1\\';k<=\\'9\\';k++)\\n                    {\\n                        if(isValid(i, j, k, board))\\n                        {\\n                            board[i][j] = k;\\n                            if(solve(board))\\n                            {\\n                                return true;\\n                            }\\n                            board[i][j]=\\'.\\';\\n                            // return false;\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int row, int col, char c, vector<vector<char>>&board)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            if(board[row][i]==c)\\n            {\\n                return false;\\n            }\\n            if(board[i][col]==c)\\n            {\\n                return false;\\n            }\\n           if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j]==\\'.\\')\\n                {\\n                    for(char k=\\'1\\';k<=\\'9\\';k++)\\n                    {\\n                        if(isValid(i, j, k, board))\\n                        {\\n                            board[i][j] = k;\\n                            if(solve(board))\\n                            {\\n                                return true;\\n                            }\\n                            board[i][j]=\\'.\\';\\n                            // return false;\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690447,
                "title": "python3-straightforward-and-readable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe easiest Method is just trial and error. We do this by finding and empty cell and checking which numbers are available for this cell. Then we input these numbers one by one and traverse deeper continuing this approach recursively until we meet one of the following two cases:\\n\\n1) The grid does not contain empty cells anymore. This means we found a valid solution.\\n2) We have an empty cell, but there are no available numbers any more.\\n\\nIn case of 2) we need to backtrack through the recursion and undo the changes we made to the grid.\\n\\nWe could make this a little fast by starting from position whith the least available numbers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn my approach I tried to keep it readable by splitting the work into small and independent functions.\\n\\nThey are named in a readable manner, so I think one can see the purpose of each of the functions.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is O(N*M) but I\\'m not entirely sure about this one, so I stand corrected.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space is taken by the recursion stack which is O(N*M) in the worst case.\\n\\n# Code\\n```Python\\nclass Solution:\\n\\n    # make a set of possible characters\\n    possible = set(str(nr) for nr in range(1,10))\\n\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        # save the board\\n        self.board = board\\n        self.dfs()\\n    \\n    def dfs(self):\\n\\n        # find the next empty cell\\n        rx, cx, complete = self.findEmpty()\\n\\n        # check whether there are empty cells\\n        if complete:\\n            return True\\n        \\n        # get the available numbers\\n        available = self.getPossible(rx, cx)\\n\\n        # check whether we have available numbers\\n        if not available:\\n            return False\\n        \\n        # go through available numbers and try them\\n        for number in available:\\n\\n            # set the number\\n            self.board[rx][cx] = number\\n\\n            # check whether it works\\n            if self.dfs():\\n                return True\\n            \\n            # reset the number\\n            self.board[rx][cx] = \".\"\\n    \\n        return False\\n\\n    def findEmpty(self):\\n        # find the next free position and if all are filled we can return True\\n        for rx in range(len(self.board)):\\n            for cx in range(len(self.board[0])):\\n                if self.board[rx][cx] == \\'.\\':\\n                    return rx, cx, False\\n        return -1, -1, True\\n\\n    def getPossible(self, rx, cx):\\n        return self.possible - self.getBox(rx, cx) - self.getRow(rx, cx) - self.getCol(rx, cx)\\n\\n    def getRow(self, rx, cx):\\n        return set(self.board[rx])\\n\\n    def getCol(self, rx, cx):\\n        return set([row[cx] for row in self.board])\\n\\n    def getBox(self, rx, cx):\\n        result = set()\\n        for rx in range(rx // 3 * 3, rx // 3 * 3 + 3):\\n            result.update(self.board[rx][cx // 3 * 3:cx // 3 * 3 + 3])\\n        return result\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n\\n    # make a set of possible characters\\n    possible = set(str(nr) for nr in range(1,10))\\n\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        # save the board\\n        self.board = board\\n        self.dfs()\\n    \\n    def dfs(self):\\n\\n        # find the next empty cell\\n        rx, cx, complete = self.findEmpty()\\n\\n        # check whether there are empty cells\\n        if complete:\\n            return True\\n        \\n        # get the available numbers\\n        available = self.getPossible(rx, cx)\\n\\n        # check whether we have available numbers\\n        if not available:\\n            return False\\n        \\n        # go through available numbers and try them\\n        for number in available:\\n\\n            # set the number\\n            self.board[rx][cx] = number\\n\\n            # check whether it works\\n            if self.dfs():\\n                return True\\n            \\n            # reset the number\\n            self.board[rx][cx] = \".\"\\n    \\n        return False\\n\\n    def findEmpty(self):\\n        # find the next free position and if all are filled we can return True\\n        for rx in range(len(self.board)):\\n            for cx in range(len(self.board[0])):\\n                if self.board[rx][cx] == \\'.\\':\\n                    return rx, cx, False\\n        return -1, -1, True\\n\\n    def getPossible(self, rx, cx):\\n        return self.possible - self.getBox(rx, cx) - self.getRow(rx, cx) - self.getCol(rx, cx)\\n\\n    def getRow(self, rx, cx):\\n        return set(self.board[rx])\\n\\n    def getCol(self, rx, cx):\\n        return set([row[cx] for row in self.board])\\n\\n    def getBox(self, rx, cx):\\n        result = set()\\n        for rx in range(rx // 3 * 3, rx // 3 * 3 + 3):\\n            result.update(self.board[rx][cx // 3 * 3:cx // 3 * 3 + 3])\\n        return result\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347530,
                "title": "c-backtracking-with-explanations-easy-to-understand",
                "content": "\\t// each row have digits from 1-9 exactly once  \\n\\t// each col have digits from 1-9 exactly once  \\n\\t// each 3 X 3 matrix have digits from 1-9 exactly once  \\n\\t// Try every possible positon to fill each the empty places and \\n\\t// for each empty place multiple recursion call will be made \\n\\t// let say we have filled some empty cell with some numbr and next recursion is called \\n\\t// for the next empty cell but if we are unable to fill this empty cell then we will return false from // here and it will backtrack and reaches to the prev cell and check for another possibilty\\n\\t// if possible to fill then return true otherwise  change the baord[i][j]=\\'.\\'\\n\\n\\t// Checking whether a position is valid or not means first three conditons fullfilling or not \\n\\t// iterate single time from 1 to 9 and check if board[row][i]==ch or board[i][col]==ch or \\n\\t// board[3*(row/3)+i/3][3*(col/3)+i%3]==ch then return false else return true\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid solveSudoku(vector<vector<char>>& board) {\\n\\t\\t\\tsolve_suduko(board);\\n\\t\\t}\\n\\n\\t\\tbool solve_suduko(vector<vector<char>>& board)\\n\\t\\t{\\n\\t\\t\\tint n=board.size();\\n\\t\\t\\tint m=board[0].size();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(board[i][j]==\\'.\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tfor(char ch=\\'1\\';ch<=\\'9\\';ch++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(isvalid(board,ch,i,j))\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tboard[i][j]=ch;\\n\\t\\t\\t\\t\\t\\t\\t\\tif(solve_suduko(board)) return true;\\n\\t\\t\\t\\t\\t\\t\\t\\telse board[i][j]=\\'.\\'; // backtarck if unable to fill the board\\n\\t\\t\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true; // if there is  no empty cell return true\\n\\t\\t}\\n\\n\\t\\tbool isvalid(vector<vector<char>>& board,char ch,int row,int col)\\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<9;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(board[row][i]==ch) return false;\\n\\t\\t\\t\\tif(board[i][col]==ch) return false;\\n\\t\\t\\t\\tif(board[3*(row/3)+i/3][3*(col/3)+i%3]==ch) return false; // dry run on a 3*3 grid to understand better\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid solveSudoku(vector<vector<char>>& board) {\\n\\t\\t\\tsolve_suduko(board);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 902465,
                "title": "java-backtracking-using-hashmaps",
                "content": "```\\nclass Solution {\\n    Map<Integer, Set<Integer>> rows = new HashMap();\\n    Map<Integer, Set<Integer>> cols = new HashMap();\\n    Map<Integer, Set<Integer>> boxs = new HashMap();\\n    \\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0)\\n            return;        \\n        StoreInitialValues(board);\\n        checkBoardValidity(board,rows,cols,boxs);        \\n    }\\n    \\n    private boolean checkBoardValidity(char[][] board,Map<Integer, Set<Integer>> rows,\\n                                        Map<Integer, Set<Integer>> cols, Map<Integer, Set<Integer>> boxs){\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(int k = 1; k <= 9; k++){\\n                        if(!rows.get(i).contains(k) && !cols.get(j).contains(k) && !boxs.get((i/3) * 3 + j/3).contains(k)){\\n                            \\n                            board[i][j] = (char) (k+\\'0\\');\\n                            rows.get(i).add(k);\\n                            cols.get(j).add(k);\\n                            boxs.get((i/3) * 3 + j/3).add(k);\\n                            \\n                            if(checkBoardValidity(board,rows,cols,boxs))\\n                                return true;\\n                            \\n                            board[i][j] = \\'.\\';\\n                            rows.get(i).remove(k);\\n                            cols.get(j).remove(k);\\n                            boxs.get((i/3) * 3 + j/3).remove(k);\\n                        }\\n                    }\\n                    return false;\\n                }                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private void StoreInitialValues(char[][] board){\\n        for(int i = 0; i < board.length; i++){\\n            rows.put(i,new HashSet());\\n            cols.put(i,new HashSet());\\n            boxs.put(i,new HashSet());\\n        }\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                rows.get(i).add(board[i][j]-\\'0\\');\\n                cols.get(j).add(board[i][j]-\\'0\\');\\n                boxs.get((i/3) * 3 + j/3).add(board[i][j]-\\'0\\');\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Set<Integer>> rows = new HashMap();\\n    Map<Integer, Set<Integer>> cols = new HashMap();\\n    Map<Integer, Set<Integer>> boxs = new HashMap();\\n    \\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0)\\n            return;        \\n        StoreInitialValues(board);\\n        checkBoardValidity(board,rows,cols,boxs);        \\n    }\\n    \\n    private boolean checkBoardValidity(char[][] board,Map<Integer, Set<Integer>> rows,\\n                                        Map<Integer, Set<Integer>> cols, Map<Integer, Set<Integer>> boxs){\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(int k = 1; k <= 9; k++){\\n                        if(!rows.get(i).contains(k) && !cols.get(j).contains(k) && !boxs.get((i/3) * 3 + j/3).contains(k)){\\n                            \\n                            board[i][j] = (char) (k+\\'0\\');\\n                            rows.get(i).add(k);\\n                            cols.get(j).add(k);\\n                            boxs.get((i/3) * 3 + j/3).add(k);\\n                            \\n                            if(checkBoardValidity(board,rows,cols,boxs))\\n                                return true;\\n                            \\n                            board[i][j] = \\'.\\';\\n                            rows.get(i).remove(k);\\n                            cols.get(j).remove(k);\\n                            boxs.get((i/3) * 3 + j/3).remove(k);\\n                        }\\n                    }\\n                    return false;\\n                }                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private void StoreInitialValues(char[][] board){\\n        for(int i = 0; i < board.length; i++){\\n            rows.put(i,new HashSet());\\n            cols.put(i,new HashSet());\\n            boxs.put(i,new HashSet());\\n        }\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                rows.get(i).add(board[i][j]-\\'0\\');\\n                cols.get(j).add(board[i][j]-\\'0\\');\\n                boxs.get((i/3) * 3 + j/3).add(board[i][j]-\\'0\\');\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750403,
                "title": "4ms-c-short-and-clean-solution-faster-than-97-35",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        \\n        for(int i=0; i<9; i++) \\n        {\\n            for(int j=0; j<9; j++)\\n                row[i][j]=col[i][j]=box[i][j]=0;\\n        }\\n        \\n        for(int i=0; i<9; i++) \\n        {\\n            for(int j=0; j<9; j++) \\n            {\\n                int num = board[i][j]-\\'1\\';\\n                if(board[i][j]!=\\'.\\')\\n                    row[i][num]=col[j][num]=box[(i/3)*3+j/3][num]=1;\\n            }\\n        }\\n        \\n        solve(board,0,0);\\n        \\n    }\\n    \\n    int row[9][9], col[9][9], box[9][9];\\n    \\n    bool solve(vector<vector<char>>& board, int x, int y) {\\n        \\n        if(x==8 && y==9)\\n            return true;\\n        else if(y>8)\\n            x++, y=0;\\n        \\n        if(board[x][y]!=\\'.\\')\\n            return solve(board,x,y+1);\\n\\n        for(int num=0; num<9; num++) \\n        {\\n            if(isSafe(num,x,y)) {\\n                row[x][num]=col[y][num]=box[(x/3)*3+y/3][num]=1;\\n                board[x][y] = num + \\'1\\';\\n                if(solve(board,x,y+1))\\n                    return true;\\n                else\\n                {\\n                    row[x][num]=col[y][num]=box[(x/3)*3+y/3][num]=0;\\n                    board[x][y] = \\'.\\';\\n                }  \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool isSafe(int num, int x, int y) {\\n        \\n        return !(row[x][num] || col[y][num] || box[(x/3)*3+y/3][num]);\\n    }\\n    \\n};\\n\\'\\'\\'\\n\\nPls upvote if you find it useful.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        \\n        for(int i=0; i<9; i++) \\n        {\\n            for(int j=0; j<9; j++)\\n                row[i][j]=col[i][j]=box[i][j]=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 734304,
                "title": "extremely-simple-cpp-solution-with-excessive-comments-and-line-by-line-explanation",
                "content": "```\\nclass Solution \\n{\\npublic:\\n\\tbool isValid(vector<vector<char>>& board, int row , int column, char c) \\n\\t{\\n        //checking all columns in a given ROW\\n\\t\\tfor (int i = 0; i < 9; ++i)\\n\\t\\t\\tif (board[row][i] == c) return false;\\n        //checking all rows in a given COLUMN\\n\\t\\tfor (int j = 0; j < 9; ++j)\\n\\t\\t\\tif (board[j][column] == c) return false;\\n        //checking the 3*3 matrix starting from given ROW and COLUMN\\n\\t\\tfor (int i = 0; i < 3; ++i)\\n\\t\\t\\tfor (int j = 0; j < 3; ++j)\\n\\t\\t\\t\\tif (board[row / 3 * 3 + i][column / 3 * 3 + j] == c)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n\\tbool solve(vector<vector<char>>& board) \\n\\t{\\n        //traversing the given board\\n\\t\\tfor (int i = 0; i < 9; ++i)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < 9; ++j)\\n\\t\\t\\t{\\n                //if location is unassigned\\n\\t\\t\\t\\tif (\\'.\\' == board[i][j]) \\n\\t\\t\\t\\t{\\n                    //we can put 1 to 9 at unassigned locatiom\\n\\t\\t\\t\\t\\tfor (int k = 0; k < 9; ++k)\\n\\t\\t\\t\\t\\t{\\n                        //checking we can put k or not [ means already present or not]\\n\\t\\t\\t\\t\\t\\tif (isValid(board, i, j, \\'1\\' + k)) \\n\\t\\t\\t\\t\\t\\t{\\n                            //adding in a hope to get done\\n\\t\\t\\t\\t\\t\\t\\tboard[i][j] = \\'1\\' + k;\\n                            //if solvable. yipieee return 1\\n\\t\\t\\t\\t\\t\\t\\tif (solve(board)) return true;\\n                            //else cry over your choice and trty other option\\n\\t\\t\\t\\t\\t\\t\\telse board[i][j] = \\'.\\';\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n                    //if we cant assign any number from 1 to 9 at that specified i and j\\n                    //location return 0;\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 1;\\n\\t}\\n\\tvoid solveSudoku(vector<vector<char>>& board) \\n\\t{\\n\\t\\tsolve(board);\\n\\t}\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\npublic:\\n\\tbool isValid(vector<vector<char>>& board, int row , int column, char c) \\n\\t{\\n        //checking all columns in a given ROW\\n\\t\\tfor (int i = 0; i < 9; ++i)\\n\\t\\t\\tif (board[row][i] == c) return false;\\n        //checking all rows in a given COLUMN\\n\\t\\tfor (int j = 0; j < 9; ++j)\\n\\t\\t\\tif (board[j][column] == c) return false;\\n        //checking the 3*3 matrix starting from given ROW and COLUMN\\n\\t\\tfor (int i = 0; i < 3; ++i)\\n\\t\\t\\tfor (int j = 0; j < 3; ++j)\\n\\t\\t\\t\\tif (board[row / 3 * 3 + i][column / 3 * 3 + j] == c)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 568151,
                "title": "python-straightforward-and-clear-recursive-backtracking-solution",
                "content": "```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        def can_place(i, j, num):\\n            # Check row\\n            if any(num == n for n in board[i]):\\n                return False\\n            \\n            # Check col\\n            if any(num == n for n in list(zip(*board))[j]):\\n                return False\\n            \\n            # Check box\\n            start_row, start_col = (i // 3) * 3, (j // 3) * 3\\n            for r in range(start_row, start_row + 3):\\n                for c in range(start_col, start_col + 3):\\n                    if num == board[r][c]:\\n                        return False\\n            return True\\n        \\n        def find_unassigned():\\n            for r in range(len(board)):\\n                for c in range(len(board[0])):\\n                    if board[r][c] == \\'.\\':\\n                        return r, c\\n            return -1, -1\\n        \\n        def solve():\\n            r, c = find_unassigned()\\n            \\n            if r == -1 and c == -1:\\n                return True\\n            \\n            for num in [str(n) for n in range(1, 10)]:\\n                if can_place(r, c, num):\\n                    board[r][c] = num\\n                    if solve():\\n                        return True\\n                    board[r][c] = \\'.\\'\\n            return False\\n\\t\\t\\n        if not board:\\n            return\\n        solve()\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        def can_place(i, j, num):\\n            # Check row\\n            if any(num == n for n in board[i]):\\n                return False\\n            \\n            # Check col\\n            if any(num == n for n in list(zip(*board))[j]):\\n                return False\\n            \\n            # Check box\\n            start_row, start_col = (i // 3) * 3, (j // 3) * 3\\n            for r in range(start_row, start_row + 3):\\n                for c in range(start_col, start_col + 3):\\n                    if num == board[r][c]:\\n                        return False\\n            return True\\n        \\n        def find_unassigned():\\n            for r in range(len(board)):\\n                for c in range(len(board[0])):\\n                    if board[r][c] == \\'.\\':\\n                        return r, c\\n            return -1, -1\\n        \\n        def solve():\\n            r, c = find_unassigned()\\n            \\n            if r == -1 and c == -1:\\n                return True\\n            \\n            for num in [str(n) for n in range(1, 10)]:\\n                if can_place(r, c, num):\\n                    board[r][c] = num\\n                    if solve():\\n                        return True\\n                    board[r][c] = \\'.\\'\\n            return False\\n\\t\\t\\n        if not board:\\n            return\\n        solve()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377997,
                "title": "javascript-solution",
                "content": "```\\nvar solveSudoku = function(board) {\\n  solver(board);\\n};\\n\\nconst solver = board => {\\n  for (let i = 0; i < 9; i++) {\\n    for (let j = 0; j < 9; j++) {\\n      if (board[i][j] === \".\") {\\n        let char = \"1\";\\n        while (+char <= 9) {\\n          if (isValidSudoku(i, j, board, char)) {\\n            board[i][j] = char;\\n            if (solver(board)) {\\n              return true;\\n            } else {\\n              board[i][j] = \".\";\\n            }\\n          }\\n          char = (+char + 1).toString();\\n        }\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n\\nconst isValidSudoku = (row, col, board, char) => {\\n  for (let i = 0; i < 9; i++) {\\n    if (board[row][i] == char) {\\n      return false;\\n    }\\n  }\\n\\n  for (let i = 0; i < 9; i++) {\\n    if (board[i][col] == char) {\\n      return false;\\n    }\\n  }\\n\\n  const x = ~~(row / 3) * 3;\\n  const y = ~~(col / 3) * 3;\\n  for (let i = 0; i < 3; i++) {\\n    for (let j = 0; j < 3; j++) {\\n      if (board[x + i][y + j] == char) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  return true;\\n};\\n```\\n\\nreferenced from https://leetcode.wang/leetCode-37-Sudoku-Solver.html",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar solveSudoku = function(board) {\\n  solver(board);\\n};\\n\\nconst solver = board => {\\n  for (let i = 0; i < 9; i++) {\\n    for (let j = 0; j < 9; j++) {\\n      if (board[i][j] === \".\") {\\n        let char = \"1\";\\n        while (+char <= 9) {\\n          if (isValidSudoku(i, j, board, char)) {\\n            board[i][j] = char;\\n            if (solver(board)) {\\n              return true;\\n            } else {\\n              board[i][j] = \".\";\\n            }\\n          }\\n          char = (+char + 1).toString();\\n        }\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n\\nconst isValidSudoku = (row, col, board, char) => {\\n  for (let i = 0; i < 9; i++) {\\n    if (board[row][i] == char) {\\n      return false;\\n    }\\n  }\\n\\n  for (let i = 0; i < 9; i++) {\\n    if (board[i][col] == char) {\\n      return false;\\n    }\\n  }\\n\\n  const x = ~~(row / 3) * 3;\\n  const y = ~~(col / 3) * 3;\\n  for (let i = 0; i < 3; i++) {\\n    for (let j = 0; j < 3; j++) {\\n      if (board[x + i][y + j] == char) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15956,
                "title": "80ms-python-code-use-dfs-with-choice",
                "content": "    class Solution:\\n    # @param board, a 9x9 2D array\\n    # Solve the Sudoku by modifying the input board in-place.\\n    # Do not return any value.\\n    def solveSudoku(self, board):\\n        res = self.dfs(board)\\n        for n, row in enumerate(res):\\n            board[n] = ''.join(row)\\n\\n    def dfs(self, board):\\n        stack = [board]\\n        while stack:\\n            s = stack.pop()\\n            result = self.fill_board(s)\\n            if result == 'complete':\\n                return s\\n            for r in result:\\n                stack.append(r)\\n                \\n    def fill_board(self, board):\\n        digits = set('123456789')\\n        choice, best = {}, []\\n        for j in range(9):\\n            for i in range(9):\\n                if board[j][i] == '.':\\n                    square = {board[j//3*3+y][i//3*3+x]\\n                              for y in range(3) for x in range(3)}\\n                    row = {board[j][x] for x in range(9)}\\n                    col = {board[y][i] for y in range(9)}\\n                    rest = digits.difference(square, row, col)\\n                    if len(rest) == 1:\\n                        board[j][i] = rest.pop()\\n                        return self.fill_board(board)\\n                    elif len(rest) == 0:\\n                        return ''\\n                    else:\\n                        choice[(j, i)] = rest\\n        if not choice:\\n            return 'complete'\\n        y, x = min(choice, key=lambda k: len(choice[k]))\\n        for n in choice[(y, x)]:\\n            b = copy.deepcopy(board)\\n            b[y][x] = n\\n            best.append(b)\\n        return best\\n\\n\\nEvery time we find a '.', we store the possible numbers we can choice in a dict,\\n\\nif the possible numbers is only one, we fill the board first and refill the board from beginning,\\n\\nand last , we choose a position where the possible numbers is least to continue search",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    # @param board, a 9x9 2D array\\n    # Solve the Sudoku by modifying the input board in-place.\\n    # Do not return any value.\\n    def solveSudoku(self, board):\\n        res = self.dfs(board)\\n        for n, row in enumerate(res):\\n            board[n] = ''.join(row)\\n\\n    def dfs(self, board):\\n        stack = [board]\\n        while stack:\\n            s = stack.pop()\\n            result = self.fill_board(s)\\n            if result == 'complete':\\n                return s\\n            for r in result:\\n                stack.append(r)\\n                \\n    def fill_board(self, board):\\n        digits = set('123456789')\\n        choice, best = {}",
                "codeTag": "Java"
            },
            {
                "id": 3996728,
                "title": "java-striver",
                "content": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0) return;\\n        solve(board);\\n    }\\n    public boolean solve(char[][] board){\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c=\\'1\\'; c<=\\'9\\'; c++){ //try all number from 1 to 9\\n                        if(isValid(board, i, j, c)){\\n                            board[i][j] = c; //put c for this cell\\n                            \\n                            if(solve(board)) return true; //If it\\'s the solution return true\\n                            else board[i][j] = \\'.\\';  //Otherwise go back\\n                        }  \\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isValid(char [][] board, int row, int col, char c){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] != \\'.\\' && board[i][col] == c) return false; //check row\\n            if(board[row][i] != \\'.\\' && board[row][i] == c) return false; //check column\\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3] != \\'.\\' && \\n               board[3*(row/3) + i/3][3*(col/3) + i%3] == c) return false; //check 3*3block\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0) return;\\n        solve(board);\\n    }\\n    public boolean solve(char[][] board){\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c=\\'1\\'; c<=\\'9\\'; c++){ //try all number from 1 to 9\\n                        if(isValid(board, i, j, c)){\\n                            board[i][j] = c; //put c for this cell\\n                            \\n                            if(solve(board)) return true; //If it\\'s the solution return true\\n                            else board[i][j] = \\'.\\';  //Otherwise go back\\n                        }  \\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isValid(char [][] board, int row, int col, char c){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] != \\'.\\' && board[i][col] == c) return false; //check row\\n            if(board[row][i] != \\'.\\' && board[row][i] == c) return false; //check column\\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3] != \\'.\\' && \\n               board[3*(row/3) + i/3][3*(col/3) + i%3] == c) return false; //check 3*3block\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622243,
                "title": "beats-99-27-c-c-solves-via-backtracking-bool-arrays-in-3-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nEach placement needs exactly 3 of these conditions !\\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse backtracking to solve!\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/wviWrbbOdYE](https://youtu.be/wviWrbbOdYE)\\n```\\n  .  .  9  7  4  8  .  .  .\\n  7  .  .  .  .  .  .  .  .\\n  .  2  .  1  .  9  .  .  .\\n  .  .  7  .  .  .  2  4  .\\n  .  6  4  .  1  .  5  9  .\\n  .  9  8  .  .  .  3  .  .\\n  .  .  .  8  .  3  .  2  .\\n  .  .  .  .  .  .  .  .  6\\n  .  .  .  2  7  5  9  .  .\\n============\\n  5  1  9  7  4  8  6  3  2\\n  7  8  3  6  5  2  4  1  9\\n  4  2  6  1  3  9  8  7  5\\n  3  5  7  9  8  6  2  4  1\\n  2  6  4  3  1  7  5  9  8\\n  1  9  8  5  2  4  3  6  7\\n  9  7  5  8  6  3  1  2  4\\n  8  3  2  4  9  1  7  5  6\\n  6  4  1  2  7  5  9  8  3\\n============\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ code Runtime 16 ms Beats 92.40%, C solution runtime: 14 ms\\n```C []\\nbool Col[9][9];\\nbool Row[9][9];\\nbool Block[9][9];\\n\\nvoid set3Cond(int i, int j, int x, bool val) {\\n    Row[i][x] = val;\\n    Col[j][x] = val;\\n    int bidx = (i / 3) * 3 + j / 3;\\n    Block[bidx][x] = val;\\n}\\n\\nvoid setup(char** board) {\\n    memset(Col, 0, sizeof(Col));\\n    memset(Row, 0, sizeof(Row));\\n    memset(Block, 0, sizeof(Block));\\n    for (int i = 0; i < 9; i++) {\\n        for (int j = 0; j < 9; j++) {\\n            char c = board[i][j];\\n            if (c == \\'.\\') continue;\\n            int x = (c - \\'0\\') % 9;\\n            set3Cond(i, j, x, 1);\\n        }\\n    }\\n}\\n\\nbool isValid(char** board, int i, int j, char c) {\\n    int x = (c - \\'0\\') % 9;\\n    return !Row[i][x] && !Col[j][x] && !Block[(i / 3) * 3 + j / 3][x];\\n}\\n\\nbool solve(char** board) {\\n    for (int i = 0; i < 9; i++) {\\n        for (int j = 0; j < 9; j++) {\\n            if (board[i][j] == \\'.\\') {\\n                for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                    if (isValid(board, i, j, c)) {\\n                        board[i][j] = c;\\n                        int x = (c - \\'0\\') % 9;\\n                        set3Cond(i, j, x, 1);\\n\\n                        if (solve(board))\\n                            return true;\\n\\n                        // Backtracking\\n                        board[i][j] = \\'.\\';\\n                        set3Cond(i, j, x, 0);\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nvoid solveSudoku(char** board, int boardSize, int* boardColSize) {\\n    setup(board);\\n    solve(board);\\n}\\n```\\n```C++ []\\nclass Solution {\\n    bool Col[9][9]={0};\\n    bool Row[9][9]={0};\\n    bool Block[9][9]={0};\\n\\npublic:\\n\\tvoid set3Cond(int i, int j,  int x, bool val=1){\\n\\t\\tRow[i][x] = val;\\n        Col[j][x] = val;\\n        int bidx = (i/3)*3 +j/3;\\n        Block[bidx][x] = val;\\n\\t}\\n\\t\\n\\tvoid setup(vector<vector<char>>& board){\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n            \\n                char c = board[i][j];\\n                if (c == \\'.\\') continue;\\n        \\t\\t\\n\\t\\t\\t\\tint x=(c-\\'0\\')%9; \\n                set3Cond(i, j, x);\\n        \\t}\\t\\n    \\t}\\t\\n\\t}\\n\\t\\n\\tvoid print(vector<vector<char>>& board){\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) \\n            \\tcout<<board[i][j];\\n            cout<<endl;\\n    \\t}\\n\\t\\tcout<<\"============\\\\n\";\\t\\n\\t} \\n\\t\\n    bool solve(vector<vector<char>>& board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                        if (isValid(board, i, j, c)) {\\n                            board[i][j] = c;\\n                            int x=(c-\\'0\\')%9; \\n                \\t\\t\\tset3Cond(i, j, x);\\n\\n                            if (solve(board)) \\n                                return 1;\\n\\n                            // Backtracking\\n                            board[i][j] = \\'.\\';\\n                \\t\\t\\tset3Cond(i, j, x, 0);\\n                        }\\n                    }\\n                    return 0;\\n                }\\n            }\\n        }  \\n        return 1; \\n    }\\n\\n    bool isValid(vector<vector<char>>& board, int i, int j, char c) {\\n    \\tint x=(c-\\'0\\')%9;\\n        return !Row[i][x] && !Col[j][x] && !Block[(i/3)*3+j/3][x];\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n    //\\tprint(board);\\n    \\tsetup(board);\\n        solve(board);\\n    //  print(board);\\n    }\\n};\\n```\\n# Using vector<pair<int, int>> as a stack to store the uncertain places is faster!!!!!\\n# It needs 11 ms and beats Beats 94.36%\\n```\\nclass Solution {\\n\\tbitset<9> Row[9];\\n    bitset<9> Col[9];\\n    bitset<9> Block[9];\\n    vector<pair<int, int>> uncertain;\\npublic:\\n     void print(vector<vector<char>>& board){\\n        for(vector<char>& row: board){\\n            for(char& c: row)\\n                cout<<c;\\n            cout<<endl;\\n        }\\n        cout<<\"===========\\\\n\";\\n    }\\n    void set3Cond(int i, int j,  int x, bool val=1){\\n\\t\\tRow[i][x] = val;\\n        Col[j][x] = val;\\n        int bidx = (i/3)*3 +j/3;\\n        Block[bidx][x] = val;\\n\\t}\\n\\n    void setup(vector<vector<char>>& board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char c=board[i][j];\\n                if ( c== \\'.\\') {\\n                    uncertain.push_back({i, j});\\n                }\\n                else {\\n                    int x=(c-\\'0\\')%9; \\n                    set3Cond(i, j, x);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool solve(vector<vector<char>>& board) \\n    {\\n        if (uncertain.empty()) \\n            return 1; \\n        auto it=prev(uncertain.end());\\n        auto [i, j]=*it;\\n        for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(i, j, c)) {\\n                board[i][j] = c;\\n                uncertain.pop_back();\\n \\n                int x=(c-\\'0\\')%9; \\n                set3Cond(i, j, x);\\n\\t\\t\\t\\t\\n                if (solve(board)) \\n                    return 1;\\n\\n                board[i][j] = \\'.\\'; // trace back\\n                uncertain.push_back({i, j});\\n                set3Cond(i, j, x, 0);\\n            }\\n        }\\n        return 0; \\n    }\\n\\n    bool isValid(int row, int col, char c) {\\n    \\tint x=(c-\\'0\\')%9;\\n        return !Row[row][x] && !Col[col][x] && !Block[(row/3)*3+col/3][x];\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n    //    print(board);\\n        setup(board);\\n        solve(board);\\n    //    print(board);\\n    }\\n};\\n```\\n# 3rd Version Runtime 3 ms beats 99.27%\\n```\\nclass Solution {\\n\\tbool Row[9][9];\\n    bool Col[9][9];\\n    bool Block[9][9];\\n    vector<pair<int, int>> uncertain;\\npublic:\\n     void print(vector<vector<char>>& board){\\n        for(vector<char>& row: board){\\n            for(char& c: row)\\n                cout<<c;\\n            cout<<endl;\\n        }\\n        cout<<\"===========\\\\n\";\\n    }\\n    void set3Cond(int i, int j,  int x, bool val=1){\\n\\t\\tRow[i][x] = val;\\n        Col[j][x] = val;\\n        int bidx = (i/3)*3 +j/3;\\n        Block[bidx][x] = val;\\n\\t}\\n\\n    void setup(vector<vector<char>>& board) {\\n        uncertain.reserve(81);\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char c=board[i][j];\\n                if ( c== \\'.\\') {\\n                    uncertain.push_back({i, j});\\n                }\\n                else {\\n                    int x=(c-\\'0\\')%9; \\n                    set3Cond(i, j, x);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool solve(vector<vector<char>>& board) \\n    {\\n        if (uncertain.empty()) \\n            return 1; \\n        auto [i, j]=uncertain.back();\\n        for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(i, j, c)) {\\n                board[i][j] = c;\\n                uncertain.pop_back();\\n \\n                int x=(c-\\'0\\')%9; \\n                set3Cond(i, j, x);\\n\\t\\t\\t\\t\\n                if (solve(board)) \\n                    return 1;\\n\\n                board[i][j] = \\'.\\'; // trace back\\n                uncertain.push_back({i, j});\\n                set3Cond(i, j, x, 0);\\n            }\\n        }\\n        return 0; \\n    }\\n\\n    bool isValid(int row, int col, char c) {\\n    \\tint x=(c-\\'0\\')%9;\\n        return !Row[row][x] && !Col[col][x] && !Block[(row/3)*3+col/3][x];\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n    //    print(board);\\n        setup(board);\\n        solve(board);\\n    //    print(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n  .  .  9  7  4  8  .  .  .\\n  7  .  .  .  .  .  .  .  .\\n  .  2  .  1  .  9  .  .  .\\n  .  .  7  .  .  .  2  4  .\\n  .  6  4  .  1  .  5  9  .\\n  .  9  8  .  .  .  3  .  .\\n  .  .  .  8  .  3  .  2  .\\n  .  .  .  .  .  .  .  .  6\\n  .  .  .  2  7  5  9  .  .\\n============\\n  5  1  9  7  4  8  6  3  2\\n  7  8  3  6  5  2  4  1  9\\n  4  2  6  1  3  9  8  7  5\\n  3  5  7  9  8  6  2  4  1\\n  2  6  4  3  1  7  5  9  8\\n  1  9  8  5  2  4  3  6  7\\n  9  7  5  8  6  3  1  2  4\\n  8  3  2  4  9  1  7  5  6\\n  6  4  1  2  7  5  9  8  3\\n============\\n```\n```C []\\nbool Col[9][9];\\nbool Row[9][9];\\nbool Block[9][9];\\n\\nvoid set3Cond(int i, int j, int x, bool val) {\\n    Row[i][x] = val;\\n    Col[j][x] = val;\\n    int bidx = (i / 3) * 3 + j / 3;\\n    Block[bidx][x] = val;\\n}\\n\\nvoid setup(char** board) {\\n    memset(Col, 0, sizeof(Col));\\n    memset(Row, 0, sizeof(Row));\\n    memset(Block, 0, sizeof(Block));\\n    for (int i = 0; i < 9; i++) {\\n        for (int j = 0; j < 9; j++) {\\n            char c = board[i][j];\\n            if (c == \\'.\\') continue;\\n            int x = (c - \\'0\\') % 9;\\n            set3Cond(i, j, x, 1);\\n        }\\n    }\\n}\\n\\nbool isValid(char** board, int i, int j, char c) {\\n    int x = (c - \\'0\\') % 9;\\n    return !Row[i][x] && !Col[j][x] && !Block[(i / 3) * 3 + j / 3][x];\\n}\\n\\nbool solve(char** board) {\\n    for (int i = 0; i < 9; i++) {\\n        for (int j = 0; j < 9; j++) {\\n            if (board[i][j] == \\'.\\') {\\n                for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                    if (isValid(board, i, j, c)) {\\n                        board[i][j] = c;\\n                        int x = (c - \\'0\\') % 9;\\n                        set3Cond(i, j, x, 1);\\n\\n                        if (solve(board))\\n                            return true;\\n\\n                        // Backtracking\\n                        board[i][j] = \\'.\\';\\n                        set3Cond(i, j, x, 0);\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nvoid solveSudoku(char** board, int boardSize, int* boardColSize) {\\n    setup(board);\\n    solve(board);\\n}\\n```\n```C++ []\\nclass Solution {\\n    bool Col[9][9]={0};\\n    bool Row[9][9]={0};\\n    bool Block[9][9]={0};\\n\\npublic:\\n\\tvoid set3Cond(int i, int j,  int x, bool val=1){\\n\\t\\tRow[i][x] = val;\\n        Col[j][x] = val;\\n        int bidx = (i/3)*3 +j/3;\\n        Block[bidx][x] = val;\\n\\t}\\n\\t\\n\\tvoid setup(vector<vector<char>>& board){\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n            \\n                char c = board[i][j];\\n                if (c == \\'.\\') continue;\\n        \\t\\t\\n\\t\\t\\t\\tint x=(c-\\'0\\')%9; \\n                set3Cond(i, j, x);\\n        \\t}\\t\\n    \\t}\\t\\n\\t}\\n\\t\\n\\tvoid print(vector<vector<char>>& board){\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) \\n            \\tcout<<board[i][j];\\n            cout<<endl;\\n    \\t}\\n\\t\\tcout<<\"============\\\\n\";\\t\\n\\t} \\n\\t\\n    bool solve(vector<vector<char>>& board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                        if (isValid(board, i, j, c)) {\\n                            board[i][j] = c;\\n                            int x=(c-\\'0\\')%9; \\n                \\t\\t\\tset3Cond(i, j, x);\\n\\n                            if (solve(board)) \\n                                return 1;\\n\\n                            // Backtracking\\n                            board[i][j] = \\'.\\';\\n                \\t\\t\\tset3Cond(i, j, x, 0);\\n                        }\\n                    }\\n                    return 0;\\n                }\\n            }\\n        }  \\n        return 1; \\n    }\\n\\n    bool isValid(vector<vector<char>>& board, int i, int j, char c) {\\n    \\tint x=(c-\\'0\\')%9;\\n        return !Row[i][x] && !Col[j][x] && !Block[(i/3)*3+j/3][x];\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n    //\\tprint(board);\\n    \\tsetup(board);\\n        solve(board);\\n    //  print(board);\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\tbitset<9> Row[9];\\n    bitset<9> Col[9];\\n    bitset<9> Block[9];\\n    vector<pair<int, int>> uncertain;\\npublic:\\n     void print(vector<vector<char>>& board){\\n        for(vector<char>& row: board){\\n            for(char& c: row)\\n                cout<<c;\\n            cout<<endl;\\n        }\\n        cout<<\"===========\\\\n\";\\n    }\\n    void set3Cond(int i, int j,  int x, bool val=1){\\n\\t\\tRow[i][x] = val;\\n        Col[j][x] = val;\\n        int bidx = (i/3)*3 +j/3;\\n        Block[bidx][x] = val;\\n\\t}\\n\\n    void setup(vector<vector<char>>& board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char c=board[i][j];\\n                if ( c== \\'.\\') {\\n                    uncertain.push_back({i, j});\\n                }\\n                else {\\n                    int x=(c-\\'0\\')%9; \\n                    set3Cond(i, j, x);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool solve(vector<vector<char>>& board) \\n    {\\n        if (uncertain.empty()) \\n            return 1; \\n        auto it=prev(uncertain.end());\\n        auto [i, j]=*it;\\n        for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(i, j, c)) {\\n                board[i][j] = c;\\n                uncertain.pop_back();\\n \\n                int x=(c-\\'0\\')%9; \\n                set3Cond(i, j, x);\\n\\t\\t\\t\\t\\n                if (solve(board)) \\n                    return 1;\\n\\n                board[i][j] = \\'.\\'; // trace back\\n                uncertain.push_back({i, j});\\n                set3Cond(i, j, x, 0);\\n            }\\n        }\\n        return 0; \\n    }\\n\\n    bool isValid(int row, int col, char c) {\\n    \\tint x=(c-\\'0\\')%9;\\n        return !Row[row][x] && !Col[col][x] && !Block[(row/3)*3+col/3][x];\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n    //    print(board);\\n        setup(board);\\n        solve(board);\\n    //    print(board);\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\tbool Row[9][9];\\n    bool Col[9][9];\\n    bool Block[9][9];\\n    vector<pair<int, int>> uncertain;\\npublic:\\n     void print(vector<vector<char>>& board){\\n        for(vector<char>& row: board){\\n            for(char& c: row)\\n                cout<<c;\\n            cout<<endl;\\n        }\\n        cout<<\"===========\\\\n\";\\n    }\\n    void set3Cond(int i, int j,  int x, bool val=1){\\n\\t\\tRow[i][x] = val;\\n        Col[j][x] = val;\\n        int bidx = (i/3)*3 +j/3;\\n        Block[bidx][x] = val;\\n\\t}\\n\\n    void setup(vector<vector<char>>& board) {\\n        uncertain.reserve(81);\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char c=board[i][j];\\n                if ( c== \\'.\\') {\\n                    uncertain.push_back({i, j});\\n                }\\n                else {\\n                    int x=(c-\\'0\\')%9; \\n                    set3Cond(i, j, x);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool solve(vector<vector<char>>& board) \\n    {\\n        if (uncertain.empty()) \\n            return 1; \\n        auto [i, j]=uncertain.back();\\n        for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(i, j, c)) {\\n                board[i][j] = c;\\n                uncertain.pop_back();\\n \\n                int x=(c-\\'0\\')%9; \\n                set3Cond(i, j, x);\\n\\t\\t\\t\\t\\n                if (solve(board)) \\n                    return 1;\\n\\n                board[i][j] = \\'.\\'; // trace back\\n                uncertain.push_back({i, j});\\n                set3Cond(i, j, x, 0);\\n            }\\n        }\\n        return 0; \\n    }\\n\\n    bool isValid(int row, int col, char c) {\\n    \\tint x=(c-\\'0\\')%9;\\n        return !Row[row][x] && !Col[col][x] && !Block[(row/3)*3+col/3][x];\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n    //    print(board);\\n        setup(board);\\n        solve(board);\\n    //    print(board);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3216467,
                "title": "java-solution-recursion",
                "content": "Try 1 through 9 for each cell. The time complexity should be 9 ^ 9, since each blank can have 9 choices. This problem works based on Backtracking and recursion.\\n# Code\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        sodoku(board);\\n    }\\n    boolean sodoku(char board[][])\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j] == \\'.\\')\\n                {\\n                    for(char c=\\'1\\';c<=\\'9\\';c++) //  Try 1 through 9.\\n                    {\\n                        if(isValid(board, i, j, c)) // checks the validity of that number.\\n                        {\\n                            board[i][j] = c; // //Put c for current cell.\\n                        \\n                            if(sodoku(board)) // //If it\\'s the solution return true.\\n                            return true;\\n                            else\\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n     boolean isValid(char[][] board, int row, int col, char c){\\n        for(int i = 0; i < 9; i++) {\\n            if(board[i][col] != \\'.\\' && board[i][col] == c)\\n            return false; \\n            if(board[row][i] != \\'.\\' && board[row][i] == c)\\n             return false; \\n            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != \\'.\\' && \\nboard[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) \\n            return false; \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        sodoku(board);\\n    }\\n    boolean sodoku(char board[][])\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j] == \\'.\\')\\n                {\\n                    for(char c=\\'1\\';c<=\\'9\\';c++) //  Try 1 through 9.\\n                    {\\n                        if(isValid(board, i, j, c)) // checks the validity of that number.\\n                        {\\n                            board[i][j] = c; // //Put c for current cell.\\n                        \\n                            if(sodoku(board)) // //If it\\'s the solution return true.\\n                            return true;\\n                            else\\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n     boolean isValid(char[][] board, int row, int col, char c){\\n        for(int i = 0; i < 9; i++) {\\n            if(board[i][col] != \\'.\\' && board[i][col] == c)\\n            return false; \\n            if(board[row][i] != \\'.\\' && board[row][i] == c)\\n             return false; \\n            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != \\'.\\' && \\nboard[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) \\n            return false; \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128908,
                "title": "recursion-backtracking-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe loop throughout the matrix to check for blank spaces and try to fill the blank space with digits [1-9] according to rules.\\n\\n# Complexity\\n- Time complexity: $$O(9^(n*n))$$\\n\\n- Space complexity: $$O(n^2)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n\\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n\\n                //Check if any blank spaces\\n                if(board[i][j] == \\'.\\'){\\n                //Check if valid value can be inserted\\n                    for(char c=\\'1\\';c<=\\'9\\'; c++){\\n                        if(isValid(board,i,j,c)){\\n                            board[i][j] = c;\\n                            if(solve(board) == true) return true;\\n                            else board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool isValid(vector<vector<char>>& board,int row,int col,char c){\\n        for(int i=0;i<9;i++){\\n            //Check if same value in column\\n            if(board[row][i] == c) return false;\\n            //Check if same value in row\\n            if(board[i][col] == c) return false;\\n            //Check if same value in [3x3] matrix \\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n\\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n\\n                //Check if any blank spaces\\n                if(board[i][j] == \\'.\\'){\\n                //Check if valid value can be inserted\\n                    for(char c=\\'1\\';c<=\\'9\\'; c++){\\n                        if(isValid(board,i,j,c)){\\n                            board[i][j] = c;\\n                            if(solve(board) == true) return true;\\n                            else board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool isValid(vector<vector<char>>& board,int row,int col,char c){\\n        for(int i=0;i<9;i++){\\n            //Check if same value in column\\n            if(board[row][i] == c) return false;\\n            //Check if same value in row\\n            if(board[i][col] == c) return false;\\n            //Check if same value in [3x3] matrix \\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762192,
                "title": "java-solution-sodoku-solver",
                "content": "**Runtime: 16 ms\\nMemory Usage: 39.5 MB***\\n\\n```\\nclass Solution {\\n    char[][] res_board;\\n    public void solveSudoku(char[][] board) {\\n        backtrack(board, 0, 0);\\n        board = res_board;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int i, int j) {\\n        int m = 9, n = 9;\\n        \\n        if (j == n) {\\n            return backtrack(board, i + 1, 0);\\n        }\\n        if (i == m) {\\n            res_board = board;\\n            return true;\\n        }\\n\\n        if (board[i][j] != \\'.\\') {\\n            return backtrack(board, i, j + 1);\\n        } \\n\\n        for (char ch = \\'1\\'; ch <= \\'9\\'; ch++) {\\n            if (!isValid(board, i, j, ch))\\n                continue;\\n\\n            board[i][j] = ch;\\n            if (backtrack(board, i, j + 1)) {\\n                return true;\\n            }\\n            board[i][j] = \\'.\\';\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isValid(char[][] board, int r, int c, char n) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[r][i] == n) return false;\\n            if (board[i][c] == n) return false;\\n            if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == n)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    char[][] res_board;\\n    public void solveSudoku(char[][] board) {\\n        backtrack(board, 0, 0);\\n        board = res_board;\\n    }\\n    \\n    private boolean backtrack(char[][] board, int i, int j) {\\n        int m = 9, n = 9;\\n        \\n        if (j == n) {\\n            return backtrack(board, i + 1, 0);\\n        }\\n        if (i == m) {\\n            res_board = board;\\n            return true;\\n        }\\n\\n        if (board[i][j] != \\'.\\') {\\n            return backtrack(board, i, j + 1);\\n        } \\n\\n        for (char ch = \\'1\\'; ch <= \\'9\\'; ch++) {\\n            if (!isValid(board, i, j, ch))\\n                continue;\\n\\n            board[i][j] = ch;\\n            if (backtrack(board, i, j + 1)) {\\n                return true;\\n            }\\n            board[i][j] = \\'.\\';\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isValid(char[][] board, int r, int c, char n) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[r][i] == n) return false;\\n            if (board[i][c] == n) return false;\\n            if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == n)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498783,
                "title": "99-86-better-memory-simple-short-clean-with-comments-python-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKED!**\\n```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        self.solve(board)\\n    \\n    def solve(self, board: List[List[str]])->bool:\\n        for r in range(len(board[0])): # solve row by row\\n            for c in range(len(board)):\\n                if board[r][c]==\".\": # if place vacant\\n                    for i in range(1,10): # try putting 1-9 numbers 1 by 1\\n                        if self.isValid(str(i), r, c, board): # CONSTRAIN\\n                            board[r][c]= str(i) # Make CHOICE\\n                            if self.solve(board): # solve this new Sudoku\\n                                return True\\n                            else:\\n                                board[r][c]=\".\" # undo CHOICE\\n                    return False            \\n        return True # GOAL - all vacant places filled\\n    \\n            \\n    def isValid(self, n:str, r:int, c:int, board: List[List[str]])->bool:\\n        for i in range(9):\\n            # check row, column, particular sub box\\n            if board[r][i]==n or board[i][c]==n or board[3*(r//3)+(i//3)][3*(c//3)+(i%3)]==n:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        self.solve(board)\\n    \\n    def solve(self, board: List[List[str]])->bool:\\n        for r in range(len(board[0])): # solve row by row\\n            for c in range(len(board)):\\n                if board[r][c]==\".\": # if place vacant\\n                    for i in range(1,10): # try putting 1-9 numbers 1 by 1\\n                        if self.isValid(str(i), r, c, board): # CONSTRAIN\\n                            board[r][c]= str(i) # Make CHOICE\\n                            if self.solve(board): # solve this new Sudoku\\n                                return True\\n                            else:\\n                                board[r][c]=\".\" # undo CHOICE\\n                    return False            \\n        return True # GOAL - all vacant places filled\\n    \\n            \\n    def isValid(self, n:str, r:int, c:int, board: List[List[str]])->bool:\\n        for i in range(9):\\n            # check row, column, particular sub box\\n            if board[r][i]==n or board[i][c]==n or board[3*(r//3)+(i//3)][3*(c//3)+(i%3)]==n:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261919,
                "title": "c-simple-easy-solution-sudoku-solver",
                "content": "class Solution {\\n\\nprivate:\\n  bool solve(vector < vector < char >> & board) {\\n     for (int i = 0; i < board.size(); i++) {\\n       for (int j = 0; j < board[0].size(); j++) {\\n          if (board[i][j] == \\'.\\') {\\n            for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n             if (isValid(board, i, j, c)) {\\n               board[i][j] = c;\\n\\n               if (solve(board))\\n                  return true;\\n               else\\n                  board[i][j] = \\'.\\';\\n          }\\n        }\\n\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n}\\nbool isValid(vector < vector < char >> & board, int row, int col, char c) {\\n  for (int i = 0; i < 9; i++) {\\n    if (board[i][col] == c)\\n      return false;\\n\\n    if (board[row][i] == c)\\n      return false;\\n\\n    if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n      return false;\\n  }\\n  return true;\\n}\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);     \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\nprivate:\\n  bool solve(vector < vector < char >> & board) {\\n     for (int i = 0; i < board.size(); i++) {\\n       for (int j = 0; j < board[0].size(); j++) {\\n          if (board[i][j] == \\'.\\') {\\n            for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n             if (isValid(board, i, j, c)) {\\n               board[i][j] = c;\\n\\n               if (solve(board))\\n                  return true;\\n               else\\n                  board[i][j] = \\'.\\';\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2108504,
                "title": "simple-backtracking-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<char>>&board, int row, int col, char num){\\n        for(int i=0; i<9;i++){\\n            if(board[i][col]==num)\\n                return false;\\n        }\\n        for(int i=0; i<9;i++){\\n            if(board[row][i]==num)\\n                return false;\\n        }\\n        int r=(row/3)*3;\\n        int c=(col/3)*3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(board[r+i][j+c]==num)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool answer(vector<vector<char>>&board, int i, int j){\\n        if(j==9){\\n            i=i+1;\\n           j=0;\\n        }\\n        if(i==9)\\n            return true;\\n        if(board[i][j]==\\'.\\'){\\n            for(char c=\\'1\\'; c<=\\'9\\'; c++){\\n                if(isvalid(board, i,j,c)){\\n                    board[i][j]=c;\\n                    if(answer(board,i,j+1)==true){\\n                        return true;\\n                    }\\n                    board[i][j]=\\'.\\';\\n                }\\n            }\\n        }\\n        else{\\n            if(answer(board,i,j+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>>& board) {\\n        bool ass=answer(board,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<char>>&board, int row, int col, char num){\\n        for(int i=0; i<9;i++){\\n            if(board[i][col]==num)\\n                return false;\\n        }\\n        for(int i=0; i<9;i++){\\n            if(board[row][i]==num)\\n                return false;\\n        }\\n        int r=(row/3)*3;\\n        int c=(col/3)*3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(board[r+i][j+c]==num)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool answer(vector<vector<char>>&board, int i, int j){\\n        if(j==9){\\n            i=i+1;\\n           j=0;\\n        }\\n        if(i==9)\\n            return true;\\n        if(board[i][j]==\\'.\\'){\\n            for(char c=\\'1\\'; c<=\\'9\\'; c++){\\n                if(isvalid(board, i,j,c)){\\n                    board[i][j]=c;\\n                    if(answer(board,i,j+1)==true){\\n                        return true;\\n                    }\\n                    board[i][j]=\\'.\\';\\n                }\\n            }\\n        }\\n        else{\\n            if(answer(board,i,j+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>>& board) {\\n        bool ass=answer(board,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037740,
                "title": "java-backtracking-easy-to-understand",
                "content": "**Please Upvote if you understood:(\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E**\\n```\\nclass Solution {\\n    private boolean isSafe(char[][] board,int i,int j,int c){\\n        for (int p = 0; p < 9; p++) {\\n            if(board[p][j]==c)\\n                return false;\\n        }\\n        for (int p = 0; p < 9; p++) {\\n            if(board[i][p]==c)\\n                return false;\\n        }\\n\\n        int row = i-i%3;\\n        int col = j-j%3;\\n        for(int p = row;p<row+3;p++){\\n            for(int q = col;q<col+3;q++){\\n                if(board[p][q] == c){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean dfs(char[][] board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]==\\'.\\'){\\n                    for(char k=\\'1\\';k<=\\'9\\';k++){\\n                        if(isSafe(board,i,j,k)){\\n                            board[i][j] = k;\\n                            if(dfs(board))\\n                                return true;\\n                            else\\n                                board[i][j]=\\'.\\';\\n                        }\\n                        \\n                    }\\n                    // this is bcoz we are unable to generate a valid sudoko with all the possible explorations.\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public void solveSudoku(char[][] board) {\\n        if(board.length==0) {\\n            return;\\n        }\\n        dfs(board);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    private boolean isSafe(char[][] board,int i,int j,int c){\\n        for (int p = 0; p < 9; p++) {\\n            if(board[p][j]==c)\\n                return false;\\n        }\\n        for (int p = 0; p < 9; p++) {\\n            if(board[i][p]==c)\\n                return false;\\n        }\\n\\n        int row = i-i%3;\\n        int col = j-j%3;\\n        for(int p = row;p<row+3;p++){\\n            for(int q = col;q<col+3;q++){\\n                if(board[p][q] == c){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean dfs(char[][] board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]==\\'.\\'){\\n                    for(char k=\\'1\\';k<=\\'9\\';k++){\\n                        if(isSafe(board,i,j,k)){\\n                            board[i][j] = k;\\n                            if(dfs(board))\\n                                return true;\\n                            else\\n                                board[i][j]=\\'.\\';\\n                        }\\n                        \\n                    }\\n                    // this is bcoz we are unable to generate a valid sudoko with all the possible explorations.\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public void solveSudoku(char[][] board) {\\n        if(board.length==0) {\\n            return;\\n        }\\n        dfs(board);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720752,
                "title": "recursion-backtracking-well-optimized-easy-one",
                "content": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n    \\n    bool solve(vector<vector<char>>& board){\\n        for(int i = 0 ; i < board.size() ; i++){\\n            for(int j = 0 ; j < board[0].size() ; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c = \\'1\\' ; c <= \\'9\\' ; c++){\\n                        if(is_valid(board, i, j, c)){\\n                            board[i][j] = c;\\n                            if(solve(board)) return true;\\n                            else board[i][j] =\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool is_valid(vector<vector<char>>& board, int row, int col, char c){\\n        for(int i = 0 ; i < 9 ; i++){\\n            if(board[i][col] == c) return false;\\n            if(board[row][i] == c) return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n    \\n    bool solve(vector<vector<char>>& board){\\n        for(int i = 0 ; i < board.size() ; i++){\\n            for(int j = 0 ; j < board[0].size() ; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c = \\'1\\' ; c <= \\'9\\' ; c++){\\n                        if(is_valid(board, i, j, c)){\\n                            board[i][j] = c;\\n                            if(solve(board)) return true;\\n                            else board[i][j] =\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool is_valid(vector<vector<char>>& board, int row, int col, char c){\\n        for(int i = 0 ; i < 9 ; i++){\\n            if(board[i][col] == c) return false;\\n            if(board[row][i] == c) return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352808,
                "title": "c-solution-with-proper-comments",
                "content": "\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board);\\n    }\\n    bool helper(vector<vector<char>>& board){\\n        for(int i = 0; i< board.size(); i++){// traverse through each row\\n            for(int j =0; j < board[0].size(); j++){//traverse through each column\\n                //and if found and empty point (.) on the board\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c = \\'1\\'; c <= \\'9\\'; c++)//possible values could be from 1 to 9\\n                    if(ispossible(i, j, c, board)){//if the char c we choose is valid cal recursively to check upon another\\n                        board[i][j] = c;\\n                        if(helper(board) == true){\\n                            return true;\\n                        }else{\\n                            board[i][j] = \\'.\\'; // c is not valid \\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool ispossible(int row , int col, char c, vector<vector<char>>& board){\\n        for(int i =0; i< 9; i++){\\n            if(board[i][col] == c){ // row check\\n                return false; // this char c is not valid hence must be present at row \\n            }\\n            if(board[row][i] == c){ // col check\\n                return false; // char c is present at some col \\n            }\\n            //3* 3 sqaure check of the condition \\n            //Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\\n            if(board[3* (row/ 3) + i/3][3* (col/ 3) + i%3] == c ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board);\\n    }\\n    bool helper(vector<vector<char>>& board){\\n        for(int i = 0; i< board.size(); i++){// traverse through each row\\n            for(int j =0; j < board[0].size(); j++){//traverse through each column\\n                //and if found and empty point (.) on the board\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c = \\'1\\'; c <= \\'9\\'; c++)//possible values could be from 1 to 9\\n                    if(ispossible(i, j, c, board)){//if the char c we choose is valid cal recursively to check upon another\\n                        board[i][j] = c;\\n                        if(helper(board) == true){\\n                            return true;\\n                        }else{\\n                            board[i][j] = \\'.\\'; // c is not valid \\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool ispossible(int row , int col, char c, vector<vector<char>>& board){\\n        for(int i =0; i< 9; i++){\\n            if(board[i][col] == c){ // row check\\n                return false; // this char c is not valid hence must be present at row \\n            }\\n            if(board[row][i] == c){ // col check\\n                return false; // char c is present at some col \\n            }\\n            //3* 3 sqaure check of the condition \\n            //Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\\n            if(board[3* (row/ 3) + i/3][3* (col/ 3) + i%3] == c ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273481,
                "title": "javascript-30-lines-beats-99-in-memory",
                "content": "```\\nvar solveSudoku = function(board) {\\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board.length; j++) {\\n            if (board[i][j] === \\'.\\') {\\n                for (let l = 1; l < 10; l++) {\\n                    if (isValid(board, i, j, l.toString())) {\\n                        board[i][j] = l.toString()\\n                        let solved = solveSudoku(board)\\n                        if (solved !== false) return solved   // if we never hit false outside this loop then it means the board is a solution\\n                        board[i][j] = \\'.\\'                     // if it was false then reset the value\\n                    }\\n                }\\n                return false                                  // if we exit the for loop it means there was no solution so return false\\n            }\\n        }\\n    }\\n    return board\\n};\\n\\nfunction isValid(board, i, j, l) {\\n    for (let p = 0; p < board.length; p++) {\\n        if (board[i][p] === l) return false\\n        if (board[p][j] === l) return false\\n        \\n        let gridVal = board[3 * Math.floor(i/3) + Math.floor(p/3)][3 * Math.floor(j/3) + p % 3]\\n        // 3 * Math.floor(i/3) and 3 * Math.floor(j/3) are the coordinates for \\n\\t\\t// the top-left square of the 3x3 grid that the value is in\\n        if (gridVal === l) return false\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvar solveSudoku = function(board) {\\n    for (let i = 0; i < board.length; i++) {\\n        for (let j = 0; j < board.length; j++) {\\n            if (board[i][j] === \\'.\\') {\\n                for (let l = 1; l < 10; l++) {\\n                    if (isValid(board, i, j, l.toString())) {\\n                        board[i][j] = l.toString()\\n                        let solved = solveSudoku(board)\\n                        if (solved !== false) return solved   // if we never hit false outside this loop then it means the board is a solution\\n                        board[i][j] = \\'.\\'                     // if it was false then reset the value\\n                    }\\n                }\\n                return false                                  // if we exit the for loop it means there was no solution so return false\\n            }\\n        }\\n    }\\n    return board\\n};\\n\\nfunction isValid(board, i, j, l) {\\n    for (let p = 0; p < board.length; p++) {\\n        if (board[i][p] === l) return false\\n        if (board[p][j] === l) return false\\n        \\n        let gridVal = board[3 * Math.floor(i/3) + Math.floor(p/3)][3 * Math.floor(j/3) + p % 3]\\n        // 3 * Math.floor(i/3) and 3 * Math.floor(j/3) are the coordinates for \\n\\t\\t// the top-left square of the 3x3 grid that the value is in\\n        if (gridVal === l) return false\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684864,
                "title": "python-clean-code-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n\\t\\t## Similar to Leetcode : 51. N Queens, 36. Valid Sudoku ##\\n\\t\\t## Time Complexity: O(9^(m * n))\\n        ## Space Complexity: O(m*n)\\n\\t\\n        n = len(board)        \\n        rows= [set() for _ in range(n)]\\n        cols = [set() for _ in range(n)]\\n        grids = [set() for _ in range(n)]\\n        \\n        def add_val_to_board(row, col, val):\\n            rows[row].add( val )\\n            cols[col].add( val )\\n            grids[(row//3)*3+ (col//3)].add( val )\\n            board[row][col] = str(val)\\n            \\n        def remove_val_from_board(row, col, val):\\n            rows[row].remove( val )\\n            cols[col].remove( val )\\n            grids[(row//3)*3+ (col//3)].remove( val )\\n            board[row][col] = \".\"\\n        \\n        def fill_board(row, col, val, board):\\n            \\n            if( row < 0 or col < 0 or row >= n or col >= n ):\\n                return\\n            \\n            ## GIST, incrementing row and col here\\n            while not board[row][col] == \\'.\\':\\n                col += 1\\n                if col == 9: \\n                    col, row = 0, row+1\\n                if row == 9: \\n                    return True\\n                \\n            for val in range( 1, n+1 ):\\n                if( val in rows[row] or val in cols[col] or val in grids[(row//3)*3+ (col//3)]):\\n                    continue\\n                    \\n                add_val_to_board(row, col, val)\\n\\n                if( fill_board(row, col, val, board) ):\\n                    return board\\n                \\n                remove_val_from_board(row, col, val)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if( not board[i][j] == \".\" ):\\n                    add_val_to_board( i, j, int(board[i][j]) )\\n        \\n        return fill_board(0, 0, board[0][0], board)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n\\t\\t## Similar to Leetcode : 51. N Queens, 36. Valid Sudoku ##\\n\\t\\t## Time Complexity: O(9^(m * n))\\n        ## Space Complexity: O(m*n)\\n\\t\\n        n = len(board)        \\n        rows= [set() for _ in range(n)]\\n        cols = [set() for _ in range(n)]\\n        grids = [set() for _ in range(n)]\\n        \\n        def add_val_to_board(row, col, val):\\n            rows[row].add( val )\\n            cols[col].add( val )\\n            grids[(row//3)*3+ (col//3)].add( val )\\n            board[row][col] = str(val)\\n            \\n        def remove_val_from_board(row, col, val):\\n            rows[row].remove( val )\\n            cols[col].remove( val )\\n            grids[(row//3)*3+ (col//3)].remove( val )\\n            board[row][col] = \".\"\\n        \\n        def fill_board(row, col, val, board):\\n            \\n            if( row < 0 or col < 0 or row >= n or col >= n ):\\n                return\\n            \\n            ## GIST, incrementing row and col here\\n            while not board[row][col] == \\'.\\':\\n                col += 1\\n                if col == 9: \\n                    col, row = 0, row+1\\n                if row == 9: \\n                    return True\\n                \\n            for val in range( 1, n+1 ):\\n                if( val in rows[row] or val in cols[col] or val in grids[(row//3)*3+ (col//3)]):\\n                    continue\\n                    \\n                add_val_to_board(row, col, val)\\n\\n                if( fill_board(row, col, val, board) ):\\n                    return board\\n                \\n                remove_val_from_board(row, col, val)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if( not board[i][j] == \".\" ):\\n                    add_val_to_board( i, j, int(board[i][j]) )\\n        \\n        return fill_board(0, 0, board[0][0], board)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679004,
                "title": "optimised-from-28ms-20ms-12ms-8ms-c",
                "content": "**Update:** Attached **Bonus Version** for people who find hard to understand Bit Manipulation.\\n**Status**:  Accepted (28ms Code) \\n**Approach**: Backtracking and  bit manipulation to validate it. (Less Mem)\\nThere are 4 versions of code. I will upload the first & final version codes along with changed part in remaining versions.\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<int> row, col, box;\\n    bool dfs(vector<vector<char>> & board){\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch = \\'1\\'; ch <= \\'9\\'; ch++){\\n                        if(isValid(ch, i, j)){\\n                            board[i][j] = ch;\\n                            int index = 1 << ch - \\'0\\';\\n                            row[i] |= index; col[j] |= index; box[i / 3 * 3 + j / 3] |= index;  \\n                            if(dfs(board)){\\n                                return true;\\n                            }\\n                            else{\\n                                row[i] ^= index; col[j] ^= index; box[i / 3 * 3 + j / 3] ^= index;\\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isValid(char c, int i, int j){\\n        int index = 1 << (c - \\'0\\');\\n        if(row[i] & index || col[j] & index ||  box[i / 3 * 3 + j / 3] & index){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        m = board.size(), n = board[0].size();\\n        row.resize(9, 0); col.resize(9,0); box.resize(9,0);\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    int index = 1 << num;\\n                    row[i] |= index;\\n                    col[j] |= index;\\n                    box[i / 3 * 3 + j / 3] |= index;  \\n                }\\n        dfs(board);\\n    }\\n};\\n```\\n**Status**:  Accepted (20ms Code)\\nRemoving a else part which i found useless, reduced run time from 28ms to 20ms.  If anyone know how? Please comment down.\\n```\\nVersion1:\\n                            if(dfs(board)){\\n                                return true;\\n                            }\\n                            else{\\n                                row[i] ^= index; col[j] ^= index; box[i / 3 * 3 + j / 3] ^= index;\\n                                board[i][j] = \\'.\\';\\n                            }\\n\\t\\t\\t\\t\\t\\t\\t\\nVersion 2:\\n\\t\\t\\t\\t\\t\\t\\tif(dfs(board)){\\n                                return true;\\n                            }\\n                            \\n                            row[i] ^= index; col[j] ^= index; box[i / 3 * 3 + j / 3] ^= index;\\n                            board[i][j] = \\'.\\';\\n```\\n**Status:** Accepted ( 12ms )\\nEvery time I fill an empty block with a number (i.e make a choise) and then I traverse the board from (0,0) position. In return I can traverse from the row where i made the choise.\\n```\\nVersion 1 & 2:\\n\\t\\t\\t\\t\\t\\tbool dfs(vector<vector<char>> & board){\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = 0; i < m; i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(board[i][j] == \\'.\\'){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t...................\\n\\t\\t\\nVersion 3:\\n\\t\\t\\t\\t\\t\\tbool dfs(vector<vector<char>> & board, int x){\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = x; i < m; i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(board[i][j] == \\'.\\'){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t....................\\n```\\n**Status:** Accepted (8ms)\\nNot a great optimisation though. We have to start the backtracking from row which contains the first unfilled cell.\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<int> row, col, box;\\n    bool dfs(vector<vector<char>> & board, int x){\\n        for(int i = x; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch = \\'1\\'; ch <= \\'9\\'; ch++){\\n                        if(isValid(ch, i, j)){\\n                            board[i][j] = ch;\\n                            int index = 1 << (ch - \\'0\\');\\n                            row[i] |= index; col[j] |= index; box[i / 3 * 3 + j / 3] |= index;  \\n                            \\n                            if(dfs(board, i)){\\n                                return true;\\n                            }\\n\\n                            row[i] ^= index; col[j] ^= index; box[i / 3 * 3 + j / 3] ^= index;\\n                            board[i][j] = \\'.\\';\\n                            \\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isValid(char c, int i, int j){\\n        int index = 1 << (c - \\'0\\');\\n        if(row[i] & index || col[j] & index ||  box[i / 3 * 3 + j / 3] & index){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        m = board.size(), n = board[0].size();\\n        row.resize(9, 0); col.resize(9,0); box.resize(9,0);\\n        int startPos;\\n        bool firstDot = false;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!firstDot && board[i][j] == \\'.\\'){\\n                    startPos = i;\\n                    firstDot = true;\\n                }\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    int index = 1 << num;\\n                    row[i] |= index;\\n                    col[j] |= index;\\n                    box[i / 3 * 3 + j / 3] |= index;  \\n                }\\n            }\\n        }\\n        dfs(board, startPos);\\n    }\\n};\\n```\\n**Bonus Version:** Similar Approach + Validation using 2D - array to help people who feel hard to understand Bit Manipulation.\\n**Status:** Accepted (8ms)\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int row[10][10], col[10][10], box[10][10];\\n    bool dfs(vector<vector<char>> & board, int x){\\n        for(int i = x; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch = \\'1\\'; ch <= \\'9\\'; ch++){\\n                        if(isValid(ch, i, j)){\\n                            board[i][j] = ch;\\n                            int num = ch - \\'0\\';\\n                            row[i][num] = 1, col[j][num] = 1, box[i /3 * 3 + j /3][num] = 1; \\n                            \\n                            if(dfs(board, i)){\\n                                return true;\\n                            }\\n\\n                            row[i][num] = 0, col[j][num] = 0, box[i /3 * 3 + j /3][num] = 0; \\n                            board[i][j] = \\'.\\';\\n                            \\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isValid(char c, int i, int j){\\n        int num = c - \\'0\\';\\n        if(row[i][num] || col[j][num] ||  box[i / 3 * 3 + j / 3][num]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        m = board.size(), n = board[0].size();\\n        memset(row, 0, sizeof(row));\\n        memset(col, 0, sizeof(col));\\n        memset(box, 0, sizeof(box));\\n        int startPos;\\n        bool firstDot = false;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!firstDot && board[i][j] == \\'.\\'){\\n                    startPos = i;\\n                    firstDot = true;\\n                }\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    row[i][num] = 1;\\n                    col[j][num] = 1;\\n                    box[i / 3 * 3 + j / 3][num] = 1;\\n                }\\n            }\\n        }\\n        dfs(board, startPos);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<int> row, col, box;\\n    bool dfs(vector<vector<char>> & board){\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch = \\'1\\'; ch <= \\'9\\'; ch++){\\n                        if(isValid(ch, i, j)){\\n                            board[i][j] = ch;\\n                            int index = 1 << ch - \\'0\\';\\n                            row[i] |= index; col[j] |= index; box[i / 3 * 3 + j / 3] |= index;  \\n                            if(dfs(board)){\\n                                return true;\\n                            }\\n                            else{\\n                                row[i] ^= index; col[j] ^= index; box[i / 3 * 3 + j / 3] ^= index;\\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isValid(char c, int i, int j){\\n        int index = 1 << (c - \\'0\\');\\n        if(row[i] & index || col[j] & index ||  box[i / 3 * 3 + j / 3] & index){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        m = board.size(), n = board[0].size();\\n        row.resize(9, 0); col.resize(9,0); box.resize(9,0);\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    int index = 1 << num;\\n                    row[i] |= index;\\n                    col[j] |= index;\\n                    box[i / 3 * 3 + j / 3] |= index;  \\n                }\\n        dfs(board);\\n    }\\n};\\n```\n```\\nVersion1:\\n                            if(dfs(board)){\\n                                return true;\\n                            }\\n                            else{\\n                                row[i] ^= index; col[j] ^= index; box[i / 3 * 3 + j / 3] ^= index;\\n                                board[i][j] = \\'.\\';\\n                            }\\n\\t\\t\\t\\t\\t\\t\\t\\nVersion 2:\\n\\t\\t\\t\\t\\t\\t\\tif(dfs(board)){\\n                                return true;\\n                            }\\n                            \\n                            row[i] ^= index; col[j] ^= index; box[i / 3 * 3 + j / 3] ^= index;\\n                            board[i][j] = \\'.\\';\\n```\n```\\nVersion 1 & 2:\\n\\t\\t\\t\\t\\t\\tbool dfs(vector<vector<char>> & board){\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = 0; i < m; i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(board[i][j] == \\'.\\'){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t...................\\n\\t\\t\\nVersion 3:\\n\\t\\t\\t\\t\\t\\tbool dfs(vector<vector<char>> & board, int x){\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int i = x; i < m; i++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif(board[i][j] == \\'.\\'){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t....................\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<int> row, col, box;\\n    bool dfs(vector<vector<char>> & board, int x){\\n        for(int i = x; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch = \\'1\\'; ch <= \\'9\\'; ch++){\\n                        if(isValid(ch, i, j)){\\n                            board[i][j] = ch;\\n                            int index = 1 << (ch - \\'0\\');\\n                            row[i] |= index; col[j] |= index; box[i / 3 * 3 + j / 3] |= index;  \\n                            \\n                            if(dfs(board, i)){\\n                                return true;\\n                            }\\n\\n                            row[i] ^= index; col[j] ^= index; box[i / 3 * 3 + j / 3] ^= index;\\n                            board[i][j] = \\'.\\';\\n                            \\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isValid(char c, int i, int j){\\n        int index = 1 << (c - \\'0\\');\\n        if(row[i] & index || col[j] & index ||  box[i / 3 * 3 + j / 3] & index){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        m = board.size(), n = board[0].size();\\n        row.resize(9, 0); col.resize(9,0); box.resize(9,0);\\n        int startPos;\\n        bool firstDot = false;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!firstDot && board[i][j] == \\'.\\'){\\n                    startPos = i;\\n                    firstDot = true;\\n                }\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    int index = 1 << num;\\n                    row[i] |= index;\\n                    col[j] |= index;\\n                    box[i / 3 * 3 + j / 3] |= index;  \\n                }\\n            }\\n        }\\n        dfs(board, startPos);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int row[10][10], col[10][10], box[10][10];\\n    bool dfs(vector<vector<char>> & board, int x){\\n        for(int i = x; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch = \\'1\\'; ch <= \\'9\\'; ch++){\\n                        if(isValid(ch, i, j)){\\n                            board[i][j] = ch;\\n                            int num = ch - \\'0\\';\\n                            row[i][num] = 1, col[j][num] = 1, box[i /3 * 3 + j /3][num] = 1; \\n                            \\n                            if(dfs(board, i)){\\n                                return true;\\n                            }\\n\\n                            row[i][num] = 0, col[j][num] = 0, box[i /3 * 3 + j /3][num] = 0; \\n                            board[i][j] = \\'.\\';\\n                            \\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isValid(char c, int i, int j){\\n        int num = c - \\'0\\';\\n        if(row[i][num] || col[j][num] ||  box[i / 3 * 3 + j / 3][num]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        m = board.size(), n = board[0].size();\\n        memset(row, 0, sizeof(row));\\n        memset(col, 0, sizeof(col));\\n        memset(box, 0, sizeof(box));\\n        int startPos;\\n        bool firstDot = false;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!firstDot && board[i][j] == \\'.\\'){\\n                    startPos = i;\\n                    firstDot = true;\\n                }\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    row[i][num] = 1;\\n                    col[j][num] = 1;\\n                    box[i / 3 * 3 + j / 3][num] = 1;\\n                }\\n            }\\n        }\\n        dfs(board, startPos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381705,
                "title": "c-straightforward-backtracking-solution-with-clear-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solveSudoku(board, 0);\\n    }\\nprivate:\\n    bool solveSudoku(vector<vector<char>>& board, int pos) {\\n        // goal is: when I reach the end, stop\\n        if(pos == 81) {\\n            return true;\\n        }\\n        int row = pos/9, col = pos%9;\\n        // choice 1: for 1~9, do nothing, check the next one\\n        if(board[row][col] != \\'.\\') {\\n            return solveSudoku(board, pos+1);\\n        }\\n        // choice 2: for \\'.\\', try all possible candidates\\n        else {\\n            for(int i = 0; i < 9; ++i) {\\n                char candidate = \\'1\\' + i;\\n                // constrain: same row/col/block can\\'t have duplicate elements\\n                // before put any candidate, check whether it is a valid solution\\n                if(valid(board, pos, candidate)) {\\n                    board[row][col] = candidate;\\n                    if(solveSudoku(board, pos+1)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        board[row][col] = \\'.\\';\\n        return false;\\n    }\\n    bool valid(vector<vector<char>>& board, int pos, char candidate) {\\n        int row = pos/9, col = pos%9;\\n        for(int col = 0; col < 9; ++col) {\\n            if(board[row][col] == candidate) {\\n                return false;\\n            }\\n        }\\n        for(int row = 0; row < 9; ++row) {\\n            if(board[row][col] == candidate) {\\n                return false;\\n            }\\n        }\\n        int upper_row = 3*(row/3), upper_col = 3*(col/3);\\n        for(int i = 0; i < 9; ++i) {\\n            if(board[upper_row + i/3][upper_col + i%3] == candidate) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solveSudoku(board, 0);\\n    }\\nprivate:\\n    bool solveSudoku(vector<vector<char>>& board, int pos) {\\n        // goal is: when I reach the end, stop\\n        if(pos == 81) {\\n            return true;\\n        }\\n        int row = pos/9, col = pos%9;\\n        // choice 1: for 1~9, do nothing, check the next one\\n        if(board[row][col] != \\'.\\') {\\n            return solveSudoku(board, pos+1);\\n        }\\n        // choice 2: for \\'.\\', try all possible candidates\\n        else {\\n            for(int i = 0; i < 9; ++i) {\\n                char candidate = \\'1\\' + i;\\n                // constrain: same row/col/block can\\'t have duplicate elements\\n                // before put any candidate, check whether it is a valid solution\\n                if(valid(board, pos, candidate)) {\\n                    board[row][col] = candidate;\\n                    if(solveSudoku(board, pos+1)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        board[row][col] = \\'.\\';\\n        return false;\\n    }\\n    bool valid(vector<vector<char>>& board, int pos, char candidate) {\\n        int row = pos/9, col = pos%9;\\n        for(int col = 0; col < 9; ++col) {\\n            if(board[row][col] == candidate) {\\n                return false;\\n            }\\n        }\\n        for(int row = 0; row < 9; ++row) {\\n            if(board[row][col] == candidate) {\\n                return false;\\n            }\\n        }\\n        int upper_row = 3*(row/3), upper_col = 3*(col/3);\\n        for(int i = 0; i < 9; ++i) {\\n            if(board[upper_row + i/3][upper_col + i%3] == candidate) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160541,
                "title": "elegant-java-method-with-backtrack-and-bit-beats-97-explaination-and-comments",
                "content": "When we meet the True/False status, we can always consider bit manipulation.\\nBasic idea is to use bit to represent which number we have already used.\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        int[] rows = new int[9];\\n        int[] cols = new int[9];\\n        int[][] subs = new int[3][3];\\n        List<Integer> miss = new ArrayList<>();\\n        for (int i = 0; i < 9; ++i) {\\n            for (int j = 0; j < 9; ++j) {\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'1\\';\\n                    rows[i] |= (1 << num);\\n                    cols[j] |= (1 << num);\\n                    subs[i / 3][j / 3] |= (1 << num);\\n                } else {\\n                    miss.add(i * 9 + j);\\n                }\\n            }\\n        }\\n        help(board, rows, cols, subs, miss, 0);\\n    }\\n    \\n    // return true if already find the result\\n    private boolean help(char[][] board, int[] rows, int[] cols, int[][] subs,\\n                        List<Integer> miss, int start) {\\n        if (start == miss.size()) {\\n            return true;\\n        }\\n        int index = miss.get(start);\\n        int y = index / 9;\\n        int x = index % 9;\\n        int full = (1 << 9) - 1;\\n        int cand = full ^ (rows[y] | cols[x] | subs[y / 3][x / 3]);// all possible candidates we can use\\n        while (cand > 0) {\\n            int bit = cand & (-cand);// last 1 bit\\n            cand -= bit;// since we have used it, we remove this bit\\n            rows[y] |= bit;\\n            cols[x] |= bit;\\n            subs[y / 3][x / 3] |= bit;\\n            if (help(board, rows, cols, subs, miss, start + 1)) {// if this is the answer, we change the position to correponding number, and return true\\n                int num = 1 + (int)(Math.log(bit) / Math.log(2));\\n                board[y][x] = (char)(num + \\'0\\');\\n                return true;\\n            }\\n            rows[y] -= bit;\\n            cols[x] -= bit;\\n            subs[y / 3][x / 3] -= bit;\\n        }\\n        return false;\\n    }\\n}\\n```\\nBTW, you can use similar idea to solve [n-queensII](https://leetcode.com/problems/n-queens-ii/description/)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        int[] rows = new int[9];\\n        int[] cols = new int[9];\\n        int[][] subs = new int[3][3];\\n        List<Integer> miss = new ArrayList<>();\\n        for (int i = 0; i < 9; ++i) {\\n            for (int j = 0; j < 9; ++j) {\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'1\\';\\n                    rows[i] |= (1 << num);\\n                    cols[j] |= (1 << num);\\n                    subs[i / 3][j / 3] |= (1 << num);\\n                } else {\\n                    miss.add(i * 9 + j);\\n                }\\n            }\\n        }\\n        help(board, rows, cols, subs, miss, 0);\\n    }\\n    \\n    // return true if already find the result\\n    private boolean help(char[][] board, int[] rows, int[] cols, int[][] subs,\\n                        List<Integer> miss, int start) {\\n        if (start == miss.size()) {\\n            return true;\\n        }\\n        int index = miss.get(start);\\n        int y = index / 9;\\n        int x = index % 9;\\n        int full = (1 << 9) - 1;\\n        int cand = full ^ (rows[y] | cols[x] | subs[y / 3][x / 3]);// all possible candidates we can use\\n        while (cand > 0) {\\n            int bit = cand & (-cand);// last 1 bit\\n            cand -= bit;// since we have used it, we remove this bit\\n            rows[y] |= bit;\\n            cols[x] |= bit;\\n            subs[y / 3][x / 3] |= bit;\\n            if (help(board, rows, cols, subs, miss, start + 1)) {// if this is the answer, we change the position to correponding number, and return true\\n                int num = 1 + (int)(Math.log(bit) / Math.log(2));\\n                board[y][x] = (char)(num + \\'0\\');\\n                return true;\\n            }\\n            rows[y] -= bit;\\n            cols[x] -= bit;\\n            subs[y / 3][x / 3] -= bit;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15874,
                "title": "slow-but-easy-and-clear-c-solution",
                "content": "    void solveSudoku(vector<vector<char>>& board) {\\n        help(board, 0, 0);\\n    }\\n    bool help(vector<vector<char>>& board, int row, int col){\\n        if(row == 9)\\n            return true;\\n        if(col == 9)\\n            return help(board, row+1, 0);\\n        if(board[row][col] != '.')\\n            return help(board, row, col+1);\\n        for(int i=1; i<=9; i++){\\n            if(isValid(board, row, col, i)){\\n                board[row][col] = i+'0';\\n                if(help(board, row, col+1))\\n                    return true;\\n                board[row][col] = '.';\\n            }\\n        }\\n        return false;\\n    }\\n    bool isValid(vector<vector<char>>& board, int row, int col, int num){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] == num+'0')\\n                return false;\\n        }\\n        for(int j=0; j<9; j++){\\n            if(board[row][j] == num+'0')\\n                return false;\\n        }\\n        for(int i=(row/3)*3; i<(row/3)*3+3; i++){\\n            for(int j=(col/3)*3; j<(col/3)*3+3; j++){\\n                if(board[i][j] == num+'0')\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    void solveSudoku(vector<vector<char>>& board) {\\n        help(board, 0, 0);\\n    }\\n    bool help(vector<vector<char>>& board, int row, int col){\\n        if(row == 9)\\n            return true;\\n        if(col == 9)\\n            return help(board, row+1, 0);\\n        if(board[row][col] != '.')\\n            return help(board, row, col+1);\\n        for(int i=1; i<=9; i++){\\n            if(isValid(board, row, col, i)){\\n                board[row][col] = i+'0';\\n                if(help(board, row, col+1))\\n                    return true;\\n                board[row][col] = '.';\\n            }\\n        }\\n        return false;\\n    }\\n    bool isValid(vector<vector<char>>& board, int row, int col, int num){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] == num+'0')\\n                return false;\\n        }\\n        for(int j=0; j<9; j++){\\n            if(board[row][j] == num+'0')\\n                return false;\\n        }\\n        for(int i=(row/3)*3; i<(row/3)*3+3; i++){\\n            for(int j=(col/3)*3; j<(col/3)*3+3; j++){\\n                if(board[i][j] == num+'0')\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15889,
                "title": "4ms-36line-c",
                "content": "    class Solution {\\n    public:\\n        bool row[9][10];\\n        bool col[9][10];\\n        bool grid[3][3][10];\\n        bool solve(vector<vector<char>>& board, int i, int j) {\\n            if (i>=9) return true;\\n            if (board[i][j] != '.')\\n                return solve(board,i+(j+1)/9,(j+1)%9);\\n            for (int k = 1; k<=9; k++) {\\n                if(!row[i][k] && !col[j][k] && !grid[i/3][j/3][k]) {\\n                    board[i][j] = '0'+k;\\n                    row[i][k] = true, col[j][k] = true, grid[i/3][j/3][k] = true;\\n                    if(solve(board,i+(j+1)/9,(j+1)%9)) return true;\\n                    board[i][j] = '.';\\n                    row[i][k] = false, col[j][k] = false, grid[i/3][j/3][k] = false;\\n                }\\n            }\\n            return false;\\n        }\\n        void solveSudoku(vector<vector<char>>& board) {\\n            memset(row, 0, sizeof(row));\\n            memset(col, 0, sizeof(col));\\n            memset(grid, 0, sizeof(grid));\\n            for (int i=0; i<9; i++) {\\n                for (int j=0; j<9; j++) {\\n                    if(board[i][j]!='.') {\\n                        row[i][board[i][j]-'0'] = true;\\n                        col[j][board[i][j]-'0'] = true;\\n                        grid[i/3][j/3][board[i][j]-'0'] = true;\\n                    }\\n                }\\n            }\\n            solve(board, 0, 0);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool row[9][10];\\n        bool col[9][10];\\n        bool grid[3][3][10];\\n        bool solve(vector<vector<char>>& board, int i, int j) {\\n            if (i>=9) return true;\\n            if (board[i][j] != '.')\\n                return solve(board,i+(j+1)/9,(j+1)%9);\\n            for (int k = 1; k<=9; k++) {\\n                if(!row[i][k] && !col[j][k] && !grid[i/3][j/3][k]) {\\n                    board[i][j] = '0'+k;\\n                    row[i][k] = true, col[j][k] = true, grid[i/3][j/3][k] = true;\\n                    if(solve(board,i+(j+1)/9,(j+1)%9)) return true;\\n                    board[i][j] = '.';\\n                    row[i][k] = false, col[j][k] = false, grid[i/3][j/3][k] = false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 15928,
                "title": "clean-c-code-using-backtrace-easy-to-understand",
                "content": "    void solveSudoku(vector<vector<char> > &board) {\\n        solveSudoku(board, 0, 0);\\n    }\\n    //backtrace\\n    bool solveSudoku(vector<vector<char> > &board, int row, int col) {\\n        if (board.size()==row) return true;\\n        if (board[row][col]!='.') {\\n            if (col==board.size()-1) return solveSudoku(board, row+1, 0);\\n            else return solveSudoku(board, row, col+1);\\n        }\\n        for (int i=1; i<=9; i++) {\\n            if (check(board, row, col, '0'+i)) {\\n                board[row][col] = '0'+i;\\n                if (col==board.size()-1 && solveSudoku(board, row+1, 0)) return true;\\n                else if (solveSudoku(board, row, col+1)) return true;\\n                board[row][col] = '.';\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool check(vector<vector<char> > &board, int row, int col, char value) {\\n        int i;\\n        for (i=0; i<9; i++) {\\n            if (board[row][i]==value) return false;\\n        }\\n        for (i=0; i<9; i++) {\\n            if (board[i][col]==value) return false;\\n        }\\n        for (i=0; i<9; i++) {\\n            int r = (row/3)*3+i/3;\\n            int c = (col/3)*3+i%3;\\n            if (board[r][c]==value) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    void solveSudoku(vector<vector<char> > &board) {\\n        solveSudoku(board, 0, 0);\\n    }\\n    //backtrace\\n    bool solveSudoku(vector<vector<char> > &board, int row, int col) {\\n        if (board.size()==row) return true;\\n        if (board[row][col]!='.') {\\n            if (col==board.size()-1) return solveSudoku(board, row+1, 0);\\n            else return solveSudoku(board, row, col+1);\\n        }\\n        for (int i=1; i<=9; i++) {\\n            if (check(board, row, col, '0'+i)) {\\n                board[row][col] = '0'+i;\\n                if (col==board.size()-1 && solveSudoku(board, row+1, 0)) return true;\\n                else if (solveSudoku(board, row, col+1)) return true;\\n                board[row][col] = '.';\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool check(vector<vector<char> > &board, int row, int col, char value) {\\n        int i;\\n        for (i=0; i<9; i++) {\\n            if (board[row][i]==value) return false;\\n        }\\n        for (i=0; i<9; i++) {\\n            if (board[i][col]==value) return false;\\n        }\\n        for (i=0; i<9; i++) {\\n            int r = (row/3)*3+i/3;\\n            int c = (col/3)*3+i%3;\\n            if (board[r][c]==value) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3976665,
                "title": "easy-solution-using-recursion-backtracking-and-math",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == c)\\n                return false;\\n            if (board[row][i] == c)\\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &board) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                        if (isValid(board, i, j, c)) {\\n                            board[i][j] = c;\\n                            if (solve(board))\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>> &board) {\\n        solve(board);\\n    }\\n};\\n\\n```\\n```JAVA []\\nclass Solution {\\n\\n    public boolean isValid(char[][] board, int row, int col, char c) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == c) return false;\\n            if (board[row][i] == c) return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean solve(char[][] board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                        if (isValid(board, i, j, c)) {\\n                            board[i][j] = c;\\n                            if (solve(board)) return true;\\n                            else board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        def isValid(board, row, col, c):\\n            for i in range(9):\\n                if board[i][col] == c:\\n                    return False\\n                if board[row][i] == c:\\n                    return False\\n                row_index = 3 * (row // 3) + i // 3\\n                col_index = 3 * (col // 3) + i % 3\\n                if board[row_index][col_index] == c:\\n                    return False\\n            return True\\n\\n        def solve(board):\\n            for row in range(9):\\n                for col in range(9):\\n                    if board[row][col] == \".\":\\n                        for c in range(1, 10):\\n                            if isValid(board, row, col, chr(c + ord(\"0\"))):\\n                                board[row][col] = chr(c + ord(\"0\"))\\n                                if solve(board):\\n                                    return True\\n                                else:\\n                                    board[row][col] = \".\"\\n                        return False\\n            return True\\n\\n        solve(board)\\n\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Math",
                    "Backtracking",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == c)\\n                return false;\\n            if (board[row][i] == c)\\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &board) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                        if (isValid(board, i, j, c)) {\\n                            board[i][j] = c;\\n                            if (solve(board))\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>> &board) {\\n        solve(board);\\n    }\\n};\\n\\n```\n```JAVA []\\nclass Solution {\\n\\n    public boolean isValid(char[][] board, int row, int col, char c) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == c) return false;\\n            if (board[row][i] == c) return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean solve(char[][] board) {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == \\'.\\') {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                        if (isValid(board, i, j, c)) {\\n                            board[i][j] = c;\\n                            if (solve(board)) return true;\\n                            else board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        def isValid(board, row, col, c):\\n            for i in range(9):\\n                if board[i][col] == c:\\n                    return False\\n                if board[row][i] == c:\\n                    return False\\n                row_index = 3 * (row // 3) + i // 3\\n                col_index = 3 * (col // 3) + i % 3\\n                if board[row_index][col_index] == c:\\n                    return False\\n            return True\\n\\n        def solve(board):\\n            for row in range(9):\\n                for col in range(9):\\n                    if board[row][col] == \".\":\\n                        for c in range(1, 10):\\n                            if isValid(board, row, col, chr(c + ord(\"0\"))):\\n                                board[row][col] = chr(c + ord(\"0\"))\\n                                if solve(board):\\n                                    return True\\n                                else:\\n                                    board[row][col] = \".\"\\n                        return False\\n            return True\\n\\n        solve(board)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869154,
                "title": "python-striver-s-solution-backtracking-easy",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        def safe(row,col,k,board): #function to check whether it is safe to insert a no. in board or not\\n            for i in range(9):\\n                if board[row][i]==k: # for checking element in same row\\n                    return False\\n                if board[i][col]==k: # for checking element in same column\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==k: # for checking element in same box\\n                    return False\\n            return True\\n        def solve(board):\\n            for i in range(9):\\n                for j in range(9):\\n                    if board[i][j]==\\'.\\':\\n                        for k in range(1,10):\\n                            k=str(k)\\n                            if safe(i,j,k,board):\\n                                board[i][j]=k\\n                                if solve(board):\\n                                    return True\\n                                board[i][j]=\\'.\\'\\n                        return False # if it is not possible to insert any particular value at that cell\\n            return True # if all the values are filled then it will return True\\n        solve(board)\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        def safe(row,col,k,board): #function to check whether it is safe to insert a no. in board or not\\n            for i in range(9):\\n                if board[row][i]==k: # for checking element in same row\\n                    return False\\n                if board[i][col]==k: # for checking element in same column\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==k: # for checking element in same box\\n                    return False\\n            return True\\n        def solve(board):\\n            for i in range(9):\\n                for j in range(9):\\n                    if board[i][j]==\\'.\\':\\n                        for k in range(1,10):\\n                            k=str(k)\\n                            if safe(i,j,k,board):\\n                                board[i][j]=k\\n                                if solve(board):\\n                                    return True\\n                                board[i][j]=\\'.\\'\\n                        return False # if it is not possible to insert any particular value at that cell\\n            return True # if all the values are filled then it will return True\\n        solve(board)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774382,
                "title": "simple-c-solution-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<char>>&board,int row ,int col,char c){\\n        for(int i=0;i<9;i++){\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>&board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]==\\'.\\'){\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){\\n                        if(isValid(board,i,j,c)){\\n                            board[i][j]=c;\\n                            if(solve(board)){\\n                                return true;\\n                            }\\n                            else{\\n                                board[i][j]=\\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<char>>&board,int row ,int col,char c){\\n        for(int i=0;i<9;i++){\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>&board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]==\\'.\\'){\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){\\n                        if(isValid(board,i,j,c)){\\n                            board[i][j]=c;\\n                            if(solve(board)){\\n                                return true;\\n                            }\\n                            else{\\n                                board[i][j]=\\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768334,
                "title": "100-easy-solution",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(9^N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);}\\n    boolean solve(char[][]board)\\n    { for(int i=0;i<board.length;i++)\\n    {for(int j=0;j<board.length;j++)\\n    { if(board[i][j] == \\'.\\')\\n    {for( char num =\\'1\\';num <=\\'9\\';num++)\\n    {  if(isSafe(board,i,j,num))\\n    {board[i][j]=num;\\n    if(solve(board)) //found the ans\\n    return true;\\n    else\\n    //backtrack\\n     board[i][j]=\\'.\\';\\n    } } return false;} }}\\n    return true; }\\n     boolean isSafe(char[][] board,int row,int col,char num)\\n    { // check the row\\n      for(int i=0;i<board.length;i++)\\n      { // check if the number is in the row\\n        if(board[i][col] == num)  return false;\\n         // check the column\\n       // check if the number is in the column\\n        if(board[row][i]== num) return false;\\n      }int sqrt=(int)(Math.sqrt(board.length));\\n      int rowStart=row - row % sqrt;\\n      int colStart=col - col % sqrt;\\n      for(int r=rowStart;r<rowStart + sqrt;r++)\\n      { for(int c=colStart;c<colStart + sqrt;c++)\\n       {if(board[r][c] == num)   return false; }\\n      }return true;\\n}\\n}\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/07096914-b792-4ad3-a529-9a2337a1971b_1689419522.1254554.jpeg)",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);}\\n    boolean solve(char[][]board)\\n    { for(int i=0;i<board.length;i++)\\n    {for(int j=0;j<board.length;j++)\\n    { if(board[i][j] == \\'.\\')\\n    {for( char num =\\'1\\';num <=\\'9\\';num++)\\n    {  if(isSafe(board,i,j,num))\\n    {board[i][j]=num;\\n    if(solve(board)) //found the ans\\n    return true;\\n    else\\n    //backtrack\\n     board[i][j]=\\'.\\';\\n    } } return false;} }}\\n    return true; }\\n     boolean isSafe(char[][] board,int row,int col,char num)\\n    { // check the row\\n      for(int i=0;i<board.length;i++)\\n      { // check if the number is in the row\\n        if(board[i][col] == num)  return false;\\n         // check the column\\n       // check if the number is in the column\\n        if(board[row][i]== num) return false;\\n      }int sqrt=(int)(Math.sqrt(board.length));\\n      int rowStart=row - row % sqrt;\\n      int colStart=col - col % sqrt;\\n      for(int r=rowStart;r<rowStart + sqrt;r++)\\n      { for(int c=colStart;c<colStart + sqrt;c++)\\n       {if(board[r][c] == num)   return false; }\\n      }return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330713,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n    public boolean solve(char[][]board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n\\n                if(board[i][j]==\\'.\\'){\\n\\n                    for(char num=\\'1\\';num<=\\'9\\';num++){\\n                        if(isPossible(board,i,j,num)){\\n                            board[i][j]=num;\\n                            if(solve(board)){\\n                                return true;\\n                            }\\n                            else{\\n                                board[i][j]=\\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isPossible(char[][]board,int row,int col,char c){\\n        for(int i=0;i<9;i++){\\n            if(board[i][col]==c) return false;\\n            if(board[row][i]==c) return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) return false;//checking in each 3 x 3 matrix\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n    public boolean solve(char[][]board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n\\n                if(board[i][j]==\\'.\\'){\\n\\n                    for(char num=\\'1\\';num<=\\'9\\';num++){\\n                        if(isPossible(board,i,j,num)){\\n                            board[i][j]=num;\\n                            if(solve(board)){\\n                                return true;\\n                            }\\n                            else{\\n                                board[i][j]=\\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isPossible(char[][]board,int row,int col,char c){\\n        for(int i=0;i<9;i++){\\n            if(board[i][col]==c) return false;\\n            if(board[row][i]==c) return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) return false;//checking in each 3 x 3 matrix\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307469,
                "title": "java-easy-to-understand-detailed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n    public boolean solve(char[][]board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n\\n                if(board[i][j]==\\'.\\'){\\n\\n                    for(char num=\\'1\\';num<=\\'9\\';num++){\\n                        if(isPossible(board,i,j,num)){\\n                            board[i][j]=num;\\n                            if(solve(board)){\\n                                return true;\\n                            }\\n                            //if the solve function return false then the prev num must be in wrong pos so then backtrack\\n                            //and fill that with \\'.\\'. \\n                            else{\\n                                board[i][j]=\\'.\\';\\n                            }\\n                        }\\n                    }\\n\\n                    //if it is not possible to select a number from 1 to 9 the solve function return false;\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isPossible(char[][]board,int row,int col,char c){\\n        for(int i=0;i<9;i++){\\n            if(board[i][col]==c) return false;//col check\\n\\n            if(board[row][i]==c) return false; //row check\\n\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) return false;//checking in each 3 x 3 matrix\\n        }\\n        return true;\\n\\n    }\\n}\\n```\\n```\\nif you have any query ask me on comment and upvote the solution.\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n    public boolean solve(char[][]board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n\\n                if(board[i][j]==\\'.\\'){\\n\\n                    for(char num=\\'1\\';num<=\\'9\\';num++){\\n                        if(isPossible(board,i,j,num)){\\n                            board[i][j]=num;\\n                            if(solve(board)){\\n                                return true;\\n                            }\\n                            //if the solve function return false then the prev num must be in wrong pos so then backtrack\\n                            //and fill that with \\'.\\'. \\n                            else{\\n                                board[i][j]=\\'.\\';\\n                            }\\n                        }\\n                    }\\n\\n                    //if it is not possible to select a number from 1 to 9 the solve function return false;\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isPossible(char[][]board,int row,int col,char c){\\n        for(int i=0;i<9;i++){\\n            if(board[i][col]==c) return false;//col check\\n\\n            if(board[row][i]==c) return false; //row check\\n\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) return false;//checking in each 3 x 3 matrix\\n        }\\n        return true;\\n\\n    }\\n}\\n```\n```\\nif you have any query ask me on comment and upvote the solution.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002213,
                "title": "solution-of-leetcode-sudoku-solver-in-java-with-solution-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs most of people have solved using <b>backtracking</b>.\\nIn backtracking there are three point you need to focus on:-\\n<ol>\\n<li><b>Parameter :-</b> Parameters are ingredients of problem solving similerly when you do cooking you select what spices and items you need. You need to figure out how many parameters you need to take to solve the particular problem.<br>\\n<p>To solve Sudoku solver we are going to take <b>Board, Row and Col</b>. We need to create a helper function,\\n<b>helper(char[][] board, int row, int col)</b> which can take these parameters and help to solve the problem.\\n</p>\\n</li>\\n<li><b>Subproblem:-</b> You need to slit it to smaller sets of problems which will easier to solve. It is similer like when you cook Biryani\\'s (An Inidan dish). You cook rice and fry checken and than mixedup and prepared full disc. Similery in <b>Coding</b>. we break bigger problem into smaler problem than try to solve.</li>\\n<li><b>Return Type:-</b>You need to keep in mind what type of value is required to further processing. Like for our <b>Sudoku Solver</b> we required <b>\\'boolean\\'.</b><br> public boolean helper(char[][] board, int row, int col){<br>  .  -------<br>-------<br>}</li>\\n</ol>\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs you can see i have created a helper method which is taking three parameter board, row and col.<br>\\n<br> public boolean helper(char[][] board, int row, int col){<br>  .  -------<br>-------<br>}\\nreturn type is boolean.\\n<span>I have also created an <b>isSafe</b> to check wheathert putting <b>Queen</b> on particulaer place is good or not.<span>\\n<b>public boolean isSafe(char[][] board, int row, int col, int number){<br> ......<br>}</b>\\nYou may find that i am taking an extra parameter int number which will keep tracking of [1, 2, 3, 4, ..., 9].\\n<i>You may refer my youtube channel for complite video solution and solution approach.\\n</i>\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/VVA8uU3S0io\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n# Complexity\\n- Time complexity: 9 ^ 9 <br>Here there are 9 x 9 matrix = 81 cell. Each cell can have Number from [1, 2, 3, ... 9]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(9^(9-1)) => o(9^8). <br>Note: Here writing space complexity in O notation slightly dispointing. In backtracking it difficult to say exact space complexity but we can estimate it to maximum 81 recursive call can.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean helper(char[][] board, int row, int col){\\n        if(row == board.length){\\n            return true;\\n        }\\n        int nrow = 0;\\n        int ncol = 0;\\n        if(col != board.length -1) {\\n            nrow = row;\\n            ncol = col+1;\\n        }else{\\n            nrow = row+1;\\n            ncol = 0;\\n        }\\n\\n        if(board[row][col] != \\'.\\'){\\n            if(helper(board, nrow, ncol)){\\n                return true;\\n            }\\n        }else{\\n            for(int i=1; i<=9; i++){\\n                if(isSafe(board, row, col, i)){\\n                    board[row][col] = (char)(i + \\'0\\');\\n                    if(helper(board, nrow, ncol)){\\n                        return true;\\n                    }else{\\n                        board[row][col] = \\'.\\';\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isSafe(char[][] board, int row, int col, int number){\\n        for(int i=0; i<board.length; i++){\\n            if(board[i][col] == (char)(number + \\'0\\')){\\n                return false;\\n            }\\n            if(board[row][i] == (char)(number +\\'0\\')){\\n                return false;\\n            }\\n        }\\n        //grid\\n        int sr = (row/3) *3;\\n        int sc = (col/3) *3;\\n        for(int i = sr; i<sr+3; i++){\\n            for(int j=sc; j< sc+3; j++){\\n                if(board[i][j] == (char)(number + \\'0\\')){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public void solveSudoku(char[][] board) {\\n        helper(board, 0, 0);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean helper(char[][] board, int row, int col){\\n        if(row == board.length){\\n            return true;\\n        }\\n        int nrow = 0;\\n        int ncol = 0;\\n        if(col != board.length -1) {\\n            nrow = row;\\n            ncol = col+1;\\n        }else{\\n            nrow = row+1;\\n            ncol = 0;\\n        }\\n\\n        if(board[row][col] != \\'.\\'){\\n            if(helper(board, nrow, ncol)){\\n                return true;\\n            }\\n        }else{\\n            for(int i=1; i<=9; i++){\\n                if(isSafe(board, row, col, i)){\\n                    board[row][col] = (char)(i + \\'0\\');\\n                    if(helper(board, nrow, ncol)){\\n                        return true;\\n                    }else{\\n                        board[row][col] = \\'.\\';\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isSafe(char[][] board, int row, int col, int number){\\n        for(int i=0; i<board.length; i++){\\n            if(board[i][col] == (char)(number + \\'0\\')){\\n                return false;\\n            }\\n            if(board[row][i] == (char)(number +\\'0\\')){\\n                return false;\\n            }\\n        }\\n        //grid\\n        int sr = (row/3) *3;\\n        int sc = (col/3) *3;\\n        for(int i = sr; i<sr+3; i++){\\n            for(int j=sc; j< sc+3; j++){\\n                if(board[i][j] == (char)(number + \\'0\\')){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public void solveSudoku(char[][] board) {\\n        helper(board, 0, 0);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510918,
                "title": "c-100-fastest-solution-detailed-explanation-easy-understand",
                "content": "**Read the below approach wnd comment inside code to understand the logic**\\n\\n***Please upvote if you like it!!!!***\\n\\n**Approach:-**\\nSince we have to fill the empty cells with available possible numbers and we can also have multiple solutions, the main intuition is to try every possible way of filling the empty cells. And the more correct way to try all possible solutions is to use recursion. In each call to the recursive function, we just try all the possible numbers for a particular cell and transfer the updated board to the next recursive call.\\n\\n**Code:-**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<char>>& board,int row,int col,char val){\\n        for(int i=0;i<9;i++){\\n            //check if value already present in row\\n            if(board[row][i]==val) return false;\\n            //check if value already present in row\\n            if(board[i][col]==val) return false;\\n            //check if value already present in given 3*3 grid\\n            if(board[(3*(row/3)+i/3)][(3*(col/3)+i%3)]==val) return false;\\n        }\\n        //if we reach here it means we can put val inside board\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]==\\'.\\'){\\n                    //check for all 1 to 9\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){\\n                        //if current char is valid to put on current block\\n                        if(isValid(board,i,j,c)){\\n                            board[i][j]=c;\\n                            bool temp=solve(board);\\n                            if(temp)\\n                                return true;\\n                            else\\n                                board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<vector<char>>& board,int row,int col,char val){\\n        for(int i=0;i<9;i++){\\n            //check if value already present in row\\n            if(board[row][i]==val) return false;\\n            //check if value already present in row\\n            if(board[i][col]==val) return false;\\n            //check if value already present in given 3*3 grid\\n            if(board[(3*(row/3)+i/3)][(3*(col/3)+i%3)]==val) return false;\\n        }\\n        //if we reach here it means we can put val inside board\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]==\\'.\\'){\\n                    //check for all 1 to 9\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){\\n                        //if current char is valid to put on current block\\n                        if(isValid(board,i,j,c)){\\n                            board[i][j]=c;\\n                            bool temp=solve(board);\\n                            if(temp)\\n                                return true;\\n                            else\\n                                board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304116,
                "title": "simple-python-solution-backtracking",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        N=len(board)\\n        for row in range(N):\\n            for col in range(N):\\n                if board[row][col]==\".\":\\n                    for num in range(1,10):\\n                        if(self.isValid(num,row,col,board,N)):\\n                            board[row][col]=str(num)\\n                            if(self.solveSudoku(board)):\\n                                return True\\n                            else:\\n                                board[row][col]=\".\"\\n                    return False\\n        return True\\n    \\n    def isValid(self,num,row,col,board,N):\\n        for i in range(N):\\n            if str(num) == board[row][i]: return False\\n            if str(num) == board[i][col]: return False\\n            if str(num) == board[3*(row//3) +i//3][3*(col//3) +i%3]: return False\\n        return True\\n```\\n\\n**EDIT:\\nTo Make generalised solution for any board size multiple of 3, I made small change:**\\n\\n```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        N=len(board)\\n        for row in range(N):\\n            for col in range(N):\\n                if board[row][col]==\".\":\\n                    for num in range(1,10):\\n                        if(self.isValid(num,row,col,board,N)):\\n                            board[row][col]=str(num)\\n                            if(self.solveSudoku(board)):\\n                                return True\\n                            else:\\n                                board[row][col]=\".\"\\n                    return False\\n        return True\\n    \\n    def isValid(self,num,row,col,board,N):\\n        for i in range(N):\\n            if str(num) == board[row][i]: return False\\n            if str(num) == board[i][col]: return False\\n\\t\\tfor i in range(9):\\n            if str(num) == board[3*(row//3) +i//3][3*(col//3) +i%3]: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        N=len(board)\\n        for row in range(N):\\n            for col in range(N):\\n                if board[row][col]==\".\":\\n                    for num in range(1,10):\\n                        if(self.isValid(num,row,col,board,N)):\\n                            board[row][col]=str(num)\\n                            if(self.solveSudoku(board)):\\n                                return True\\n                            else:\\n                                board[row][col]=\".\"\\n                    return False\\n        return True\\n    \\n    def isValid(self,num,row,col,board,N):\\n        for i in range(N):\\n            if str(num) == board[row][i]: return False\\n            if str(num) == board[i][col]: return False\\n            if str(num) == board[3*(row//3) +i//3][3*(col//3) +i%3]: return False\\n        return True\\n```\n```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        N=len(board)\\n        for row in range(N):\\n            for col in range(N):\\n                if board[row][col]==\".\":\\n                    for num in range(1,10):\\n                        if(self.isValid(num,row,col,board,N)):\\n                            board[row][col]=str(num)\\n                            if(self.solveSudoku(board)):\\n                                return True\\n                            else:\\n                                board[row][col]=\".\"\\n                    return False\\n        return True\\n    \\n    def isValid(self,num,row,col,board,N):\\n        for i in range(N):\\n            if str(num) == board[row][i]: return False\\n            if str(num) == board[i][col]: return False\\n\\t\\tfor i in range(9):\\n            if str(num) == board[3*(row//3) +i//3][3*(col//3) +i%3]: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566508,
                "title": "java-easy-solution-with-explanation-backtracking",
                "content": "**Code**\\nTime complexity - Worst Case `O(9^(n*n))` when all the places are blank and each cell has 9 possibilities from 1-9\\nIt can also be written as `theta(9^z)` where z is number of places with \\'.\\' throughout the matrix.\\n\\nThis code can be made more compact but that would make it difficult to understand but my intent is to make this clear along with giving the code.\\n\\n```java\\npublic void solveSudoku(char[][] board) {\\n\\tsolveSudokuUtil(board);\\n}\\n\\npublic boolean solveSudokuUtil(char[][] board) {\\n\\t// check first if the array is filled or not\\n\\tboolean isFull = true;\\n\\tint row = 0, col = 0;\\n\\tfor(int i = 0; i < board.length; i++) {\\n\\t\\tfor(int j = 0; j < board.length; j++) {\\n\\t\\t\\tif(board[i][j] == \\'.\\') {\\n\\t\\t\\t\\tisFull = false;\\n\\t\\t\\t\\trow = i;\\n\\t\\t\\t\\tcol = j;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!isFull)\\n\\t\\t\\tbreak;\\n\\t}\\n\\t// if the sudoku is already solved\\n\\tif(isFull) return true;\\n\\n\\t// try to enter number from 1-9\\n\\tfor(int num = 1; num <= 9; num++) {\\n\\t\\tif(isSafe(board, row, col, (char)(num + \\'0\\'))) {\\n\\t\\t\\tboard[row][col] = (char)(num + \\'0\\');\\n\\t\\t\\t// solve rest of the board until it get solved\\n\\t\\t\\tif(solveSudokuUtil(board)) {\\n\\t\\t\\t\\treturn true;   \\n\\t\\t\\t}\\n\\t\\t\\t// backtracking step\\n\\t\\t\\tboard[row][col] = \\'.\\';\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\npublic boolean isSafe(char[][] board, int row, int col, char num) {\\n\\t// check row\\n\\tfor(int j = 0; j < board.length; j++) {\\n\\t\\tif(board[row][j] == num)\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\t// check column\\n\\tfor(int i = 0; i < board.length; i++) {\\n\\t\\tif(board[i][col] == num) \\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\t// check block of 3X3 size\\n\\t// we are given 9X9 matrix so each block will be of size (square root) * (square root)\\n\\tint sqrt = (int)Math.sqrt(board.length);\\n\\tint rowBlockStart = row - row % sqrt;\\n\\tint colBlockStart = col - col % sqrt;\\n\\n\\tfor(int i = rowBlockStart; i < rowBlockStart + sqrt; i++) {\\n\\t\\tfor(int j = colBlockStart; j < colBlockStart + sqrt; j++) {\\n\\t\\t\\tif(board[i][j] == num) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```\\n\\n**Explanation**\\nSo in this question we are required to solve the sudoku puzzle and you know we will be using backtracking for it because they work best for it.\\nSo as the question has made the rules of sudoku very clear, these are:-\\n```\\nA sudoku solution must satisfy all of the following rules:\\n\\nEach of the digits 1-9 must occur exactly once in each row.\\nEach of the digits 1-9 must occur exactly once in each column.\\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\\n```\\n\\nSo the `solveSudokuUtil` function just says that :-\\n- first check if the sudoku puzzle is already filled or not, if it is then just return with true, else store the indices of the cell which is not filled in `row` and `col` variables.\\n- Now you are having row and col of the cell, try all the possibilites from 1 through 9 and check if we can enter `num` into it according to above mentioned constraints.\\n\\t- if it is safe then try to solve the rest of the board and if it can be solved then return true and let recursion solve the sudoku for you.\\n- after that keep on resetting the cell if it is not solved successfully.\\n\\nNow the only thing left is the check for `isSafe` :-\\n- We need to check if the row contains that num.\\n- We need to check if the column contains that num.\\n- Now we need to check if the num is present in the 3X3 block, let\\'s get it very clear:-\\n\\t- So for checking in 3X3 block let\\'s find the starting row and column indices of that block and check in that block, let\\'s understand how to get starting indices.\\n\\t- So rowBlockStart represents starting row of that block and colBlockStart represents starting column.\\n\\t- The formula for that is:-\\n\\t\\t- `rowBlockStart = row - row % sqrt`\\n\\t\\t- `colBlockStart = col - col % sqrt`\\n\\t- This is because we are standing on (row,col) and we want to know starting row and column indices of that block, so for that we need to remove just the extra, which is actually the index mod the block size(sqrt). The modulus can be 0, 1, 2 and we need to substract that much for corresponding row or col to get to the starting.\\n\\n![image](https://assets.leetcode.com/users/images/8cdda667-a674-46fa-9c43-4f255756f468_1636377116.7214139.png)\\n\\nThe start can only be either 0, 3, 6 all of them are divisible by the size of the block i.e 3. So that\\'s the point of observation.\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\npublic void solveSudoku(char[][] board) {\\n\\tsolveSudokuUtil(board);\\n}\\n\\npublic boolean solveSudokuUtil(char[][] board) {\\n\\t// check first if the array is filled or not\\n\\tboolean isFull = true;\\n\\tint row = 0, col = 0;\\n\\tfor(int i = 0; i < board.length; i++) {\\n\\t\\tfor(int j = 0; j < board.length; j++) {\\n\\t\\t\\tif(board[i][j] == \\'.\\') {\\n\\t\\t\\t\\tisFull = false;\\n\\t\\t\\t\\trow = i;\\n\\t\\t\\t\\tcol = j;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(!isFull)\\n\\t\\t\\tbreak;\\n\\t}\\n\\t// if the sudoku is already solved\\n\\tif(isFull) return true;\\n\\n\\t// try to enter number from 1-9\\n\\tfor(int num = 1; num <= 9; num++) {\\n\\t\\tif(isSafe(board, row, col, (char)(num + \\'0\\'))) {\\n\\t\\t\\tboard[row][col] = (char)(num + \\'0\\');\\n\\t\\t\\t// solve rest of the board until it get solved\\n\\t\\t\\tif(solveSudokuUtil(board)) {\\n\\t\\t\\t\\treturn true;   \\n\\t\\t\\t}\\n\\t\\t\\t// backtracking step\\n\\t\\t\\tboard[row][col] = \\'.\\';\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\npublic boolean isSafe(char[][] board, int row, int col, char num) {\\n\\t// check row\\n\\tfor(int j = 0; j < board.length; j++) {\\n\\t\\tif(board[row][j] == num)\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\t// check column\\n\\tfor(int i = 0; i < board.length; i++) {\\n\\t\\tif(board[i][col] == num) \\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\t// check block of 3X3 size\\n\\t// we are given 9X9 matrix so each block will be of size (square root) * (square root)\\n\\tint sqrt = (int)Math.sqrt(board.length);\\n\\tint rowBlockStart = row - row % sqrt;\\n\\tint colBlockStart = col - col % sqrt;\\n\\n\\tfor(int i = rowBlockStart; i < rowBlockStart + sqrt; i++) {\\n\\t\\tfor(int j = colBlockStart; j < colBlockStart + sqrt; j++) {\\n\\t\\t\\tif(board[i][j] == num) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```\n```\\nA sudoku solution must satisfy all of the following rules:\\n\\nEach of the digits 1-9 must occur exactly once in each row.\\nEach of the digits 1-9 must occur exactly once in each column.\\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1503902,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        fun(board);\\n    }\\n    bool fun(vector<vector<char>> &board){\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==\\'.\\'){\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){\\n                        if(isValid(board, i, j, c)){\\n                            board[i][j]=c;\\n                            if(fun(board)) return 1;\\n                            board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c){\\n        for(int i=0;i<9;i++){\\n            if(board[i][col]==c) return 0;\\n            if(board[row][i]==c) return 0;\\n            if(board[3*(row/3) + i/3][3*(col/3) +i%3]==c) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        fun(board);\\n    }\\n    bool fun(vector<vector<char>> &board){\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==\\'.\\'){\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){\\n                        if(isValid(board, i, j, c)){\\n                            board[i][j]=c;\\n                            if(fun(board)) return 1;\\n                            board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c){\\n        for(int i=0;i<9;i++){\\n            if(board[i][col]==c) return 0;\\n            if(board[row][i]==c) return 0;\\n            if(board[3*(row/3) + i/3][3*(col/3) +i%3]==c) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429087,
                "title": "javascript-straightforward-backtracking-solution-concise-clean-code-30-lines",
                "content": "**Backtracking Time O(9 ^ (9 ^ 2))**\\n```\\nvar solveSudoku = function(sudoku) { \\n    var isValid = (row, col, value) => {\\n        for (let i = 0; i < 9; i++) {\\n            if (\\n                sudoku[row][i] === value || sudoku[i][col] === value ||\\n\\t\\t\\t\\tsudoku[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + (i % 3)] === value\\n\\t\\t\\t) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    };\\n\\n    var backtracking = (i, j) => {\\n        if (i === 9) return true;\\n\\n        if (sudoku[i][j] !== \".\")\\n            return j === 8 ? backtracking(i + 1, 0) : backtracking(i, j + 1);\\n\\n        for (let k = 1; k <= 9; k++) {\\n            if (isValid(i, j, k.toString())) {\\n                sudoku[i][j] = k.toString();\\n                const boolean = j === 8 ? backtracking(i + 1, 0) : backtracking(i, j + 1);\\n                \\n                if (boolean) return true;\\n                sudoku[i][j] = \".\";\\n            }\\n        }\\n    };\\n\\n    backtracking(0, 0);\\n    return sudoku;\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nvar solveSudoku = function(sudoku) { \\n    var isValid = (row, col, value) => {\\n        for (let i = 0; i < 9; i++) {\\n            if (\\n                sudoku[row][i] === value || sudoku[i][col] === value ||\\n\\t\\t\\t\\tsudoku[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + (i % 3)] === value\\n\\t\\t\\t) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    };\\n\\n    var backtracking = (i, j) => {\\n        if (i === 9) return true;\\n\\n        if (sudoku[i][j] !== \".\")\\n            return j === 8 ? backtracking(i + 1, 0) : backtracking(i, j + 1);\\n\\n        for (let k = 1; k <= 9; k++) {\\n            if (isValid(i, j, k.toString())) {\\n                sudoku[i][j] = k.toString();\\n                const boolean = j === 8 ? backtracking(i + 1, 0) : backtracking(i, j + 1);\\n                \\n                if (boolean) return true;\\n                sudoku[i][j] = \".\";\\n            }\\n        }\\n    };\\n\\n    backtracking(0, 0);\\n    return sudoku;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1415911,
                "title": "simple-c-sol-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n     bool isValid(int i,int j,vector<vector<char>>&board){\\n        for(int k=0;k<9;k++){\\n            if(k!=i and board[k][j]==board[i][j]){\\n                return false;\\n            }\\n        }\\n        for(int k=0;k<9;k++){\\n            if(k!=j and board[i][k]==board[i][j]){\\n                return false;\\n            }\\n        }\\n        int i1=(i/3)*3,j1=(j/3)*3;\\n        for(int k=i1;k<i1+3;k++){\\n            for(int l=j1;l<j1+3;l++){\\n                if((k!=i and l!=j) and board[k][l]==board[i][j]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isValidUtill(vector<vector<char>>& board,int i,int j){\\n        if(i>=9){\\n            return true;\\n        }\\n        if(j==9){\\n            return isValidUtill(board,i+1,0);\\n        }\\n        if(board[i][j]!=\\'.\\'){\\n            return isValidUtill(board,i,j+1);\\n        }\\n        \\n        for(int k=1;k<=9;k++){\\n            board[i][j]=\\'0\\'+k;\\n            if(isValid(i,j,board) and isValidUtill(board,i,j+1)){\\n                return true;\\n            }\\n            board[i][j]=\\'.\\';\\n        }\\n        return false;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>>& board) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        bool a=isValidUtill(board,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isValid(int i,int j,vector<vector<char>>&board){\\n        for(int k=0;k<9;k++){\\n            if(k!=i and board[k][j]==board[i][j]){\\n                return false;\\n            }\\n        }\\n        for(int k=0;k<9;k++){\\n            if(k!=j and board[i][k]==board[i][j]){\\n                return false;\\n            }\\n        }\\n        int i1=(i/3)*3,j1=(j/3)*3;\\n        for(int k=i1;k<i1+3;k++){\\n            for(int l=j1;l<j1+3;l++){\\n                if((k!=i and l!=j) and board[k][l]==board[i][j]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isValidUtill(vector<vector<char>>& board,int i,int j){\\n        if(i>=9){\\n            return true;\\n        }\\n        if(j==9){\\n            return isValidUtill(board,i+1,0);\\n        }\\n        if(board[i][j]!=\\'.\\'){\\n            return isValidUtill(board,i,j+1);\\n        }\\n        \\n        for(int k=1;k<=9;k++){\\n            board[i][j]=\\'0\\'+k;\\n            if(isValid(i,j,board) and isValidUtill(board,i,j+1)){\\n                return true;\\n            }\\n            board[i][j]=\\'.\\';\\n        }\\n        return false;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>>& board) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL);\\n        bool a=isValidUtill(board,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324722,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool isValid(vector<vector<char>>&board,int row,int col,int n)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            if(board[i][col]==n+\\'0\\' || board[row][i]==n+\\'0\\')\\n            {\\n                return false;\\n            }\\n        }\\n        int currRow=(row/3)*3,currCol=(col/3)*3;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(board[currRow+i][currCol+j]==n+\\'0\\')\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void helper(vector<vector<char>>&ans,vector<vector<char>>&board,int row,int col)\\n    {\\n        if(row==9)\\n        {\\n            ans=board;\\n            return;\\n        }\\n        int nextRow,nextCol;\\n        if(col==8)\\n        {\\n            nextCol=0;\\n            nextRow=row+1;\\n        }\\n        else\\n        {\\n            nextCol=col+1;\\n            nextRow=row;\\n        }\\n        if(board[row][col]==\\'.\\')\\n        {\\n            for(int i=1;i<=9;i++)\\n            {\\n                if(isValid(board,row,col,i))\\n                {\\n                    board[row][col]=i+\\'0\\';\\n                    helper(ans,board,nextRow,nextCol);\\n                    board[row][col]=\\'.\\';\\n                }\\n            }\\n        }\\n        else\\n        {\\n            helper(ans,board,nextRow,nextCol);\\n        }\\n    }\\n    void solveSudoku(vector<vector<char>>& board)\\n    {\\n        vector<vector<char>>ans;\\n        helper(ans,board,0,0);\\n        board=ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool isValid(vector<vector<char>>&board,int row,int col,int n)\\n    {\\n        for(int i=0;i<9;i++)\\n        {\\n            if(board[i][col]==n+\\'0\\' || board[row][i]==n+\\'0\\')\\n            {\\n                return false;\\n            }\\n        }\\n        int currRow=(row/3)*3,currCol=(col/3)*3;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(board[currRow+i][currCol+j]==n+\\'0\\')\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void helper(vector<vector<char>>&ans,vector<vector<char>>&board,int row,int col)\\n    {\\n        if(row==9)\\n        {\\n            ans=board;\\n            return;\\n        }\\n        int nextRow,nextCol;\\n        if(col==8)\\n        {\\n            nextCol=0;\\n            nextRow=row+1;\\n        }\\n        else\\n        {\\n            nextCol=col+1;\\n            nextRow=row;\\n        }\\n        if(board[row][col]==\\'.\\')\\n        {\\n            for(int i=1;i<=9;i++)\\n            {\\n                if(isValid(board,row,col,i))\\n                {\\n                    board[row][col]=i+\\'0\\';\\n                    helper(ans,board,nextRow,nextCol);\\n                    board[row][col]=\\'.\\';\\n                }\\n            }\\n        }\\n        else\\n        {\\n            helper(ans,board,nextRow,nextCol);\\n        }\\n    }\\n    void solveSudoku(vector<vector<char>>& board)\\n    {\\n        vector<vector<char>>ans;\\n        helper(ans,board,0,0);\\n        board=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310684,
                "title": "detailed-java-solution-with-comments",
                "content": "**Please Upvote if you liked the post**\\n\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n    \\n    private boolean solve(char[][] board){\\n        \\n        for(int i = 0;i<9;i++){\\n            for(int j = 0;j<9;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char k =\\'1\\';k<=\\'9\\';k++){\\n                        if(isValid(board,i,j,k)){\\n                            board[i][j] = k;\\n                            if(solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false; //not able to place any num from 1-9 at i,j \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isValid(char [][] board,int row,int col,char val){//o(n)\\n        //check entire col,row\\n        for(int i = 0;i<9;i++){\\n            if(board[i][col] == val) return false;\\n            if(board[row][i] == val) return false;\\n        }  \\n        \\n        //getting the top left corner of 3 cross 3 matrix\\n        //row/3 & col/3 gives u exact subarray box , we multiply these by 3\\n        //so that we can get the top left corner of that box(i.e box starting)\\n        int rowst = (row/3) * 3;\\n        int colst = (col/3) * 3;\\n        \\n        //checking the 3 cross 3 submatrix\\n        for(int i = 0;i<3;i++){\\n            for(int j = 0;j<3;j++){\\n                if(board[rowst + i][colst + j] == val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n    \\n    private boolean solve(char[][] board){\\n        \\n        for(int i = 0;i<9;i++){\\n            for(int j = 0;j<9;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char k =\\'1\\';k<=\\'9\\';k++){\\n                        if(isValid(board,i,j,k)){\\n                            board[i][j] = k;\\n                            if(solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false; //not able to place any num from 1-9 at i,j \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isValid(char [][] board,int row,int col,char val){//o(n)\\n        //check entire col,row\\n        for(int i = 0;i<9;i++){\\n            if(board[i][col] == val) return false;\\n            if(board[row][i] == val) return false;\\n        }  \\n        \\n        //getting the top left corner of 3 cross 3 matrix\\n        //row/3 & col/3 gives u exact subarray box , we multiply these by 3\\n        //so that we can get the top left corner of that box(i.e box starting)\\n        int rowst = (row/3) * 3;\\n        int colst = (col/3) * 3;\\n        \\n        //checking the 3 cross 3 submatrix\\n        for(int i = 0;i<3;i++){\\n            for(int j = 0;j<3;j++){\\n                if(board[rowst + i][colst + j] == val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101207,
                "title": "javascript",
                "content": "```\\n\\nconst solveSudoku =(board) => {\\n    if (!board || board.length == 0) {\\n        return;\\n    }\\n    Result(board);\\n};\\n\\nconst Result = (board) => {\\n    for (let i = 0; i < 9; i++) {\\n        for (let j = 0; j < 9; j++) {\\n            if (board[i][j] === \".\") {\\n                for (let c = 1; c <= 9; c++) {\\n                    if (isValid(board, i, j, c.toString())) {\\n                        board[i][j] = c.toString();\\n                        if (Result(board)) {\\n                            return true;\\n                        }else{\\n                            board[i][j] = \".\";\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n\\nconst isValid = (board, row, col, c) => {\\n    for (let i = 0; i < 9; i++) {\\n        if (board[i][col] == c) return false;\\n        if (board[row][i] == c) return false;\\n    }\\n\\n    const x = ~~(row / 3) * 3;\\n    const y = ~~(col / 3) * 3;\\n    for (let i = 0; i < 3; i++) {\\n        for (let j = 0; j < 3; j++) {\\n            if (board[x + i][y + j] == c) {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst solveSudoku =(board) => {\\n    if (!board || board.length == 0) {\\n        return;\\n    }\\n    Result(board);\\n};\\n\\nconst Result = (board) => {\\n    for (let i = 0; i < 9; i++) {\\n        for (let j = 0; j < 9; j++) {\\n            if (board[i][j] === \".\") {\\n                for (let c = 1; c <= 9; c++) {\\n                    if (isValid(board, i, j, c.toString())) {\\n                        board[i][j] = c.toString();\\n                        if (Result(board)) {\\n                            return true;\\n                        }else{\\n                            board[i][j] = \".\";\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n\\nconst isValid = (board, row, col, c) => {\\n    for (let i = 0; i < 9; i++) {\\n        if (board[i][col] == c) return false;\\n        if (board[row][i] == c) return false;\\n    }\\n\\n    const x = ~~(row / 3) * 3;\\n    const y = ~~(col / 3) * 3;\\n    for (let i = 0; i < 3; i++) {\\n        for (let j = 0; j < 3; j++) {\\n            if (board[x + i][y + j] == c) {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943648,
                "title": "python-backtracking-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, sudoku: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def findempty(emptylist):\\n            for i in range(9):\\n                for j in range(9):\\n                    if sudoku[i][j]==\\'.\\':\\n                        emptylist[0]=i \\n                        emptylist[1]=j \\n                        return True\\n            return False\\n        def incol(val,c):\\n            for i in range(9):\\n                if sudoku[i][c]==val:\\n                    return True \\n            return False\\n        def ingrid(val,r,c):\\n            for i in range(3):\\n                for j in range(3):\\n                    if sudoku[i+r][j+c]==val:\\n                        return True\\n            return False\\n        def safe(val,i,j):\\n            return not(val in sudoku[i] or incol(val,j) or ingrid(val,i-i%3,j-j%3))\\n\\n        def solved():\\n            emptylist = [0,0]\\n            if not findempty(emptylist):\\n                return True \\n            for digit in range(1,10):\\n                if safe(str(digit),emptylist[0],emptylist[1]):\\n                    sudoku[emptylist[0]][emptylist[1]]=str(digit)\\n                    if solved():\\n                        return True\\n                    sudoku[emptylist[0]][emptylist[1]]=\\'.\\'\\n            return False\\n        solved()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, sudoku: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def findempty(emptylist):\\n            for i in range(9):\\n                for j in range(9):\\n                    if sudoku[i][j]==\\'.\\':\\n                        emptylist[0]=i \\n                        emptylist[1]=j \\n                        return True\\n            return False\\n        def incol(val,c):\\n            for i in range(9):\\n                if sudoku[i][c]==val:\\n                    return True \\n            return False\\n        def ingrid(val,r,c):\\n            for i in range(3):\\n                for j in range(3):\\n                    if sudoku[i+r][j+c]==val:\\n                        return True\\n            return False\\n        def safe(val,i,j):\\n            return not(val in sudoku[i] or incol(val,j) or ingrid(val,i-i%3,j-j%3))\\n\\n        def solved():\\n            emptylist = [0,0]\\n            if not findempty(emptylist):\\n                return True \\n            for digit in range(1,10):\\n                if safe(str(digit),emptylist[0],emptylist[1]):\\n                    sudoku[emptylist[0]][emptylist[1]]=str(digit)\\n                    if solved():\\n                        return True\\n                    sudoku[emptylist[0]][emptylist[1]]=\\'.\\'\\n            return False\\n        solved()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742929,
                "title": "c-python-clearn-backtracking-solution",
                "content": "- this is a search problem from (0, 0)\\n\\t- if the board[y][x] is filled, move to next grid\\n\\t- if not, pick a number from 1 to 9, backtracking!\\n\\nHere is the code. Enjoy it. \\n```c++\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        backtracking(0, board);\\n        return;\\n    }\\n    bool backtracking(int idx, vector<vector<char>> &board) {\\n        // fill out the board, stop!\\n        if(idx == 81) return true;\\n        // get y and x\\n        pair<int, int> xy = getXY(idx);\\n        // board[y][x] is filled \\n        if(board[xy.second][xy.first] != \\'.\\') return backtracking(idx + 1, board);\\n        // pick up a num from 1 to 9\\n        for(int i = 0; i < 9; ++i) {\\n            if(check(i, xy.second, xy.first, board)) {\\n                board[xy.second][xy.first] = \\'1\\' + i;\\n                // if a valid answer is reached, just return without trace back to original value\\n                if(backtracking(idx + 1, board)) return true;\\n                board[xy.second][xy.first] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    pair<int, int> getXY(int i) {\\n        return make_pair(i / 9, i % 9);\\n    }\\n    bool check(int num, int y, int x, vector<vector<char>> &board) {\\n        // check row \\n        for(int i = 0; i < 9; ++i) {\\n            if(board[y][i] == \\'1\\' + num) return false;\\n        }\\n        // check col\\n        for(int i = 0; i < 9; ++i) {\\n            if(board[i][x] == \\'1\\' + num) return false;\\n        }\\n        // check square\\n        int row = y / 3, col = x / 3;\\n        for(int i = row * 3; i < row * 3 + 3; ++i) {\\n            for(int j = col * 3; j < col * 3 + 3; ++j) {\\n                if(board[i][j] == \\'1\\' + num) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n- python version\\n```python\\nclass Solution(object):\\n    def solveSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: None Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        self.backtracking(0, board)\\n        return \\n        \\n    def backtracking(self, idx, board):\\n        if idx == 81:\\n            return True\\n        y, x = self.getXY(idx)\\n        if board[y][x] != \\'.\\':\\n            return self.backtracking(idx + 1, board)\\n        for i in range(1, 10):\\n            if self.check(y, x, board, str(i)):\\n                board[y][x] = str(i)\\n                if self.backtracking(idx + 1, board):\\n                    return True\\n                board[y][x] = \\'.\\'\\n        return False\\n    \\n    def getXY(self, i):\\n        y = i / 9\\n        x = i % 9\\n        return y, x\\n    \\n    def check(self, y, x, board, num):\\n        # check row\\n        for i in range(0, 9):\\n            if board[i][x] == num:\\n                return False\\n        # check col\\n        for i in range(0, 9):\\n            if board[y][i] == num:\\n                return False\\n        # check sqr\\n        row, col = y / 3, x / 3\\n        for i in range(row * 3, row * 3 + 3):\\n            for j in range(col * 3, col * 3 + 3):\\n                if board[i][j] == num:\\n                    return False\\n        return True\\n \\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        backtracking(0, board);\\n        return;\\n    }\\n    bool backtracking(int idx, vector<vector<char>> &board) {\\n        // fill out the board, stop!\\n        if(idx == 81) return true;\\n        // get y and x\\n        pair<int, int> xy = getXY(idx);\\n        // board[y][x] is filled \\n        if(board[xy.second][xy.first] != \\'.\\') return backtracking(idx + 1, board);\\n        // pick up a num from 1 to 9\\n        for(int i = 0; i < 9; ++i) {\\n            if(check(i, xy.second, xy.first, board)) {\\n                board[xy.second][xy.first] = \\'1\\' + i;\\n                // if a valid answer is reached, just return without trace back to original value\\n                if(backtracking(idx + 1, board)) return true;\\n                board[xy.second][xy.first] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    pair<int, int> getXY(int i) {\\n        return make_pair(i / 9, i % 9);\\n    }\\n    bool check(int num, int y, int x, vector<vector<char>> &board) {\\n        // check row \\n        for(int i = 0; i < 9; ++i) {\\n            if(board[y][i] == \\'1\\' + num) return false;\\n        }\\n        // check col\\n        for(int i = 0; i < 9; ++i) {\\n            if(board[i][x] == \\'1\\' + num) return false;\\n        }\\n        // check square\\n        int row = y / 3, col = x / 3;\\n        for(int i = row * 3; i < row * 3 + 3; ++i) {\\n            for(int j = col * 3; j < col * 3 + 3; ++j) {\\n                if(board[i][j] == \\'1\\' + num) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```python\\nclass Solution(object):\\n    def solveSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: None Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        self.backtracking(0, board)\\n        return \\n        \\n    def backtracking(self, idx, board):\\n        if idx == 81:\\n            return True\\n        y, x = self.getXY(idx)\\n        if board[y][x] != \\'.\\':\\n            return self.backtracking(idx + 1, board)\\n        for i in range(1, 10):\\n            if self.check(y, x, board, str(i)):\\n                board[y][x] = str(i)\\n                if self.backtracking(idx + 1, board):\\n                    return True\\n                board[y][x] = \\'.\\'\\n        return False\\n    \\n    def getXY(self, i):\\n        y = i / 9\\n        x = i % 9\\n        return y, x\\n    \\n    def check(self, y, x, board, num):\\n        # check row\\n        for i in range(0, 9):\\n            if board[i][x] == num:\\n                return False\\n        # check col\\n        for i in range(0, 9):\\n            if board[y][i] == num:\\n                return False\\n        # check sqr\\n        row, col = y / 3, x / 3\\n        for i in range(row * 3, row * 3 + 3):\\n            for j in range(col * 3, col * 3 + 3):\\n                if board[i][j] == num:\\n                    return False\\n        return True\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 349112,
                "title": "ruby-backtracing-way",
                "content": "```\\ndef solve_sudoku(board)\\n  all_empty_cells = find_all_empty_cells(board)\\n  result = fill_sudoku(board, all_empty_cells)\\n  puts(result)\\nend\\n\\ndef fill_sudoku(board, all_empty_cells)\\n  return true if all_empty_cells.empty?\\n  cell = all_empty_cells.pop\\n  options = options_of_cell(board, cell.first, cell.last)\\n  options.each do |option|\\n    board[cell.first][cell.last] = option\\n    return true if fill_sudoku(board, all_empty_cells)\\n    board[cell.first][cell.last] = \\'.\\'\\n  end\\n  all_empty_cells.push(cell)\\n  return false\\nend\\n\\ndef find_all_empty_cells(board)\\n  result = []\\n  board.each_with_index do |row, row_i|\\n    row.each_with_index do |cell, col_i|\\n      if cell == \\'.\\'\\n        result << [row_i, col_i]\\n      end\\n    end\\n  end\\n  return result\\nend\\n\\ndef options_of_cell(board, row_i, col_i)\\n  options = %w{1 2 3 4 5 6 7 8 9}\\n  i = (row_i / 3) * 3\\n  j = (col_i / 3) * 3\\n  options -= board[row_i]\\n  options -= board.map{ |row| row[col_i] }\\n  options -= (i..i+2).map do |r_i|\\n    board[r_i][j..j+2]\\n  end.flatten\\n  options\\nend\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef solve_sudoku(board)\\n  all_empty_cells = find_all_empty_cells(board)\\n  result = fill_sudoku(board, all_empty_cells)\\n  puts(result)\\nend\\n\\ndef fill_sudoku(board, all_empty_cells)\\n  return true if all_empty_cells.empty?\\n  cell = all_empty_cells.pop\\n  options = options_of_cell(board, cell.first, cell.last)\\n  options.each do |option|\\n    board[cell.first][cell.last] = option\\n    return true if fill_sudoku(board, all_empty_cells)\\n    board[cell.first][cell.last] = \\'.\\'\\n  end\\n  all_empty_cells.push(cell)\\n  return false\\nend\\n\\ndef find_all_empty_cells(board)\\n  result = []\\n  board.each_with_index do |row, row_i|\\n    row.each_with_index do |cell, col_i|\\n      if cell == \\'.\\'\\n        result << [row_i, col_i]\\n      end\\n    end\\n  end\\n  return result\\nend\\n\\ndef options_of_cell(board, row_i, col_i)\\n  options = %w{1 2 3 4 5 6 7 8 9}\\n  i = (row_i / 3) * 3\\n  j = (col_i / 3) * 3\\n  options -= board[row_i]\\n  options -= board.map{ |row| row[col_i] }\\n  options -= (i..i+2).map do |r_i|\\n    board[r_i][j..j+2]\\n  end.flatten\\n  options\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 326339,
                "title": "simple-python-solution-36ms-beat-99-70",
                "content": "How do we select the first position to make a move?\\nFind all unoccupied positions and their possibles moves,\\nselect the position with smallest possible moves and make a possible move, \\nuntil find the solution, backtrack if find contradiction.\\n\\n```\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        def backtrack():\\n            if not unoccupied: # solved\\n                return\\n            fst = (-1, -1)\\n            choices = {str(i) for i in range(1, 10)}\\n            for i, j in unoccupied:\\n                possible_moves = rows[i].intersection(cols[j]).intersection(boxs[i//3][j//3])\\n                if len(possible_moves) == 0: # contradiction, some previous moves are wrong\\n                    return\\n                elif len(possible_moves) < len(choices):\\n                    fst = (i, j)\\n                    choices = possible_moves\\n            for choice in list(choices):\\n                if unoccupied: # not solved\\n                    (i, j) = fst\\n                    unoccupied.remove(fst)\\n                    board[i][j] = choice\\n                    rows[i].remove(choice)\\n                    cols[j].remove(choice)\\n                    boxs[i//3][j//3].remove(choice)\\n                    backtrack()\\n                    if unoccupied: # not solved\\n                        unoccupied.add(fst)\\n                        board[i][j] = \\'.\\'\\n                        rows[i].add(choice)\\n                        cols[j].add(choice)\\n                        boxs[i//3][j//3].add(choice)\\n            \\n        rows = [{str(i) for i in range(1, 10)} for _ in range(9)]\\n        cols = [{str(i) for i in range(1, 10)} for _ in range(9)]\\n        boxs = [[{str(i) for i in range(1, 10)} for _ in range(3)] for _ in range(3)]\\n        unoccupied = set()\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \\'.\\':\\n                    rows[i].remove(board[i][j])\\n                    cols[j].remove(board[i][j])\\n                    boxs[i//3][j//3].remove(board[i][j])\\n                else:\\n                    unoccupied.add((i, j))\\n        backtrack()\\n```",
                "solutionTags": [],
                "code": "```\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        def backtrack():\\n            if not unoccupied: # solved\\n                return\\n            fst = (-1, -1)\\n            choices = {str(i) for i in range(1, 10)}\\n            for i, j in unoccupied:\\n                possible_moves = rows[i].intersection(cols[j]).intersection(boxs[i//3][j//3])\\n                if len(possible_moves) == 0: # contradiction, some previous moves are wrong\\n                    return\\n                elif len(possible_moves) < len(choices):\\n                    fst = (i, j)\\n                    choices = possible_moves\\n            for choice in list(choices):\\n                if unoccupied: # not solved\\n                    (i, j) = fst\\n                    unoccupied.remove(fst)\\n                    board[i][j] = choice\\n                    rows[i].remove(choice)\\n                    cols[j].remove(choice)\\n                    boxs[i//3][j//3].remove(choice)\\n                    backtrack()\\n                    if unoccupied: # not solved\\n                        unoccupied.add(fst)\\n                        board[i][j] = \\'.\\'\\n                        rows[i].add(choice)\\n                        cols[j].add(choice)\\n                        boxs[i//3][j//3].add(choice)\\n            \\n        rows = [{str(i) for i in range(1, 10)} for _ in range(9)]\\n        cols = [{str(i) for i in range(1, 10)} for _ in range(9)]\\n        boxs = [[{str(i) for i in range(1, 10)} for _ in range(3)] for _ in range(3)]\\n        unoccupied = set()\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \\'.\\':\\n                    rows[i].remove(board[i][j])\\n                    cols[j].remove(board[i][j])\\n                    boxs[i//3][j//3].remove(board[i][j])\\n                else:\\n                    unoccupied.add((i, j))\\n        backtrack()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 310600,
                "title": "clean-c-backtracking-solution-with-proper-variable-names",
                "content": "I saw a lot of solutions posted here. Couldn\\'t find one with proper variable names. So posting my solution. Runtime is `12ms`. It uses simple backtracking and constraint checking. It\\'s not very fast, but its intuitive enough for interview.\\n\\n```\\nclass Solution {\\nprivate:\\n    void initialConfiguration(vector<vector<char>>& board){\\n        for(int i=0; i<9; ++i){\\n            for(int j=0; j<9; ++j){\\n                if(board[i][j]!=\\'.\\'){\\n                    placeNumber(board, i, j, board[i][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void placeNumber(vector<vector<char>>& board, int r, int c, char d){\\n        board[r][c] = d;\\n        rowTracker[r][d-\\'1\\'] = true;\\n        colTracker[c][d-\\'1\\'] = true;\\n        boxTracker[((r/3)*3)+(c/3)][d-\\'1\\'] = true;\\n    }\\n    void removeNumber(vector<vector<char>>& board, int r, int c, char d){\\n        board[r][c] = \\'.\\';\\n        rowTracker[r][d-\\'1\\'] = false;\\n        colTracker[c][d-\\'1\\'] = false;\\n        boxTracker[((r/3)*3)+(c/3)][d-\\'1\\'] = false;\\n    }\\n    bool isSafe(vector<vector<char>>& board, int r, int c, char d){\\n        return !(   rowTracker[r][d-\\'1\\'] \\n                 || colTracker[c][d-\\'1\\'] \\n                 || boxTracker[((r/3)*3)+(c/3)][d-\\'1\\']);\\n    }\\npublic:\\n    bool backtrack(vector<vector<char>>& board, int i, int j){\\n        if(i==9){\\n            return true;\\n        }\\n        if(j==9){\\n            return backtrack(board, i+1, 0);\\n        }\\n        if(board[i][j]!=\\'.\\'){\\n            return backtrack(board, i, j+1);\\n        }\\n        for(int d=\\'1\\'; d<=\\'9\\'; ++d){\\n            if(isSafe(board, i, j, d)){\\n                placeNumber(board, i, j, d);\\n                if(backtrack(board, i, j+1)==true){\\n                    return true;\\n                }\\n                removeNumber(board, i, j, d);\\n            }\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        rowTracker = vector<vector<bool>>(9, vector<bool>(9, false));\\n        colTracker = vector<vector<bool>>(9, vector<bool>(9, false));\\n        boxTracker = vector<vector<bool>>(9, vector<bool>(9, false));\\n        \\n        initialConfiguration(board);\\n        bool isSolvable = backtrack(board, 0, 0);\\n        // cout << \"Can this config be solved ? \" << boolalpha << isSolvable;\\n        \\n        return; \\n    }\\nprivate :\\n    vector<vector<bool>> rowTracker;\\n    vector<vector<bool>> colTracker;\\n    vector<vector<bool>> boxTracker;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void initialConfiguration(vector<vector<char>>& board){\\n        for(int i=0; i<9; ++i){\\n            for(int j=0; j<9; ++j){\\n                if(board[i][j]!=\\'.\\'){\\n                    placeNumber(board, i, j, board[i][j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void placeNumber(vector<vector<char>>& board, int r, int c, char d){\\n        board[r][c] = d;\\n        rowTracker[r][d-\\'1\\'] = true;\\n        colTracker[c][d-\\'1\\'] = true;\\n        boxTracker[((r/3)*3)+(c/3)][d-\\'1\\'] = true;\\n    }\\n    void removeNumber(vector<vector<char>>& board, int r, int c, char d){\\n        board[r][c] = \\'.\\';\\n        rowTracker[r][d-\\'1\\'] = false;\\n        colTracker[c][d-\\'1\\'] = false;\\n        boxTracker[((r/3)*3)+(c/3)][d-\\'1\\'] = false;\\n    }\\n    bool isSafe(vector<vector<char>>& board, int r, int c, char d){\\n        return !(   rowTracker[r][d-\\'1\\'] \\n                 || colTracker[c][d-\\'1\\'] \\n                 || boxTracker[((r/3)*3)+(c/3)][d-\\'1\\']);\\n    }\\npublic:\\n    bool backtrack(vector<vector<char>>& board, int i, int j){\\n        if(i==9){\\n            return true;\\n        }\\n        if(j==9){\\n            return backtrack(board, i+1, 0);\\n        }\\n        if(board[i][j]!=\\'.\\'){\\n            return backtrack(board, i, j+1);\\n        }\\n        for(int d=\\'1\\'; d<=\\'9\\'; ++d){\\n            if(isSafe(board, i, j, d)){\\n                placeNumber(board, i, j, d);\\n                if(backtrack(board, i, j+1)==true){\\n                    return true;\\n                }\\n                removeNumber(board, i, j, d);\\n            }\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        rowTracker = vector<vector<bool>>(9, vector<bool>(9, false));\\n        colTracker = vector<vector<bool>>(9, vector<bool>(9, false));\\n        boxTracker = vector<vector<bool>>(9, vector<bool>(9, false));\\n        \\n        initialConfiguration(board);\\n        bool isSolvable = backtrack(board, 0, 0);\\n        // cout << \"Can this config be solved ? \" << boolalpha << isSolvable;\\n        \\n        return; \\n    }\\nprivate :\\n    vector<vector<bool>> rowTracker;\\n    vector<vector<bool>> colTracker;\\n    vector<vector<bool>> boxTracker;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 309661,
                "title": "python-solution",
                "content": "```\\nimport itertools\\nimport copy\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        if not any([\\'.\\' in x for x in board]):\\n            return\\n        minset = set(range(10))\\n        mx,my = 0,0\\n        for (i,j) in itertools.product(range(9),range(9)):\\n            if board[i][j] == \\'.\\':\\n                rset = set(board[i])\\n                cset = set([board[x][j] for x in range(9)])\\n                blockset = set([board[x][y] for (x,y) in itertools.product(range(int(i/3)*3,int(i/3)*3+3),range(int(j/3)*3,int(j/3)*3+3))])\\n                ac = set()\\n                for d in range(1,10):\\n                    d = str(d)\\n                    if d not in rset and d not in cset and d not in blockset:\\n                        # board[i][j]  = d\\n                        ac.add(d)\\n                if len(ac) < len(minset):\\n                    minset = ac\\n                    mx,my = i,j\\n        for x in minset:\\n            board[mx][my] = x\\n            self.solveSudoku(board)\\n            if not any([\\'.\\' in x for x in board]):\\n                return\\n            board[mx][my]=\\'.\\'\\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport itertools\\nimport copy\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        if not any([\\'.\\' in x for x in board]):\\n            return\\n        minset = set(range(10))\\n        mx,my = 0,0\\n        for (i,j) in itertools.product(range(9),range(9)):\\n            if board[i][j] == \\'.\\':\\n                rset = set(board[i])\\n                cset = set([board[x][j] for x in range(9)])\\n                blockset = set([board[x][y] for (x,y) in itertools.product(range(int(i/3)*3,int(i/3)*3+3),range(int(j/3)*3,int(j/3)*3+3))])\\n                ac = set()\\n                for d in range(1,10):\\n                    d = str(d)\\n                    if d not in rset and d not in cset and d not in blockset:\\n                        # board[i][j]  = d\\n                        ac.add(d)\\n                if len(ac) < len(minset):\\n                    minset = ac\\n                    mx,my = i,j\\n        for x in minset:\\n            board[mx][my] = x\\n            self.solveSudoku(board)\\n            if not any([\\'.\\' in x for x in board]):\\n                return\\n            board[mx][my]=\\'.\\'\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 15828,
                "title": "very-simple-solution-accepted-with-12ms-in-c-well-explained",
                "content": "Let's just hit the road! \\n\\n- move the pointer from left to right and the whole direction is from top-left to bottom-right;\\n- check each cell while moving;\\n- try each possible candidate from '1' to '9' while the checking cell is empty and if it's solvable from now on (recursive method) then just return it;\\n- if all possible candidates failed, return false to indicate un-solvable in this condition which means indirectly that we should try another path - typical DFS solution using recursion.\\n\\nBang! End of Story!\\n\\n- space complexity O(1) -> nothing need to be recorded here just using constant space;\\n- time complexity O(9^k) but since we just are required to find only one viable solution, the cost will be dramatically reduced.\\n\\n\\n----------\\n\\n    bool check(char** board, int r, int c, char a) //check it in row, column and the sub three-dimension cube;\\n    {\\n        for(int i = 0; i < 9; i++) if(board[r][i]==a || board[i][c]==a) return false;\\n        int r0=r-r%3, c0=c-c%3; //get the start row and column of the sub cube;\\n        for(int i = 0; i < 3; i++)\\n            for(int j = 0; j < 3; j++)\\n                if(board[r0+i][c0+j] == a) return false;\\n        return true;\\n    }\\n    bool solver(char** board, int r, int c) //check and try it from left to right and then downwards;\\n    {\\n        if(r == 9) return true; //now till the end and nothing wrong so far, so return true;\\n        if(c == 9) return solver(board, r+1, 0); //till the end of the current row and then downwards;\\n        if(board[r][c] != '.') return solver(board, r, c+1); //already taken just move to the next;\\n        for(char a = '1'; a <= '9'; a++) //try each possible candidate;\\n        {\\n            if(check(board, r, c, a)) //check its validity;\\n            {\\n                board[r][c] = a; //set it then and just move to the next;\\n                if(solver(board, r, c+1)) return true; //if it's solvable then just return true;\\n                board[r][c] = '.'; //restore it for easier checking in the next round;\\n            }\\n        }\\n        return false; //nothing works around then return false;\\n    }\\n    void solveSudoku(char** board, int rSize, int cSize)\\n    {\\n        solver(board, 0, 0); //start from the top-left position to the bottom right end;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "Let's just hit the road! \\n\\n- move the pointer from left to right and the whole direction is from top-left to bottom-right;\\n- check each cell while moving;\\n- try each possible candidate from '1' to '9' while the checking cell is empty and if it's solvable from now on (recursive method) then just return it;\\n- if all possible candidates failed, return false to indicate un-solvable in this condition which means indirectly that we should try another path - typical DFS solution using recursion.\\n\\nBang! End of Story!\\n\\n- space complexity O(1) -> nothing need to be recorded here just using constant space;\\n- time complexity O(9^k) but since we just are required to find only one viable solution, the cost will be dramatically reduced.\\n\\n\\n----------\\n\\n    bool check(char** board, int r, int c, char a) //check it in row, column and the sub three-dimension cube;\\n    {\\n        for(int i = 0; i < 9; i++) if(board[r][i]==a || board[i][c]==a) return false;\\n        int r0=r-r%3, c0=c-c%3; //get the start row and column of the sub cube;\\n        for(int i = 0; i < 3; i++)\\n            for(int j = 0; j < 3; j++)\\n                if(board[r0+i][c0+j] == a) return false;\\n        return true;\\n    }\\n    bool solver(char** board, int r, int c) //check and try it from left to right and then downwards;\\n    {\\n        if(r == 9) return true; //now till the end and nothing wrong so far, so return true;\\n        if(c == 9) return solver(board, r+1, 0); //till the end of the current row and then downwards;\\n        if(board[r][c] != '.') return solver(board, r, c+1); //already taken just move to the next;\\n        for(char a = '1'; a <= '9'; a++) //try each possible candidate;\\n        {\\n            if(check(board, r, c, a)) //check its validity;\\n            {\\n                board[r][c] = a; //set it then and just move to the next;\\n                if(solver(board, r, c+1)) return true; //if it's solvable then just return true;\\n                board[r][c] = '.'; //restore it for easier checking in the next round;\\n            }\\n        }\\n        return false; //nothing works around then return false;\\n    }\\n    void solveSudoku(char** board, int rSize, int cSize)\\n    {\\n        solver(board, 0, 0); //start from the top-left position to the bottom right end;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15769,
                "title": "share-my-clean-solution-based-on-valid-sudoku",
                "content": "Basically we will stop at each '.' in matrix,  then do DFS on it. If none of 1-9 values can meet requirement, then we know above recursion has assigned an inappropriate value, so we will return back and try another \\nvalue in above recursion. Repeat this until we can fill the whole matrix. It is not tricky, just like a brute force or enumerate solution.\\n\\n    public void solveSudoku(char[][] board) {\\n        boolean[][] cols = new boolean[9][9];\\n        boolean[][] rows = new boolean[9][9];\\n        boolean[][] blocks = new boolean[9][9];\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] == '.') continue;\\n                \\n                int val = board[i][j] - '0' - 1;\\n                int k = i/3*3 + j/3;\\n                \\n                rows[i][val] = true;\\n                cols[j][val] = true;\\n                blocks[k][val] = true;\\n            }\\n        }\\n        \\n        DFS(board, cols, rows, blocks);\\n    }\\n    \\n    public boolean DFS(char[][] board, boolean[][] cols, boolean[][] rows, boolean[][] blocks){\\n        \\n        for(int i = 0; i < 9; i++){\\n        \\tfor(int j = 0; j < 9; j++){\\n                if(board[i][j] == '.'){\\n                \\tint k = i/3*3 + j/3;\\n                    for(int l = 0; l < 9; l++){\\n                        if(!cols[j][l] && !rows[i][l] && !blocks[k][l]){\\n                            rows[i][l] = cols[j][l] = blocks[k][l] = true;\\n                            board[i][j] = (char) ('0' + 1 + l);\\n                            if(DFS(board, cols, rows, blocks)) return true;\\n                            rows[i][l] = cols[j][l] = blocks[k][l] = false;\\n                            board[i][j] = '.';                            \\n                        }\\n                    }                 \\n                    return false;\\n                }        \\t\\t\\n        \\t}\\n        }\\n\\n    \\t\\n        return true;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "Basically we will stop at each '.' in matrix,  then do DFS on it. If none of 1-9 values can meet requirement, then we know above recursion has assigned an inappropriate value, so we will return back and try another \\nvalue in above recursion. Repeat this until we can fill the whole matrix. It is not tricky, just like a brute force or enumerate solution.\\n\\n    public void solveSudoku(char[][] board) {\\n        boolean[][] cols = new boolean[9][9];\\n        boolean[][] rows = new boolean[9][9];\\n        boolean[][] blocks = new boolean[9][9];\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] == '.') continue;\\n                \\n                int val = board[i][j] - '0' - 1;\\n                int k = i/3*3 + j/3;\\n                \\n                rows[i][val] = true;\\n                cols[j][val] = true;\\n                blocks[k][val] = true;\\n            }\\n        }\\n        \\n        DFS(board, cols, rows, blocks);\\n    }\\n    \\n    public boolean DFS(char[][] board, boolean[][] cols, boolean[][] rows, boolean[][] blocks){\\n        \\n        for(int i = 0; i < 9; i++){\\n        \\tfor(int j = 0; j < 9; j++){\\n                if(board[i][j] == '.'){\\n                \\tint k = i/3*3 + j/3;\\n                    for(int l = 0; l < 9; l++){\\n                        if(!cols[j][l] && !rows[i][l] && !blocks[k][l]){\\n                            rows[i][l] = cols[j][l] = blocks[k][l] = true;\\n                            board[i][j] = (char) ('0' + 1 + l);\\n                            if(DFS(board, cols, rows, blocks)) return true;\\n                            rows[i][l] = cols[j][l] = blocks[k][l] = false;\\n                            board[i][j] = '.';                            \\n                        }\\n                    }                 \\n                    return false;\\n                }        \\t\\t\\n        \\t}\\n        }\\n\\n    \\t\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15949,
                "title": "2ms-120-line-c-with-dlx",
                "content": "ok, not enough clean...\\n\\n    class Solution {\\n    public:\\n        static const int maxn = 15;\\n    \\n        int n;\\n    \\n        static const int maxCol = maxn * maxn * 4;\\n        static const int maxNode = maxCol + maxn * maxn * maxn * 4;\\n    \\n        int ID;\\n        int h, S[maxCol], N[maxCol];\\n        int U[maxNode], D[maxNode], L[maxNode], R[maxNode], C[maxNode], V[maxNode];\\n    \\n        char str[maxn*maxn];\\n    \\n        bool succ;\\n        void DL(int c, bool uncover = false)\\n        {\\n            if (!uncover) {R[L[c]] = R[c], L[R[c]] = L[c];}\\n            else {R[L[c]] = L[R[c]] = c;}\\n            for (int i = D[c]; i != c; i = D[i]) {\\n                for (int j = R[i]; j != i; j = R[j]) {\\n                    if (!uncover) {U[D[j]]=U[j], D[U[j]]=D[j], --S[C[j]];}\\n                    else {U[D[j]] = D[U[j]] = j, ++S[C[j]];}\\n                }\\n            }\\n        }\\n        void dfs(int dep)\\n        {\\n            if (succ || R[h] == h) {\\n                succ = true;\\n                return ;\\n            }\\n            int c = R[h];\\n            for (int i = R[h]; i != h; i = R[i]) {\\n                if (!S[i]) return ;\\n                if (S[i] < S[c]) c = i;\\n            }\\n            DL(c);\\n            for (int i = D[c]; i != c; i = D[i]) {\\n                N[c] = V[i];\\n                for (int j = R[i]; j != i; j = R[j]) {\\n                    DL(C[j]), N[C[j]] = V[j];\\n                }\\n                dfs(dep+1);\\n                if (succ) return ;\\n                for (int j = L[i]; j != i; j = L[j]) {\\n                    DL(C[j], true);\\n                }\\n            }\\n            DL(c, true);\\n        }\\n        int add(int c, int v)\\n        {\\n            ++S[c];\\n            L[ID] = R[ID] = ID;\\n            U[ID] = U[c], D[ID]  = c;\\n            D[U[ID]] = U[D[ID]] = ID;\\n            V[ID] = v;\\n            C[ID] = c;\\n            return ID++;\\n        }\\n        # define INSR(x, y) do{ L[y]=x,R[y]=R[x];R[L[y]]=L[R[y]]=y; }while(0)\\n        void solveSudoku(std::vector<std::vector<char> > &board) {\\n            n = 9;\\n    \\n            char str[maxn*maxn];\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    str[i*9+j] = board[i][j];\\n                }\\n            }\\n            str[n*n] = 0;\\n    \\n            h = 4*n*n;\\n            for (int c = 0; c <= h; ++c) {\\n                S[c] = 0;\\n                C[c] = D[c] = U[c] = c;\\n                L[c] = (c ? c-1:h), R[c] = (c==h ? 0:c+1);\\n            }\\n            ID = h + 1;\\n            for (int i = 0; str[i]; ++i) {\\n                int x = i / 9, y = i % 9;\\n                int lo = 1, hi = n;\\n                if ('1'<=str[i]&&str[i]<='0'+n) {\\n                    lo = hi = str[i] - '0';\\n                    V[i] = str[i] - '0';\\n                }\\n                for (int j = lo; j <= hi; ++j) {\\n                    int a = add(i, j);\\n                    int b = add(n*n+x*9+j-1, j);\\n                    int c = add(2*n*n+y*9+j-1, j);\\n                    int d = add(3*n*n+(x/3*3+y/3)*9+j-1, j);\\n                    INSR(a, b);\\n                    INSR(b, c);\\n                    INSR(c, d);\\n                }\\n            }\\n            for (int i = R[h]; i != h; i = R[i]) {\\n                if (S[i] == 0) return;\\n                if (S[i] == 1) {\\n                    N[i] = V[i];\\n                    DL(i);\\n                    for (int j = D[i]; j != i; j = D[j]) {\\n                        for (int k = R[j]; k != j; k = R[k]) DL(C[k]), N[C[k]] = V[k];\\n                    }\\n                }\\n            }\\n            succ = false;\\n            dfs(0);\\n            if (succ) {\\n                for (int i = 0; i < n*n; ++i) {\\n                    board[i/9][i%9] = N[i] + '0';\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        static const int maxn = 15;\\n    \\n        int n;\\n    \\n        static const int maxCol = maxn * maxn * 4;\\n        static const int maxNode = maxCol + maxn * maxn * maxn * 4;\\n    \\n        int ID;\\n        int h, S[maxCol], N[maxCol];\\n        int U[maxNode], D[maxNode], L[maxNode], R[maxNode], C[maxNode], V[maxNode];\\n    \\n        char str[maxn*maxn];\\n    \\n        bool succ;\\n        void DL(int c, bool uncover = false)\\n        {\\n            if (!uncover) {R[L[c]] = R[c], L[R[c]] = L[c];}",
                "codeTag": "Java"
            },
            {
                "id": 15800,
                "title": "is-a-naive-backtracking-approach-acceptable",
                "content": "Hi,\\n\\nMy approach for this is to simply go look at the first empty cell, try everything from 1..9 in there, and if that results in a valid board, continue on with the rest of the board.\\n\\nMy solution times out on one of the inputs, although the same problem is correctly solved in 0.06 seconds on my laptop. How do I need to improve my solution to pass?\\n\\nCode:\\n\\n    public static void solveSudoku(char[][] board) {\\n            solve(board, 0);\\n        }\\n        \\n        private static boolean solve(char[][] board, int ind){\\n        \\tif(ind == 81) return true; // solved and it's correct\\n        \\t\\n        \\tint row = ind / 9;\\n        \\tint col = ind % 9;\\n        \\t\\n        \\t// Advance forward on cells that are prefilled\\n        \\tif(board[row][col] != '.') return solve(board, ind+1);\\n        \\t\\n        \\telse{\\n                // we are positioned on first something we need to fill in.\\n                // Try all possibilities\\n        \\t\\t\\n                for(int i = 1; i <= 9; i++){\\n                    board[row][col] = Character.forDigit(i,10);\\n                    if(isValidSudoku(board)){\\n                    \\t// Don't backtrack if this choice leads\\n                    \\t// to a final solution since we need to modify\\n                    \\t// the original array\\n                    \\tif(solve(board, ind+1)) return true; \\n                    }\\n                    board[row][col] = '.'; // unmake move\\n                }    \\t\\t\\n        \\t}\\n        \\t\\n        \\t// no solution\\n        \\treturn false;\\n        }\\n \\nAnd here is the validation function I just copy/pasted from my solution to the previous question which asked to validate a partially filled board. It's rather verbose, but it passed the test:\\n\\n    // validates sudoku board\\n        public static boolean isValidSudoku(char[][] board) {\\n            final int ROWS = 9;\\n            final int COLS = 9;\\n            boolean[] nums = new boolean[10];\\n            \\n            // validate every row\\n            for(int row = 0; row < ROWS; row++){\\n                for(int col = 0; col < COLS; col++){\\n                    int num = Character.getNumericValue(board[row][col]);\\n                    if(board[row][col] != '.'){\\n                        if(nums[num]) return false;\\n                        nums[num] = true;                    \\n                    }\\n                }\\n                for(int i = 0; i < nums.length; i++) nums[i] = false; // reset\\n            }\\n            \\n            // validate every column\\n            for(int col = 0; col < COLS; col++){\\n                for(int row = 0; row < ROWS; row++){\\n                    int num = Character.getNumericValue(board[row][col]);\\n                    if(board[row][col] != '.'){\\n                        if(nums[num]) return false;\\n                        nums[num] = true;                    \\n                    }\\n                }\\n                for(int i = 0; i < nums.length; i++) nums[i] = false; // reset\\n            }\\n            \\n            // validate every grid subsquare\\n            \\n            for(int i = 0; i < ROWS; i += 3){\\n                for(int j = 0; j < COLS; j += 3){\\n                   for(int k = 0; k < 3; k++){\\n                       for(int m = 0; m < 3; m++){\\n                         char elem = board[i+k][j+m];\\n                         if(elem != '.'){\\n                           int num = Character.getNumericValue(elem);\\n                           if(nums[num]) return false;\\n                           nums[num] = true;  \\n                         }                       \\n                       }\\n                   }\\n                   for(int z = 0; z < nums.length; z++) nums[z] = false;\\n                }\\n            } \\n            return true;\\n        }\\n\\nFor the input \\n\\n\"..9748...\",\"7........\",\".2.1.9...\",\"..7...24.\",\".64.1.59.\",\".98...3..\",\"...8.3.2.\",\"........6\",\"...2759..\"\\n\\nmy solution gives me, in 0.06 seconds:\\n\\n    5 1 9 7 4 8 6 3 2 \\n    7 8 3 6 5 2 4 1 9 \\n    4 2 6 1 3 9 8 7 5 \\n    3 5 7 9 8 6 2 4 1 \\n    2 6 4 3 1 7 5 9 8 \\n    1 9 8 5 2 4 3 6 7 \\n    9 7 5 8 6 3 1 2 4 \\n    8 3 2 4 9 1 7 5 6 \\n    6 4 1 2 7 5 9 8 3",
                "solutionTags": [],
                "code": "Hi,\\n\\nMy approach for this is to simply go look at the first empty cell, try everything from 1..9 in there, and if that results in a valid board, continue on with the rest of the board.\\n\\nMy solution times out on one of the inputs, although the same problem is correctly solved in 0.06 seconds on my laptop. How do I need to improve my solution to pass?\\n\\nCode:\\n\\n    public static void solveSudoku(char[][] board) {\\n            solve(board, 0);\\n        }\\n        \\n        private static boolean solve(char[][] board, int ind){\\n        \\tif(ind == 81) return true; // solved and it's correct\\n        \\t\\n        \\tint row = ind / 9;\\n        \\tint col = ind % 9;\\n        \\t\\n        \\t// Advance forward on cells that are prefilled\\n        \\tif(board[row][col] != '.') return solve(board, ind+1);\\n        \\t\\n        \\telse{\\n                // we are positioned on first something we need to fill in.\\n                // Try all possibilities\\n        \\t\\t\\n                for(int i = 1; i <= 9; i++){\\n                    board[row][col] = Character.forDigit(i,10);\\n                    if(isValidSudoku(board)){\\n                    \\t// Don't backtrack if this choice leads\\n                    \\t// to a final solution since we need to modify\\n                    \\t// the original array\\n                    \\tif(solve(board, ind+1)) return true; \\n                    }\\n                    board[row][col] = '.'; // unmake move\\n                }    \\t\\t\\n        \\t}\\n        \\t\\n        \\t// no solution\\n        \\treturn false;\\n        }\\n \\nAnd here is the validation function I just copy/pasted from my solution to the previous question which asked to validate a partially filled board. It's rather verbose, but it passed the test:\\n\\n    // validates sudoku board\\n        public static boolean isValidSudoku(char[][] board) {\\n            final int ROWS = 9;\\n            final int COLS = 9;\\n            boolean[] nums = new boolean[10];\\n            \\n            // validate every row\\n            for(int row = 0; row < ROWS; row++){\\n                for(int col = 0; col < COLS; col++){\\n                    int num = Character.getNumericValue(board[row][col]);\\n                    if(board[row][col] != '.'){\\n                        if(nums[num]) return false;\\n                        nums[num] = true;                    \\n                    }\\n                }\\n                for(int i = 0; i < nums.length; i++) nums[i] = false; // reset\\n            }\\n            \\n            // validate every column\\n            for(int col = 0; col < COLS; col++){\\n                for(int row = 0; row < ROWS; row++){\\n                    int num = Character.getNumericValue(board[row][col]);\\n                    if(board[row][col] != '.'){\\n                        if(nums[num]) return false;\\n                        nums[num] = true;                    \\n                    }\\n                }\\n                for(int i = 0; i < nums.length; i++) nums[i] = false; // reset\\n            }\\n            \\n            // validate every grid subsquare\\n            \\n            for(int i = 0; i < ROWS; i += 3){\\n                for(int j = 0; j < COLS; j += 3){\\n                   for(int k = 0; k < 3; k++){\\n                       for(int m = 0; m < 3; m++){\\n                         char elem = board[i+k][j+m];\\n                         if(elem != '.'){\\n                           int num = Character.getNumericValue(elem);\\n                           if(nums[num]) return false;\\n                           nums[num] = true;  \\n                         }                       \\n                       }\\n                   }\\n                   for(int z = 0; z < nums.length; z++) nums[z] = false;\\n                }\\n            } \\n            return true;\\n        }\\n\\nFor the input \\n\\n\"..9748...\",\"7........\",\".2.1.9...\",\"..7...24.\",\".64.1.59.\",\".98...3..\",\"...8.3.2.\",\"........6\",\"...2759..\"\\n\\nmy solution gives me, in 0.06 seconds:\\n\\n    5 1 9 7 4 8 6 3 2 \\n    7 8 3 6 5 2 4 1 9 \\n    4 2 6 1 3 9 8 7 5 \\n    3 5 7 9 8 6 2 4 1 \\n    2 6 4 3 1 7 5 9 8 \\n    1 9 8 5 2 4 3 6 7 \\n    9 7 5 8 6 3 1 2 4 \\n    8 3 2 4 9 1 7 5 6 \\n    6 4 1 2 7 5 9 8 3",
                "codeTag": "Unknown"
            },
            {
                "id": 3900934,
                "title": "easy-c-solution-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool safe(int row,int col,vector<vector<char>>& board,char c){\\n        for(int i = 0; i < 9;i++){\\n            if(board[row][i] == c) return false;\\n\\n            if(board[i][col] == c) return false;\\n\\n            if(board[3*(row/3) + (i/3)][3*(col/3) + (i%3)] == c) return false;\\n\\n        }\\n        return true;\\n    }\\n    \\n    bool solve(vector<vector<char>>& board){\\n        int n = board[0].size();\\n\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0; j < n;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c = \\'1\\'; c <= \\'9\\';c++){\\n                        if(safe(i,j,board,c)){\\n                            board[i][j] = c;\\n                            bool possible = solve(board);\\n                            if(possible){\\n                                return true;\\n                            }\\n                            else{\\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }     \\n                    }\\n                    return false;\\n                }\\n        \\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& sudoku) {\\n        solve(sudoku);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool safe(int row,int col,vector<vector<char>>& board,char c){\\n        for(int i = 0; i < 9;i++){\\n            if(board[row][i] == c) return false;\\n\\n            if(board[i][col] == c) return false;\\n\\n            if(board[3*(row/3) + (i/3)][3*(col/3) + (i%3)] == c) return false;\\n\\n        }\\n        return true;\\n    }\\n    \\n    bool solve(vector<vector<char>>& board){\\n        int n = board[0].size();\\n\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0; j < n;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char c = \\'1\\'; c <= \\'9\\';c++){\\n                        if(safe(i,j,board,c)){\\n                            board[i][j] = c;\\n                            bool possible = solve(board);\\n                            if(possible){\\n                                return true;\\n                            }\\n                            else{\\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }     \\n                    }\\n                    return false;\\n                }\\n        \\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& sudoku) {\\n        solve(sudoku);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709303,
                "title": "issafe-condtion-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI read a lot of solutions but no one truly explained the most important check condition for the given problem. \\nA normal backtracking problem where we place a certain number on an empty cell and check if it solves our problem or else we backtrack to the last valid state.\\nThe solve function is pretty normal if you have solved any backtracking question before so I shall leave that upto you.\\nThe **most important part** of the question is the `isSafe function`\\nRules of Sudoku : \\n1. A number shall not repeat in any row\\n2. A number shall not repeat in any column\\n3. A number shall not repeat in the smaller 3x3 block\\n\\nIts easy to check the first 2 conditions.\\nLets focus on the 3rd condition.\\nIf you make a 9x9 board and write down the indices(0-based) you shall notice that the upper left corner of every small 3x3 box has indices of the form - (3x,3y).\\nOnce i have these indices I can run a normal for loop to check the smaller block\\n\\n*****board[3*(row/3) + i%3][3*(col/3) + j%3]*** is the required check condition where 3*(row/3) gives us the 3x type of index and + i%3 is the displacement in the given row.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isSafe(vector<vector<char>>& board, int row, int col, char ch ){\\n        for( int i = 0; i < 9; i++ ){\\n            if( board[i][col] == ch && i != row ){\\n                return false;\\n            }\\n            if( board[row][i] == ch && i != col ){\\n                return false;\\n            }\\n        }\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if( (board[3*(row/3) + i%3][3*(col/3) + j%3] == ch) && (3*(row/3) + i%3 != row) && (3*(col/3) + j%3 != col )){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n    bool solve( vector<vector<char>>& board ){\\n        for( int i = 0; i < board.size(); i++ ){\\n            for( int j = 0; j < board.size(); j++ ){\\n                if( board[i][j] == \\'.\\' ){\\n                    for( char ch = \\'1\\'; ch <= \\'9\\'; ch++ ){\\n                        if( isSafe(board,i,j,ch) ){\\n                            // place the current character\\n                            board[i][j] = ch;\\n                            if( solve(board) == true ){\\n                                return true;\\n                            }\\n                            // if the currently placed character does not return true then backtrack\\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isSafe(vector<vector<char>>& board, int row, int col, char ch ){\\n        for( int i = 0; i < 9; i++ ){\\n            if( board[i][col] == ch && i != row ){\\n                return false;\\n            }\\n            if( board[row][i] == ch && i != col ){\\n                return false;\\n            }\\n        }\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if( (board[3*(row/3) + i%3][3*(col/3) + j%3] == ch) && (3*(row/3) + i%3 != row) && (3*(col/3) + j%3 != col )){\\n                return false;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n    bool solve( vector<vector<char>>& board ){\\n        for( int i = 0; i < board.size(); i++ ){\\n            for( int j = 0; j < board.size(); j++ ){\\n                if( board[i][j] == \\'.\\' ){\\n                    for( char ch = \\'1\\'; ch <= \\'9\\'; ch++ ){\\n                        if( isSafe(board,i,j,ch) ){\\n                            // place the current character\\n                            board[i][j] = ch;\\n                            if( solve(board) == true ){\\n                                return true;\\n                            }\\n                            // if the currently placed character does not return true then backtrack\\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696602,
                "title": "c-backtracking-faster-than-100-c-submissions",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void ans(vector<vector<char>>& board, vector<vector<char>>& curr, int i, int j, vector<vector<bool>>& col, vector<vector<bool>>& row, vector<vector<bool>>& mat) {\\n        while(i < 9 && board[i][j] != \\'.\\') {\\n            if (j < 8) j++;\\n            else {\\n                j = 0;\\n                i++;\\n            }\\n        }\\n        if(i == 9) {\\n            curr = board;\\n            return;\\n        }\\n\\n        for(int k = 1; k <= 9; k++) {\\n            if(curr.size() > 0) break;\\n            if(!col[j][k] && !row[i][k] && !mat[3*(i/3) + (j/3)][k]) {\\n                col[j][k] = true;\\n                row[i][k] = true;\\n                mat[3*(i/3) + (j/3)][k] = true;\\n                board[i][j] = (char)(\\'0\\'+k);\\n                ans(board, curr, i, j, col, row, mat);\\n                col[j][k] = false;\\n                row[i][k] = false;\\n                mat[3*(i/3) + (j/3)][k] = false;\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        vector<vector<bool>> col(9, vector<bool>(10, false));\\n        vector<vector<bool>> row(9, vector<bool>(10, false));\\n        vector<vector<bool>> mat(9, vector<bool>(10, false));\\n        vector<vector<char>> curr;\\n\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    int x = board[i][j] - \\'0\\';\\n                    row[i][x] = true;\\n                    col[j][x] = true;\\n                    mat[3*(i/3) + (j/3)][x] = true;\\n                }\\n            }\\n        }\\n\\n        ans(board, curr, 0, 0, col, row, mat);\\n        board = curr;\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void ans(vector<vector<char>>& board, vector<vector<char>>& curr, int i, int j, vector<vector<bool>>& col, vector<vector<bool>>& row, vector<vector<bool>>& mat) {\\n        while(i < 9 && board[i][j] != \\'.\\') {\\n            if (j < 8) j++;\\n            else {\\n                j = 0;\\n                i++;\\n            }\\n        }\\n        if(i == 9) {\\n            curr = board;\\n            return;\\n        }\\n\\n        for(int k = 1; k <= 9; k++) {\\n            if(curr.size() > 0) break;\\n            if(!col[j][k] && !row[i][k] && !mat[3*(i/3) + (j/3)][k]) {\\n                col[j][k] = true;\\n                row[i][k] = true;\\n                mat[3*(i/3) + (j/3)][k] = true;\\n                board[i][j] = (char)(\\'0\\'+k);\\n                ans(board, curr, i, j, col, row, mat);\\n                col[j][k] = false;\\n                row[i][k] = false;\\n                mat[3*(i/3) + (j/3)][k] = false;\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        vector<vector<bool>> col(9, vector<bool>(10, false));\\n        vector<vector<bool>> row(9, vector<bool>(10, false));\\n        vector<vector<bool>> mat(9, vector<bool>(10, false));\\n        vector<vector<char>> curr;\\n\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    int x = board[i][j] - \\'0\\';\\n                    row[i][x] = true;\\n                    col[j][x] = true;\\n                    mat[3*(i/3) + (j/3)][x] = true;\\n                }\\n            }\\n        }\\n\\n        ans(board, curr, 0, 0, col, row, mat);\\n        board = curr;\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683921,
                "title": "c-well-commented-backtracking-faster-than-100-c-submissions",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void ans(vector<vector<char>>& board, vector<vector<char>>& curr, int i, int j, vector<vector<bool>>& col, vector<vector<bool>>& row, vector<vector<bool>>& mat) {\\n        // Find the next empty cell\\n        while(i < 9 && board[i][j] != \\'.\\') {\\n            if (j < 8)\\n                j++;\\n            else {\\n                j = 0;\\n                i++;\\n            }\\n        }\\n\\n        // If we have reached the end of the board, we have found a solution\\n        if(i == 9) {\\n            curr = board;\\n            return;\\n        }\\n\\n        // Try different numbers from 1 to 9\\n        for(int k = 1; k <= 9; k++) {\\n            // If a solution has already been found, exit the loop\\n            if(curr.size() > 0)\\n                break;\\n\\n            // Check if the current number k is valid for the current cell\\n            if(!col[j][k] && !row[i][k] && !mat[3*(i/3) + (j/3)][k]) {\\n                // Mark the current number k as used\\n                col[j][k] = true;\\n                row[i][k] = true;\\n                mat[3*(i/3) + (j/3)][k] = true;\\n\\n                // Place the current number k in the current cell\\n                board[i][j] = (char)(\\'0\\'+k);\\n\\n                // Recursively solve the Sudoku puzzle\\n                ans(board, curr, i, j, col, row, mat);\\n\\n                // Undo the current number k and mark it as unused\\n                col[j][k] = false;\\n                row[i][k] = false;\\n                mat[3*(i/3) + (j/3)][k] = false;\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        vector<vector<bool>> col(9, vector<bool>(10, false));\\n        vector<vector<bool>> row(9, vector<bool>(10, false));\\n        vector<vector<bool>> mat(9, vector<bool>(10, false));\\n        vector<vector<char>> curr;\\n\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    int x = board[i][j] - \\'0\\';\\n                    row[i][x] = true;\\n                    col[j][x] = true;\\n                    mat[3*(i/3) + (j/3)][x] = true;\\n                }\\n            }\\n        }\\n\\n        ans(board, curr, 0, 0, col, row, mat);\\n        board = curr;\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void ans(vector<vector<char>>& board, vector<vector<char>>& curr, int i, int j, vector<vector<bool>>& col, vector<vector<bool>>& row, vector<vector<bool>>& mat) {\\n        // Find the next empty cell\\n        while(i < 9 && board[i][j] != \\'.\\') {\\n            if (j < 8)\\n                j++;\\n            else {\\n                j = 0;\\n                i++;\\n            }\\n        }\\n\\n        // If we have reached the end of the board, we have found a solution\\n        if(i == 9) {\\n            curr = board;\\n            return;\\n        }\\n\\n        // Try different numbers from 1 to 9\\n        for(int k = 1; k <= 9; k++) {\\n            // If a solution has already been found, exit the loop\\n            if(curr.size() > 0)\\n                break;\\n\\n            // Check if the current number k is valid for the current cell\\n            if(!col[j][k] && !row[i][k] && !mat[3*(i/3) + (j/3)][k]) {\\n                // Mark the current number k as used\\n                col[j][k] = true;\\n                row[i][k] = true;\\n                mat[3*(i/3) + (j/3)][k] = true;\\n\\n                // Place the current number k in the current cell\\n                board[i][j] = (char)(\\'0\\'+k);\\n\\n                // Recursively solve the Sudoku puzzle\\n                ans(board, curr, i, j, col, row, mat);\\n\\n                // Undo the current number k and mark it as unused\\n                col[j][k] = false;\\n                row[i][k] = false;\\n                mat[3*(i/3) + (j/3)][k] = false;\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        vector<vector<bool>> col(9, vector<bool>(10, false));\\n        vector<vector<bool>> row(9, vector<bool>(10, false));\\n        vector<vector<bool>> mat(9, vector<bool>(10, false));\\n        vector<vector<char>> curr;\\n\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    int x = board[i][j] - \\'0\\';\\n                    row[i][x] = true;\\n                    col[j][x] = true;\\n                    mat[3*(i/3) + (j/3)][x] = true;\\n                }\\n            }\\n        }\\n\\n        ans(board, curr, 0, 0, col, row, mat);\\n        board = curr;\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634621,
                "title": "bactracking-beginner-friendly-solution-beats-93-90",
                "content": "```\\nclass Solution {\\n    vector<vector<char>> res;\\n    vector<vector<bool>> row{9, vector<bool>(10)};\\n    vector<vector<bool>> col{9, vector<bool>(10)};\\n    vector<vector<bool>> sub{9, vector<bool>(10)};\\n\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    row[i][board[i][j]-\\'0\\'] = 1;\\n                    col[j][board[i][j]-\\'0\\'] = 1;\\n                    sub[i/3*3 + j/3][board[i][j]-\\'0\\'] = 1;\\n                }\\n            }\\n        }\\n\\n        helper(board, 0, 0);\\n        board = res;\\n    }\\n    \\n    void helper(vector<vector<char>>& board, int i, int j) {\\n        if (i==8 and j==9) {\\n            res = board;\\n            return;\\n        }\\n\\n        if (j==9) {i++; j=0;}\\n        if (i==9) return;\\n\\n        if (board[i][j] != \\'.\\') {\\n            helper(board, i, j+1);\\n            return;\\n        }\\n\\n        for (int k=1; k<=9; k++) {\\n            if (row[i][k] || col[j][k] || sub[i/3*3+j/3][k]) continue;\\n\\n            row[i][k] = 1;\\n            col[j][k] = 1;\\n            sub[i/3*3 + j/3][k] = 1;\\n\\n            board[i][j] = k+\\'0\\';\\n            helper(board, i, j+1);\\n            board[i][j] = \\'.\\';\\n\\n            row[i][k] = 0;\\n            col[j][k] = 0;\\n            sub[i/3*3 + j/3][k] = 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<char>> res;\\n    vector<vector<bool>> row{9, vector<bool>(10)};\\n    vector<vector<bool>> col{9, vector<bool>(10)};\\n    vector<vector<bool>> sub{9, vector<bool>(10)};\\n\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    row[i][board[i][j]-\\'0\\'] = 1;\\n                    col[j][board[i][j]-\\'0\\'] = 1;\\n                    sub[i/3*3 + j/3][board[i][j]-\\'0\\'] = 1;\\n                }\\n            }\\n        }\\n\\n        helper(board, 0, 0);\\n        board = res;\\n    }\\n    \\n    void helper(vector<vector<char>>& board, int i, int j) {\\n        if (i==8 and j==9) {\\n            res = board;\\n            return;\\n        }\\n\\n        if (j==9) {i++; j=0;}\\n        if (i==9) return;\\n\\n        if (board[i][j] != \\'.\\') {\\n            helper(board, i, j+1);\\n            return;\\n        }\\n\\n        for (int k=1; k<=9; k++) {\\n            if (row[i][k] || col[j][k] || sub[i/3*3+j/3][k]) continue;\\n\\n            row[i][k] = 1;\\n            col[j][k] = 1;\\n            sub[i/3*3 + j/3][k] = 1;\\n\\n            board[i][j] = k+\\'0\\';\\n            helper(board, i, j+1);\\n            board[i][j] = \\'.\\';\\n\\n            row[i][k] = 0;\\n            col[j][k] = 0;\\n            sub[i/3*3 + j/3][k] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633318,
                "title": "easiest-implementation-c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<vector<char>>& board, int row, int col, char ch){\\n        for(int j=0; j<9; j++){\\n            if(board[row][j] == ch) return false;\\n        }\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] == ch) return false;\\n        }\\n\\n        int rMin = row - (row%3);\\n        int cMin = col - (col%3);\\n        for(int i=rMin; i<rMin+3; i++){\\n            for(int j=cMin; j<cMin+3; j++){\\n                if(board[i][j] == ch) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch=\\'1\\'; ch<=\\'9\\'; ch++){\\n                        if(check(board,i,j,ch)){\\n                            board[i][j] = ch;\\n                            if(solve(board)) return true;\\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<vector<char>>& board, int row, int col, char ch){\\n        for(int j=0; j<9; j++){\\n            if(board[row][j] == ch) return false;\\n        }\\n        for(int i=0; i<9; i++){\\n            if(board[i][col] == ch) return false;\\n        }\\n\\n        int rMin = row - (row%3);\\n        int cMin = col - (col%3);\\n        for(int i=rMin; i<rMin+3; i++){\\n            for(int j=cMin; j<cMin+3; j++){\\n                if(board[i][j] == ch) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    for(char ch=\\'1\\'; ch<=\\'9\\'; ch++){\\n                        if(check(board,i,j,ch)){\\n                            board[i][j] = ch;\\n                            if(solve(board)) return true;\\n                            board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593332,
                "title": "c-clean-code-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<vector<char>>& board, int i, int j, char val){\\n        int sRow = i/3*3;\\n        int sCol = j/3*3;\\n\\n        for(int k=0; k<9; k++){\\n            if(board[i][k] == val) return false;\\n            if(board[k][j] == val) return false;\\n\\n            if(board[k/3 + sRow][k%3 + sCol] == val) return false;\\n        }\\n\\n        return true;\\n    }\\n    bool solver(vector<vector<char>>& board, int row, int col){\\n        if(row == 9) return true;\\n\\n        if(board[row][col] == \\'.\\'){\\n            for(char ch=\\'1\\'; ch<=\\'9\\'; ch++){\\n                if(isValid(board,row,col,ch)){\\n                    board[row][col] = ch;\\n                    if(col < 8){\\n                        if(solver(board,row,col+1)) return true;\\n                    }\\n                    else if(solver(board,row+1,0)) return true;\\n\\n                    board[row][col] = \\'.\\';\\n                }\\n            }\\n        }\\n        else{\\n            if(col < 8){\\n                if(solver(board,row,col+1)) return true;\\n            }\\n\\n            else if(solver(board,row+1,0)) return true;\\n        }\\n        \\n\\n        return false;\\n\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solver(board,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<vector<char>>& board, int i, int j, char val){\\n        int sRow = i/3*3;\\n        int sCol = j/3*3;\\n\\n        for(int k=0; k<9; k++){\\n            if(board[i][k] == val) return false;\\n            if(board[k][j] == val) return false;\\n\\n            if(board[k/3 + sRow][k%3 + sCol] == val) return false;\\n        }\\n\\n        return true;\\n    }\\n    bool solver(vector<vector<char>>& board, int row, int col){\\n        if(row == 9) return true;\\n\\n        if(board[row][col] == \\'.\\'){\\n            for(char ch=\\'1\\'; ch<=\\'9\\'; ch++){\\n                if(isValid(board,row,col,ch)){\\n                    board[row][col] = ch;\\n                    if(col < 8){\\n                        if(solver(board,row,col+1)) return true;\\n                    }\\n                    else if(solver(board,row+1,0)) return true;\\n\\n                    board[row][col] = \\'.\\';\\n                }\\n            }\\n        }\\n        else{\\n            if(col < 8){\\n                if(solver(board,row,col+1)) return true;\\n            }\\n\\n            else if(solver(board,row+1,0)) return true;\\n        }\\n        \\n\\n        return false;\\n\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solver(board,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362415,
                "title": "c-using-recursion-backtracking-well-commented",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool solve(vector<vector<char>> &board){   \\n        // 1. Find empty cell\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                \\n                // 2. Found an empty cell\\n                if(board[i][j] == \\'.\\'){\\n                    \\n                    // 3. Try to place number 1-9\\n                    for(char ch=\\'1\\'; ch<=\\'9\\'; ch++){\\n                        if(isValid(board, i, j, ch)){\\n                            \\n                            // 4. Can be placed so place it\\n                            // and call recursion for further filling\\n                            \\n                            board[i][j] = ch;\\n                            \\n                            // 5. If the recursion returns true, then don\\'t try anymore\\n                            // just return back as only one soluton is needed\\n                            if(solve(board))\\n                                return true;\\n                            else{\\n                                board[i][j] = \\'.\\';   \\n                            }\\n                        }\\n                    }\\n                    \\n                    // 6. If can\\'t place any number, then return false\\n                    return false;\\n                }\\n                \\n            }\\n        }\\n        \\n        // 7. If found no empty places means board is already solved so just return true\\n        return true;\\n    }\\n    \\n    bool isValid(vector<vector<char>>& board, int row, int col, char ch){\\n        for(int i=0; i<9; i++){\\n            // Check the row\\n            if(board[row][i] == ch) return false;\\n\\n            // Check the column\\n            if(board[i][col] == ch) return false;\\n\\n            // Check the submatrix\\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3] == ch) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool solve(vector<vector<char>> &board){   \\n        // 1. Find empty cell\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                \\n                // 2. Found an empty cell\\n                if(board[i][j] == \\'.\\'){\\n                    \\n                    // 3. Try to place number 1-9\\n                    for(char ch=\\'1\\'; ch<=\\'9\\'; ch++){\\n                        if(isValid(board, i, j, ch)){\\n                            \\n                            // 4. Can be placed so place it\\n                            // and call recursion for further filling\\n                            \\n                            board[i][j] = ch;\\n                            \\n                            // 5. If the recursion returns true, then don\\'t try anymore\\n                            // just return back as only one soluton is needed\\n                            if(solve(board))\\n                                return true;\\n                            else{\\n                                board[i][j] = \\'.\\';   \\n                            }\\n                        }\\n                    }\\n                    \\n                    // 6. If can\\'t place any number, then return false\\n                    return false;\\n                }\\n                \\n            }\\n        }\\n        \\n        // 7. If found no empty places means board is already solved so just return true\\n        return true;\\n    }\\n    \\n    bool isValid(vector<vector<char>>& board, int row, int col, char ch){\\n        for(int i=0; i<9; i++){\\n            // Check the row\\n            if(board[row][i] == ch) return false;\\n\\n            // Check the column\\n            if(board[i][col] == ch) return false;\\n\\n            // Check the submatrix\\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3] == ch) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288694,
                "title": "python-iterative-backtracking-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    \\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        row = { i:[0]*10 for i in range(0,9) }\\n        col = { i:[0]*10 for i in range(0,9) }\\n        box = { i:[0]*10 for i in range(0,9) }\\n        n,m = len(board),len(board[0])\\n        for i in range(0,n):\\n            for j in range(0,m):\\n                box_index = 3*(i//3) + j//3 \\n                c = ord(board[i][j][0]) - ord(\\'0\\')\\n                if( c < 0 or c > 9 ):\\n                    board[i][j] = 0\\n                else: \\n                    board[i][j] = c ;\\n                    row[i][c] = 1\\n                    col[j][c] = 1\\n                    box[box_index][c] = 1\\n\\n        \\n        def rec(i,j):\\n            if( board[i][j] > 0 and board[i][j] <= 9  ):\\n                if( j < 8 ):\\n                    if( rec(i,j+1)):\\n                        return True\\n                elif( i < 8 ):\\n                    if( rec(i+1,0) ):\\n                        return True \\n                elif( i == 8 and j == 8 ):\\n                    return True ;\\n            else:\\n                box_index = 3*(i//3) + j//3   \\n                for k in range(1,10):\\n                    if( row[i][k] == col[j][k] == box[box_index][k] == 0 ):\\n                        row[i][k] = col[j][k] = box[box_index][k] = 1\\n                        board[i][j] = k \\n                        if( j < 8 ):\\n                            if(rec(i,j+1)):\\n                                return True;\\n                        elif( i < 8 ):\\n                            if( rec(i+1,0) ):\\n                                return True ;\\n                        else:\\n                            return True;\\n                        board[i][j] = 0 \\n                        row[i][k] = col[j][k] = box[box_index][k] = 0\\n                \\n            return False;\\n        \\n        rec(0,0)\\n\\n        \\n        for i in range(0,9):\\n            for j in range(0,9):\\n                board[i][j] = chr(board[i][j]+ord(\\'0\\'))\\n\\n\\n        return board;\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        row = { i:[0]*10 for i in range(0,9) }\\n        col = { i:[0]*10 for i in range(0,9) }\\n        box = { i:[0]*10 for i in range(0,9) }\\n        n,m = len(board),len(board[0])\\n        for i in range(0,n):\\n            for j in range(0,m):\\n                box_index = 3*(i//3) + j//3 \\n                c = ord(board[i][j][0]) - ord(\\'0\\')\\n                if( c < 0 or c > 9 ):\\n                    board[i][j] = 0\\n                else: \\n                    board[i][j] = c ;\\n                    row[i][c] = 1\\n                    col[j][c] = 1\\n                    box[box_index][c] = 1\\n\\n        \\n        def rec(i,j):\\n            if( board[i][j] > 0 and board[i][j] <= 9  ):\\n                if( j < 8 ):\\n                    if( rec(i,j+1)):\\n                        return True\\n                elif( i < 8 ):\\n                    if( rec(i+1,0) ):\\n                        return True \\n                elif( i == 8 and j == 8 ):\\n                    return True ;\\n            else:\\n                box_index = 3*(i//3) + j//3   \\n                for k in range(1,10):\\n                    if( row[i][k] == col[j][k] == box[box_index][k] == 0 ):\\n                        row[i][k] = col[j][k] = box[box_index][k] = 1\\n                        board[i][j] = k \\n                        if( j < 8 ):\\n                            if(rec(i,j+1)):\\n                                return True;\\n                        elif( i < 8 ):\\n                            if( rec(i+1,0) ):\\n                                return True ;\\n                        else:\\n                            return True;\\n                        board[i][j] = 0 \\n                        row[i][k] = col[j][k] = box[box_index][k] = 0\\n                \\n            return False;\\n        \\n        rec(0,0)\\n\\n        \\n        for i in range(0,9):\\n            for j in range(0,9):\\n                board[i][j] = chr(board[i][j]+ord(\\'0\\'))\\n\\n\\n        return board;\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243916,
                "title": "java-easy-solution-with-explaination",
                "content": "# Intuition\\nThis solution uses backtracking to solve the Sudoku puzzle.\\n\\n# Approach\\n It starts at the top-left cell and recursively tries all possible values (from 1 to 9) that can be filled in the cell. It then moves to the next cell to the right and repeats the process. If it reaches the end of a row, it moves to the first cell of the next row. If it has successfully filled all cells, it returns true to indicate that the puzzle has been solved. If it encounters an invalid configuration, it backtracks and tries a different value for the previous cell.\\n*\\nThe isValid method checks whether a given value can be placed in a given cell without violating the rules of Sudoku. It checks the row, column, and 3x3 box containing the cell for any occurrences of the value.\\n\\n# Complexity\\n- Time complexity:- The time complexity of this solution is O(9^(nn)), where n is the length of the side of the Sudoku puzzle (in this case, n = 9). This is because each cell can have 9 possible values and there are nn cells in the puzzle.\\n\\n\\n- Space complexity:\\nThe space complexity is O(n*n) because it creates a 2D array to store the Sudoku puzzle. This solution should be able to solve most Sudoku puzzles within a reasonable amount of time.\\n\\n# Code\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board, 0, 0);\\n    }\\n    \\n    private boolean solve(char[][] board, int row, int col) {\\n        if (col == 9) {\\n            row++;\\n            col = 0;\\n        }\\n        \\n        if (row == 9) {\\n            return true;\\n        }\\n        \\n        if (board[row][col] != \\'.\\') {\\n            return solve(board, row, col + 1);\\n        }\\n        \\n        for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, row, col, c)) {\\n                board[row][col] = c;\\n                if (solve(board, row, col + 1)) {\\n                    return true;\\n                }\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean isValid(char[][] board, int row, int col, char c) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[row][i] == c) {\\n                return false;\\n            }\\n            if (board[i][col] == c) {\\n                return false;\\n            }\\n            int boxRow = (row / 3) * 3 + i / 3;\\n            int boxCol = (col / 3) * 3 + i % 3;\\n            if (board[boxRow][boxCol] == c) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board, 0, 0);\\n    }\\n    \\n    private boolean solve(char[][] board, int row, int col) {\\n        if (col == 9) {\\n            row++;\\n            col = 0;\\n        }\\n        \\n        if (row == 9) {\\n            return true;\\n        }\\n        \\n        if (board[row][col] != \\'.\\') {\\n            return solve(board, row, col + 1);\\n        }\\n        \\n        for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, row, col, c)) {\\n                board[row][col] = c;\\n                if (solve(board, row, col + 1)) {\\n                    return true;\\n                }\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean isValid(char[][] board, int row, int col, char c) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[row][i] == c) {\\n                return false;\\n            }\\n            if (board[i][col] == c) {\\n                return false;\\n            }\\n            int boxRow = (row / 3) * 3 + i / 3;\\n            int boxCol = (col / 3) * 3 + i % 3;\\n            if (board[boxRow][boxCol] == c) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215622,
                "title": "q37-accepted-c-used-recursion-bt-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int row,int col,char &c,vector<vector<char>>& board){\\n        for(int i=0;i<9;i++){\\n            if(board[i][col]==c) //Checking Row\\n                return false;\\n            if(board[row][i]==c) //Checking Column\\n                return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) //Checking 3*3 sub-matrix for unique number betweeen 1-9\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0;i<9;i++){ // Traversal through each element in 9*9 Sudoku\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]==\\'.\\'){ // If Empty\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){\\n                        if(isSafe(i,j,c,board)==true){ //Checking whether 1-9 which numbers sets the 3 Sudoku Criteria\\n                            board[i][j]=c;\\n                            if(solve(board)==true) //Condition Checking\\n                                return true;\\n                            else\\n                                board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int row,int col,char &c,vector<vector<char>>& board){\\n        for(int i=0;i<9;i++){\\n            if(board[i][col]==c) //Checking Row\\n                return false;\\n            if(board[row][i]==c) //Checking Column\\n                return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) //Checking 3*3 sub-matrix for unique number betweeen 1-9\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<char>>& board){\\n        for(int i=0;i<9;i++){ // Traversal through each element in 9*9 Sudoku\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]==\\'.\\'){ // If Empty\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){\\n                        if(isSafe(i,j,c,board)==true){ //Checking whether 1-9 which numbers sets the 3 Sudoku Criteria\\n                            board[i][j]=c;\\n                            if(solve(board)==true) //Condition Checking\\n                                return true;\\n                            else\\n                                board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878317,
                "title": "this-is-the-solution-chatgpt-ai-gave-to-this-problem",
                "content": "I asked [chatGPT](https://chat.openai.com/chat) to write a program that solves Sudoku puzzles in Python: \\n\\n# Code\\n```\\nclass Solution(object):\\n    def solveSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: None Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        solve_sudoku(board)\\n\\ndef solve_sudoku(grid):\\n    row, col = find_empty_cell(grid)\\n    if row == -1:\\n        return True\\n\\n    for num in range(1, 10):\\n        if is_safe(grid, row, col, num):\\n            grid[row][col] = str(num)\\n\\n            if solve_sudoku(grid):\\n                return True\\n\\n            grid[row][col] = \\'.\\'\\n\\n    return False\\n\\ndef find_empty_cell(grid):\\n    for i in range(9):\\n        for j in range(9):\\n            if grid[i][j] == \\'.\\':\\n                return (i, j)\\n\\n    return (-1, -1)\\n\\ndef is_safe(grid, row, col, num):\\n    # Check if the number is already in the current row\\n    for i in range(9):\\n        if grid[row][i] == str(num):\\n            return False\\n\\n    # Check if the number is already in the current column\\n    for i in range(9):\\n        if grid[i][col] == str(num):\\n            return False\\n\\n    # Check if the number is already in the current 3x3 box\\n    start_row = row - row % 3\\n    start_col = col - col % 3\\n    for i in range(3):\\n        for j in range(3):\\n            if grid[start_row + i][start_col + j] == str(num):\\n                return False\\n\\n    return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def solveSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: None Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        solve_sudoku(board)\\n\\ndef solve_sudoku(grid):\\n    row, col = find_empty_cell(grid)\\n    if row == -1:\\n        return True\\n\\n    for num in range(1, 10):\\n        if is_safe(grid, row, col, num):\\n            grid[row][col] = str(num)\\n\\n            if solve_sudoku(grid):\\n                return True\\n\\n            grid[row][col] = \\'.\\'\\n\\n    return False\\n\\ndef find_empty_cell(grid):\\n    for i in range(9):\\n        for j in range(9):\\n            if grid[i][j] == \\'.\\':\\n                return (i, j)\\n\\n    return (-1, -1)\\n\\ndef is_safe(grid, row, col, num):\\n    # Check if the number is already in the current row\\n    for i in range(9):\\n        if grid[row][i] == str(num):\\n            return False\\n\\n    # Check if the number is already in the current column\\n    for i in range(9):\\n        if grid[i][col] == str(num):\\n            return False\\n\\n    # Check if the number is already in the current 3x3 box\\n    start_row = row - row % 3\\n    start_col = col - col % 3\\n    for i in range(3):\\n        for j in range(3):\\n            if grid[start_row + i][start_col + j] == str(num):\\n                return False\\n\\n    return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850056,
                "title": "if-youwant-c-code-simple-code-clean-code-return-thissolution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector < vector < char >> & board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n        if (board[i][col] == c)\\n        return false;\\n\\n        if (board[row][i] == c)\\n        return false;\\n\\n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n    }\\n    bool helper(vector<vector<char>>& board){\\n        for (int i = 0; i < board.size(); i++) {\\n        for (int j = 0; j < board[0].size(); j++) {\\n            if (board[i][j] == \\'.\\') {\\n                for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                    if (isValid(board, i, j, c)) {\\n                        board[i][j] = c;\\n                        if (helper(board))\\n                        return true;\\n                        else\\n                        board[i][j] = \\'.\\';\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector < vector < char >> & board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n        if (board[i][col] == c)\\n        return false;\\n\\n        if (board[row][i] == c)\\n        return false;\\n\\n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n    }\\n    bool helper(vector<vector<char>>& board){\\n        for (int i = 0; i < board.size(); i++) {\\n        for (int j = 0; j < board[0].size(); j++) {\\n            if (board[i][j] == \\'.\\') {\\n                for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n                    if (isValid(board, i, j, c)) {\\n                        board[i][j] = c;\\n                        if (helper(board))\\n                        return true;\\n                        else\\n                        board[i][j] = \\'.\\';\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842618,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n\\n    public boolean solve(char[][] board)\\n    {\\n        for(int i = 0; i < board.length; i++)\\n        {\\n            for(int j = 0; j < board[0].length; j++)\\n            {\\n                if(board[i][j] == \\'.\\')\\n                {\\n                    for(char c = \\'1\\'; c <=\\'9\\'; c++)\\n                    {\\n                        if(isValid(board, i, j, c) == true)\\n                        {\\n                            board[i][j] = c;\\n\\n                            if(solve(board) == true) \\n                            {\\n                                return true;\\n                            }\\n                            else\\n                            { \\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n   public boolean isValid(char[][] board, int row, int col, char c)\\n    {\\n        for(int i = 0; i < 9; i++)\\n        {\\n            if(board[row][i] == c) return false;\\n            if(board[i][col] == c) return false;\\n\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n\\n    public boolean solve(char[][] board)\\n    {\\n        for(int i = 0; i < board.length; i++)\\n        {\\n            for(int j = 0; j < board[0].length; j++)\\n            {\\n                if(board[i][j] == \\'.\\')\\n                {\\n                    for(char c = \\'1\\'; c <=\\'9\\'; c++)\\n                    {\\n                        if(isValid(board, i, j, c) == true)\\n                        {\\n                            board[i][j] = c;\\n\\n                            if(solve(board) == true) \\n                            {\\n                                return true;\\n                            }\\n                            else\\n                            { \\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n   public boolean isValid(char[][] board, int row, int col, char c)\\n    {\\n        for(int i = 0; i < 9; i++)\\n        {\\n            if(board[row][i] == c) return false;\\n            if(board[i][col] == c) return false;\\n\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800826,
                "title": "sudoku-backtracking",
                "content": "# Sudoku Solver\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe naive approach is to generate all possible configurations of numbers from 1 to 9 to fill the empty cells. Try every configuration one by one until the correct configuration is found, i.e. for every unassigned position fill the position with a number from 1 to 9. After filling all the unassigned positions check if the matrix is safe or not. If safe print else recurs for other cases.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(9^(n*n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(N*N):\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > MeraSudoku;\\n    bool checkSudoku(int& row, int& col)\\n    {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (MeraSudoku[i][j] == 0) {\\n                    row = i;\\n                    col = j;\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool inRow(int i, int num)\\n    {\\n        for (int j = 0; j < 9; j++) {\\n            if (MeraSudoku[i][j] == num)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool inCol(int j, int num)\\n    {\\n        for (int i = 0; i < 9; i++) {\\n            if (MeraSudoku[i][j] == num)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool inSmall(int row, int col, int num)\\n    {\\n        int rowfactor = row - (row % 3);\\n        int colfactor = col - (col % 3);\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                int item = MeraSudoku[i + rowfactor][j + colfactor];\\n                if (item == num)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool isPossibleToPut(int row, int col, int number)\\n    {\\n        bool r = inRow(row, number);\\n        bool c = inCol(col, number);\\n        bool s = inSmall(row, col, number);\\n        return r && c && s;\\n    }\\n    bool solve(vector<vector<int> >& MeraSudoku)\\n    {\\n        int row = 0;\\n        int col = 0;\\n        if (checkSudoku(row, col)) {\\n            return true;\\n        }\\n        for (int number = 1; number <= 9; number++) {\\n            if (isPossibleToPut(row, col, number)) {\\n                MeraSudoku[row][col] = number;\\n                if (solve(MeraSudoku))\\n                    return true;\\n                MeraSudoku[row][col] = 0;\\n            }\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char> >& board)\\n    {\\n        MeraSudoku.resize(9, vector<int>(9, 0));\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    MeraSudoku[i][j] = (board[i][j] - \\'0\\');\\n                }\\n            }\\n        }\\n        solve(MeraSudoku);\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char ch = MeraSudoku[i][j] + \\'0\\';\\n                board[i][j] = ch;\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > MeraSudoku;\\n    bool checkSudoku(int& row, int& col)\\n    {\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (MeraSudoku[i][j] == 0) {\\n                    row = i;\\n                    col = j;\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool inRow(int i, int num)\\n    {\\n        for (int j = 0; j < 9; j++) {\\n            if (MeraSudoku[i][j] == num)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool inCol(int j, int num)\\n    {\\n        for (int i = 0; i < 9; i++) {\\n            if (MeraSudoku[i][j] == num)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool inSmall(int row, int col, int num)\\n    {\\n        int rowfactor = row - (row % 3);\\n        int colfactor = col - (col % 3);\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                int item = MeraSudoku[i + rowfactor][j + colfactor];\\n                if (item == num)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool isPossibleToPut(int row, int col, int number)\\n    {\\n        bool r = inRow(row, number);\\n        bool c = inCol(col, number);\\n        bool s = inSmall(row, col, number);\\n        return r && c && s;\\n    }\\n    bool solve(vector<vector<int> >& MeraSudoku)\\n    {\\n        int row = 0;\\n        int col = 0;\\n        if (checkSudoku(row, col)) {\\n            return true;\\n        }\\n        for (int number = 1; number <= 9; number++) {\\n            if (isPossibleToPut(row, col, number)) {\\n                MeraSudoku[row][col] = number;\\n                if (solve(MeraSudoku))\\n                    return true;\\n                MeraSudoku[row][col] = 0;\\n            }\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char> >& board)\\n    {\\n        MeraSudoku.resize(9, vector<int>(9, 0));\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    MeraSudoku[i][j] = (board[i][j] - \\'0\\');\\n                }\\n            }\\n        }\\n        solve(MeraSudoku);\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char ch = MeraSudoku[i][j] + \\'0\\';\\n                board[i][j] = ch;\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800522,
                "title": "java-o-9-n-2-70-faster-backtracking-easy-solution-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, we\\'ll try having all possibilities for each empty cell of ```board``` following the constraints of a sudoku ->\\n \\n- Each row will contain all digits among 1-9 (inclusive) and none should repeat.\\n- Each col will contain all digits among 1-9 (inclusive) and none should repeat.\\n- Similarly, the 3X3 sub-grids *(there are total 9 such subgrids - can be obtained by splitting up the board into 9 equal parts)*\\n**The subgrids can be observed in below image by the bold lines which divide the ```board``` into 9 equal regions.**\\n*NOTE-> Any number must not repeat in a row, column or the subgrid.*\\n\\n![LeetCode](https://www.tutorialcup.com/wp-content/uploads/2020/05/Sudoku1.png){:style=\\'width: 600px\"}\\n\\n### STEPS to be followed ->\\n\\n- Place a number from 1-9 (say ```1```) in an empty cell (say ```board[0][2]```)and move to next empty cell (recursively) (i.e. ```board[0][3]```) and try to obtain a possible solution for the sudoku.\\n- If we get a solution, return ```true```, else try changing the value at ```board[0][2]``` to ```2```, ```3``` $$and$$ $$so$$ $$on...$$.\\n- The above steps have to be performed for all the empty cells and a number can be put at an index in ```board``` if and only if it passes the check ```isSafeToPlace(board, r, c, i)```.\\n- If after testing for all the numbers i.e. 1-9 at a specific cell, we don\\'t get any solution, then we **backtrack** by setting the default value ```.``` at that index and return to previous level.\\n\\n# Complexity\\n- Time complexity: O((9^$$n^2$$)*n) **(Beats 71%)** -> \\n  - *Each cell has 9 options and we have $$n^2$$ such cells, along with it, setting a value at an index requires check by ```isSafeToPlace()``` which again consumes O(n) time.*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$ -> \\n    - *At a time, callstack may contain a max of $$n^2$$ levels.*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution.. :)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solveSudokuHelper(board, 0, 0);\\n    }\\n    public static boolean solveSudokuHelper(char[][] board, int r, int c) {\\n        //base case\\n        if(r == board.length) return true;\\n\\n        if(c == board[0].length) return solveSudokuHelper(board, r+1, 0);\\n        //cells which are prefilled should not be changed\\n        if(board[r][c] != \\'.\\') return solveSudokuHelper(board, r, c+1);\\n\\n        for(int i = 1; i <= 9; i++){\\n            if(isSafeToPlace(board, r, c, i)){\\n                board[r][c] = (char)(i+\\'0\\');\\n                if(solveSudokuHelper(board, r, c+1)) return true;\\n            }\\n        }\\n        //backtrack\\n        board[r][c] = \\'.\\';\\n        return false;\\n    }\\n    public static boolean isSafeToPlace(char[][] board, int r, int c, int val) {\\n        //checks the row and col\\n        for(int i = 0; i < board.length; i++){\\n            if(board[i][c] == (char)(val+\\'0\\') || board[r][i] == (char)(val+\\'0\\')) return false;\\n        }\\n        //checks within the sub-grid\\n        for(int i = (r/3)*3; i < (r/3)*3 + 3; i++){\\n            for(int j = (c/3)*3; j < (c/3)*3 + 3; j++) if(board[i][j] == (char)(val+\\'0\\')) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```board```\n```board```\n```1```\n```board[0][2]```\n```board[0][3]```\n```true```\n```board[0][2]```\n```2```\n```3```\n```board```\n```isSafeToPlace(board, r, c, i)```\n```.```\n```isSafeToPlace()```\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solveSudokuHelper(board, 0, 0);\\n    }\\n    public static boolean solveSudokuHelper(char[][] board, int r, int c) {\\n        //base case\\n        if(r == board.length) return true;\\n\\n        if(c == board[0].length) return solveSudokuHelper(board, r+1, 0);\\n        //cells which are prefilled should not be changed\\n        if(board[r][c] != \\'.\\') return solveSudokuHelper(board, r, c+1);\\n\\n        for(int i = 1; i <= 9; i++){\\n            if(isSafeToPlace(board, r, c, i)){\\n                board[r][c] = (char)(i+\\'0\\');\\n                if(solveSudokuHelper(board, r, c+1)) return true;\\n            }\\n        }\\n        //backtrack\\n        board[r][c] = \\'.\\';\\n        return false;\\n    }\\n    public static boolean isSafeToPlace(char[][] board, int r, int c, int val) {\\n        //checks the row and col\\n        for(int i = 0; i < board.length; i++){\\n            if(board[i][c] == (char)(val+\\'0\\') || board[r][i] == (char)(val+\\'0\\')) return false;\\n        }\\n        //checks within the sub-grid\\n        for(int i = (r/3)*3; i < (r/3)*3 + 3; i++){\\n            for(int j = (c/3)*3; j < (c/3)*3 + 3; j++) if(board[i][j] == (char)(val+\\'0\\')) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776998,
                "title": "cpp-solution-why-inplace-is-required",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    vector<vector < char>> nb;\\n        bool check(vector<vector < char>> &board, int i, int j, char cmp)\\n        {\\n            for (int x = 0; x < board.size(); x++)\\t//row and column\\n                if (board[i][x] == cmp or board[x][j] == cmp)\\n                    return false;\\n            i = i - (i % 3);\\n            j = j - (j % 3);\\n            for (int row = i; row < i + 3; row++)\\t//3x3 small matrix\\n            {\\n                for (int col = j; col < j + 3; col++)\\n                {\\n                    if (board[row][col] == cmp)\\n                        return false;\\n                }\\n            }\\n            return true;\\n        }\\n    void sudoku(vector<vector < char>> &board)\\n    {\\n        int row = -1;\\n        int col = -1;\\n\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n            if (row != -1 and col != -1)\\n                break;\\n        }\\n\\n        if (row == -1 and col == -1)\\n        {nb=board;return;}\\n\\n        for (int x = 1; x <= 9; x++)\\n        {\\n            if (check(board, row, col, char(48 + x)))\\n            {\\n                board[row][col] = char(48 + x);\\n                sudoku(board);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    void solveSudoku(vector<vector < char>> &board)\\n    {\\n        sudoku(board);\\n        \\n        board=nb;\\n    }\\n};\\n```\\n\\n**Imp Note-** **Since the question does not specifies in place change but it asks to fill the values in the sudoku . So the correct solution will be of inplace-**\\n\\n```\\nclass Solution\\n{\\n    public:\\n        bool check(vector<vector < char>> &board, int i, int j, char cmp)\\n        {\\n            for (int x = 0; x < board.size(); x++)\\t//row and column\\n                if (board[i][x] == cmp or board[x][j] == cmp)\\n                    return false;\\n            i = i - (i % 3);\\n            j = j - (j % 3);\\n            for (int row = i; row < i + 3; row++)\\t//3x3 small matrix\\n            {\\n                for (int col = j; col < j + 3; col++)\\n                {\\n                    if (board[row][col] == cmp)\\n                        return false;\\n                }\\n            }\\n            return true;\\n        }\\n    bool sudoku(vector<vector < char>> &board)\\n    {\\n        int row = -1;\\n        int col = -1;\\n\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n            if (row != -1 and col != -1)\\n                break;\\n        }\\n\\n        if (row == -1 and col == -1)\\n            return true;\\n\\n        for (int x = 1; x <= 9; x++)\\n        {\\n            if (check(board, row, col, char(48 + x)))\\n            {\\n                board[row][col] = char(48 + x);\\n                if(sudoku(board))\\n                    return true;\\n                    \\n            }\\n        }\\n        board[row][col] = \\'.\\';\\n        return false;\\n    }\\n    void solveSudoku(vector<vector < char>> &board)\\n    {\\n        sudoku(board);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<vector < char>> nb;\\n        bool check(vector<vector < char>> &board, int i, int j, char cmp)\\n        {\\n            for (int x = 0; x < board.size(); x++)\\t//row and column\\n                if (board[i][x] == cmp or board[x][j] == cmp)\\n                    return false;\\n            i = i - (i % 3);\\n            j = j - (j % 3);\\n            for (int row = i; row < i + 3; row++)\\t//3x3 small matrix\\n            {\\n                for (int col = j; col < j + 3; col++)\\n                {\\n                    if (board[row][col] == cmp)\\n                        return false;\\n                }\\n            }\\n            return true;\\n        }\\n    void sudoku(vector<vector < char>> &board)\\n    {\\n        int row = -1;\\n        int col = -1;\\n\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n            if (row != -1 and col != -1)\\n                break;\\n        }\\n\\n        if (row == -1 and col == -1)\\n        {nb=board;return;}\\n\\n        for (int x = 1; x <= 9; x++)\\n        {\\n            if (check(board, row, col, char(48 + x)))\\n            {\\n                board[row][col] = char(48 + x);\\n                sudoku(board);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    void solveSudoku(vector<vector < char>> &board)\\n    {\\n        sudoku(board);\\n        \\n        board=nb;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    public:\\n        bool check(vector<vector < char>> &board, int i, int j, char cmp)\\n        {\\n            for (int x = 0; x < board.size(); x++)\\t//row and column\\n                if (board[i][x] == cmp or board[x][j] == cmp)\\n                    return false;\\n            i = i - (i % 3);\\n            j = j - (j % 3);\\n            for (int row = i; row < i + 3; row++)\\t//3x3 small matrix\\n            {\\n                for (int col = j; col < j + 3; col++)\\n                {\\n                    if (board[row][col] == cmp)\\n                        return false;\\n                }\\n            }\\n            return true;\\n        }\\n    bool sudoku(vector<vector < char>> &board)\\n    {\\n        int row = -1;\\n        int col = -1;\\n\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n            if (row != -1 and col != -1)\\n                break;\\n        }\\n\\n        if (row == -1 and col == -1)\\n            return true;\\n\\n        for (int x = 1; x <= 9; x++)\\n        {\\n            if (check(board, row, col, char(48 + x)))\\n            {\\n                board[row][col] = char(48 + x);\\n                if(sudoku(board))\\n                    return true;\\n                    \\n            }\\n        }\\n        board[row][col] = \\'.\\';\\n        return false;\\n    }\\n    void solveSudoku(vector<vector < char>> &board)\\n    {\\n        sudoku(board);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454459,
                "title": "c-beginner-solution-with-basic-knowledge-of-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n\\t//bool function for using it again using recursion you will understand as you proceed further...\\n    bool solve(vector<vector<char>>& board){\\n\\t//two for loops for simply traversing through the vector matrix.\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board.size(); j++){\\n                if(board[i][j]==\\'.\\'){\\n                    for(char c= \\'1\\'; c<=\\'9\\'; c++){\\n\\t\\t\\t\\t\\t   //isValid function is at the last to check the three conditions row column and the 3 by 3 block\\n                        if(isValid(board, i, j, c)==true){\\n                            board[i][j]=c;\\n\\t\\t\\t\\t\\t\\t\\t//This is where the recursion happens an element is replaced with the character and is waited untill rest of the sudoku can be filled with that element in place. If not then the else statement comes into action and then the same process happens with the element;\\n                            if(solve(board)==true)\\n                                return true;\\n                            else\\n                                board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t//isValid function to check the three conditions if the element is present in row column or the block\\n    bool isValid(vector<vector<char>>&board, int row, int col, char c){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col]==c)\\n                return false;\\n            if(board[row][i]==c)\\n                return false;\\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3]==c)\\n                return false;\\n        }\\n        return true;\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n\\t//bool function for using it again using recursion you will understand as you proceed further...\\n    bool solve(vector<vector<char>>& board){\\n\\t//two for loops for simply traversing through the vector matrix.\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board.size(); j++){\\n                if(board[i][j]==\\'.\\'){\\n                    for(char c= \\'1\\'; c<=\\'9\\'; c++){\\n\\t\\t\\t\\t\\t   //isValid function is at the last to check the three conditions row column and the 3 by 3 block\\n                        if(isValid(board, i, j, c)==true){\\n                            board[i][j]=c;\\n\\t\\t\\t\\t\\t\\t\\t//This is where the recursion happens an element is replaced with the character and is waited untill rest of the sudoku can be filled with that element in place. If not then the else statement comes into action and then the same process happens with the element;\\n                            if(solve(board)==true)\\n                                return true;\\n                            else\\n                                board[i][j]=\\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t//isValid function to check the three conditions if the element is present in row column or the block\\n    bool isValid(vector<vector<char>>&board, int row, int col, char c){\\n        for(int i=0; i<9; i++){\\n            if(board[i][col]==c)\\n                return false;\\n            if(board[row][i]==c)\\n                return false;\\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3]==c)\\n                return false;\\n        }\\n        return true;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2421168,
                "title": "easy-javascript-recursive-detailed-explanation",
                "content": "```\\nvar solveSudoku = function(board) {\\n//     loop over each row\\n    for(let i=0; i<board.length ; i++){\\n        \\n        //     loop over each col\\n        for(let j=0; j<board[0].length; j++){\\n            \\n//            check if block is empty\\n            if(board[i][j] === \\'.\\'){\\n                \\n//                 if yes fill it by finding a valid number\\n                for(let k=1; k<=9 ; k++){\\n                    \\n                    const num = k.toString()\\n//                     check for valid num\\n                    if(isNumValid(i,j,num,board)){\\n//                      update sudoku\\n                        \\n                        board[i][j] = num\\n                        \\n//                         now check if the updated sudoku is valid ? by checking this sudoku using recursion. \\n//                         if yes return true \\n//                         if no, backtrack changes and try filling it with a different number.\\n                        \\n                        if(solveSudoku(board) === true){\\n                            return true\\n                        }else{\\n//                             backtrack\\n                            board[i][j] = \\'.\\'\\n                        }\\n                        \\n                    }\\n                }\\n//                 if no valid num is found return false\\n                return false\\n            }\\n            \\n            \\n        }\\n    }\\n//     Sudoku is completely filled hence return true\\n                return true\\n\\n};\\n\\n//Helper function\\nfunction isNumValid(row, col, num, board){\\n    for(let i=0 ; i<9 ; i++){\\n        \\n        if(board[row][i] === num) return false\\n        \\n        if(board[i][col] === num) return false\\n        \\n        const currentMatrixRow = Math.floor(row/3)        \\n        const currentMatrixCol = Math.floor(col/3)\\n\\n        const currentRow =  3 * currentMatrixRow + Math.floor(i/3)        \\n        const currentCol = 3 * currentMatrixCol + i%3 \\n \\n        \\n        if(board[currentRow][currentCol] === num ) return false\\n        \\n    }\\n            return true\\n\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvar solveSudoku = function(board) {\\n//     loop over each row\\n    for(let i=0; i<board.length ; i++){\\n        \\n        //     loop over each col\\n        for(let j=0; j<board[0].length; j++){\\n            \\n//            check if block is empty\\n            if(board[i][j] === \\'.\\'){\\n                \\n//                 if yes fill it by finding a valid number\\n                for(let k=1; k<=9 ; k++){\\n                    \\n                    const num = k.toString()\\n//                     check for valid num\\n                    if(isNumValid(i,j,num,board)){\\n//                      update sudoku\\n                        \\n                        board[i][j] = num\\n                        \\n//                         now check if the updated sudoku is valid ? by checking this sudoku using recursion. \\n//                         if yes return true \\n//                         if no, backtrack changes and try filling it with a different number.\\n                        \\n                        if(solveSudoku(board) === true){\\n                            return true\\n                        }else{\\n//                             backtrack\\n                            board[i][j] = \\'.\\'\\n                        }\\n                        \\n                    }\\n                }\\n//                 if no valid num is found return false\\n                return false\\n            }\\n            \\n            \\n        }\\n    }\\n//     Sudoku is completely filled hence return true\\n                return true\\n\\n};\\n\\n//Helper function\\nfunction isNumValid(row, col, num, board){\\n    for(let i=0 ; i<9 ; i++){\\n        \\n        if(board[row][i] === num) return false\\n        \\n        if(board[i][col] === num) return false\\n        \\n        const currentMatrixRow = Math.floor(row/3)        \\n        const currentMatrixCol = Math.floor(col/3)\\n\\n        const currentRow =  3 * currentMatrixRow + Math.floor(i/3)        \\n        const currentCol = 3 * currentMatrixCol + i%3 \\n \\n        \\n        if(board[currentRow][currentCol] === num ) return false\\n        \\n    }\\n            return true\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276383,
                "title": "c-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValid(int r, int c, char ch, vector<vector<char>>& board)\\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<9;i++)\\n\\t\\t\\t\\tif(board[i][c]==ch || board[r][i]==ch || board[3*(r/3)+i/3][3*(c/3)+i%3] == ch)   return false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbool solve(vector<vector<char>>& board) \\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<9;i++)\\n\\t\\t\\t\\tfor(int j=0;j<9;j++)\\n\\t\\t\\t\\t\\tif(board[i][j]==\\'.\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tfor(char d=\\'1\\';d<=\\'9\\';d++)\\n\\t\\t\\t\\t\\t\\t\\tif(isValid(i,j,d,board))\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tboard[i][j] = d;\\n\\t\\t\\t\\t\\t\\t\\t\\tif(solve(board))    return true;\\n\\t\\t\\t\\t\\t\\t\\t\\telse    board[i][j] = \\'.\\';\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid solveSudoku(vector<vector<char>>& board)\\n\\t\\t{\\n\\t\\t\\tsolve(board);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isValid(int r, int c, char ch, vector<vector<char>>& board)\\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<9;i++)\\n\\t\\t\\t\\tif(board[i][c]==ch || board[r][i]==ch || board[3*(r/3)+i/3][3*(c/3)+i%3] == ch)   return false;\\n\\t\\t\\treturn true;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2255026,
                "title": "c-100-faster-representation-solution-with-comments-backtracking",
                "content": "***\\n***Intuition:***\\n***\\n***\\nSince we have to fill the empty cells with available possible numbers and we can also have multiple solutions, the main intuition is to try every possible way of filling the empty cells. And the more correct way to try all possible solutions is to use recursion. In each call to the recursive function, we just try all the possible numbers for a particular cell and transfer the updated board to the next recursive call.\\n***\\n***Approach:***\\n***\\n***\\n* Let\\u2019s see the step by step approach. Our main recursive function(solve()) is going to just do a plain matrix traversal of the sudoku board. When we find an empty cell, we pause and try to put all available numbers(1 \\u2013 9) in that particular empty cell.\\n*  We need another loop to do that. But wait, we forgot one thing \\u2013 the board has to satisfy all the conditions, right? So, for that we have another function(isValid()) which will check whether the number we have inserted into that empty cell will not violate any conditions.\\n*  If it is violating, we try with the next number. If it is not, we call the same function recursively, but this time with the updated state of the board. Now, as usual it tries to fill the remaining cells in the board in the same way.\\n* Now we\\u2019ll come to the returning values. If at any point we cannot insert any numbers from 1 \\u2013 9 in a particular cell, it means the current state of the board is wrong and we need to backtrack. An important point to follow is, we need to return false to let the parent function(which is called this function) know that we cannot fill this way. This will serve as a hint to that function, that it needs to try with the next possible number. Refer to the picture below.\\n![image](https://assets.leetcode.com/users/images/a659d9fb-09bf-40c7-99b4-552c1cbfad90_1657286877.4578748.png)\\n* If a recursive call returns true, we can assume that we found one possible way of filling and we simply do an early return.\\n ***\\n ***Validating Board***\\n***\\n***\\n*  Now, let\\u2019s see how we are validating the sudoku board. After determining a number for a cell(at i\\u2019th row, j\\u2019th col), we try to check the validity. As we know, a valid sudoku needs to satisfy 3 conditions, we can use three loops. But we can do within a single loop itself. Let\\u2019s try to understand that.\\n* We loop from 0 to 8 and check the values \\u2013 board[i][col](1st condition) and board[row][i](2nd condition), whether the number is already included. For the 3rd condition \\u2013 the expression (3 * (row / 3) + i / 3) evaluates to the row numbers of that 3\\xD73 submatrix and the expression (3 * (col / 3) + i % 3) evaluates to the column numbers.\\n* For eg, if row= 5 and col= 3, the cells visited are\\n![image](https://assets.leetcode.com/users/images/66a93f79-622d-49ce-b4ee-b119562ef7bc_1657286906.1037207.png)\\n* It covers all the cells in the sub-matrix.\\n***\\n\\n***C++ Code***\\n***\\n***\\n```\\nclass Solution {\\n\\nprivate:\\n  bool solve(vector < vector < char >> & board) {\\n     for (int i = 0; i < board.size(); i++) {\\n       for (int j = 0; j < board[0].size(); j++) {\\n          if (board[i][j] == \\'.\\') {\\n            for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n             if (isValid(board, i, j, c)) {\\n               board[i][j] = c;\\n\\n               if (solve(board))\\n                  return true;\\n               else\\n                  board[i][j] = \\'.\\';\\n          }\\n        }\\n\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n}\\nbool isValid(vector < vector < char >> & board, int row, int col, char c) {\\n  for (int i = 0; i < 9; i++) {\\n    if (board[i][col] == c)\\n      return false;\\n\\n    if (board[row][i] == c)\\n      return false;\\n\\n    if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n      return false;\\n  }\\n  return true;\\n}\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);     \\n    }\\n};\\n```\\n***\\n***\\n***Time Complexity: O(9(n ^ 2))*** , in the worst case, for each cell in the n2 board, we have 9 possible numbers.\\n\\n***Space Complexity: O(1)*** , since we are refilling the given board itself, there is no extra space required, so constant space complexity.\\n***\\n***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n  bool solve(vector < vector < char >> & board) {\\n     for (int i = 0; i < board.size(); i++) {\\n       for (int j = 0; j < board[0].size(); j++) {\\n          if (board[i][j] == \\'.\\') {\\n            for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n             if (isValid(board, i, j, c)) {\\n               board[i][j] = c;\\n\\n               if (solve(board))\\n                  return true;\\n               else\\n                  board[i][j] = \\'.\\';\\n          }\\n        }\\n\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n}\\nbool isValid(vector < vector < char >> & board, int row, int col, char c) {\\n  for (int i = 0; i < 9; i++) {\\n    if (board[i][col] == c)\\n      return false;\\n\\n    if (board[row][i] == c)\\n      return false;\\n\\n    if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n      return false;\\n  }\\n  return true;\\n}\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134604,
                "title": "c-easy-and-simple-solution-detailed-expanation-at-each-step-recursion",
                "content": "```\\nbool isValid(vector<vector<char>>& board, int row, int col, char c)\\n    {\\n        for(int i=0; i<9; i++)\\n        {\\n            //For checking the column\\n            if(board[i][col]==c)\\n                return false;\\n            \\n            //For checking the row\\n            if(board[row][i]==c)\\n                return false;\\n            \\n            //For checking the 3X3 sub-matrix\\n            if(board[3*(row/3)+(i/3)][3*(col/3)+i%3]==c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n//Return type of recur is bool coz we want just 1 solution and not all possible solutions that we normally do in recursion problems\\n    bool recur(vector<vector<char>>& board)\\n    {\\n        //Traverse the board until all the cells are filled\\n        for(int row=0; row<9; row++)\\n        {\\n            for(int col=0; col<9; col++)\\n            {\\n              //If a cell is blank, check all possible values that are valid\\n                if(board[row][col]==\\'.\\')\\n                {\\n                    for(char c=\\'1\\'; c<=\\'9\\'; c++)\\n                    {\\n                        //If it\\'s valid then fill it up and go for recursion\\n                        if(isValid(board,row,col,c))\\n                        {\\n                            board[row][col]=c;\\n                            bool possible=recur(board);\\n                            if(possible)  //This means we\\'re heading towards solution\\n                                return true;\\n                            board[row][col]=\\'.\\';   //For Backtracking\\n                        }\\n                    }\\n                //If no value is valid, it\\'s wrong solutin so return false\\n                    return false;\\n                }\\n            }\\n        }\\n//If traversing is over then it means there\\'s no blank left and we got our solution so we return true\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        \\n        bool b=recur(board);\\n    }\\n```\\n*If this was helpful don\\'t forget to upvote.*",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool isValid(vector<vector<char>>& board, int row, int col, char c)\\n    {\\n        for(int i=0; i<9; i++)\\n        {\\n            //For checking the column\\n            if(board[i][col]==c)\\n                return false;\\n            \\n            //For checking the row\\n            if(board[row][i]==c)\\n                return false;\\n            \\n            //For checking the 3X3 sub-matrix\\n            if(board[3*(row/3)+(i/3)][3*(col/3)+i%3]==c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n//Return type of recur is bool coz we want just 1 solution and not all possible solutions that we normally do in recursion problems\\n    bool recur(vector<vector<char>>& board)\\n    {\\n        //Traverse the board until all the cells are filled\\n        for(int row=0; row<9; row++)\\n        {\\n            for(int col=0; col<9; col++)\\n            {\\n              //If a cell is blank, check all possible values that are valid\\n                if(board[row][col]==\\'.\\')\\n                {\\n                    for(char c=\\'1\\'; c<=\\'9\\'; c++)\\n                    {\\n                        //If it\\'s valid then fill it up and go for recursion\\n                        if(isValid(board,row,col,c))\\n                        {\\n                            board[row][col]=c;\\n                            bool possible=recur(board);\\n                            if(possible)  //This means we\\'re heading towards solution\\n                                return true;\\n                            board[row][col]=\\'.\\';   //For Backtracking\\n                        }\\n                    }\\n                //If no value is valid, it\\'s wrong solutin so return false\\n                    return false;\\n                }\\n            }\\n        }\\n//If traversing is over then it means there\\'s no blank left and we got our solution so we return true\\n        return true;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        \\n        bool b=recur(board);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964117,
                "title": "java-simple-solution",
                "content": "**If you like the solution PLEASE UPVOTE**\\n```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0){\\n            return;\\n        }\\n        solve(board);\\n    }\\n    public boolean solve(char[][] board){\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'.\\'){\\n                    \\n                    for(char c = \\'1\\'; c <= \\'9\\'; c++){\\n                        \\n                        if(isValid(board, i, j, c)){\\n                            //if it is valid than put the c there\\n                            board[i][j] = c;\\n                            \\n                            //after putting call recursion\\n                            if(solve(board)){\\n                            //if we solve the board than return true;\\n                                return true;\\n                            }else{\\n                            //if we not able to solve put back the \\'.\\'\\n                            //backtrack    \\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }  \\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isValid(char board[][], int row, int col, char c){\\n        for(int i = 0; i < 9; i++){\\n            \\n            //for checking in the row\\n            if(board[i][col] == c){\\n                return false;\\n            }\\n            \\n            //for checking in the col\\n            if(board[row][i] == c){\\n                return false;\\n            }\\n            \\n            //for checking in the 3 * 3 box\\n            if(board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3 ] == c){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public void solveSudoku(char[][] board) {\\n        if(board == null || board.length == 0){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1811164,
                "title": "0ms-c-bit-mask-backtracking-solution",
                "content": "# Important Concepts\\n### Bit Operations\\n- `1 << n` is a **shift operation** and creates a number represented by the binary with all bits `0` except the `n-th` bit from right->left (`0-th` is the rightmost bit).\\n    - Example: `1 << 0` = `1`, `1 << 3 = 1000`, `1 << 5 = 100000`.\\n- `result = a | b` is the **OR** operator. The result\\'s `i-th` bit will be `1` if either the `i-th` bit in `a` is `1` or if the `i-th` bit in `b` is `1`.\\n    - Example: `101 | 010 = 111`, `100 | 001 = 101`, `0101 | 0110 = 0111`, `111 | 101 = 111`.\\n- `result = a ^ b` is the **XOR** operator. The result\\'s `i-th` bit will be `1` if the (`i-th` bit in `a` is `1` and the `i-th` bit in `b` is 0) or the (`i-th` of `a` is 0 and the `i-th` bit in `b` is `1`). \\n    - Only one of the operands can be `1` for the result to be `1`.\\n    - Example: `101 | 010 = 111`, `100 | 001 = 101`, `0101 | 0110 = 0011`, `111 | 101 = 010`.\\n- `result = a & b` is the **AND** operator. The result\\'s `i-th` bit will be `1` if both `a`\\'s `i-th` bit and `b`\\'s `i-th` bit have value `1`.\\n\\t- Example: `101 | 010` = `000`, `100 | 001 = 000`, `0101 | 0110 = 0100`, `111 | 101 = 101`.\\n\\n### Set operations with bit mask\\nSince we\\'re dealing with numbers between 1-9, an `int` with 32 bits is more than enough to be used as a `set` and store which numbers are being used in each row, column, and sub box.\\nThis `set` structure can be defined as `int mySet = 0`. The usage is:\\n- `mySet` contains the number `p` if the bit `p-th` bit from right to left is `1`. A set containing the number `2` and `5` is `100100`.\\n- `mySet | (1 << p)` adds `p` to `mySet`.\\n- `mySet ^ (1 << p)` removes `p` from `mySet`.\\n- `myset & (1 << p)` checks if `mySet` contains the number `p`.\\n\\n### Index math\\n- In our 9x9 sudoku we have 3x3 sub boxes. Given a cell in the sudoku at position `i,j`, I can find the respective sub box at `floor(i/3),  floor(j/3)`.\\n    - Examples: `position 1,1 = box 0,0`, `position 5,8 = box 1,2`.\\n\\nThat\\'s it, let\\'s go to the solution.\\n\\n## Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        // rows[i] stores the the set containing the numbers in the i-th row.\\n        vector<int> rows(9, 0);\\n        \\n        // columns[j] stores the the set containing the numbers in the j-th column.\\n        vector<int> columns(9, 0);\\n        \\n        // boxes[i][j] stores the set containing the numbers in the ij-th sub box.\\n        vector<vector<int>> boxes(3, vector<int>(3, 0));\\n        \\n        // Set the initial state of the board by adding the numbers to their respective rows, columns and sub box\\'s bit masks\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] == \\'.\\') continue;\\n                int mask = 1 << (board[i][j] - \\'0\\');\\n                rows[i] |= mask;\\n                columns[j] |= mask;\\n                boxes[i / 3][j / 3] |= mask;\\n            }\\n        }\\n        \\n        // Call the helper function\\n        solve(board, rows, columns, boxes, 0, 0);\\n    }\\n\\t\\n    bool solve(vector<vector<char>>& board, vector<int>& rows, vector<int>& columns, vector<vector<int>>& boxes, int i, int j){\\n        // If I populated all the rows, I found a solution;\\n        if(i == board.size()) return true;\\n        \\n        // If I reached the end of a row, go to the start of the next one\\n        if(j == board[i].size()) return solve(board, rows, columns, boxes, i+1, 0);\\n        \\n        // If this field is already populated, skip it\\n        if(board[i][j] != \\'.\\') return solve(board, rows, columns, boxes, i, j+1);\\n        \\n        // Let\\'s try all possible solutions\\n        for(int p = 1; p <= 9; p++){\\n            // The mask for the number the number p\\n            int mask = 1 << p;\\n            \\n            // If p already is in the current row, skip it\\n            if(mask & rows[i]) continue;\\n            \\n            // If p already if in the current column, skip it\\n            if(mask & columns[j]) continue;\\n            \\n            // If p already is in the current box, skip it.\\n            if(mask & boxes[i / 3][j / 3]) continue;\\n            \\n            // Add mask to row, column, sub box, and board.\\n            rows[i] |= mask;\\n            columns[j] |= mask;\\n            boxes[i / 3][j / 3] |= mask;\\n            board[i][j] = p + \\'0\\';\\n            \\n            // If we can fill the rest of the board, we are done!\\n            if(solve(board, rows, columns, boxes, i, j+1)) return true;\\n            \\n            // Otherwise, remove p from row, columns, sub box, and board.\\n            rows[i] ^= mask;\\n            columns[j] ^= mask;\\n            boxes[i / 3][j / 3] ^= mask;\\n            board[i][j] = \\'.\\';\\n        }\\n        \\n        // If we were unable to fill the board after trying all numbers from 1 to 9,\\n        // we\\'ve reached an invalid state and can\\'t continue.\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        // rows[i] stores the the set containing the numbers in the i-th row.\\n        vector<int> rows(9, 0);\\n        \\n        // columns[j] stores the the set containing the numbers in the j-th column.\\n        vector<int> columns(9, 0);\\n        \\n        // boxes[i][j] stores the set containing the numbers in the ij-th sub box.\\n        vector<vector<int>> boxes(3, vector<int>(3, 0));\\n        \\n        // Set the initial state of the board by adding the numbers to their respective rows, columns and sub box\\'s bit masks\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] == \\'.\\') continue;\\n                int mask = 1 << (board[i][j] - \\'0\\');\\n                rows[i] |= mask;\\n                columns[j] |= mask;\\n                boxes[i / 3][j / 3] |= mask;\\n            }\\n        }\\n        \\n        // Call the helper function\\n        solve(board, rows, columns, boxes, 0, 0);\\n    }\\n\\t\\n    bool solve(vector<vector<char>>& board, vector<int>& rows, vector<int>& columns, vector<vector<int>>& boxes, int i, int j){\\n        // If I populated all the rows, I found a solution;\\n        if(i == board.size()) return true;\\n        \\n        // If I reached the end of a row, go to the start of the next one\\n        if(j == board[i].size()) return solve(board, rows, columns, boxes, i+1, 0);\\n        \\n        // If this field is already populated, skip it\\n        if(board[i][j] != \\'.\\') return solve(board, rows, columns, boxes, i, j+1);\\n        \\n        // Let\\'s try all possible solutions\\n        for(int p = 1; p <= 9; p++){\\n            // The mask for the number the number p\\n            int mask = 1 << p;\\n            \\n            // If p already is in the current row, skip it\\n            if(mask & rows[i]) continue;\\n            \\n            // If p already if in the current column, skip it\\n            if(mask & columns[j]) continue;\\n            \\n            // If p already is in the current box, skip it.\\n            if(mask & boxes[i / 3][j / 3]) continue;\\n            \\n            // Add mask to row, column, sub box, and board.\\n            rows[i] |= mask;\\n            columns[j] |= mask;\\n            boxes[i / 3][j / 3] |= mask;\\n            board[i][j] = p + \\'0\\';\\n            \\n            // If we can fill the rest of the board, we are done!\\n            if(solve(board, rows, columns, boxes, i, j+1)) return true;\\n            \\n            // Otherwise, remove p from row, columns, sub box, and board.\\n            rows[i] ^= mask;\\n            columns[j] ^= mask;\\n            boxes[i / 3][j / 3] ^= mask;\\n            board[i][j] = \\'.\\';\\n        }\\n        \\n        // If we were unable to fill the board after trying all numbers from 1 to 9,\\n        // we\\'ve reached an invalid state and can\\'t continue.\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734046,
                "title": "python-backtrack-solution",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        chars = \"123456789\"\\n        def isvalid(row,col,c):\\n            for i in range(9):\\n                if board[row][i]==c:\\n                    return False\\n                if board[i][col]==c:\\n                    return False\\n                if board[3*(row//3)+(i//3)][3*(col//3)+(i%3)]==c:\\n                    return False\\n            return True\\n        \\n        def solve():\\n            for i in range(len(board)):\\n                for j in range(len(board[0])):\\n                    if board[i][j]==\".\":\\n                        for c in chars:\\n                            if isvalid(i,j,c):\\n                                board[i][j]=c\\n                                if solve():\\n                                    return True\\n                                board[i][j]=\".\"\\n                        return False\\n            return True\\n        solve()\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        chars = \"123456789\"\\n        def isvalid(row,col,c):\\n            for i in range(9):\\n                if board[row][i]==c:\\n                    return False\\n                if board[i][col]==c:\\n                    return False\\n                if board[3*(row//3)+(i//3)][3*(col//3)+(i%3)]==c:\\n                    return False\\n            return True\\n        \\n        def solve():\\n            for i in range(len(board)):\\n                for j in range(len(board[0])):\\n                    if board[i][j]==\".\":\\n                        for c in chars:\\n                            if isvalid(i,j,c):\\n                                board[i][j]=c\\n                                if solve():\\n                                    return True\\n                                board[i][j]=\".\"\\n                        return False\\n            return True\\n        solve()\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685828,
                "title": "python-simple-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \\n        # Check if it is safe to place a number at chosen position\\n        def isValid(board:List[List[str]], row:int, col:int, val:str) -> bool:\\n            \\n            # Checking for duplicate in row and column\\n            for i in range(0, 9):\\n                if board[i][col]==val: return False\\n                if board[row][i]==val: return False\\n            \\n            # Identifying in which 3*3 block the position is\\n            for limit in range(3, 10, 3):\\n                if row < limit: \\n                    rowLimit = limit\\n                    break\\n            for limit in range(3, 10, 3):\\n                if col < limit:\\n                    colLimit = limit\\n                    break\\n            \\n            # Once we got 3*3 block i.e. (rowLimit, colLimit)\\n            # Find out if there occurs any duplicate value\\n            for i in range(rowLimit-3, rowLimit):\\n                for j in range(colLimit-3, colLimit):\\n                    if board[i][j]==val: return False\\n            \\n            # If we\\'ve reached here, then it\\'s safe\\n            return True\\n\\n        # Recursive function\\n        def sudoku(board:List[List[str]]):\\n            # Loops to reached each cell of the board\\n            for i in range(0, 9):\\n                for j in range(0, 9):\\n                    \\n                    # Check for empty place\\n                    if board[i][j] == \".\":\\n                        # Loop through to get all possible values which could be inserted in place\\n                        for val in range(1, 10):\\n                            # Check whether the chosen value is valid for the position\\n                            if isValid(board, i, j, str(val)):\\n                                # If value is valid then just put it in place\\n                                board[i][j] = str(val)\\n                                # Check whether the sudoku can be solved for this value\\n                                if sudoku(board) == True:\\n                                    # If solved, return True\\n                                    return True\\n                                # If it wasn\\'t solved with the chosen value, then remove the value from the place i.e. backtrack\\n                                board[i][j] = \".\"\\n                        \\n                        # If no value can be placed at the place, then we have to backtrack thus return False\\n                        return False\\n            \\n            # If we reached to this point, it means we\\'ve been to each cell of the board and successfully filled all the empty cells, hence return True\\n            return True\\n        \\n        # Call the recursive function with the given board\\n        sudoku(board)\\n        \\n        # Return the board\\n        return board\\n```\\n\\nThank you for reading.\\nI hope it was useful :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \\n        # Check if it is safe to place a number at chosen position\\n        def isValid(board:List[List[str]], row:int, col:int, val:str) -> bool:\\n            \\n            # Checking for duplicate in row and column\\n            for i in range(0, 9):\\n                if board[i][col]==val: return False\\n                if board[row][i]==val: return False\\n            \\n            # Identifying in which 3*3 block the position is\\n            for limit in range(3, 10, 3):\\n                if row < limit: \\n                    rowLimit = limit\\n                    break\\n            for limit in range(3, 10, 3):\\n                if col < limit:\\n                    colLimit = limit\\n                    break\\n            \\n            # Once we got 3*3 block i.e. (rowLimit, colLimit)\\n            # Find out if there occurs any duplicate value\\n            for i in range(rowLimit-3, rowLimit):\\n                for j in range(colLimit-3, colLimit):\\n                    if board[i][j]==val: return False\\n            \\n            # If we\\'ve reached here, then it\\'s safe\\n            return True\\n\\n        # Recursive function\\n        def sudoku(board:List[List[str]]):\\n            # Loops to reached each cell of the board\\n            for i in range(0, 9):\\n                for j in range(0, 9):\\n                    \\n                    # Check for empty place\\n                    if board[i][j] == \".\":\\n                        # Loop through to get all possible values which could be inserted in place\\n                        for val in range(1, 10):\\n                            # Check whether the chosen value is valid for the position\\n                            if isValid(board, i, j, str(val)):\\n                                # If value is valid then just put it in place\\n                                board[i][j] = str(val)\\n                                # Check whether the sudoku can be solved for this value\\n                                if sudoku(board) == True:\\n                                    # If solved, return True\\n                                    return True\\n                                # If it wasn\\'t solved with the chosen value, then remove the value from the place i.e. backtrack\\n                                board[i][j] = \".\"\\n                        \\n                        # If no value can be placed at the place, then we have to backtrack thus return False\\n                        return False\\n            \\n            # If we reached to this point, it means we\\'ve been to each cell of the board and successfully filled all the empty cells, hence return True\\n            return True\\n        \\n        # Call the recursive function with the given board\\n        sudoku(board)\\n        \\n        # Return the board\\n        return board\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506178,
                "title": "easy-to-understand-as-well-as-implement-javascript",
                "content": "```\\nvar solveSudoku = function(board) {\\n    function sudokuSolver(board) {\\n        for(let i = 0; i < 9; i++) {\\n            for(let j = 0; j < 9; j++) {\\n                if(board[i][j] === \\'.\\') {\\n                    let char = \\'1\\';\\n                    while(char <= 9) {\\n                        if(isValidSudoku(i, j, char)) {\\n                            board[i][j] = char;\\n                            \\n                            if(sudokuSolver(board)) return true;\\n                            else board[i][j] = \\'.\\';\\n                        }\\n                        char = (parseInt(char) + 1).toString();\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    function isValidSudoku(row, col, char) {\\n        for(let i = 0; i < 9; i++) {\\n            if(board[row][i] === char) return false;\\n        }\\n        \\n        for(let i = 0; i < 9; i++) {\\n            if(board[i][col] === char) return false;\\n        }\\n        \\n        let x = Math.floor(row / 3) * 3;\\n        let y = Math.floor(col / 3) * 3;\\n        \\n        for(let i = 0; i < 3; i++) {\\n            for(let j = 0; j < 3; j++) {\\n                if(board[x + i][y + j] === char) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    sudokuSolver(board);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar solveSudoku = function(board) {\\n    function sudokuSolver(board) {\\n        for(let i = 0; i < 9; i++) {\\n            for(let j = 0; j < 9; j++) {\\n                if(board[i][j] === \\'.\\') {\\n                    let char = \\'1\\';\\n                    while(char <= 9) {\\n                        if(isValidSudoku(i, j, char)) {\\n                            board[i][j] = char;\\n                            \\n                            if(sudokuSolver(board)) return true;\\n                            else board[i][j] = \\'.\\';\\n                        }\\n                        char = (parseInt(char) + 1).toString();\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    function isValidSudoku(row, col, char) {\\n        for(let i = 0; i < 9; i++) {\\n            if(board[row][i] === char) return false;\\n        }\\n        \\n        for(let i = 0; i < 9; i++) {\\n            if(board[i][col] === char) return false;\\n        }\\n        \\n        let x = Math.floor(row / 3) * 3;\\n        let y = Math.floor(col / 3) * 3;\\n        \\n        for(let i = 0; i < 3; i++) {\\n            for(let j = 0; j < 3; j++) {\\n                if(board[x + i][y + j] === char) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    sudokuSolver(board);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1504008,
                "title": "python-using-backtracking-solution-time-o-9-m-space-o-m-m-is-the-number-of-missing-cells",
                "content": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:        \\n        def dfs(row, col):\\n            if row == 9: return True\\n            if col == 9: return dfs(row + 1, 0)\\n            if board[row][col] != \\'.\\': return dfs(row, col + 1)\\n            for c in range(1, 10):\\n                if not isValid(row, col, str(c)): continue\\n                board[row][col] = str(c)\\n                if dfs(row, col + 1): return True\\n                board[row][col] = \\'.\\'\\n            return False\\n        \\n        def isValid(row , col, c):\\n            for i in range(9):\\n                if board[row][i] != \\'.\\' and board[row][i] == c: return False\\n                if board[i][col] != \\'.\\' and board[i][col] == c: return False\\n            for i in range(3):\\n                for j in range(3):\\n                    baseRow, baseCol = row - row%3, col - col %3\\n                    current = board[baseRow + i][ baseCol + j]\\n                    if current != \\'.\\' and current == c: return False\\n            return True\\n        dfs(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:        \\n        def dfs(row, col):\\n            if row == 9: return True\\n            if col == 9: return dfs(row + 1, 0)\\n            if board[row][col] != \\'.\\': return dfs(row, col + 1)\\n            for c in range(1, 10):\\n                if not isValid(row, col, str(c)): continue\\n                board[row][col] = str(c)\\n                if dfs(row, col + 1): return True\\n                board[row][col] = \\'.\\'\\n            return False\\n        \\n        def isValid(row , col, c):\\n            for i in range(9):\\n                if board[row][i] != \\'.\\' and board[row][i] == c: return False\\n                if board[i][col] != \\'.\\' and board[i][col] == c: return False\\n            for i in range(3):\\n                for j in range(3):\\n                    baseRow, baseCol = row - row%3, col - col %3\\n                    current = board[baseRow + i][ baseCol + j]\\n                    if current != \\'.\\' and current == c: return False\\n            return True\\n        dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483899,
                "title": "simple-clean-java-solution",
                "content": "```\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n       \\n    }\\n    boolean solve(char[][] board){\\n        for(int i=0;i<board.length;i++){          //traverse the whole 9*9 matrix\\n            for(int j=0;j<board[0].length;j++){\\n                \\n                if(board[i][j]==\\'.\\'){        // if empty space found\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){                       // check if a number bw 1-9 can be fit into it\\n                        if(isvalid(board,i,j,c)){                         // validate\\n                            board[i][j]=c;                                  // put that number\\n                            if(solve(board)==true){return true;}         // recursively check further\\n                            else{board[i][j]=\\'.\\';}                       // else mark it again empty\\n                        }\\n                        \\n                    }\\n                      return false; \\n                }\\n                \\n            }\\n        }\\n      return true;\\n    } \\n    boolean isvalid(char[][]board, int row,int  col, char c){        // IMPORTANT validate function check row, column and 3*3 box , if that number is present return false\\n        for(int i=0;i<9;i++){\\n            if( board[row][i]==c){return false;}\\n            if( board[i][col]==c){return false;}\\n            if(board[3*(row/3) +i/3][3*(col/3)+i%3]==c){return false;}           // very important check\\n        }\\n        \\n        return true;     \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n       \\n    }\\n    boolean solve(char[][] board){\\n        for(int i=0;i<board.length;i++){          //traverse the whole 9*9 matrix\\n            for(int j=0;j<board[0].length;j++){\\n                \\n                if(board[i][j]==\\'.\\'){        // if empty space found\\n                    for(char c=\\'1\\';c<=\\'9\\';c++){                       // check if a number bw 1-9 can be fit into it\\n                        if(isvalid(board,i,j,c)){                         // validate\\n                            board[i][j]=c;                                  // put that number\\n                            if(solve(board)==true){return true;}         // recursively check further\\n                            else{board[i][j]=\\'.\\';}                       // else mark it again empty\\n                        }\\n                        \\n                    }\\n                      return false; \\n                }\\n                \\n            }\\n        }\\n      return true;\\n    } \\n    boolean isvalid(char[][]board, int row,int  col, char c){        // IMPORTANT validate function check row, column and 3*3 box , if that number is present return false\\n        for(int i=0;i<9;i++){\\n            if( board[row][i]==c){return false;}\\n            if( board[i][col]==c){return false;}\\n            if(board[3*(row/3) +i/3][3*(col/3)+i%3]==c){return false;}           // very important check\\n        }\\n        \\n        return true;     \\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1420736,
                "title": "simple-and-clean-solution-backtracking-c-beats-98",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(int i, int j, vector<vector<char>>& board, int rows[][9], int cols[][9], int cells[][3][3]){\\n        if(j == board[0].size()){\\n            return solve(i+1, 0, board, rows, cols, cells);\\n        } else if(i == board.size()){\\n            return true;\\n        } else if(board[i][j] != \\'.\\'){\\n            return solve(i, j+1, board, rows, cols, cells);\\n        }\\n        for(int k = 1; k <= 9; k++){\\n            if(rows[k][i] == 1 || cols[k][j] == 1 || cells[k][i/3][j/3] == 1)\\n                continue;\\n            \\n            rows[k][i] = cols[k][j] = cells[k][i/3][j/3] = 1;\\n            board[i][j] = (char)(k+\\'0\\');\\n            if(solve(i, j+1, board, rows, cols, cells)){\\n                return true;\\n            }\\n            rows[k][i] = cols[k][j] = cells[k][i/3][j/3] = 0;\\n            board[i][j] = \\'.\\';\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        int rows[10][9] = {};\\n        int cols[10][9] = {};\\n        int cells[10][3][3] = {};\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int k = board[i][j] - \\'0\\';\\n                    rows[k][i] = cols[k][j] = cells[k][i/3][j/3] = 1;\\n                }\\n            }\\n        }\\n        solve(0,0, board, rows, cols, cells);\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i, int j, vector<vector<char>>& board, int rows[][9], int cols[][9], int cells[][3][3]){\\n        if(j == board[0].size()){\\n            return solve(i+1, 0, board, rows, cols, cells);\\n        } else if(i == board.size()){\\n            return true;\\n        } else if(board[i][j] != \\'.\\'){\\n            return solve(i, j+1, board, rows, cols, cells);\\n        }\\n        for(int k = 1; k <= 9; k++){\\n            if(rows[k][i] == 1 || cols[k][j] == 1 || cells[k][i/3][j/3] == 1)\\n                continue;\\n            \\n            rows[k][i] = cols[k][j] = cells[k][i/3][j/3] = 1;\\n            board[i][j] = (char)(k+\\'0\\');\\n            if(solve(i, j+1, board, rows, cols, cells)){\\n                return true;\\n            }\\n            rows[k][i] = cols[k][j] = cells[k][i/3][j/3] = 0;\\n            board[i][j] = \\'.\\';\\n        }\\n        return false;\\n    }\\n    void solveSudoku(vector<vector<char>>& board) {\\n        int rows[10][9] = {};\\n        int cols[10][9] = {};\\n        int cells[10][3][3] = {};\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int k = board[i][j] - \\'0\\';\\n                    rows[k][i] = cols[k][j] = cells[k][i/3][j/3] = 1;\\n                }\\n            }\\n        }\\n        solve(0,0, board, rows, cols, cells);\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416940,
                "title": "oop-python-backtracking-with-bit-masking-set-without-extra-space",
                "content": "Here is the framework of backtracking:\\nSet a number to a board, check if it is possible, if not possible, return to previous state\\nIf it reach the end, we return True and not setting it to another value\\n```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        board_state = BoardState()     \\n        board_state.init_board(board)\\n\\n        def backtracking(curr, board_state):\\n            if curr == (len(board[0]) * len(board)):\\n                return True\\n            \\n            i, j = curr // len(board), curr % len(board)\\n            \\n            if board[i][j] != \\'.\\':\\n                return backtracking(curr+1, board_state)\\n\\n            for intended in range(1, 10):\\n                if board_state.valid_step(i, j, intended):\\n                    board_state.set_board(i, j, intended)\\n                    res = backtracking(curr+1, board_state)\\n                    if res: # we have found a result already\\n                        board[i][j] = str(intended)\\n                        return True\\n                    board_state.clear_board(i, j, intended)\\n\\n            return False\\n        \\n        backtracking(0, board_state)\\n        return\\n```\\n\\n\\n\\n\\nWe define a class called board stste, which can help us to know if we can put the number to the place, there are multiple ways to implement it:\\n\\nBit masking:\\n```\\nclass BoardState:\\n    def __init__(self):\\n        self.cells = [0] * 9\\n        self.rows = [0] * 9\\n        self.cols = [0] * 9\\n    \\n    def get_bit(self, x, i):\\n        return x & (1 << i)\\n        \\n    def set_bit(self, x, i):\\n        return x | (1 << i)\\n        \\n    def clear_bit(self, x, i):\\n        return x & ~(1 << i)\\n\\t\\t\\n    def init_board(self, board):\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] != \\'.\\':\\n                    val = int(board[i][j])\\n                    self.set_board(i, j, val)  \\n        \\n    def valid_step(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        col_mask = self.get_bit(self.cols[j], val)\\n        row_mask = self.get_bit(self.rows[i], val)\\n        cell_mask = self.get_bit(self.cells[cell_id], val)\\n        return (col_mask | row_mask | cell_mask) == 0\\n        \\n    def set_board(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        self.cols[j] = self.set_bit(self.cols[j], val)\\n        self.rows[i] = self.set_bit(self.rows[i], val)\\n        self.cells[cell_id] = self.set_bit(self.cells[cell_id], val)\\n```\\n\\nHashset\\n```\\nclass BoardState:\\n    def __init__(self):\\n        self.cells = [set() for _ in range(9)]\\n        self.rows = [set() for _ in range(9)]\\n        self.cols = [set() for _ in range(9)]\\n\\t\\n    def init_board(self, board):\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] != \\'.\\':\\n                    val = int(board[i][j])\\n                    self.set_board(i, j, val)  \\n        \\n    def valid_step(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        in_col = val in self.cols[j]\\n        in_row = val in self.rows[i]\\n        in_cell = val in self.cells[cell_id]\\n        return (in_col or in_row or in_cell) == False\\n        \\n    def set_board(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        self.cols[j].add(val)\\n        self.rows[i].add(val)\\n        self.cells[cell_id].add(val)\\n            \\n    def clear_board(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        self.cols[j].remove(val)\\n        self.rows[i].remove(val)\\n        self.cells[cell_id].remove(val)\\n```\\n\\nInstead of using masking method, we can also use the original board without extra space\\n```\\nclass BoardState:\\n    def __init__(self):\\n        pass\\n\\t\\n    def init_board(self, board):\\n        self.board = board\\n        \\n    def valid_step(self, i, j, val):\\n        # search for same row\\n        cell_sx = i // 3 * 3\\n        cell_sy = j // 3 * 3\\n        val = str(val)\\n        for x in range(9):\\n            cell_cx = cell_sx + x // 3\\n            cell_cy = cell_sy + x % 3\\n            if self.board[x][j] == val or\\\\\\n                self.board[i][x] == val or \\\\\\n                self.board[cell_cx][cell_cy] == val:\\n                return False\\n        return True     \\n        \\n    def set_board(self, i, j, val):\\n        self.board[i][j] = str(val)\\n            \\n    def clear_board(self, i, j, val):\\n        self.board[i][j] = \\'.\\'\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        board_state = BoardState()     \\n        board_state.init_board(board)\\n\\n        def backtracking(curr, board_state):\\n            if curr == (len(board[0]) * len(board)):\\n                return True\\n            \\n            i, j = curr // len(board), curr % len(board)\\n            \\n            if board[i][j] != \\'.\\':\\n                return backtracking(curr+1, board_state)\\n\\n            for intended in range(1, 10):\\n                if board_state.valid_step(i, j, intended):\\n                    board_state.set_board(i, j, intended)\\n                    res = backtracking(curr+1, board_state)\\n                    if res: # we have found a result already\\n                        board[i][j] = str(intended)\\n                        return True\\n                    board_state.clear_board(i, j, intended)\\n\\n            return False\\n        \\n        backtracking(0, board_state)\\n        return\\n```\n```\\nclass BoardState:\\n    def __init__(self):\\n        self.cells = [0] * 9\\n        self.rows = [0] * 9\\n        self.cols = [0] * 9\\n    \\n    def get_bit(self, x, i):\\n        return x & (1 << i)\\n        \\n    def set_bit(self, x, i):\\n        return x | (1 << i)\\n        \\n    def clear_bit(self, x, i):\\n        return x & ~(1 << i)\\n\\t\\t\\n    def init_board(self, board):\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] != \\'.\\':\\n                    val = int(board[i][j])\\n                    self.set_board(i, j, val)  \\n        \\n    def valid_step(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        col_mask = self.get_bit(self.cols[j], val)\\n        row_mask = self.get_bit(self.rows[i], val)\\n        cell_mask = self.get_bit(self.cells[cell_id], val)\\n        return (col_mask | row_mask | cell_mask) == 0\\n        \\n    def set_board(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        self.cols[j] = self.set_bit(self.cols[j], val)\\n        self.rows[i] = self.set_bit(self.rows[i], val)\\n        self.cells[cell_id] = self.set_bit(self.cells[cell_id], val)\\n```\n```\\nclass BoardState:\\n    def __init__(self):\\n        self.cells = [set() for _ in range(9)]\\n        self.rows = [set() for _ in range(9)]\\n        self.cols = [set() for _ in range(9)]\\n\\t\\n    def init_board(self, board):\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] != \\'.\\':\\n                    val = int(board[i][j])\\n                    self.set_board(i, j, val)  \\n        \\n    def valid_step(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        in_col = val in self.cols[j]\\n        in_row = val in self.rows[i]\\n        in_cell = val in self.cells[cell_id]\\n        return (in_col or in_row or in_cell) == False\\n        \\n    def set_board(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        self.cols[j].add(val)\\n        self.rows[i].add(val)\\n        self.cells[cell_id].add(val)\\n            \\n    def clear_board(self, i, j, val):\\n        cell_id = i // 3 * 3 + j // 3\\n        self.cols[j].remove(val)\\n        self.rows[i].remove(val)\\n        self.cells[cell_id].remove(val)\\n```\n```\\nclass BoardState:\\n    def __init__(self):\\n        pass\\n\\t\\n    def init_board(self, board):\\n        self.board = board\\n        \\n    def valid_step(self, i, j, val):\\n        # search for same row\\n        cell_sx = i // 3 * 3\\n        cell_sy = j // 3 * 3\\n        val = str(val)\\n        for x in range(9):\\n            cell_cx = cell_sx + x // 3\\n            cell_cy = cell_sy + x % 3\\n            if self.board[x][j] == val or\\\\\\n                self.board[i][x] == val or \\\\\\n                self.board[cell_cx][cell_cy] == val:\\n                return False\\n        return True     \\n        \\n    def set_board(self, i, j, val):\\n        self.board[i][j] = str(val)\\n            \\n    def clear_board(self, i, j, val):\\n        self.board[i][j] = \\'.\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362094,
                "title": "c-backtracking-solution-with-comments-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    bool isSafeToPlace(vector<vector<char>> &board , int row , int col , char ch)\\n    {\\n        //start idx of row and col of 3*3 grid box\\n        int rowIdx = 3 * (row/3) ;\\n        int colIdx = 3 * (col/3) ;\\n        \\n        for(int idx = 0 ; idx < 9 ; idx++)\\n        {\\n                //checks for that row fixed , and column varies\\n            if(board[row][idx] == ch)\\n                return false ;\\n            \\n                //checks for that column fixed , and row varies\\n            if(board[idx][col] == ch)\\n                return false ;\\n            \\n                //checks within that grid of 3*3 , where rowIdx and colIdx mark the start row-col of that grid\\n            if(board[rowIdx + (idx/3)][colIdx + (idx%3)] == ch)\\n                return false ;\\n        }\\n        \\n        return true ;\\n    }\\n    \\n    \\n    bool makeMyBoard(vector<vector<char>> &board)\\n    {\\n        for(int row = 0 ; row < board.size() ; row++)\\n        {\\n            for(int col = 0 ; col < board[0].size() ; col++)\\n            {\\n                if(board[row][col] == \\'.\\')\\n                {\\n                    for(char ch = \\'1\\' ; ch <= \\'9\\' ; ch++)\\n                    {\\n                        bool isSafe = isSafeToPlace(board , row , col , ch) ;\\n                        \\n                        \\n                        if(isSafe)\\n                        {\\n                            board[row][col] = ch ;\\n                            \\n\\t\\t\\t\\t\\t\\t\\t\\tif(makeMyBoard(board))  return true ;       //recursive call\\n                            \\n\\t\\t\\t\\t\\t\\t\\tboard[row][col] = \\'.\\' ;       //decision to backtrack if false , returns in case of true\\n                        }\\n                        \\n                    }\\n                \\n                    return false ;\\n                }\\n                \\n            }\\n            \\n        }\\n        return true ;\\n    }\\n    \\n    void solveSudoku(vector<vector<char>>& board) {\\n\\t\\t\\t//calling function maintaining the board\\n\\t\\tmakeMyBoard(board) ;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isSafeToPlace(vector<vector<char>> &board , int row , int col , char ch)\\n    {\\n        //start idx of row and col of 3*3 grid box\\n        int rowIdx = 3 * (row/3) ;\\n        int colIdx = 3 * (col/3) ;\\n        \\n        for(int idx = 0 ; idx < 9 ; idx++)\\n        {\\n                //checks for that row fixed , and column varies\\n            if(board[row][idx] == ch)\\n                return false ;\\n            \\n                //checks for that column fixed , and row varies\\n            if(board[idx][col] == ch)\\n                return false ;\\n            \\n                //checks within that grid of 3*3 , where rowIdx and colIdx mark the start row-col of that grid\\n            if(board[rowIdx + (idx/3)][colIdx + (idx%3)] == ch)\\n                return false ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1322742,
                "title": "java-simple-backtracking-with-explanation-beats-90",
                "content": "Start with creating a \"state\" of the given sudoku board. The state includes these 4 variables -\\n\\n`rowVals` stores characters used in a row. `row[i]`is the characters used in `i-th` row of the board\\n`colVals` stores characters used in a col\\n`subBoxVals` stores the characters stored in a \"subBox\"\\n`unfilledPos` stores positions [i, j] where we have  `.` in the board\\n\\n*Backtracking -*\\nThe backtracking function receives the board and index of the unfilledPos which it must fill by guessing. The function returns true if it was able to fill the position at its index as well as all subsequent indices, while maintaining the constraints of sudoku.\\n\\nIn the backtracking function, we essentially fill the position by guessing a valid digit from 1 through 9. We use the state that we created initially to check which digits can be used as guesses. Once we make a guess, we update the state. If the guess doesn\\'t work for rest of the board, we undo the guess (ie, backtrack)\\n\\n*Footnote*\\nSimilar problem to try -\\nL351: Android unlock patterns https://leetcode.com/problems/android-unlock-patterns/\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n    private boolean[][] rowVals;\\n    private boolean[][] colVals;\\n    private boolean[][] subBoxVals;\\n    private List<int[]> unfilledPos;\\n    \\n    \\n    public void solveSudoku(char[][] board) {\\n        rowVals = new boolean[9][9];\\n        colVals = new boolean[9][9];\\n        subBoxVals = new boolean[9][9];\\n        unfilledPos = new ArrayList();\\n        \\n        /* Hydrate rowVals, colVals, subBoxVals, unfilledPos */\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                \\n                if(board[i][j] == \\'.\\') { \\n                    unfilledPos.add(new int[] { i, j });\\n                    continue;\\n                }\\n                \\n                int k = (int) (board[i][j] - \\'1\\');\\n                rowVals[i][k] = true;\\n                colVals[j][k] = true;\\n                subBoxVals[getSubBox(i, j)][k] = true;\\n            }\\n        }\\n        \\n        backtrack(board, 0);\\n    }\\n    \\n    private boolean backtrack(char[][] board, int index) {\\n        if(index == unfilledPos.size()) return true;\\n        \\n        int[] pos = unfilledPos.get(index);\\n        int x = pos[0], y = pos[1];\\n        \\n        for(int guess = 0; guess < 9; guess++) {\\n            if(canUse(board, x, y, guess)) {\\n                \\n                board[x][y] = (char) (\\'1\\' + guess);\\n                rowVals[x][guess] = true;\\n                colVals[y][guess] = true;\\n                subBoxVals[getSubBox(x, y)][guess] = true;\\n                \\n                boolean isRestValid = backtrack(board, index + 1);\\n                if(isRestValid) return true;\\n                \\n                /* Rest of the board is not valid. So we backtrack, ie, undo our guess */\\n                board[x][y] = \\'.\\';\\n                rowVals[x][guess] = false;\\n                colVals[y][guess] = false;\\n                subBoxVals[getSubBox(x, y)][guess] = false;\\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int getSubBox(int i, int j) {\\n        return (i / 3) * 3 + (j / 3);\\n    }\\n    \\n    private boolean canUse(char[][] board, int x, int y, int guess) {        \\n        return !rowVals[x][guess] \\n            && !colVals[y][guess] \\n            && !subBoxVals[getSubBox(x, y)][guess];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private boolean[][] rowVals;\\n    private boolean[][] colVals;\\n    private boolean[][] subBoxVals;\\n    private List<int[]> unfilledPos;\\n    \\n    \\n    public void solveSudoku(char[][] board) {\\n        rowVals = new boolean[9][9];\\n        colVals = new boolean[9][9];\\n        subBoxVals = new boolean[9][9];\\n        unfilledPos = new ArrayList();\\n        \\n        /* Hydrate rowVals, colVals, subBoxVals, unfilledPos */\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                \\n                if(board[i][j] == \\'.\\') { \\n                    unfilledPos.add(new int[] { i, j });\\n                    continue;\\n                }\\n                \\n                int k = (int) (board[i][j] - \\'1\\');\\n                rowVals[i][k] = true;\\n                colVals[j][k] = true;\\n                subBoxVals[getSubBox(i, j)][k] = true;\\n            }\\n        }\\n        \\n        backtrack(board, 0);\\n    }\\n    \\n    private boolean backtrack(char[][] board, int index) {\\n        if(index == unfilledPos.size()) return true;\\n        \\n        int[] pos = unfilledPos.get(index);\\n        int x = pos[0], y = pos[1];\\n        \\n        for(int guess = 0; guess < 9; guess++) {\\n            if(canUse(board, x, y, guess)) {\\n                \\n                board[x][y] = (char) (\\'1\\' + guess);\\n                rowVals[x][guess] = true;\\n                colVals[y][guess] = true;\\n                subBoxVals[getSubBox(x, y)][guess] = true;\\n                \\n                boolean isRestValid = backtrack(board, index + 1);\\n                if(isRestValid) return true;\\n                \\n                /* Rest of the board is not valid. So we backtrack, ie, undo our guess */\\n                board[x][y] = \\'.\\';\\n                rowVals[x][guess] = false;\\n                colVals[y][guess] = false;\\n                subBoxVals[getSubBox(x, y)][guess] = false;\\n                \\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int getSubBox(int i, int j) {\\n        return (i / 3) * 3 + (j / 3);\\n    }\\n    \\n    private boolean canUse(char[][] board, int x, int y, int guess) {        \\n        return !rowVals[x][guess] \\n            && !colVals[y][guess] \\n            && !subBoxVals[getSubBox(x, y)][guess];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300663,
                "title": "sudoku-solver-java-solution-100-fast-solution",
                "content": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n    boolean solve(char[][] board) {\\n        for(int i=0;i<board.length;i++) {\\n            for(int j = 0; j < board[0].length; j++) {\\n                if(board[i][j] == \\'.\\') {\\n                    for(char c=\\'1\\';c<=\\'9\\';c++) {\\n                        if(isValid(board,i,j,c)) {\\n                            board[i][j] = c;\\n                            \\n                            if(solve(board) == true) {\\n                                return true;\\n                            } else{\\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    boolean isValid(char[][] board,int row,int col,char c) {\\n        for(int i=0;i<9;i++) {\\n            if(board[i][col] == c) return false;\\n            if(board[row][i] == c) return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void solveSudoku(char[][] board) {\\n        solve(board);\\n    }\\n    boolean solve(char[][] board) {\\n        for(int i=0;i<board.length;i++) {\\n            for(int j = 0; j < board[0].length; j++) {\\n                if(board[i][j] == \\'.\\') {\\n                    for(char c=\\'1\\';c<=\\'9\\';c++) {\\n                        if(isValid(board,i,j,c)) {\\n                            board[i][j] = c;\\n                            \\n                            if(solve(board) == true) {\\n                                return true;\\n                            } else{\\n                                board[i][j] = \\'.\\';\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    boolean isValid(char[][] board,int row,int col,char c) {\\n        for(int i=0;i<9;i++) {\\n            if(board[i][col] == c) return false;\\n            if(board[row][i] == c) return false;\\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576287,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1565522,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1567334,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1716614,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1570404,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1575798,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1566294,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1572005,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1923461,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1568117,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1576287,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1565522,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1567334,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1716614,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1570404,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1575798,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1566294,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1572005,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1923461,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1568117,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "O (9 ^ 81) is constant. Since the board is 9 x 9 this means n is constant. N doesn\\'t grow. It\\'s fixed. And so is the time complexity. Fight me or agree with me."
                    },
                    {
                        "username": "MoonBrew",
                        "content": "1. You normally compare number of comparisions etc. done by the algorithm for time complexity. Seems like you are talking about problem itself.\n2. Even though the number of combinations are bounded, each particular problem can range from simple to hard depending on how many backtracks are needed. So for a brute force algorithm, you could say that as the problem gets harder it takes exponentially longer to solve it? Algorithms that deal much better with backtracks would be faster than brute force the harder the problem. Their time complexity, wouldn't that be lower? I guess for me N would not be the size of the squares but the hardness of the problem, if that were measurable."
                    },
                    {
                        "username": "user5267Xl",
                        "content": "- Since 9 and 81 are both constants, O(9^81) would normally be expressed as O(1).\\n- While the complexity may ultimately be bounded, choosing a huge limit doesn\\'t tell us anything interesting about the algorithm you\\'ve chosen to solve the problem. Calling the number of grid spaces \"N\" serves little purpose. It seems likely that the complexity of any sudoku solver will depend on the number of degrees of freedom in a given puzzle, but that\\'s just my guess.\\n- There aren\\'t nearly 9^81 possible ways to fill out an empty sudoku grid. That\\'s obvious just from the fact that entering a digit on an empty grid constrains 20 other squares to be some digit other than that one. Brittanica suggests that there are around 6.67e22 possible sudoku, and while that\\'s a big number it\\'s far, far smaller than 9^81."
                    },
                    {
                        "username": "Psykotic",
                        "content": "I don\\'t agree. Now give me a time and place to fight you"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am going to agree with you, my lord."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "9 ^ 81 = 196627050475552913618075908526912116283103450944214766927315415537966391196809\\n\\nDefinitely constant but too big to be true"
                    },
                    {
                        "username": "power721",
                        "content": "Dr. Donald Knuth\\u2019s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem.\\n\\nNOTE:This is a very complicate solution. \\n\\n[A Sudoku Solver in Java implementing Knuth\\u2019s Dancing Links Algorithm][1]\\n\\n\\n  [1]: http://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html"
                    },
                    {
                        "username": "billyoyo",
                        "content": "I wrote my implementation of this algorithm in python, where it ran in 48ms (beating 94.67% of solutions at the time), though there was definitely room to get it to run quicker in a couple of places.\\n\\nThe theory is very similar to the other python solutions, but with a couple of added sections which added a significant amount more code (which is why I\\'m not just posting my code). To be honest, I think any performance gain you can get from this algorithm is outweighed by the extra complexity of the code. \\n\\nThe algorithm:\\n* First, go through every empty cell and find its possible values (by looking at the square, row and column it\\'s in), store this list of possible values as the cells value\\n* Whenever a cell\\'s list of possible values gets reduced to a single value, fill in this value and update all the other unfilled cells in the same square, row and column\\n* Next go through every square, row and column and look for groups of possible values which are the same. If any of these groups have the same size as their amount of possible values, remove them from all other possible value arrays in the square/row/column.\\n\\t* e.g. if a row contains three unfilled cells with possible values (1, 2), (1, 2), (1, 3), the third cell can be reduced to (3) and thus filled in. The reason for this is that since the first two cells must collectively hold values 1 & 2, it\\'s impossible for the third to cell to have value 1, so it\\'s only possible value is 3.\\n* Keep repeating this last process until all possible reductions have been made\\n* If the board still isn\\'t filled, we now need to make a guess, choose your guess as follows:\\n\\t* find a group of size two (e.g. if a row has unfilled values (1, 3), (1, 3) then pick one of these cells to guess)\\n\\t* otherwise find an unfilled cell with the smallest amount of possible values\\n* Once we know our guess, recursively apply the algorithm with all variations of the guess to find a solution.\\n\\nThe two additions to the standard algorithm people are using are:\\n* filtering out groups of identical possibilities\\n* trying to be a bit smarter with our guesses\\n\\nThis algorithm should significantly reduce the number of guesses that need to be made to find a solution, and quite a lot of sudokus can be solved using this without requiring a single guess."
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I liked your solution. Did you post it in the solutions tab? If not, I\\'d like to see it plz."
                    },
                    {
                        "username": "conrad001",
                        "content": "I do not understand how the output should be. I am returning the correct answer but somehow the output in the testcase is the original unfilled board. "
                    },
                    {
                        "username": "markjreed",
                        "content": "Don\\'t return anything. Just modify the array in-place."
                    },
                    {
                        "username": "iCantC",
                        "content": "I checked out recent submissions & finally ended up returning boolean"
                    },
                    {
                        "username": "darklord0206",
                        "content": "yeah ! same error i am facing "
                    },
                    {
                        "username": "lazywitt",
                        "content": "change the given vector instead of returning a new solved vector"
                    },
                    {
                        "username": "amatana",
                        "content": "For the lazy:\\n\\n[[\"2\",\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"9\",\"6\",\".\",\"2\",\".\",\"1\",\".\"],[\"4\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\"8\",\".\",\"7\",\"9\",\".\",\"4\",\"5\",\".\",\"2\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"7\",\".\",\".\",\"5\"],[\".\",\"4\",\".\",\"2\",\".\",\"6\",\"1\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"8\",\"6\"]]\\n\\n[[\"6\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\"3\"],[\".\",\"4\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\"4\",\".\",\"7\",\".\"],[\"3\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"1\",\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\"6\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\"5\",\".\",\".\",\".\",\"9\",\"8\",\"7\"],[\".\",\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"2\",\".\",\".\",\".\",\"4\",\"8\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"2\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\"6\",\".\",\".\",\"2\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\",\"1\"],[\".\",\"2\",\".\",\"8\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"4\",\".\",\"3\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\"6\",\".\",\".\",\"5\",\".\"],[\".\",\".\",\".\",\"2\",\".\",\".\",\"3\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"8\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\"4\",\"7\",\".\",\"8\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\".\",\".\",\"7\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\"3\",\"5\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\".\"],[\".\",\"1\",\".\",\".\",\"6\",\".\",\".\",\".\",\".\"],[\"2\",\"8\",\".\",\".\",\"4\",\".\",\".\",\".\",\".\"],[\".\",\"9\",\".\",\"1\",\".\",\".\",\".\",\"4\",\".\"],[\".\",\".\",\".\",\".\",\"2\",\".\",\"6\",\"9\",\".\"]]\\n\\n[[\".\",\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\"5\",\".\",\"6\",\"2\",\".\",\".\",\"9\"],[\".\",\"6\",\"8\",\".\",\".\",\".\",\"3\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"6\",\"4\",\".\",\"8\",\".\",\"2\"],[\".\",\".\",\"4\",\"7\",\".\",\".\",\"9\",\".\",\".\"],[\".\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\"],[\"1\",\"7\",\".\",\"4\",\"3\",\".\",\".\",\".\",\".\"]]\\n\\n[[\"1\",\".\",\".\",\".\",\".\",\"6\",\".\",\"8\",\".\"],[\".\",\"6\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\"9\",\".\",\"6\",\".\",\".\"],[\".\",\"7\",\".\",\"4\",\".\",\".\",\"5\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\"7\",\".\",\"1\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\".\",\"3\",\"2\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[[\".\",\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\"8\",\"7\",\"3\",\".\",\".\",\".\",\"4\",\".\"],[\"6\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\"9\",\"7\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"4\",\"3\",\".\",\".\",\"7\",\"5\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\".\"],[\".\",\"3\",\".\",\".\",\".\",\"1\",\"4\",\"5\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\"1\"]]\\n\\n[[\".\",\"4\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\"9\",\".\",\".\",\"3\",\".\"],[\".\",\"7\",\"6\",\".\",\"2\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"4\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"9\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\"6\",\".\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\"4\",\".\",\"5\",\".\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\"7\",\"1\",\".\",\".\",\"2\",\".\",\".\"]]"
                    },
                    {
                        "username": "AnirudhVadera",
                        "content": "thanks man \\n"
                    },
                    {
                        "username": "416486188",
                        "content": "It is nothing but brute force + backtracking"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Backtracking is the brute force method, but when the bounding condition isn\\'t met, it kills the further recursion, but in brute force, you keep going."
                    },
                    {
                        "username": "shamas",
                        "content": "If you happen to have used a separate variable to store the solution before returning, you need to copy the results into the memory location of the original \\'board\\' variable. The assessing program does not look at your return value, it looks at the data stored at the location of the board variable passed to your program."
                    },
                    {
                        "username": "edaengineer",
                        "content": "\\nHow is it that these backtrack solutions don\\'t TLE? How is it that this problem can be run in finite time even for 9 * 9 grid? There is a total of (approx) 9 ^ 81 possibilities which is almost infinite (approx 10^80) ? That\\'s more than total atoms in the universe.\\n\\n**Even if we account for only 40 being empty cells, it\\'s still ~ 9^40 possibilities, which is more than 1 billion times longer than Leetcode acceptance time.**\\n\\nThe solutions that run on Leetcode are at most 10^ 8 complex in terms of possibilities, and this is just infinite comparatively."
                    },
                    {
                        "username": "GeorgeTaveras1231",
                        "content": "The thing is 9^81 are the number of possibilities to try on a completely empty board. As the board gets filled up, the number of possibilities to try is reduced. For example, if you add a `1` at `(0,0)` to a completely empty board, the number of possibilities goes down to `9^60 * 8^20` as there are now 20 boxes where there are only 8 options to try (8 on the sub-box, 6 on the right of the 1 and 6 on the bottom of the 1). The more you fill the box, the number of possibilities digress towards 1."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@charonme](/charonme) I run my solution it took 24ms in C++ to solve this \"hardest ever sudoku\" \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "charonme",
                        "content": "That\\'s only if you first fill all the cells and then check all the constraints. If you check the constraints before filling each additional cell the complexity is much smaller although it will still TLE if you feed it this one: https://abcnews.go.com/blogs/headlines/2012/06/can-you-solve-the-hardest-ever-sudoku\\n[[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"3\",\"6\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"7\",\".\",\".\",\"9\",\".\",\"2\",\".\",\".\"],[\".\",\"5\",\".\",\".\",\".\",\"7\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"4\",\"5\",\"7\",\".\",\".\"],[\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"3\",\".\"],[\".\",\".\",\"1\",\".\",\".\",\".\",\".\",\"6\",\"8\"],[\".\",\".\",\"8\",\"5\",\".\",\".\",\".\",\"1\",\".\"],[\".\",\"9\",\".\",\".\",\".\",\".\",\"4\",\".\",\".\"]]"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use backtracking to solve! This  short video shows the process for backtracking!!\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\n\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\ndigit once or none.\nThere are 27 conditions need to check.\n3 kinds of conditions: columns , rows and blocks.\n# Each board[i][j] lies exactly in one column, one row and one block.\n\nEach placement needs exactly 3 of these conditions !\nBoolean arrays suffice to use for recording and checking and play the role of hash tables and much faster! By solving Sudoku one can save more time.\nUse backtracking to solve in 16 ms!\n```\n  .  .  9  7  4  8  .  .  .\n  7  .  .  .  .  .  .  .  .\n  .  2  .  1  .  9  .  .  .\n  .  .  7  .  .  .  2  4  .\n  .  6  4  .  1  .  5  9  .\n  .  9  8  .  .  .  3  .  .\n  .  .  .  8  .  3  .  2  .\n  .  .  .  .  .  .  .  .  6\n  .  .  .  2  7  5  9  .  .\n============\n  5  1  9  7  4  8  6  3  2\n  7  8  3  6  5  2  4  1  9\n  4  2  6  1  3  9  8  7  5\n  3  5  7  9  8  6  2  4  1\n  2  6  4  3  1  7  5  9  8\n  1  9  8  5  2  4  3  6  7\n  9  7  5  8  6  3  1  2  4\n  8  3  2  4  9  1  7  5  6\n  6  4  1  2  7  5  9  8  3\n============\n```"
                    },
                    {
                        "username": "zzzppp",
                        "content": "boardColSizes  = 9\\uFF0C it is not a valid addr"
                    }
                ]
            },
            {
                "id": 1956259,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 1720949,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 1911070,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 1631324,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 1571825,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 1571091,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 1571092,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 2070550,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 2046149,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 2039064,
                "content": [
                    {
                        "username": "2030019",
                        "content": "Is it really possible to solve this question by own with just a past knowledge about recursion and backtracking?"
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Please stop requiring me to use jagged arrays, 2d arrays were literally made for this and they\\'d be much simpler to deal with in this case"
                    },
                    {
                        "username": "IAmTea",
                        "content": "Basically this requires Wave Function Collapse which is a quite complicated algorithm created for procedure generation of in-game worlds and based on sudoku solution."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Here a example\\nhttps://github.com/Zed-Bailey/SudokuSolver"
                    },
                    {
                        "username": "kickiniteasy",
                        "content": "This would Run fine for me but not Submit and would get stuck on one particular board even when I was submitting a correct answer for that board. After 1hr of debugging I finally put the board state they supplied in to an online Sudoku generator... IT HAS MULTIPLE SOLUTIONS.\\n\\nMy solution is also correct. The cake is a lie."
                    },
                    {
                        "username": "n2xiong",
                        "content": "I suggest relax the restriction and let the submitted program to judge if there is no solution or multiple solutions."
                    },
                    {
                        "username": "AlexTheGreat",
                        "content": "Seems there is always only 1 solution, but just to double check..."
                    },
                    {
                        "username": "ggorantl",
                        "content": "Can any one share there Code here for this question?"
                    },
                    {
                        "username": "aditya13451",
                        "content": "Can someone please help me, in my code the grid is not showing changes even i have passed it by reference.\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool canPlaceDigit(vector<vector<char>>& grid, int n, int i, int j, int d){\\n        // checks if we can place digit \\'d\\' in the (i,j)th cell of the grid[][]\\n        for(int k=0; k<n; k++){\\n            if(grid[i][k] == d+\\'0\\' || grid[k][j] == d+\\'0\\'){     // row or column\\n                return false;\\n            }\\n        }\\n\\n        // check if digit \\'d\\' is in the same subgrid of (i, j)th cell\\n        int rn = sqrt(n);\\n\\n        int sx = i/rn * rn;\\n        int sy = j/rn * rn;\\n\\n        // OR\\n\\n        // int sx = i - i%rn;\\n        // int sy = j - j%rn;\\n\\n        for(int x=sx; x<(sx+rn); x++){\\n            for(int y=sy; y < (sy + rn); y++){\\n                if(grid[x][y] == d+\\'0\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    void helper(vector<vector<char>>& grid, int n, int i, int j){\\n        // base case\\n        if(i == n){\\n            // // all empty cells have been assigned valid digits\\n            // for (int i = 0; i < n; i++) {\\n            //     for (int j = 0; j < n; j++) {\\n            //         cout << grid[i][j] << \" \";\\n            //     }\\n            //     cout << endl;\\n            // }\\n            // cout << endl;\\n            return;\\n        }\\n\\n\\n        // recursive case\\n\\n        if(j == n){\\n            // digits have been assigned to all the cells in the ith row -\\n            // move to the next row, and start filling from its 0th cell\\n            helper(grid, n, i + 1, 0);\\n            return;\\n        }\\n\\n        if(grid[i][j] != \\'.\\'){\\n            // (i, j)th cell is already assigned a digit -\\n            // move to the next cell at the (i, j+1)th idx\\n            helper(grid, n, i, j + 1);\\n            return;\\n        }\\n\\n        // assign a valid digit \\'d\\' to the (i, j)th cell where 1<=d<=9\\n        for(int d=1; d<=9; d++){\\n            if(canPlaceDigit(grid, n, i, j, d)){\\n                char digit = d + \\'0\\';\\n                grid[i][j] = digit;\\n                helper(grid, n, i, j + 1);\\n                grid[i][j] = \\'.\\'; // backtracking\\n            }\\n        }\\n\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        helper(board, 9, 0, 0);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "wakai-megumi",
                        "content": "why this code fsails any explanation\n\n\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        \n        // \n         solve_sudoku(board ,  0 , 0);\n          return ;\n\n         \n    }\nprivate boolean is_valid(char[][]board , int value , int row , int column){\n    //   in horizontaa and vertical direction\n       for( int i = 0 ; i < 9 ; i++){\n           char ro = board[row][i];\n           char co = board[i][column];\n          if( ro == (char) (value  + '0') || co == (char) (value + '0') ) return false ;\n       }\n  // now check inn the corresponding small box\n          int ro_index = row / 3 ;\n          int co_index = column / 3 ;\n          for( int i =  ro_index  ; i <  ro_index + 3 ; i ++){\n              for ( int j  = co_index ; j < co_index +3 ; j++){\n               char ele = board[i][j];\n                if( ele == (char) (value + '0') ) return false ;     \n              }\n          }\n\n          return true ;\n      \n}\n\n\n\n\n    private boolean solve_sudoku(char[][]board , int row , int column){\n// base case\n   if(row == 8 && column ==9   ) return true;\n \n\n        for( int r  = row ; r < 9  ;r++){       /// loop to iterate the row\n           for (int c = column ; c < 9 ; c++){\n                    // column iteration\n                char curr = board [r][c];\n                if(curr == '.'){               // if the element is empty then only we do something\n                for( int val = 1 ; val<10 ; val++){\n                    if(is_valid( board ,val , r , c)){     // if this value can be taken then we do something here\n                           // add in the board\n                           board[r][c]  = (char) (val + '0') ;\n                           if(!solve_sudoku(board , r , c +1)){\n                             board[r][c] = '.';\n                           }else{\n                               return true ;\n                           }\n\n                    }\n                }\n                return false ;\n\n                }\n \n           }\n           column = 0;\n           \n             \n        }\n          if(row > 8 ) return true;\n      \n        return false ;\n    }\n\n\n\n\n}\n\nwhy my code not working can anyone explain to me\n"
                    },
                    {
                        "username": "Genius_2023",
                        "content": "Why here using in grid by chars. If board is accepted numbers, then there is may be solving problem easy."
                    }
                ]
            },
            {
                "id": 1979049,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1952066,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1949684,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1948942,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1942037,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1932849,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1915665,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1915600,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1911976,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850512,
                "content": [
                    {
                        "username": "Lucky_Coder2002",
                        "content": "I think test cases are wrong....."
                    },
                    {
                        "username": "smitbhatt138",
                        "content": "Why is it giving TLE if i use count variable to check if if contains any empty cells ? I am returning from function if that count variable reaches zero.\n\nEven when it is already given in statement that it will have exact solution for any input."
                    },
                    {
                        "username": "jonasmock",
                        "content": "6/7 tests passed using Backtracking. Answer for test 7 is correct but time limit exceeded :( \\n\\n`from typing import List\\n\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n\\n        result = []\\n        self.fixed_numbers = []\\n        self.solved = False\\n\\n        # Fixed numbers in board\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \".\":\\n                    self.fixed_numbers.append((i,j))\\n\\n        def backtrack(i: int, j: int, board: List[List[str]]):\\n\\n            if self.solved:\\n                return\\n            else:\\n                #print(\"Current index: \", i, j, \"Orginal board: \", original_board[i][j], \"Current board: \", board[i][j])\\n                \\n\\n                if (i,j) in self.fixed_numbers:\\n\\n                    if j == 8 and i < 8:\\n                        #print(\"Skip to next row\")\\n                        backtrack(i+1, 0, board)\\n                    elif j < 8 and i <= 8:\\n                        #print(\"Skip to next column\")\\n                        backtrack(i, j+1, board)\\n                    elif j == 8 and i == 8:\\n                        #print(\"Solution found\")\\n                        self.solved = True\\n                        result.append(board)\\n                \\n                else:\\n\\n                    row = board[i]\\n                    col = [ board[idx][j] for idx in range(9)]\\n                    field = self.getFieldAsList(i, j, board)\\n\\n                    for candidate in range(1, 10):\\n\\n                        if self.isRowCandidate(str(candidate), row) and self.isColumnCandidate(str(candidate), col) and self.isFieldCandidate(str(candidate), field):\\n\\n                            if not self.solved:\\n\\n                                #print(\"Candidate found: \", candidate, \" at \", i, j)\\n                                #print(row)\\n                                #print(col)\\n                                #print(field)\\n\\n                                board[i][j] = str(candidate)\\n\\n                                #print(board)\\n\\n\\n                                if j == 8 and i < 8 :\\n                                    #print(\"Forward to next row\")\\n                                    backtrack(i+1, 0, board)\\n                                elif j < 8 and i <= 8:\\n                                    #print(\"Forward to next column\")\\n                                    backtrack(i, j+1, board)\\n                                elif j == 8 and i == 8:\\n                                    #print(\"Solution found\")\\n                                    self.solved = True\\n                                    result.append(board)\\n                    \\n                    # Backtrack tp previous field\\n                    if not self.solved:\\n                        board[i][j] = \".\"\\n                        return\\n\\n\\n        \\n        backtrack(0,0,board)\\n\\n        return result\\n\\n\\n\\n    def isRowCandidate(self, candidate: int, row: list) -> bool:\\n        return not candidate in row\\n\\n    def isColumnCandidate(self, candidate: int, col: list) -> bool:\\n        return not candidate in col\\n    \\n    def isFieldCandidate(self, candidate: int, field: List[List[str]]) -> bool:\\n        return not candidate in field\\n\\n    def getFieldAsList(self, i, j, board):\\n\\n        field = []\\n        corner = i - i % 3, j - j % 3\\n        \\n        for x in range(corner[0], corner[0] + 3):\\n            for y in range(corner[1], corner[1] + 3):\\n                field.append(board[x][y])\\n        \\n        return field\\n`"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I can\\'t understand why I am still getting TLE, I used backtracking, even tried to optimize the code, but still I am getting TLE.\\nI looked at others submission, and tried to run them on the same test case, which again gives me TLE. I can\\'t understand how they got their code submitted. \\nCan anyone help me with it?"
                    },
                    {
                        "username": "parzam77",
                        "content": "Does anybody know the reason?, I'm returning one of the possible solution, but even it's failing why ? why?\nHere is the output for given example problem.\n\n[[\"5\",\"3\",\"2\",\"6\",\"7\",\"4\",\"9\",\"1\",\"8\"],\n[\"6\",\"7\",\"3\",\"1\",\"9\",\"5\",\"8\",\"4\",\"2\"],\n[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],\n[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],\n[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],\n[\"7\",\"1\",\"4\",\"9\",\"2\",\"8\",\"3\",\"5\",\"6\"],\n[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],\n[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],\n[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Your solution contains two 3\\'s in the first sub-box"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "Can i use Bruce force method to solve this problem???\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "adriankwokace",
                        "content": "[Solved - using deep copy]\nI know i need to save the solution in the \"board\" variable. However, during runtime, the ID of board is changed thus the checker is not reading my \"board\". If I need to have the ID remain unchanged, this involve changing my whole algorithm. Any suggestions?\n\nfor example:\nBefore:\nID of board: 140475198989760\nAfter\nID of board: 140475194412672\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "Is it possible to solve the problem by using the recursive call as a void type and not a bool type(in c++) ? PS I am not talking about the validSudoku but the solver. `your inline code...your inline code..."
                    },
                    {
                        "username": "vitaliypidlypnyi",
                        "content": "How should I post a c# solution?\\nI\\'m facing the same issue each time when I try to solve a task which requires input parameter modification using c#.\\nAfter running, it just shows the original input, not modified one. Regardless what I do with input parameter in my code.\\n\\nF.E. even if I directly set all board values to \\'.\\', it still shows the original board as output of my solution\\n\\nvar rect = new char[board.Length][];\\nfor (int i = 0; i < board.Length; i++)\\n{\\n\\trect[i] = Enumerable.Range(0, 9).Select(c => \\'.\\').ToArray();\\n}\\n\\nboard = rect;\\n\\n\\nOutput\\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\\n\\n\\nCan anybody suggest how to correctly solve this issue?"
                    },
                    {
                        "username": "dreamville_dsa",
                        "content": "WHY AM I GETTIN A RUNTIME ERROR IN THE FOLLOWING CODE:\\n\\n class Solution {\\npublic:\\n\\n    bool isSafe(vector < vector < char >> & grid, int row, int col, char val) {\\n        for(int j=0; j<9; j++){\\n            if(grid[j][col]==val || grid[row][j]==val) return false;\\n        }\\n\\n        int rs = row - row%3;\\n        int cs = col - col%3;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i+rs][j+cs]==val) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool solve(vector<vector<char>> &grid){\\n        int i,j;\\n        for(i=0; i<9; i++){\\n            for(j=0; j<9; j++){\\n                if(grid[i][j]==\\'.\\'){    \\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(i==9 && j==9) return true;\\n\\n        for(char k=\\'1\\'; k<=\\'9\\'; k++){\\n            if(isSafe(grid, i, j, k)){\\n                grid[i][j] = k;\\n                if(solve(grid) == true) return true;\\n                grid[i][j] = \\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n        return ;   \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1816353,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            },
            {
                "id": 1789595,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            },
            {
                "id": 1785850,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            },
            {
                "id": 1779259,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            },
            {
                "id": 1755735,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            },
            {
                "id": 1752611,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            },
            {
                "id": 1732719,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            },
            {
                "id": 1725021,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            },
            {
                "id": 1705551,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            },
            {
                "id": 1680395,
                "content": [
                    {
                        "username": "saransh_1024",
                        "content": " `class Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<char>> &board, int row, int col, char c)\\n    {\\n        for (int i = 0; i < 9; i++)\\n        {\\n            if (board[i][col] == c)\\n                return false;\\n\\n            if (board[row][i] == c)\\n                return false;\\n\\n            if (board[3 * (row / 3) + i / 3][3 * (row / 3) + i % 3] == c)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // tere naam, humne kiya hai...\\n    bool solve(vector<vector<char>> &board)\\n    {\\n        for (int i = 0; i < board.size(); i++)\\n        {\\n            for (int j = 0; j < board[0].size(); j++)\\n            {\\n                if (board[i][j] == \\'.\\')\\n                {\\n                    for (char c = \\'1\\'; c <= \\'9\\'; c++)\\n                    {\\n                        if (isValid(board, i, j, c))\\n                        {\\n                            board[i][j] = c;\\n\\n                            if (solve(board) == true)\\n                                return true;\\n                            else\\n                                board[i][j] = \\'.\\';\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>> &board)\\n    {\\n        solve(board);\\n    }\\n};`\\n\\nwhy is my solution not working, the logic is fine , still showing wrong answer."
                    },
                    {
                        "username": "aman_hacks",
                        "content": "What's wrong in my code?\nWhy it's giving me wrong answer? \n\n`\n    \n    int gridNo(int i, int j)\n    {\n        return (3 * (i/3) + j/3);\n    }\n    vector<vector<int>> row(9, vector<int>(9, 0));\n    vector<vector<int>> col(9, vector<int>(9, 0));\n    vector<vector<int>> grid(9, vector<int>(9, 0)); // Divided into NINE 3*3 grids\n\n    bool solve(int i, int j,vector<vector<char>> &board)\n    {\n        if(i>=9) return true;\n        \n        if(j>=9) return solve(i+1, 0, board);\n        if(board[i][j]!='.') return solve(i, j+1, board);\n\n        for(int num = 1; num <= 9; num++)\n        {\n            int number = num-1;\n            if(row[i][number]==0 && col[j][number]==0 && grid[gridNo(i, j)][number]==0)\n            {\n                row[i][number] = 1;\n                col[j][number] = 1;\n                grid[gridNo(i, j)][number] = 1;\n                board[i][j] = num + '0';\n                \n                if(solve(i, j+1, board)==true) return true;\n                row[i][number] = 0;\n                col[j][number] = 0;\n                grid[gridNo(i, j)][number] = 0;\n                board[i][j] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        \n        for(int i=0; i<9; i++)\n        {\n            for(int j=0; j<9; j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    int number = board[i][j] - '1';\n                    row[i][number] = 1;\n                    col[j][number] = 1;\n                    grid[gridNo(i, j)][number] = 1;\n                }\n            }\n        }\n        solve(0, 0, board);\n    }\n`"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Any Suggestion Which approach we use to solve this?"
                    },
                    {
                        "username": "OmGori",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x000000346063 bp 0x7ffd53f3ec90 sp 0x7ffd53f3ec40 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #7 0x7f957a73d0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\n\\n\\nI am getting these deadly signal runtime error , Please assist me to solve this error ...."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": " for i in range(0,9):\\n        for j in range(0,9):\\n            if((i>=0 and i<3) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(0,3)]\\n            elif((i>=0 and i<3) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(0,3)]\\n            elif((i>=3 and i<6) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(3,6)]\\n            elif((i>=3 and i<6) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(3,6)]\\n            elif((i>=6 and i<9) and (j>=0 and j<3)):\\n                c=[board[k][0:3] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=3 and j<6)):\\n                c=[board[k][3:6] for k in range(6,9)]\\n            elif((i>=6 and i<9) and (j>=6 and j<9)):\\n                c=[board[k][6:9] for k in range(6,9)]\\n            flag=False;\\n            print(c)\\n                \\n            if(board[i][j]==\".\"):\\n                a=board[i:i+1]\\n                b=[]\\n                for i1 in range(9):\\n                    b.append(board[i1][j])\\n                d=[]\\n                for m in range(3):\\n                    for n in range(3):\\n                        d.append(c[m][n])\\n                for l in range(1,10):\\n                    if(str(l) not in b):\\n                        if(str(l) not in a):\\n                            if(str(l) not in d):\\n                                board[i][j]=str(l)\\n                                break\\n    return board\\n\\n\\n\\n\\ni don\\'t know what the problem is with this code."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "champ9X",
                        "content": "You can verify which numbers can be filled in a cell (Valid Sudoku) then solve the board according to each possible number and see whether it results in a complete solution or not..."
                    },
                    {
                        "username": "shlokm2",
                        "content": "Hello,\\nI\\'ve been trying to solve this problem through simple backtracking where I store all spots that have not been filled in a queue (`empty`). For each empty spot, I then try all values from 1 to 10, call the recursive method to see if that value is a valid solution and write a base case where it simply checks if the board is full by checking if the queue is empty.\\n\\nI can\\'t figure out what\\'s going wrong. If i print the board out in the backtracking method it seems to start to fill the board but it just stops in the middle for some reason.\\n\\n```python\\nclass Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        empty = []\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \".\"):\\n                    empty.append((i, j))\\n        \\n        def addToBoard(board, i, j, value):\\n            if value in board[i]:\\n                return False\\n            if value in [row[j] for row in board]:\\n                return False\\n            square_x = i // 3\\n            square_y = j // 3\\n            for a in range(3):\\n                for b in range(3):\\n                    if board[square_x + a][square_y + b] == value:\\n                        return False\\n            return True\\n        def backtrack(empty, board):\\n            #base case\\n            print(board)\\n            if len(empty) == 0:\\n                print(\"this has to print\")\\n                return True\\n            #at least one element in empty\\n            i, j = empty[0]\\n            board_works = False\\n            #try all values in element\\n            for chances in range(1, 10):\\n                if addToBoard(board, i, j, str(chances)):\\n                    board[i][j] = str(chances)\\n                    if backtrack(empty[1:], board):\\n                        return True\\n                    else:\\n                        board[i][j] = \".\"\\n            if not board_works:\\n                return False\\n        backtrack(empty, board)\\n```"
                    },
                    {
                        "username": "dmxart13",
                        "content": "My code works in VS and here in Stdout the answer is correct but it says \"Wrong Answer\".  In Output shows an intermediate value. Why?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I kind of hate that backtracking is the answer here. Its basically \"dont use any kind of logic, just have the computer guess until its right\". I wanted to write a LOGICAL solver, and figured LC would provide pretty easy sudoku games as test cases.\\n\\nCurrently my solver has 3 levels of logic:\\nStart: Store all possible digits as a 9-bit \\'flag array\\' number, per cell  \\n1: When a cell is \\'solved\\' (including the given cells at the start), remove it as a possibility for the  other cells in its row, col, and box. Any new cells that are down to only one possibility get added to the \\'solved\\' list and continue to be processed in \"level 1 logic\".\\n2: Ok... not good enough. Fine. For all remaining, unsolved cells, compare them with the other cells in its row, col, box. If the cell in question is the only in a grouping (row, col, box) for a given digit, it must be that digit. Add it to \"solved\" cells for further processing back at level 1\\n3: Wow really? They just put in arbitrarily hard sudoku puzzles that require advanced techniques for humans to solve them. OK, I know one other technique... If there are N cells in a group (row, col, box) that have N identical possibilities, then those possibilities are bound to that group of N cells, the other unsolved cells in the group cannot be one of those N possibilities.  Easiest in pairs: if two cells in a row both have ONLY (\\'1\\',\\'2\\') as possibilities, one cell must be the \\'1\\' and the other the \\'2\\'. We can thus eliminate these N possibilities from each of the other cells in the grouping under consideration. This may solve some cells and we can go back to level 1.\\n4: Wow... I as a human could not solve this sudoku without resorting to guess and check at this point. I know there are very advanced techniques that are algorithmic I could continue to add but I dont know them. \\n\\nI suppose the answer is \"Just use backtracking to let the computer guess and check its way through from the start\" but frankly its pretty unsatisfying. The lesson being, I guess, is the best way for a computer to solve it might be wholly different than how a human would. "
                    }
                ]
            }
        ]
    }
]